{"version":3,"sources":["editor/MultiRangeInlineEditor.js"],"names":["define","require","exports","module","_","TextRange","InlineTextEditor","EditorManager","FileUtils","PreferencesManager","ProjectManager","Commands","Strings","CommandManager","_prevMatchCmd","_nextMatchCmd","_parseStyleSize","$target","styleName","parseInt","css","SearchResultItem","rangeResult","this","name","textRange","document","lineStart","lineEnd","_updateRangeLabel","listItem","range","labelCB","text","escape","startLine","html","attr","MultiRangeInlineEditor","ranges","messageCB","fileComparator","call","_ranges","map","_messageCB","_labelCB","_selectedRangeIndex","_collapsedFiles","_fileComparator","defaultComparator","file1","file2","comparePaths","fullPath","sort","result1","result2","file","bind","getFocusedMultiRangeInlineEditor","focusedWidget","getFocusedInlineWidget","_previousRange","focusedMultiRangeInlineEditor","_selectPreviousRange","_nextRange","_selectNextRange","prototype","$listItem","Object","create","constructor","parentClass","$messageDiv","$relatedContainer","$related","$selectedMarker","$rangeList","_$headers","_createListItem","self","$rangeItem","$","data","appendTo","mousedown","setSelectedIndex","indexOf","_toggleSection","duringInit","$headerItem","$disclosureIcon","find","isCollapsing","hasClass","toggleClass","nextUntil","toggle","setting","getViewState","STATE_PROJECT_CONTEXT","setViewState","_updateSelectedMarker","_ruleListHeightChanged","index","findIndex","resultItem","_createHeaderItem","doc","makeProjectRelativeIfPossible","click","_renderList","empty","lastSectionDoc","numItemsInSection","finalizeSection","append","forEach","load","hostEditor","apply","arguments","addClass","$editorHolder","on","e","stopPropagation","toCollapse","keys","length","$wrapper","before","_removeRange","indexToSelect","clickHandler","_onClick","$htmlContent","_updateCommands","enabled","hasFocus","setEnabled","onAdded","force","newIndex","Math","min","max","$previousItem","removeClass","editor","off","setInlineContent","hasHiddenMatches","INLINE_EDITOR_HIDDEN_MATCHES","done","msg","INLINE_EDITOR_NO_MATCHES","sizeInlineWidgetToContents","remove","_getSelectedRange","endLine","focus","_updateEditorMinHeight","refresh","_ensureCursorVisible","ruleListNaturalHeight","outerHeight","headerHeight","getScrollerElement","close","dispose","splice","addAndSelectRange","newRange","i","parent","animate","hide","containerHeight","height","itemTop","position","top","scrollTop","show","paddingTop","itemBottom","onClosed","searchResult","event","childEditor","editorRoot","getRootElement","editorPos","offset","containsClick","pageY","setCursorPos","lastLine","getLastVisibleLine","getLine","$parent","target","contains","window","activeElement","hostScrollPos","getScrollPos","cursorCoords","_codeMirror","scrollerTop","getVirtualScrollAreaTop","scrollIntoView","left","x","right","bottom","_onLostContent","cause","type","_getRanges","_selectNextPrev","dir","origDoc","widgetHeight","$header","setInlineWidgetHeight","onParentShown","register","CMD_QUICK_EDIT_PREV_MATCH","QUICK_EDIT_PREV_MATCH","CMD_QUICK_EDIT_NEXT_MATCH","QUICK_EDIT_NEXT_MATCH"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// FUTURE: Merge part (or all) of this class with InlineTextEditor\n\n/**\n * An inline editor for displaying and editing multiple text ranges. Each range corresponds to a\n * contiguous set of lines in a file.\n *\n * In the current implementation, only one range is visible at a time. A list on the right side\n * of the editor allows the user to select which range is visible.\n *\n * This module does not dispatch any events.\n */\ndefine(function (require, exports, module) {\n\n\n    var _ = require(\"thirdparty/lodash\");\n\n    // Load dependent modules\n    var TextRange           = require(\"document/TextRange\").TextRange,\n        InlineTextEditor    = require(\"editor/InlineTextEditor\").InlineTextEditor,\n        EditorManager       = require(\"editor/EditorManager\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        ProjectManager      = require(\"project/ProjectManager\"),\n        Commands            = require(\"command/Commands\"),\n        Strings             = require(\"strings\"),\n        CommandManager      = require(\"command/CommandManager\");\n\n    var _prevMatchCmd, _nextMatchCmd;\n\n    /**\n     * Remove trailing \"px\" from a style size value.\n     * @param {!JQuery} $target Element in DOM\n     * @param {!string} styleName Style name to query\n     * @return {number} Style value converted from string to number, removing \"px\" units\n     */\n    function _parseStyleSize($target, styleName) {\n        return parseInt($target.css(styleName), 10);\n    }\n\n\n    /**\n     * Stores one search result: its source file, line range, etc. plus the DOM node representing it\n     * in the results list.\n     * @constructor\n     */\n    function SearchResultItem(rangeResult) {\n        this.name = rangeResult.name;\n        this.textRange = new TextRange(rangeResult.document, rangeResult.lineStart, rangeResult.lineEnd);\n        // this.$listItem is assigned in load()\n    }\n    SearchResultItem.prototype.name = null;\n    SearchResultItem.prototype.textRange = null;\n    SearchResultItem.prototype.$listItem = null;\n\n    function _updateRangeLabel(listItem, range, labelCB) {\n        if (labelCB) {\n            range.name = labelCB(range.textRange);\n        }\n        var text = _.escape(range.name) + \" <span class='related-file'>:\" + (range.textRange.startLine + 1) + \"</span>\";\n        listItem.html(text);\n        listItem.attr(\"title\", listItem.text());\n    }\n\n\n    /**\n     * @constructor\n     * @param {Array.<{name:String,document:Document,lineStart:number,lineEnd:number}>} ranges The text\n     *      ranges to display. Results within the same file are expected to be contiguous in this array.\n     * @param {?function(): $.Promise} messageCB Optional; returns a promise resolved with a message to\n     *      show when no matches are available. The message should be already-escaped HTML.\n     * @param {?function(range): string} labelCB Optional; returns an updated label string for the given\n     *      range. Called when we detect that the content of a range has changed. The label is plain\n     *      text, not HTML.\n     * @param {?function(!File, !File):number} fileComparator Optional comparison function for sorting\n     *      the results list (based on range.document.file). Defaults to FileUtils.comparePaths().\n     * @extends {InlineTextEditor}\n     */\n    function MultiRangeInlineEditor(ranges, messageCB, labelCB, fileComparator) {\n        InlineTextEditor.call(this);\n\n        // Store the results to show in the range list. This creates TextRanges bound to the Document,\n        // which will stay up to date automatically (but we must be sure to detach them later)\n        this._ranges = ranges.map(function (rangeResult) {\n            return new SearchResultItem(rangeResult);\n        });\n        this._messageCB = messageCB;\n        this._labelCB = labelCB;\n\n        this._selectedRangeIndex = -1;\n        this._collapsedFiles = {};\n\n        // Set up list sort order\n        this._fileComparator = fileComparator || function defaultComparator(file1, file2) {\n            return FileUtils.comparePaths(file1.fullPath, file2.fullPath);\n        };\n        this._ranges.sort(function (result1, result2) {\n            return this._fileComparator(result1.textRange.document.file, result2.textRange.document.file);\n        }.bind(this));\n    }\n    MultiRangeInlineEditor.prototype = Object.create(InlineTextEditor.prototype);\n    MultiRangeInlineEditor.prototype.constructor = MultiRangeInlineEditor;\n    MultiRangeInlineEditor.prototype.parentClass = InlineTextEditor.prototype;\n\n    MultiRangeInlineEditor.prototype.$messageDiv = null;\n    MultiRangeInlineEditor.prototype.$relatedContainer = null;\n    MultiRangeInlineEditor.prototype.$related = null;\n    MultiRangeInlineEditor.prototype.$selectedMarker = null;\n\n    /** Includes all the _ranges[i].$listItem items, as well as section headers */\n    MultiRangeInlineEditor.prototype.$rangeList = null;\n\n    /**\n     * List of search results. Section headers are not represented in this list (they are implied before each group of\n     * of consecutive results from the same Document).\n     * @type {!Array.<SearchResultItem>}\n     */\n    MultiRangeInlineEditor.prototype._ranges = null;\n\n    /** Index into this._ranges - indices do not include section headers */\n    MultiRangeInlineEditor.prototype._selectedRangeIndex = null;\n\n    /**\n     * Map from fullPath to true if collapsed. May not agree with preferences, in cases where multiple inline editors make\n     * concurrent changes.\n     * @type {!Object.<string, boolean>}\n     */\n    MultiRangeInlineEditor.prototype._collapsedFiles = null;\n\n    MultiRangeInlineEditor.prototype._messageCB = null;\n    MultiRangeInlineEditor.prototype._labelCB = null;\n    MultiRangeInlineEditor.prototype._fileComparator = null;\n\n    /** @type {!Object.<string, jQueryObject>} Map from fullPath to section header DOM node */\n    MultiRangeInlineEditor.prototype._$headers = null;\n\n\n    /**\n     * @private\n     * Add a new result item <li> to the range list UI ($rangeList) and saves it in range.$listItem\n     * @param {SearchResultItem} range The range to add.\n     */\n    MultiRangeInlineEditor.prototype._createListItem = function (range) {\n        var self = this,\n            $rangeItem = $(\"<li/>\");\n\n        // Attach filename for unit test use\n        $rangeItem.data(\"filename\", range.textRange.document.file.name);\n\n        $rangeItem.appendTo(this.$rangeList);\n\n        _updateRangeLabel($rangeItem, range);\n        $rangeItem.mousedown(function () {\n            self.setSelectedIndex(self._ranges.indexOf(range));\n        });\n\n        range.$listItem = $rangeItem;\n    };\n\n    /** Collapses/expands a file section in the range list UI */\n    MultiRangeInlineEditor.prototype._toggleSection = function (fullPath, duringInit) {\n        var $headerItem = this._$headers[fullPath];\n        var $disclosureIcon = $headerItem.find(\".disclosure-triangle\");\n        var isCollapsing = $disclosureIcon.hasClass(\"expanded\");\n        $disclosureIcon.toggleClass(\"expanded\");\n        $headerItem.nextUntil(\".section-header\").toggle(!isCollapsing);  // explicit visibility arg, since during load() jQ doesn't think nodes are visible\n\n        // Update instance-specific state...\n        this._collapsedFiles[fullPath] = isCollapsing;\n        // ...AND persist as per-project view state\n        if (!duringInit) {\n            var setting = PreferencesManager.getViewState(\"inlineEditor.collapsedFiles\", PreferencesManager.STATE_PROJECT_CONTEXT) || {};\n            if (isCollapsing) {\n                setting[fullPath] = true;\n            } else {\n                delete setting[fullPath];\n            }\n            PreferencesManager.setViewState(\"inlineEditor.collapsedFiles\", setting, PreferencesManager.STATE_PROJECT_CONTEXT);\n        }\n\n        // Show/hide selection indicator if selection was in collapsed section\n        this._updateSelectedMarker(false);\n\n        // Changing height of rule list may change ht of overall editor\n        this._ruleListHeightChanged();\n\n        // If user expands collapsed section and nothing selected yet, select first result in this section\n        if (this._selectedRangeIndex === -1 && !isCollapsing && !duringInit) {\n            var index = _.findIndex(this._ranges, function (resultItem) {\n                return resultItem.textRange.document.file.fullPath === fullPath;\n            });\n            this.setSelectedIndex(index);\n        }\n    };\n\n    /** Adds a file section header <li> to the range list UI ($rangeList) and adds it to the this._$headers map */\n    MultiRangeInlineEditor.prototype._createHeaderItem = function (doc) {\n        var $headerItem = $(\"<li class='section-header'><span class='disclosure-triangle expanded'/><span class='filename'>\" + _.escape(doc.file.name) + \"</span></li>\")\n            .attr(\"title\", ProjectManager.makeProjectRelativeIfPossible(doc.file.fullPath))\n            .appendTo(this.$rangeList);\n\n        $headerItem.click(function () {\n            this._toggleSection(doc.file.fullPath);\n        }.bind(this));\n\n        this._$headers[doc.file.fullPath] = $headerItem;\n    };\n\n    /** Refresh the contents of $rangeList */\n    MultiRangeInlineEditor.prototype._renderList = function () {\n        this.$rangeList.empty();\n        this._$headers = {};\n\n        var self = this,\n            lastSectionDoc,\n            numItemsInSection = 0;\n\n        // After seeing all results for a given file, update its header with total # of results\n        function finalizeSection() {\n            if (lastSectionDoc) {\n                self._$headers[lastSectionDoc.file.fullPath].append(\" (\" + numItemsInSection + \")\");\n                if (self._collapsedFiles[lastSectionDoc.file.fullPath]) {\n                    self._toggleSection(lastSectionDoc.file.fullPath, true);\n                }\n            }\n        }\n\n        this._ranges.forEach(function (resultItem) {\n            if (lastSectionDoc !== resultItem.textRange.document) {\n                // Finalize previous section\n                finalizeSection();\n\n                // Initialize new section\n                lastSectionDoc = resultItem.textRange.document;\n                numItemsInSection = 0;\n\n                // Create filename header for new section\n                this._createHeaderItem(lastSectionDoc);\n            }\n            numItemsInSection++;\n            this._createListItem(resultItem);\n        }, this);\n\n        // Finalize last section\n        finalizeSection();\n    };\n\n\n    /**\n     * @override\n     * @param {!Editor} hostEditor  Outer Editor instance that inline editor will sit within.\n     *\n     */\n    MultiRangeInlineEditor.prototype.load = function (hostEditor) {\n        MultiRangeInlineEditor.prototype.parentClass.load.apply(this, arguments);\n\n        // Create the message area\n        this.$messageDiv = $(\"<div/>\")\n            .addClass(\"inline-editor-message\");\n\n        // Prevent touch scroll events from bubbling up to the parent editor.\n        this.$editorHolder.on(\"mousewheel.MultiRangeInlineEditor\", function (e) {\n            e.stopPropagation();\n        });\n\n        // Outer container for border-left and scrolling\n        this.$relatedContainer = $(\"<div/>\").addClass(\"related-container\");\n\n        // List \"selection\" highlight\n        this.$selectedMarker = $(\"<div/>\").appendTo(this.$relatedContainer).addClass(\"selection\");\n\n        // Inner container\n        this.$related = $(\"<div/>\").appendTo(this.$relatedContainer).addClass(\"related\");\n\n        // Range list\n        this.$rangeList = $(\"<ul/>\").appendTo(this.$related);\n\n        // Determine which sections are initially collapsed (the actual collapsing happens after onAdded(),\n        // because jQuery.hide() requires the computed value of 'display' to work properly)\n        var toCollapse = PreferencesManager.getViewState(\"inlineEditor.collapsedFiles\", PreferencesManager.STATE_PROJECT_CONTEXT) || {};\n        Object.keys(toCollapse).forEach(function (fullPath) {\n            this._collapsedFiles[fullPath] = true;\n        }.bind(this));\n\n        // Render list & section headers (matching collapsed state set above)\n        this._renderList();\n\n        if (this._ranges.length > 1) {      // attach to main container\n            this.$wrapper.before(this.$relatedContainer);\n        }\n\n        // Add TextRange listeners to update UI as text changes\n        var self = this;\n        this._ranges.forEach(function (range, index) {\n            // Update list item as TextRange changes\n            range.textRange.on(\"change\", function () {\n                _updateRangeLabel(range.$listItem, range);\n            }).on(\"contentChange\", function () {\n                _updateRangeLabel(range.$listItem, range, self._labelCB);\n            });\n\n            // If TextRange lost sync, remove it from the list (and close the widget if no other ranges are left)\n            range.textRange.on(\"lostSync\", function () {\n                self._removeRange(range);\n            });\n        });\n\n        // Initial selection is the first non-collapsed result item\n        var indexToSelect = _.findIndex(this._ranges, function (range) {\n            return !this._collapsedFiles[range.textRange.document.file.fullPath];\n        }.bind(this));\n        if (this._ranges.length === 1 && indexToSelect === -1) {\n            // If no right-hand rule list shown, select the one result even if it's in a collapsed file (since no way to expand)\n            indexToSelect = 0;\n        }\n\n        if (indexToSelect !== -1) {\n            // select the first visible range\n            this.setSelectedIndex(indexToSelect);\n        } else {\n            // force the message div to show\n            this.setSelectedIndex(-1);\n        }\n\n        // Listen for clicks directly on us, so we can set focus back to the editor\n        var clickHandler = this._onClick.bind(this);\n        this.$htmlContent.on(\"click.MultiRangeInlineEditor\", clickHandler);\n        // Also handle mouseup in case the user drags a little bit\n        this.$htmlContent.on(\"mouseup.MultiRangeInlineEditor\", clickHandler);\n\n        // Update the rule list navigation menu items when we gain/lose focus.\n        this.$htmlContent\n            .on(\"focusin.MultiRangeInlineEditor\", this._updateCommands.bind(this))\n            .on(\"focusout.MultiRangeInlineEditor\", this._updateCommands.bind(this));\n    };\n\n    /**\n     * @private\n     * Updates the enablement for the rule list navigation commands.\n     */\n    MultiRangeInlineEditor.prototype._updateCommands = function () {\n        var enabled = (this.hasFocus() && this._ranges.length > 1);\n        _prevMatchCmd.setEnabled(enabled && this._selectedRangeIndex > 0);\n        _nextMatchCmd.setEnabled(enabled && this._selectedRangeIndex !== -1 && this._selectedRangeIndex < this._ranges.length - 1);\n    };\n\n    /**\n     * @override\n     */\n    MultiRangeInlineEditor.prototype.onAdded = function () {\n        // Set the initial position of the selected marker now that we're laid out.\n        this._updateSelectedMarker(false);\n\n        // Call super\n        MultiRangeInlineEditor.prototype.parentClass.onAdded.apply(this, arguments);\n\n        // Initially size the inline widget (calls sizeInlineWidgetToContents())\n        this._ruleListHeightChanged();\n\n        this._updateCommands();\n    };\n\n    /**\n     * Specify the range that is shown in the editor.\n     *\n     * @param {!number} index The index of the range to select, or -1 to deselect all. Index into this._ranges,\n     *      so section headers are not included in the sequence.\n     * @param {boolean} force Whether to re-select the item even if we think it's already selected\n     *     (used if the range list has changed).\n     */\n    MultiRangeInlineEditor.prototype.setSelectedIndex = function (index, force) {\n        var newIndex = Math.min(Math.max(-1, index), this._ranges.length - 1),\n            self = this;\n\n        if (!force && newIndex !== -1 && newIndex === this._selectedRangeIndex) {\n            return;\n        }\n\n        // Remove selected class(es)\n        var $previousItem = (this._selectedRangeIndex >= 0) ? this._ranges[this._selectedRangeIndex].$listItem : null;\n        if ($previousItem) {\n            $previousItem.removeClass(\"selected\");\n        }\n\n        // Clear our listeners on the previous editor since it'll be destroyed in setInlineContent().\n        if (this.editor) {\n            this.editor.off(\".MultiRangeInlineEditor\");\n        }\n\n        this._selectedRangeIndex = newIndex;\n\n        if (newIndex === -1) {\n            // show the message div\n            this.setInlineContent(null);\n            var hasHiddenMatches = this._ranges.length > 0;\n            if (hasHiddenMatches) {\n                this.$messageDiv.text(Strings.INLINE_EDITOR_HIDDEN_MATCHES);\n            } else if (this._messageCB) {\n                this._messageCB(hasHiddenMatches).done(function (msg) {\n                    self.$messageDiv.html(msg);\n                });\n            } else {\n                this.$messageDiv.text(Strings.INLINE_EDITOR_NO_MATCHES);\n            }\n            this.$htmlContent.append(this.$messageDiv);\n            this.sizeInlineWidgetToContents();\n        } else {\n            this.$messageDiv.remove();\n\n            var range = this._getSelectedRange();\n            range.$listItem.addClass(\"selected\");\n\n            // Add new editor\n            this.setInlineContent(range.textRange.document, range.textRange.startLine, range.textRange.endLine);\n            this.editor.focus();\n\n            this._updateEditorMinHeight();\n            this.editor.refresh();\n\n            // Ensure the cursor position is visible in the host editor as the user is arrowing around.\n            this.editor.on(\"cursorActivity.MultiRangeInlineEditor\", this._ensureCursorVisible.bind(this));\n\n            // ensureVisibility is set to false because we don't want to scroll the main editor when the user selects a view\n            this.sizeInlineWidgetToContents();\n\n            this._updateSelectedMarker(true);\n        }\n\n        this._updateCommands();\n    };\n\n    /**\n     * Ensures that the editor's min-height is set so it never gets shorter than the rule list.\n     * This is necessary to make sure the editor's horizontal scrollbar stays at the bottom of the\n     * widget.\n     */\n    MultiRangeInlineEditor.prototype._updateEditorMinHeight = function () {\n        if (!this.editor) {\n            return;\n        }\n\n        // Set the scroller's min-height to the natural height of the rule list, so the editor\n        // always stays at least as tall as the rule list.\n        var ruleListNaturalHeight = this.$related.outerHeight(),\n            headerHeight = $(\".inline-editor-header\", this.$htmlContent).outerHeight();\n\n        // If the widget isn't fully loaded yet, bail--we'll get called again in onAdded().\n        if (!ruleListNaturalHeight || !headerHeight) {\n            return;\n        }\n\n        // We have to set this on the scroller instead of the wrapper because:\n        // * we want the wrapper's actual height to remain \"auto\"\n        // * if we set a min-height on the wrapper, the scroller's height: 100% doesn't\n        //   respect it (height: 100% doesn't seem to work properly with min-height on the parent)\n        $(this.editor.getScrollerElement())\n            .css(\"min-height\", (ruleListNaturalHeight - headerHeight) + \"px\");\n    };\n\n    /** Update inline widget height to reflect changed rule-list height */\n    MultiRangeInlineEditor.prototype._ruleListHeightChanged = function () {\n        // Editor's min height depends on rule list height\n        this._updateEditorMinHeight();\n\n        // Overall widget height may have changed too\n        this.sizeInlineWidgetToContents();\n    };\n\n    MultiRangeInlineEditor.prototype._removeRange = function (range) {\n        // If this is the last range, just close the whole widget\n        if (this._ranges.length <= 1) {\n            this.close();\n            return;  // note: the dispose() that would normally happen below is covered by close()\n        }\n\n        // Now we know there is at least one other range -> found out which one this is\n        var index = this._ranges.indexOf(range);\n\n        // If the range to be removed is the selected one, first switch to another one\n        if (index === this._selectedRangeIndex) {\n            // If possible, select the one below, else select the one above\n            if (index + 1 < this._ranges.length) {\n                this.setSelectedIndex(index + 1);\n            } else {\n                this.setSelectedIndex(index - 1);\n            }\n        }\n\n        // Now we can remove this range\n        range.textRange.dispose();\n        this._ranges.splice(index, 1);\n\n        // Re-render list & section headers\n        this._renderList();\n\n        // Move selection highlight if deletion affected its position\n        if (index < this._selectedRangeIndex) {\n            this._selectedRangeIndex--;\n            this._updateSelectedMarker(true);\n        }\n\n        if (this._ranges.length === 1) {\n            this.$relatedContainer.remove();\n\n            // Refresh the height of the inline editor since we remove\n            // the entire selector list.\n            if (this.editor) {\n                this.editor.refresh();\n            }\n        }\n\n        this._updateCommands();\n    };\n\n    /**\n     * Adds a new range to the inline editor and selects it. The range will be inserted\n     * immediately below the last range for the same document, or at the end of the list\n     * if there are no other ranges for that document.\n     * @param {string} name The label for the new range.\n     * @param {Document} doc The document the range is in.\n     * @param {number} lineStart The starting line of the range, 0-based, inclusive.\n     * @param {number} lineEnd The ending line of the range, 0-based, inclusive.\n     */\n    MultiRangeInlineEditor.prototype.addAndSelectRange = function (name, doc, lineStart, lineEnd) {\n        var newRange = new SearchResultItem({\n                name: name,\n                document: doc,\n                lineStart: lineStart,\n                lineEnd: lineEnd\n            }),\n            i;\n\n        // Insert the new range after the last range from the same doc, or at the\n        // end of the list.\n        for (i = 0; i < this._ranges.length; i++) {\n            if (this._fileComparator(this._ranges[i].textRange.document.file, doc.file) > 0) {\n                break;\n            }\n        }\n        this._ranges.splice(i, 0, newRange);\n\n        // Update rule list display\n        this._renderList();\n\n        // Ensure rule list is visible if there are now multiple results\n        if (this._ranges.length > 1 && !this.$relatedContainer.parent().length) {\n            this.$wrapper.before(this.$relatedContainer);\n        }\n\n        // If added rule is in a collapsed item, expand it for clarity\n        if (this._collapsedFiles[doc.file.fullPath]) {\n            this._toggleSection(doc.file.fullPath);\n        }\n\n        // Select new range, showing it in the editor\n        this.setSelectedIndex(i, true);  // force, since i might be same as before\n\n        this._updateCommands();\n    };\n\n    MultiRangeInlineEditor.prototype._updateSelectedMarker = function (animate) {\n        // If no selection or selection is in a collapsed section, just hide the marker\n        if (this._selectedRangeIndex < 0 || this._collapsedFiles[this._getSelectedRange().textRange.document.file.fullPath]) {\n            this.$selectedMarker.hide();\n            return;\n        }\n\n        var $rangeItem = this._ranges[this._selectedRangeIndex].$listItem;\n\n        // scroll the selection to the rangeItem\n        var containerHeight = this.$relatedContainer.height(),\n            itemTop = $rangeItem.position().top,\n            scrollTop = this.$relatedContainer.scrollTop();\n\n        this.$selectedMarker\n            .show()\n            .toggleClass(\"animate\", animate)\n            .css(\"top\", itemTop)\n            .height($rangeItem.outerHeight());\n\n        if (containerHeight <= 0) {\n            return;\n        }\n\n        var paddingTop = _parseStyleSize($rangeItem.parent(), \"paddingTop\");\n\n        if ((itemTop - paddingTop) < scrollTop) {\n            this.$relatedContainer.scrollTop(itemTop - paddingTop);\n        } else {\n            var itemBottom = itemTop + $rangeItem.height() + _parseStyleSize($rangeItem.parent(), \"paddingBottom\");\n\n            if (itemBottom > (scrollTop + containerHeight)) {\n                this.$relatedContainer.scrollTop(itemBottom - containerHeight);\n            }\n        }\n    };\n\n    /**\n     * Called any time inline is closed, whether manually (via closeThisInline()) or automatically\n     */\n    MultiRangeInlineEditor.prototype.onClosed = function () {\n        // Superclass onClosed() destroys editor\n        MultiRangeInlineEditor.prototype.parentClass.onClosed.apply(this, arguments);\n\n        // de-ref all the Documents in the search results\n        this._ranges.forEach(function (searchResult) {\n            searchResult.textRange.dispose();\n        });\n\n        // Remove event handlers\n        this.$htmlContent.off(\".MultiRangeInlineEditor\");\n        this.$editorHolder.off(\".MultiRangeInlineEditor\");\n    };\n\n    /**\n     * Prevent clicks in the dead areas of the inlineWidget from changing the focus and insertion point in the editor.\n     * This is done by detecting clicks in the inlineWidget that are not inside the editor or the range list and\n     * restoring focus and the insertion point.\n     */\n    MultiRangeInlineEditor.prototype._onClick = function (event) {\n        if (!this.editor) {\n            return;\n        }\n\n        var childEditor = this.editor,\n            editorRoot = childEditor.getRootElement(),\n            editorPos = $(editorRoot).offset();\n\n        function containsClick($parent) {\n            return $parent.find(event.target).length > 0 || $parent[0] === event.target;\n        }\n\n        // Ignore clicks in editor and clicks on filename link\n        // Check clicks on filename link in the context of the current inline widget.\n        if (!containsClick($(editorRoot)) && !containsClick($(\".filename\", this.$htmlContent))) {\n            childEditor.focus();\n            // Only set the cursor if the click isn't in the range list.\n            if (!containsClick(this.$relatedContainer)) {\n                if (event.pageY < editorPos.top) {\n                    childEditor.setCursorPos(0, 0);\n                } else if (event.pageY > editorPos.top + $(editorRoot).height()) {\n                    var lastLine = childEditor.getLastVisibleLine();\n                    childEditor.setCursorPos(lastLine, childEditor.document.getLine(lastLine).length);\n                }\n            }\n        }\n    };\n\n    /**\n     * Based on the position of the cursor in the inline editor, determine whether we need to change the\n     * vertical scroll position of the host editor to ensure that the cursor is visible.\n     */\n    MultiRangeInlineEditor.prototype._ensureCursorVisible = function () {\n        if (!this.editor) {\n            return;\n        }\n\n        if ($.contains(this.editor.getRootElement(), window.document.activeElement)) {\n            var hostScrollPos = this.hostEditor.getScrollPos(),\n                cursorCoords = this.editor._codeMirror.cursorCoords();\n\n            // Vertically, we want to set the scroll position relative to the overall host editor, not\n            // the lineSpace of the widget itself. We don't want to modify the horizontal scroll position.\n            var scrollerTop = this.hostEditor.getVirtualScrollAreaTop();\n            this.hostEditor._codeMirror.scrollIntoView({\n                left: hostScrollPos.x,\n                top: cursorCoords.top - scrollerTop,\n                right: hostScrollPos.x,\n                bottom: cursorCoords.bottom - scrollerTop\n            });\n        }\n    };\n\n    /**\n     * Overwrite InlineTextEditor's _onLostContent to do nothing if the document's file is deleted\n     * (deletes are handled via TextRange's lostSync).\n     */\n    MultiRangeInlineEditor.prototype._onLostContent = function (event, cause) {\n        // Ignore when the editor's content got lost due to a deleted file\n        if (cause && cause.type === \"deleted\") { return; }\n        // Else yield to the parent's implementation\n        return MultiRangeInlineEditor.prototype.parentClass._onLostContent.apply(this, arguments);\n    };\n\n    /**\n     * @return {Array.<SearchResultItem>}\n     */\n    MultiRangeInlineEditor.prototype._getRanges = function () {\n        return this._ranges;\n    };\n\n    /**\n     * @return {!SearchResultItem}\n     */\n    MultiRangeInlineEditor.prototype._getSelectedRange = function () {\n        return this._selectedRangeIndex >= 0 ? this._ranges[this._selectedRangeIndex] : null;\n    };\n\n    /**\n     * Move the selection up or down, skipping any collapsed groups. If selection is currently IN a\n     * collapsed group, we expand it first so that other items in the same file are eligible.\n     */\n    MultiRangeInlineEditor.prototype._selectNextPrev = function (dir) {\n        if (this._selectedRangeIndex === -1) {\n            return;\n        }\n\n        // Traverse up or down the list until we find an item eligible for selection\n        var origDoc = this._ranges[this._selectedRangeIndex].textRange.document,\n            i;\n        for (i = this._selectedRangeIndex + dir; i >= 0 && i < this._ranges.length; i += dir) {\n            var doc = this._ranges[i].textRange.document;\n\n            // If first candidate is in same collapsed group as current selection, expand it\n            if (doc === origDoc && this._collapsedFiles[doc.file.fullPath]) {\n                this._toggleSection(doc.file.fullPath);\n            }\n\n            // Only consider expanded groups now\n            if (!this._collapsedFiles[doc.file.fullPath]) {\n                this.setSelectedIndex(i);\n                return;\n            }\n        }\n        // If we got here, we couldn't find any eligible item - so do nothing. Happens if selection is\n        // already the first/last item, or if all remaining items above/below the selection are collapsed.\n    };\n\n    /**\n     * Display the next range in the range list\n     */\n    MultiRangeInlineEditor.prototype._selectNextRange = function () {\n        this._selectNextPrev(1);\n    };\n\n    /**\n     *  Display the previous range in the range list\n     */\n    MultiRangeInlineEditor.prototype._selectPreviousRange = function () {\n        this._selectNextPrev(-1);\n    };\n\n    /**\n     * Sizes the inline widget height to be the maximum between the range list height and the editor height\n     * @override\n     */\n    MultiRangeInlineEditor.prototype.sizeInlineWidgetToContents = function () {\n        // Size the code mirror editors height to the editor content\n        MultiRangeInlineEditor.prototype.parentClass.sizeInlineWidgetToContents.call(this);\n\n        // Size the widget height to the max between the editor/message content and the related ranges list\n        var widgetHeight = Math.max(this.$related.height(),\n                                    this.$header.outerHeight() +\n                                        (this._selectedRangeIndex === -1 ? this.$messageDiv.outerHeight() : this.$editorHolder.height()));\n\n        if (widgetHeight) {\n            this.hostEditor.setInlineWidgetHeight(this, widgetHeight, false);\n        }\n    };\n\n    /**\n     * Called when the editor containing the inline is made visible. Updates UI based on\n     * state that might have changed while the editor was hidden.\n     */\n    MultiRangeInlineEditor.prototype.onParentShown = function () {\n        MultiRangeInlineEditor.prototype.parentClass.onParentShown.apply(this, arguments);\n        this._updateSelectedMarker(false);\n    };\n\n    /**\n     * Refreshes the height of the inline editor and all child editors.\n     * @override\n     */\n    MultiRangeInlineEditor.prototype.refresh = function () {\n        MultiRangeInlineEditor.prototype.parentClass.refresh.apply(this, arguments);\n        this.sizeInlineWidgetToContents();\n        if (this.editor) {\n            this.editor.refresh();\n        }\n    };\n\n    /**\n     * Returns the currently focused MultiRangeInlineEditor.\n     * @return {MultiRangeInlineEditor}\n     */\n    function getFocusedMultiRangeInlineEditor() {\n        var focusedWidget = EditorManager.getFocusedInlineWidget();\n        if (focusedWidget instanceof MultiRangeInlineEditor) {\n            return focusedWidget;\n        }\n        return null;\n\n    }\n\n    /**\n     * Previous Range command handler\n     */\n    function _previousRange() {\n        var focusedMultiRangeInlineEditor = getFocusedMultiRangeInlineEditor();\n        if (focusedMultiRangeInlineEditor) {\n            focusedMultiRangeInlineEditor._selectPreviousRange();\n        }\n    }\n\n    /**\n     * Next Range command handler\n     */\n    function _nextRange() {\n        var focusedMultiRangeInlineEditor = getFocusedMultiRangeInlineEditor();\n        if (focusedMultiRangeInlineEditor) {\n            focusedMultiRangeInlineEditor._selectNextRange();\n        }\n    }\n\n    _prevMatchCmd = CommandManager.register(Strings.CMD_QUICK_EDIT_PREV_MATCH, Commands.QUICK_EDIT_PREV_MATCH, _previousRange);\n    _prevMatchCmd.setEnabled(false);\n    _nextMatchCmd = CommandManager.register(Strings.CMD_QUICK_EDIT_NEXT_MATCH, Commands.QUICK_EDIT_NEXT_MATCH, _nextRange);\n    _nextMatchCmd.setEnabled(false);\n\n    exports.MultiRangeInlineEditor = MultiRangeInlineEditor;\n    exports.getFocusedMultiRangeInlineEditor = getFocusedMultiRangeInlineEditor;\n});\n"],"file":"MultiRangeInlineEditor.js"}
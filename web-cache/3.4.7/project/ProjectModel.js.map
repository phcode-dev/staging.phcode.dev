{"version":3,"sources":["project/ProjectModel.js"],"names":["define","require","exports","module","InMemoryFile","EventDispatcher","FileUtils","_","FileSystem","FileSystemError","FileTreeViewModel","Async","PerfUtils","EVENT_CHANGE","EVENT_SHOULD_SELECT","EVENT_SHOULD_FOCUS","EVENT_FS_RENAME_STARTED","EVENT_FS_RENAME_END","ERROR_CREATION","ERROR_INVALID_FILENAME","ERROR_NOT_IN_PROJECT","_exclusionListRegEx","_cacheExcludeFileNameRegEx","defaultIgnoreGlobs","_invalidChars","_illegalFilenamesRegEx","isValidFilename","filename","match","isValidPath","path","_shouldShowName","name","test","shouldShow","entry","shouldIndex","FILE_RENAMING","FILE_CREATING","RENAME_CANCELLED","_pathIsFile","last","_getFSObject","getFileForPath","getDirectoryForPath","_getPathFromFSObject","fsobj","fullPath","doCreate","isFolder","d","$","Deferred","getBaseName","resolve","err","directory","create","reject","file","writeText","then","ALREADY_EXISTS","promise","ProjectModel","initial","projectRoot","this","undefined","focused","_focused","_viewModel","on","trigger","bind","_selections","_ensureTrailingSlash","_getWelcomeProjectPath","sampleUrl","initialPath","substr","lastIndexOf","_addWelcomeProjectPath","currentProjects","pathNoSlash","stripTrailingSlash","newProjects","clone","indexOf","push","_isWelcomeProjectPath","welcomeProjectPath","welcomeProjects","makeEventDispatcher","prototype","_projectBaseUrl","_currentPath","_allFilesCachePromise","_allFilesScopeCachePromise","_allFilesScope","setFocused","setSelected","setSelectionWidth","width","setScrollerInfo","scrollWidth","scrollTop","scrollLeft","offsetTop","setSelectionScrollerInfo","getBaseUrl","setBaseUrl","projectBaseUrl","length","isWithinProject","absPathOrEntry","absPath","makeProjectRelativeIfPossible","slice","getDirectoryInProject","isDirectory","_getAllFilesCache","sort","deferred","allFiles","allFilesVisitor","isFile","projectIndexTimer","markStart","options","sortList","visit","finalizeMeasurement","addMeasurement","_getAllFilesInScopeCache","scope","self","Error","scopeTimer","getAllFiles","filter","additionalFiles","filteredFilesDeferred","getAllFilesFn","done","result","forEach","e","console","error","stack","fail","_resetCache","setProjectRoot","_rootChanged","getContents","contents","setDirectoryContents","_getDirectoryContents","setDirectoryOpen","open","projectRelative","needsLoading","isPathLoaded","onSuccess","openPath","currentPathInProject","isFilePathVisible","selected","relativeSelected","parentDirectory","getDirectoryPath","showInTree","Phoenix","app","openPathInFileBrowser","catch","doNotOpen","oldProjectPath","pathInProject","performRename","moveMarker","context","previousSelection","previousPath","hadFocus","getSelected","setCurrentFile","curFile","selectInWorkingSet","add","setContext","_doNotRename","_saveContext","previousContext","currentContext","restoreContext","getContext","startRename","isMoved","rename","type","projectRelativePath","newPath","setRenameValue","cancelRename","renameInfo","_cancelCreating","_renameItem","oldPath","newName","oldName","viewModel","createAtPath","finalizeRename","deleteAtPath","errorType","errorInfo","renameItem","startCreating","basedir","createPlaceholder","setSortDirectoriesFirst","sortDirectoriesFirst","getOpenNodes","reopenNodes","nodesByDepth","doSequentially","toOpenPaths","doInParallel","relative","refresh","openNodes","selections","handleFSEvent","added","removed","changes","changed","map","find","processChanges","closeSubtree","toggleSubdirectories","openOrClose","childNodes","getChildDirectories","node"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* unittests: ProjectModel */\n\n/**\n * Provides the data source for a project and manages the view model for the FileTreeView.\n */\ndefine(function (require, exports, module) {\n\n\n    var InMemoryFile        = require(\"document/InMemoryFile\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        _                   = require(\"thirdparty/lodash\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        FileSystemError     = require(\"filesystem/FileSystemError\"),\n        FileTreeViewModel   = require(\"project/FileTreeViewModel\"),\n        Async               = require(\"utils/Async\"),\n        PerfUtils           = require(\"utils/PerfUtils\");\n\n    // Constants\n    var EVENT_CHANGE            = \"change\",\n        EVENT_SHOULD_SELECT     = \"select\",\n        EVENT_SHOULD_FOCUS      = \"focus\",\n        EVENT_FS_RENAME_STARTED = \"mvStart\",\n        EVENT_FS_RENAME_END     = \"mvEnd\",\n        ERROR_CREATION          = \"creationError\",\n        ERROR_INVALID_FILENAME  = \"invalidFilename\",\n        ERROR_NOT_IN_PROJECT    = \"notInProject\";\n\n    /**\n     * @private\n     * File and folder names which are not displayed or searched\n     * TODO: We should add the rest of the file names that TAR excludes:\n     *    http://www.gnu.org/software/tar/manual/html_section/exclude.html\n     * TODO: This should be user configurable\n     *    https://github.com/adobe/brackets/issues/6781\n     * @type {RegExp}\n     */\n    var _exclusionListRegEx = /\\.pyc$|^\\.git$|^\\.gitmodules$|^\\.svn$|^\\.DS_Store$|^Icon\\r|^Thumbs\\.db$|^\\.hg$|^CVS$|^\\.hgtags$|^\\.idea$|^\\.c9revisions$|^\\.SyncArchive$|^\\.SyncID$|^\\.SyncIgnore$|\\~$/;\n    var _cacheExcludeFileNameRegEx = /^node_modules$|^bower_components$|^.npm$|^.yarn$|^__pycache__$/;\n\n    /**\n     * Glob definition of files and folders that should be excluded directly\n     * inside node domain watching with chokidar\n     */\n    const defaultIgnoreGlobs = [\n        \"node_modules\",\n        \"**/node_modules\",\n        \"bower_components\",\n        \"**/bower_components\",\n        \".npm\",\n        \".yarn\",\n        \"__pycache__\",\n        \".pyc\",\n        \".git\",\n        \".gitmodules\",\n        \".svn\",\n        \".DS_Store\",\n        \"Thumbs.db\",\n        \".hg\",\n        \"CVS\",\n        \".hgtags\",\n        \".idea\",\n        \".c9revisions\",\n        \".SyncArchive\",\n        \".SyncID\",\n        \".SyncIgnore\"\n    ];\n\n    /**\n     * @private\n     * RegEx to validate a file path.\n     */\n    var _invalidChars = /([?\\*\\|\\<\\>\"]+|\\/{2,}|\\.{2,}|\\.$)/i;\n\n    /**\n     * @private\n     * RegEx to validate if a filename is not allowed even if the system allows it.\n     * This is done to prevent cross-platform issues.\n     */\n    var _illegalFilenamesRegEx = /((\\b(com[0-9]+|lpt[0-9]+|nul|con|prn|aux)\\b)|\\.+$|\\/+|\\\\+|\\:)/i;\n\n    /**\n     * Returns true if this matches valid filename specifications.\n     * See http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx\n     *\n     * TODO: This likely belongs in FileUtils.\n     *\n     * @param {string} filename to check\n     * @return {boolean} true if the filename is valid\n     */\n    function isValidFilename(filename) {\n        // Fix issue adobe#13099\n        // See https://github.com/adobe/brackets/issues/13099\n        return !(\n            filename.match(_invalidChars)|| filename.match(_illegalFilenamesRegEx)\n        );\n    }\n\n    /**\n     * Returns true if given path is valid.\n     *\n     * @param {string} path to check\n     * @return {boolean} true if the filename is valid\n     */\n    function isValidPath(path) {\n        // Fix issue adobe#13099\n        // See https://github.com/adobe/brackets/issues/13099\n        return !(path.match(_invalidChars));\n    }\n\n    /**\n     * @private\n     * @see #shouldShow\n     */\n    function _shouldShowName(name) {\n        return !_exclusionListRegEx.test(name);\n    }\n\n    /**\n     * Returns false for files and directories that are not commonly useful to display.\n     *\n     * @param {!FileSystemEntry} entry File or directory to filter\n     * @return {boolean} true if the file should be displayed\n     */\n    function shouldShow(entry) {\n        return _shouldShowName(entry.name);\n    }\n\n    /**\n     * Returns false for files and directories that should not be indexed for search or code hints.\n     * If the entry is a directory, its children should be indexed too.\n     *\n     * @param {!FileSystemEntry} entry File or directory to filter\n     * @return {boolean} true if the file should be displayed\n     */\n    function shouldIndex(entry) {\n        return shouldShow(entry) && !_cacheExcludeFileNameRegEx.test(entry.name);\n    }\n\n    // Constants used by the ProjectModel\n\n    var FILE_RENAMING     = 0,\n        FILE_CREATING     = 1,\n        RENAME_CANCELLED  = 2;\n\n\n    /**\n     * @private\n     *\n     * Determines if a path string is pointing to a directory (does it have a trailing slash?)\n     *\n     * @param {string} path Path to test.\n     */\n    function _pathIsFile(path) {\n        return _.last(path) !== \"/\";\n    }\n\n    /**\n     * @private\n     *\n     * Gets the FileSystem object (either a File or Directory) based on the path provided.\n     *\n     * @param {string} path Path to retrieve\n     */\n    function _getFSObject(path) {\n        if (!path) {\n            return path;\n        } else if (_pathIsFile(path)) {\n            return FileSystem.getFileForPath(path);\n        }\n        return FileSystem.getDirectoryForPath(path);\n    }\n\n    /**\n     * @private\n     *\n     * Given what is possible a FileSystem object, return its path (if a string path is passed in,\n     * it will be returned as-is).\n     *\n     * @param {FileSystemEntry} fsobj Object from which the path should be extracted\n     */\n    function _getPathFromFSObject(fsobj) {\n        if (fsobj && fsobj.fullPath) {\n            return fsobj.fullPath;\n        }\n        return fsobj;\n    }\n\n    /**\n     * Creates a new file or folder at the given path. The returned promise is rejected if the filename\n     * is invalid, the new path already exists or some other filesystem error comes up.\n     *\n     * @param {string} path path to create\n     * @param {boolean} isFolder true if the new entry is a folder\n     * @return {$.Promise} resolved when the file or directory has been created.\n     */\n    function doCreate(path, isFolder) {\n        const d = new $.Deferred();\n        const filename = FileUtils.getBaseName(path);\n\n        // Check if filename\n        // or Check if fullpath with filename is valid - This check is used to circumvent directory jumps (Like ../..)\n        if (!isValidFilename(filename) || !isValidPath(path)){\n            return d.reject(ERROR_INVALID_FILENAME).promise();\n        }\n\n        FileSystem.resolve(path, function (err) {\n            if (!err) {\n                // Item already exists, fail with error\n                d.reject(FileSystemError.ALREADY_EXISTS);\n                return;\n            }\n            if (isFolder) {\n                const directory = FileSystem.getDirectoryForPath(path);\n\n                directory.create(function (err) {\n                    if (err) {\n                        d.reject(err);\n                    } else {\n                        d.resolve(directory);\n                    }\n                });\n            } else {\n                // Create an empty file\n                const file = FileSystem.getFileForPath(path);\n\n                FileUtils.writeText(file, \"\").then(function () {\n                    d.resolve(file);\n                }, d.reject);\n            }\n        });\n\n        return d.promise();\n    }\n\n    /**\n     * @constructor\n     *\n     * The ProjectModel provides methods for accessing information about the current open project.\n     * It also manages the view model to display a FileTreeView of the project.\n     *\n     * Events:\n     * - EVENT_CHANGE (`change`) - Fired when there's a change that should refresh the UI\n     * - EVENT_SHOULD_SELECT (`select`) - Fired when a selection has been made in the file tree and the file tree should be selected\n     * - EVENT_SHOULD_FOCUS (`focus`)\n     * - ERROR_CREATION (`creationError`) - Triggered when there's a problem creating a file\n     */\n    function ProjectModel(initial) {\n        initial = initial || {};\n        if (initial.projectRoot) {\n            this.projectRoot = initial.projectRoot;\n        }\n\n        if (initial.focused !== undefined) {\n            this._focused = initial.focused;\n        }\n        this._viewModel = new FileTreeViewModel.FileTreeViewModel();\n        this._viewModel.on(FileTreeViewModel.EVENT_CHANGE, function () {\n            this.trigger(EVENT_CHANGE);\n        }.bind(this));\n        this._selections = {};\n    }\n    EventDispatcher.makeEventDispatcher(ProjectModel.prototype);\n\n    /**\n     * @type {Directory}\n     *\n     * The root Directory object for the project.\n     */\n    ProjectModel.prototype.projectRoot = null;\n\n    /**\n     * @private\n     * @type {FileTreeViewModel}\n     *\n     * The view model for this project.\n     */\n    ProjectModel.prototype._viewModel = null;\n\n    /**\n     * @private\n     * @type {string}\n     *\n     * Encoded URL\n     * @see {@link ProjectModel#getBaseUrl}, {@link ProjectModel#setBaseUrl}\n     */\n    ProjectModel.prototype._projectBaseUrl = \"\";\n\n    /**\n     * @private\n     * @type {{selected: ?string, context: ?string, previousContext: ?string, rename: ?Object}}\n     *\n     * Keeps track of selected files, context, previous context and files\n     * that are being renamed or created.\n     */\n    ProjectModel.prototype._selections = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     *\n     * Flag to store whether the file tree has focus.\n     */\n    ProjectModel.prototype._focused = true;\n\n    /**\n     * @private\n     * @type {string}\n     *\n     * Current file path being viewed.\n     */\n    ProjectModel.prototype._currentPath = null;\n\n    /**\n     * @private\n     * @type {?$.Promise.<Array<File>>}\n     *\n     * A promise that is resolved with an array of all project files. Used by\n     * ProjectManager.getAllFiles().\n     */\n    ProjectModel.prototype._allFilesCachePromise = null;\n    ProjectModel.prototype._allFilesScopeCachePromise = null;\n    ProjectModel.prototype._allFilesScope = null;\n\n    /**\n     * Sets whether the file tree is focused or not.\n     *\n     * @param {boolean} focused True if the file tree has the focus.\n     */\n    ProjectModel.prototype.setFocused = function (focused) {\n        this._focused = focused;\n        if (!focused) {\n            this.setSelected(null);\n        }\n    };\n\n    /**\n     * Sets the width of the selection bar.\n     *\n     * @param {int} width New width\n     */\n    ProjectModel.prototype.setSelectionWidth = function (width) {\n        this._viewModel.setSelectionWidth(width);\n    };\n\n    /**\n     * Tracks the scroller position.\n     *\n     * @param {int} scrollWidth Width of the tree container\n     * @param {int} scrollTop Top of scroll position\n     * @param {int} scrollLeft Left of scroll position\n     * @param {int} offsetTop Top of scroller element\n     */\n    ProjectModel.prototype.setScrollerInfo = function (scrollWidth, scrollTop, scrollLeft, offsetTop) {\n        this._viewModel.setSelectionScrollerInfo(scrollWidth, scrollTop, scrollLeft, offsetTop);\n    };\n\n    /**\n     * Returns the encoded Base URL of the currently loaded project, or empty string if no project\n     * is open (during startup, or running outside of app shell).\n     * @return {String}\n     */\n    ProjectModel.prototype.getBaseUrl = function getBaseUrl() {\n        return this._projectBaseUrl;\n    };\n\n    /**\n     * Sets the encoded Base URL of the currently loaded project.\n     * @param {String}\n     */\n    ProjectModel.prototype.setBaseUrl = function setBaseUrl(projectBaseUrl) {\n        // Ensure trailing slash to be consistent with projectRoot.fullPath\n        // so they're interchangable (i.e. easy to convert back and forth)\n        if (projectBaseUrl.length > 0 && projectBaseUrl[projectBaseUrl.length - 1] !== \"/\") {\n            projectBaseUrl += \"/\";\n        }\n\n        this._projectBaseUrl = projectBaseUrl;\n        return projectBaseUrl;\n    };\n\n    /**\n     * Returns true if absPath lies within the project, false otherwise.\n     * Does not support paths containing \"..\"\n     *\n     * @param {string|FileSystemEntry} absPathOrEntry\n     * @return {boolean}\n     */\n    ProjectModel.prototype.isWithinProject = function isWithinProject(absPathOrEntry) {\n        var absPath = absPathOrEntry.fullPath || absPathOrEntry;\n        return (this.projectRoot && absPath.indexOf(this.projectRoot.fullPath) === 0);\n    };\n\n    /**\n     * If absPath lies within the project, returns a project-relative path. Else returns absPath\n     * unmodified.\n     * Does not support paths containing \"..\"\n     *\n     * @param {!string} absPath\n     * @return {!string}\n     */\n    ProjectModel.prototype.makeProjectRelativeIfPossible = function makeProjectRelativeIfPossible(absPath) {\n        if (absPath && this.isWithinProject(absPath)) {\n            return absPath.slice(this.projectRoot.fullPath.length);\n        }\n        return absPath;\n    };\n\n    /**\n     * Returns a valid directory within the project, either the path (or Directory object)\n     * provided or the project root.\n     *\n     * @param {string|Directory} path Directory path to verify against the project\n     * @return {string} A directory path within the project.\n     */\n    ProjectModel.prototype.getDirectoryInProject = function (path) {\n        if (path && typeof path === \"string\") {\n            if (_.last(path) !== \"/\") {\n                path += \"/\";\n            }\n        } else if (path && path.isDirectory) {\n            path = path.fullPath;\n        } else {\n            path = null;\n        }\n\n        if (!path || (typeof path !== \"string\") || !this.isWithinProject(path)) {\n            path = this.projectRoot.fullPath;\n        }\n        return path;\n    };\n\n    /**\n     * @private\n     *\n     * Returns a promise that resolves with a cached copy of all project files.\n     * Used by ProjectManager.getAllFiles(). Ensures that at most one un-cached\n     * directory traversal is active at a time, which is useful at project load\n     * time when watchers (and hence filesystem-level caching) has not finished\n     * starting up. The cache is cleared on every filesystem change event, and\n     * also on project load and unload.\n     *\n     * @param {boolean} sort true to sort files by their paths\n     * @return {$.Promise.<Array.<File>>}\n     */\n    ProjectModel.prototype._getAllFilesCache = function _getAllFilesCache(sort) {\n        if (!this._allFilesCachePromise) {\n            var deferred = new $.Deferred(),\n                allFiles = [],\n                allFilesVisitor = function (entry) {\n                    if (shouldIndex(entry)) {\n                        if (entry.isFile) {\n                            allFiles.push(entry);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n            this._allFilesCachePromise = deferred.promise();\n\n            var projectIndexTimer = PerfUtils.markStart(\"Creating project files cache: \" +\n                                                        this.projectRoot.fullPath),\n                options = {\n                    sortList: sort\n                };\n\n            this.projectRoot.visit(allFilesVisitor, options, function (err) {\n                if (err) {\n                    PerfUtils.finalizeMeasurement(projectIndexTimer);\n                    deferred.reject(err);\n                } else {\n                    PerfUtils.addMeasurement(projectIndexTimer);\n                    deferred.resolve(allFiles);\n                }\n            }.bind(this));\n        }\n\n        return this._allFilesCachePromise;\n    };\n\n    ProjectModel.prototype._getAllFilesInScopeCache = function (sort, scope) {\n        let self = this;\n        if(!this.isWithinProject(scope)){\n            return (new $.Deferred()).reject(\n                new Error(`Scope ${scope.fullPath} should be within project root ${self.projectRoot}`)\n            ).promise();\n        }\n        if (!this._allFilesScopeCachePromise || this._allFilesScope !== scope) {\n            this._allFilesScope = scope;\n            const deferred = new $.Deferred(),\n                allFiles = [],\n                allFilesVisitor = function (entry) {\n                    if (shouldIndex(entry) || entry.fullPath === scope.fullPath) {\n                        if (entry.isFile) {\n                            allFiles.push(entry);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n            this._allFilesScopeCachePromise = deferred.promise();\n\n            const scopeTimer = PerfUtils.markStart(\"Project scope files cache: \" +\n                    scope.fullPath),\n                options = {\n                    sortList: sort\n                };\n\n            scope.visit(allFilesVisitor, options, function (err) {\n                if (err) {\n                    PerfUtils.finalizeMeasurement(scopeTimer);\n                    deferred.reject(err);\n                } else {\n                    PerfUtils.addMeasurement(scopeTimer);\n                    deferred.resolve(allFiles);\n                }\n            }.bind(this));\n        }\n\n        return this._allFilesScopeCachePromise;\n    };\n\n    /**\n     * Returns an Array of all files for this project, optionally including\n     * files additional files provided. Files are filtered out by shouldShow().\n     *\n     * @param {function (File, number):boolean=} filter Optional function to filter\n     *          the file list (does not filter directory traversal). API matches Array.filter().\n     * @param {Array.<File>=} additionalFiles Additional files to include (for example, the WorkingSet)\n     *          Only adds files that are *not* under the project root or untitled documents.\n     * @param {boolean} sort true to sort files by their paths\n     * @param {Object} options optional path within project to narrow down the search\n     * @param {File} options.scope optional path within project to narrow down the search\n     *\n     * @return {$.Promise} Promise that is resolved with an Array of File objects.\n     */\n    ProjectModel.prototype.getAllFiles = function getAllFiles(filter, additionalFiles, sort, options) {\n        // The filter and includeWorkingSet params are both optional.\n        // Handle the case where filter is omitted but includeWorkingSet is\n        // specified.\n        if (typeof (filter) !== \"function\") {\n            options = sort;\n            sort = additionalFiles;\n            additionalFiles = filter;\n            filter = null;\n        }\n        options = options || {};\n\n        var filteredFilesDeferred = new $.Deferred();\n\n        // First gather all files in project proper\n        // Note that with proper promises we may be able to fix this so that we're not doing this\n        // anti-pattern of creating a separate deferred rather than just chaining off of the promise\n        // from _getAllFilesCache\n        const getAllFilesFn = options.scope ?\n            this._getAllFilesInScopeCache.bind(this) : this._getAllFilesCache.bind(this);\n        getAllFilesFn(sort, options.scope).done(function (result) {\n            result = [...result]; // clone it as the above result is cached and we dont want to modify the cache\n            // Add working set entries, if requested\n            if (additionalFiles) {\n                additionalFiles.forEach(function (file) {\n                    if (result.indexOf(file) === -1 && !(file instanceof InMemoryFile)) {\n                        result.push(file);\n                    }\n                });\n            }\n\n            // Filter list, if requested\n            if (filter) {\n                result = result.filter(filter);\n            }\n\n            // If a done handler attached to the returned filtered files promise\n            // throws an exception that isn't handled here then it will leave\n            // _allFilesCachePromise in an inconsistent state such that no\n            // additional done handlers will ever be called!\n            try {\n                filteredFilesDeferred.resolve(result);\n            } catch (e) {\n                console.error(\"Unhandled exception in getAllFiles handler: \" + e, e.stack);\n            }\n        }).fail(function (err) {\n            try {\n                filteredFilesDeferred.reject(err);\n            } catch (e) {\n                console.error(\"Unhandled exception in getAllFiles handler: \" + e, e.stack);\n            }\n        });\n\n        return filteredFilesDeferred.promise();\n    };\n\n    /**\n     * @private\n     *\n     * Resets the all files cache.\n     */\n    ProjectModel.prototype._resetCache = function _resetCache() {\n        this._allFilesCachePromise = null;\n        this._allFilesScopeCachePromise = null;\n        this._allFilesScope = null;\n    };\n\n    /**\n     * Sets the project root (effectively resetting this ProjectModel).\n     *\n     * @param {Directory} projectRoot new project root\n     * @return {$.Promise} resolved when the project root has been updated\n     */\n    ProjectModel.prototype.setProjectRoot = function (projectRoot) {\n        this.projectRoot = projectRoot;\n        this._resetCache();\n        this._viewModel._rootChanged();\n\n        var d = new $.Deferred(),\n            self = this;\n\n        projectRoot.getContents(function (err, contents) {\n            if (err) {\n                d.reject(err);\n            } else {\n                self._viewModel.setDirectoryContents(\"\", contents);\n                d.resolve();\n            }\n        });\n        return d.promise();\n    };\n\n    /**\n     * @private\n     *\n     * Gets the contents of a directory at the given path.\n     *\n     * @param {string} path path to retrieve\n     * @return {$.Promise} Resolved with the directory contents.\n     */\n    ProjectModel.prototype._getDirectoryContents = function (path) {\n        var d = new $.Deferred();\n        FileSystem.getDirectoryForPath(path).getContents(function (err, contents) {\n            if (err) {\n                d.reject(err);\n            } else {\n                d.resolve(contents);\n            }\n        });\n        return d.promise();\n    };\n\n    /**\n     * Opens or closes the given directory in the file tree.\n     *\n     * @param {string} path Path to open\n     * @param {boolean} open `true` to open the path\n     * @return {$.Promise} resolved when the path has been opened.\n     */\n    ProjectModel.prototype.setDirectoryOpen = function (path, open) {\n        var projectRelative = this.makeProjectRelativeIfPossible(path),\n            needsLoading    = !this._viewModel.isPathLoaded(projectRelative),\n            d               = new $.Deferred(),\n            self            = this;\n\n        function onSuccess(contents) {\n            // Update the view model\n            if (contents) {\n                self._viewModel.setDirectoryContents(projectRelative, contents);\n            }\n\n            if (open) {\n                self._viewModel.openPath(projectRelative);\n                if (self._focused) {\n                    var currentPathInProject = self.makeProjectRelativeIfPossible(self._currentPath);\n                    if (self._viewModel.isFilePathVisible(currentPathInProject)) {\n                        self.setSelected(self._currentPath, true);\n                    } else {\n                        self.setSelected(null);\n                    }\n                }\n            } else {\n                self._viewModel.setDirectoryOpen(projectRelative, false);\n                var selected = self._selections.selected;\n                if (selected) {\n                    var relativeSelected = self.makeProjectRelativeIfPossible(selected);\n                    if (!self._viewModel.isFilePathVisible(relativeSelected)) {\n                        self.setSelected(null);\n                    }\n                }\n            }\n\n            d.resolve();\n        }\n\n        // If the view model doesn't have the data it needs, we load it now, otherwise we can just\n        // manage the selection and resovle the promise.\n        if (open && needsLoading) {\n            var parentDirectory = FileUtils.getDirectoryPath(FileUtils.stripTrailingSlash(path));\n            this.setDirectoryOpen(parentDirectory, true).then(function () {\n                self._getDirectoryContents(path).then(onSuccess).fail(function (err) {\n                    d.reject(err);\n                });\n            }, function (err) {\n                d.reject(err);\n            });\n        } else {\n            onSuccess();\n        }\n\n        return d.promise();\n    };\n\n    /**\n     * Shows the given path in the tree and selects it if it's a file. Any intermediate directories\n     * will be opened and a promise is returned to show when the entire operation is complete.\n     *\n     * @param {string|File|Directory} path full path to the file or directory\n     * @return {$.Promise} promise resolved when the path is shown\n     */\n    ProjectModel.prototype.showInTree = function (path) {\n        var d = new $.Deferred();\n        path = _getPathFromFSObject(path);\n\n        if (!this.isWithinProject(path)) {\n            Phoenix.app.openPathInFileBrowser(path)\n                .then(d.resolve)\n                .catch(d.reject);\n            return d.promise();\n        }\n\n        const self = this;\n        this.setDirectoryOpen(FileUtils.getDirectoryPath(path), true).then(function () {\n            if (_pathIsFile(path)) {\n                self.setSelected(path);\n            }\n            d.resolve();\n        }, function (err) {\n            d.reject(err);\n        });\n        return d.promise();\n    };\n\n    /**\n     * Selects the given path in the file tree and opens the file (unless doNotOpen is specified).\n     * Directories will not be selected.\n     *\n     * When the selection changes, any rename operation that is currently underway will be completed.\n     *\n     * @param {string} path full path to the file being selected\n     * @param {boolean} doNotOpen `true` if the file should not be opened.\n     */\n    ProjectModel.prototype.setSelected = function (path, doNotOpen) {\n        path = _getPathFromFSObject(path);\n\n        // Directories are not selectable\n        if (!_pathIsFile(path)) {\n            return;\n        }\n\n        var oldProjectPath = this.makeProjectRelativeIfPossible(this._selections.selected),\n            pathInProject = this.makeProjectRelativeIfPossible(path);\n\n        if (path && !this._viewModel.isFilePathVisible(pathInProject)) {\n            path = null;\n            pathInProject = null;\n        }\n\n        this.performRename();\n\n        this._viewModel.moveMarker(\"selected\", oldProjectPath, pathInProject);\n        if (this._selections.context) {\n            this._viewModel.moveMarker(\"context\", this.makeProjectRelativeIfPossible(this._selections.context), null);\n            delete this._selections.context;\n        }\n\n        var previousSelection = this._selections.selected;\n        this._selections.selected = path;\n\n        if (path) {\n            if (!doNotOpen) {\n                this.trigger(EVENT_SHOULD_SELECT, {\n                    path: path,\n                    previousPath: previousSelection,\n                    hadFocus: this._focused\n                });\n            }\n\n            this.trigger(EVENT_SHOULD_FOCUS);\n        }\n    };\n\n    /**\n     * Gets the currently selected file or directory.\n     *\n     * @return {FileSystemEntry} the filesystem object for the currently selected file\n     */\n    ProjectModel.prototype.getSelected = function () {\n        return _getFSObject(this._selections.selected);\n    };\n\n    /**\n     * Keeps track of which file is currently being edited.\n     *\n     * @param {File|string} curFile Currently edited file.\n     */\n    ProjectModel.prototype.setCurrentFile = function (curFile) {\n        this._currentPath = _getPathFromFSObject(curFile);\n    };\n\n    /**\n     * Adds the file at the given path to the Working Set and selects it there.\n     *\n     * @param {string} path full path of file to open in Working Set\n     */\n    ProjectModel.prototype.selectInWorkingSet = function (path) {\n        this.performRename();\n        this.trigger(EVENT_SHOULD_SELECT, {\n            path: path,\n            add: true\n        });\n    };\n\n    /**\n     * Sets the context (for context menu operations) to the given path. This is independent from the\n     * open/selected file.\n     *\n     * @param {string} path full path of file or directory to which the context should be setBaseUrl\n     * @param {boolean} _doNotRename True if this context change should not cause a rename operation to finish. This is a special case that goes with context menu handling.\n     * @param {boolean} _saveContext True if the current context should be saved (see comment below)\n     */\n    ProjectModel.prototype.setContext = function (path, _doNotRename, _saveContext) {\n        // This bit is not ideal: when the user right-clicks on an item in the file tree\n        // and there is already a context menu up, the FileTreeView sends a signal to set the\n        // context to the new element but the PopupManager follows that with a message that it's\n        // closing the context menu (because it closes the previous one and then opens the new\n        // one.) This timing means that we need to provide some special case handling here.\n        if (_saveContext) {\n            if (!path) {\n                this._selections.previousContext = this._selections.context;\n            } else {\n                this._selections.previousContext = path;\n            }\n        } else {\n            delete this._selections.previousContext;\n        }\n\n        path = _getPathFromFSObject(path);\n\n        if (!_doNotRename) {\n            this.performRename();\n        }\n        var currentContext = this._selections.context;\n        this._selections.context = path;\n        this._viewModel.moveMarker(\"context\", this.makeProjectRelativeIfPossible(currentContext),\n                                   this.makeProjectRelativeIfPossible(path));\n    };\n\n    /**\n     * Restores the context to the last non-null context. This is specifically here to handle\n     * the sequence of messages that we get from the project context menu.\n     */\n    ProjectModel.prototype.restoreContext = function () {\n        if (this._selections.previousContext) {\n            this.setContext(this._selections.previousContext);\n        }\n    };\n\n    /**\n     * Gets the currently selected context.\n     *\n     * @return {FileSystemEntry} filesystem object for the context file or directory\n     */\n    ProjectModel.prototype.getContext = function () {\n        return _getFSObject(this._selections.context);\n    };\n\n    /**\n     * Starts a rename operation for the file or directory at the given path. If the path is\n     * not provided, the current context is used.\n     *\n     * If a rename operation is underway, it will be completed automatically.\n     *\n     * The Promise returned is resolved with an object with a `newPath` property with the renamed path. If the user cancels the operation, the promise is resolved with the value RENAME_CANCELLED.\n     *\n     * @param {string=} path optional path to start renaming\n     * @param {boolean=} isMoved optional flag which indicates whether the entry is being moved instead of renamed\n     * @return {$.Promise} resolved when the operation is complete.\n     */\n    ProjectModel.prototype.startRename = function (path, isMoved) {\n        var d = new $.Deferred();\n        path = _getPathFromFSObject(path);\n        if (!path) {\n            path = this._selections.context;\n            if (!path) {\n                return d.resolve().promise();\n            }\n        }\n\n        if (this._selections.rename && this._selections.rename.path === path) {\n            return d.resolve().promise();\n        }\n\n        if (!this.isWithinProject(path)) {\n            return d.reject({\n                type: ERROR_NOT_IN_PROJECT,\n                isFolder: !_pathIsFile(path),\n                fullPath: path\n            }).promise();\n        }\n\n        var projectRelativePath = this.makeProjectRelativeIfPossible(path);\n\n        if (!this._viewModel.isFilePathVisible(projectRelativePath)) {\n            this.showInTree(path);\n        }\n\n        if (!isMoved) {\n            if (path !== this._selections.context) {\n                this.setContext(path);\n            } else {\n                this.performRename();\n            }\n\n            this._viewModel.moveMarker(\"rename\", null,\n                projectRelativePath);\n        }\n        this._selections.rename = {\n            deferred: d,\n            type: FILE_RENAMING,\n            path: path,\n            newPath: path\n        };\n        return d.promise();\n    };\n\n    /**\n     * Sets the new value for the rename operation that is in progress (started previously with a call\n     * to `startRename`).\n     *\n     * @param {string} newPath new path for the file or directory being renamed\n     */\n    ProjectModel.prototype.setRenameValue = function (newPath) {\n        if (!this._selections.rename) {\n            return;\n        }\n        this._selections.rename.newPath = newPath;\n    };\n\n    /**\n     * Cancels the rename operation that is in progress. This resolves the original promise with\n     * a RENAME_CANCELLED value.\n     */\n    ProjectModel.prototype.cancelRename = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo) {\n            return;\n        }\n\n        // File creation is a special case.\n        if (renameInfo.type === FILE_CREATING) {\n            this._cancelCreating();\n            return;\n        }\n\n        this._viewModel.moveMarker(\"rename\", this.makeProjectRelativeIfPossible(renameInfo.path), null);\n        renameInfo.deferred.resolve(RENAME_CANCELLED);\n        delete this._selections.rename;\n        this.setContext(null);\n    };\n\n    /**\n     * @private\n     *\n     * Renames the item at the old path to the new name provided.\n     *\n     * @param {string} oldPath full path to the current location of file or directory (should include trailing slash for directory)\n     * @param {string} newPath full path to the new location of the file or directory\n     * @param {string} newName new name for the file or directory\n     */\n    ProjectModel.prototype._renameItem = function (oldPath, newPath, newName) {\n        const result = new $.Deferred();\n        const isFolder = !_pathIsFile(oldPath);\n        const self = this;\n\n        if (oldPath === newPath) {\n            result.resolve();\n        } else if (!isValidFilename(newName)) {\n            result.reject(ERROR_INVALID_FILENAME);\n        } else {\n            var entry = isFolder ? FileSystem.getDirectoryForPath(oldPath) : FileSystem.getFileForPath(oldPath);\n            self.trigger(EVENT_FS_RENAME_STARTED);\n            entry.rename(newPath, function (err) {\n                self.trigger(EVENT_FS_RENAME_END);\n                if (err) {\n                    result.reject(err);\n                } else {\n                    result.resolve();\n                }\n            });\n        }\n\n        return result.promise();\n    };\n\n    /**\n     * Completes the rename operation that is in progress.\n     */\n    ProjectModel.prototype.performRename = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo) {\n            return;\n        }\n        var oldPath         = renameInfo.path,\n            isFolder        = renameInfo.isFolder || !_pathIsFile(oldPath),\n            oldProjectPath  = this.makeProjectRelativeIfPossible(oldPath),\n\n            // To get the parent directory, we need to strip off the trailing slash on a directory name\n            parentDirectory = FileUtils.getDirectoryPath(isFolder ? FileUtils.stripTrailingSlash(oldPath) : oldPath),\n            oldName         = FileUtils.getBaseName(oldPath),\n            newPath         = renameInfo.newPath,\n            newName         = FileUtils.getBaseName(newPath),\n            viewModel       = this._viewModel,\n            self            = this;\n\n        if (renameInfo.type !== FILE_CREATING && oldPath === newPath) {\n            this.cancelRename();\n            return;\n        }\n\n        if (isFolder && _.last(newPath) !== \"/\") {\n            newPath += \"/\";\n        }\n\n        delete this._selections.rename;\n        delete this._selections.context;\n\n        viewModel.moveMarker(\"rename\", oldProjectPath, null);\n        viewModel.moveMarker(\"context\", oldProjectPath, null);\n        viewModel.moveMarker(\"creating\", oldProjectPath, null);\n\n        function finalizeRename() {\n            viewModel.renameItem(oldProjectPath, self.makeProjectRelativeIfPossible(newPath));\n            if (self._selections.selected && self._selections.selected.indexOf(oldPath) === 0) {\n                self._selections.selected = newPath + self._selections.selected.slice(oldPath.length);\n                self.setCurrentFile(newPath);\n            }\n        }\n\n        if (renameInfo.type === FILE_CREATING) {\n            this.createAtPath(newPath).done(function (entry) {\n                finalizeRename();\n                renameInfo.deferred.resolve(entry);\n            }).fail(function (error) {\n                self._viewModel.deleteAtPath(self.makeProjectRelativeIfPossible(renameInfo.path));\n                renameInfo.deferred.reject(error);\n            });\n        } else {\n            this._renameItem(oldPath, newPath, newName).then(function () {\n                finalizeRename();\n                renameInfo.deferred.resolve({\n                    newPath: newPath\n                });\n            }).fail(function (errorType) {\n                var errorInfo = {\n                    type: errorType,\n                    isFolder: isFolder,\n                    fullPath: oldPath\n                };\n                renameInfo.deferred.reject(errorInfo);\n            });\n        }\n    };\n\n    /**\n     * Creates a file or folder at the given path. Folder paths should have a trailing slash.\n     *\n     * If an error comes up during creation, the ERROR_CREATION event is triggered.\n     *\n     * @param {string} path full path to file or folder to create\n     * @return {$.Promise} resolved when creation is complete\n     */\n    ProjectModel.prototype.createAtPath = function (path) {\n        var isFolder  = !_pathIsFile(path),\n            name      = FileUtils.getBaseName(path),\n            self      = this;\n\n        return doCreate(path, isFolder).done(function (entry) {\n            if (!isFolder) {\n                self.selectInWorkingSet(entry.fullPath);\n            }\n        }).fail(function (error) {\n            self.trigger(ERROR_CREATION, {\n                type: error,\n                name: name,\n                isFolder: isFolder\n            });\n        });\n    };\n\n    /**\n     * Starts creating a file or folder with the given name in the given directory.\n     *\n     * The Promise returned is resolved with an object with a `newPath` property with the renamed path. If the user cancels the operation, the promise is resolved with the value RENAME_CANCELLED.\n     *\n     * @param {string} basedir directory that should contain the new entry\n     * @param {string} newName initial name for the new entry (the user can rename it)\n     * @param {boolean} isFolder `true` if the entry being created is a folder\n     * @return {$.Promise} resolved when the user is done creating the entry.\n     */\n    ProjectModel.prototype.startCreating = function (basedir, newName, isFolder) {\n        this.performRename();\n        var d = new $.Deferred(),\n            self = this;\n\n        this.setDirectoryOpen(basedir, true).then(function () {\n            self._viewModel.createPlaceholder(self.makeProjectRelativeIfPossible(basedir), newName, isFolder);\n            var promise = self.startRename(basedir + newName);\n            self._selections.rename.type = FILE_CREATING;\n            if (isFolder) {\n                self._selections.rename.isFolder = isFolder;\n            }\n            promise.then(d.resolve).fail(d.reject);\n        }).fail(function (err) {\n            d.reject(err);\n        });\n        return d.promise();\n    };\n\n    /**\n     * Cancels the creation process that is underway. The original promise returned will be resolved with the\n     * RENAME_CANCELLED value. The temporary entry added to the file tree will be deleted.\n     */\n    ProjectModel.prototype._cancelCreating = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo || renameInfo.type !== FILE_CREATING) {\n            return;\n        }\n        this._viewModel.deleteAtPath(this.makeProjectRelativeIfPossible(renameInfo.path));\n        renameInfo.deferred.resolve(RENAME_CANCELLED);\n        delete this._selections.rename;\n        this.setContext(null);\n    };\n\n    /**\n     * Sets the `sortDirectoriesFirst` option for the file tree view.\n     *\n     * @param {boolean} True if directories should appear first\n     */\n    ProjectModel.prototype.setSortDirectoriesFirst = function (sortDirectoriesFirst) {\n        this._viewModel.setSortDirectoriesFirst(sortDirectoriesFirst);\n    };\n\n    /**\n     * Gets an array of arrays where each entry of the top-level array has an array\n     * of paths that are at the same depth in the tree. All of the paths are full paths.\n     *\n     * @return {Array.<Array.<string>>} Array of array of full paths, organized by depth in the tree.\n     */\n    ProjectModel.prototype.getOpenNodes = function () {\n        return this._viewModel.getOpenNodes(this.projectRoot.fullPath);\n    };\n\n    /**\n     * Reopens a set of nodes in the tree by full path.\n     * @param {Array.<Array.<string>>} nodesByDepth An array of arrays of node ids to reopen. The ids within\n     *     each sub-array are reopened in parallel, and the sub-arrays are reopened in order, so they should\n     *     be sorted by depth within the tree.\n     * @return {$.Deferred} A promise that will be resolved when all nodes have been fully\n     *     reopened.\n     */\n    ProjectModel.prototype.reopenNodes = function (nodesByDepth) {\n        var deferred = new $.Deferred();\n\n        if (!nodesByDepth || nodesByDepth.length === 0) {\n            // All paths are opened and fully rendered.\n            return deferred.resolve().promise();\n        }\n        var self = this;\n        return Async.doSequentially(nodesByDepth, function (toOpenPaths) {\n            return Async.doInParallel(\n                    toOpenPaths,\n                    function (path) {\n                        return self._getDirectoryContents(path).then(function (contents) {\n                            var relative = self.makeProjectRelativeIfPossible(path);\n                            self._viewModel.setDirectoryContents(relative, contents);\n                            self._viewModel.setDirectoryOpen(relative, true);\n                        });\n                    },\n                    false\n                );\n        });\n\n    };\n\n    /**\n     * Clears caches and refreshes the contents of the tree.\n     *\n     * @return {$.Promise} resolved when the tree has been refreshed\n     */\n    ProjectModel.prototype.refresh = function () {\n        var projectRoot = this.projectRoot,\n            openNodes   = this.getOpenNodes(),\n            self        = this,\n            selections  = this._selections,\n            viewModel   = this._viewModel,\n            deferred    = new $.Deferred();\n\n        this.setProjectRoot(projectRoot).then(function () {\n            self.reopenNodes(openNodes).then(function () {\n                if (selections.selected) {\n                    viewModel.moveMarker(\"selected\", null, self.makeProjectRelativeIfPossible(selections.selected));\n                }\n\n                if (selections.context) {\n                    viewModel.moveMarker(\"context\", null, self.makeProjectRelativeIfPossible(selections.context));\n                }\n\n                if (selections.rename) {\n                    viewModel.moveMarker(\"rename\", null, self.makeProjectRelativeIfPossible(selections.rename));\n                }\n\n                deferred.resolve();\n            });\n        });\n\n        return deferred.promise();\n    };\n\n    /**\n     * Handles filesystem change events and prepares the update for the view model.\n     *\n     * @param {?(File|Directory)} entry File or Directory changed\n     * @param {Array.<FileSystemEntry>=} added If entry is a Directory, contains zero or more added children\n     * @param {Array.<FileSystemEntry>=} removed If entry is a Directory, contains zero or more removed\n     */\n    ProjectModel.prototype.handleFSEvent = function (entry, added, removed) {\n        this._resetCache();\n\n        if (!entry) {\n            this.refresh();\n            return;\n        }\n\n        if (!this.isWithinProject(entry)) {\n            return;\n        }\n\n        var changes = {},\n            self = this;\n\n        if (entry.isFile) {\n            changes.changed = [\n                this.makeProjectRelativeIfPossible(entry.fullPath)\n            ];\n        } else {\n            // Special case: a directory passed in without added and removed values\n            // needs to be updated.\n            if (!added && !removed) {\n                entry.getContents(function (err, contents) {\n                    if (err) {\n                        console.error(\"Unexpected error refreshing file tree for directory \" + entry.fullPath + \": \" + err, err.stack);\n                        return;\n                    }\n                    self._viewModel.setDirectoryContents(self.makeProjectRelativeIfPossible(entry.fullPath), contents);\n                });\n\n                // Exit early because we can't update the viewModel until we get the directory contents.\n                return;\n            }\n        }\n\n        if (added) {\n            changes.added = added.map(function (entry) {\n                return self.makeProjectRelativeIfPossible(entry.fullPath);\n            });\n        }\n\n        if (removed) {\n            if (this._selections.selected &&\n                    _.find(removed, { fullPath: this._selections.selected })) {\n                this.setSelected(null);\n            }\n\n            if (this._selections.rename &&\n                    _.find(removed, { fullPath: this._selections.rename.path })) {\n                this.cancelRename();\n            }\n\n            if (this._selections.context &&\n                    _.find(removed, { fullPath: this._selections.context })) {\n                this.setContext(null);\n            }\n            changes.removed = removed.map(function (entry) {\n                return self.makeProjectRelativeIfPossible(entry.fullPath);\n            });\n        }\n\n        this._viewModel.processChanges(changes);\n    };\n\n    /**\n     * Closes the directory at path and recursively closes all of its children.\n     *\n     * @param {string} path Path of subtree to close\n     */\n    ProjectModel.prototype.closeSubtree = function (path) {\n        this._viewModel.closeSubtree(this.makeProjectRelativeIfPossible(path));\n    };\n\n    /**\n     * Toggle the open state of subdirectories.\n     * @param {!string}  path        parent directory\n     * @param {boolean} openOrClose  true to open directory, false to close\n     * @return {$.Promise} promise resolved when the directories are open\n     */\n    ProjectModel.prototype.toggleSubdirectories = function (path, openOrClose) {\n        var self = this,\n            d = new $.Deferred();\n\n        this.setDirectoryOpen(path, true).then(function () {\n            var projectRelativePath = self.makeProjectRelativeIfPossible(path),\n                childNodes = self._viewModel.getChildDirectories(projectRelativePath);\n\n            Async.doInParallel(childNodes, function (node) {\n                return self.setDirectoryOpen(path + node, openOrClose);\n            }, true).then(function () {\n                d.resolve();\n            }, function (err) {\n                d.reject(err);\n            });\n        });\n\n        return d.promise();\n    };\n\n    /**\n     * Although Brackets is generally standardized on folder paths with a trailing \"/\", some APIs here\n     * receive project paths without \"/\" due to legacy preference storage formats, etc.\n     * @param {!string} fullPath  Path that may or may not end in \"/\"\n     * @return {!string} Path that ends in \"/\"\n     */\n    function _ensureTrailingSlash(fullPath) {\n        if (_pathIsFile(fullPath)) {\n            return fullPath + \"/\";\n        }\n        return fullPath;\n    }\n\n    /**\n     * @private\n     *\n     * Returns the full path to the welcome project, which we open on first launch.\n     *\n     * @param {string} sampleUrl URL for getting started project\n     * @param {string} initialPath Path to Brackets directory (see {@link FileUtils::#getNativeBracketsDirectoryPath})\n     * @return {!string} fullPath reference\n     */\n    function _getWelcomeProjectPath(sampleUrl, initialPath) {\n        if (sampleUrl) {\n            // Back up one more folder. The samples folder is assumed to be at the same level as\n            // the src folder, and the sampleUrl is relative to the samples folder.\n            initialPath = initialPath.substr(0, initialPath.lastIndexOf(\"/\")) + \"/samples/\" + sampleUrl;\n        }\n\n        return _ensureTrailingSlash(initialPath); // paths above weren't canonical\n    }\n\n    /**\n     * @private\n     *\n     * Adds the path to the list of welcome projects we've ever seen, if not on the list already.\n     *\n     * @param {string} path Path to possibly add\n     * @param {Array.<string>=} currentProjects Array of current welcome projects\n     * @return {Array.<string>} New array of welcome projects with the additional project added\n     */\n    function _addWelcomeProjectPath(path, currentProjects) {\n        var pathNoSlash = FileUtils.stripTrailingSlash(path);  // \"welcomeProjects\" pref has standardized on no trailing \"/\"\n\n        var newProjects;\n\n        if (currentProjects) {\n            newProjects = _.clone(currentProjects);\n        } else {\n            newProjects = [];\n        }\n\n        if (newProjects.indexOf(pathNoSlash) === -1) {\n            newProjects.push(pathNoSlash);\n        }\n        return newProjects;\n    }\n\n    /**\n     * Returns true if the given path is the same as one of the welcome projects we've previously opened,\n     * or the one for the current build.\n     *\n     * @param {string} path Path to check to see if it's a welcome project\n     * @param {string} welcomeProjectPath Current welcome project path\n     * @param {Array.<string>=} welcomeProjects All known welcome projects\n     */\n    function _isWelcomeProjectPath(path, welcomeProjectPath, welcomeProjects) {\n        if (path === welcomeProjectPath) {\n            return true;\n        }\n\n        // No match on the current path, and it's not a match if there are no previously known projects\n        if (!welcomeProjects) {\n            return false;\n        }\n\n        var pathNoSlash = FileUtils.stripTrailingSlash(path);  // \"welcomeProjects\" pref has standardized on no trailing \"/\"\n        return welcomeProjects.indexOf(pathNoSlash) !== -1;\n    }\n\n    exports._getWelcomeProjectPath  = _getWelcomeProjectPath;\n    exports._addWelcomeProjectPath  = _addWelcomeProjectPath;\n    exports._isWelcomeProjectPath   = _isWelcomeProjectPath;\n    exports._ensureTrailingSlash    = _ensureTrailingSlash;\n    exports._shouldShowName         = _shouldShowName;\n    exports._invalidChars           = \"? * | : / < > \\\\ | \\\" ..\";\n\n    exports.shouldShow              = shouldShow;\n    exports.shouldIndex             = shouldIndex;\n    exports.defaultIgnoreGlobs      = defaultIgnoreGlobs;\n    exports.isValidFilename         = isValidFilename;\n    exports.isValidPath             = isValidPath;\n    exports.EVENT_CHANGE            = EVENT_CHANGE;\n    exports.EVENT_SHOULD_SELECT     = EVENT_SHOULD_SELECT;\n    exports.EVENT_SHOULD_FOCUS      = EVENT_SHOULD_FOCUS;\n    exports.EVENT_FS_RENAME_STARTED = EVENT_FS_RENAME_STARTED;\n    exports.EVENT_FS_RENAME_END     = EVENT_FS_RENAME_END;\n    exports.ERROR_CREATION          = ERROR_CREATION;\n    exports.ERROR_INVALID_FILENAME  = ERROR_INVALID_FILENAME;\n    exports.ERROR_NOT_IN_PROJECT    = ERROR_NOT_IN_PROJECT;\n    exports.FILE_RENAMING           = FILE_RENAMING;\n    exports.FILE_CREATING           = FILE_CREATING;\n    exports.RENAME_CANCELLED        = RENAME_CANCELLED;\n    exports.doCreate                = doCreate;\n    exports.ProjectModel            = ProjectModel;\n});\n"],"file":"ProjectModel.js"}
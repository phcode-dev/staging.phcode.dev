{"version":3,"sources":["extensions/default/InlineTimingFunctionEditor/TimingFunctionUtils.js"],"names":["define","require","exports","module","Strings","brackets","getModule","StringUtils","AnimationUtils","BEZIER_CURVE_VALID_REGEX","BEZIER_CURVE_GENERAL_REGEX","EASE_STRICT_REGEX","EASE_LAX_REGEX","LINEAR_STRICT_REGEX","LINEAR_LAX_REGEX","STEPS_VALID_REGEX","STEPS_GENERAL_REGEX","STEP_STRICT_REGEX","STEP_LAX_REGEX","BEZIER","STEP","_convertToNumber","str","isNumber","value","val","parseFloat","isNum","isNaN","Infinity","_getValidBezierParams","match","param","def","oldIndex","index","originalString","i","split","trim","undefined","splice","join","_validateCubicBezierParams","x1","y1","x2","y2","_getValidStepsParams","params","replace","Math","floor","substr","_validateStepsParams","count","showHideHint","hint","show","documentCode","editorCode","elem","shown","animationInProgress","removeClass","html","format","INLINE_TIMING_EDITOR_INVALID","css","animateUsingClass","done","hide","_tagMatch","type","isBezier","isStep","bezierCurveMatch","lax","window","console","log","stepsMatch","timingFunctionMatch"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\n/**\n *  Utilities functions related to color matching\n */\ndefine(function (require, exports, module) {\n\n\n    var Strings         = brackets.getModule(\"strings\"),\n        StringUtils     = brackets.getModule(\"utils/StringUtils\"),\n        AnimationUtils  = brackets.getModule(\"utils/AnimationUtils\");\n\n    /**\n     * Regular expressions for matching timing functions\n     * @const @type {RegExp}\n     */\n    var BEZIER_CURVE_VALID_REGEX        = /cubic-bezier\\(\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*\\)/,\n        BEZIER_CURVE_GENERAL_REGEX      = /cubic-bezier\\((.*)\\)/,\n        EASE_STRICT_REGEX               = /[: ,]ease(?:-in)?(?:-out)?[ ,;]/,\n        EASE_LAX_REGEX                  = /ease(?:-in)?(?:-out)?/,\n        LINEAR_STRICT_REGEX             = /(transition|animation).*?[: ,]linear[ ,;]/,\n        LINEAR_LAX_REGEX                = /linear/,\n        STEPS_VALID_REGEX               = /steps\\(\\s*(\\d+)\\s*(?:,\\s*(\\w+)\\s*)?\\)/,\n        STEPS_GENERAL_REGEX             = /steps\\((.*)\\)/,\n        STEP_STRICT_REGEX               = /[: ,](?:step-start|step-end)[ ,;]/,\n        STEP_LAX_REGEX                  = /step-start|step-end/;\n\n    /**\n     * Type constants\n     * @const @type {number}\n     */\n    var BEZIER  = 1,\n        STEP    = 2;\n\n    /**\n     * If string is a number, then convert it.\n     *\n     * @param {string} str  value parsed from page.\n     * @return { isNumber: boolean, value: ?number }\n     */\n    function _convertToNumber(str) {\n        if (typeof str !== \"string\") {\n            return { isNumber: false, value: null };\n        }\n\n        var val = parseFloat(+str, 10),\n            isNum = (typeof val === \"number\") && !isNaN(val) &&\n                    (val !== Infinity) && (val !== -Infinity);\n\n        return {\n            isNumber: isNum,\n            value: val\n        };\n    }\n\n    /**\n     * Get valid params for an invalid cubic-bezier.\n     *\n     * @param {RegExp.match} match (Invalid) matches from cubicBezierMatch()\n     * @return {?RegExp.match} Valid match or null if the output is not valid\n     */\n    function _getValidBezierParams(match) {\n        var param,\n            // take ease-in-out as default value in case there are no params yet (or they are invalid)\n            def = [ \".42\", \"0\", \".58\", \"1\" ],\n            oldIndex = match.index, // we need to store the old match.index to re-set the index afterwards\n            originalString = match[0],\n            i;\n\n        if (match) {\n            match = match[1].split(\",\");\n        }\n\n        if (match) {\n            for (i = 0; i <= 3; i++) {\n                if (match[i]) {\n                    match[i] = match[i].trim();\n                    param = _convertToNumber(match[i]);\n\n                    // Verify the param is a number\n                    // If not, replace it with the default value\n                    if (!param.isNumber) {\n                        match[i] = undefined;\n\n                    // Verify x coordinates are in 0-1 range\n                    // If not, set them to the closest value in range\n                    } else if (i === 0 || i === 2) {\n                        if (param.value < 0) {\n                            match[i] = \"0\";\n                        } else if (param.value > 1) {\n                            match[i] = \"1\";\n                        }\n                    }\n                }\n\n                if (!match[i]) {\n                    match[i] = def[i];\n                }\n            }\n        } else {\n            match = def;\n        }\n        match = match.splice(0, 4); // make sure there are only 4 params\n        match = \"cubic-bezier(\" + match.join(\", \") + \")\";\n        match = match.match(BEZIER_CURVE_VALID_REGEX);\n\n        if (match) {\n            match.index = oldIndex; // re-set the index here to get the right context\n            match.originalString = originalString;\n            return match;\n        }\n        return null;\n    }\n\n    /**\n     * Validate cubic-bezier function parameters that are not already validated by regex:\n     *\n     * @param {RegExp.match} match  RegExp Match object with cubic-bezier function parameters\n     *                              in array positions 1-4.\n     * @return {boolean} true if all parameters are valid, otherwise, false\n     */\n    function _validateCubicBezierParams(match) {\n        var x1 = _convertToNumber(match[1]),\n            y1 = _convertToNumber(match[2]),\n            x2 = _convertToNumber(match[3]),\n            y2 = _convertToNumber(match[4]);\n\n        // Verify all params are numbers\n        if (!x1.isNumber || !y1.isNumber || !x2.isNumber || !y2.isNumber) {\n            return false;\n        }\n\n        // Verify x params are in 0-1 range\n        if (x1.value < 0 || x1.value > 1 || x2.value < 0 || x2.value > 1) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get valid params for an invalid steps function.\n     *\n     * @param {RegExp.match} match (Invalid) matches from stepsMatch()\n     * @return {?RegExp.match} Valid match or null if the output is not valid\n     */\n    function _getValidStepsParams(match) {\n        var param,\n            def = [ \"5\", \"end\" ],\n            params = def,\n            oldIndex = match.index, // we need to store the old match.index to re-set the index afterwards\n            originalString = match[0];\n\n        if (match) {\n            match = match[1].split(\",\");\n        }\n\n        if (match) {\n            if (match[0]) {\n                param = match[0].replace(/[\\s\\\"']/g, \"\"); // replace possible trailing whitespace or leading quotes\n                param = _convertToNumber(param);\n\n                // Verify number_of_params is a number\n                // If not, replace it with the default value\n                if (!param.isNumber) {\n                    param.value = def[0];\n\n                // Round number_of_params to an integer\n                } else if (param.value) {\n                    param.value = Math.floor(param.value);\n                }\n\n                // Verify number_of_steps is >= 1\n                // If not, set them to the default value\n                if (param.value < 1) {\n                    param.value = def[0];\n                }\n                params[0] = param.value;\n            }\n            if (match[1]) {\n                // little autocorrect feature: leading s gets 'start', everything else gets 'end'\n                param = match[1].replace(/[\\s\\\"']/g, \"\"); // replace possible trailing whitespace or leading quotes\n                param = param.substr(0, 1);\n                if (param === \"s\") {\n                    params[1] = \"start\";\n                } else {\n                    params[1] = \"end\";\n                }\n            }\n        }\n        params = \"steps(\" + params.join(\", \") + \")\";\n        params = params.match(STEPS_VALID_REGEX);\n\n        if (params) {\n            params.index = oldIndex; // re-set the index here to get the right context\n            params.originalString = originalString;\n            return params;\n        }\n        return null;\n    }\n\n    /**\n     * Validate steps function parameters that are not already validated by regex:\n     *\n     * @param {RegExp.match} match  RegExp Match object with steps function parameters\n     *                              in array position 1 (and optionally 2).\n     * @return {boolean} true if all parameters are valid, otherwise, false\n     */\n    function _validateStepsParams(match) {\n        var count = _convertToNumber(match[1]);\n\n        if (!count.isNumber || count.value < 1 || Math.floor(count.value) !== count.value) {\n            return false;\n        }\n\n        if (match[2] && match[2] !== \"start\" && match[2] !== \"end\") {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Show, hide or update the hint text\n     *\n     * @param {object} hint Editor.hint object of the current InlineTimingFunctionEditor\n     * @param {boolean} show Whether the hint should be shown or hidden\n     * @param {string=} documentCode The invalid code from the document (can be omitted when hiding)\n     * @param {string=} editorCode The valid code that is shown in the Inline Editor (can be omitted when hiding)\n     */\n    function showHideHint(hint, show, documentCode, editorCode) {\n        if (!hint || !hint.elem) {\n            return;\n        }\n\n        if (show) {\n            hint.shown = true;\n            hint.animationInProgress = false;\n            hint.elem.removeClass(\"fadeout\");\n            hint.elem.html(StringUtils.format(Strings.INLINE_TIMING_EDITOR_INVALID, documentCode, editorCode));\n            hint.elem.css(\"display\", \"block\");\n        } else if (hint.shown) {\n            hint.animationInProgress = true;\n            AnimationUtils.animateUsingClass(hint.elem[0], \"fadeout\", 750)\n                .done(function () {\n                    if (hint.animationInProgress) { // do this only if the animation was not cancelled\n                        hint.elem.hide();\n                    }\n                    hint.shown = false;\n                    hint.animationInProgress = false;\n                });\n        } else {\n            hint.elem.hide();\n        }\n    }\n\n    /**\n     * Tag this match with type and return it for chaining\n     *\n     * @param {!RegExp.match} match  RegExp Match object with steps function parameters\n     *                              in array position 1 (and optionally 2).\n     * @param {number} type Either BEZIER or STEP\n     * @return {RegExp.match} Same object that was passed in.\n     */\n    function _tagMatch(match, type) {\n        switch (type) {\n        case BEZIER:\n            match.isBezier = true;\n            break;\n        case STEP:\n            match.isStep = true;\n            break;\n        }\n\n        return match;\n    }\n\n    /**\n     * Match a bezier curve function value from a CSS Declaration or Value.\n     *\n     * Matches returned from this function must be handled in\n     * BezierCurveEditor._getCubicBezierCoords().\n     *\n     * @param {string} str  Input string.\n     * @param {!boolean} lax  Parsing mode where:\n     *          lax=false Input is a Full or partial line containing CSS Declaration.\n     *                    This is the more strict search used for initial detection.\n     *          lax=true  Input is a previously parsed value. This is the less strict search\n     *                    used to convert previously parsed values to RegExp match format.\n     * @return {!RegExpMatch}\n     */\n    function bezierCurveMatch(str, lax) {\n        var match;\n\n        // First look for any cubic-bezier().\n        match = str.match(BEZIER_CURVE_VALID_REGEX);\n        if (match && _validateCubicBezierParams(match)) { // cubic-bezier() with valid params\n            return _tagMatch(match, BEZIER);\n        }\n\n        match = str.match(BEZIER_CURVE_GENERAL_REGEX);\n        if (match) {\n            match = _getValidBezierParams(match);\n            if (match && _validateCubicBezierParams(match)) {\n                return _tagMatch(match, BEZIER);\n            }  // this should not happen!\n            window.console.log(\"brackets-cubic-bezier: TimingFunctionUtils._getValidBezierParams created invalid code\");\n\n        }\n\n        // Next look for the ease functions (which are special cases of cubic-bezier())\n        if (lax) {\n            // For lax parsing, just look for the keywords\n            match = str.match(EASE_LAX_REGEX);\n            if (match) {\n                return _tagMatch(match, BEZIER);\n            }\n        } else {\n            // For strict parsing, start with a syntax verifying search\n            match = str.match(EASE_STRICT_REGEX);\n            if (match) {\n                // return exact match to keyword that we need for later replacement\n                return _tagMatch(str.match(EASE_LAX_REGEX), BEZIER);\n            }\n        }\n\n        // Final case is linear.\n        if (lax) {\n            // For lax parsing, just look for the keyword\n            match = str.match(LINEAR_LAX_REGEX);\n            if (match) {\n                return _tagMatch(match, BEZIER);\n            }\n        } else {\n            // The linear keyword can occur in other values, so for strict parsing we\n            // only detect when it's on same line as \"transition\" or \"animation\"\n            match = str.match(LINEAR_STRICT_REGEX);\n            if (match) {\n                // return exact match to keyword that we need for later replacement\n                return _tagMatch(str.match(LINEAR_LAX_REGEX), BEZIER);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Match a steps function value from a CSS Declaration or Value.\n     *\n     * Matches returned from this function must be handled in\n     * BezierCurveEditor._getCubicBezierCoords().\n     *\n     * @param {string} str  Input string.\n     * @param {!boolean} lax  Parsing mode where:\n     *          lax=false Input is a Full or partial line containing CSS Declaration.\n     *                    This is the more strict search used for initial detection.\n     *          lax=true  Input is a previously parsed value. This is the less strict search\n     *                    used to convert previously parsed values to RegExp match format.\n     * @return {!RegExpMatch}\n     */\n    function stepsMatch(str, lax) {\n        var match;\n\n        // First look for any steps().\n        match = str.match(STEPS_VALID_REGEX);\n        if (match && _validateStepsParams(match)) { // cubic-bezier() with valid params\n            return _tagMatch(match, STEP);\n        }\n\n        match = str.match(STEPS_GENERAL_REGEX);\n        if (match) {\n            match = _getValidStepsParams(match);\n            if (match && _validateStepsParams(match)) {\n                return _tagMatch(match, STEP);\n            }  // this should not happen!\n            window.console.log(\"brackets-steps: TimingFunctionUtils._getValidStepsParams created invalid code\");\n\n        }\n\n        // Next look for the step functions (which are special cases of steps())\n        if (lax) {\n            // For lax parsing, just look for the keywords\n            match = str.match(STEP_LAX_REGEX);\n            if (match) {\n                return _tagMatch(match, STEP);\n            }\n        } else {\n            // For strict parsing, start with a syntax verifying search\n            match = str.match(STEP_STRICT_REGEX);\n            if (match) {\n                // return exact match to keyword that we need for later replacement\n                return _tagMatch(str.match(STEP_LAX_REGEX), STEP);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Match a timing function value from a CSS Declaration or Value.\n     *\n     * Matches returned from this function must be handled in\n     * BezierCurveEditor._getCubicBezierCoords().\n     *\n     * @param {string} str  Input string.\n     * @param {!boolean} lax  Parsing mode where:\n     *          lax=false Input is a Full or partial line containing CSS Declaration.\n     *                    This is the more strict search used for initial detection.\n     *          lax=true  Input is a previously parsed value. This is the less strict search\n     *                    used to convert previously parsed values to RegExp match format.\n     * @return {!RegExpMatch}\n     */\n    function timingFunctionMatch(str, lax) {\n        return bezierCurveMatch(str, lax) || stepsMatch(str, lax);\n    }\n\n    // Define public API\n    exports.timingFunctionMatch = timingFunctionMatch;\n    exports.bezierCurveMatch    = bezierCurveMatch;\n    exports.stepsMatch          = stepsMatch;\n    exports.showHideHint        = showHideHint;\n});\n"],"file":"TimingFunctionUtils.js"}
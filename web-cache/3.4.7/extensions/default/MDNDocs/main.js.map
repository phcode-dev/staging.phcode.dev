{"version":3,"sources":["extensions/default/MDNDocs/main.js"],"names":["define","require","exports","module","_","brackets","getModule","EditorManager","FileSystem","FileUtils","CSSUtils","HTMLUtils","ExtensionUtils","Metrics","InlineDocsViewer","promiseCache","getDocs","fileName","result","$","Deferred","path","getModulePath","file","getFileForPath","readAsText","done","text","jsonData","JSON","parse","ex","console","error","reject","resolve","fail","err","promise","inlineProvider","hostEditor","pos","jsonFile","propInfo","propQueue","langId","getLanguageForSelection","getId","supportedLangs","isQuickDocAvailable","css","scss","less","html","countEvent","sel","getSelection","start","line","end","getTagInfo","position","tokenType","ATTR_NAME","attr","name","push","toLowerCase","tagName","getInfoAtPos","replace","length","docs","displayName","propDetails","propName","find","hasOwnProperty","substr","lastIndexOf","inlineWidget","load","registerInlineDocsProvider","_getDocs","_inlineProvider"],"mappings":"AAqBAA,OAAO,SAAUC,QAASC,QAASC,QAI/B,IAAIC,EAAuBC,SAASC,UAAU,qBAC1CC,cAAuBF,SAASC,UAAU,wBAC1CE,WAAuBH,SAASC,UAAU,yBAC1CG,UAAuBJ,SAASC,UAAU,kBAC1CI,SAAuBL,SAASC,UAAU,qBAC1CK,UAAuBN,SAASC,UAAU,sBAC1CM,eAAuBP,SAASC,UAAU,wBAC1CO,QAAuBR,SAASC,UAAU,iBAG1CQ,iBAAmBb,QAAQ,oBAM3Bc,aAAe,GAQnB,SAASC,QAAQC,UACb,IAAKF,aAAaE,UAAW,CACzB,IAAIC,OAAS,IAAIC,EAAEC,SAEfC,KAAOT,eAAeU,cAAcnB,OAAQc,UAC5CM,KAAOf,WAAWgB,eAAeH,MAErCZ,UAAUgB,WAAWF,MAChBG,KAAK,SAAUC,MACZ,IAAIC,SACJ,IACIA,SAAWC,KAAKC,MAAMH,MACxB,MAAOI,IACLC,QAAQC,MAAM,qCAAsCF,IACpDb,OAAOgB,SAEXhB,OAAOiB,QAAQP,YAElBQ,KAAK,SAAUC,KACZL,QAAQC,MAAM,0CAA2CI,KACzDnB,OAAOgB,WAGfnB,aAAaE,UAAYC,OAAOoB,UAGpC,OAAOvB,aAAaE,UAWxB,SAASsB,eAAeC,WAAYC,KAChC,IAAIC,SAAUC,SACVC,UAAY,GACZC,OAASL,WAAWM,0BAA0BC,QAC9CC,eAMAC,oBAGJ,KAH0BJ,OANL,CACbK,KAAO,EACPC,MAAQ,EACRC,MAAQ,EACRC,MAAQ,GAEkCR,SAAW,GAIzD,OAAO,KAIXhC,QAAQyC,WACJ,UACA,WACA,OAIJ,IAAIC,IAAMf,WAAWgB,eACrB,GAAID,IAAIE,MAAMC,OAASH,IAAII,IAAID,KAC3B,OAAO,KAyBX,GAtBe,SAAXb,QACAH,SAAW,aACXC,SAAWhC,UAAUiD,WAAWpB,WAAYe,IAAIE,QACnCI,SAASC,YAAcnD,UAAUoD,WAAapB,SAASqB,MAAQrB,SAASqB,KAAKC,MAEtFrB,UAAUsB,KAAKvB,SAASqB,KAAKC,KAAKE,eAElCxB,SAASyB,UACTzB,SAAWA,SAASyB,QAAQD,cAC5BvB,UAAUsB,KAAK,IAAMvB,SAAW,QAGpCD,SAAW,YACXC,SAAWjC,SAAS2D,aAAa7B,WAAYe,IAAIE,QACpCQ,OACTrB,UAAUsB,KAAKvB,SAASsB,MAExBrB,UAAUsB,KAAKvB,SAASsB,KAAKK,QAAQ,yBAA0B,OAKnE1B,UAAU2B,OAAQ,CAClB,IAAIrD,OAAS,IAAIC,EAAEC,SA4BnB,OAzBAJ,QAAQ0B,UACHhB,KAAK,SAAU8C,MAGZ,IAAIC,YAAaC,YACbC,SAAWvE,EAAEwE,KAAKhC,UAAW,SAAU+B,UACnC,OAAOH,KAAKK,eAAeF,YAOnC,GAJIA,WACAD,YAAcF,KAAKG,UACnBF,YAAcE,SAASG,OAAOH,SAASI,YAAY,KAAO,IAE1DL,YAAa,CACb,IAAIM,aAAe,IAAIlE,iBAAiB2D,YAAaC,aACrDM,aAAaC,KAAKzC,YAClBtB,OAAOiB,QAAQ6C,mBAEf9D,OAAOgB,WAGdE,KAAK,WACFlB,OAAOgB,WAGRhB,OAAOoB,UAGlB,OAAO,KAKX/B,cAAc2E,2BAA2B3C,gBAEzCrC,QAAQiF,SAAmBnE,QAC3Bd,QAAQkF,gBAAmB7C","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Core modules\n    var _                    = brackets.getModule(\"thirdparty/lodash\"),\n        EditorManager        = brackets.getModule(\"editor/EditorManager\"),\n        FileSystem           = brackets.getModule(\"filesystem/FileSystem\"),\n        FileUtils            = brackets.getModule(\"file/FileUtils\"),\n        CSSUtils             = brackets.getModule(\"language/CSSUtils\"),\n        HTMLUtils            = brackets.getModule(\"language/HTMLUtils\"),\n        ExtensionUtils       = brackets.getModule(\"utils/ExtensionUtils\"),\n        Metrics              = brackets.getModule(\"utils/Metrics\");\n\n    // Extension modules\n    var InlineDocsViewer = require(\"InlineDocsViewer\");\n\n\n    /*\n     * Caches docs promises\n     */\n    var promiseCache = {};\n\n    /**\n     * Lazily loads JSON docs files. Returns a Promise the is resolved with the parsed Object, or\n     * rejected if the file is missing/corrupt.\n     * @param {string} fileName JSON file to load\n     * @return {!$.Promise}\n     */\n    function getDocs(fileName) {\n        if (!promiseCache[fileName]) {\n            var result = new $.Deferred();\n\n            var path = ExtensionUtils.getModulePath(module, fileName),\n                file = FileSystem.getFileForPath(path);\n\n            FileUtils.readAsText(file)\n                .done(function (text) {\n                    var jsonData;\n                    try {\n                        jsonData = JSON.parse(text);\n                    } catch (ex) {\n                        console.error(\"Malformed documentation database: \", ex);\n                        result.reject();\n                    }\n                    result.resolve(jsonData);  // ignored if we already reject()ed above\n                })\n                .fail(function (err) {\n                    console.error(\"Unable to load documentation database: \", err);\n                    result.reject();\n                });\n\n            promiseCache[fileName] = result.promise();\n        }\n\n        return promiseCache[fileName];\n    }\n\n\n    /**\n     * Inline docs provider.\n     *\n     * @param {!Editor} editor\n     * @param {!{line:Number, ch:Number}} pos\n     * @return {?$.Promise} resolved with an InlineWidget; null if we're not going to provide anything\n     */\n    function inlineProvider(hostEditor, pos) {\n        var jsonFile, propInfo,\n            propQueue = [], // priority queue of propNames to try\n            langId = hostEditor.getLanguageForSelection().getId(),\n            supportedLangs = {\n                \"css\": true,\n                \"scss\": true,\n                \"less\": true,\n                \"html\": true\n            },\n            isQuickDocAvailable = langId ? supportedLangs[langId] : -1; // fail if langId is falsy\n\n        // Only provide docs when cursor is in supported language\n        if (!isQuickDocAvailable) {\n            return null;\n        }\n\n        // Send analytics data for Quick Doc open\n        Metrics.countEvent(\n            \"MDNDocs\",\n            \"QuickDoc\",\n            \"css\"\n        );\n\n        // Only provide docs if the selection is within a single line\n        var sel = hostEditor.getSelection();\n        if (sel.start.line !== sel.end.line) {\n            return null;\n        }\n\n        if (langId === \"html\") { // HTML\n            jsonFile = \"html.json\";\n            propInfo = HTMLUtils.getTagInfo(hostEditor, sel.start);\n            if (propInfo.position.tokenType === HTMLUtils.ATTR_NAME && propInfo.attr && propInfo.attr.name) {\n                // we're on an HTML attribute (and not on its value)\n                propQueue.push(propInfo.attr.name.toLowerCase());\n            }\n            if (propInfo.tagName) { // we're somehow on an HTML tag (no matter where exactly)\n                propInfo = propInfo.tagName.toLowerCase();\n                propQueue.push(\"<\" + propInfo + \">\");\n            }\n        } else { // CSS-like language\n            jsonFile = \"css.json\";\n            propInfo = CSSUtils.getInfoAtPos(hostEditor, sel.start);\n            if (propInfo.name) {\n                propQueue.push(propInfo.name);\n                // remove possible vendor prefixes\n                propQueue.push(propInfo.name.replace(/^-(?:webkit|moz|ms|o)-/, \"\"));\n            }\n        }\n\n        // Are we on a supported property? (no matter if info is available for the property)\n        if (propQueue.length) {\n            var result = new $.Deferred();\n\n            // Load JSON file if not done yet\n            getDocs(jsonFile)\n                .done(function (docs) {\n                    // Construct inline widget (if we have docs for this property)\n\n                    var displayName, propDetails,\n                        propName = _.find(propQueue, function (propName) { // find the first property where info is available\n                            return docs.hasOwnProperty(propName);\n                        });\n\n                    if (propName) {\n                        propDetails = docs[propName];\n                        displayName = propName.substr(propName.lastIndexOf(\"/\") + 1);\n                    }\n                    if (propDetails) {\n                        var inlineWidget = new InlineDocsViewer(displayName, propDetails);\n                        inlineWidget.load(hostEditor);\n                        result.resolve(inlineWidget);\n                    } else {\n                        result.reject();\n                    }\n                })\n                .fail(function () {\n                    result.reject();\n                });\n\n            return result.promise();\n\n        }\n        return null;\n\n    }\n\n    // Register as inline docs provider\n    EditorManager.registerInlineDocsProvider(inlineProvider);\n\n    exports._getDocs         = getDocs;\n    exports._inlineProvider  = inlineProvider;\n});\n"],"file":"main.js"}
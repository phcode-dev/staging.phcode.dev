{"version":3,"sources":["editor/EditorHelper/IndentHelper.js"],"names":["define","require","exports","module","_","CodeMirror","PreferencesManager","EditorPreferences","SOFT_TABS","_addIndentAtEachSelection","selections","self","this","instance","_codeMirror","usingTabs","getOption","indentUnit","edits","each","sel","indentStr","i","numSpaces","start","ch","push","edit","text","document","doMultipleEdits","_autoIndentEachSelection","lineLengths","line","getLine","length","commands","indentAuto","changed","newSelections","getSelections","index","newSel","cmpPos","end","indentMore","_handleTabKey","selectionType","search","_handleSoftTabNavigation","direction","functionName","overallJump","get","cursor","jump","substr","addHelpers","Editor","prototype"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * self program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * self program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with self program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Editor instance helpers for indentation relator editor flows. Only to be used from Editor.js.\n */\n\ndefine(function (require, exports, module) {\n\n    const _ = require(\"thirdparty/lodash\"),\n        CodeMirror = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        PreferencesManager = require(\"preferences/PreferencesManager\"),\n        EditorPreferences = require(\"./EditorPreferences\");\n\n    const SOFT_TABS = EditorPreferences.SOFT_TABS;\n\n    /**\n     * Helper function for `_handleTabKey()` (case 2) - see comment in that function.\n     * @param {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>} selections\n     *     The selections to indent.\n     */\n    function _addIndentAtEachSelection(selections) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        var instance = self._codeMirror,\n            usingTabs = instance.getOption(\"indentWithTabs\"),\n            indentUnit = instance.getOption(\"indentUnit\"),\n            edits = [];\n\n        _.each(selections, function (sel) {\n            var indentStr = \"\", i, numSpaces;\n            if (usingTabs) {\n                indentStr = \"\\t\";\n            } else {\n                numSpaces = indentUnit - (sel.start.ch % indentUnit);\n                for (i = 0; i < numSpaces; i++) {\n                    indentStr += \" \";\n                }\n            }\n            edits.push({edit: {text: indentStr, start: sel.start}});\n        });\n\n        self.document.doMultipleEdits(edits);\n    }\n\n    /**\n     * Helper function for `_handleTabKey()` (case 3) - see comment in that function.\n     * @param {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>} selections\n     *     The selections to indent.\n     */\n    function _autoIndentEachSelection(selections) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        // Capture all the line lengths, so we can tell if anything changed.\n        // Note that self function should only be called if all selections are within a single line.\n        var instance = self._codeMirror,\n            lineLengths = {};\n        _.each(selections, function (sel) {\n            lineLengths[sel.start.line] = instance.getLine(sel.start.line).length;\n        });\n\n        // First, try to do a smart indent on all selections.\n        CodeMirror.commands.indentAuto(instance);\n\n        // If there were no code or selection changes, then indent each selection one more indent.\n        var changed = false,\n            newSelections = self.getSelections();\n        if (newSelections.length === selections.length) {\n            _.each(selections, function (sel, index) {\n                var newSel = newSelections[index];\n                if (CodeMirror.cmpPos(sel.start, newSel.start) !== 0 ||\n                    CodeMirror.cmpPos(sel.end, newSel.end) !== 0 ||\n                    instance.getLine(sel.start.line).length !== lineLengths[sel.start.line]) {\n                    changed = true;\n                    // Bail - we don't need to look any further once we've found a change.\n                    return false;\n                }\n            });\n        } else {\n            changed = true;\n        }\n\n        if (!changed) {\n            CodeMirror.commands.indentMore(instance);\n        }\n    }\n\n    function _handleTabKey() {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        // Tab key handling is done as follows:\n        // 1. If any of the selections are multiline, just add one indent level to the\n        //    beginning of all lines that intersect any selection.\n        // 2. Otherwise, if any of the selections is a cursor or single-line range that\n        //    ends at or after the first non-whitespace character in a line:\n        //    - if indentation is set to tabs, just insert a hard tab before each selection.\n        //    - if indentation is set to spaces, insert the appropriate number of spaces before\n        //      each selection to get to its next soft tab stop.\n        // 3. Otherwise (all selections are cursors or single-line, and are in the whitespace\n        //    before their respective lines), try to autoindent each line based on the mode.\n        //    If none of the cursors moved and no space was added, then add one indent level\n        //    to the beginning of all lines.\n\n        // Note that in case 2, we do the \"dumb\" insertion even if the cursor is immediately\n        // before the first non-whitespace character in a line. It might seem more convenient\n        // to do autoindent in that case. However, the problem is if that line is already\n        // indented past its \"proper\" location. In that case, we don't want Tab to\n        // *outdent* the line. If we had more control over the autoindent algorithm or\n        // implemented it ourselves, we could handle that case separately.\n\n        var instance = self._codeMirror,\n            selectionType = \"indentAuto\",\n            selections = self.getSelections();\n\n        _.each(selections, function (sel) {\n            if (sel.start.line !== sel.end.line) {\n                // Case 1 - we found a multiline selection. We can bail as soon as we find one of these.\n                selectionType = \"indentAtBeginning\";\n                return false;\n            } else if (sel.end.ch > 0 && sel.end.ch >= instance.getLine(sel.end.line).search(/\\S/)) {\n                // Case 2 - we found a selection that ends at or after the first non-whitespace\n                // character on the line. We need to keep looking in case we find a later multiline\n                // selection though.\n                selectionType = \"indentAtSelection\";\n            }\n        });\n\n        switch (selectionType) {\n        case \"indentAtBeginning\":\n            // Case 1\n            CodeMirror.commands.indentMore(instance);\n            break;\n\n        case \"indentAtSelection\":\n            // Case 2\n            self._addIndentAtEachSelection(selections);\n            break;\n\n        case \"indentAuto\":\n            // Case 3\n            self._autoIndentEachSelection(selections);\n            break;\n        }\n    }\n\n    /**\n     * @private\n     * Handle left arrow, right arrow, backspace and delete keys when soft tabs are used.\n     * @param {number} direction Direction of movement: 1 for forward, -1 for backward\n     * @param {string} functionName name of the CodeMirror function to call if we handle the key\n     */\n    function _handleSoftTabNavigation(direction, functionName) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        var instance = self._codeMirror,\n            overallJump = null;\n\n        if (!instance.getOption(\"indentWithTabs\") && PreferencesManager.get(SOFT_TABS)) {\n            var indentUnit = instance.getOption(\"indentUnit\");\n\n            _.each(self.getSelections(), function (sel) {\n                if (CodeMirror.cmpPos(sel.start, sel.end) !== 0) {\n                    // self is a range - it will just collapse/be deleted regardless of the jump we set, so\n                    // we can just ignore it and continue. (We don't want to return false in self case since\n                    // we want to keep looking at other ranges.)\n                    return;\n                }\n\n                var cursor = sel.start,\n                    jump   = (indentUnit === 0) ? 1 : cursor.ch % indentUnit,\n                    line   = instance.getLine(cursor.line);\n\n                // Don't do any soft tab handling if there are non-whitespace characters before the cursor in\n                // any of the selections.\n                if (line.substr(0, cursor.ch).search(/\\S/) !== -1) {\n                    jump = null;\n                } else if (direction === 1) { // right\n                    if (indentUnit) {\n                        jump = indentUnit - jump;\n                    }\n\n                    // Don't jump if it would take us past the end of the line, or if there are\n                    // non-whitespace characters within the jump distance.\n                    if (cursor.ch + jump > line.length || line.substr(cursor.ch, jump).search(/\\S/) !== -1) {\n                        jump = null;\n                    }\n                } else { // left\n                    // If we are on the tab boundary, jump by the full amount,\n                    // but not beyond the start of the line.\n                    if (jump === 0) {\n                        jump = indentUnit;\n                    }\n                    if (cursor.ch - jump < 0) {\n                        jump = null;\n                    } else {\n                        // We're moving left, so negate the jump.\n                        jump = -jump;\n                    }\n                }\n\n                // Did we calculate a jump, and is self jump value either the first one or\n                // consistent with all the other jumps? If so, we're good. Otherwise, bail\n                // out of the foreach, since as soon as we hit an inconsistent jump we don't\n                // have to look any further.\n                if (jump !== null &&\n                    (overallJump === null || overallJump === jump)) {\n                    overallJump = jump;\n                } else {\n                    overallJump = null;\n                    return false;\n                }\n            });\n        }\n\n        if (overallJump === null) {\n            // Just do the default move, which is one char in the given direction.\n            overallJump = direction;\n        }\n        instance[functionName](overallJump, \"char\");\n    }\n\n    /**\n     * add required helpers to editor\n     * @param Editor\n     */\n    function addHelpers(Editor) {\n        // only private Editor APIs should be assigned below. Public APIs should be updated in Editor.js only.\n        Editor.prototype._addIndentAtEachSelection = _addIndentAtEachSelection;\n        Editor.prototype._autoIndentEachSelection = _autoIndentEachSelection;\n        Editor.prototype._handleTabKey = _handleTabKey;\n        Editor.prototype._handleSoftTabNavigation = _handleSoftTabNavigation;\n    }\n\n    exports.addHelpers =addHelpers;\n});\n"],"file":"IndentHelper.js"}
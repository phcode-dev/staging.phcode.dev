{"version":3,"sources":["extensions/default/InlineTimingFunctionEditor/InlineTimingFunctionEditor.js"],"names":["define","require","exports","module","InlineWidget","brackets","getModule","BezierCurveEditor","StepEditor","TimingFunctionUtils","lastOriginId","InlineTimingFunctionEditor","timingFunction","startBookmark","endBookmark","this","_timingFunction","_startBookmark","_endBookmark","_isOwnChange","_isHostChange","_origin","_handleTimingFunctionChange","bind","_handleHostDocumentChange","call","prototype","Object","create","constructor","parentClass","timingFunctionEditor","getCurrentRange","start","end","find","line","hostEditor","document","getLine","matches","timingFunctionMatch","substr","ch","originalLength","originalString","length","undefined","clear","_codeMirror","setBookmark","match","timingFunctionString","self","range","batchOperation","replaceRange","newEnd","setSelection","load","apply","arguments","isBezier","$htmlContent","isStep","window","console","log","onAdded","doc","addRef","on","setInlineWidgetHeight","getRootElement","outerHeight","focus","onClosed","destroy","off","releaseRef","handleExternalUpdate","close"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var InlineWidget         = brackets.getModule(\"editor/InlineWidget\").InlineWidget,\n        BezierCurveEditor    = require(\"BezierCurveEditor\").BezierCurveEditor,\n        StepEditor           = require(\"StepEditor\").StepEditor,\n        TimingFunctionUtils  = require(\"TimingFunctionUtils\");\n\n\n    /** @type {number} Global var used to provide a unique ID for each timingFunction editor instance's _origin field. */\n    var lastOriginId = 1;\n\n    /**\n     * Constructor for inline widget containing a BezierCurveEditor control\n     *\n     * @param {!RegExpMatch} timingFunction  RegExp match object of initially selected timingFunction\n     * @param {!CodeMirror.Bookmark} startBookmark\n     * @param {!CodeMirror.Bookmark} endBookmark\n     */\n    function InlineTimingFunctionEditor(timingFunction, startBookmark, endBookmark) {\n        this._timingFunction = timingFunction;\n        this._startBookmark = startBookmark;\n        this._endBookmark = endBookmark;\n        this._isOwnChange = false;\n        this._isHostChange = false;\n        this._origin = \"+InlineTimingFunctionEditor_\" + (lastOriginId++);\n\n        this._handleTimingFunctionChange = this._handleTimingFunctionChange.bind(this);\n        this._handleHostDocumentChange = this._handleHostDocumentChange.bind(this);\n\n        InlineWidget.call(this);\n    }\n\n    InlineTimingFunctionEditor.prototype = Object.create(InlineWidget.prototype);\n    InlineTimingFunctionEditor.prototype.constructor = InlineTimingFunctionEditor;\n    InlineTimingFunctionEditor.prototype.parentClass = InlineWidget.prototype;\n\n    /** @type {!BezierCurveEditor} BezierCurveEditor instance */\n    InlineTimingFunctionEditor.prototype.timingFunctionEditor = null;\n\n    /** @type {!string} Current value of the timing function editor control */\n    InlineTimingFunctionEditor.prototype._timingFunction = null;\n\n    /**\n     * Start of the range of code we're attached to; _startBookmark.find() may by null if sync is lost.\n     * @type {!CodeMirror.Bookmark}\n     */\n    InlineTimingFunctionEditor.prototype._startBookmark = null;\n\n    /**\n     * End of the range of code we're attached to; _endBookmark.find() may by null if sync is lost or even\n     * in some cases when it's not. Call getCurrentRange() for the definitive text range we're attached to.\n     * @type {!CodeMirror.Bookmark}\n     */\n    InlineTimingFunctionEditor.prototype._endBookmark = null;\n\n    /** @type {boolean} True while we're syncing a timing function editor change into the code editor */\n    InlineTimingFunctionEditor.prototype._isOwnChange = null;\n\n    /** @type {boolean} True while we're syncing a code editor change into the timing function editor */\n    InlineTimingFunctionEditor.prototype._isHostChange = null;\n\n    /** @type {number} ID used to identify edits coming from this inline widget for undo batching */\n    InlineTimingFunctionEditor.prototype._origin = null;\n\n\n    /**\n     * Returns the current text range of the timingFunction we're attached to, or null if\n     * we've lost sync with what's in the code.\n     *\n     * @return {?{\n     *              start: {line:number, ch:number},\n     *              end:   {line:number, ch:number},\n     *              match: {RegExpMatch}\n     *          }}\n     */\n    InlineTimingFunctionEditor.prototype.getCurrentRange = function () {\n        var start, end;\n\n        start = this._startBookmark.find();\n        if (!start) {\n            return null;\n        }\n\n        end = this._endBookmark.find();\n        if (!end) {\n            end = { line: start.line };\n        }\n\n        // Even if we think we have a good end bookmark, we want to run the\n        // regexp match to see if there's a valid match that extends past the bookmark.\n        // This can happen if the user deletes the end of the existing timingFunction and then\n        // types some more.\n        // FUTURE: when we migrate to CodeMirror v3, we might be able to use markText()\n        // instead of two bookmarks to track the range. (In our current old version of\n        // CodeMirror v2, markText() isn't robust enough for this case.)\n        var line = this.hostEditor.document.getLine(start.line),\n            matches = TimingFunctionUtils.timingFunctionMatch(line.substr(start.ch), true),\n            originalLength;\n\n        // No longer have a match\n        if (!matches) {\n            return null;\n        }\n\n        originalLength = ((matches.originalString && matches.originalString.length) || matches[0].length);\n        // Note that end.ch is exclusive, so we don't need to add 1 before comparing to\n        // the matched length here.\n        if (end.ch === undefined || (end.ch - start.ch) !== originalLength) {\n            end.ch = start.ch + originalLength;\n            this._endBookmark.clear();\n            this._endBookmark = this.hostEditor._codeMirror.setBookmark(end);\n        }\n\n        if (end.ch === undefined) {\n            // We were unable to resync the end bookmark.\n            return null;\n        }\n        return {\n            start: start,\n            end: end,\n            match: matches,\n            originalLength: originalLength\n        };\n\n    };\n\n    /**\n     * When the timing function editor's selected timingFunction changes, update text in code editor\n     * @param {!string} timingFunctionString\n     */\n    InlineTimingFunctionEditor.prototype._handleTimingFunctionChange = function (timingFunctionString) {\n        var self                = this,\n            timingFunctionMatch = TimingFunctionUtils.timingFunctionMatch(timingFunctionString, true);\n        if (timingFunctionMatch !== this._timingFunction) {\n            var range = this.getCurrentRange();\n            if (!range) {\n                return;\n            }\n\n            // Don't push the change back into the host editor if it came from the host editor.\n            if (!this._isHostChange) {\n                this._isOwnChange = true;\n                this.hostEditor.document.batchOperation(function () {\n                    // Replace old timingFunction in code with the editor's timing function, and select it\n                    self.hostEditor.document.replaceRange(timingFunctionString, range.start, range.end, self._origin);\n                    var newEnd = { line: range.start.line, ch: range.start.ch + timingFunctionString.length };\n                    self.hostEditor.setSelection(range.start, newEnd, false, 0, self._origin);\n                });\n                this._isOwnChange = false;\n            }\n\n            this._timingFunction = timingFunctionMatch;\n        }\n    };\n\n    /**\n     * @override\n     * @param {!Editor} hostEditor\n     */\n    InlineTimingFunctionEditor.prototype.load = function (hostEditor) {\n        InlineTimingFunctionEditor.prototype.parentClass.load.apply(this, arguments);\n\n        // Create appropriate timing function editor control\n        if (this._timingFunction.isBezier) {\n            this.timingFunctionEditor = new BezierCurveEditor(this.$htmlContent, this._timingFunction, this._handleTimingFunctionChange);\n        } else if (this._timingFunction.isStep) {\n            this.timingFunctionEditor = new StepEditor(this.$htmlContent, this._timingFunction, this._handleTimingFunctionChange);\n        } else {\n            window.console.log(\"InlineTimingFunctionEditor.load tried to load an unkown timing function type\");\n        }\n    };\n\n    /**\n     * @override\n     * Perform sizing & focus once we've been added to Editor's DOM\n     */\n    InlineTimingFunctionEditor.prototype.onAdded = function () {\n        InlineTimingFunctionEditor.prototype.parentClass.onAdded.apply(this, arguments);\n\n        var doc = this.hostEditor.document;\n        doc.addRef();\n        doc.on(\"change\", this._handleHostDocumentChange);\n\n        this.hostEditor.setInlineWidgetHeight(this, this.timingFunctionEditor.getRootElement().outerHeight(), true);\n\n        this.timingFunctionEditor.focus();\n    };\n\n    /**\n     * @override\n     * Called whenever the inline widget is closed, whether automatically or explicitly\n     */\n    InlineTimingFunctionEditor.prototype.onClosed = function () {\n        InlineTimingFunctionEditor.prototype.parentClass.onClosed.apply(this, arguments);\n\n        this.timingFunctionEditor.destroy();\n\n        if (this._startBookmark) {\n            this._startBookmark.clear();\n        }\n        if (this._endBookmark) {\n            this._endBookmark.clear();\n        }\n\n        var doc = this.hostEditor.document;\n        doc.off(\"change\", this._handleHostDocumentChange);\n        doc.releaseRef();\n    };\n\n    /**\n     * When text in the code editor changes, update timing function editor to reflect it\n     */\n    InlineTimingFunctionEditor.prototype._handleHostDocumentChange = function () {\n        // Don't push the change into the timingFunction editor if it came from the timingFunction editor.\n        if (this._isOwnChange) {\n            return;\n        }\n\n        var range = this.getCurrentRange();\n        if (range) {\n            if (range.match !== this._timingFunction) {\n                this._isHostChange = true;\n                this._isHostChange = false;\n                this._timingFunction = range.match;\n                this.timingFunctionEditor.handleExternalUpdate(range.match);\n            }\n        } else {\n            // The edit caused our range to become invalid. Close the editor.\n            this.close();\n        }\n    };\n\n    exports.InlineTimingFunctionEditor = InlineTimingFunctionEditor;\n});\n"],"file":"InlineTimingFunctionEditor.js"}
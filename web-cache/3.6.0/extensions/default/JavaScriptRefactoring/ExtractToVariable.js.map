{"version":3,"sources":["extensions/default/JavaScriptRefactoring/ExtractToVariable.js"],"names":["define","require","exports","module","ASTWalker","brackets","getModule","EditorManager","Session","RefactoringUtils","Strings","InlineMenu","session","extract","scopes","parentStatement","expns","text","insertPosition","varType","varName","getUniqueIdentifierName","varDeclaration","parentStatementStartPos","editor","posFromIndex","start","insertStartPos","selections","doc","document","replaceExpnIndex","posToIndent","edits","type","isEqual","expression","line","ch","adjustPosForChange","split","i","length","end","push","edit","selection","batchOperation","replaceRange","doMultipleEdits","primary","setSelections","_codeMirror","indentLine","findAllExpressions","parentBlockStatement","expn","obj","node","getText","substr","simple","getExpressions","ast","s","e","findSurroundExpression","checkExpnEquality","find","extractToVariable","getActiveEditor","parentExpn","getExpression","findSurroundASTNode","getScopeData","done","scope","firstExpnsScopes","getAllScopes","insertPostion","parentScope","body","insertNode","originNode","displayErrorMessageAtCursor","ERROR_EXTRACTTO_VARIABLE_NOT_VALID","handleExtractToVariable","getSelections","ERROR_EXTRACTTO_VARIABLE_MULTICURSORS","initializeSession","getSelection","retObj","normalizeText","getSelectedText","indexFromPos","inlineMenu","getAST","hasSelection","forEach","index","value","sort","a","b","firstExpnLength","numLines","filter","name","indexOf","callExtractToVariable","id","EXTRACTTO_VARIABLE_SELECT_EXPRESSION","onHover","expnId","off","isLineVisible","on","openRemovedMenu","setSelection","open","onSelect","close","onClose","fail","ERROR_TERN_FAILED","startPos","endPos","expnscope"],"mappings":"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","sourcesContent":["/*\n*  Copyright (c) 2021 - present core.ai . All rights reserved.\n *  Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n*\n* Permission is hereby granted, free of charge, to any person obtaining a\n* copy of this software and associated documentation files (the \"Software\"),\n* to deal in the Software without restriction, including without limitation\n* the rights to use, copy, modify, merge, publish, distribute, sublicense,\n* and/or sell copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n* DEALINGS IN THE SOFTWARE.\n*\n*/\n\ndefine(function(require, exports, module) {\n\n\n    var ASTWalker           = brackets.getModule(\"thirdparty/acorn/dist/walk\"),\n        EditorManager       = brackets.getModule(\"editor/EditorManager\"),\n        Session             = brackets.getModule(\"JSUtils/Session\"),\n        RefactoringUtils    = require(\"RefactoringUtils\"),\n        Strings             = brackets.getModule(\"strings\"),\n        InlineMenu          = brackets.getModule(\"widgets/InlineMenu\").InlineMenu;\n\n    var session = null;\n\n    /**\n     * Does the actual extraction. i.e Replacing the text, Creating a variable\n     * and multi select variable names\n     */\n    function extract(scopes, parentStatement, expns, text, insertPosition) {\n        var varType          = \"var\",\n            varName          = RefactoringUtils.getUniqueIdentifierName(scopes, \"extracted\"),\n            varDeclaration   = varType + \" \" + varName + \" = \" + text + \";\\n\",\n            parentStatementStartPos = session.editor.posFromIndex(parentStatement.start),\n            insertStartPos   = insertPosition || parentStatementStartPos,\n            selections       = [],\n            doc              = session.editor.document,\n            replaceExpnIndex = 0,\n            posToIndent,\n            edits            = [];\n\n        // If parent statement is expression statement, then just append var declaration\n        // Ex: \"add(1, 2)\" will become \"var extracted = add(1, 2)\"\n        if (parentStatement.type === \"ExpressionStatement\" &&\n                RefactoringUtils.isEqual(parentStatement.expression, expns[0]) &&\n                insertStartPos.line === parentStatementStartPos.line &&\n                insertStartPos.ch === parentStatementStartPos.ch) {\n            varDeclaration = varType + \" \" + varName + \" = \";\n            replaceExpnIndex = 1;\n        }\n\n        posToIndent = doc.adjustPosForChange(insertStartPos, varDeclaration.split(\"\\n\"), insertStartPos, insertStartPos);\n\n        // adjust pos for change\n        for (var i = replaceExpnIndex; i < expns.length; ++i) {\n            expns[i].start  = session.editor.posFromIndex(expns[i].start);\n            expns[i].end    = session.editor.posFromIndex(expns[i].end);\n            expns[i].start  = doc.adjustPosForChange(expns[i].start, varDeclaration.split(\"\\n\"), insertStartPos, insertStartPos);\n            expns[i].end    = doc.adjustPosForChange(expns[i].end, varDeclaration.split(\"\\n\"), insertStartPos, insertStartPos);\n\n            edits.push({\n                edit: {\n                    text: varName,\n                    start: expns[i].start,\n                    end: expns[i].end\n                },\n                selection: {\n                    start: expns[i].start,\n                    end: {line: expns[i].start.line, ch: expns[i].start.ch + varName.length}\n                }\n            });\n        }\n\n        // Replace and multi-select\n        doc.batchOperation(function() {\n            doc.replaceRange(varDeclaration, insertStartPos);\n\n            selections = doc.doMultipleEdits(edits);\n            selections.push({\n                start: {line: insertStartPos.line, ch: insertStartPos.ch + varType.length + 1},\n                end: {line: insertStartPos.line, ch: insertStartPos.ch + varType.length + varName.length + 1},\n                primary: true\n            });\n            session.editor.setSelections(selections);\n            session.editor._codeMirror.indentLine(posToIndent.line, \"smart\");\n        });\n    }\n\n    /**\n     * Find all expressions in the parentBlockStatement that are same as expn\n     * @param {!ASTNode} parentBlockStatement\n     * @param {!ASTNode} expn\n     * @param {!string} text - text of the expression\n     * @return {!Array.<ASTNode>}\n     */\n    function findAllExpressions(parentBlockStatement, expn, text) {\n        var doc   = session.editor.document,\n            obj   = {},\n            expns = [];\n\n        // find all references of the expression\n        obj[expn.type] = function(node) {\n            if (text === doc.getText().substr(node.start, node.end - node.start)) {\n                expns.push(node);\n            }\n        };\n        ASTWalker.simple(parentBlockStatement, obj);\n\n        return expns;\n    }\n\n    /**\n     * Gets the surrounding expressions of start and end offset\n     * @param {!ASTNode} ast - the ast of the complete file\n     * @param {!number} start - the start offset\n     * @param {!number} end - the end offset\n     * @return {!Array.<ASTNode>}\n     */\n    function getExpressions(ast, start, end) {\n        var expns = [],\n            s     = start,\n            e     = end,\n            expn;\n\n        while (true) {\n            expn = RefactoringUtils.findSurroundExpression(ast, {start: s, end: e});\n            if (!expn) {\n                break;\n            }\n            expns.push(expn);\n            s = expn.start - 1;\n        }\n\n        s = start;\n        e = end;\n\n        function checkExpnEquality(e) {\n            return e.start === expn.start && e.end === expn.end;\n        }\n\n        while (true) {\n            expn = RefactoringUtils.findSurroundExpression(ast, {start: s, end: e});\n            if (!expn) {\n                break;\n            }\n            e = expn.end + 1;\n\n            // if expn already added, continue\n            if (expns.find(checkExpnEquality)) {\n                continue;\n            }\n\n            expns.push(expn);\n        }\n\n        return expns;\n    }\n\n    /**\n     * Creates params needed for extraction and calls extract\n     * extract() does the actual extraction\n     */\n    function extractToVariable(ast, start, end, text, scopes) {\n        var doc                   = session.editor.document,\n            editor = EditorManager.getActiveEditor(),\n            parentExpn            = RefactoringUtils.getExpression(ast, start, end, doc.getText()),\n            expns                 = [],\n            parentBlockStatement,\n            parentStatement;\n\n        if (!parentExpn) {\n            session.editor.displayErrorMessageAtCursor(Strings.ERROR_EXTRACTTO_VARIABLE_NOT_VALID);\n            return;\n        }\n\n        // Find all expressions only if selected expn is not a subexpression\n        // In case of subexpressions, ast cannot be used to find all expressions\n        if (doc.getText().substr(parentExpn.start, parentExpn.end - parentExpn.start) === text) {\n            parentBlockStatement = RefactoringUtils.findSurroundASTNode(ast, parentExpn, [\"BlockStatement\", \"Program\"]);\n            expns                = findAllExpressions(parentBlockStatement, parentExpn, text);\n\n            RefactoringUtils.getScopeData(session, editor.posFromIndex(expns[0].start)).done(function(scope) {\n                var firstExpnsScopes = RefactoringUtils.getAllScopes(ast, scope, doc.getText()),\n                    insertPostion;\n                parentStatement = RefactoringUtils.findSurroundASTNode(ast, expns[0], [\"Statement\"]);\n                if (scopes.length < firstExpnsScopes.length) {\n                    var parentScope;\n                    if (expns[0].body && expns[0].body.type === \"BlockStatement\") {\n                        parentScope = firstExpnsScopes[firstExpnsScopes.length - scopes.length];\n                    } else {\n                        parentScope = firstExpnsScopes[firstExpnsScopes.length - scopes.length - 1];\n                    }\n\n                    var insertNode = RefactoringUtils.findSurroundASTNode(ast, parentScope.originNode, [\"Statement\"]);\n                    if (insertNode) {\n                        insertPostion = session.editor.posFromIndex(insertNode.start);\n                    }\n                }\n                extract(scopes, parentStatement, expns, text, insertPostion);\n            });\n        } else {\n            parentStatement = RefactoringUtils.findSurroundASTNode(ast, parentExpn, [\"Statement\"]);\n            extract(scopes, parentStatement, [{ start: start, end: end }], text);\n        }\n    }\n\n\n    /**\n     * Main function that handles extract to variable\n     */\n    function handleExtractToVariable() {\n        var editor = EditorManager.getActiveEditor();\n\n        if (editor.getSelections().length > 1) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_EXTRACTTO_VARIABLE_MULTICURSORS);\n            return;\n        }\n\n        initializeSession(editor);\n\n        var selection = editor.getSelection(),\n            doc       = editor.document,\n            retObj    = RefactoringUtils.normalizeText(editor.getSelectedText(), editor.indexFromPos(selection.start),\n                        editor.indexFromPos(selection.end), true),\n            text      = retObj.text,\n            start     = retObj.start,\n            end       = retObj.end,\n            ast,\n            scopes,\n            expns,\n            inlineMenu;\n\n        function callExtractToVariable(startPos, endPos, value) {\n            RefactoringUtils.getScopeData(session, editor.posFromIndex(startPos))\n                .done(function(expnscope) {\n                    scopes = RefactoringUtils.getAllScopes(ast, expnscope, doc.getText());\n                    extractToVariable(ast, startPos, endPos, value, scopes);\n                }).fail(function() {\n                    editor.displayErrorMessageAtCursor(Strings.ERROR_TERN_FAILED);\n                });\n        }\n\n        RefactoringUtils.getScopeData(session, editor.posFromIndex(start)).done(function(scope) {\n            ast = RefactoringUtils.getAST(doc.getText());\n            scopes = RefactoringUtils.getAllScopes(ast, scope, doc.getText());\n\n            if (editor.hasSelection()) {\n                extractToVariable(ast, start, end, text, scopes);\n            } else {\n                expns = getExpressions(ast, start, end);\n\n                expns.forEach(function(expn, index) {\n                    expn.value = doc.getText().substr(expn.start, expn.end - expn.start);\n                });\n\n                // Sort expressions by their length\n                expns.sort(function(a, b) {\n                    return a.value.length - b.value.length;\n                });\n\n                if (!expns || !expns.length) {\n                    session.editor.displayErrorMessageAtCursor(Strings.ERROR_EXTRACTTO_VARIABLE_NOT_VALID);\n                    return;\n                }\n\n                // Filter expns based on length of first surrounding expression\n                var firstExpnLength = RefactoringUtils.numLines(expns[0].value);\n                expns = expns.filter(function(expn) {\n                    return RefactoringUtils.numLines(expn.value) === firstExpnLength;\n                });\n\n                // Add name for the expression based on its value\n                expns.forEach(function(expn, index) {\n                    // If expn name is multi-line, display only first line\n                    if (RefactoringUtils.numLines(expn.value) > 1) {\n                        expn.name = expn.value.substr(0, expn.value.indexOf(\"\\n\")) + \"...\";\n                    } else {\n                        expn.name = expn.value;\n                    }\n                });\n\n                // If only one surround expression, extract\n                if (expns.length === 1) {\n                    callExtractToVariable(expns[0].start, expns[0].end, expns[0].value);\n                    return;\n                }\n\n                expns.forEach(function(expn, index) {\n                    expn.id = index;\n                });\n\n                // UI for extract to variable\n                inlineMenu = new InlineMenu(session.editor, Strings.EXTRACTTO_VARIABLE_SELECT_EXPRESSION);\n\n                inlineMenu.onHover(function (expnId) {\n                    // Remove the scroll Handlers If already Attached.\n                    editor.off(\"scroll.inlinemenu\");\n                    // Add a scroll handler If Selection Range is not View.\n                    // This is Added for a Bug, where Menu used not to open for the first Time\n                    if(!editor.isLineVisible(editor.posFromIndex(expns[expnId].end).line)) {\n                        editor.on(\"scroll.inlinemenu\", function() {\n                            // Remove the Handlers so that If scroll event is triggerd again by any other operation\n                            // Menu should not be reopened.\n                            // Menu Should be reopened only if Scroll event is triggered by onHover.\n                            editor.off(\"scroll.inlinemenu\");\n                            inlineMenu.openRemovedMenu();\n                        });\n                    }\n                    editor.setSelection(editor.posFromIndex(expns[expnId].start), editor.posFromIndex(expns[expnId].end));\n                });\n\n                inlineMenu.open(expns);\n\n                inlineMenu.onSelect(function (expnId) {\n                    callExtractToVariable(expns[expnId].start, expns[expnId].end, expns[expnId].value);\n                    inlineMenu.close();\n                });\n\n                inlineMenu.onClose(function () {\n                    inlineMenu.close();\n                });\n            }\n        }).fail(function() {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_TERN_FAILED);\n        });\n    }\n\n    /**\n     * Creates a new session from editor and stores it in session global variable\n     */\n    function initializeSession(editor) {\n        session = new Session(editor);\n    }\n\n    exports.handleExtractToVariable = handleExtractToVariable;\n});\n"],"file":"ExtractToVariable.js"}
{"version":3,"sources":["JSUtils/Session.js"],"names":["define","require","exports","module","StringMatch","TokenUtils","LanguageManager","HTMLUtils","HintUtils","ScopeManager","Acorn","Acorn_Loose","Session","editor","this","path","document","file","fullPath","ternHints","ternGuesses","fnType","builtins","getLexicalState","token","state","lexical","localState","penalizeUnderscoreValueCompare","a","b","aName","value","toLowerCase","bName","prototype","_getBuiltins","getBuiltins","push","getPath","getCursor","getCursorPos","getLine","line","doc","getOffset","cursor","getOffsetFromCursor","indexFromPos","getToken","cm","_codeMirror","getTokenAt","getNextTokenOnLine","getNextCursorOnLine","ch","length","_getPreviousToken","prev","start","test","string","getNextToken","skipWhitespace","next","end","getQuery","query","maybeIdentifier","substring","getContext","depth","undefined","findPreviousDot","getFunctionInfo","inFunctionCall","functionCallPos","self","foundCall","isOnFunctionIdentifier","type","nextToken","localLexical","localCursor","isInFunctionalCall","lex","info","col","column","e","found","Math","max","charAt","getType","propertyLookup","context","property","getHints","matcher","MAX_DISPLAYED_HINTS","needGuesses","hints","isBuiltin","origin","indexOf","filterWithQueryAndMatcher","matchResults","$","map","hint","searchResult","match","guess","keyword","literal","url","showFunctionType","builtin","multiFieldSort","concat","LITERALS","KEYWORDS","slice","setTernHints","newHints","setGuesses","newGuesses","setFnType","newFnType","setFunctionCallPos","getParameterHint","fnHint","fragment","getRange","ast","parse","startOffset","cursorOffset","offset","node","body","currentArg","expression","expressions","left","right","args","i","n","lastEnd","text","parameters","currentIndex","getJavascriptText","getLanguageForPath","getId","scriptBlocks","findBlocks","htmlStart","forEach","scriptBlock","htmlText","replace","getText","isFunctionName","prevToken"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\ndefine(function (require, exports, module) {\n\n\n    var StringMatch     = require(\"utils/StringMatch\"),\n        TokenUtils      = require(\"utils/TokenUtils\"),\n        LanguageManager = require(\"language/LanguageManager\"),\n        HTMLUtils       = require(\"language/HTMLUtils\"),\n        HintUtils       = require(\"JSUtils/HintUtils\"),\n        ScopeManager    = require(\"JSUtils/ScopeManager\"),\n        Acorn           = require(\"thirdparty/acorn/dist/acorn\"),\n        Acorn_Loose     = require(\"thirdparty/acorn/dist/acorn_loose\");\n\n    /**\n     * Session objects encapsulate state associated with a hinting session\n     * and provide methods for updating and querying the session.\n     *\n     * @constructor\n     * @param {Editor} editor - the editor context for the session\n     */\n    function Session(editor) {\n        this.editor = editor;\n        this.path = editor.document.file.fullPath;\n        this.ternHints = [];\n        this.ternGuesses = null;\n        this.fnType = null;\n        this.builtins = null;\n    }\n\n    /**\n     *  Get the builtin libraries tern is using.\n     *\n     * @return {Array.<string>} - array of library names.\n     * @private\n     */\n    Session.prototype._getBuiltins = function () {\n        if (!this.builtins) {\n            this.builtins = ScopeManager.getBuiltins();\n            this.builtins.push(\"requirejs.js\");     // consider these globals as well.\n        }\n\n        return this.builtins;\n    };\n\n    /**\n     * Get the name of the file associated with the current session\n     *\n     * @return {string} - the full pathname of the file associated with the\n     *      current session\n     */\n    Session.prototype.getPath = function () {\n        return this.path;\n    };\n\n    /**\n     * Get the current cursor position.\n     *\n     * @return {{line: number, ch: number}} - the current cursor position\n     */\n    Session.prototype.getCursor = function () {\n        return this.editor.getCursorPos();\n    };\n\n    /**\n     * Get the text of a line.\n     *\n     * @param {number} line - the line number\n     * @return {string} - the text of the line\n     */\n    Session.prototype.getLine = function (line) {\n        var doc = this.editor.document;\n        return doc.getLine(line);\n    };\n\n    /**\n     * Get the offset of the current cursor position\n     *\n     * @return {number} - the offset into the current document of the current\n     *      cursor\n     */\n    Session.prototype.getOffset = function () {\n        var cursor = this.getCursor();\n\n        return this.getOffsetFromCursor(cursor);\n    };\n\n    /**\n     * Get the offset of a cursor position\n     *\n     * @param {{line: number, ch: number}} the line/col info\n     * @return {number} - the offset into the current document of the cursor\n     */\n    Session.prototype.getOffsetFromCursor = function (cursor) {\n        return this.editor.indexFromPos(cursor);\n    };\n\n    /**\n     * Get the token at the given cursor position, or at the current cursor\n     * if none is given.\n     *\n     * @param {?{line: number, ch: number}} cursor - the cursor position\n     *      at which to retrieve a token\n     * @return {Object} - the CodeMirror token at the given cursor position\n     */\n    Session.prototype.getToken = function (cursor) {\n        var cm = this.editor._codeMirror;\n\n        if (cursor) {\n            return TokenUtils.getTokenAt(cm, cursor);\n        }\n        return TokenUtils.getTokenAt(cm, this.getCursor());\n\n    };\n\n    /**\n     * Get the token after the one at the given cursor position\n     *\n     * @param {{line: number, ch: number}} cursor - cursor position before\n     *      which a token should be retrieved\n     * @return {Object} - the CodeMirror token after the one at the given\n     *      cursor position\n     */\n    Session.prototype.getNextTokenOnLine = function (cursor) {\n        cursor = this.getNextCursorOnLine(cursor);\n        if (cursor) {\n            return this.getToken(cursor);\n        }\n\n        return null;\n    };\n\n    /**\n     * Get the next cursor position on the line, or null if there isn't one.\n     *\n     * @return {?{line: number, ch: number}} - the cursor position\n     *      immediately following the current cursor position, or null if\n     *      none exists.\n     */\n    Session.prototype.getNextCursorOnLine = function (cursor) {\n        var doc     = this.editor.document,\n            line    = doc.getLine(cursor.line);\n\n        if (cursor.ch < line.length) {\n            return {\n                ch: cursor.ch + 1,\n                line: cursor.line\n            };\n        }\n        return null;\n\n    };\n\n    /**\n     * Get the token before the one at the given cursor position\n     *\n     * @param {{line: number, ch: number}} cursor - cursor position after\n     *      which a token should be retrieved\n     * @return {Object} - the CodeMirror token before the one at the given\n     *      cursor position\n     */\n    Session.prototype._getPreviousToken = function (cursor) {\n        var token   = this.getToken(cursor),\n            prev    = token,\n            doc     = this.editor.document;\n\n        do {\n            if (prev.start < cursor.ch) {\n                cursor.ch = prev.start;\n            } else if (prev.start > 0) {\n                cursor.ch = prev.start - 1;\n            } else if (cursor.line > 0) {\n                cursor.ch = doc.getLine(cursor.line - 1).length;\n                cursor.line--;\n            } else {\n                break;\n            }\n            prev = this.getToken(cursor);\n        } while (!/\\S/.test(prev.string));\n\n        return prev;\n    };\n\n    /**\n     * Get the token after the one at the given cursor position\n     *\n     * @param {{line: number, ch: number}} cursor - cursor position after\n     *      which a token should be retrieved\n     * @param {boolean} skipWhitespace - true if this should skip over whitespace tokens\n     * @return {Object} - the CodeMirror token after the one at the given\n     *      cursor position\n     */\n    Session.prototype.getNextToken = function (cursor, skipWhitespace) {\n        var token   = this.getToken(cursor),\n            next    = token,\n            doc     = this.editor.document;\n\n        do {\n            if (next.end > cursor.ch) {\n                cursor.ch = next.end;\n            } else if (next.end < doc.getLine(cursor.line).length) {\n                cursor.ch = next.end + 1;\n            } else if (doc.getLine(cursor.line + 1)) {\n                cursor.ch = 0;\n                cursor.line++;\n            } else {\n                next = null;\n                break;\n            }\n            next = this.getToken(cursor);\n        } while (skipWhitespace && !/\\S/.test(next.string));\n\n        return next;\n    };\n\n    /**\n     * Calculate a query string relative to the current cursor position\n     * and token. E.g., from a state \"identi<cursor>er\", the query string is\n     * \"identi\".\n     *\n     * @return {string} - the query string for the current cursor position\n     */\n    Session.prototype.getQuery = function () {\n        var cursor  = this.getCursor(),\n            token   = this.getToken(cursor),\n            query   = \"\",\n            start   = cursor.ch,\n            end     = start;\n\n        if (token) {\n            var line = this.getLine(cursor.line);\n            while (start > 0) {\n                if (HintUtils.maybeIdentifier(line[start - 1])) {\n                    start--;\n                } else {\n                    break;\n                }\n            }\n\n            query = line.substring(start, end);\n        }\n\n        return query;\n    };\n\n    /**\n     * Find the context of a property lookup. For example, for a lookup\n     * foo(bar, baz(quux)).prop, foo is the context.\n     *\n     * @param {{line: number, ch: number}} cursor - the cursor position\n     *      at which context information is to be retrieved\n     * @param {number=} depth - the current depth of the parenthesis stack, or\n     *      undefined if the depth is 0.\n     * @return {string} - the context for the property that was looked up\n     */\n    Session.prototype.getContext = function (cursor, depth) {\n        var token = this.getToken(cursor);\n\n        if (depth === undefined) {\n            depth = 0;\n        }\n\n        if (token.string === \")\") {\n            this._getPreviousToken(cursor);\n            return this.getContext(cursor, ++depth);\n        } else if (token.string === \"(\") {\n            this._getPreviousToken(cursor);\n            return this.getContext(cursor, --depth);\n        }\n        if (depth > 0 || token.string === \".\") {\n            this._getPreviousToken(cursor);\n            return this.getContext(cursor, depth);\n        }\n        return token.string;\n\n\n    };\n\n    /**\n     * @return {{line:number, ch:number}} - the line, col info for where the previous \".\"\n     *      in a property lookup occurred, or undefined if no previous \".\" was found.\n     */\n    Session.prototype.findPreviousDot = function () {\n        var cursor = this.getCursor(),\n            token = this.getToken(cursor);\n\n        // If the cursor is right after the dot, then the current token will be \".\"\n        if (token && token.string === \".\") {\n            return cursor;\n        }\n            // If something has been typed like 'foo.b' then we have to look back 2 tokens\n            // to get past the 'b' token\n        token = this._getPreviousToken(cursor);\n        if (token && token.string === \".\") {\n            return cursor;\n        }\n\n        return undefined;\n    };\n\n    /**\n     *\n     * @param {Object} token - a CodeMirror token\n     * @return {*} - the lexical state of the token\n     */\n    function getLexicalState(token) {\n        if (token.state.lexical) {\n            // in a javascript file this is just in the state field\n            return token.state.lexical;\n        } else if (token.state.localState && token.state.localState.lexical) {\n            // inline javascript in an html file will have this in\n            // the localState field\n            return token.state.localState.lexical;\n        }\n    }\n\n\n    /**\n     * Determine if the caret is either within a function call or on the function call itself.\n     *\n     * @return {{inFunctionCall: boolean, functionCallPos: {line: number, ch: number}}}\n     * inFunctionCall - true if the caret if either within a function call or on the\n     * function call itself.\n     * functionCallPos - the offset of the '(' character of the function call if inFunctionCall\n     * is true, otherwise undefined.\n     */\n    Session.prototype.getFunctionInfo = function () {\n        var inFunctionCall   = false,\n            cursor           = this.getCursor(),\n            functionCallPos,\n            token            = this.getToken(cursor),\n            lexical,\n            self = this,\n            foundCall = false;\n\n        /**\n         * Test if the cursor is on a function identifier\n         *\n         * @return {Object} - lexical state if on a function identifier, null otherwise.\n         */\n        function isOnFunctionIdentifier() {\n\n            // Check if we might be on function identifier of the function call.\n            var type = token.type,\n                nextToken,\n                localLexical,\n                localCursor = {line: cursor.line, ch: token.end};\n\n            if (type === \"variable-2\" || type === \"variable\" || type === \"property\") {\n                nextToken = self.getNextToken(localCursor, true);\n                if (nextToken && nextToken.string === \"(\") {\n                    localLexical = getLexicalState(nextToken);\n                    return localLexical;\n                }\n            }\n\n            return null;\n        }\n\n        /**\n         * Test is a lexical state is in a function call.\n         *\n         * @param {Object} lex - lexical state.\n         * @return {Object | boolean}\n         *\n         */\n        function isInFunctionalCall(lex) {\n            // in a call, or inside array or object brackets that are inside a function.\n            return (lex && (lex.info === \"call\" ||\n                (lex.info === undefined && (lex.type === \"]\" || lex.type === \"}\") &&\n                    lex.prev.info === \"call\")));\n        }\n\n        if (token) {\n            // if this token is part of a function call, then the tokens lexical info\n            // will be annotated with \"call\".\n            // If the cursor is inside an array, \"[]\", or object, \"{}\", the lexical state\n            // will be undefined, not \"call\". lexical.prev will be the function state.\n            // Handle this case and then set \"lexical\" to lexical.prev.\n            // Also test if the cursor is on a function identifier of a function call.\n            lexical = getLexicalState(token);\n            foundCall = isInFunctionalCall(lexical);\n\n            if (!foundCall) {\n                lexical = isOnFunctionIdentifier();\n                foundCall = isInFunctionalCall(lexical);\n            }\n\n            if (foundCall) {\n                // we need to find the location of the called function so that we can request the functions type.\n                // the token's lexical info will contain the column where the open \"(\" for the\n                // function call occurs, but for whatever reason it does not have the line, so\n                // we have to walk back and try to find the correct location.  We do this by walking\n                // up the lines starting with the line the token is on, and seeing if any of the lines\n                // have \"(\" at the column indicated by the tokens lexical state.\n                // We walk back 9 lines, as that should be far enough to find most function calls,\n                // and it will prevent us from walking back thousands of lines if something went wrong.\n                // there is nothing magical about 9 lines, and it can be adjusted if it doesn't seem to be\n                // working well\n                if (lexical.info === undefined) {\n                    lexical = lexical.prev;\n                }\n\n                var col = lexical.info === \"call\" ? lexical.column : lexical.prev.column,\n                    line,\n                    e,\n                    found;\n                for (line = this.getCursor().line, e = Math.max(0, line - 9), found = false; line >= e; --line) {\n                    if (this.getLine(line).charAt(col) === \"(\") {\n                        found = true;\n                        break;\n                    }\n                }\n\n                if (found) {\n                    inFunctionCall = true;\n                    functionCallPos = {line: line, ch: col};\n                }\n            }\n        }\n\n        return {\n            inFunctionCall: inFunctionCall,\n            functionCallPos: functionCallPos\n        };\n    };\n\n    /**\n     * Get the type of the current session, i.e., whether it is a property\n     * lookup and, if so, what the context of the lookup is.\n     *\n     * @return {{property: boolean,\n                 context: string} - an Object consisting\n     *      of a {boolean} \"property\" that indicates whether or not the type of\n     *      the session is a property lookup, and a {string} \"context\" that\n     *      indicates the object context (as described in getContext above) of\n     *      the property lookup, or null if there is none. The context is\n     *      always null for non-property lookups.\n     */\n    Session.prototype.getType = function () {\n        var propertyLookup   = false,\n            context          = null,\n            cursor           = this.getCursor(),\n            token            = this.getToken(cursor);\n\n        if (token) {\n            if (token.type === \"property\") {\n                propertyLookup = true;\n            }\n\n            cursor = this.findPreviousDot();\n            if (cursor) {\n                propertyLookup = true;\n                context = this.getContext(cursor);\n            }\n        }\n\n        return {\n            property: propertyLookup,\n            context: context\n        };\n    };\n\n    // Comparison function used for sorting that does a case-insensitive string\n    // comparison on the \"value\" field of both objects. Unlike a normal string\n    // comparison, however, this sorts leading \"_\" to the bottom, given that a\n    // leading \"_\" usually denotes a private value.\n    function penalizeUnderscoreValueCompare(a, b) {\n        var aName = a.value.toLowerCase(), bName = b.value.toLowerCase();\n        // this sort function will cause _ to sort lower than lower case\n        // alphabetical letters\n        if (aName[0] === \"_\" && bName[0] !== \"_\") {\n            return 1;\n        } else if (bName[0] === \"_\" && aName[0] !== \"_\") {\n            return -1;\n        }\n        if (aName < bName) {\n            return -1;\n        } else if (aName > bName) {\n            return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * Get a list of hints for the current session using the current scope\n     * information.\n     *\n     * @param {string} query - the query prefix\n     * @param {StringMatcher} matcher - the class to find query matches and sort the results\n     * @return {hints: Array.<string>, needGuesses: boolean} - array of\n     * matching hints. If needGuesses is true, then the caller needs to\n     * request guesses and call getHints again.\n     */\n    Session.prototype.getHints = function (query, matcher) {\n\n        if (query === undefined) {\n            query = \"\";\n        }\n\n        var MAX_DISPLAYED_HINTS = 500,\n            type                = this.getType(),\n            builtins            = this._getBuiltins(),\n            needGuesses         = false,\n            hints;\n\n        /**\n         *  Is the origin one of the builtin files.\n         *\n         * @param {string} origin\n         */\n        function isBuiltin(origin) {\n            return builtins.indexOf(origin) !== -1;\n        }\n\n        /**\n         *  Filter an array hints using a given query and matcher.\n         *  The hints are returned in the format of the matcher.\n         *  The matcher returns the value in the \"label\" property,\n         *  the match score in \"matchGoodness\" property.\n         *\n         * @param {Array} hints - array of hints\n         * @param {StringMatcher} matcher\n         * @return {Array} - array of matching hints.\n         */\n        function filterWithQueryAndMatcher(hints, matcher) {\n            var matchResults = $.map(hints, function (hint) {\n                var searchResult = matcher.match(hint.value, query);\n                if (searchResult) {\n                    searchResult.value = hint.value;\n                    searchResult.guess = hint.guess;\n                    searchResult.type = hint.type;\n\n                    if (hint.keyword !== undefined) {\n                        searchResult.keyword = hint.keyword;\n                    }\n\n                    if (hint.literal !== undefined) {\n                        searchResult.literal = hint.literal;\n                    }\n\n                    if (hint.depth !== undefined) {\n                        searchResult.depth = hint.depth;\n                    }\n\n                    if (hint.doc) {\n                        searchResult.doc = hint.doc;\n                    }\n\n                    if (hint.url) {\n                        searchResult.url = hint.url;\n                    }\n\n                    if (!type.property && !type.showFunctionType && hint.origin &&\n                            isBuiltin(hint.origin)) {\n                        searchResult.builtin = 1;\n                    } else {\n                        searchResult.builtin = 0;\n                    }\n                }\n\n                return searchResult;\n            });\n\n            return matchResults;\n        }\n\n        if (type.property) {\n            hints = this.ternHints || [];\n            hints = filterWithQueryAndMatcher(hints, matcher);\n\n            // If there are no hints then switch over to guesses.\n            if (hints.length === 0) {\n                if (this.ternGuesses) {\n                    hints = filterWithQueryAndMatcher(this.ternGuesses, matcher);\n                } else {\n                    needGuesses = true;\n                }\n            }\n\n            StringMatch.multiFieldSort(hints, [ \"matchGoodness\", penalizeUnderscoreValueCompare ]);\n        } else {     // identifiers, literals, and keywords\n            hints = this.ternHints || [];\n            hints = hints.concat(HintUtils.LITERALS);\n            hints = hints.concat(HintUtils.KEYWORDS);\n            hints = filterWithQueryAndMatcher(hints, matcher);\n            StringMatch.multiFieldSort(hints, [ \"matchGoodness\", \"depth\", \"builtin\", penalizeUnderscoreValueCompare ]);\n        }\n\n        if (hints.length > MAX_DISPLAYED_HINTS) {\n            hints = hints.slice(0, MAX_DISPLAYED_HINTS);\n        }\n\n        return {hints: hints, needGuesses: needGuesses};\n    };\n\n    Session.prototype.setTernHints = function (newHints) {\n        this.ternHints = newHints;\n    };\n\n    Session.prototype.setGuesses = function (newGuesses) {\n        this.ternGuesses = newGuesses;\n    };\n\n    /**\n     * Set a new function type hint.\n     *\n     * @param {Array<{name: string, type: string, isOptional: boolean}>} newFnType -\n     * Array of function hints.\n     */\n    Session.prototype.setFnType = function (newFnType) {\n        this.fnType = newFnType;\n    };\n\n    /**\n     * The position of the function call for the current fnType.\n     *\n     * @param {{line:number, ch:number}} functionCallPos - the offset of the function call.\n     */\n    Session.prototype.setFunctionCallPos = function (functionCallPos) {\n        this.functionCallPos = functionCallPos;\n    };\n\n    /**\n     * Get the function type hint.  This will format the hint, showing the\n     * parameter at the cursor in bold.\n     *\n     * @return {{parameters: Array<{name: string, type: string, isOptional: boolean}>,\n     * currentIndex: number}} An Object where the\n     * \"parameters\" property is an array of parameter objects;\n     * the \"currentIndex\" property index of the hint the cursor is on, may be\n     * -1 if the cursor is on the function identifier.\n     */\n    Session.prototype.getParameterHint = function () {\n        var fnHint = this.fnType,\n            cursor = this.getCursor(),\n            token = this.getToken(this.functionCallPos),\n            start = {line: this.functionCallPos.line, ch: token.start},\n            fragment = this.editor.document.getRange(start,\n                {line: this.functionCallPos.line + 10, ch: 0});\n\n        var ast;\n        try {\n            ast = Acorn.parse(fragment);\n        } catch (e) {\n            ast = Acorn_Loose.parse(fragment, {});\n        }\n\n        // find argument as cursor location and bold it.\n        var startOffset = this.getOffsetFromCursor(start),\n            cursorOffset = this.getOffsetFromCursor(cursor),\n            offset = cursorOffset - startOffset,\n            node = ast.body[0],\n            currentArg = -1;\n\n        if (node.type === \"ExpressionStatement\") {\n            node = node.expression;\n            if (node.type === \"SequenceExpression\") {\n                node = node.expressions[0];\n            }\n            if (node.type === \"BinaryExpression\") {\n                if (node.left.type === \"CallExpression\") {\n                    node = node.left;\n                } else if (node.right.type === \"CallExpression\") {\n                    node = node.right;\n                }\n            }\n            if (node.type === \"CallExpression\") {\n                var args = node[\"arguments\"],\n                    i,\n                    n = args.length,\n                    lastEnd = offset,\n                    text;\n                for (i = 0; i < n; i++) {\n                    node = args[i];\n                    if (offset >= node.start && offset <= node.end) {\n                        currentArg = i;\n                        break;\n                    } else if (offset < node.start) {\n                        // The range of nodes can be disjoint so see i f we\n                        // passed the node. If we passed the node look at the\n                        // text between the nodes to figure out which\n                        // arg we are on.\n                        text = fragment.substring(lastEnd, node.start);\n\n                        // test if comma is before or after the offset\n                        if (text.indexOf(\",\") >= (offset - lastEnd)) {\n                            // comma is after the offset so the current arg is the\n                            // previous arg node.\n                            i--;\n                        } else if (i === 0 && text.indexOf(\"(\") !== -1) {\n                            // the cursor is on the function identifier\n                            currentArg = -1;\n                            break;\n                        }\n\n                        currentArg = Math.max(0, i);\n                        break;\n                    } else if (i + 1 === n) {\n                        // look for a comma after the node.end. This will tell us we\n                        // are on the next argument, even there is no text, and therefore no node,\n                        // for the next argument.\n                        text = fragment.substring(node.end, offset);\n                        if (text.indexOf(\",\") !== -1) {\n                            currentArg = i + 1; // we know we are after the current arg, but keep looking\n                        }\n                    }\n\n                    lastEnd = node.end;\n                }\n\n                // if there are no args, then figure out if we are on the function identifier\n                if (n === 0 && cursorOffset > this.getOffsetFromCursor(this.functionCallPos)) {\n                    currentArg = 0;\n                }\n            }\n        }\n\n        return {parameters: fnHint, currentIndex: currentArg};\n    };\n\n    /**\n     * Get the javascript text of the file open in the editor for this Session.\n     * For a javascript file, this is just the text of the file.  For an HTML file,\n     * this will be only the text in the <script> tags.  This is so that we can pass\n     * just the javascript text to tern, and avoid confusing it with HTML tags, since it\n     * only knows how to parse javascript.\n     * @return {string} - the \"javascript\" text that can be sent to Tern.\n     */\n    Session.prototype.getJavascriptText = function () {\n        if (LanguageManager.getLanguageForPath(this.editor.document.file.fullPath).getId() === \"html\") {\n            // HTML file - need to send back only the bodies of the\n            // <script> tags\n            var text = \"\",\n                editor = this.editor,\n                scriptBlocks = HTMLUtils.findBlocks(editor, \"javascript\");\n\n            // Add all the javascript text\n            // For non-javascript blocks we replace everything except for newlines\n            // with whitespace.  This is so that the offset and cursor positions\n            // we get from the document still work.\n            // Alternatively we could strip the non-javascript text, and modify the offset,\n            // and/or cursor, but then we have to remember how to reverse the translation\n            // to support jump-to-definition\n            var htmlStart = {line: 0, ch: 0};\n            scriptBlocks.forEach(function (scriptBlock) {\n                var start = scriptBlock.start,\n                    end = scriptBlock.end;\n\n                // get the preceding html text, and replace it with whitespace\n                var htmlText = editor.document.getRange(htmlStart, start);\n                htmlText = htmlText.replace(/./g, \" \");\n\n                htmlStart = end;\n                text += htmlText + scriptBlock.text;\n            });\n\n            return text;\n        }\n            // Javascript file, just return the text\n        return this.editor.document.getText();\n\n    };\n\n    /**\n     * Determine if the cursor is located in the name of a function declaration.\n     * This is so we can suppress hints when in a function name, as we do for variable and\n     * parameter declarations, but we can tell those from the token itself rather than having\n     * to look at previous tokens.\n     *\n     * @return {boolean} - true if the current cursor position is in the name of a function\n     * declaration.\n     */\n    Session.prototype.isFunctionName = function () {\n        var cursor = this.getCursor(),\n            prevToken = this._getPreviousToken(cursor);\n\n        return prevToken.string === \"function\";\n    };\n\n    module.exports = Session;\n});\n"],"file":"Session.js"}
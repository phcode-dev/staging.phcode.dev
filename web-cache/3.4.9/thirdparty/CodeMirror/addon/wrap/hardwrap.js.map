{"version":3,"sources":["thirdparty/CodeMirror/addon/wrap/hardwrap.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","Pos","findParagraph","cm","pos","options","startRE","paragraphStart","getHelper","start","line","first","firstLine","getLine","test","endRE","paragraphEnd","end","last","lastLine","from","to","findBreakPoint","text","column","wrapOn","killTrailingSpace","forceBreak","at","length","charAt","slice","match","endOfText","wrapRange","clipPos","killTrailing","changes","curLine","curNo","lines","getRange","leadingSpace","i","oldLen","spaceInserted","spaceTrimmed","firstBreak","push","bp","operation","change","cmpPos","replaceRange","changeEnd","defineExtension","this","getCursor","para","commands","wrapLines","ranges","listSelections","range","span","empty","head","paras","madeChange"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n\n  function findParagraph(cm, pos, options) {\n    var startRE = options.paragraphStart || cm.getHelper(pos, \"paragraphStart\");\n    for (var start = pos.line, first = cm.firstLine(); start > first; --start) {\n      var line = cm.getLine(start);\n      if (startRE && startRE.test(line)) break;\n      if (!/\\S/.test(line)) { ++start; break; }\n    }\n    var endRE = options.paragraphEnd || cm.getHelper(pos, \"paragraphEnd\");\n    for (var end = pos.line + 1, last = cm.lastLine(); end <= last; ++end) {\n      var line = cm.getLine(end);\n      if (endRE && endRE.test(line)) { ++end; break; }\n      if (!/\\S/.test(line)) break;\n    }\n    return {from: start, to: end};\n  }\n\n  function findBreakPoint(text, column, wrapOn, killTrailingSpace, forceBreak) {\n    var at = column\n    while (at < text.length && text.charAt(at) == \" \") at++\n    for (; at > 0; --at)\n      if (wrapOn.test(text.slice(at - 1, at + 1))) break;\n\n    if (!forceBreak && at <= text.match(/^[ \\t]*/)[0].length) {\n      // didn't find a break point before column, in non-forceBreak mode try to\n      // find one after 'column'.\n      for (at = column + 1; at < text.length - 1; ++at) {\n        if (wrapOn.test(text.slice(at - 1, at + 1))) break;\n      }\n    }\n\n    for (var first = true;; first = false) {\n      var endOfText = at;\n      if (killTrailingSpace)\n        while (text.charAt(endOfText - 1) == \" \") --endOfText;\n      if (endOfText == 0 && first) at = column;\n      else return {from: endOfText, to: at};\n    }\n  }\n\n  function wrapRange(cm, from, to, options) {\n    from = cm.clipPos(from); to = cm.clipPos(to);\n    var column = options.column || 80;\n    var wrapOn = options.wrapOn || /\\s\\S|-[^\\.\\d]/;\n    var forceBreak = options.forceBreak !== false;\n    var killTrailing = options.killTrailingSpace !== false;\n    var changes = [], curLine = \"\", curNo = from.line;\n    var lines = cm.getRange(from, to, false);\n    if (!lines.length) return null;\n    var leadingSpace = lines[0].match(/^[ \\t]*/)[0];\n    if (leadingSpace.length >= column) column = leadingSpace.length + 1\n\n    for (var i = 0; i < lines.length; ++i) {\n      var text = lines[i], oldLen = curLine.length, spaceInserted = 0;\n      if (curLine && text && !wrapOn.test(curLine.charAt(curLine.length - 1) + text.charAt(0))) {\n        curLine += \" \";\n        spaceInserted = 1;\n      }\n      var spaceTrimmed = \"\";\n      if (i) {\n        spaceTrimmed = text.match(/^\\s*/)[0];\n        text = text.slice(spaceTrimmed.length);\n      }\n      curLine += text;\n      if (i) {\n        var firstBreak = curLine.length > column && leadingSpace == spaceTrimmed &&\n          findBreakPoint(curLine, column, wrapOn, killTrailing, forceBreak);\n        // If this isn't broken, or is broken at a different point, remove old break\n        if (!firstBreak || firstBreak.from != oldLen || firstBreak.to != oldLen + spaceInserted) {\n          changes.push({text: [spaceInserted ? \" \" : \"\"],\n                        from: Pos(curNo, oldLen),\n                        to: Pos(curNo + 1, spaceTrimmed.length)});\n        } else {\n          curLine = leadingSpace + text;\n          ++curNo;\n        }\n      }\n      while (curLine.length > column) {\n        var bp = findBreakPoint(curLine, column, wrapOn, killTrailing, forceBreak);\n        if (bp.from != bp.to ||\n            forceBreak && leadingSpace !== curLine.slice(0, bp.to)) {\n          changes.push({text: [\"\", leadingSpace],\n                        from: Pos(curNo, bp.from),\n                        to: Pos(curNo, bp.to)});\n          curLine = leadingSpace + curLine.slice(bp.to);\n          ++curNo;\n        } else {\n          break;\n        }\n      }\n    }\n    if (changes.length) cm.operation(function() {\n      for (var i = 0; i < changes.length; ++i) {\n        var change = changes[i];\n        if (change.text || CodeMirror.cmpPos(change.from, change.to))\n          cm.replaceRange(change.text, change.from, change.to);\n      }\n    });\n    return changes.length ? {from: changes[0].from, to: CodeMirror.changeEnd(changes[changes.length - 1])} : null;\n  }\n\n  CodeMirror.defineExtension(\"wrapParagraph\", function(pos, options) {\n    options = options || {};\n    if (!pos) pos = this.getCursor();\n    var para = findParagraph(this, pos, options);\n    return wrapRange(this, Pos(para.from, 0), Pos(para.to - 1), options);\n  });\n\n  CodeMirror.commands.wrapLines = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), at = cm.lastLine() + 1;\n      for (var i = ranges.length - 1; i >= 0; i--) {\n        var range = ranges[i], span;\n        if (range.empty()) {\n          var para = findParagraph(cm, range.head, {});\n          span = {from: Pos(para.from, 0), to: Pos(para.to - 1)};\n        } else {\n          span = {from: range.from(), to: range.to()};\n        }\n        if (span.to.line >= at) continue;\n        at = span.from.line;\n        wrapRange(cm, span.from, span.to, {});\n      }\n    });\n  };\n\n  CodeMirror.defineExtension(\"wrapRange\", function(from, to, options) {\n    return wrapRange(this, from, to, options || {});\n  });\n\n  CodeMirror.defineExtension(\"wrapParagraphsInRange\", function(from, to, options) {\n    options = options || {};\n    var cm = this, paras = [];\n    for (var line = from.line; line <= to.line;) {\n      var para = findParagraph(cm, Pos(line, 0), options);\n      paras.push(para);\n      line = para.to;\n    }\n    var madeChange = false;\n    if (paras.length) cm.operation(function() {\n      for (var i = paras.length - 1; i >= 0; --i)\n        madeChange = madeChange || wrapRange(cm, Pos(paras[i].from, 0), Pos(paras[i].to - 1), options);\n    });\n    return madeChange;\n  });\n});\n"],"file":"hardwrap.js"}
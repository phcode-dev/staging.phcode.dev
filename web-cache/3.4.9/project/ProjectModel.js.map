{"version":3,"sources":["project/ProjectModel.js"],"names":["define","require","exports","module","InMemoryFile","EventDispatcher","FileUtils","_","FileSystem","DocumentManager","FileSystemError","FileTreeViewModel","Async","PerfUtils","EVENT_CHANGE","EVENT_SHOULD_SELECT","EVENT_SHOULD_FOCUS","EVENT_FS_RENAME_STARTED","EVENT_FS_RENAME_END","ERROR_CREATION","ERROR_INVALID_FILENAME","ERROR_NOT_IN_PROJECT","_exclusionListRegEx","_cacheExcludeFileNameRegEx","defaultIgnoreGlobs","_invalidChars","_illegalFilenamesRegEx","isValidFilename","filename","match","isValidPath","path","_shouldShowName","name","test","shouldShow","entry","shouldIndex","setFileTreeFilter","FILE_RENAMING","FILE_CREATING","RENAME_CANCELLED","_pathIsFile","last","_getFSObject","getFileForPath","getDirectoryForPath","_getPathFromFSObject","fsobj","fullPath","doCreate","isFolder","d","$","Deferred","getBaseName","resolve","err","directory","create","reject","file","writeText","then","ALREADY_EXISTS","promise","ProjectModel","initial","projectRoot","this","undefined","focused","_focused","_viewModel","on","trigger","bind","_selections","_getGitIgnoreFileContent","Promise","getDocumentForPath","done","doc","getText","fail","_gitIgnores","gitIgnoreFilters","filter","relativePath","relative","basePath","startsWith","gitIgnore","ignores","e","console","error","async","_updateGitIgnoreFromPath","gitIgnorePath","parentFullPath","gitIgnoreSearchedInDir","gitIgnoreContent","push","fs","utils","ignore","add","_updateGitIgnore","siblingEntries","dirname","sibling","isFile","_ensureTrailingSlash","_getWelcomeProjectPath","sampleUrl","initialPath","substr","lastIndexOf","_addWelcomeProjectPath","currentProjects","pathNoSlash","stripTrailingSlash","newProjects","clone","indexOf","_isWelcomeProjectPath","welcomeProjectPath","welcomeProjects","makeEventDispatcher","prototype","_projectBaseUrl","_currentPath","_allFilesCachePromise","_allFilesScopeCachePromise","_allFilesScope","setFocused","setSelected","setSelectionWidth","width","setScrollerInfo","scrollWidth","scrollTop","scrollLeft","offsetTop","setSelectionScrollerInfo","getBaseUrl","setBaseUrl","projectBaseUrl","length","isWithinProject","absPathOrEntry","absPath","makeProjectRelativeIfPossible","slice","getDirectoryInProject","isDirectory","computeProjectGitIgnoreAsync","self","jsPromise","_getAllFilesCache","catch","finally","sort","_gitIgnoreFiltersOut","deferred","allFiles","allFilesVisitor","projectIndexTimer","markStart","options","sortList","visit","finalizeMeasurement","addMeasurement","_getAllFilesInScopeCache","scope","Error","scopeTimer","getAllFiles","additionalFiles","filteredFilesDeferred","getAllFilesFn","result","forEach","stack","_resetCache","setProjectRoot","_rootChanged","getContents","contents","setDirectoryContents","_getDirectoryContents","setDirectoryOpen","open","projectRelative","needsLoading","isPathLoaded","onSuccess","openPath","currentPathInProject","isFilePathVisible","selected","relativeSelected","parentDirectory","getDirectoryPath","showInTree","Phoenix","app","openPathInFileBrowser","doNotOpen","oldProjectPath","pathInProject","performRename","moveMarker","context","previousSelection","previousPath","hadFocus","getSelected","setCurrentFile","curFile","selectInWorkingSet","setContext","_doNotRename","_saveContext","previousContext","currentContext","restoreContext","getContext","startRename","isMoved","rename","type","projectRelativePath","newPath","setRenameValue","cancelRename","renameInfo","_cancelCreating","_renameItem","oldPath","newName","oldName","viewModel","createAtPath","finalizeRename","deleteAtPath","errorType","errorInfo","renameItem","startCreating","basedir","createPlaceholder","setSortDirectoriesFirst","sortDirectoriesFirst","getOpenNodes","reopenNodes","nodesByDepth","doSequentially","toOpenPaths","doInParallel","refresh","openNodes","selections","handleFSEvent","added","removed","changes","changed","map","find","processChanges","closeSubtree","toggleSubdirectories","openOrClose","childNodes","getChildDirectories","node"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* unittests: ProjectModel */\n\n/*global fs, path, jsPromise*/\n\n/**\n * Provides the data source for a project and manages the view model for the FileTreeView.\n */\ndefine(function (require, exports, module) {\n\n\n    var InMemoryFile        = require(\"document/InMemoryFile\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        _                   = require(\"thirdparty/lodash\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        DocumentManager     = require(\"document/DocumentManager\"),\n        FileSystemError     = require(\"filesystem/FileSystemError\"),\n        FileTreeViewModel   = require(\"project/FileTreeViewModel\"),\n        Async               = require(\"utils/Async\"),\n        PerfUtils           = require(\"utils/PerfUtils\");\n\n    // Constants\n    var EVENT_CHANGE            = \"change\",\n        EVENT_SHOULD_SELECT     = \"select\",\n        EVENT_SHOULD_FOCUS      = \"focus\",\n        EVENT_FS_RENAME_STARTED = \"mvStart\",\n        EVENT_FS_RENAME_END     = \"mvEnd\",\n        ERROR_CREATION          = \"creationError\",\n        ERROR_INVALID_FILENAME  = \"invalidFilename\",\n        ERROR_NOT_IN_PROJECT    = \"notInProject\";\n\n    /**\n     * @private\n     * File and folder names which are not displayed or searched\n     * TODO: We should add the rest of the file names that TAR excludes:\n     *    http://www.gnu.org/software/tar/manual/html_section/exclude.html\n     * TODO: This should be user configurable\n     *    https://github.com/adobe/brackets/issues/6781\n     * @type {RegExp}\n     */\n    var _exclusionListRegEx = /\\.pyc$|^\\.git$|^\\.gitmodules$|^\\.svn$|^\\.DS_Store$|^Icon\\r|^Thumbs\\.db$|^\\.hg$|^CVS$|^\\.hgtags$|^\\.idea$|^\\.c9revisions$|^\\.SyncArchive$|^\\.SyncID$|^\\.SyncIgnore$|\\~$/;\n    var _cacheExcludeFileNameRegEx = /^node_modules$|^bower_components$|^.npm$|^.yarn$|^__pycache__$/;\n\n    /**\n     * Glob definition of files and folders that should be excluded directly\n     * inside node domain watching with chokidar\n     */\n    const defaultIgnoreGlobs = [\n        \"node_modules/**\",\n        \"**/node_modules/**\",\n        \"bower_components/**\",\n        \"**/bower_components/**\",\n        \".npm\",\n        \".yarn\",\n        \"__pycache__\",\n        \".pyc\",\n        \".git\",\n        \".gitmodules\",\n        \".svn\",\n        \".DS_Store\",\n        \"Thumbs.db\",\n        \".hg\",\n        \"CVS\",\n        \".hgtags\",\n        \".idea\",\n        \".c9revisions\",\n        \".SyncArchive\",\n        \".SyncID\",\n        \".SyncIgnore\"\n    ];\n\n    /**\n     * @private\n     * RegEx to validate a file path.\n     */\n    var _invalidChars = /([?\\*\\|\\<\\>\"]+|\\/{2,}|\\.{2,}|\\.$)/i;\n\n    /**\n     * @private\n     * RegEx to validate if a filename is not allowed even if the system allows it.\n     * This is done to prevent cross-platform issues.\n     */\n    var _illegalFilenamesRegEx = /((\\b(com[0-9]+|lpt[0-9]+|nul|con|prn|aux)\\b)|\\.+$|\\/+|\\\\+|\\:)/i;\n\n    /**\n     * Returns true if this matches valid filename specifications.\n     * See http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx\n     *\n     * TODO: This likely belongs in FileUtils.\n     *\n     * @param {string} filename to check\n     * @return {boolean} true if the filename is valid\n     */\n    function isValidFilename(filename) {\n        // Fix issue adobe#13099\n        // See https://github.com/adobe/brackets/issues/13099\n        return !(\n            filename.match(_invalidChars)|| filename.match(_illegalFilenamesRegEx)\n        );\n    }\n\n    /**\n     * Returns true if given path is valid.\n     *\n     * @param {string} path to check\n     * @return {boolean} true if the filename is valid\n     */\n    function isValidPath(path) {\n        // Fix issue adobe#13099\n        // See https://github.com/adobe/brackets/issues/13099\n        return !(path.match(_invalidChars));\n    }\n\n    /**\n     * @private\n     * @see #shouldShow\n     */\n    function _shouldShowName(name) {\n        return !_exclusionListRegEx.test(name);\n    }\n\n    FileSystem.setFileTreeFilter(_shouldShowName);\n\n    /**\n     * Returns false for files and directories that are not commonly useful to display.\n     *\n     * @param {!FileSystemEntry} entry File or directory to filter\n     * @return {boolean} true if the file should be displayed\n     */\n    function shouldShow(entry) {\n        return _shouldShowName(entry.name);\n    }\n\n    /**\n     * Returns false for files and directories that should not be indexed for search or code hints.\n     * If the entry is a directory, its children should be indexed too.\n     *\n     * @param {!FileSystemEntry} entry File or directory to filter\n     * @return {boolean} true if the file should be displayed\n     */\n    function shouldIndex(entry) {\n        return shouldShow(entry) && !_cacheExcludeFileNameRegEx.test(entry.name);\n    }\n\n    // Constants used by the ProjectModel\n\n    var FILE_RENAMING     = 0,\n        FILE_CREATING     = 1,\n        RENAME_CANCELLED  = 2;\n\n\n    /**\n     * @private\n     *\n     * Determines if a path string is pointing to a directory (does it have a trailing slash?)\n     *\n     * @param {string} path Path to test.\n     */\n    function _pathIsFile(path) {\n        return _.last(path) !== \"/\";\n    }\n\n    /**\n     * @private\n     *\n     * Gets the FileSystem object (either a File or Directory) based on the path provided.\n     *\n     * @param {string} path Path to retrieve\n     */\n    function _getFSObject(path) {\n        if (!path) {\n            return path;\n        } else if (_pathIsFile(path)) {\n            return FileSystem.getFileForPath(path);\n        }\n        return FileSystem.getDirectoryForPath(path);\n    }\n\n    /**\n     * @private\n     *\n     * Given what is possible a FileSystem object, return its path (if a string path is passed in,\n     * it will be returned as-is).\n     *\n     * @param {FileSystemEntry} fsobj Object from which the path should be extracted\n     */\n    function _getPathFromFSObject(fsobj) {\n        if (fsobj && fsobj.fullPath) {\n            return fsobj.fullPath;\n        }\n        return fsobj;\n    }\n\n    /**\n     * Creates a new file or folder at the given path. The returned promise is rejected if the filename\n     * is invalid, the new path already exists or some other filesystem error comes up.\n     *\n     * @param {string} path path to create\n     * @param {boolean} isFolder true if the new entry is a folder\n     * @return {$.Promise} resolved when the file or directory has been created.\n     */\n    function doCreate(path, isFolder) {\n        const d = new $.Deferred();\n        const filename = FileUtils.getBaseName(path);\n\n        // Check if filename\n        // or Check if fullpath with filename is valid - This check is used to circumvent directory jumps (Like ../..)\n        if (!isValidFilename(filename) || !isValidPath(path)){\n            return d.reject(ERROR_INVALID_FILENAME).promise();\n        }\n\n        FileSystem.resolve(path, function (err) {\n            if (!err) {\n                // Item already exists, fail with error\n                d.reject(FileSystemError.ALREADY_EXISTS);\n                return;\n            }\n            if (isFolder) {\n                const directory = FileSystem.getDirectoryForPath(path);\n\n                directory.create(function (err) {\n                    if (err) {\n                        d.reject(err);\n                    } else {\n                        d.resolve(directory);\n                    }\n                });\n            } else {\n                // Create an empty file\n                const file = FileSystem.getFileForPath(path);\n\n                FileUtils.writeText(file, \"\").then(function () {\n                    d.resolve(file);\n                }, d.reject);\n            }\n        });\n\n        return d.promise();\n    }\n\n    /**\n     * @constructor\n     *\n     * The ProjectModel provides methods for accessing information about the current open project.\n     * It also manages the view model to display a FileTreeView of the project.\n     *\n     * Events:\n     * - EVENT_CHANGE (`change`) - Fired when there's a change that should refresh the UI\n     * - EVENT_SHOULD_SELECT (`select`) - Fired when a selection has been made in the file tree and the file tree should be selected\n     * - EVENT_SHOULD_FOCUS (`focus`)\n     * - ERROR_CREATION (`creationError`) - Triggered when there's a problem creating a file\n     */\n    function ProjectModel(initial) {\n        initial = initial || {};\n        if (initial.projectRoot) {\n            this.projectRoot = initial.projectRoot;\n        }\n\n        if (initial.focused !== undefined) {\n            this._focused = initial.focused;\n        }\n        this._viewModel = new FileTreeViewModel.FileTreeViewModel();\n        this._viewModel.on(FileTreeViewModel.EVENT_CHANGE, function () {\n            this.trigger(EVENT_CHANGE);\n        }.bind(this));\n        this._selections = {};\n    }\n    EventDispatcher.makeEventDispatcher(ProjectModel.prototype);\n\n    /**\n     * @type {Directory}\n     *\n     * The root Directory object for the project.\n     */\n    ProjectModel.prototype.projectRoot = null;\n\n    /**\n     * @private\n     * @type {FileTreeViewModel}\n     *\n     * The view model for this project.\n     */\n    ProjectModel.prototype._viewModel = null;\n\n    /**\n     * @private\n     * @type {string}\n     *\n     * Encoded URL\n     * @see {@link ProjectModel#getBaseUrl}, {@link ProjectModel#setBaseUrl}\n     */\n    ProjectModel.prototype._projectBaseUrl = \"\";\n\n    /**\n     * @private\n     * @type {{selected: ?string, context: ?string, previousContext: ?string, rename: ?Object}}\n     *\n     * Keeps track of selected files, context, previous context and files\n     * that are being renamed or created.\n     */\n    ProjectModel.prototype._selections = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     *\n     * Flag to store whether the file tree has focus.\n     */\n    ProjectModel.prototype._focused = true;\n\n    /**\n     * @private\n     * @type {string}\n     *\n     * Current file path being viewed.\n     */\n    ProjectModel.prototype._currentPath = null;\n\n    /**\n     * @private\n     * @type {?$.Promise.<Array<File>>}\n     *\n     * A promise that is resolved with an array of all project files. Used by\n     * ProjectManager.getAllFiles().\n     */\n    ProjectModel.prototype._allFilesCachePromise = null;\n    ProjectModel.prototype._allFilesScopeCachePromise = null;\n    ProjectModel.prototype._allFilesScope = null;\n\n    /**\n     * Sets whether the file tree is focused or not.\n     *\n     * @param {boolean} focused True if the file tree has the focus.\n     */\n    ProjectModel.prototype.setFocused = function (focused) {\n        this._focused = focused;\n        if (!focused) {\n            this.setSelected(null);\n        }\n    };\n\n    /**\n     * Sets the width of the selection bar.\n     *\n     * @param {int} width New width\n     */\n    ProjectModel.prototype.setSelectionWidth = function (width) {\n        this._viewModel.setSelectionWidth(width);\n    };\n\n    /**\n     * Tracks the scroller position.\n     *\n     * @param {int} scrollWidth Width of the tree container\n     * @param {int} scrollTop Top of scroll position\n     * @param {int} scrollLeft Left of scroll position\n     * @param {int} offsetTop Top of scroller element\n     */\n    ProjectModel.prototype.setScrollerInfo = function (scrollWidth, scrollTop, scrollLeft, offsetTop) {\n        this._viewModel.setSelectionScrollerInfo(scrollWidth, scrollTop, scrollLeft, offsetTop);\n    };\n\n    /**\n     * Returns the encoded Base URL of the currently loaded project, or empty string if no project\n     * is open (during startup, or running outside of app shell).\n     * @return {String}\n     */\n    ProjectModel.prototype.getBaseUrl = function getBaseUrl() {\n        return this._projectBaseUrl;\n    };\n\n    /**\n     * Sets the encoded Base URL of the currently loaded project.\n     * @param {String}\n     */\n    ProjectModel.prototype.setBaseUrl = function setBaseUrl(projectBaseUrl) {\n        // Ensure trailing slash to be consistent with projectRoot.fullPath\n        // so they're interchangable (i.e. easy to convert back and forth)\n        if (projectBaseUrl.length > 0 && projectBaseUrl[projectBaseUrl.length - 1] !== \"/\") {\n            projectBaseUrl += \"/\";\n        }\n\n        this._projectBaseUrl = projectBaseUrl;\n        return projectBaseUrl;\n    };\n\n    /**\n     * Returns true if absPath lies within the project, false otherwise.\n     * Does not support paths containing \"..\"\n     *\n     * @param {string|FileSystemEntry} absPathOrEntry\n     * @return {boolean}\n     */\n    ProjectModel.prototype.isWithinProject = function isWithinProject(absPathOrEntry) {\n        var absPath = absPathOrEntry.fullPath || absPathOrEntry;\n        return (this.projectRoot && absPath.indexOf(this.projectRoot.fullPath) === 0);\n    };\n\n    /**\n     * If absPath lies within the project, returns a project-relative path. Else returns absPath\n     * unmodified.\n     * Does not support paths containing \"..\"\n     *\n     * @param {!string} absPath\n     * @return {!string}\n     */\n    ProjectModel.prototype.makeProjectRelativeIfPossible = function makeProjectRelativeIfPossible(absPath) {\n        if (absPath && this.isWithinProject(absPath)) {\n            return absPath.slice(this.projectRoot.fullPath.length);\n        }\n        return absPath;\n    };\n\n    /**\n     * Returns a valid directory within the project, either the path (or Directory object)\n     * provided or the project root.\n     *\n     * @param {string|Directory} path Directory path to verify against the project\n     * @return {string} A directory path within the project.\n     */\n    ProjectModel.prototype.getDirectoryInProject = function (path) {\n        if (path && typeof path === \"string\") {\n            if (_.last(path) !== \"/\") {\n                path += \"/\";\n            }\n        } else if (path && path.isDirectory) {\n            path = path.fullPath;\n        } else {\n            path = null;\n        }\n\n        if (!path || (typeof path !== \"string\") || !this.isWithinProject(path)) {\n            path = this.projectRoot.fullPath;\n        }\n        return path;\n    };\n\n    function _getGitIgnoreFileContent(fullPath) {\n        return new Promise(resolve=>{\n            DocumentManager.getDocumentForPath(fullPath)\n                .done(function (doc) {\n                    resolve(doc.getText()||\"\");\n                })\n                .fail(function () {\n                    resolve(null);\n                });\n        });\n    }\n\n    function _gitIgnores(entry, gitIgnoreFilters) {\n        try{\n            for(let filter of gitIgnoreFilters) {\n                const relativePath = path.relative(filter.basePath, entry.fullPath);\n                if(relativePath && !relativePath.startsWith(\"..\") &&\n                    filter.gitIgnore.ignores(relativePath)){\n                    return true;\n                }\n            }\n        } catch (e) {\n            console.error(\"Error while filtering get all files: \", e);\n        }\n        return false;\n    }\n\n    async function _updateGitIgnoreFromPath(gitIgnorePath, parentFullPath, gitIgnoreSearchedInDir, gitIgnoreFilters) {\n        const gitIgnoreContent = await _getGitIgnoreFileContent(gitIgnorePath);\n        gitIgnoreSearchedInDir[parentFullPath] = true;\n        if(gitIgnoreContent){\n            gitIgnoreFilters.push({\n                basePath: parentFullPath,\n                gitIgnore: fs.utils.ignore().add(gitIgnoreContent),\n                gitIgnoreContent\n            });\n        }\n    }\n\n    async function _updateGitIgnore(entry, siblingEntries, gitIgnoreSearchedInDir, gitIgnoreFilters) {\n        const parentFullPath = `${path.dirname(entry.fullPath)}/`; // Eg. /path/to/dir/\n        if(!gitIgnoreSearchedInDir[parentFullPath] && siblingEntries) {\n            // we have to check for gitIgnoreFile in this level is present or not.\n            for(let sibling of siblingEntries) {\n                if(sibling.isFile && sibling.name === \".gitignore\") {\n                    await _updateGitIgnoreFromPath(sibling.fullPath, parentFullPath,\n                        gitIgnoreSearchedInDir, gitIgnoreFilters);\n                }\n            }\n        }\n    }\n\n    /**\n     * Scans the whole project folder and computes the project wide git ignore\n     * filters to use. If there are nested .gitignore folders in project, that will also be detected.\n     * @return {Promise<{basePath: string, gitIgnore: object, gitIgnoreContent:string}>} returns an array with\n     *          basePath - the parent directory housing the git ignore file Eg: `/tauri/projectRoot/parent/`\n     *          gitIgnore - the git ignore filter fn that can be used to test if a path is ignored by calling\n     *             gitIgnore.ignores(relativePathToBasePath)\n     *          gitIgnoreContent - the textual content of the git ignore file.\n     */\n    ProjectModel.prototype.computeProjectGitIgnoreAsync = async function () {\n        let self = this;\n        return new Promise(resolve=>{\n            let gitIgnoreFilters = [];\n            jsPromise(self._getAllFilesCache(false, gitIgnoreFilters))\n                .catch(console.error)\n                .finally(()=>{\n                    resolve(gitIgnoreFilters);\n                });\n        });\n    };\n\n    /**\n     * @private\n     *\n     * Returns a promise that resolves with a cached copy of all project files.\n     * Used by ProjectManager.getAllFiles(). Ensures that at most one un-cached\n     * directory traversal is active at a time, which is useful at project load\n     * time when watchers (and hence filesystem-level caching) has not finished\n     * starting up. The cache is cleared on every filesystem change event, and\n     * also on project load and unload.\n     *\n     * @param {boolean} sort true to sort files by their paths\n     * @return {$.Promise.<Array.<File>>}\n     */\n    ProjectModel.prototype._getAllFilesCache = function _getAllFilesCache(sort, _gitIgnoreFiltersOut) {\n        let self = this;\n        if (!this._allFilesCachePromise) {\n            let gitIgnoreFilters = _gitIgnoreFiltersOut || [], gitIgnoreSearchedInDir = {};\n\n            let deferred = new $.Deferred(),\n                allFiles = [],\n                allFilesVisitor = async function (entry, siblingEntries) {\n                    if(entry.isDirectory && self.projectRoot.fullPath === entry.fullPath) {\n                        await _updateGitIgnoreFromPath(`${entry.fullPath}.gitignore`, entry.fullPath,\n                            gitIgnoreSearchedInDir, gitIgnoreFilters);\n                    }\n                    await _updateGitIgnore(entry, siblingEntries, gitIgnoreSearchedInDir, gitIgnoreFilters);\n                    if (shouldIndex(entry) && !_gitIgnores(entry, gitIgnoreFilters)) {\n                        if (entry.isFile) {\n                            allFiles.push(entry);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n            this._allFilesCachePromise = deferred.promise();\n\n            var projectIndexTimer = PerfUtils.markStart(\"Creating project files cache: \" +\n                                                        this.projectRoot.fullPath),\n                options = {\n                    sortList: sort\n                };\n\n            this.projectRoot.visit(allFilesVisitor, options, function (err) {\n                if (err) {\n                    PerfUtils.finalizeMeasurement(projectIndexTimer);\n                    deferred.reject(err);\n                } else {\n                    PerfUtils.addMeasurement(projectIndexTimer);\n                    deferred.resolve(allFiles);\n                }\n            }.bind(this));\n        }\n\n        return this._allFilesCachePromise;\n    };\n\n    ProjectModel.prototype._getAllFilesInScopeCache = function (sort, scope) {\n        let self = this;\n        if(!this.isWithinProject(scope)){\n            return (new $.Deferred()).reject(\n                new Error(`Scope ${scope.fullPath} should be within project root ${self.projectRoot}`)\n            ).promise();\n        }\n        if (!this._allFilesScopeCachePromise || this._allFilesScope !== scope) {\n            this._allFilesScope = scope;\n            let gitIgnoreFilters = [], gitIgnoreSearchedInDir = {};\n            const deferred = new $.Deferred(),\n                allFiles = [],\n                allFilesVisitor = async function (entry, siblingEntries) {\n                    if(entry.isDirectory && self.projectRoot.fullPath === entry.fullPath) {\n                        await _updateGitIgnoreFromPath(`${entry.fullPath}.gitignore`, entry.fullPath,\n                            gitIgnoreSearchedInDir, gitIgnoreFilters);\n                    }\n                    await _updateGitIgnore(entry, siblingEntries, gitIgnoreSearchedInDir, gitIgnoreFilters);\n                    if ((shouldIndex(entry) && !_gitIgnores(entry, gitIgnoreFilters)) ||\n                        entry.fullPath === scope.fullPath) {\n                        if (entry.isFile) {\n                            allFiles.push(entry);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n            this._allFilesScopeCachePromise = deferred.promise();\n\n            const scopeTimer = PerfUtils.markStart(\"Project scope files cache: \" +\n                    scope.fullPath),\n                options = {\n                    sortList: sort\n                };\n\n            scope.visit(allFilesVisitor, options, function (err) {\n                if (err) {\n                    PerfUtils.finalizeMeasurement(scopeTimer);\n                    deferred.reject(err);\n                } else {\n                    PerfUtils.addMeasurement(scopeTimer);\n                    deferred.resolve(allFiles);\n                }\n            }.bind(this));\n        }\n\n        return this._allFilesScopeCachePromise;\n    };\n\n    /**\n     * Returns an Array of all files for this project, optionally including\n     * files additional files provided. Files are filtered out by shouldShow().\n     *\n     * @param {function (File, number):boolean=} filter Optional function to filter\n     *          the file list (does not filter directory traversal). API matches Array.filter().\n     * @param {Array.<File>=} additionalFiles Additional files to include (for example, the WorkingSet)\n     *          Only adds files that are *not* under the project root or untitled documents.\n     * @param {boolean} sort true to sort files by their paths\n     * @param {Object} options optional path within project to narrow down the search\n     * @param {File} options.scope optional path within project to narrow down the search\n     *\n     * @return {$.Promise} Promise that is resolved with an Array of File objects.\n     */\n    ProjectModel.prototype.getAllFiles = function getAllFiles(filter, additionalFiles, sort, options) {\n        // The filter and includeWorkingSet params are both optional.\n        // Handle the case where filter is omitted but includeWorkingSet is\n        // specified.\n        if (typeof (filter) !== \"function\") {\n            options = sort;\n            sort = additionalFiles;\n            additionalFiles = filter;\n            filter = null;\n        }\n        options = options || {};\n\n        var filteredFilesDeferred = new $.Deferred();\n\n        // First gather all files in project proper\n        // Note that with proper promises we may be able to fix this so that we're not doing this\n        // anti-pattern of creating a separate deferred rather than just chaining off of the promise\n        // from _getAllFilesCache\n        const getAllFilesFn = options.scope ?\n            this._getAllFilesInScopeCache.bind(this) : this._getAllFilesCache.bind(this);\n        getAllFilesFn(sort, options.scope).done(function (result) {\n            result = [...result]; // clone it as the above result is cached and we dont want to modify the cache\n            // Add working set entries, if requested\n            if (additionalFiles) {\n                additionalFiles.forEach(function (file) {\n                    if (result.indexOf(file) === -1 && !(file instanceof InMemoryFile)) {\n                        result.push(file);\n                    }\n                });\n            }\n\n            // Filter list, if requested\n            if (filter) {\n                result = result.filter(filter);\n            }\n\n            // If a done handler attached to the returned filtered files promise\n            // throws an exception that isn't handled here then it will leave\n            // _allFilesCachePromise in an inconsistent state such that no\n            // additional done handlers will ever be called!\n            try {\n                filteredFilesDeferred.resolve(result);\n            } catch (e) {\n                console.error(\"Unhandled exception in getAllFiles handler: \" + e, e.stack);\n            }\n        }).fail(function (err) {\n            try {\n                filteredFilesDeferred.reject(err);\n            } catch (e) {\n                console.error(\"Unhandled exception in getAllFiles handler: \" + e, e.stack);\n            }\n        });\n\n        return filteredFilesDeferred.promise();\n    };\n\n    /**\n     * @private\n     *\n     * Resets the all files cache.\n     */\n    ProjectModel.prototype._resetCache = function _resetCache() {\n        this._allFilesCachePromise = null;\n        this._allFilesScopeCachePromise = null;\n        this._allFilesScope = null;\n    };\n\n    /**\n     * Sets the project root (effectively resetting this ProjectModel).\n     *\n     * @param {Directory} projectRoot new project root\n     * @return {$.Promise} resolved when the project root has been updated\n     */\n    ProjectModel.prototype.setProjectRoot = function (projectRoot) {\n        this.projectRoot = projectRoot;\n        this._resetCache();\n        this._viewModel._rootChanged();\n\n        var d = new $.Deferred(),\n            self = this;\n\n        projectRoot.getContents(function (err, contents) {\n            if (err) {\n                d.reject(err);\n            } else {\n                self._viewModel.setDirectoryContents(\"\", contents);\n                d.resolve();\n            }\n        });\n        return d.promise();\n    };\n\n    /**\n     * @private\n     *\n     * Gets the contents of a directory at the given path.\n     *\n     * @param {string} path path to retrieve\n     * @return {$.Promise} Resolved with the directory contents.\n     */\n    ProjectModel.prototype._getDirectoryContents = function (path) {\n        var d = new $.Deferred();\n        FileSystem.getDirectoryForPath(path).getContents(function (err, contents) {\n            if (err) {\n                d.reject(err);\n            } else {\n                d.resolve(contents);\n            }\n        });\n        return d.promise();\n    };\n\n    /**\n     * Opens or closes the given directory in the file tree.\n     *\n     * @param {string} path Path to open\n     * @param {boolean} open `true` to open the path\n     * @return {$.Promise} resolved when the path has been opened.\n     */\n    ProjectModel.prototype.setDirectoryOpen = function (path, open) {\n        var projectRelative = this.makeProjectRelativeIfPossible(path),\n            needsLoading    = !this._viewModel.isPathLoaded(projectRelative),\n            d               = new $.Deferred(),\n            self            = this;\n\n        function onSuccess(contents) {\n            // Update the view model\n            if (contents) {\n                self._viewModel.setDirectoryContents(projectRelative, contents);\n            }\n\n            if (open) {\n                self._viewModel.openPath(projectRelative);\n                if (self._focused) {\n                    var currentPathInProject = self.makeProjectRelativeIfPossible(self._currentPath);\n                    if (self._viewModel.isFilePathVisible(currentPathInProject)) {\n                        self.setSelected(self._currentPath, true);\n                    } else {\n                        self.setSelected(null);\n                    }\n                }\n            } else {\n                self._viewModel.setDirectoryOpen(projectRelative, false);\n                var selected = self._selections.selected;\n                if (selected) {\n                    var relativeSelected = self.makeProjectRelativeIfPossible(selected);\n                    if (!self._viewModel.isFilePathVisible(relativeSelected)) {\n                        self.setSelected(null);\n                    }\n                }\n            }\n\n            d.resolve();\n        }\n\n        // If the view model doesn't have the data it needs, we load it now, otherwise we can just\n        // manage the selection and resovle the promise.\n        if (open && needsLoading) {\n            var parentDirectory = FileUtils.getDirectoryPath(FileUtils.stripTrailingSlash(path));\n            this.setDirectoryOpen(parentDirectory, true).then(function () {\n                self._getDirectoryContents(path).then(onSuccess).fail(function (err) {\n                    d.reject(err);\n                });\n            }, function (err) {\n                d.reject(err);\n            });\n        } else {\n            onSuccess();\n        }\n\n        return d.promise();\n    };\n\n    /**\n     * Shows the given path in the tree and selects it if it's a file. Any intermediate directories\n     * will be opened and a promise is returned to show when the entire operation is complete.\n     *\n     * @param {string|File|Directory} path full path to the file or directory\n     * @return {$.Promise} promise resolved when the path is shown\n     */\n    ProjectModel.prototype.showInTree = function (path) {\n        var d = new $.Deferred();\n        path = _getPathFromFSObject(path);\n\n        if (!this.isWithinProject(path)) {\n            Phoenix.app.openPathInFileBrowser(path)\n                .then(d.resolve)\n                .catch(d.reject);\n            return d.promise();\n        }\n\n        const self = this;\n        this.setDirectoryOpen(FileUtils.getDirectoryPath(path), true).then(function () {\n            if (_pathIsFile(path)) {\n                self.setSelected(path);\n            }\n            d.resolve();\n        }, function (err) {\n            d.reject(err);\n        });\n        return d.promise();\n    };\n\n    /**\n     * Selects the given path in the file tree and opens the file (unless doNotOpen is specified).\n     * Directories will not be selected.\n     *\n     * When the selection changes, any rename operation that is currently underway will be completed.\n     *\n     * @param {string} path full path to the file being selected\n     * @param {boolean} doNotOpen `true` if the file should not be opened.\n     */\n    ProjectModel.prototype.setSelected = function (path, doNotOpen) {\n        path = _getPathFromFSObject(path);\n\n        // Directories are not selectable\n        if (!_pathIsFile(path)) {\n            return;\n        }\n\n        var oldProjectPath = this.makeProjectRelativeIfPossible(this._selections.selected),\n            pathInProject = this.makeProjectRelativeIfPossible(path);\n\n        if (path && !this._viewModel.isFilePathVisible(pathInProject)) {\n            path = null;\n            pathInProject = null;\n        }\n\n        this.performRename();\n\n        this._viewModel.moveMarker(\"selected\", oldProjectPath, pathInProject);\n        if (this._selections.context) {\n            this._viewModel.moveMarker(\"context\", this.makeProjectRelativeIfPossible(this._selections.context), null);\n            delete this._selections.context;\n        }\n\n        var previousSelection = this._selections.selected;\n        this._selections.selected = path;\n\n        if (path) {\n            if (!doNotOpen) {\n                this.trigger(EVENT_SHOULD_SELECT, {\n                    path: path,\n                    previousPath: previousSelection,\n                    hadFocus: this._focused\n                });\n            }\n\n            this.trigger(EVENT_SHOULD_FOCUS);\n        }\n    };\n\n    /**\n     * Gets the currently selected file or directory.\n     *\n     * @return {FileSystemEntry} the filesystem object for the currently selected file\n     */\n    ProjectModel.prototype.getSelected = function () {\n        return _getFSObject(this._selections.selected);\n    };\n\n    /**\n     * Keeps track of which file is currently being edited.\n     *\n     * @param {File|string} curFile Currently edited file.\n     */\n    ProjectModel.prototype.setCurrentFile = function (curFile) {\n        this._currentPath = _getPathFromFSObject(curFile);\n    };\n\n    /**\n     * Adds the file at the given path to the Working Set and selects it there.\n     *\n     * @param {string} path full path of file to open in Working Set\n     */\n    ProjectModel.prototype.selectInWorkingSet = function (path) {\n        this.performRename();\n        this.trigger(EVENT_SHOULD_SELECT, {\n            path: path,\n            add: true\n        });\n    };\n\n    /**\n     * Sets the context (for context menu operations) to the given path. This is independent from the\n     * open/selected file.\n     *\n     * @param {string} path full path of file or directory to which the context should be setBaseUrl\n     * @param {boolean} _doNotRename True if this context change should not cause a rename operation to finish. This is a special case that goes with context menu handling.\n     * @param {boolean} _saveContext True if the current context should be saved (see comment below)\n     */\n    ProjectModel.prototype.setContext = function (path, _doNotRename, _saveContext) {\n        // This bit is not ideal: when the user right-clicks on an item in the file tree\n        // and there is already a context menu up, the FileTreeView sends a signal to set the\n        // context to the new element but the PopupManager follows that with a message that it's\n        // closing the context menu (because it closes the previous one and then opens the new\n        // one.) This timing means that we need to provide some special case handling here.\n        if (_saveContext) {\n            if (!path) {\n                this._selections.previousContext = this._selections.context;\n            } else {\n                this._selections.previousContext = path;\n            }\n        } else {\n            delete this._selections.previousContext;\n        }\n\n        path = _getPathFromFSObject(path);\n\n        if (!_doNotRename) {\n            this.performRename();\n        }\n        var currentContext = this._selections.context;\n        this._selections.context = path;\n        this._viewModel.moveMarker(\"context\", this.makeProjectRelativeIfPossible(currentContext),\n                                   this.makeProjectRelativeIfPossible(path));\n    };\n\n    /**\n     * Restores the context to the last non-null context. This is specifically here to handle\n     * the sequence of messages that we get from the project context menu.\n     */\n    ProjectModel.prototype.restoreContext = function () {\n        if (this._selections.previousContext) {\n            this.setContext(this._selections.previousContext);\n        }\n    };\n\n    /**\n     * Gets the currently selected context.\n     *\n     * @return {FileSystemEntry} filesystem object for the context file or directory\n     */\n    ProjectModel.prototype.getContext = function () {\n        return _getFSObject(this._selections.context);\n    };\n\n    /**\n     * Starts a rename operation for the file or directory at the given path. If the path is\n     * not provided, the current context is used.\n     *\n     * If a rename operation is underway, it will be completed automatically.\n     *\n     * The Promise returned is resolved with an object with a `newPath` property with the renamed path. If the user cancels the operation, the promise is resolved with the value RENAME_CANCELLED.\n     *\n     * @param {string=} path optional path to start renaming\n     * @param {boolean=} isMoved optional flag which indicates whether the entry is being moved instead of renamed\n     * @return {$.Promise} resolved when the operation is complete.\n     */\n    ProjectModel.prototype.startRename = function (path, isMoved) {\n        var d = new $.Deferred();\n        path = _getPathFromFSObject(path);\n        if (!path) {\n            path = this._selections.context;\n            if (!path) {\n                return d.resolve().promise();\n            }\n        }\n\n        if (this._selections.rename && this._selections.rename.path === path) {\n            return d.resolve().promise();\n        }\n\n        if (!this.isWithinProject(path)) {\n            return d.reject({\n                type: ERROR_NOT_IN_PROJECT,\n                isFolder: !_pathIsFile(path),\n                fullPath: path\n            }).promise();\n        }\n\n        var projectRelativePath = this.makeProjectRelativeIfPossible(path);\n\n        if (!this._viewModel.isFilePathVisible(projectRelativePath)) {\n            this.showInTree(path);\n        }\n\n        if (!isMoved) {\n            if (path !== this._selections.context) {\n                this.setContext(path);\n            } else {\n                this.performRename();\n            }\n\n            this._viewModel.moveMarker(\"rename\", null,\n                projectRelativePath);\n        }\n        this._selections.rename = {\n            deferred: d,\n            type: FILE_RENAMING,\n            path: path,\n            newPath: path\n        };\n        return d.promise();\n    };\n\n    /**\n     * Sets the new value for the rename operation that is in progress (started previously with a call\n     * to `startRename`).\n     *\n     * @param {string} newPath new path for the file or directory being renamed\n     */\n    ProjectModel.prototype.setRenameValue = function (newPath) {\n        if (!this._selections.rename) {\n            return;\n        }\n        this._selections.rename.newPath = newPath;\n    };\n\n    /**\n     * Cancels the rename operation that is in progress. This resolves the original promise with\n     * a RENAME_CANCELLED value.\n     */\n    ProjectModel.prototype.cancelRename = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo) {\n            return;\n        }\n\n        // File creation is a special case.\n        if (renameInfo.type === FILE_CREATING) {\n            this._cancelCreating();\n            return;\n        }\n\n        this._viewModel.moveMarker(\"rename\", this.makeProjectRelativeIfPossible(renameInfo.path), null);\n        renameInfo.deferred.resolve(RENAME_CANCELLED);\n        delete this._selections.rename;\n        this.setContext(null);\n    };\n\n    /**\n     * @private\n     *\n     * Renames the item at the old path to the new name provided.\n     *\n     * @param {string} oldPath full path to the current location of file or directory (should include trailing slash for directory)\n     * @param {string} newPath full path to the new location of the file or directory\n     * @param {string} newName new name for the file or directory\n     */\n    ProjectModel.prototype._renameItem = function (oldPath, newPath, newName) {\n        const result = new $.Deferred();\n        const isFolder = !_pathIsFile(oldPath);\n        const self = this;\n\n        if (oldPath === newPath) {\n            result.resolve();\n        } else if (!isValidFilename(newName)) {\n            result.reject(ERROR_INVALID_FILENAME);\n        } else {\n            var entry = isFolder ? FileSystem.getDirectoryForPath(oldPath) : FileSystem.getFileForPath(oldPath);\n            self.trigger(EVENT_FS_RENAME_STARTED);\n            entry.rename(newPath, function (err) {\n                self.trigger(EVENT_FS_RENAME_END);\n                if (err) {\n                    result.reject(err);\n                } else {\n                    result.resolve();\n                }\n            });\n        }\n\n        return result.promise();\n    };\n\n    /**\n     * Completes the rename operation that is in progress.\n     */\n    ProjectModel.prototype.performRename = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo) {\n            return;\n        }\n        var oldPath         = renameInfo.path,\n            isFolder        = renameInfo.isFolder || !_pathIsFile(oldPath),\n            oldProjectPath  = this.makeProjectRelativeIfPossible(oldPath),\n\n            // To get the parent directory, we need to strip off the trailing slash on a directory name\n            parentDirectory = FileUtils.getDirectoryPath(isFolder ? FileUtils.stripTrailingSlash(oldPath) : oldPath),\n            oldName         = FileUtils.getBaseName(oldPath),\n            newPath         = renameInfo.newPath,\n            newName         = FileUtils.getBaseName(newPath),\n            viewModel       = this._viewModel,\n            self            = this;\n\n        if (renameInfo.type !== FILE_CREATING && oldPath === newPath) {\n            this.cancelRename();\n            return;\n        }\n\n        if (isFolder && _.last(newPath) !== \"/\") {\n            newPath += \"/\";\n        }\n\n        delete this._selections.rename;\n        delete this._selections.context;\n\n        viewModel.moveMarker(\"rename\", oldProjectPath, null);\n        viewModel.moveMarker(\"context\", oldProjectPath, null);\n        viewModel.moveMarker(\"creating\", oldProjectPath, null);\n\n        function finalizeRename() {\n            viewModel.renameItem(oldProjectPath, self.makeProjectRelativeIfPossible(newPath));\n            if (self._selections.selected && self._selections.selected.indexOf(oldPath) === 0) {\n                self._selections.selected = newPath + self._selections.selected.slice(oldPath.length);\n                self.setCurrentFile(newPath);\n            }\n        }\n\n        if (renameInfo.type === FILE_CREATING) {\n            this.createAtPath(newPath).done(function (entry) {\n                finalizeRename();\n                renameInfo.deferred.resolve(entry);\n            }).fail(function (error) {\n                self._viewModel.deleteAtPath(self.makeProjectRelativeIfPossible(renameInfo.path));\n                renameInfo.deferred.reject(error);\n            });\n        } else {\n            this._renameItem(oldPath, newPath, newName).then(function () {\n                finalizeRename();\n                renameInfo.deferred.resolve({\n                    newPath: newPath\n                });\n            }).fail(function (errorType) {\n                var errorInfo = {\n                    type: errorType,\n                    isFolder: isFolder,\n                    fullPath: oldPath\n                };\n                renameInfo.deferred.reject(errorInfo);\n            });\n        }\n    };\n\n    /**\n     * Creates a file or folder at the given path. Folder paths should have a trailing slash.\n     *\n     * If an error comes up during creation, the ERROR_CREATION event is triggered.\n     *\n     * @param {string} path full path to file or folder to create\n     * @return {$.Promise} resolved when creation is complete\n     */\n    ProjectModel.prototype.createAtPath = function (path) {\n        var isFolder  = !_pathIsFile(path),\n            name      = FileUtils.getBaseName(path),\n            self      = this;\n\n        return doCreate(path, isFolder).done(function (entry) {\n            if (!isFolder) {\n                self.selectInWorkingSet(entry.fullPath);\n            }\n        }).fail(function (error) {\n            self.trigger(ERROR_CREATION, {\n                type: error,\n                name: name,\n                isFolder: isFolder\n            });\n        });\n    };\n\n    /**\n     * Starts creating a file or folder with the given name in the given directory.\n     *\n     * The Promise returned is resolved with an object with a `newPath` property with the renamed path. If the user cancels the operation, the promise is resolved with the value RENAME_CANCELLED.\n     *\n     * @param {string} basedir directory that should contain the new entry\n     * @param {string} newName initial name for the new entry (the user can rename it)\n     * @param {boolean} isFolder `true` if the entry being created is a folder\n     * @return {$.Promise} resolved when the user is done creating the entry.\n     */\n    ProjectModel.prototype.startCreating = function (basedir, newName, isFolder) {\n        this.performRename();\n        var d = new $.Deferred(),\n            self = this;\n\n        this.setDirectoryOpen(basedir, true).then(function () {\n            self._viewModel.createPlaceholder(self.makeProjectRelativeIfPossible(basedir), newName, isFolder);\n            var promise = self.startRename(basedir + newName);\n            self._selections.rename.type = FILE_CREATING;\n            if (isFolder) {\n                self._selections.rename.isFolder = isFolder;\n            }\n            promise.then(d.resolve).fail(d.reject);\n        }).fail(function (err) {\n            d.reject(err);\n        });\n        return d.promise();\n    };\n\n    /**\n     * Cancels the creation process that is underway. The original promise returned will be resolved with the\n     * RENAME_CANCELLED value. The temporary entry added to the file tree will be deleted.\n     */\n    ProjectModel.prototype._cancelCreating = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo || renameInfo.type !== FILE_CREATING) {\n            return;\n        }\n        this._viewModel.deleteAtPath(this.makeProjectRelativeIfPossible(renameInfo.path));\n        renameInfo.deferred.resolve(RENAME_CANCELLED);\n        delete this._selections.rename;\n        this.setContext(null);\n    };\n\n    /**\n     * Sets the `sortDirectoriesFirst` option for the file tree view.\n     *\n     * @param {boolean} True if directories should appear first\n     */\n    ProjectModel.prototype.setSortDirectoriesFirst = function (sortDirectoriesFirst) {\n        this._viewModel.setSortDirectoriesFirst(sortDirectoriesFirst);\n    };\n\n    /**\n     * Gets an array of arrays where each entry of the top-level array has an array\n     * of paths that are at the same depth in the tree. All of the paths are full paths.\n     *\n     * @return {Array.<Array.<string>>} Array of array of full paths, organized by depth in the tree.\n     */\n    ProjectModel.prototype.getOpenNodes = function () {\n        return this._viewModel.getOpenNodes(this.projectRoot.fullPath);\n    };\n\n    /**\n     * Reopens a set of nodes in the tree by full path.\n     * @param {Array.<Array.<string>>} nodesByDepth An array of arrays of node ids to reopen. The ids within\n     *     each sub-array are reopened in parallel, and the sub-arrays are reopened in order, so they should\n     *     be sorted by depth within the tree.\n     * @return {$.Deferred} A promise that will be resolved when all nodes have been fully\n     *     reopened.\n     */\n    ProjectModel.prototype.reopenNodes = function (nodesByDepth) {\n        var deferred = new $.Deferred();\n\n        if (!nodesByDepth || nodesByDepth.length === 0) {\n            // All paths are opened and fully rendered.\n            return deferred.resolve().promise();\n        }\n        var self = this;\n        return Async.doSequentially(nodesByDepth, function (toOpenPaths) {\n            return Async.doInParallel(\n                    toOpenPaths,\n                    function (path) {\n                        return self._getDirectoryContents(path).then(function (contents) {\n                            var relative = self.makeProjectRelativeIfPossible(path);\n                            self._viewModel.setDirectoryContents(relative, contents);\n                            self._viewModel.setDirectoryOpen(relative, true);\n                        });\n                    },\n                    false\n                );\n        });\n\n    };\n\n    /**\n     * Clears caches and refreshes the contents of the tree.\n     *\n     * @return {$.Promise} resolved when the tree has been refreshed\n     */\n    ProjectModel.prototype.refresh = function () {\n        var projectRoot = this.projectRoot,\n            openNodes   = this.getOpenNodes(),\n            self        = this,\n            selections  = this._selections,\n            viewModel   = this._viewModel,\n            deferred    = new $.Deferred();\n\n        this.setProjectRoot(projectRoot).then(function () {\n            self.reopenNodes(openNodes).then(function () {\n                if (selections.selected) {\n                    viewModel.moveMarker(\"selected\", null, self.makeProjectRelativeIfPossible(selections.selected));\n                }\n\n                if (selections.context) {\n                    viewModel.moveMarker(\"context\", null, self.makeProjectRelativeIfPossible(selections.context));\n                }\n\n                if (selections.rename) {\n                    viewModel.moveMarker(\"rename\", null, self.makeProjectRelativeIfPossible(selections.rename));\n                }\n\n                deferred.resolve();\n            });\n        });\n\n        return deferred.promise();\n    };\n\n    /**\n     * Handles filesystem change events and prepares the update for the view model.\n     *\n     * @param {?(File|Directory)} entry File or Directory changed\n     * @param {Array.<FileSystemEntry>=} added If entry is a Directory, contains zero or more added children\n     * @param {Array.<FileSystemEntry>=} removed If entry is a Directory, contains zero or more removed\n     */\n    ProjectModel.prototype.handleFSEvent = function (entry, added, removed) {\n        this._resetCache();\n\n        if (!entry) {\n            this.refresh();\n            return;\n        }\n\n        if (!this.isWithinProject(entry)) {\n            return;\n        }\n\n        var changes = {},\n            self = this;\n\n        if (entry.isFile) {\n            changes.changed = [\n                this.makeProjectRelativeIfPossible(entry.fullPath)\n            ];\n        } else {\n            // Special case: a directory passed in without added and removed values\n            // needs to be updated.\n            if (!added && !removed) {\n                entry.getContents(function (err, contents) {\n                    if (err) {\n                        console.error(\"Unexpected error refreshing file tree for directory \" + entry.fullPath + \": \" + err, err.stack);\n                        return;\n                    }\n                    self._viewModel.setDirectoryContents(self.makeProjectRelativeIfPossible(entry.fullPath), contents);\n                });\n\n                // Exit early because we can't update the viewModel until we get the directory contents.\n                return;\n            }\n        }\n\n        if (added) {\n            changes.added = added.map(function (entry) {\n                return self.makeProjectRelativeIfPossible(entry.fullPath);\n            });\n        }\n\n        if (removed) {\n            if (this._selections.selected &&\n                    _.find(removed, { fullPath: this._selections.selected })) {\n                this.setSelected(null);\n            }\n\n            if (this._selections.rename &&\n                    _.find(removed, { fullPath: this._selections.rename.path })) {\n                this.cancelRename();\n            }\n\n            if (this._selections.context &&\n                    _.find(removed, { fullPath: this._selections.context })) {\n                this.setContext(null);\n            }\n            changes.removed = removed.map(function (entry) {\n                return self.makeProjectRelativeIfPossible(entry.fullPath);\n            });\n        }\n\n        this._viewModel.processChanges(changes);\n    };\n\n    /**\n     * Closes the directory at path and recursively closes all of its children.\n     *\n     * @param {string} path Path of subtree to close\n     */\n    ProjectModel.prototype.closeSubtree = function (path) {\n        this._viewModel.closeSubtree(this.makeProjectRelativeIfPossible(path));\n    };\n\n    /**\n     * Toggle the open state of subdirectories.\n     * @param {!string}  path        parent directory\n     * @param {boolean} openOrClose  true to open directory, false to close\n     * @return {$.Promise} promise resolved when the directories are open\n     */\n    ProjectModel.prototype.toggleSubdirectories = function (path, openOrClose) {\n        var self = this,\n            d = new $.Deferred();\n\n        this.setDirectoryOpen(path, true).then(function () {\n            var projectRelativePath = self.makeProjectRelativeIfPossible(path),\n                childNodes = self._viewModel.getChildDirectories(projectRelativePath);\n\n            Async.doInParallel(childNodes, function (node) {\n                return self.setDirectoryOpen(path + node, openOrClose);\n            }, true).then(function () {\n                d.resolve();\n            }, function (err) {\n                d.reject(err);\n            });\n        });\n\n        return d.promise();\n    };\n\n    /**\n     * Although Brackets is generally standardized on folder paths with a trailing \"/\", some APIs here\n     * receive project paths without \"/\" due to legacy preference storage formats, etc.\n     * @param {!string} fullPath  Path that may or may not end in \"/\"\n     * @return {!string} Path that ends in \"/\"\n     */\n    function _ensureTrailingSlash(fullPath) {\n        if (_pathIsFile(fullPath)) {\n            return fullPath + \"/\";\n        }\n        return fullPath;\n    }\n\n    /**\n     * @private\n     *\n     * Returns the full path to the welcome project, which we open on first launch.\n     *\n     * @param {string} sampleUrl URL for getting started project\n     * @param {string} initialPath Path to Brackets directory (see {@link FileUtils::#getNativeBracketsDirectoryPath})\n     * @return {!string} fullPath reference\n     */\n    function _getWelcomeProjectPath(sampleUrl, initialPath) {\n        if (sampleUrl) {\n            // Back up one more folder. The samples folder is assumed to be at the same level as\n            // the src folder, and the sampleUrl is relative to the samples folder.\n            initialPath = initialPath.substr(0, initialPath.lastIndexOf(\"/\")) + \"/samples/\" + sampleUrl;\n        }\n\n        return _ensureTrailingSlash(initialPath); // paths above weren't canonical\n    }\n\n    /**\n     * @private\n     *\n     * Adds the path to the list of welcome projects we've ever seen, if not on the list already.\n     *\n     * @param {string} path Path to possibly add\n     * @param {Array.<string>=} currentProjects Array of current welcome projects\n     * @return {Array.<string>} New array of welcome projects with the additional project added\n     */\n    function _addWelcomeProjectPath(path, currentProjects) {\n        var pathNoSlash = FileUtils.stripTrailingSlash(path);  // \"welcomeProjects\" pref has standardized on no trailing \"/\"\n\n        var newProjects;\n\n        if (currentProjects) {\n            newProjects = _.clone(currentProjects);\n        } else {\n            newProjects = [];\n        }\n\n        if (newProjects.indexOf(pathNoSlash) === -1) {\n            newProjects.push(pathNoSlash);\n        }\n        return newProjects;\n    }\n\n    /**\n     * Returns true if the given path is the same as one of the welcome projects we've previously opened,\n     * or the one for the current build.\n     *\n     * @param {string} path Path to check to see if it's a welcome project\n     * @param {string} welcomeProjectPath Current welcome project path\n     * @param {Array.<string>=} welcomeProjects All known welcome projects\n     */\n    function _isWelcomeProjectPath(path, welcomeProjectPath, welcomeProjects) {\n        if (path === welcomeProjectPath) {\n            return true;\n        }\n\n        // No match on the current path, and it's not a match if there are no previously known projects\n        if (!welcomeProjects) {\n            return false;\n        }\n\n        var pathNoSlash = FileUtils.stripTrailingSlash(path);  // \"welcomeProjects\" pref has standardized on no trailing \"/\"\n        return welcomeProjects.indexOf(pathNoSlash) !== -1;\n    }\n\n    // private APIs\n    exports._getWelcomeProjectPath  = _getWelcomeProjectPath;\n    exports._addWelcomeProjectPath  = _addWelcomeProjectPath;\n    exports._isWelcomeProjectPath   = _isWelcomeProjectPath;\n    exports._ensureTrailingSlash    = _ensureTrailingSlash;\n    exports._shouldShowName         = _shouldShowName;\n    exports._invalidChars           = \"? * | : / < > \\\\ | \\\" ..\";\n\n    exports.shouldShow              = shouldShow;\n    exports.shouldIndex             = shouldIndex;\n    exports.defaultIgnoreGlobs      = defaultIgnoreGlobs;\n    exports.isValidFilename         = isValidFilename;\n    exports.isValidPath             = isValidPath;\n    exports.EVENT_CHANGE            = EVENT_CHANGE;\n    exports.EVENT_SHOULD_SELECT     = EVENT_SHOULD_SELECT;\n    exports.EVENT_SHOULD_FOCUS      = EVENT_SHOULD_FOCUS;\n    exports.EVENT_FS_RENAME_STARTED = EVENT_FS_RENAME_STARTED;\n    exports.EVENT_FS_RENAME_END     = EVENT_FS_RENAME_END;\n    exports.ERROR_CREATION          = ERROR_CREATION;\n    exports.ERROR_INVALID_FILENAME  = ERROR_INVALID_FILENAME;\n    exports.ERROR_NOT_IN_PROJECT    = ERROR_NOT_IN_PROJECT;\n    exports.FILE_RENAMING           = FILE_RENAMING;\n    exports.FILE_CREATING           = FILE_CREATING;\n    exports.RENAME_CANCELLED        = RENAME_CANCELLED;\n    exports.doCreate                = doCreate;\n    exports.ProjectModel            = ProjectModel;\n});\n"],"file":"ProjectModel.js"}
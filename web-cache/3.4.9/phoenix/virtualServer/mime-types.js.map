{"version":3,"sources":["phoenix/virtualServer/mime-types.js"],"names":["importScripts","self","mime","db","MIME_TYPE_DATABASE_REFERENCE","path","console","error","EXTRACT_TYPE_REGEXP","TEXT_TYPE_REGEXP","charset","type","match","exec","toLowerCase","test","contentType","str","indexOf","lookup","extension","exts","extensions","length","extname","substr","types","populateMaps","preference","undefined","Object","keys","forEach","forEachMimeType","i","from","source","to","charsets","text/html","htm","html","shtml"],"mappings":"AAsBAA,cAAc,oCAMVC,KAAKC,MACJ,WACGD,KAAKC,KAAM,GACX,IAAIC,GAAKC,6BAEJH,KAAKI,MACNC,QAAQC,MAAM,qDAOlB,IAAIC,oBAAsB,0BACtBC,iBAAmB,WAgCvB,SAASC,QAAQC,MACb,IAAKA,MAAwB,iBAATA,KAChB,OAAO,EAIX,IAAIC,MAAQJ,oBAAoBK,KAAKF,MACjCT,KAAOU,OAAST,GAAGS,MAAM,GAAGE,eAEhC,OAAIZ,MAAQA,KAAKQ,QACNR,KAAKQ,WAIZE,QAASH,iBAAiBM,KAAKH,MAAM,MAC9B,QAaf,SAASI,YAAYC,KAEjB,IAAKA,KAAsB,iBAARA,IACf,OAAO,EAGX,IAAIf,MAA6B,IAAtBe,IAAIC,QAAQ,KACjBjB,KAAKC,KAAKiB,OAAOF,KACjBA,IAEN,IAAKf,KACD,OAAO,EAIX,IAAiC,IAA7BA,KAAKgB,QAAQ,WAAmB,CAChC,IAAIR,QAAUT,KAAKC,KAAKQ,QAAQR,MAC5BQ,UAAWR,MAAQ,aAAeQ,QAAQI,eAGlD,OAAOZ,KAUX,SAASkB,UAAUT,MACf,IAAKA,MAAwB,iBAATA,KAChB,OAAO,EAIX,IAAIC,MAAQJ,oBAAoBK,KAAKF,MAGjCU,KAAOT,OAASX,KAAKC,KAAKoB,WAAWV,MAAM,GAAGE,eAElD,SAAKO,OAASA,KAAKE,SAIZF,KAAK,GAUhB,SAASF,OAAOd,MACZ,IAAKA,MAAwB,iBAATA,KAChB,OAAO,EAIX,IAAIe,UAAYnB,KAAKI,KAAKmB,QAAQ,KAAOnB,MACpCS,cACAW,OAAO,GAEZ,OAAKL,WAIEnB,KAAKC,KAAKwB,MAAMN,aAHZ,EAWf,SAASO,aAAaL,WAAYI,OAE9B,IAAIE,WAAa,CAAC,QAAS,cAAUC,EAAW,QAEhDC,OAAOC,KAAK5B,IAAI6B,QAAQ,SAASC,gBAAgBtB,MAC7C,IAAIT,KAAOC,GAAGQ,MACVU,KAAOnB,KAAKoB,WAEhB,GAAKD,MAASA,KAAKE,OAAnB,CAKAD,WAAWX,MAAQU,KAGnB,IAAK,IAAIa,EAAI,EAAGA,EAAIb,KAAKE,OAAQW,IAAK,CAClC,IAAId,UAAYC,KAAKa,GAErB,GAAIR,MAAMN,WAAY,CAClB,IAAIe,KAAOP,WAAWV,QAAQf,GAAGuB,MAAMN,YAAYgB,QAC/CC,GAAKT,WAAWV,QAAQhB,KAAKkC,QAEjC,GAAyB,6BAArBV,MAAMN,aACLe,KAAOE,IAAOF,OAASE,IAAyC,iBAAnCX,MAAMN,WAAWK,OAAO,EAAG,KAEzD,SAKRC,MAAMN,WAAaT,SAjK/BV,KAAKC,KAAKQ,QAAUA,QACpBT,KAAKC,KAAKoC,SAAW,CAACnB,OAAQT,SAC9BT,KAAKC,KAAKc,YAAcA,YACxBf,KAAKC,KAAKkB,UAAYA,UACtBnB,KAAKC,KAAKoB,WAAa,CACnBiB,YAAa,CACT,OACA,MACA,UAGRtC,KAAKC,KAAKiB,OAASA,OACnBlB,KAAKC,KAAKwB,MAAQ,CACdc,IAAK,YACLC,KAAM,YACNC,MAAO,aAuJXf,aAAa1B,KAAKC,KAAKoB,WAAYrB,KAAKC,KAAKwB,OA1LjD","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * modified by core.ai, based on  mime-types lib https://github.com/jshttp/mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*globals MIME_TYPE_DATABASE_REFERENCE*/\nimportScripts('phoenix/virtualServer/mime-db.js');\n\n/**\n * Web worker env\n * based on  mime-types lib https://github.com/jshttp/mime-types\n */\nif(!self.mime){\n    (function() {\n        self.mime ={};\n        let db = MIME_TYPE_DATABASE_REFERENCE;\n\n        if (!self.path) {\n            console.error(\"Phoenix fs lib should be loaded before mime type.\");\n        }\n        /**\n         * Module variables.\n         * @private\n         */\n\n        var EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/;\n        var TEXT_TYPE_REGEXP = /^text\\//i;\n\n        /**\n         * Module exports.\n         * @public\n         */\n\n        self.mime.charset = charset;\n        self.mime.charsets = {lookup: charset};\n        self.mime.contentType = contentType;\n        self.mime.extension = extension;\n        self.mime.extensions = {\n            \"text/html\": [\n                \"html\",\n                \"htm\",\n                \"shtml\"\n            ]\n        };\n        self.mime.lookup = lookup;\n        self.mime.types = {\n            htm: \"text/html\",\n            html: \"text/html\",\n            shtml: \"text/html\"\n        };\n\n        /**\n         * Get the default charset for a MIME type.\n         *\n         * @param {string} type\n         * @return {boolean|string}\n         */\n\n        function charset(type) {\n            if (!type || typeof type !== 'string') {\n                return false;\n            }\n\n            // TODO: use media-typer\n            var match = EXTRACT_TYPE_REGEXP.exec(type);\n            var mime = match && db[match[1].toLowerCase()];\n\n            if (mime && mime.charset) {\n                return mime.charset;\n            }\n\n            // default text/* to utf-8\n            if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n                return 'UTF-8';\n            }\n\n            return false;\n        }\n\n        /**\n         * Create a full Content-Type header given a MIME type or extension.\n         *\n         * @param {string} str\n         * @return {boolean|string}\n         */\n\n        function contentType(str) {\n            // TODO: should this even be in this module?\n            if (!str || typeof str !== 'string') {\n                return false;\n            }\n\n            var mime = str.indexOf('/') === -1\n                ? self.mime.lookup(str)\n                : str;\n\n            if (!mime) {\n                return false;\n            }\n\n            // TODO: use content-type or other module\n            if (mime.indexOf('charset') === -1) {\n                var charset = self.mime.charset(mime);\n                if (charset) { mime += '; charset=' + charset.toLowerCase(); }\n            }\n\n            return mime;\n        }\n\n        /**\n         * Get the default extension for a MIME type.\n         *\n         * @param {string} type\n         * @return {boolean|string}\n         */\n\n        function extension(type) {\n            if (!type || typeof type !== 'string') {\n                return false;\n            }\n\n            // TODO: use media-typer\n            var match = EXTRACT_TYPE_REGEXP.exec(type);\n\n            // get extensions\n            var exts = match && self.mime.extensions[match[1].toLowerCase()];\n\n            if (!exts || !exts.length) {\n                return false;\n            }\n\n            return exts[0];\n        }\n\n        /**\n         * Lookup the MIME type for a file path/extension.\n         *\n         * @param {string} path\n         * @return {boolean|string}\n         */\n\n        function lookup(path) {\n            if (!path || typeof path !== 'string') {\n                return false;\n            }\n\n            // get the extension (\"ext\" or \".ext\" or full path)\n            var extension = self.path.extname('x.' + path)\n                .toLowerCase()\n                .substr(1);\n\n            if (!extension) {\n                return false;\n            }\n\n            return self.mime.types[extension] || false;\n        }\n\n        /**\n         * Populate the extensions and types maps.\n         * @private\n         */\n\n        function populateMaps(extensions, types) {\n            // source preference (least -> most)\n            var preference = ['nginx', 'apache', undefined, 'iana'];\n\n            Object.keys(db).forEach(function forEachMimeType(type) {\n                var mime = db[type];\n                var exts = mime.extensions;\n\n                if (!exts || !exts.length) {\n                    return;\n                }\n\n                // mime -> extensions\n                extensions[type] = exts;\n\n                // extension -> mime\n                for (var i = 0; i < exts.length; i++) {\n                    var extension = exts[i];\n\n                    if (types[extension]) {\n                        var from = preference.indexOf(db[types[extension]].source);\n                        var to = preference.indexOf(mime.source);\n\n                        if (types[extension] !== 'application/octet-stream' &&\n                            (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n                            // skip the remapping\n                            continue;\n                        }\n                    }\n\n                    // set the extension -> mime\n                    types[extension] = type;\n                }\n            });\n        }\n\n        populateMaps(self.mime.extensions, self.mime.types);\n    }());\n}\n"],"file":"mime-types.js"}
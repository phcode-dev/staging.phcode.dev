{"version":3,"sources":["extensions/default/CSSAtRuleCodeHints/unittests.js"],"names":["define","require","exports","module","SpecRunnerUtils","brackets","getModule","CSSAtRuleCodeHints","describe","defaultContent","testDocument","testEditor","setupTest","content","languageId","mock","createMockEditor","doc","editor","tearDownTest","destroyMockEditor","expectHints","provider","implicitChar","returnWholeObj","expect","hasHints","toBe","hintsObj","getHints","toBeTruthy","hints","expectNoHints","verifyListsAreIdentical","hintList","values","i","length","selectHint","expectedHint","indexOf","not","insertHint","fixPos","pos","sticky","expectCursorAt","selection","getSelection","start","toEql","end","verifyFirstEntry","expectedFirstHint","verifyAllValues","sort","toString","modesToTest","modeCounter","selectMode","beforeEach","afterEach","testAllHints","setCursorPos","line","ch","restrictedBlockHints","testFilteredHints","testNoHintsOnSpace","testNoHints","it","getLine"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2017 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global describe, it, expect, beforeEach, afterEach */\n\ndefine(function (require, exports, module) {\n\n\n    var SpecRunnerUtils     = brackets.getModule(\"spec/SpecRunnerUtils\"),\n        CSSAtRuleCodeHints  = require(\"main\");\n\n    describe(\"CSS '@' rules Code Hinting\", function () {\n\n        var defaultContent = \"@ { \\n\" +\n                             \"} \\n\" +\n                             \" \\n\" +\n                             \"@m \";\n\n\n        var testDocument, testEditor;\n\n        /*\n         * Create a mockup editor with the given content and language id.\n         *\n         * @param {string} content - content for test window\n         * @param {string} languageId\n         */\n        function setupTest(content, languageId) {\n            var mock = SpecRunnerUtils.createMockEditor(content, languageId);\n            testDocument = mock.doc;\n            testEditor = mock.editor;\n        }\n\n        function tearDownTest() {\n            SpecRunnerUtils.destroyMockEditor(testDocument);\n            testEditor = null;\n            testDocument = null;\n        }\n\n        // Ask provider for hints at current cursor position; expect it to return some\n        function expectHints(provider, implicitChar, returnWholeObj) {\n            expect(provider.hasHints(testEditor, implicitChar)).toBe(true);\n            var hintsObj = provider.getHints();\n            expect(hintsObj).toBeTruthy();\n            // return just the array of hints if returnWholeObj is falsy\n            return returnWholeObj ? hintsObj : hintsObj.hints;\n        }\n\n        // Ask provider for hints at current cursor position; expect it NOT to return any\n        function expectNoHints(provider, implicitChar) {\n            expect(provider.hasHints(testEditor, implicitChar)).toBe(false);\n        }\n\n        // compares lists to ensure they are the same\n        function verifyListsAreIdentical(hintList, values) {\n            var i;\n            expect(hintList.length).toBe(values.length);\n            for (i = 0; i < values.length; i++) {\n                expect(hintList[i]).toBe(values[i]);\n            }\n        }\n\n\n        function selectHint(provider, expectedHint, implicitChar) {\n            var hintList = expectHints(provider, implicitChar);\n            expect(hintList.indexOf(expectedHint)).not.toBe(-1);\n            return provider.insertHint(expectedHint);\n        }\n\n        // Helper function for testing cursor position\n        function fixPos(pos) {\n            if (!(\"sticky\" in pos)) {\n                pos.sticky = null;\n            }\n            return pos;\n        }\n        function expectCursorAt(pos) {\n            var selection = testEditor.getSelection();\n            expect(fixPos(selection.start)).toEql(fixPos(selection.end));\n            expect(fixPos(selection.start)).toEql(fixPos(pos));\n        }\n\n        function verifyFirstEntry(hintList, expectedFirstHint) {\n            expect(hintList[0]).toBe(expectedFirstHint);\n        }\n\n        // Helper function to\n        // a) ensure the hintList and the list with the available values have the same size\n        // b) ensure that all possible values are mentioned in the hintList\n        function verifyAllValues(hintList, values) {\n            expect(hintList.length).toBe(values.length);\n            expect(hintList.sort().toString()).toBe(values.sort().toString());\n        }\n\n\n        var modesToTest = ['css', 'scss', 'less'],\n            modeCounter;\n\n\n        var selectMode = function () {\n            return modesToTest[modeCounter];\n        };\n\n        describe(\"'@' rules in styles mode (selection of correct restricted block based on input)\", function () {\n\n            beforeEach(function () {\n                // create Editor instance (containing a CodeMirror instance)\n                var mock = SpecRunnerUtils.createMockEditor(defaultContent, selectMode());\n                testEditor = mock.editor;\n                testDocument = mock.doc;\n            });\n\n            afterEach(function () {\n                SpecRunnerUtils.destroyMockEditor(testDocument);\n                testEditor = null;\n                testDocument = null;\n            });\n\n            var testAllHints = function () {\n                    testEditor.setCursorPos({ line: 0, ch: 1 });    // after @\n                    var hintList = expectHints(CSSAtRuleCodeHints.restrictedBlockHints);\n                    verifyFirstEntry(hintList, \"@charset\");  // filtered on \"empty string\"\n                    verifyListsAreIdentical(hintList, [\"@charset\",\n                        \"@counter-style\",\n                        \"@font-face\",\n                        \"@font-feature-values\",\n                        \"@import\",\n                        \"@keyframes\",\n                        \"@media\",\n                        \"@namespace\",\n                        \"@page\",\n                        \"@supports\"]);\n                },\n                testFilteredHints = function () {\n                    testEditor.setCursorPos({ line: 3, ch: 2 });    // after @m\n                    var hintList = expectHints(CSSAtRuleCodeHints.restrictedBlockHints);\n                    verifyFirstEntry(hintList, \"@media\");  // filtered on \"@m\"\n                    verifyListsAreIdentical(hintList, [\"@media\"]);\n                },\n                testNoHintsOnSpace = function () {\n                    testEditor.setCursorPos({ line: 3, ch: 3 });    // after {\n                    expect(CSSAtRuleCodeHints.restrictedBlockHints.hasHints(testEditor, '')).toBe(false);\n                },\n                testNoHints = function () {\n                    testEditor.setCursorPos({ line: 0, ch: 0 });    // after {\n                    expect(CSSAtRuleCodeHints.restrictedBlockHints.hasHints(testEditor, 'c')).toBe(false);\n                };\n\n            for (modeCounter in modesToTest) {\n                it(\"should list all rule hints right after @\", testAllHints);\n                it(\"should list filtered rule hints right after @m\", testFilteredHints);\n                it(\"should not list rule hints on space\", testNoHintsOnSpace);\n                it(\"should not list rule hints if the cursor is before @\", testNoHints);\n            }\n        });\n\n        describe(\"'@' rules in LESS mode (selection of correct restricted block based on input)\", function () {\n            defaultContent = \"@ { \\n\" +\n                             \"} \\n\" +\n                             \" \\n\" +\n                             \"@m \\n\" +\n                             \"@green: green;\\n\" +\n                             \".div { \\n\" +\n                             \"color: @\" +\n                             \"} \\n\";\n\n            beforeEach(function () {\n                // create Editor instance (containing a CodeMirror instance)\n                var mock = SpecRunnerUtils.createMockEditor(defaultContent, \"less\");\n                testEditor = mock.editor;\n                testDocument = mock.doc;\n            });\n\n            afterEach(function () {\n                SpecRunnerUtils.destroyMockEditor(testDocument);\n                testEditor = null;\n                testDocument = null;\n            });\n\n            it(\"should not list rule hints in less variable evaluation scope\", function () {\n                testEditor.setCursorPos({ line: 3, ch: 3 });    // after {\n                expect(CSSAtRuleCodeHints.restrictedBlockHints.hasHints(testEditor, '')).toBe(false);\n            });\n\n        });\n\n        describe(\"'@' rule hint insertion\", function () {\n            beforeEach(function () {\n                // create Editor instance (containing a CodeMirror instance)\n                var mock = SpecRunnerUtils.createMockEditor(defaultContent, \"css\");\n                testEditor = mock.editor;\n                testDocument = mock.doc;\n            });\n\n            afterEach(function () {\n                SpecRunnerUtils.destroyMockEditor(testDocument);\n                testEditor = null;\n                testDocument = null;\n            });\n\n            it(\"should insert @rule selected\", function () {\n                testEditor.setCursorPos({ line: 0, ch: 1 });   // cursor after '@'\n                selectHint(CSSAtRuleCodeHints.restrictedBlockHints, \"@charset\");\n                expect(testDocument.getLine(0)).toBe(\"@charset { \");\n                expectCursorAt({ line: 0, ch: 8 });\n            });\n\n            it(\"should insert filtered selection by replacing the existing rule\", function () {\n                testEditor.setCursorPos({ line: 3, ch: 2 });   // cursor after '@m'\n                selectHint(CSSAtRuleCodeHints.restrictedBlockHints, \"@media\");\n                expect(testDocument.getLine(3)).toBe(\"@media \");\n                expectCursorAt({ line: 3, ch: 6 });\n            });\n        });\n\n    });\n});\n\n"],"file":"unittests.js"}
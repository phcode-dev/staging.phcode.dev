{"version":3,"sources":["extensions/default/CodeFolding/foldhelpers/foldcode.js"],"names":["define","require","exports","module","CodeMirror","brackets","getModule","prefs","doFold","cm","pos","options","force","Pos","finder","rangeFinder","fold","auto","range","widget","textRange","getRange","allowFolded","to","line","from","getSetting","marks","findMarksAt","i","lastMark","foldMarks","length","__isFold","cleared","clear","filter","d","find","makeWidget","window","document","createElement","className","scanUp","firstLine","markText","replacedWith","clearOnEnter","on","e","preventDefault","_lineFolds","signal","init","defineExtension","this","folds","keys","rf","result","cachedRange","Object","forEach","lineNumber","lastLine","commands","foldCode","getCursor","unfold","foldAll","operation","unfoldAll","isFolded","unfoldCode","foldToLevel","start","end","foldLevel","n","undefined","registerHelper","funcs","Array","prototype","slice","call","arguments","found","helpers","getHelpers","mode","getMode","name","modeHelper","indexOf","push"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n// Based on http://codemirror.net/addon/fold/foldcode.js\n// Modified by Patrick Oladimeji for Brackets\n\ndefine(function (require, exports, module) {\n\n    var CodeMirror          = brackets.getModule(\"thirdparty/CodeMirror/lib/codemirror\"),\n        prefs               = require(\"Prefs\");\n\n    /**\n      * Performs the folding and unfolding of code regions.\n      * @param {CodeMirror} cm the CodeMirror instance\n      * @param {number| Object} pos\n      */\n    function doFold(cm, pos, options, force) {\n        options = options || {};\n        force = force || \"fold\";\n        if (typeof pos === \"number\") {\n            pos = CodeMirror.Pos(pos, 0);\n        }\n\n        var finder = options.rangeFinder || CodeMirror.fold.auto,\n            range,\n            widget,\n            textRange;\n\n        function getRange(allowFolded) {\n            var range = options.range || finder(cm, pos);\n            if (!range || range.to.line - range.from.line < prefs.getSetting(\"minFoldSize\")) {\n                return null;\n            }\n            var marks = cm.findMarksAt(range.from),\n                i,\n                lastMark,\n                foldMarks;\n            for (i = 0; i < marks.length; ++i) {\n                if (marks[i].__isFold && force !== \"fold\") {\n                    if (!allowFolded) {\n                        return null;\n                    }\n                    range.cleared = true;\n                    marks[i].clear();\n                }\n            }\n            //check for overlapping folds\n            if (marks && marks.length) {\n                foldMarks = marks.filter(function (d) {\n                    return d.__isFold;\n                });\n                if (foldMarks && foldMarks.length) {\n                    lastMark = foldMarks[foldMarks.length - 1].find();\n                    if (lastMark && range.from.line <= lastMark.to.line && lastMark.to.line < range.to.line) {\n                        return null;\n                    }\n                }\n            }\n            return range;\n        }\n\n        function makeWidget() {\n            var widget = window.document.createElement(\"span\");\n            widget.className = \"CodeMirror-foldmarker\";\n            return widget;\n        }\n\n        range = getRange(true);\n        if (options.scanUp) {\n            while (!range && pos.line > cm.firstLine()) {\n                pos = CodeMirror.Pos(pos.line - 1, 0);\n                range = getRange(false);\n            }\n        }\n        if (!range || range.cleared || force === \"unfold\" || range.to.line - range.from.line < prefs.getSetting(\"minFoldSize\")) {\n            if (range) { range.cleared = false; }\n            return;\n        }\n\n        widget = makeWidget();\n        textRange = cm.markText(range.from, range.to, {\n            replacedWith: widget,\n            clearOnEnter: true,\n            __isFold: true\n        });\n\n        CodeMirror.on(widget, \"mousedown\", function (e) {\n            textRange.clear();\n            e.preventDefault();\n        });\n\n        textRange.on(\"clear\", function (from, to) {\n            delete cm._lineFolds[from.line];\n            CodeMirror.signal(cm, \"unfold\", cm, from, to);\n        });\n\n        if (force === \"fold\") {\n            delete range.cleared;\n            // In some cases such as in xml style files, the start of  line folds can span multiple lines.\n            // For instance the attributes of an element can span multiple lines. In these cases when folding\n            // we want to render a gutter marker for both the beginning and end of the opening xml tag.\n            if (pos.line < range.from.line) {\n                cm._lineFolds[range.from.line] = range;\n            } else {\n                cm._lineFolds[pos.line] = range;\n            }\n        } else {\n            delete cm._lineFolds[pos.line];\n        }\n\n        CodeMirror.signal(cm, force, cm, range.from, range.to);\n        return range;\n    }\n\n    /**\n        Initialises extensions and helpers on the CodeMirror object\n    */\n    function init() {\n        CodeMirror.defineExtension(\"foldCode\", function (pos, options, force) {\n            return doFold(this, pos, options, force);\n        });\n\n        CodeMirror.defineExtension(\"unfoldCode\", function (pos, options) {\n            return doFold(this, pos, options, \"unfold\");\n        });\n\n        CodeMirror.defineExtension(\"isFolded\", function (line) {\n            return this._lineFolds && this._lineFolds[line];\n        });\n\n        /**\n          * Checks the validity of the ranges passed in the parameter and returns the foldranges\n          * that are still valid in the current document\n          * @param {object} folds the dictionary of lines in the current document that should be folded\n          * @returns {object} valid folds found in those passed in parameter\n          */\n        CodeMirror.defineExtension(\"getValidFolds\", function (folds) {\n            var keys, rf = CodeMirror.fold.auto, cm = this, result = {}, range, cachedRange;\n            if (folds && (keys = Object.keys(folds)).length) {\n                keys.forEach(function (lineNumber) {\n                    lineNumber = +lineNumber;\n                    if (lineNumber >= cm.firstLine() && lineNumber <= cm.lastLine()) {\n                        range = rf(cm, CodeMirror.Pos(lineNumber, 0));\n                        cachedRange = folds[lineNumber];\n                        if (range && cachedRange && range.from.line === cachedRange.from.line &&\n                                range.to.line === cachedRange.to.line) {\n                            result[lineNumber] = folds[lineNumber];\n                        }\n                    }\n                });\n            }\n            return result;\n        });\n\n        /**\n          * Utility function to fold the region at the current cursor position in  a document\n          * @param {CodeMirror} cm the CodeMirror instance\n          * @param {?options} options extra options to pass to the fold function\n          */\n        CodeMirror.commands.fold = function (cm, options) {\n            cm.foldCode(cm.getCursor(), options, \"fold\");\n        };\n\n        /**\n          * Utility function to unfold the region at the current cursor position in  a document\n          * @param {CodeMirror} cm the CodeMirror instance\n          * @param {?options} options extra options to pass to the fold function\n          */\n        CodeMirror.commands.unfold = function (cm, options) {\n            cm.foldCode(cm.getCursor(), options, \"unfold\");\n        };\n\n        /**\n          * Utility function to fold all foldable regions in a document\n          * @param {CodeMirror} cm the CodeMirror instance\n          */\n        CodeMirror.commands.foldAll = function (cm) {\n            cm.operation(function () {\n                var i, e;\n                for (i = cm.firstLine(), e = cm.lastLine(); i <= e; i++) {\n                    cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n                }\n            });\n        };\n\n        /**\n          * Utility function to unfold all folded regions in a document\n          * @param {CodeMirror} cm the CodeMirror instance\n          * @param {?number} from the line number for the beginning of the region to unfold\n          * @param {?number} to the line number for the end of the region to unfold\n          */\n        CodeMirror.commands.unfoldAll = function (cm, from, to) {\n            from = from || cm.firstLine();\n            to = to || cm.lastLine();\n            cm.operation(function () {\n                var i, e;\n                for (i = from, e = to; i <= e; i++) {\n                    if (cm.isFolded(i)) { cm.unfoldCode(i, {range: cm._lineFolds[i]}); }\n                }\n            });\n        };\n\n        /**\n          * Folds the specified range. The descendants of any fold regions within the range are also folded up to\n          * a level set globally in the `maxFoldLevel' preferences\n          * @param {CodeMirror} cm the CodeMirror instance\n          * @param {?number} start the line number for the beginning of the region to fold\n          * @param {?number} end the line number for the end of the region to fold\n          */\n        CodeMirror.commands.foldToLevel = function (cm, start, end) {\n            var rf = CodeMirror.fold.auto;\n            function foldLevel(n, from, to) {\n                if (n > 0) {\n                    var i = from, range;\n                    while (i < to) {\n                        range = rf(cm, CodeMirror.Pos(i, 0));\n                        if (range) {\n                            //call fold level for the range just folded\n                            foldLevel(n - 1, range.from.line + 1, range.to.line - 1);\n                            cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n                            i = range.to.line + 1;\n                        } else {\n                            i++;\n                        }\n                    }\n                }\n            }\n            cm.operation(function () {\n                start = start === undefined ? cm.firstLine() : start;\n                end = end || cm.lastLine();\n                foldLevel(prefs.getSetting(\"maxFoldLevel\"), start, end);\n            });\n        };\n\n        /**\n          * Helper to combine an array of fold range finders into one. This goes through the\n          * list of fold helpers in the parameter arguments and returns the first non-null\n          * range found from calling the fold helpers in order.\n          */\n        CodeMirror.registerHelper(\"fold\", \"combine\", function () {\n            var funcs = Array.prototype.slice.call(arguments, 0);\n            return function (cm, start) {\n                var i;\n                for (i = 0; i < funcs.length; ++i) {\n                    var found = funcs[i] && funcs[i](cm, start);\n                    if (found) {\n                        return found;\n                    }\n                }\n            };\n        });\n\n        /**\n          * Creates a helper which returns the appropriate fold function based on the mode of the current position in\n          * a document.\n          * @param {CodeMirror} cm the CodeMirror instance\n          * @param {number} start the current position in the document\n          */\n        CodeMirror.registerHelper(\"fold\", \"auto\", function (cm, start) {\n            var helpers = cm.getHelpers(start, \"fold\"), i, range;\n            //ensure mode helper is loaded if there is one\n            var mode = cm.getMode().name;\n            var modeHelper = CodeMirror.fold[mode];\n            if (modeHelper && helpers.indexOf(modeHelper) < 0) {\n                helpers.push(modeHelper);\n            }\n            for (i = 0; i < helpers.length; i++) {\n                range = helpers[i](cm, start);\n                if (range && range.to.line - range.from.line >= prefs.getSetting(\"minFoldSize\")) { return range; }\n            }\n        });\n    }\n\n    exports.init = init;\n});\n"],"file":"foldcode.js"}
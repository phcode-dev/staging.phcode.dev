{"version":3,"sources":["JSUtils/HintUtils.js"],"names":["define","require","exports","module","Acorn","LANGUAGE_ID","JSX_LANGUAGE_ID","HTML_LANGUAGE_ID","PHP_LANGUAGE_ID","SUPPORTED_LANGUAGES","SINGLE_QUOTE","DOUBLE_QUOTE","makeToken","value","positions","maybeIdentifier","key","result","i","length","isIdentifierChar","charCodeAt","hintable","token","_isInsideRegExp","state","lastType","localState","type","hintableKey","showOnDot","eventName","name","EVENT_TAG","annotateLiterals","literals","kind","map","t","literal","origin","test","delimiter","annotateKeywords","keywords","keyword","isSupportedLanguage","languageId","indexOf","KEYWORD_NAMES","KEYWORD_TOKENS","KEYWORDS","LITERAL_NAMES","LITERAL_TOKENS","LITERALS"],"mappings":"AAuBAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,MAA8BH,QAAQ,+BAEtCI,YAA8B,aAC9BC,gBAA8B,MAC9BC,iBAA8B,OAC9BC,gBAA8B,MAC9BC,oBAA8B,CAACJ,YAHD,MACA,OACA,OAE9BK,aAA8B,IAC9BC,aAA8B,IAWlC,SAASC,UAAUC,MAAOC,WAGtB,MAAO,CACHD,MAAOA,MACPC,UAJJA,UAAYA,WAAa,IAc7B,SAASC,gBAAgBC,KACrB,IAAIC,QAAS,EACTC,EAEJ,IAAKA,EAAI,EAAGA,EAAIF,IAAIG,SAChBF,OAASb,MAAMgB,iBAAiBJ,IAAIK,WAAWH,KADvBA,KAO5B,OAAOD,OASX,SAASK,SAASC,OAEd,SAASC,gBAAgBD,OACrB,OAAOA,MAAME,QAAmC,WAAzBF,MAAME,MAAMC,UAC3BH,MAAME,MAAME,YAAkD,WAApCJ,MAAME,MAAME,WAAWD,UAG7D,OAAQH,MAAMK,MACd,IAAK,UACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,MACD,OAAO,EACX,IAAK,WAED,OAAQJ,gBAAgBD,OAC5B,QACI,OAAO,GAYf,SAASM,YAAYb,IAAKc,WACtB,OAAgB,OAARd,KAAiBc,WAAqB,MAARd,KAAgBD,gBAAgBC,KAU1E,SAASe,UAAUC,MACf,IAAIC,UACJ,OAAOD,KAAO,IADE,oBAiBpB,SAASE,iBAAiBC,SAAUC,MAChC,OAAOD,SAASE,IAAI,SAAUC,GAW1B,OAVAA,EAAEC,SAAU,EACZD,EAAEF,KAAOA,KACTE,EAAEE,OAAS,aACE,WAATJ,OACI,SAASK,KAAKH,EAAEzB,OAChByB,EAAEI,UAAYhC,aAEd4B,EAAEI,UAAY/B,cAGf2B,IAYf,SAASK,iBAAiBC,UACtB,OAAOA,SAASP,IAAI,SAAUC,GAG1B,OAFAA,EAAEO,SAAU,EACZP,EAAEE,OAAS,aACJF,IAIf,SAASQ,oBAAoBC,YACzB,OAAoD,IAA7CtC,oBAAoBuC,QAAQD,YAGvC,IAAIE,cAOAC,eAGAC,SAAkBR,iBAVA,CACd,QAAS,OAAQ,QAAS,QAAS,QAAS,WAAY,WACxD,UAAW,SAAU,KAAM,OAAQ,SAAU,UAAW,UACxD,MAAO,WAAY,KAAM,SAAU,KAAM,aAAc,MAAO,MAC9D,SAAU,QAAS,SAAU,OAAQ,QAAS,MAAO,SAAU,MAC/D,OAAQ,QAAS,OAAQ,SAEGN,IAAI,SAAUC,GAC1C,OAAO1B,UAAU0B,EAAG,OAIxBc,cAGAC,eAGAC,SAAkBpB,iBANA,CACd,OAAQ,QAAS,QAEWG,IAAI,SAAUC,GAC1C,OAAO1B,UAAU0B,EAAG,OAI5BpC,QAAQU,UAA8BA,UACtCV,QAAQoB,SAA8BA,SACtCpB,QAAQ2B,YAA8BA,YACtC3B,QAAQa,gBAA8BA,gBACtCb,QAAQ6B,UAA8BA,UACtC7B,QAAQgC,iBAA8BA,iBACtChC,QAAQ4C,oBAA8BA,oBACtC5C,QAAQiD,SAA8BA,SACtCjD,QAAQoD,SAA8BA,SACtCpD,QAAQG,YAA8BA,YACtCH,QAAQQ,aAA8BA,aACtCR,QAAQS,aAA8BA,aACtCT,QAAQO,oBAA8BA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\ndefine(function (require, exports, module) {\n\n\n    var Acorn                       = require(\"thirdparty/acorn/dist/acorn\");\n\n    var LANGUAGE_ID                 = \"javascript\",\n        JSX_LANGUAGE_ID             = \"jsx\",\n        HTML_LANGUAGE_ID            = \"html\",\n        PHP_LANGUAGE_ID             = \"php\",\n        SUPPORTED_LANGUAGES         = [LANGUAGE_ID, JSX_LANGUAGE_ID, HTML_LANGUAGE_ID, PHP_LANGUAGE_ID],\n        SINGLE_QUOTE                = \"'\",\n        DOUBLE_QUOTE                = \"\\\"\";\n\n    /**\n     * Create a hint token with name value that occurs at the given list of\n     * positions.\n     *\n     * @param {string} value - name of the new hint token\n     * @param {?Array.<number>=} positions - optional list of positions at which\n     *      the token occurs\n     * @return {Object} - a new hint token\n     */\n    function makeToken(value, positions) {\n        positions = positions || [];\n\n        return {\n            value: value,\n            positions: positions\n        };\n    }\n\n    /**\n     * Is the string key perhaps a valid JavaScript identifier?\n     *\n     * @param {string} key - string to test.\n     * @return {boolean} - could key be a valid identifier?\n     */\n    function maybeIdentifier(key) {\n        var result = false,\n            i;\n\n        for (i = 0; i < key.length; i++) {\n            result = Acorn.isIdentifierChar(key.charCodeAt(i));\n            if (!result) {\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Is the token's class hintable? (A very conservative test.)\n     *\n     * @param {Object} token - the token to test for hintability\n     * @return {boolean} - could the token be hintable?\n     */\n    function hintable(token) {\n\n        function _isInsideRegExp(token) {\n            return token.state && (token.state.lastType === \"regexp\" ||\n                   (token.state.localState && token.state.localState.lastType === \"regexp\"));\n        }\n\n        switch (token.type) {\n        case \"comment\":\n        case \"number\":\n        case \"regexp\":\n        case \"string\":\n        case \"def\":     // exclude variable & param decls\n            return false;\n        case \"string-2\":\n            // exclude strings inside a regexp\n            return !_isInsideRegExp(token);\n        default:\n            return true;\n        }\n    }\n\n    /**\n     *  Determine if hints should be displayed for the given key.\n     *\n     * @param {string} key - key entered by the user\n     * @param {boolean} showOnDot - show hints on dot (\".\").\n     * @return {boolean} true if the hints should be shown for the key,\n     * false otherwise.\n     */\n    function hintableKey(key, showOnDot) {\n        return (key === null || (showOnDot && key === \".\") || maybeIdentifier(key));\n    }\n\n    /*\n     * Get a JS-hints-specific event name. Used to prevent event namespace\n     * pollution.\n     *\n     * @param {string} name - the unqualified event name\n     * @return {string} - the qualified event name\n     */\n    function eventName(name) {\n        var EVENT_TAG = \"brackets-js-hints\";\n        return name + \".\" + EVENT_TAG;\n    }\n\n    /*\n     * Annotate a list of tokens as literals of a particular kind;\n     * if string literals, annotate with an appropriate delimiter.\n     *\n     * @param {Array.<Object>} literals - list of hint tokens\n     * @param {string} kind - the kind of literals in the list (e.g., \"string\")\n     * @return {Array.<Object>} - the input array; to each object in the array a\n     *      new literal {boolean} property has been added to indicate that it\n     *      is a literal hint, and also a new kind {string} property to indicate\n     *      the literal kind. For string literals, a delimiter property is also\n     *      added to indicate what the default delimiter should be (viz. a\n     *      single or double quotation mark).\n     */\n    function annotateLiterals(literals, kind) {\n        return literals.map(function (t) {\n            t.literal = true;\n            t.kind = kind;\n            t.origin = \"ecmascript\";\n            if (kind === \"string\") {\n                if (/[^\\\\]\"/.test(t.value)) {\n                    t.delimiter = SINGLE_QUOTE;\n                } else {\n                    t.delimiter = DOUBLE_QUOTE;\n                }\n            }\n            return t;\n        });\n    }\n\n    /*\n     * Annotate a list of tokens as keywords\n     *\n     * @param {Array.<Object>} keyword - list of keyword tokens\n     * @return {Array.<Object>} - the input array; to each object in the array a\n     *      new keyword {boolean} property has been added to indicate that the\n     *      hint is a keyword.\n     */\n    function annotateKeywords(keywords) {\n        return keywords.map(function (t) {\n            t.keyword = true;\n            t.origin = \"ecmascript\";\n            return t;\n        });\n    }\n\n    function isSupportedLanguage(languageId) {\n        return SUPPORTED_LANGUAGES.indexOf(languageId) !== -1;\n    }\n\n    var KEYWORD_NAMES   = [\n            \"break\", \"case\", \"catch\", \"class\", \"const\", \"continue\", \"debugger\",\n            \"default\", \"delete\", \"do\", \"else\", \"export\", \"extends\", \"finally\",\n            \"for\", \"function\", \"if\", \"import\", \"in\", \"instanceof\", \"let\", \"new\",\n            \"return\", \"super\", \"switch\", \"this\", \"throw\", \"try\", \"typeof\", \"var\",\n            \"void\", \"while\", \"with\", \"yield\"\n        ],\n        KEYWORD_TOKENS  = KEYWORD_NAMES.map(function (t) {\n            return makeToken(t, []);\n        }),\n        KEYWORDS        = annotateKeywords(KEYWORD_TOKENS);\n\n    var LITERAL_NAMES   = [\n            \"true\", \"false\", \"null\"\n        ],\n        LITERAL_TOKENS  = LITERAL_NAMES.map(function (t) {\n            return makeToken(t, []);\n        }),\n        LITERALS        = annotateLiterals(LITERAL_TOKENS);\n\n    exports.makeToken                   = makeToken;\n    exports.hintable                    = hintable;\n    exports.hintableKey                 = hintableKey;\n    exports.maybeIdentifier             = maybeIdentifier;\n    exports.eventName                   = eventName;\n    exports.annotateLiterals            = annotateLiterals;\n    exports.isSupportedLanguage         = isSupportedLanguage;\n    exports.KEYWORDS                    = KEYWORDS;\n    exports.LITERALS                    = LITERALS;\n    exports.LANGUAGE_ID                 = LANGUAGE_ID;\n    exports.SINGLE_QUOTE                = SINGLE_QUOTE;\n    exports.DOUBLE_QUOTE                = DOUBLE_QUOTE;\n    exports.SUPPORTED_LANGUAGES         = SUPPORTED_LANGUAGES;\n});\n"],"file":"HintUtils.js"}
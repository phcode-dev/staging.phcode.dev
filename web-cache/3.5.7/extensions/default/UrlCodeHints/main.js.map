{"version":3,"sources":["extensions/default/UrlCodeHints/main.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","CodeHintManager","CSSUtils","FileSystem","FileUtils","HTMLUtils","PreferencesManager","ProjectManager","StringUtils","PathUtils","Strings","Data","urlHints","data","htmlAttrs","styleModes","UrlCodeHints","_clearCachedHints","cachedHints","deferred","state","definePreference","description","DESCRIPTION_URL_CODE_HINTS","prototype","_getUrlList","query","directory","doc","docDir","queryDir","queryUrl","result","self","targetDir","unfiltered","this","editor","document","file","getDirectoryPath","fullPath","parseUrl","queryStr","length","getProjectRoot","decodeURI","substring","tag","attrName","filename","push","forEach","item","getDirectoryForPath","reject","$","Deferred","getContents","err","contents","currentDeferred","entryStr","syncResults","entry","shouldIndex","_name","_isDirectory","Array","resolveWith","_getUrlHints","hints","sortFunc","indexOf","closeOnSelect","urlSort","hasHints","implicitChar","mode","getModeForSelection","hasHtmlHints","hasCssHints","cursor","getCursorPos","info","getInfoAtPos","context","PROP_VALUE","IMPORT_URL","i","val","index","values","offset","match","tagInfo","tokenType","getTagInfo","position","ATTR_VALUE","attr","name","value","slice","hintsAndSortFunc","foundPrefix","toLowerCase","getHints","key","filter","substr","matchWhitespace","replace","leadingWhitespace","openingQuote","lowerCaseFilter","console","assert","map","sort","selectInitial","handleWideResults","Object","hasOwnProperty","done","asyncHints","insertHint","completion","encodeURI","insertHtmlHint","insertCssHint","getCharOffset","array","pos1","pos2","count","findNextPosInArray","ch","pos","o","searchOffset","start","line","end","hasClosingQuote","hasClosingParen","insertText","moveLen","closingPos","searchResult","nextSlash","_codeMirror","replaceRange","setCursorPos","charCount","endQuote","shouldReplace","hasEndQuote","quoteChar","appReady","JSON","parse","registerHintProvider","on","hintProvider"],"mappings":"AAuBAA,OAAO,SAAUC,QAASC,QAASC,QAI/B,IAAIC,QAAsBC,SAASC,UAAU,iBACzCC,gBAAsBF,SAASC,UAAU,0BACzCE,SAAsBH,SAASC,UAAU,qBACzCG,WAAsBJ,SAASC,UAAU,yBACzCI,UAAsBL,SAASC,UAAU,kBACzCK,UAAsBN,SAASC,UAAU,sBACzCM,mBAAsBP,SAASC,UAAU,kCACzCO,eAAsBR,SAASC,UAAU,0BACzCQ,YAAsBT,SAASC,UAAU,qBACzCS,UAAsBV,SAASC,UAAU,oCACzCU,QAAsBX,SAASC,UAAU,WACzCW,KAAsBhB,QAAQ,kBAE9BiB,SACAC,KACAC,UACAC,WAAkB,CAAC,MAAO,cAAe,eAU7C,SAASC,gBAiuBT,SAASC,oBAEDL,UAAYA,SAASM,aAAeN,SAASM,YAAYC,UACX,YAA1CP,SAASM,YAAYC,SAASC,UAKlCR,SAASM,YAAc,MAhvB/BZ,mBAAmBe,iBAAiB,wBAAyB,WAAW,EAAM,CAC1EC,YAAaZ,QAAQa,6BAczBP,aAAaQ,UAAUC,YAAc,SAAUC,OAC3C,IAAIC,UACAC,IACAC,OACAC,SAAW,GACXC,SACAC,OAAS,GACTC,KACAC,UACAC,WAAa,GAGjB,OADAP,IAAMQ,KAAKC,QAAUD,KAAKC,OAAOC,WACpBV,IAAIW,MAIjBV,OAASzB,UAAUoC,iBAAiBZ,IAAIW,KAAKE,WAG7CV,SAAWtB,UAAUiC,SAAShB,MAAMiB,aAEhCb,SAAWC,SAASJ,WAMpBO,UAFAJ,SAASc,OAAS,GAAqB,MAAhBd,SAAS,GAEpBvB,eAAesC,iBAAiBJ,SAChCK,UAAUhB,UAAUiB,UAAU,GAG9BlB,OAASiB,UAAUhB,UAqB/BM,KAAKlB,cAEAkB,KAAKlB,YAAYQ,OACdU,KAAKlB,YAAYQ,MAAMsB,MAAQtB,MAAMsB,KACrCZ,KAAKlB,YAAYQ,MAAMuB,WAAavB,MAAMuB,UAC1Cb,KAAKlB,YAAYY,WAAaA,UAC9BM,KAAKlB,YAAYW,SAAWA,SAGhCO,KAAKlB,YAAc,OAIvBkB,KAAKlB,aAELiB,WAAaC,KAAKlB,YAAYiB,WAoER,MAAtBJ,SAASmB,SACTlB,OAAOmB,KAAKrB,SAAW,KACM,OAAtBC,SAASmB,UAChBlB,OAAOmB,KAAKrB,SAAW,MAI3BK,WAAWiB,QAAQ,SAAUC,MACzBrB,OAAOmB,KAAKE,QASTrB,SAlFHL,UAAYxB,WAAWmD,oBAAoBpB,YAC3CD,KAAOG,MAEElB,aAAee,KAAKf,YAAYC,UACrCc,KAAKf,YAAYC,SAASoC,SAG9BtB,KAAKf,YAAc,GACnBe,KAAKf,YAAYC,SAAWqC,EAAEC,WAC9BxB,KAAKf,YAAYiB,WAAa,GAE9BR,UAAU+B,YAAY,SAAUC,IAAKC,UACjC,IAAIC,gBAAiBC,SAAUC,YAE1BJ,MACDC,SAASR,QAAQ,SAAUY,OACnBzD,eAAe0D,YAAYD,SAE3BF,SAAWhC,SAAWkC,MAAME,MACxBF,MAAMG,eACNL,UAAY,KAMhB3B,WAAWgB,KAAKW,aAIxB7B,KAAKf,YAAYiB,WAAaA,WAC9BF,KAAKf,YAAYQ,MAAaA,MAC9BO,KAAKf,YAAYY,SAAaA,SAC9BG,KAAKf,YAAYW,OAAaA,OAEY,aAAtCI,KAAKf,YAAYC,SAASC,UAC1ByC,gBAAkB5B,KAAKf,YAAYC,UAKnC4C,YAAc9B,KAAKR,YAAYC,kBACJ0C,MACvBP,gBAAgBQ,YAAYpC,KAAM,CAAC8B,eAE/BF,iBAA+C,YAA5BA,gBAAgBzC,SACnCyC,gBAAgBN,SAGhBtB,KAAKf,YAAYC,UACyB,YAAtCc,KAAKf,YAAYC,SAASC,UAC9Ba,KAAKf,YAAYC,SAASoC,SAC1BtB,KAAKf,YAAYC,SAAW,WAOzCc,KAAKf,YAAYC,WApHjBa,QAuJfhB,aAAaQ,UAAU8C,aAAe,SAAU5C,OAC5C,IAAI6C,MAAQ,GACRC,SAWJ,OARqC,IAAjC9C,MAAMiB,SAAS8B,QAAQ,OAGvBrC,KAAKsC,eAAgB,EACrBH,MAAQnC,KAAKX,YAAYC,OACzB8C,SAAWhE,YAAYmE,SAGpB,CAAEJ,MAAOA,MAAOC,SAAUA,WAoBrCxD,aAAaQ,UAAUoD,SAAW,SAAUvC,OAAQwC,cAChD,IAAIC,KAAOzC,OAAO0C,sBAClB,MAAa,SAATD,KACO1C,KAAK4C,aAAa3C,OAAQwC,cAC1B9D,WAAW0D,QAAQK,OAAS,GAC5B1C,KAAK6C,YAAY5C,OAAQwC,eAsBxC7D,aAAaQ,UAAUyD,YAAc,SAAU5C,OAAQwC,cACnDzC,KAAKC,OAASA,OACd,IAAI6C,OAAS9C,KAAKC,OAAO8C,eAIzB,GAFA/C,KAAKgD,KAAOlF,SAASmF,aAAahD,OAAQ6C,QAEtC9C,KAAKgD,KAAKE,UAAYpF,SAASqF,YAAcnD,KAAKgD,KAAKE,UAAYpF,SAASsF,WAC5E,OAAO,EAIX,IAAIC,EACAC,IAAM,GAEV,IAAKD,EAAI,EAAGA,GAAKrD,KAAKgD,KAAKO,OAASF,EAAIrD,KAAKgD,KAAKQ,OAAOhD,OAAQ6C,IACzDA,EAAIrD,KAAKgD,KAAKO,MACdD,KAAOtD,KAAKgD,KAAKQ,OAAOH,GAExBC,KAAOtD,KAAKgD,KAAKQ,OAAOH,GAAG1C,UAAU,EAAGX,KAAKgD,KAAKS,QAK1D,QAAIH,IAAII,MAAM,eAuBlB9E,aAAaQ,UAAUwD,aAAe,SAAU3C,OAAQwC,cACpD,IAAIkB,QACArE,MACAsE,UAQJ,GANA5D,KAAKC,OAASA,OAGdX,MAAQ,MACRsE,WAFAD,QAAU1F,UAAU4F,WAAW5D,OAAQA,OAAO8C,iBAE1Be,SAASF,aAEX3F,UAAU8F,YAGpBrF,UAAUiF,QAAQK,KAAKC,MAAO,CAG1B3E,MADAqE,QAAQG,SAASL,QAAU,EACnBE,QAAQK,KAAKE,MAAMC,MAAM,EAAGR,QAAQG,SAASL,QAK7C,GAGZ,IAAIW,iBACAjC,MADmBnC,KAAKkC,aAAa,CAAC3B,SAAUjB,QACvB6C,MAE7B,GAAIA,iBAAiBH,MAAO,CAExB,IAAIqB,EAAGgB,aAAc,EAErB,IADA/E,MAAQA,MAAMgF,cACTjB,EAAI,EAAGA,EAAIlB,MAAM3B,OAAQ6C,IAC1B,GAA8C,IAA1ClB,MAAMkB,GAAGiB,cAAcjC,QAAQ/C,OAAc,CAC7C+E,aAAc,EACd,MAIHA,cACD/E,MAAQ,OAMxB,OAAkB,OAAVA,OAsBZV,aAAaQ,UAAUmF,SAAW,SAAUC,KACxC,IAAI9B,KAAO1C,KAAKC,OAAO0C,sBACnBG,OAAS9C,KAAKC,OAAO8C,eACrB0B,OAAS,GACTtC,MAAQ,GACRC,SACA9C,MAAQ,CAAEiB,SAAU,IACpBX,OAAS,GAEb,GAAa,SAAT8C,KAAiB,CACjB,IAAIiB,QAAU1F,UAAU4F,WAAW7D,KAAKC,OAAQ6C,QAC5Cc,UAEJ,GAFgBD,QAAQG,SAASF,YAEf3F,UAAU8F,aAAerF,UAAUiF,QAAQK,KAAKC,MAC9D,OAAO,KAGPN,QAAQG,SAASL,QAAU,IAC3BnE,MAAMiB,SAAWoD,QAAQK,KAAKE,MAAMC,MAAM,EAAGR,QAAQG,SAASL,SAElEzD,KAAKgD,KAAOW,YAET,CAAA,KAAIhF,WAAW0D,QAAQK,OAAS,GA6CnC,OAAO,KA5CP1C,KAAKgD,KAAOlF,SAASmF,aAAajD,KAAKC,OAAQ6C,QAE/C,IAAII,QAAUlD,KAAKgD,KAAKE,QACxB,GAAIA,UAAYpF,SAASqF,YAAcD,UAAYpF,SAASsF,WACxD,OAAO,KAIX,IAAyB,IAArBpD,KAAKgD,KAAKO,MAAc,CAGxB,IAAIF,EAAGC,IAAM,GACb,IAAKD,EAAI,EAAGA,EAAIrD,KAAKgD,KAAKO,MAAOF,IAC7BC,KAAOtD,KAAKgD,KAAKQ,OAAOH,GAGxBrD,KAAKgD,KAAKO,MAAQvD,KAAKgD,KAAKQ,OAAOhD,SACnC8C,KAAOtD,KAAKgD,KAAKQ,OAAOxD,KAAKgD,KAAKO,OAAOmB,OAAO,EAAG1E,KAAKgD,KAAKS,SAOjE,IAAIkB,iBAHJrB,IAAMA,IAAIsB,QAAQ,aAAc,KAGNlB,MAAM,QAC5BiB,iBACA3E,KAAKgD,KAAK6B,kBAAoBF,gBAAgB,GAC9CrB,IAAMA,IAAI3C,UAAUgE,gBAAgB,GAAGnE,SAEvCR,KAAKgD,KAAK6B,kBAAoB,KAI9BvB,IAAII,MAAM,UACV1D,KAAKgD,KAAK8B,aAAexB,IAAI,GAC7BA,IAAMA,IAAI3C,UAAU,IAEpBX,KAAKgD,KAAK8B,aAAe,KAG7BxF,MAAMiB,SAAW+C,KAOzB,GAAuB,OAAnBhE,MAAMiB,SAAmB,CACzBkE,OAASnF,MAAMiB,SACf,IAAI6D,iBAAmBpE,KAAKkC,aAAa5C,OACzC6C,MAAQiC,iBAAiBjC,MACzBC,SAAWgC,iBAAiBhC,SAIhC,GAFApC,KAAKgD,KAAKyB,OAASA,OAEftC,iBAAiBH,OAASG,MAAM3B,OAAQ,CAExC,IAAIuE,gBAAkBN,OAAOH,cAQ7B,OAPAU,QAAQC,QAAQrF,OAAOY,QAOhB,CACH2B,MAPJvC,OAASwB,EAAE8D,IAAI/C,MAAO,SAAUlB,MAC5B,GAAoD,IAAhDA,KAAKqD,cAAcjC,QAAQ0C,iBAC3B,OAAO9D,OAEZkE,KAAK/C,UAIJsB,MAAOpE,MAAMiB,SACb6E,eAAe,EACfC,mBAAmB,GAGpB,GAAIlD,iBAAiBmD,QAAUnD,MAAMoD,eAAe,QAAS,CAEhE,IAAIxG,SAAWqC,EAAEC,WAiBjB,OAhBAc,MAAMqD,KAAK,SAAUC,YACjB,IAAIV,gBAAkBN,OAAOH,cAC7B1E,OAASwB,EAAE8D,IAAIO,WAAY,SAAUxE,MACjC,GAAoD,IAAhDA,KAAKqD,cAAcjC,QAAQ0C,iBAC3B,OAAO9D,OAEZkE,KAAK/C,UAERrD,SAASkD,YAAYjC,KAAM,CAAC,CACxBmC,MAAOvC,OACP8D,MAAOpE,MAAMiB,SACb6E,eAAe,EACfC,mBAAmB,OAIpBtG,SAGX,OAAO,MAaXH,aAAaQ,UAAUsG,WAAa,SAAUC,YAC1C,IAAIjD,KAAO1C,KAAKC,OAAO0C,sBAKvB,OAFAgD,WAAaC,UAAUD,YAEV,SAATjD,KACO1C,KAAK6F,eAAeF,YACpBhH,WAAW0D,QAAQK,OAAS,GAC5B1C,KAAK8F,cAAcH,aAqBlC/G,aAAaQ,UAAU2G,cAAgB,SAAUC,MAAOC,KAAMC,MAC1D,IAAI7C,EAAG8C,MAAQ,EAEf,GAAIF,KAAK1C,QAAU2C,KAAK3C,MACpB,OAAQ2C,KAAKzC,QAAUwC,KAAKxC,OAAWyC,KAAKzC,OAASwC,KAAKxC,OAAU,EACjE,GAAIwC,KAAK1C,MAAQ2C,KAAK3C,MAAO,CAChC,GAAI0C,KAAK1C,MAAQ,GAAK0C,KAAK1C,OAASyC,MAAMxF,QAAU0F,KAAK3C,MAAQ,GAAK2C,KAAK3C,OAASyC,MAAMxF,OACtF,OAAO,EAGX,IAAK6C,EAAI4C,KAAK1C,MAAOF,GAAK6C,KAAK3C,MAAOF,IAC9BA,IAAM4C,KAAK1C,MACX4C,OAAUH,MAAM3C,GAAG7C,OAASyF,KAAKxC,OAC1BJ,IAAM6C,KAAK3C,MAClB4C,OAASD,KAAKzC,OAEd0C,OAASH,MAAM3C,GAAG7C,OAK9B,OAAO2F,OAgBXvH,aAAaQ,UAAUgH,mBAAqB,SAAUJ,MAAOK,GAAIC,KAC7D,IAAIjD,EAAGkD,EAAGC,aACV,IAAKnD,EAAIiD,IAAI/C,MAAOF,EAAI2C,MAAMxF,OAAQ6C,IAKlC,GAHAmD,aAAgBnD,IAAMiD,IAAI/C,MAAS+C,IAAI7C,OAAS,GAGrC,KAFX8C,EAAIP,MAAM3C,GAAGhB,QAAQgE,GAAIG,eAGrB,MAAO,CAAEjD,MAAOF,EAAGI,OAAQ8C,GAGnC,MAAO,CAAEhD,OAAQ,EAAGE,QAAS,IAajC7E,aAAaQ,UAAU0G,cAAgB,SAAUH,YAC7C,IAAI7C,OAAS9C,KAAKC,OAAO8C,eACrB0D,MAAS,CAAEC,KAAM5D,OAAO4D,KAAML,GAAIvD,OAAOuD,IACzCM,IAAS,CAAED,KAAM5D,OAAO4D,KAAML,GAAIvD,OAAOuD,IAEzCO,iBAAkB,EAClBC,iBAAkB,EAClBC,WAAkBnB,WAClBoB,QAAkB,EAClBC,WAAkB,CAAEzD,OAAQ,EAAGE,QAAS,GACxCwD,aAAkB,CAAE1D,OAAQ,EAAGE,QAAS,GAE5C,GAAIzD,KAAKgD,KAAKE,UAAYpF,SAASqF,YAAcnD,KAAKgD,KAAKE,UAAYpF,SAASsF,WAC5E,OAAO,EA4BX,GAvBKpD,KAAKsC,eAA6C,OAA5BqD,WAAWjC,MAAM,SACxC1D,KAAKsC,eAAgB,GAIrBtC,KAAKgD,KAAK8B,eAEV8B,iBAAyC,KADzCI,WAAahH,KAAKoG,mBAAmBpG,KAAKgD,KAAKQ,OAAQxD,KAAKgD,KAAK8B,aAAc9E,KAAKgD,OACtDO,OAM9BsD,gBAFAD,iBAE2C,KAD3CK,aAAejH,KAAKoG,mBAAmBpG,KAAKgD,KAAKQ,OAAQ,IAAKwD,aAC9BzD,OAIS,KADzCyD,WAAahH,KAAKoG,mBAAmBpG,KAAKgD,KAAKQ,OAAQ,IAAKxD,KAAKgD,OACnCO,MAM9BvD,KAAKsC,eACqB,IAAtB0E,WAAWzD,QACXoD,IAAIN,IAAMrG,KAAK+F,cAAc/F,KAAKgD,KAAKQ,OAAQxD,KAAKgD,KAAMgE,iBAE3D,CAEH,IAAIE,UAAYlH,KAAKoG,mBAAmBpG,KAAKgD,KAAKQ,OAAQ,IAAKxD,KAAKgD,MAChEkE,UAAU3D,QAAUvD,KAAKgD,KAAKO,OAAS2D,UAAUzD,SAAWzD,KAAKgD,KAAKS,SACtEkD,IAAIN,IAAM,GA0BlB,OAvBIrG,KAAKgD,KAAKyB,OAAOjE,OAAS,IAC1BiG,MAAMJ,IAAMrG,KAAKgD,KAAKyB,OAAOjE,QAI7BR,KAAKgD,KAAK8B,eAAiB8B,kBAC3BE,YAAc9G,KAAKgD,KAAK8B,cAEvB+B,kBAEG7G,KAAKgD,KAAK6B,oBACViC,YAAc9G,KAAKgD,KAAK6B,mBAE5BiC,YAAc,KAOlB9G,KAAKC,OAAOkH,YAAYC,aAAaN,WAAYL,MAAOE,KAGpD3G,KAAKsC,gBAELyE,SAAWH,gBAAkB,EAAI,IAAMC,gBAAkB,EAAI,IAC/C,GACV7G,KAAKC,OAAOoH,aAAaZ,MAAMC,KAAMD,MAAMJ,GAAKV,WAAWnF,OAASuG,UAEjE,KAIXA,SAAY/G,KAAKgD,KAAK8B,eAAiB8B,gBAAmB,EAAI,IAAOC,gBAAsB,EAAJ,IACzE,GACV7G,KAAKC,OAAOoH,aAAaZ,MAAMC,KAAMD,MAAMJ,GAAKV,WAAWnF,SAIxD,IAaX5B,aAAaQ,UAAUyG,eAAiB,SAAUF,YAC9C,IAAI7C,OAAS9C,KAAKC,OAAO8C,eACrB0D,MAAQ,CAACC,MAAO,EAAGL,IAAK,GACxBM,IAAM,CAACD,MAAO,EAAGL,IAAK,GACtB1C,QAAU1F,UAAU4F,WAAW7D,KAAKC,OAAQ6C,QAC5Cc,UAAYD,QAAQG,SAASF,UAC7B0D,UAAY,EACZC,SAAW,GACXC,eAAgB,EAyCpB,OAvCI5D,YAAc3F,UAAU8F,aAGnB/D,KAAKsC,eAA6C,OAA5BqD,WAAWjC,MAAM,SACxC1D,KAAKsC,eAAgB,EAGrBkF,eAAgB,GAGf7D,QAAQK,KAAKyD,eACdF,SAAW5D,QAAQK,KAAK0D,WAEpB/B,YAAc4B,SACqB,IAA5B5D,QAAQG,SAASL,SACxBkC,WAAa,IAAOA,WAAa,MAIrC6B,cAEAF,UAAY3D,QAAQK,KAAKE,MAAM1D,QAG/B8G,UAAYtH,KAAKgD,KAAKyB,OAAOjE,OAGzBR,KAAKgD,KAAKgB,KAAKE,MAAM1D,OAAS8G,WAAiD,MAApCtH,KAAKgD,KAAKgB,KAAKE,MAAMoD,aAChEA,WAAa,KAKzBX,IAAID,KAAOD,MAAMC,KAAO5D,OAAO4D,KAC/BD,MAAMJ,GAAKvD,OAAOuD,GAAK1C,QAAQG,SAASL,OACxCkD,IAAIN,GAAKI,MAAMJ,GAAKiB,UAEpBtH,KAAKC,OAAOC,SAASkH,aAAazB,WAAYc,MAAOE,KAEhD3G,KAAKsC,eASNsB,YAAc3F,UAAU8F,YAAcJ,QAAQK,KAAKyD,aAEnDzH,KAAKC,OAAOoH,aAAaZ,MAAMC,KAAMD,MAAMJ,GAAKV,WAAWnF,OAAS,IAGjE,IAXCoD,YAAc3F,UAAU8F,YAAeJ,QAAQK,KAAKyD,aACpDzH,KAAKC,OAAOoH,aAAaZ,MAAMC,KAAMD,MAAMJ,GAAKV,WAAWnF,OAAS,IAEjE,IAuBf9C,QAAQiK,SAAS,WACblJ,KAAkBmJ,KAAKC,MAAMtJ,MAC7BG,UAAkBD,KAAKC,UAEvBF,SAAkB,IAAII,aACtBf,gBAAgBiK,qBAAqBtJ,SAAU,CAAC,MAAO,OAAQ,OAAQ,QAAS,GAEhFT,WAAWgK,GAAG,SAAUlJ,mBACxBd,WAAWgK,GAAG,SAAUlJ,mBAGxBrB,QAAQwK,aAAexJ","sourcesContent":["/*\n *  Copyright (c) 2021 - present core.ai . All rights reserved.\n *  Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Brackets modules\n    var AppInit             = brackets.getModule(\"utils/AppInit\"),\n        CodeHintManager     = brackets.getModule(\"editor/CodeHintManager\"),\n        CSSUtils            = brackets.getModule(\"language/CSSUtils\"),\n        FileSystem          = brackets.getModule(\"filesystem/FileSystem\"),\n        FileUtils           = brackets.getModule(\"file/FileUtils\"),\n        HTMLUtils           = brackets.getModule(\"language/HTMLUtils\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        ProjectManager      = brackets.getModule(\"project/ProjectManager\"),\n        StringUtils         = brackets.getModule(\"utils/StringUtils\"),\n        PathUtils           = brackets.getModule(\"thirdparty/path-utils/path-utils\"),\n        Strings             = brackets.getModule(\"strings\"),\n        Data                = require(\"text!data.json\"),\n\n        urlHints,\n        data,\n        htmlAttrs,\n        styleModes      = [\"css\", \"text/x-less\", \"text/x-scss\"];\n\n\n    PreferencesManager.definePreference(\"codehint.UrlCodeHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_URL_CODE_HINTS\n    });\n\n    /**\n     * @constructor\n     */\n    function UrlCodeHints() {}\n\n    /**\n     * Helper function to create a list of urls to existing files based on the query.\n     * @param {{queryStr: string}} query -- a query object, used to filter the code hints\n     *\n     * @return {Array.<string>|$.Deferred} The (possibly deferred) hints.\n     */\n    UrlCodeHints.prototype._getUrlList = function (query) {\n        var directory,\n            doc,\n            docDir,\n            queryDir = \"\",\n            queryUrl,\n            result = [],\n            self,\n            targetDir,\n            unfiltered = [];\n\n        doc = this.editor && this.editor.document;\n        if (!doc || !doc.file) {\n            return result;\n        }\n\n        docDir = FileUtils.getDirectoryPath(doc.file.fullPath);\n\n        // get relative path from query string\n        queryUrl = PathUtils.parseUrl(query.queryStr);\n        if (queryUrl) {\n            queryDir = queryUrl.directory;\n        }\n\n        // build target folder path\n        if (queryDir.length > 0 && queryDir[0] === \"/\") {\n            // site-root relative path\n            targetDir = ProjectManager.getProjectRoot().fullPath +\n                        decodeURI(queryDir).substring(1);\n        } else {\n            // page relative path\n            targetDir = docDir + decodeURI(queryDir);\n        }\n\n        // Get list of files from target folder. Getting the file/folder info is an\n        // asynch operation, so it works like this:\n        //\n        // The initial pass initiates the asynchronous retrieval of data and returns an\n        // empty list, so no code hints are displayed. In the async callback, the code\n        // hints and the original query are stored in a cache, and then the process to\n        // show code hints is re-initiated.\n        //\n        // During the next pass, there should now be code hints cached from the initial\n        // pass, but user may have typed while file/folder info was being retrieved from\n        // disk, so we need to make sure code hints still apply to current query. If so,\n        // display them, otherwise, clear cache and start over.\n        //\n        // As user types within a folder, the same unfiltered file/folder list is still\n        // valid and re-used from cache. Filtering based on user input is done outside\n        // of this method. When user moves to a new folder, then the cache is deleted,\n        // and file/folder info for new folder is then retrieved.\n\n        if (this.cachedHints) {\n            // url hints have been cached, so determine if they're stale\n            if (!this.cachedHints.query ||\n                    this.cachedHints.query.tag !== query.tag ||\n                    this.cachedHints.query.attrName !== query.attrName ||\n                    this.cachedHints.queryDir !== queryDir ||\n                    this.cachedHints.docDir !== docDir) {\n\n                // delete stale cache\n                this.cachedHints = null;\n            }\n        }\n\n        if (this.cachedHints) {\n            // use cached hints\n            unfiltered = this.cachedHints.unfiltered;\n\n        } else {\n            directory = FileSystem.getDirectoryForPath(targetDir);\n            self = this;\n\n            if (self.cachedHints && self.cachedHints.deferred) {\n                self.cachedHints.deferred.reject();\n            }\n            // create empty object so we can detect \"waiting\" state\n            self.cachedHints = {};\n            self.cachedHints.deferred = $.Deferred();\n            self.cachedHints.unfiltered = [];\n\n            directory.getContents(function (err, contents) {\n                var currentDeferred, entryStr, syncResults;\n\n                if (!err) {\n                    contents.forEach(function (entry) {\n                        if (ProjectManager.shouldIndex(entry)) {\n                            // convert to doc relative path\n                            entryStr = queryDir + entry._name;\n                            if (entry._isDirectory) {\n                                entryStr += \"/\";\n                            }\n\n                            // code hints show the unencoded string so the\n                            // choices are easier to read.  The encoded string\n                            // will still be inserted into the editor.\n                            unfiltered.push(entryStr);\n                        }\n                    });\n\n                    self.cachedHints.unfiltered = unfiltered;\n                    self.cachedHints.query      = query;\n                    self.cachedHints.queryDir   = queryDir;\n                    self.cachedHints.docDir     = docDir;\n\n                    if (self.cachedHints.deferred.state() !== \"rejected\") {\n                        currentDeferred = self.cachedHints.deferred;\n\n                        // Since we've cached the results, the next call to _getUrlList should be synchronous.\n                        // If it isn't, we've got a problem and should reject both the current deferred\n                        // and any new deferred that got created on the call.\n                        syncResults = self._getUrlList(query);\n                        if (syncResults instanceof Array) {\n                            currentDeferred.resolveWith(self, [syncResults]);\n                        } else {\n                            if (currentDeferred && currentDeferred.state() === \"pending\") {\n                                currentDeferred.reject();\n                            }\n\n                            if (self.cachedHints.deferred &&\n                                    self.cachedHints.deferred.state() === \"pending\") {\n                                self.cachedHints.deferred.reject();\n                                self.cachedHints.deferred = null;\n                            }\n                        }\n                    }\n                }\n            });\n\n            return self.cachedHints.deferred;\n        }\n\n        // build list\n\n        // without these entries, typing \"../\" will not display entries for containing folder\n        if (queryUrl.filename === \".\") {\n            result.push(queryDir + \".\");\n        } else if (queryUrl.filename === \"..\") {\n            result.push(queryDir + \"..\");\n        }\n\n        // add file/folder entries\n        unfiltered.forEach(function (item) {\n            result.push(item);\n        });\n\n        // TODO: filter by desired file type based on tag, type attr, etc.\n\n        // TODO: add list item to top of list to popup modal File Finder dialog\n        // New string: \"Browse...\" or \"Choose a File...\"\n        // Command: Commands.FILE_OPEN\n\n        return result;\n    };\n\n    /**\n     * Helper function that determines the possible value hints for a given html tag/attribute name pair\n     *\n     * @param {{queryStr: string}} query\n     * The current query\n     *\n     * @return {{hints: (Array.<string>|$.Deferred), sortFunc: ?function(string, string): number}}\n     * The (possibly deferred) hints and the sort function to use on thise hints.\n     */\n    UrlCodeHints.prototype._getUrlHints = function (query) {\n        var hints = [],\n            sortFunc;\n\n        // Do not show hints after \"?\" in url\n        if (query.queryStr.indexOf(\"?\") === -1) {\n\n            // Default behavior for url hints is do not close on select.\n            this.closeOnSelect = false;\n            hints = this._getUrlList(query);\n            sortFunc = StringUtils.urlSort;\n        }\n\n        return { hints: hints, sortFunc: sortFunc };\n    };\n\n    /**\n     * Determines whether url hints are available in the current editor\n     * context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non-null,\n     * whether it is appropriate to do so.\n     */\n    UrlCodeHints.prototype.hasHints = function (editor, implicitChar) {\n        var mode = editor.getModeForSelection();\n        if (mode === \"html\") {\n            return this.hasHtmlHints(editor, implicitChar);\n        } else if (styleModes.indexOf(mode) > -1) {\n            return this.hasCssHints(editor, implicitChar);\n        }\n\n        return false;\n    };\n\n    /**\n     * Helper function for hasHints() for CSS.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non-null,\n     * whether it is appropriate to do so.\n     */\n    UrlCodeHints.prototype.hasCssHints = function (editor, implicitChar) {\n        this.editor = editor;\n        var cursor = this.editor.getCursorPos();\n\n        this.info = CSSUtils.getInfoAtPos(editor, cursor);\n\n        if (this.info.context !== CSSUtils.PROP_VALUE && this.info.context !== CSSUtils.IMPORT_URL) {\n            return false;\n        }\n\n        // collect existing value\n        var i,\n            val = \"\";\n\n        for (i = 0; i <= this.info.index && i < this.info.values.length; i++) {\n            if (i < this.info.index) {\n                val += this.info.values[i];\n            } else {\n                val += this.info.values[i].substring(0, this.info.offset);\n            }\n        }\n\n        // starts with \"url(\" ?\n        if (val.match(/^\\s*url\\(/i)) {\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * Helper function for hasHints() for HTML.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non-null,\n     * whether it is appropriate to do so.\n     */\n    UrlCodeHints.prototype.hasHtmlHints = function (editor, implicitChar) {\n        var tagInfo,\n            query,\n            tokenType;\n\n        this.editor = editor;\n\n        tagInfo = HTMLUtils.getTagInfo(editor, editor.getCursorPos());\n        query = null;\n        tokenType = tagInfo.position.tokenType;\n\n        if (tokenType === HTMLUtils.ATTR_VALUE) {\n\n            // Verify that attribute name has hintable values\n            if (htmlAttrs[tagInfo.attr.name]) {\n\n                if (tagInfo.position.offset >= 0) {\n                    query = tagInfo.attr.value.slice(0, tagInfo.position.offset);\n                } else {\n                    // We get negative offset for a quoted attribute value with some leading whitespaces\n                    // as in <a rel= \"rtl\" where the cursor is just to the right of the \"=\".\n                    // So just set the queryStr to an empty string.\n                    query = \"\";\n                }\n\n                var hintsAndSortFunc = this._getUrlHints({queryStr: query}),\n                    hints = hintsAndSortFunc.hints;\n\n                if (hints instanceof Array) {\n                    // If we got synchronous hints, check if we have something we'll actually use\n                    var i, foundPrefix = false;\n                    query = query.toLowerCase();\n                    for (i = 0; i < hints.length; i++) {\n                        if (hints[i].toLowerCase().indexOf(query) === 0) {\n                            foundPrefix = true;\n                            break;\n                        }\n                    }\n\n                    if (!foundPrefix) {\n                        query = null;\n                    }\n                }\n            }\n        }\n\n        return (query !== null);\n    };\n\n    /**\n     * Returns a list of available url hints, if possible, for the current\n     * editor context.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists, should be\n     *    selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    UrlCodeHints.prototype.getHints = function (key) {\n        var mode = this.editor.getModeForSelection(),\n            cursor = this.editor.getCursorPos(),\n            filter = \"\",\n            hints = [],\n            sortFunc,\n            query = { queryStr: \"\" },\n            result = [];\n\n        if (mode === \"html\") {\n            var tagInfo = HTMLUtils.getTagInfo(this.editor, cursor),\n                tokenType = tagInfo.position.tokenType;\n\n            if (tokenType !== HTMLUtils.ATTR_VALUE || !htmlAttrs[tagInfo.attr.name]) {\n                return null;\n            }\n\n            if (tagInfo.position.offset >= 0) {\n                query.queryStr = tagInfo.attr.value.slice(0, tagInfo.position.offset);\n            }\n            this.info = tagInfo;\n\n        } else if (styleModes.indexOf(mode) > -1) {\n            this.info = CSSUtils.getInfoAtPos(this.editor, cursor);\n\n            var context = this.info.context;\n            if (context !== CSSUtils.PROP_VALUE && context !== CSSUtils.IMPORT_URL) {\n                return null;\n            }\n\n            // Cursor is in an existing property value or partially typed value\n            if (this.info.index !== -1) {\n\n                // Collect value up to (item) index/(char) offset\n                var i, val = \"\";\n                for (i = 0; i < this.info.index; i++) {\n                    val += this.info.values[i];\n                }\n                // index may exceed length of array for multiple-value case\n                if (this.info.index < this.info.values.length) {\n                    val += this.info.values[this.info.index].substr(0, this.info.offset);\n                }\n\n                // Strip \"url(\"\n                val = val.replace(/^\\s*url\\(/i, \"\");\n\n                // Keep track of leading whitespace and strip it\n                var matchWhitespace = val.match(/^\\s*/);\n                if (matchWhitespace) {\n                    this.info.leadingWhitespace = matchWhitespace[0];\n                    val = val.substring(matchWhitespace[0].length);\n                } else {\n                    this.info.leadingWhitespace = null;\n                }\n\n                // Keep track of opening quote and strip it\n                if (val.match(/^[\"']/)) {\n                    this.info.openingQuote = val[0];\n                    val = val.substring(1);\n                } else {\n                    this.info.openingQuote = null;\n                }\n\n                query.queryStr = val;\n            }\n\n        } else {\n            return null;\n        }\n\n        if (query.queryStr !== null) {\n            filter = query.queryStr;\n            var hintsAndSortFunc = this._getUrlHints(query);\n            hints = hintsAndSortFunc.hints;\n            sortFunc = hintsAndSortFunc.sortFunc;\n        }\n        this.info.filter = filter;\n\n        if (hints instanceof Array && hints.length) {\n            // Array was returned\n            var lowerCaseFilter = filter.toLowerCase();\n            console.assert(!result.length);\n            result = $.map(hints, function (item) {\n                if (item.toLowerCase().indexOf(lowerCaseFilter) === 0) {\n                    return item;\n                }\n            }).sort(sortFunc);\n\n            return {\n                hints: result,\n                match: query.queryStr,\n                selectInitial: true,\n                handleWideResults: false\n            };\n\n        } else if (hints instanceof Object && hints.hasOwnProperty(\"done\")) {\n            // Deferred hints were returned\n            var deferred = $.Deferred();\n            hints.done(function (asyncHints) {\n                var lowerCaseFilter = filter.toLowerCase();\n                result = $.map(asyncHints, function (item) {\n                    if (item.toLowerCase().indexOf(lowerCaseFilter) === 0) {\n                        return item;\n                    }\n                }).sort(sortFunc);\n\n                deferred.resolveWith(this, [{\n                    hints: result,\n                    match: query.queryStr,\n                    selectInitial: true,\n                    handleWideResults: false\n                }]);\n            });\n\n            return deferred;\n        }\n\n        return null;\n    };\n\n    /**\n     * Inserts a given url hint into the current editor context.\n     *\n     * @param {jQuery.Object} completion\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    UrlCodeHints.prototype.insertHint = function (completion) {\n        var mode = this.editor.getModeForSelection();\n\n        // Encode the string just prior to inserting the hint into the editor\n        completion = encodeURI(completion);\n\n        if (mode === \"html\") {\n            return this.insertHtmlHint(completion);\n        } else if (styleModes.indexOf(mode) > -1) {\n            return this.insertCssHint(completion);\n        }\n\n        return false;\n    };\n\n    /**\n     * Get distance between 2 positions.\n     *\n     * Assumption: pos2 >= pos1\n     *\n     * Note that this function is designed to work on CSSUtils info.values array,\n     * so this could be made a method if that is converted to an object.\n     *\n     * @param {Array.<string>}  array  - strings to be searched\n     * @param {{index: number, offset: number}} pos1 - starting index/offset in index string\n     * @param {{index: number, offset: number}} pos2 - ending index/offset in index string\n     *\n     * @return {number}\n     * Number of characters between 2 positions\n     */\n    UrlCodeHints.prototype.getCharOffset = function (array, pos1, pos2) {\n        var i, count = 0;\n\n        if (pos1.index === pos2.index) {\n            return (pos2.offset >= pos1.offset) ? (pos2.offset - pos1.offset) : 0;\n        } else if (pos1.index < pos2.index) {\n            if (pos1.index < 0 || pos1.index >= array.length || pos2.index < 0 || pos2.index >= array.length) {\n                return 0;\n            }\n\n            for (i = pos1.index; i <= pos2.index; i++) {\n                if (i === pos1.index) {\n                    count += (array[i].length - pos1.offset);\n                } else if (i === pos2.index) {\n                    count += pos2.offset;\n                } else {\n                    count += array[i].length;\n                }\n            }\n        }\n\n        return count;\n    };\n\n    /**\n     * Finds next position in array of specified char.\n     *\n     * Note that this function is designed to work on CSSUtils info.values array,\n     * so this could be made a method if that is converted to an object.\n     *\n     * @param {Array}  array - strings to be searched\n     * @param {string} ch    - char to search for\n     * @param {{index: number, offset: number}} pos - starting index/offset in index string\n     *\n     * @return {{index: number, offset: number}}\n     * Index of array, and offset in string where char found.\n     */\n    UrlCodeHints.prototype.findNextPosInArray = function (array, ch, pos) {\n        var i, o, searchOffset;\n        for (i = pos.index; i < array.length; i++) {\n            // Only use offset on index, then offset of 0 after that\n            searchOffset = (i === pos.index) ? pos.offset : 0;\n            o = array[i].indexOf(ch, searchOffset);\n\n            if (o !== -1) {\n                return { index: i, offset: o };\n            }\n        }\n        return { index: -1, offset: -1 };\n    };\n\n    /**\n     * Inserts a given css url hint into the current editor context.\n     *\n     * @param {jQuery.Object} completion\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    UrlCodeHints.prototype.insertCssHint = function (completion) {\n        var cursor = this.editor.getCursorPos(),\n            start  = { line: cursor.line, ch: cursor.ch },\n            end    = { line: cursor.line, ch: cursor.ch };\n\n        var hasClosingQuote = false,\n            hasClosingParen = false,\n            insertText      = completion,\n            moveLen         = 0,\n            closingPos      = { index: -1, offset: -1 },\n            searchResult    = { index: -1, offset: -1 };\n\n        if (this.info.context !== CSSUtils.PROP_VALUE && this.info.context !== CSSUtils.IMPORT_URL) {\n            return false;\n        }\n\n        // Special handling for URL hinting -- if the completion is a file name\n        // and not a folder, then close the code hint list.\n        if (!this.closeOnSelect && completion.match(/\\/$/) === null) {\n            this.closeOnSelect = true;\n        }\n\n        // Look for optional closing quote\n        if (this.info.openingQuote) {\n            closingPos = this.findNextPosInArray(this.info.values, this.info.openingQuote, this.info);\n            hasClosingQuote = (closingPos.index !== -1);\n        }\n\n        // Look for closing paren\n        if (hasClosingQuote) {\n            searchResult = this.findNextPosInArray(this.info.values, \")\", closingPos);\n            hasClosingParen = (searchResult.index !== -1);\n        } else {\n            // index may exceed length of array for multiple-value case\n            closingPos = this.findNextPosInArray(this.info.values, \")\", this.info);\n            hasClosingParen = (closingPos.index !== -1);\n        }\n\n        // Insert folder names, but replace file names, so if a file is selected\n        // (i.e. closeOnSelect === true), then adjust insert char positions to\n        // replace existing value, if there is a closing paren\n        if (this.closeOnSelect) {\n            if (closingPos.index !== -1) {\n                end.ch += this.getCharOffset(this.info.values, this.info, closingPos);\n            }\n        } else {\n            // If next char is \"/\", then overwrite it since we're inserting a \"/\"\n            var nextSlash = this.findNextPosInArray(this.info.values, \"/\", this.info);\n            if (nextSlash.index === this.info.index && nextSlash.offset === this.info.offset) {\n                end.ch += 1;\n            }\n        }\n        if (this.info.filter.length > 0) {\n            start.ch -= this.info.filter.length;\n        }\n\n        // Append matching quote, whitespace, paren\n        if (this.info.openingQuote && !hasClosingQuote) {\n            insertText += this.info.openingQuote;\n        }\n        if (!hasClosingParen) {\n            // Add trailing whitespace to match leading whitespace\n            if (this.info.leadingWhitespace) {\n                insertText += this.info.leadingWhitespace;\n            }\n            insertText += \")\";\n        }\n\n        // HACK (tracking adobe/brackets#1688): We talk to the private CodeMirror instance\n        // directly to replace the range instead of using the Document, as we should. The\n        // reason is due to a flaw in our current document synchronization architecture when\n        // inline editors are open.\n        this.editor._codeMirror.replaceRange(insertText, start, end);\n\n        // Adjust cursor position\n        if (this.closeOnSelect) {\n            // If there is existing closing quote and/or paren, move the cursor past them\n            moveLen = (hasClosingQuote ? 1 : 0) + (hasClosingParen ? 1 : 0);\n            if (moveLen > 0) {\n                this.editor.setCursorPos(start.line, start.ch + completion.length + moveLen);\n            }\n            return false;\n\n        }\n            // If closing quote and/or paren are added, move the cursor to where it would have been\n        moveLen = ((this.info.openingQuote && !hasClosingQuote) ? 1 : 0) + (!hasClosingParen ? 1 : 0);\n        if (moveLen > 0) {\n            this.editor.setCursorPos(start.line, start.ch + completion.length);\n        }\n\n\n        return true;\n    };\n\n    /**\n     * Inserts a given html url hint into the current editor context.\n     *\n     * @param {jQuery.Object} completion\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    UrlCodeHints.prototype.insertHtmlHint = function (completion) {\n        var cursor = this.editor.getCursorPos(),\n            start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            tagInfo = HTMLUtils.getTagInfo(this.editor, cursor),\n            tokenType = tagInfo.position.tokenType,\n            charCount = 0,\n            endQuote = \"\",\n            shouldReplace = false;\n\n        if (tokenType === HTMLUtils.ATTR_VALUE) {\n            // Special handling for URL hinting -- if the completion is a file name\n            // and not a folder, then close the code hint list.\n            if (!this.closeOnSelect && completion.match(/\\/$/) === null) {\n                this.closeOnSelect = true;\n\n                // Insert folder names, but replace file names\n                shouldReplace = true;\n            }\n\n            if (!tagInfo.attr.hasEndQuote) {\n                endQuote = tagInfo.attr.quoteChar;\n                if (endQuote) {\n                    completion += endQuote;\n                } else if (tagInfo.position.offset === 0) {\n                    completion = \"\\\"\" + completion + \"\\\"\";\n                }\n            }\n\n            if (shouldReplace) {\n                // Replace entire value\n                charCount = tagInfo.attr.value.length;\n            } else {\n                // Replace filter (to insert new selection)\n                charCount = this.info.filter.length;\n\n                // If next char is \"/\", then overwrite it since we're inserting a \"/\"\n                if (this.info.attr.value.length > charCount && this.info.attr.value[charCount] === \"/\") {\n                    charCount += 1;\n                }\n            }\n        }\n\n        end.line = start.line = cursor.line;\n        start.ch = cursor.ch - tagInfo.position.offset;\n        end.ch = start.ch + charCount;\n\n        this.editor.document.replaceRange(completion, start, end);\n\n        if (!this.closeOnSelect) {\n            // If we append the missing quote, then we need to adjust the cursor postion\n            // to keep the code hint list open.\n            if (tokenType === HTMLUtils.ATTR_VALUE && !tagInfo.attr.hasEndQuote) {\n                this.editor.setCursorPos(start.line, start.ch + completion.length - 1);\n            }\n            return true;\n        }\n\n        if (tokenType === HTMLUtils.ATTR_VALUE && tagInfo.attr.hasEndQuote) {\n            // Move the cursor to the right of the existing end quote after value insertion.\n            this.editor.setCursorPos(start.line, start.ch + completion.length + 1);\n        }\n\n        return false;\n    };\n\n    function _clearCachedHints() {\n        // Verify cache exists and is not deferred\n        if (urlHints && urlHints.cachedHints && urlHints.cachedHints.deferred &&\n                urlHints.cachedHints.deferred.state() !== \"pending\") {\n\n            // Cache may or may not be stale. Main benefit of cache is to limit async lookups\n            // during typing. File tree updates cannot happen during typing, so it's probably\n            // not worth determining whether cache may still be valid. Just delete it.\n            urlHints.cachedHints = null;\n        }\n    }\n\n    AppInit.appReady(function () {\n        data            = JSON.parse(Data);\n        htmlAttrs       = data.htmlAttrs;\n\n        urlHints        = new UrlCodeHints();\n        CodeHintManager.registerHintProvider(urlHints, [\"css\", \"html\", \"less\", \"scss\"], 5);\n\n        FileSystem.on(\"change\", _clearCachedHints);\n        FileSystem.on(\"rename\", _clearCachedHints);\n\n        // For unit testing\n        exports.hintProvider = urlHints;\n    });\n});\n"],"file":"main.js"}
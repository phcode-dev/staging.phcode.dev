{"version":3,"sources":["extensions/default/InlineTimingFunctionEditor/main.js"],"names":["define","require","exports","module","EditorManager","brackets","getModule","ExtensionUtils","Strings","Mustache","InlineTimingFunctionEditor","TimingFunctionUtils","Localized","prepareEditorForProvider","hostEditor","pos","cursorLine","sel","startPos","endPos","startBookmark","endBookmark","currentMatch","cm","_codeMirror","getSelection","start","line","end","timingFunction","reason","document","getLine","match","timingFunctionMatch","ERROR_TIMINGQUICKEDIT_INVALIDSYNTAX","lineOffset","matchLength","originalString","length","ch","index","restOfLine","substring","newMatch","$","extend","setBookmark","setSelection","inlineTimingFunctionEditorProvider","context","inlineTimingFunctionEditor","result","load","Deferred","resolve","promise","init","loadStyleSheet","addEmbeddedStyleSheet","render","registerInlineEditProvider"],"mappings":"AA2CAA,OAAO,SAAUC,QAASC,QAASC,QAI/B,IAAIC,cAAsBC,SAASC,UAAU,wBACzCC,eAAsBF,SAASC,UAAU,wBACzCE,QAAsBH,SAASC,UAAU,WACzCG,SAAsBJ,SAASC,UAAU,gCAEzCI,2BAA6BT,QAAQ,8BAA8BS,2BACnEC,oBAA6BV,QAAQ,uBACrCW,UAA6BX,QAAQ,sBAczC,SAASY,yBAAyBC,WAAYC,KAC1C,IAAIC,WAAYC,IAAKC,SAAUC,OAAQC,cAAeC,YAAaC,aAC/DC,GAAKT,WAAWU,YAGpB,IADAP,IAAMH,WAAWW,gBACTC,MAAMC,OAASV,IAAIW,IAAID,KAC3B,MAAO,CAACE,eAAgB,KAAMC,OAAQ,MAO1C,KAJAd,WAAaF,WAAWiB,SAASC,QAAQjB,IAAIY,OAI7BM,MAAM,iCAClB,MAAO,CAACJ,eAAgB,KAAMC,OAAQ,MAI1C,KADAR,aAAeX,oBAAoBuB,oBAAoBlB,YAAY,IAE/D,MAAO,CAACa,eAAgB,KAAMC,OAAQtB,QAAQ2B,qCAMlD,IAFA,IAAIC,WAAa,EACbC,YAAgBf,aAAagB,gBAAkBhB,aAAagB,eAAeC,QAAWjB,aAAa,GAAGiB,OACnGxB,IAAIyB,GAAMlB,aAAamB,MAAQJ,YAAcD,YAAa,CAC7D,IAAIM,WAAa1B,WAAW2B,UAAUrB,aAAamB,MAAQJ,YAAcD,YACrEQ,SAAWjC,oBAAoBuB,oBAAoBQ,YAAY,GAEnE,IAAIE,SAIA,MAHAR,YAAed,aAAamB,MAAQJ,YACpCf,aAAeuB,EAAEC,QAAO,EAAM,GAAIF,UAkB1C,OAZAtB,aAAac,WAAaA,WAE1BlB,SAAW,CAACS,KAAMZ,IAAIY,KAAMa,GAAIJ,WAAad,aAAamB,OAC1DtB,OAAW,CAACQ,KAAMZ,IAAIY,KAAMa,GAAIJ,WAAad,aAAamB,MAAQJ,aAElEjB,cAAgBG,GAAGwB,YAAY7B,UAC/BG,YAAgBE,GAAGwB,YAAY5B,QAI/BL,WAAWkC,aAAa9B,SAAUC,QAE3B,CACHU,eAAgBP,aAChBI,MAAON,cACPQ,IAAKP,aAcb,SAAS4B,mCAAmCnC,WAAYC,KACpD,IAAImC,QAAUrC,yBAAyBC,WAAYC,KAC/CoC,2BACAC,OAEJ,OAAKF,QAAQrB,iBAGbsB,2BAA6B,IAAIzC,2BAA2BwC,QAAQrB,eAAgBqB,QAAQxB,MAAOwB,QAAQtB,MAChFyB,KAAKvC,aAEhCsC,OAAS,IAAIP,EAAES,UACRC,QAAQJ,4BACRC,OAAOI,WAPHN,QAAQpB,QAAU,KAcjC,SAAS2B,OAELlD,eAAemD,eAAevD,OAAQ,aACtCI,eAAeoD,sBAAsBlD,SAASmD,OAAOhD,UAAWJ,UAEhEJ,cAAcyD,2BAA2BZ,oCAG7CQ,OAIAvD,QAAQ+C,mCAAqCA","sourcesContent":["/*\n *  Copyright (c) 2021 - present core.ai . All rights reserved.\n *  Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/*\n * The timing function canvas and editing code was adapted from Lea Verou's cubic-bezier project:\n * - https://github.com/LeaVerou/cubic-bezier (cubic-bezier.com)\n *\n * The canvas exceeds the top and bottom of main grid so y-value of points can be\n * dragged outside of the 0-1 range.\n *\n *   . . . . . .\n *   .         .\n *   +---------+\n *   |         |\n *   |         |\n *   |         |\n *   |         |\n *   +---------+ <-- main grid has height of 150\n *   .         .\n *   . . . . . . <-- canvas has height of 300 (extra 75 above/below)\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Brackets modules\n    var EditorManager       = brackets.getModule(\"editor/EditorManager\"),\n        ExtensionUtils      = brackets.getModule(\"utils/ExtensionUtils\"),\n        Strings             = brackets.getModule(\"strings\"),\n        Mustache            = brackets.getModule(\"thirdparty/mustache/mustache\"),\n\n        InlineTimingFunctionEditor = require(\"InlineTimingFunctionEditor\").InlineTimingFunctionEditor,\n        TimingFunctionUtils        = require(\"TimingFunctionUtils\"),\n        Localized                  = require(\"text!Localized.css\");\n\n\n    // Functions\n\n\n    /**\n     * Prepare hostEditor for an InlineTimingFunctionEditor at pos if possible.\n     * Return editor context if so; otherwise null.\n     *\n     * @param {Editor} hostEditor\n     * @param {{line:Number, ch:Number}} pos\n     * @return {timingFunction:{?string}, reason:{?string}, start:{?TextMarker}, end:{?TextMarker}}\n     */\n    function prepareEditorForProvider(hostEditor, pos) {\n        var cursorLine, sel, startPos, endPos, startBookmark, endBookmark, currentMatch,\n            cm = hostEditor._codeMirror;\n\n        sel = hostEditor.getSelection();\n        if (sel.start.line !== sel.end.line) {\n            return {timingFunction: null, reason: null};\n        }\n\n        cursorLine = hostEditor.document.getLine(pos.line);\n\n        // code runs several matches complicated patterns, multiple times, so\n        // first do a quick, simple check to see make sure we may have a match\n        if (!cursorLine.match(/cubic-bezier|linear|ease|step/)) {\n            return {timingFunction: null, reason: null};\n        }\n\n        currentMatch = TimingFunctionUtils.timingFunctionMatch(cursorLine, false);\n        if (!currentMatch) {\n            return {timingFunction: null, reason: Strings.ERROR_TIMINGQUICKEDIT_INVALIDSYNTAX};\n        }\n\n        // check for subsequent matches, and use first match after pos\n        var lineOffset = 0,\n            matchLength = ((currentMatch.originalString && currentMatch.originalString.length) || currentMatch[0].length);\n        while (pos.ch > (currentMatch.index + matchLength + lineOffset)) {\n            var restOfLine = cursorLine.substring(currentMatch.index + matchLength + lineOffset),\n                newMatch = TimingFunctionUtils.timingFunctionMatch(restOfLine, false);\n\n            if (newMatch) {\n                lineOffset += (currentMatch.index + matchLength);\n                currentMatch = $.extend(true, [], newMatch);\n            } else {\n                break;\n            }\n        }\n\n        currentMatch.lineOffset = lineOffset;\n\n        startPos = {line: pos.line, ch: lineOffset + currentMatch.index};\n        endPos   = {line: pos.line, ch: lineOffset + currentMatch.index + matchLength};\n\n        startBookmark = cm.setBookmark(startPos);\n        endBookmark   = cm.setBookmark(endPos);\n\n        // Adjust selection to the match so that the inline editor won't\n        // get dismissed while we're updating the timing function.\n        hostEditor.setSelection(startPos, endPos);\n\n        return {\n            timingFunction: currentMatch,\n            start: startBookmark,\n            end: endBookmark\n        };\n    }\n\n    /**\n     * Registered as an inline editor provider: creates an InlineTimingFunctionEditor\n     * when the cursor is on a timing function value.\n     *\n     * @param {!Editor} hostEditor\n     * @param {!{line:Number, ch:Number}} pos\n     * @return {?$.Promise} synchronously resolved with an InlineWidget, or\n     *         {string} if timing function with invalid syntax is detected at pos, or\n     *         null if there's no timing function at pos.\n     */\n    function inlineTimingFunctionEditorProvider(hostEditor, pos) {\n        var context = prepareEditorForProvider(hostEditor, pos),\n            inlineTimingFunctionEditor,\n            result;\n\n        if (!context.timingFunction) {\n            return context.reason || null;\n        }\n        inlineTimingFunctionEditor = new InlineTimingFunctionEditor(context.timingFunction, context.start, context.end);\n        inlineTimingFunctionEditor.load(hostEditor);\n\n        result = new $.Deferred();\n        result.resolve(inlineTimingFunctionEditor);\n        return result.promise();\n\n    }\n\n    /**\n     * Initialization code\n     */\n    function init() {\n        // Load our stylesheet\n        ExtensionUtils.loadStyleSheet(module, \"main.less\");\n        ExtensionUtils.addEmbeddedStyleSheet(Mustache.render(Localized, Strings));\n\n        EditorManager.registerInlineEditProvider(inlineTimingFunctionEditorProvider);\n    }\n\n    init();\n\n\n    // for unit tests only\n    exports.inlineTimingFunctionEditorProvider = inlineTimingFunctionEditorProvider;\n});\n"],"file":"main.js"}
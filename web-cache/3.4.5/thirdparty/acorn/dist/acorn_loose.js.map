{"version":3,"sources":["thirdparty/acorn/dist/acorn_loose.js"],"names":["global","factory","exports","module","require","define","amd","self","acorn","loose","this","noop","LooseParser","input","options","toks","constructor","BaseParser","tokenizer","tok","last","type","tokTypes","eof","start","end","validateRegExpFlags","validateRegExpPattern","locations","here","curPosition","loc","SourceLocation","ahead","context","curIndent","curLineStart","nextLineStart","lineEnd","inAsync","inFunction","prototype","startNode","Node","storeCurrentPos","startNodeAt","pos","finishNode","node","ranges","range","dummyNode","dummy","name","dummyIdent","dummyString","value","raw","eat","next","isContextual","eatContextual","canInsertSemicolon","braceR","lineBreak","test","slice","semicolon","semi","expect","i","lookAhead","j","pushCx","push","popCx","pop","length","isNewLine","charCodeAt","indentationAfter","count","ch","tabSize","closes","closeTok","indent","line","blockHeuristic","tokenStartsLine","p","extend","f","parse","parseTopLevel","plugins","len","arguments","cls","Parser","lp","isSpace","isDummy","shift","readToken","dot","substr","ecmaVersion","ellipsis","Token","e","SyntaxError","msg","message","raisedAt","replace","string","re","RegExp","regexp","template","resetTo","getLineInfo","charAt","match","exprAllowed","curLine","lineStart","lineBreakG","lastIndex","exec","index","n","lp$1","body","parseStatement","adaptDirectivePrologue","sourceType","starttype","kind","isLet","_var","_break","_continue","isBreak","label","parseIdent","_debugger","_do","_while","parseParenExpression","_for","isAwait","parenL","parseFor","_const","init$1","parseVar","declarations","_in","await","parseForIn","init","parseExpression","toAssignable","_function","parseFunction","_if","consequent","alternate","_else","_return","argument","_switch","blockIndent","cur","discriminant","cases","braceL","_case","_default","isCase","colon","_throw","_try","block","parseBlock","handler","_catch","clause","param","parseExprAtom","parenR","finalizer","_finally","_with","object","_class","parseClass","_import","expression","parseImport","_export","parseExport","isAsyncFunction","expr","update","left","right","noIn","decl","id","eq","parseMaybeAssign","comma","decl$1","isStatement","superClass","_extends","method","isGenerator","isAsync","static","star","parsePropertyName","key","computed","parseMethod","oldInAsync","oldInFunction","initFunction","generator","async","params","parseFunctionParams","source","fNode","declaration","keyword","specifiers","parseExportSpecifierList","elt","local","parseImportSpecifiers","unshift","elts","continuedLine","elt$1","imported","exported","lp$2","checkLVal","expressions","val","startsExpr","delegate","parseMaybeConditional","isAssign","node$1","operator","parseExprOps","question","parseExprOp","parseMaybeUnary","minPrec","prec","binop","rightStart","sawUnary","allowAwaitOutsideFunction","parseAwait","prefix","incDec","parseExprSubscripts","postfix","node$2","starstar","node$3","parseSubscripts","base","noCalls","startIndent","maybeAsyncArrow","property","parsePropertyAccessor","bracketL","bracketR","backQuote","tag","quasi","parseTemplate","exprList","parseExprList","arrow","parseArrowExpression","callee","_this","_super","regex","pattern","flags","num","bigint","_null","_true","_false","parenStart","inner","preserveParens","par","elements","parseObj","_new","parseNew","parseDynamicImport","meta","parseTemplateElement","elem","invalidTemplate","cooked","tail","curElt","quasis","properties","prop","shorthand","isAsyncProp","assign","binding","list","toAssignableList","close","allowEmpty","defaultOptions","Object","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('./acorn')) :\n  typeof define === 'function' && define.amd ? define(['exports', './acorn'], factory) :\n  (global = global || self, factory((global.acorn = global.acorn || {}, global.acorn.loose = {}), global.acorn));\n}(this, function (exports, acorn) { 'use strict';\n\n  function noop() {}\n\n  var LooseParser = function LooseParser(input, options) {\n    if ( options === void 0 ) options = {};\n\n    this.toks = this.constructor.BaseParser.tokenizer(input, options);\n    this.options = this.toks.options;\n    this.input = this.toks.input;\n    this.tok = this.last = {type: acorn.tokTypes.eof, start: 0, end: 0};\n    this.tok.validateRegExpFlags = noop;\n    this.tok.validateRegExpPattern = noop;\n    if (this.options.locations) {\n      var here = this.toks.curPosition();\n      this.tok.loc = new acorn.SourceLocation(this.toks, here, here);\n    }\n    this.ahead = []; // Tokens ahead\n    this.context = []; // Indentation contexted\n    this.curIndent = 0;\n    this.curLineStart = 0;\n    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n    this.inAsync = false;\n    this.inFunction = false;\n  };\n\n  LooseParser.prototype.startNode = function startNode () {\n    return new acorn.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null)\n  };\n\n  LooseParser.prototype.storeCurrentPos = function storeCurrentPos () {\n    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start\n  };\n\n  LooseParser.prototype.startNodeAt = function startNodeAt (pos) {\n    if (this.options.locations) {\n      return new acorn.Node(this.toks, pos[0], pos[1])\n    } else {\n      return new acorn.Node(this.toks, pos)\n    }\n  };\n\n  LooseParser.prototype.finishNode = function finishNode (node, type) {\n    node.type = type;\n    node.end = this.last.end;\n    if (this.options.locations)\n      { node.loc.end = this.last.loc.end; }\n    if (this.options.ranges)\n      { node.range[1] = this.last.end; }\n    return node\n  };\n\n  LooseParser.prototype.dummyNode = function dummyNode (type) {\n    var dummy = this.startNode();\n    dummy.type = type;\n    dummy.end = dummy.start;\n    if (this.options.locations)\n      { dummy.loc.end = dummy.loc.start; }\n    if (this.options.ranges)\n      { dummy.range[1] = dummy.start; }\n    this.last = {type: acorn.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc};\n    return dummy\n  };\n\n  LooseParser.prototype.dummyIdent = function dummyIdent () {\n    var dummy = this.dummyNode(\"Identifier\");\n    dummy.name = \"✖\";\n    return dummy\n  };\n\n  LooseParser.prototype.dummyString = function dummyString () {\n    var dummy = this.dummyNode(\"Literal\");\n    dummy.value = dummy.raw = \"✖\";\n    return dummy\n  };\n\n  LooseParser.prototype.eat = function eat (type) {\n    if (this.tok.type === type) {\n      this.next();\n      return true\n    } else {\n      return false\n    }\n  };\n\n  LooseParser.prototype.isContextual = function isContextual (name) {\n    return this.tok.type === acorn.tokTypes.name && this.tok.value === name\n  };\n\n  LooseParser.prototype.eatContextual = function eatContextual (name) {\n    return this.tok.value === name && this.eat(acorn.tokTypes.name)\n  };\n\n  LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon () {\n    return this.tok.type === acorn.tokTypes.eof || this.tok.type === acorn.tokTypes.braceR ||\n      acorn.lineBreak.test(this.input.slice(this.last.end, this.tok.start))\n  };\n\n  LooseParser.prototype.semicolon = function semicolon () {\n    return this.eat(acorn.tokTypes.semi)\n  };\n\n  LooseParser.prototype.expect = function expect (type) {\n    if (this.eat(type)) { return true }\n    for (var i = 1; i <= 2; i++) {\n      if (this.lookAhead(i).type === type) {\n        for (var j = 0; j < i; j++) { this.next(); }\n        return true\n      }\n    }\n  };\n\n  LooseParser.prototype.pushCx = function pushCx () {\n    this.context.push(this.curIndent);\n  };\n\n  LooseParser.prototype.popCx = function popCx () {\n    this.curIndent = this.context.pop();\n  };\n\n  LooseParser.prototype.lineEnd = function lineEnd (pos) {\n    while (pos < this.input.length && !acorn.isNewLine(this.input.charCodeAt(pos))) { ++pos; }\n    return pos\n  };\n\n  LooseParser.prototype.indentationAfter = function indentationAfter (pos) {\n    for (var count = 0;; ++pos) {\n      var ch = this.input.charCodeAt(pos);\n      if (ch === 32) { ++count; }\n      else if (ch === 9) { count += this.options.tabSize; }\n      else { return count }\n    }\n  };\n\n  LooseParser.prototype.closes = function closes (closeTok, indent, line, blockHeuristic) {\n    if (this.tok.type === closeTok || this.tok.type === acorn.tokTypes.eof) { return true }\n    return line !== this.curLineStart && this.curIndent < indent && this.tokenStartsLine() &&\n      (!blockHeuristic || this.nextLineStart >= this.input.length ||\n       this.indentationAfter(this.nextLineStart) < indent)\n  };\n\n  LooseParser.prototype.tokenStartsLine = function tokenStartsLine () {\n    for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {\n      var ch = this.input.charCodeAt(p);\n      if (ch !== 9 && ch !== 32) { return false }\n    }\n    return true\n  };\n\n  LooseParser.prototype.extend = function extend (name, f) {\n    this[name] = f(this[name]);\n  };\n\n  LooseParser.prototype.parse = function parse () {\n    this.next();\n    return this.parseTopLevel()\n  };\n\n  LooseParser.extend = function extend () {\n      var plugins = [], len = arguments.length;\n      while ( len-- ) plugins[ len ] = arguments[ len ];\n\n    var cls = this;\n    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n    return cls\n  };\n\n  LooseParser.parse = function parse (input, options) {\n    return new this(input, options).parse()\n  };\n\n  // Allows plugins to extend the base parser / tokenizer used\n  LooseParser.BaseParser = acorn.Parser;\n\n  var lp = LooseParser.prototype;\n\n  function isSpace(ch) {\n    return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || acorn.isNewLine(ch)\n  }\n\n  lp.next = function() {\n    this.last = this.tok;\n    if (this.ahead.length)\n      { this.tok = this.ahead.shift(); }\n    else\n      { this.tok = this.readToken(); }\n\n    if (this.tok.start >= this.nextLineStart) {\n      while (this.tok.start >= this.nextLineStart) {\n        this.curLineStart = this.nextLineStart;\n        this.nextLineStart = this.lineEnd(this.curLineStart) + 1;\n      }\n      this.curIndent = this.indentationAfter(this.curLineStart);\n    }\n  };\n\n  lp.readToken = function() {\n    for (;;) {\n      try {\n        this.toks.next();\n        if (this.toks.type === acorn.tokTypes.dot &&\n            this.input.substr(this.toks.end, 1) === \".\" &&\n            this.options.ecmaVersion >= 6) {\n          this.toks.end++;\n          this.toks.type = acorn.tokTypes.ellipsis;\n        }\n        return new acorn.Token(this.toks)\n      } catch (e) {\n        if (!(e instanceof SyntaxError)) { throw e }\n\n        // Try to skip some text, based on the error message, and then continue\n        var msg = e.message, pos = e.raisedAt, replace = true;\n        if (/unterminated/i.test(msg)) {\n          pos = this.lineEnd(e.pos + 1);\n          if (/string/.test(msg)) {\n            replace = {start: e.pos, end: pos, type: acorn.tokTypes.string, value: this.input.slice(e.pos + 1, pos)};\n          } else if (/regular expr/i.test(msg)) {\n            var re = this.input.slice(e.pos, pos);\n            try { re = new RegExp(re); } catch (e) { /* ignore compilation error due to new syntax */ }\n            replace = {start: e.pos, end: pos, type: acorn.tokTypes.regexp, value: re};\n          } else if (/template/.test(msg)) {\n            replace = {\n              start: e.pos,\n              end: pos,\n              type: acorn.tokTypes.template,\n              value: this.input.slice(e.pos, pos)\n            };\n          } else {\n            replace = false;\n          }\n        } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n          while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) { ++pos; }\n        } else if (/character escape|expected hexadecimal/i.test(msg)) {\n          while (pos < this.input.length) {\n            var ch = this.input.charCodeAt(pos++);\n            if (ch === 34 || ch === 39 || acorn.isNewLine(ch)) { break }\n          }\n        } else if (/unexpected character/i.test(msg)) {\n          pos++;\n          replace = false;\n        } else if (/regular expression/i.test(msg)) {\n          replace = true;\n        } else {\n          throw e\n        }\n        this.resetTo(pos);\n        if (replace === true) { replace = {start: pos, end: pos, type: acorn.tokTypes.name, value: \"✖\"}; }\n        if (replace) {\n          if (this.options.locations)\n            { replace.loc = new acorn.SourceLocation(\n              this.toks,\n              acorn.getLineInfo(this.input, replace.start),\n              acorn.getLineInfo(this.input, replace.end)); }\n          return replace\n        }\n      }\n    }\n  };\n\n  lp.resetTo = function(pos) {\n    this.toks.pos = pos;\n    var ch = this.input.charAt(pos - 1);\n    this.toks.exprAllowed = !ch || /[[{(,;:?/*=+\\-~!|&%^<>]/.test(ch) ||\n      /[enwfd]/.test(ch) &&\n      /\\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(pos - 10, pos));\n\n    if (this.options.locations) {\n      this.toks.curLine = 1;\n      this.toks.lineStart = acorn.lineBreakG.lastIndex = 0;\n      var match;\n      while ((match = acorn.lineBreakG.exec(this.input)) && match.index < pos) {\n        ++this.toks.curLine;\n        this.toks.lineStart = match.index + match[0].length;\n      }\n    }\n  };\n\n  lp.lookAhead = function(n) {\n    while (n > this.ahead.length)\n      { this.ahead.push(this.readToken()); }\n    return this.ahead[n - 1]\n  };\n\n  function isDummy(node) { return node.name === \"✖\" }\n\n  var lp$1 = LooseParser.prototype;\n\n  lp$1.parseTopLevel = function() {\n    var node = this.startNodeAt(this.options.locations ? [0, acorn.getLineInfo(this.input, 0)] : 0);\n    node.body = [];\n    while (this.tok.type !== acorn.tokTypes.eof) { node.body.push(this.parseStatement()); }\n    this.toks.adaptDirectivePrologue(node.body);\n    this.last = this.tok;\n    if (this.options.ecmaVersion >= 6) {\n      node.sourceType = this.options.sourceType;\n    }\n    return this.finishNode(node, \"Program\")\n  };\n\n  lp$1.parseStatement = function() {\n    var starttype = this.tok.type, node = this.startNode(), kind;\n\n    if (this.toks.isLet()) {\n      starttype = acorn.tokTypes._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n    case acorn.tokTypes._break: case acorn.tokTypes._continue:\n      this.next();\n      var isBreak = starttype === acorn.tokTypes._break;\n      if (this.semicolon() || this.canInsertSemicolon()) {\n        node.label = null;\n      } else {\n        node.label = this.tok.type === acorn.tokTypes.name ? this.parseIdent() : null;\n        this.semicolon();\n      }\n      return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n\n    case acorn.tokTypes._debugger:\n      this.next();\n      this.semicolon();\n      return this.finishNode(node, \"DebuggerStatement\")\n\n    case acorn.tokTypes._do:\n      this.next();\n      node.body = this.parseStatement();\n      node.test = this.eat(acorn.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();\n      this.semicolon();\n      return this.finishNode(node, \"DoWhileStatement\")\n\n    case acorn.tokTypes._for:\n      this.next(); // `for` keyword\n      var isAwait = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual(\"await\");\n\n      this.pushCx();\n      this.expect(acorn.tokTypes.parenL);\n      if (this.tok.type === acorn.tokTypes.semi) { return this.parseFor(node, null) }\n      var isLet = this.toks.isLet();\n      if (isLet || this.tok.type === acorn.tokTypes._var || this.tok.type === acorn.tokTypes._const) {\n        var init$1 = this.parseVar(this.startNode(), true, isLet ? \"let\" : this.tok.value);\n        if (init$1.declarations.length === 1 && (this.tok.type === acorn.tokTypes._in || this.isContextual(\"of\"))) {\n          if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {\n            node.await = isAwait;\n          }\n          return this.parseForIn(node, init$1)\n        }\n        return this.parseFor(node, init$1)\n      }\n      var init = this.parseExpression(true);\n      if (this.tok.type === acorn.tokTypes._in || this.isContextual(\"of\")) {\n        if (this.options.ecmaVersion >= 9 && this.tok.type !== acorn.tokTypes._in) {\n          node.await = isAwait;\n        }\n        return this.parseForIn(node, this.toAssignable(init))\n      }\n      return this.parseFor(node, init)\n\n    case acorn.tokTypes._function:\n      this.next();\n      return this.parseFunction(node, true)\n\n    case acorn.tokTypes._if:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.consequent = this.parseStatement();\n      node.alternate = this.eat(acorn.tokTypes._else) ? this.parseStatement() : null;\n      return this.finishNode(node, \"IfStatement\")\n\n    case acorn.tokTypes._return:\n      this.next();\n      if (this.eat(acorn.tokTypes.semi) || this.canInsertSemicolon()) { node.argument = null; }\n      else { node.argument = this.parseExpression(); this.semicolon(); }\n      return this.finishNode(node, \"ReturnStatement\")\n\n    case acorn.tokTypes._switch:\n      var blockIndent = this.curIndent, line = this.curLineStart;\n      this.next();\n      node.discriminant = this.parseParenExpression();\n      node.cases = [];\n      this.pushCx();\n      this.expect(acorn.tokTypes.braceL);\n\n      var cur;\n      while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true)) {\n        if (this.tok.type === acorn.tokTypes._case || this.tok.type === acorn.tokTypes._default) {\n          var isCase = this.tok.type === acorn.tokTypes._case;\n          if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n          node.cases.push(cur = this.startNode());\n          cur.consequent = [];\n          this.next();\n          if (isCase) { cur.test = this.parseExpression(); }\n          else { cur.test = null; }\n          this.expect(acorn.tokTypes.colon);\n        } else {\n          if (!cur) {\n            node.cases.push(cur = this.startNode());\n            cur.consequent = [];\n            cur.test = null;\n          }\n          cur.consequent.push(this.parseStatement());\n        }\n      }\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      this.popCx();\n      this.eat(acorn.tokTypes.braceR);\n      return this.finishNode(node, \"SwitchStatement\")\n\n    case acorn.tokTypes._throw:\n      this.next();\n      node.argument = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(node, \"ThrowStatement\")\n\n    case acorn.tokTypes._try:\n      this.next();\n      node.block = this.parseBlock();\n      node.handler = null;\n      if (this.tok.type === acorn.tokTypes._catch) {\n        var clause = this.startNode();\n        this.next();\n        if (this.eat(acorn.tokTypes.parenL)) {\n          clause.param = this.toAssignable(this.parseExprAtom(), true);\n          this.expect(acorn.tokTypes.parenR);\n        } else {\n          clause.param = null;\n        }\n        clause.body = this.parseBlock();\n        node.handler = this.finishNode(clause, \"CatchClause\");\n      }\n      node.finalizer = this.eat(acorn.tokTypes._finally) ? this.parseBlock() : null;\n      if (!node.handler && !node.finalizer) { return node.block }\n      return this.finishNode(node, \"TryStatement\")\n\n    case acorn.tokTypes._var:\n    case acorn.tokTypes._const:\n      return this.parseVar(node, false, kind || this.tok.value)\n\n    case acorn.tokTypes._while:\n      this.next();\n      node.test = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WhileStatement\")\n\n    case acorn.tokTypes._with:\n      this.next();\n      node.object = this.parseParenExpression();\n      node.body = this.parseStatement();\n      return this.finishNode(node, \"WithStatement\")\n\n    case acorn.tokTypes.braceL:\n      return this.parseBlock()\n\n    case acorn.tokTypes.semi:\n      this.next();\n      return this.finishNode(node, \"EmptyStatement\")\n\n    case acorn.tokTypes._class:\n      return this.parseClass(true)\n\n    case acorn.tokTypes._import:\n      if (this.options.ecmaVersion > 10 && this.lookAhead(1).type === acorn.tokTypes.parenL) {\n        node.expression = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\")\n      }\n\n      return this.parseImport()\n\n    case acorn.tokTypes._export:\n      return this.parseExport()\n\n    default:\n      if (this.toks.isAsyncFunction()) {\n        this.next();\n        this.next();\n        return this.parseFunction(node, true, true)\n      }\n      var expr = this.parseExpression();\n      if (isDummy(expr)) {\n        this.next();\n        if (this.tok.type === acorn.tokTypes.eof) { return this.finishNode(node, \"EmptyStatement\") }\n        return this.parseStatement()\n      } else if (starttype === acorn.tokTypes.name && expr.type === \"Identifier\" && this.eat(acorn.tokTypes.colon)) {\n        node.body = this.parseStatement();\n        node.label = expr;\n        return this.finishNode(node, \"LabeledStatement\")\n      } else {\n        node.expression = expr;\n        this.semicolon();\n        return this.finishNode(node, \"ExpressionStatement\")\n      }\n    }\n  };\n\n  lp$1.parseBlock = function() {\n    var node = this.startNode();\n    this.pushCx();\n    this.expect(acorn.tokTypes.braceL);\n    var blockIndent = this.curIndent, line = this.curLineStart;\n    node.body = [];\n    while (!this.closes(acorn.tokTypes.braceR, blockIndent, line, true))\n      { node.body.push(this.parseStatement()); }\n    this.popCx();\n    this.eat(acorn.tokTypes.braceR);\n    return this.finishNode(node, \"BlockStatement\")\n  };\n\n  lp$1.parseFor = function(node, init) {\n    node.init = init;\n    node.test = node.update = null;\n    if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.semi) { node.test = this.parseExpression(); }\n    if (this.eat(acorn.tokTypes.semi) && this.tok.type !== acorn.tokTypes.parenR) { node.update = this.parseExpression(); }\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    node.body = this.parseStatement();\n    return this.finishNode(node, \"ForStatement\")\n  };\n\n  lp$1.parseForIn = function(node, init) {\n    var type = this.tok.type === acorn.tokTypes._in ? \"ForInStatement\" : \"ForOfStatement\";\n    this.next();\n    node.left = init;\n    node.right = this.parseExpression();\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    node.body = this.parseStatement();\n    return this.finishNode(node, type)\n  };\n\n  lp$1.parseVar = function(node, noIn, kind) {\n    node.kind = kind;\n    this.next();\n    node.declarations = [];\n    do {\n      var decl = this.startNode();\n      decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();\n      decl.init = this.eat(acorn.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    } while (this.eat(acorn.tokTypes.comma))\n    if (!node.declarations.length) {\n      var decl$1 = this.startNode();\n      decl$1.id = this.dummyIdent();\n      node.declarations.push(this.finishNode(decl$1, \"VariableDeclarator\"));\n    }\n    if (!noIn) { this.semicolon(); }\n    return this.finishNode(node, \"VariableDeclaration\")\n  };\n\n  lp$1.parseClass = function(isStatement) {\n    var node = this.startNode();\n    this.next();\n    if (this.tok.type === acorn.tokTypes.name) { node.id = this.parseIdent(); }\n    else if (isStatement === true) { node.id = this.dummyIdent(); }\n    else { node.id = null; }\n    node.superClass = this.eat(acorn.tokTypes._extends) ? this.parseExpression() : null;\n    node.body = this.startNode();\n    node.body.body = [];\n    this.pushCx();\n    var indent = this.curIndent + 1, line = this.curLineStart;\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent, line)) {\n      if (this.semicolon()) { continue }\n      var method = this.startNode(), isGenerator = (void 0), isAsync = (void 0);\n      if (this.options.ecmaVersion >= 6) {\n        method.static = false;\n        isGenerator = this.eat(acorn.tokTypes.star);\n      }\n      this.parsePropertyName(method);\n      if (isDummy(method.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(acorn.tokTypes.comma); continue }\n      if (method.key.type === \"Identifier\" && !method.computed && method.key.name === \"static\" &&\n          (this.tok.type !== acorn.tokTypes.parenL && this.tok.type !== acorn.tokTypes.braceL)) {\n        method.static = true;\n        isGenerator = this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(method);\n      } else {\n        method.static = false;\n      }\n      if (!method.computed &&\n          method.key.type === \"Identifier\" && method.key.name === \"async\" && this.tok.type !== acorn.tokTypes.parenL &&\n          !this.canInsertSemicolon()) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(method);\n      } else {\n        isAsync = false;\n      }\n      if (this.options.ecmaVersion >= 5 && method.key.type === \"Identifier\" &&\n          !method.computed && (method.key.name === \"get\" || method.key.name === \"set\") &&\n          this.tok.type !== acorn.tokTypes.parenL && this.tok.type !== acorn.tokTypes.braceL) {\n        method.kind = method.key.name;\n        this.parsePropertyName(method);\n        method.value = this.parseMethod(false);\n      } else {\n        if (!method.computed && !method.static && !isGenerator && !isAsync && (\n          method.key.type === \"Identifier\" && method.key.name === \"constructor\" ||\n            method.key.type === \"Literal\" && method.key.value === \"constructor\")) {\n          method.kind = \"constructor\";\n        } else {\n          method.kind = \"method\";\n        }\n        method.value = this.parseMethod(isGenerator, isAsync);\n      }\n      node.body.body.push(this.finishNode(method, \"MethodDefinition\"));\n    }\n    this.popCx();\n    if (!this.eat(acorn.tokTypes.braceR)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    this.semicolon();\n    this.finishNode(node.body, \"ClassBody\");\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  };\n\n  lp$1.parseFunction = function(node, isStatement, isAsync) {\n    var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = this.eat(acorn.tokTypes.star);\n    }\n    if (this.options.ecmaVersion >= 8) {\n      node.async = !!isAsync;\n    }\n    if (this.tok.type === acorn.tokTypes.name) { node.id = this.parseIdent(); }\n    else if (isStatement === true) { node.id = this.dummyIdent(); }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.parseFunctionParams();\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  };\n\n  lp$1.parseExport = function() {\n    var node = this.startNode();\n    this.next();\n    if (this.eat(acorn.tokTypes.star)) {\n      node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : this.dummyString();\n      return this.finishNode(node, \"ExportAllDeclaration\")\n    }\n    if (this.eat(acorn.tokTypes._default)) {\n      // export default (function foo() {}) // This is FunctionExpression.\n      var isAsync;\n      if (this.tok.type === acorn.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) { this.next(); }\n        node.declaration = this.parseFunction(fNode, \"nullableID\", isAsync);\n      } else if (this.tok.type === acorn.tokTypes._class) {\n        node.declaration = this.parseClass(\"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {\n      node.declaration = this.parseStatement();\n      node.specifiers = [];\n      node.source = null;\n    } else {\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifierList();\n      node.source = this.eatContextual(\"from\") ? this.parseExprAtom() : null;\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  };\n\n  lp$1.parseImport = function() {\n    var node = this.startNode();\n    this.next();\n    if (this.tok.type === acorn.tokTypes.string) {\n      node.specifiers = [];\n      node.source = this.parseExprAtom();\n    } else {\n      var elt;\n      if (this.tok.type === acorn.tokTypes.name && this.tok.value !== \"from\") {\n        elt = this.startNode();\n        elt.local = this.parseIdent();\n        this.finishNode(elt, \"ImportDefaultSpecifier\");\n        this.eat(acorn.tokTypes.comma);\n      }\n      node.specifiers = this.parseImportSpecifiers();\n      node.source = this.eatContextual(\"from\") && this.tok.type === acorn.tokTypes.string ? this.parseExprAtom() : this.dummyString();\n      if (elt) { node.specifiers.unshift(elt); }\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\")\n  };\n\n  lp$1.parseImportSpecifiers = function() {\n    var elts = [];\n    if (this.tok.type === acorn.tokTypes.star) {\n      var elt = this.startNode();\n      this.next();\n      elt.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n      elts.push(this.finishNode(elt, \"ImportNamespaceSpecifier\"));\n    } else {\n      var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n      this.pushCx();\n      this.eat(acorn.tokTypes.braceL);\n      if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n      while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n        var elt$1 = this.startNode();\n        if (this.eat(acorn.tokTypes.star)) {\n          elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : this.dummyIdent();\n          this.finishNode(elt$1, \"ImportNamespaceSpecifier\");\n        } else {\n          if (this.isContextual(\"from\")) { break }\n          elt$1.imported = this.parseIdent();\n          if (isDummy(elt$1.imported)) { break }\n          elt$1.local = this.eatContextual(\"as\") ? this.parseIdent() : elt$1.imported;\n          this.finishNode(elt$1, \"ImportSpecifier\");\n        }\n        elts.push(elt$1);\n        this.eat(acorn.tokTypes.comma);\n      }\n      this.eat(acorn.tokTypes.braceR);\n      this.popCx();\n    }\n    return elts\n  };\n\n  lp$1.parseExportSpecifierList = function() {\n    var elts = [];\n    var indent = this.curIndent, line = this.curLineStart, continuedLine = this.nextLineStart;\n    this.pushCx();\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curLineStart > continuedLine) { continuedLine = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {\n      if (this.isContextual(\"from\")) { break }\n      var elt = this.startNode();\n      elt.local = this.parseIdent();\n      if (isDummy(elt.local)) { break }\n      elt.exported = this.eatContextual(\"as\") ? this.parseIdent() : elt.local;\n      this.finishNode(elt, \"ExportSpecifier\");\n      elts.push(elt);\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.eat(acorn.tokTypes.braceR);\n    this.popCx();\n    return elts\n  };\n\n  var lp$2 = LooseParser.prototype;\n\n  lp$2.checkLVal = function(expr) {\n    if (!expr) { return expr }\n    switch (expr.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n      return expr\n\n    case \"ParenthesizedExpression\":\n      expr.expression = this.checkLVal(expr.expression);\n      return expr\n\n    default:\n      return this.dummyIdent()\n    }\n  };\n\n  lp$2.parseExpression = function(noIn) {\n    var start = this.storeCurrentPos();\n    var expr = this.parseMaybeAssign(noIn);\n    if (this.tok.type === acorn.tokTypes.comma) {\n      var node = this.startNodeAt(start);\n      node.expressions = [expr];\n      while (this.eat(acorn.tokTypes.comma)) { node.expressions.push(this.parseMaybeAssign(noIn)); }\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  };\n\n  lp$2.parseParenExpression = function() {\n    this.pushCx();\n    this.expect(acorn.tokTypes.parenL);\n    var val = this.parseExpression();\n    this.popCx();\n    this.expect(acorn.tokTypes.parenR);\n    return val\n  };\n\n  lp$2.parseMaybeAssign = function(noIn) {\n    if (this.toks.isContextual(\"yield\")) {\n      var node = this.startNode();\n      this.next();\n      if (this.semicolon() || this.canInsertSemicolon() || (this.tok.type !== acorn.tokTypes.star && !this.tok.type.startsExpr)) {\n        node.delegate = false;\n        node.argument = null;\n      } else {\n        node.delegate = this.eat(acorn.tokTypes.star);\n        node.argument = this.parseMaybeAssign();\n      }\n      return this.finishNode(node, \"YieldExpression\")\n    }\n\n    var start = this.storeCurrentPos();\n    var left = this.parseMaybeConditional(noIn);\n    if (this.tok.type.isAssign) {\n      var node$1 = this.startNodeAt(start);\n      node$1.operator = this.tok.value;\n      node$1.left = this.tok.type === acorn.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);\n      this.next();\n      node$1.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node$1, \"AssignmentExpression\")\n    }\n    return left\n  };\n\n  lp$2.parseMaybeConditional = function(noIn) {\n    var start = this.storeCurrentPos();\n    var expr = this.parseExprOps(noIn);\n    if (this.eat(acorn.tokTypes.question)) {\n      var node = this.startNodeAt(start);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      node.alternate = this.expect(acorn.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  };\n\n  lp$2.parseExprOps = function(noIn) {\n    var start = this.storeCurrentPos();\n    var indent = this.curIndent, line = this.curLineStart;\n    return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line)\n  };\n\n  lp$2.parseExprOp = function(left, start, minPrec, noIn, indent, line) {\n    if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) { return left }\n    var prec = this.tok.type.binop;\n    if (prec != null && (!noIn || this.tok.type !== acorn.tokTypes._in)) {\n      if (prec > minPrec) {\n        var node = this.startNodeAt(start);\n        node.left = left;\n        node.operator = this.tok.value;\n        this.next();\n        if (this.curLineStart !== line && this.curIndent < indent && this.tokenStartsLine()) {\n          node.right = this.dummyIdent();\n        } else {\n          var rightStart = this.storeCurrentPos();\n          node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);\n        }\n        this.finishNode(node, /&&|\\|\\|/.test(node.operator) ? \"LogicalExpression\" : \"BinaryExpression\");\n        return this.parseExprOp(node, start, minPrec, noIn, indent, line)\n      }\n    }\n    return left\n  };\n\n  lp$2.parseMaybeUnary = function(sawUnary) {\n    var start = this.storeCurrentPos(), expr;\n    if (this.options.ecmaVersion >= 8 && this.toks.isContextual(\"await\") &&\n      (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))\n    ) {\n      expr = this.parseAwait();\n      sawUnary = true;\n    } else if (this.tok.type.prefix) {\n      var node = this.startNode(), update = this.tok.type === acorn.tokTypes.incDec;\n      if (!update) { sawUnary = true; }\n      node.operator = this.tok.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(true);\n      if (update) { node.argument = this.checkLVal(node.argument); }\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else if (this.tok.type === acorn.tokTypes.ellipsis) {\n      var node$1 = this.startNode();\n      this.next();\n      node$1.argument = this.parseMaybeUnary(sawUnary);\n      expr = this.finishNode(node$1, \"SpreadElement\");\n    } else {\n      expr = this.parseExprSubscripts();\n      while (this.tok.type.postfix && !this.canInsertSemicolon()) {\n        var node$2 = this.startNodeAt(start);\n        node$2.operator = this.tok.value;\n        node$2.prefix = false;\n        node$2.argument = this.checkLVal(expr);\n        this.next();\n        expr = this.finishNode(node$2, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(acorn.tokTypes.starstar)) {\n      var node$3 = this.startNodeAt(start);\n      node$3.operator = \"**\";\n      node$3.left = expr;\n      node$3.right = this.parseMaybeUnary(false);\n      return this.finishNode(node$3, \"BinaryExpression\")\n    }\n\n    return expr\n  };\n\n  lp$2.parseExprSubscripts = function() {\n    var start = this.storeCurrentPos();\n    return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart)\n  };\n\n  lp$2.parseSubscripts = function(base, start, noCalls, startIndent, line) {\n    for (;;) {\n      if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine()) {\n        if (this.tok.type === acorn.tokTypes.dot && this.curIndent === startIndent)\n          { --startIndent; }\n        else\n          { return base }\n      }\n\n      var maybeAsyncArrow = base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n\n      if (this.eat(acorn.tokTypes.dot)) {\n        var node = this.startNodeAt(start);\n        node.object = base;\n        if (this.curLineStart !== line && this.curIndent <= startIndent && this.tokenStartsLine())\n          { node.property = this.dummyIdent(); }\n        else\n          { node.property = this.parsePropertyAccessor() || this.dummyIdent(); }\n        node.computed = false;\n        base = this.finishNode(node, \"MemberExpression\");\n      } else if (this.tok.type === acorn.tokTypes.bracketL) {\n        this.pushCx();\n        this.next();\n        var node$1 = this.startNodeAt(start);\n        node$1.object = base;\n        node$1.property = this.parseExpression();\n        node$1.computed = true;\n        this.popCx();\n        this.expect(acorn.tokTypes.bracketR);\n        base = this.finishNode(node$1, \"MemberExpression\");\n      } else if (!noCalls && this.tok.type === acorn.tokTypes.parenL) {\n        var exprList = this.parseExprList(acorn.tokTypes.parenR);\n        if (maybeAsyncArrow && this.eat(acorn.tokTypes.arrow))\n          { return this.parseArrowExpression(this.startNodeAt(start), exprList, true) }\n        var node$2 = this.startNodeAt(start);\n        node$2.callee = base;\n        node$2.arguments = exprList;\n        base = this.finishNode(node$2, \"CallExpression\");\n      } else if (this.tok.type === acorn.tokTypes.backQuote) {\n        var node$3 = this.startNodeAt(start);\n        node$3.tag = base;\n        node$3.quasi = this.parseTemplate();\n        base = this.finishNode(node$3, \"TaggedTemplateExpression\");\n      } else {\n        return base\n      }\n    }\n  };\n\n  lp$2.parseExprAtom = function() {\n    var node;\n    switch (this.tok.type) {\n    case acorn.tokTypes._this:\n    case acorn.tokTypes._super:\n      var type = this.tok.type === acorn.tokTypes._this ? \"ThisExpression\" : \"Super\";\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, type)\n\n    case acorn.tokTypes.name:\n      var start = this.storeCurrentPos();\n      var id = this.parseIdent();\n      var isAsync = false;\n      if (id.name === \"async\" && !this.canInsertSemicolon()) {\n        if (this.eat(acorn.tokTypes._function))\n          { return this.parseFunction(this.startNodeAt(start), false, true) }\n        if (this.tok.type === acorn.tokTypes.name) {\n          id = this.parseIdent();\n          isAsync = true;\n        }\n      }\n      return this.eat(acorn.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id\n\n    case acorn.tokTypes.regexp:\n      node = this.startNode();\n      var val = this.tok.value;\n      node.regex = {pattern: val.pattern, flags: val.flags};\n      node.value = val.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes.num: case acorn.tokTypes.string:\n      node = this.startNode();\n      node.value = this.tok.value;\n      node.raw = this.input.slice(this.tok.start, this.tok.end);\n      if (this.tok.type === acorn.tokTypes.num && node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes._null: case acorn.tokTypes._true: case acorn.tokTypes._false:\n      node = this.startNode();\n      node.value = this.tok.type === acorn.tokTypes._null ? null : this.tok.type === acorn.tokTypes._true;\n      node.raw = this.tok.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case acorn.tokTypes.parenL:\n      var parenStart = this.storeCurrentPos();\n      this.next();\n      var inner = this.parseExpression();\n      this.expect(acorn.tokTypes.parenR);\n      if (this.eat(acorn.tokTypes.arrow)) {\n        // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.\n        var params = inner.expressions || [inner];\n        if (params.length && isDummy(params[params.length - 1]))\n          { params.pop(); }\n        return this.parseArrowExpression(this.startNodeAt(parenStart), params)\n      }\n      if (this.options.preserveParens) {\n        var par = this.startNodeAt(parenStart);\n        par.expression = inner;\n        inner = this.finishNode(par, \"ParenthesizedExpression\");\n      }\n      return inner\n\n    case acorn.tokTypes.bracketL:\n      node = this.startNode();\n      node.elements = this.parseExprList(acorn.tokTypes.bracketR, true);\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case acorn.tokTypes.braceL:\n      return this.parseObj()\n\n    case acorn.tokTypes._class:\n      return this.parseClass(false)\n\n    case acorn.tokTypes._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, false)\n\n    case acorn.tokTypes._new:\n      return this.parseNew()\n\n    case acorn.tokTypes.backQuote:\n      return this.parseTemplate()\n\n    case acorn.tokTypes._import:\n      if (this.options.ecmaVersion > 10) {\n        return this.parseDynamicImport()\n      } else {\n        return this.dummyIdent()\n      }\n\n    default:\n      return this.dummyIdent()\n    }\n  };\n\n  lp$2.parseDynamicImport = function() {\n    var node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"Import\")\n  };\n\n  lp$2.parseNew = function() {\n    var node = this.startNode(), startIndent = this.curIndent, line = this.curLineStart;\n    var meta = this.parseIdent(true);\n    if (this.options.ecmaVersion >= 6 && this.eat(acorn.tokTypes.dot)) {\n      node.meta = meta;\n      node.property = this.parseIdent(true);\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var start = this.storeCurrentPos();\n    node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);\n    if (this.tok.type === acorn.tokTypes.parenL) {\n      node.arguments = this.parseExprList(acorn.tokTypes.parenR);\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\")\n  };\n\n  lp$2.parseTemplateElement = function() {\n    var elem = this.startNode();\n\n    // The loose parser accepts invalid unicode escapes even in untagged templates.\n    if (this.tok.type === acorn.tokTypes.invalidTemplate) {\n      elem.value = {\n        raw: this.tok.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.tok.start, this.tok.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.tok.value\n      };\n    }\n    this.next();\n    elem.tail = this.tok.type === acorn.tokTypes.backQuote;\n    return this.finishNode(elem, \"TemplateElement\")\n  };\n\n  lp$2.parseTemplate = function() {\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement();\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      this.next();\n      node.expressions.push(this.parseExpression());\n      if (this.expect(acorn.tokTypes.braceR)) {\n        curElt = this.parseTemplateElement();\n      } else {\n        curElt = this.startNode();\n        curElt.value = {cooked: \"\", raw: \"\"};\n        curElt.tail = true;\n        this.finishNode(curElt, \"TemplateElement\");\n      }\n      node.quasis.push(curElt);\n    }\n    this.expect(acorn.tokTypes.backQuote);\n    return this.finishNode(node, \"TemplateLiteral\")\n  };\n\n  lp$2.parseObj = function() {\n    var node = this.startNode();\n    node.properties = [];\n    this.pushCx();\n    var indent = this.curIndent + 1, line = this.curLineStart;\n    this.eat(acorn.tokTypes.braceL);\n    if (this.curIndent + 1 < indent) { indent = this.curIndent; line = this.curLineStart; }\n    while (!this.closes(acorn.tokTypes.braceR, indent, line)) {\n      var prop = this.startNode(), isGenerator = (void 0), isAsync = (void 0), start = (void 0);\n      if (this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.ellipsis)) {\n        prop.argument = this.parseMaybeAssign();\n        node.properties.push(this.finishNode(prop, \"SpreadElement\"));\n        this.eat(acorn.tokTypes.comma);\n        continue\n      }\n      if (this.options.ecmaVersion >= 6) {\n        start = this.storeCurrentPos();\n        prop.method = false;\n        prop.shorthand = false;\n        isGenerator = this.eat(acorn.tokTypes.star);\n      }\n      this.parsePropertyName(prop);\n      if (this.toks.isAsyncProp(prop)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(acorn.tokTypes.star);\n        this.parsePropertyName(prop);\n      } else {\n        isAsync = false;\n      }\n      if (isDummy(prop.key)) { if (isDummy(this.parseMaybeAssign())) { this.next(); } this.eat(acorn.tokTypes.comma); continue }\n      if (this.eat(acorn.tokTypes.colon)) {\n        prop.kind = \"init\";\n        prop.value = this.parseMaybeAssign();\n      } else if (this.options.ecmaVersion >= 6 && (this.tok.type === acorn.tokTypes.parenL || this.tok.type === acorn.tokTypes.braceL)) {\n        prop.kind = \"init\";\n        prop.method = true;\n        prop.value = this.parseMethod(isGenerator, isAsync);\n      } else if (this.options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n                 !prop.computed && (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n                 (this.tok.type !== acorn.tokTypes.comma && this.tok.type !== acorn.tokTypes.braceR && this.tok.type !== acorn.tokTypes.eq)) {\n        prop.kind = prop.key.name;\n        this.parsePropertyName(prop);\n        prop.value = this.parseMethod(false);\n      } else {\n        prop.kind = \"init\";\n        if (this.options.ecmaVersion >= 6) {\n          if (this.eat(acorn.tokTypes.eq)) {\n            var assign = this.startNodeAt(start);\n            assign.operator = \"=\";\n            assign.left = prop.key;\n            assign.right = this.parseMaybeAssign();\n            prop.value = this.finishNode(assign, \"AssignmentExpression\");\n          } else {\n            prop.value = prop.key;\n          }\n        } else {\n          prop.value = this.dummyIdent();\n        }\n        prop.shorthand = true;\n      }\n      node.properties.push(this.finishNode(prop, \"Property\"));\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.popCx();\n    if (!this.eat(acorn.tokTypes.braceR)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    return this.finishNode(node, \"ObjectExpression\")\n  };\n\n  lp$2.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(acorn.tokTypes.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseExpression();\n        this.expect(acorn.tokTypes.bracketR);\n        return\n      } else {\n        prop.computed = false;\n      }\n    }\n    var key = (this.tok.type === acorn.tokTypes.num || this.tok.type === acorn.tokTypes.string) ? this.parseExprAtom() : this.parseIdent();\n    prop.key = key || this.dummyIdent();\n  };\n\n  lp$2.parsePropertyAccessor = function() {\n    if (this.tok.type === acorn.tokTypes.name || this.tok.type.keyword) { return this.parseIdent() }\n  };\n\n  lp$2.parseIdent = function() {\n    var name = this.tok.type === acorn.tokTypes.name ? this.tok.value : this.tok.type.keyword;\n    if (!name) { return this.dummyIdent() }\n    var node = this.startNode();\n    this.next();\n    node.name = name;\n    return this.finishNode(node, \"Identifier\")\n  };\n\n  lp$2.initFunction = function(node) {\n    node.id = null;\n    node.params = [];\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = false;\n      node.expression = false;\n    }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = false; }\n  };\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  lp$2.toAssignable = function(node, binding) {\n    if (!node || node.type === \"Identifier\" || (node.type === \"MemberExpression\" && !binding)) ; else if (node.type === \"ParenthesizedExpression\") {\n      this.toAssignable(node.expression, binding);\n    } else if (this.options.ecmaVersion < 6) {\n      return this.dummyIdent()\n    } else if (node.type === \"ObjectExpression\") {\n      node.type = \"ObjectPattern\";\n      for (var i = 0, list = node.properties; i < list.length; i += 1)\n        {\n        var prop = list[i];\n\n        this.toAssignable(prop, binding);\n      }\n    } else if (node.type === \"ArrayExpression\") {\n      node.type = \"ArrayPattern\";\n      this.toAssignableList(node.elements, binding);\n    } else if (node.type === \"Property\") {\n      this.toAssignable(node.value, binding);\n    } else if (node.type === \"SpreadElement\") {\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, binding);\n    } else if (node.type === \"AssignmentExpression\") {\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n    } else {\n      return this.dummyIdent()\n    }\n    return node\n  };\n\n  lp$2.toAssignableList = function(exprList, binding) {\n    for (var i = 0, list = exprList; i < list.length; i += 1)\n      {\n      var expr = list[i];\n\n      this.toAssignable(expr, binding);\n    }\n    return exprList\n  };\n\n  lp$2.parseFunctionParams = function(params) {\n    params = this.parseExprList(acorn.tokTypes.parenR);\n    return this.toAssignableList(params, true)\n  };\n\n  lp$2.parseMethod = function(isGenerator, isAsync) {\n    var node = this.startNode(), oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6)\n      { node.generator = !!isGenerator; }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.parseFunctionParams();\n    node.body = this.parseBlock();\n    this.toks.adaptDirectivePrologue(node.body.body);\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, \"FunctionExpression\")\n  };\n\n  lp$2.parseArrowExpression = function(node, params, isAsync) {\n    var oldInAsync = this.inAsync, oldInFunction = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n    this.inAsync = node.async;\n    this.inFunction = true;\n    node.params = this.toAssignableList(params, true);\n    node.expression = this.tok.type !== acorn.tokTypes.braceL;\n    if (node.expression) {\n      node.body = this.parseMaybeAssign();\n    } else {\n      node.body = this.parseBlock();\n      this.toks.adaptDirectivePrologue(node.body.body);\n    }\n    this.inAsync = oldInAsync;\n    this.inFunction = oldInFunction;\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  };\n\n  lp$2.parseExprList = function(close, allowEmpty) {\n    this.pushCx();\n    var indent = this.curIndent, line = this.curLineStart, elts = [];\n    this.next(); // Opening bracket\n    while (!this.closes(close, indent + 1, line)) {\n      if (this.eat(acorn.tokTypes.comma)) {\n        elts.push(allowEmpty ? null : this.dummyIdent());\n        continue\n      }\n      var elt = this.parseMaybeAssign();\n      if (isDummy(elt)) {\n        if (this.closes(close, indent, line)) { break }\n        this.next();\n      } else {\n        elts.push(elt);\n      }\n      this.eat(acorn.tokTypes.comma);\n    }\n    this.popCx();\n    if (!this.eat(close)) {\n      // If there is no closing brace, make the node span to the start\n      // of the next token (this is useful for Tern)\n      this.last.end = this.tok.start;\n      if (this.options.locations) { this.last.loc.end = this.tok.loc.start; }\n    }\n    return elts\n  };\n\n  lp$2.parseAwait = function() {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary();\n    return this.finishNode(node, \"AwaitExpression\")\n  };\n\n  // Acorn: Loose parser\n\n  acorn.defaultOptions.tabSize = 4;\n\n  function parse(input, options) {\n    return LooseParser.parse(input, options)\n  }\n\n  exports.LooseParser = LooseParser;\n  exports.parse = parse;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],"file":"acorn_loose.js"}
{"version":3,"sources":["thirdparty/globmatch.js"],"names":["define","r","exports","module","platform","fnmatch","filepath","glob","matchOptions","dot","noext","length","matchBase","minimatch","replace","Minimatch","LRU","LRUCache","cache","cnt","this","set","k","v","get","max","GLOBSTAR","sigmund","obj","JSON","stringify","path","f","e","split","pop","qmark","star","twoStarDot","twoStarNoDot","reSpecials","charSet","s","reduce","c","slashSplit","monkeyPatch","desc","Object","getOwnPropertyDescriptor","String","prototype","orig","value","p","match","call","defineProperty","filter","pattern","options","i","list","ext","a","b","t","keys","forEach","TypeError","nocomment","charAt","trim","join","cacheKey","cached","regexp","negate","comment","empty","make","_made","parseNegate","globSet","braceExpand","debug","console","error","globParts","map","si","parse","indexOf","negateOffset","nonegate","l","substr","Error","nobrace","escaping","prefix","tail","numset","suf","start","end","inc","ii","ll","push","depth","member","sawEnd","addMember","FOR","addBraces","concat","ret","defaults","def","m","SUBPARSE","isSub","noglobstar","re","hasMagic","nocase","patternListStack","plType","stateChar","inClass","reClassStart","classStart","patternStart","pl","clearStateChar","len","type","reStart","cs","sp","slice","_","$1","$2","addPatternStart","globUnescape","flags","regExp","RegExp","_glob","_src","makeRe","twoStar","regExpEscape","ex","partial","hit","matchOne","flipNegate","mm","nonull","file","emptyFileEnd","fi","pi","fl","fr","pr","WHILE","swallowee","toLowerCase"],"mappings":"AAUAA,OAAO,SAAUC,EAAGC,QAASC,OAAQC,UAKrC,SAASC,QAAQC,SAAUC,MACzB,IAAIC,aAAe,CAACC,KAAK,EAAMC,OAAO,GAQtC,MALsC,MAAlCJ,SAASA,SAASK,OAAS,KAC7BH,aAAaI,WAAY,GAIpBC,UAAUP,SADjBC,KAAOA,KAAKO,QAAQ,QAAS,gBACIN,cAZnCL,OAAOD,QAAUG,QACjBQ,UAAUE,UAAYA,UActB,IAAIC,IAAM,SAASC,WAEX,IAAIC,MAAQ,GACRC,IAAM,EACVC,KAAKC,IAAM,SAAUC,EAAGC,KACtBJ,KACW,MAAKD,MAAQ,IACxBA,MAAMI,GAAKC,GAEbH,KAAKI,IAAM,SAAUF,GAAK,OAAOJ,MAAMI,KAE3CJ,MAAQL,UAAUK,MAAQ,IAAIF,IAAI,CAACS,IAAK,MACxCC,SAAWb,UAAUa,SAAWX,UAAUW,SAAW,GACrDC,QAAU,SAASA,QAASC,KACxB,OAAOC,KAAKC,UAAUF,MAG1BG,cAAmB,SAAUC,GAEzB,IAAIC,GADJD,EAAIA,EAAEE,MAAM,WACFC,MAEV,OADKF,IAAGA,EAAID,EAAEG,OACPF,GAIXG,MAAQ,OAGRC,KAAOD,MAAQ,KAKfE,WAAa,0CAIbC,aAAe,0BAGfC,WAAaC,QAAQ,mBAGzB,SAASA,QAASC,GAChB,OAAOA,EAAER,MAAM,IAAIS,OAAO,SAAUtB,IAAKuB,GAEvC,OADAvB,IAAIuB,IAAK,EACFvB,KACN,IAIL,IAAIwB,WAAa,MAGjB,SAASC,cACP,IAAIC,KAAOC,OAAOC,yBAAyBC,OAAOC,UAAW,SACzDC,KAAOL,KAAKM,MAChBN,KAAKM,MAAQ,SAAUC,GACrB,OAAIA,aAAavC,UAAkBuC,EAAEC,MAAMnC,MACpCgC,KAAKI,KAAKpC,KAAMkC,IAEzBN,OAAOS,eAAeP,OAAOC,UAAWJ,MAI1C,SAASW,OAAQC,QAASC,SAExB,OADAA,QAAUA,SAAW,GACd,SAAUN,EAAGO,EAAGC,MACrB,OAAOjD,UAAUyC,EAAGK,QAASC,UAIjC,SAASG,IAAKC,EAAGC,GACfD,EAAIA,GAAK,GACTC,EAAIA,GAAK,GACT,IAAIC,EAAI,GAOR,OANAlB,OAAOmB,KAAKF,GAAGG,QAAQ,SAAU9C,GAC/B4C,EAAE5C,GAAK2C,EAAE3C,KAEX0B,OAAOmB,KAAKH,GAAGI,QAAQ,SAAU9C,GAC/B4C,EAAE5C,GAAK0C,EAAE1C,KAEJ4C,EAyBT,SAASrD,UAAWyC,EAAGK,QAASC,SAC9B,GAAuB,iBAAZD,QACT,MAAM,IAAIU,UAAU,gCAMtB,OAHKT,UAASA,QAAU,OAGnBA,QAAQU,WAAmC,MAAtBX,QAAQY,OAAO,MAKlB,KAAnBZ,QAAQa,OAA4B,KAANlB,EAE3B,IAAIvC,UAAU4C,QAASC,SAASL,MAAMD,IAG/C,SAASvC,UAAW4C,QAASC,SAC3B,KAAMxC,gBAAgBL,WACpB,OAAO,IAAIA,UAAU4C,QAASC,QAAS1C,OAGzC,GAAuB,iBAAZyC,QACT,MAAM,IAAIU,UAAU,gCAGjBT,UAASA,QAAU,IACxBD,QAAUA,QAAQa,OAID,UAAbpE,WACFuD,QAAUA,QAAQzB,MAAM,MAAMuC,KAAK,MAMrC,IAAIC,SAAWf,QAAU,KAAOhC,QAAQiC,SACpCe,OAAS9D,UAAUK,MAAMM,IAAIkD,UACjC,GAAIC,OAAQ,OAAOA,OACnB9D,UAAUK,MAAMG,IAAIqD,SAAUtD,MAE9BA,KAAKwC,QAAUA,QACfxC,KAAKC,IAAM,GACXD,KAAKuC,QAAUA,QACfvC,KAAKwD,OAAS,KACdxD,KAAKyD,QAAS,EACdzD,KAAK0D,SAAU,EACf1D,KAAK2D,OAAQ,EAGb3D,KAAK4D,OAIP,SAASA,OAEP,IAAI5D,KAAK6D,MAAT,CAEA,IAAItB,QAAUvC,KAAKuC,QACfC,QAAUxC,KAAKwC,QAGnB,GAAKA,QAAQU,WAAmC,MAAtBX,QAAQY,OAAO,GAIzC,GAAKZ,QAAL,CAMAvC,KAAK8D,cAGL,IAAI7D,IAAMD,KAAK+D,QAAU/D,KAAKgE,cAE1BxB,QAAQyB,OAAOC,QAAQC,MAAMnE,KAAKuC,QAAStC,KAO/CA,IAAMD,KAAKoE,UAAYnE,IAAIoE,IAAI,SAAU/C,GACvC,OAAOA,EAAER,MAAMW,cAGbe,QAAQyB,OAAOC,QAAQC,MAAMnE,KAAKuC,QAAStC,KAG/CA,IAAMA,IAAIoE,IAAI,SAAU/C,EAAGgD,GAAIrE,KAC7B,OAAOqB,EAAE+C,IAAIrE,KAAKuE,MAAOvE,OACxBA,MAECwC,QAAQyB,OAAOC,QAAQC,MAAMnE,KAAKuC,QAAStC,KAG/CA,IAAMA,IAAIqC,OAAO,SAAUhB,GACzB,OAAQ,IAAMA,EAAEkD,SAAQ,KAGtBhC,QAAQyB,OAAOC,QAAQC,MAAMnE,KAAKuC,QAAStC,KAE/CD,KAAKC,IAAMA,SArCTD,KAAK2D,OAAQ,OAJb3D,KAAK0D,SAAU,GA6CnB,SAASI,cACP,IAAIvB,QAAUvC,KAAKuC,QACfkB,QAAS,EACTjB,QACAiC,aAAe,EAEnB,IAHczE,KAAKwC,QAGPkC,SAAZ,CAEA,IAAM,IAAIjC,EAAI,EAAGkC,EAAIpC,QAAQhD,OACvBkD,EAAIkC,GAA2B,MAAtBpC,QAAQY,OAAOV,GACxBA,IACJgB,QAAUA,OACVgB,eAGEA,eAAczE,KAAKuC,QAAUA,QAAQqC,OAAOH,eAChDzE,KAAKyD,OAASA,QAkBhB,SAASO,YAAazB,QAASC,SAK7B,GAJAA,QAAUA,SAAWxC,KAAKwC,aAIH,KAHvBD,aAA6B,IAAZA,QACbvC,KAAKuC,QAAUA,SAGjB,MAAM,IAAIsC,MAAM,qBAGlB,GAAIrC,QAAQsC,UACPvC,QAAQJ,MAAM,UAEjB,MAAO,CAACI,SAGV,IAAIwC,UAAW,EAmBf,GAA0B,MAAtBxC,QAAQY,OAAO,GAAY,CAG7B,IADA,IAAI6B,OAAS,KACJvC,EAAI,EAAGkC,EAAIpC,QAAQhD,OAAQkD,EAAIkC,EAAGlC,IAAM,CAC/C,IAAIjB,EAEJ,GAAU,QAFNA,EAAIe,QAAQY,OAAOV,IAGrBsC,UAAYA,cACP,GAAU,MAANvD,IAAcuD,SAAU,CACjCC,OAASzC,QAAQqC,OAAO,EAAGnC,GAC3B,OAKJ,OAAe,OAAXuC,OAEK,CAACzC,SAGCyB,YAAYzB,QAAQqC,OAAOnC,GAAID,SAC9B6B,IAAI,SAAUvB,GACxB,OAAOkC,OAASlC,IAFlB,IAAImC,KAaN,IAAIC,OAAS3C,QAAQJ,MAAM,iCAC3B,GAAI+C,OAAQ,CAOV,IALA,IAAIC,IAAMnB,YAAYzB,QAAQqC,OAAOM,OAAO,GAAG3F,QAASiD,SACpD4C,OAASF,OAAO,GAChBG,KAAOH,OAAO,GACdI,IAAMF,MAAQC,KAAO,EAAI,EACzBpF,IAAM,GACDwC,EAAI2C,MAAO3C,GAAM4C,IAAMC,IAAM7C,GAAK6C,IAEzC,IAAK,IAAIC,GAAK,EAAGC,GAAKL,IAAI5F,OAAQgG,GAAKC,GAAID,KACzCtF,IAAIwF,KAAKhD,EAAI0C,IAAII,KAGrB,OAAOtF,IAST,IAAIwC,EAAI,EACJiD,MAAQ,EACRzF,IAAM,GACN0F,OAAS,GACTC,QAAS,EACTb,UAAW,EAEf,SAASc,YACP5F,IAAIwF,KAAKE,QACTA,OAAS,GAIXG,IAAK,IAAKrD,EAAI,EAAGkC,EAAIpC,QAAQhD,OAAQkD,EAAIkC,EAAGlC,IAAM,CAChD,IAAIjB,EAAIe,QAAQY,OAAOV,GAGvB,GAAIsC,SACFA,UAAW,EACXY,QAAU,KAAOnE,OAEjB,OAAQA,GACN,IAAK,KACHuD,UAAW,EACX,SAEF,IAAK,IACHW,QACAC,QAAU,IACV,SAEF,IAAK,IAGH,GAAc,MAFdD,MAEiB,CACfG,YAEApD,IACA,MAAMqD,IAENH,QAAUnE,EACV,SAGJ,IAAK,IACW,IAAVkE,MACFG,YAEAF,QAAUnE,EAEZ,SAEF,QACEmE,QAAUnE,EACV,UAQR,GAAc,IAAVkE,MAEF,OAAO1B,YAAY,KAAOzB,QAASC,SAMrC,IAAI2C,IAAMnB,YAAYzB,QAAQqC,OAAOnC,GAAID,SAGrCuD,UAA2B,IAAf9F,IAAIV,OAUpBU,KARAA,IAAMA,IAAIoE,IAAI,SAAUnC,GACtB,OAAO8B,YAAY9B,EAAGM,YAOdjB,OAAO,SAAUoD,EAAG9F,GAC5B,OAAO8F,EAAEqB,OAAOnH,KAGdkH,YACF9F,IAAMA,IAAIoE,IAAI,SAAU/C,GACtB,MAAO,IAAMA,EAAI,OAMrB,IADA,IAAI2E,IAAM,GACDxD,EAAI,EAAGkC,EAAI1E,IAAIV,OAAQkD,EAAIkC,EAAGlC,IACrC,IAAK,IAAI8C,GAAK,EAAGC,GAAKL,IAAI5F,OAAQgG,GAAKC,GAAID,KACzCU,IAAIR,KAAKxF,IAAIwC,GAAK0C,IAAII,KAG1B,OAAOU,IArYTxG,UAAUiC,YAAcA,YAWxBjC,UAAU6C,OAASA,OAqBnB7C,UAAUyG,SAAW,SAAUC,KAC7B,IAAKA,MAAQvE,OAAOmB,KAAKoD,KAAK5G,OAAQ,OAAOE,UAE7C,IAAIuC,KAAOvC,UAEP2G,EAAI,SAAS3G,UAAWyC,EAAGK,QAASC,SACtC,OAAOR,KAAKvC,UAAUyC,EAAGK,QAASI,IAAIwD,IAAK3D,WAO7C,OAJA4D,EAAEzG,UAAY,SAASA,UAAW4C,QAASC,SACzC,OAAO,IAAIR,KAAKrC,UAAU4C,QAASI,IAAIwD,IAAK3D,WAGvC4D,GAGTzG,UAAUuG,SAAW,SAAUC,KAC7B,OAAKA,KAAQvE,OAAOmB,KAAKoD,KAAK5G,OACvBE,UAAUyG,SAASC,KAAKxG,UADcA,WA6D/CA,UAAUoC,UAAU6B,KAAOA,KAsD3BjE,UAAUoC,UAAU+B,YAAcA,YA8BlCrE,UAAUuE,YAAc,SAAUzB,QAASC,SACzC,OAAO,IAAI7C,UAAU4C,QAASC,SAASwB,eAGzCrE,UAAUoC,UAAUiC,YAAcA,YA6MlCrE,UAAUoC,UAAUwC,MAAQA,MAC5B,IAAI8B,SAAW,GACf,SAAS9B,MAAOhC,QAAS+D,OACvB,IAAI9D,QAAUxC,KAAKwC,QAGnB,IAAKA,QAAQ+D,YAA0B,OAAZhE,QAAkB,OAAOjC,SACpD,GAAgB,KAAZiC,QAAgB,MAAO,GAE3B,IAAIiE,GAAK,GACLC,WAAajE,QAAQkE,OACrB3B,UAAW,EAEX4B,iBAAmB,GACnBC,OACAC,UACAC,SAAU,EACVC,cAAgB,EAChBC,YAAc,EAGdC,aAAqC,MAAtB1E,QAAQY,OAAO,GAAa,GAEzCX,QAAQnD,IAAM,iCACd,UAyMF6H,GAvMJ,SAASC,iBACP,GAAIN,UAAW,CAGb,OAAQA,WACN,IAAK,IACHL,IAAMvF,KACNwF,UAAW,EACX,MACF,IAAK,IACHD,IAAMxF,MACNyF,UAAW,EACX,MACF,QACED,IAAM,KAAKK,UAGfA,WAAY,GAIhB,IAAM,IAAIpE,EAAI,EAAG2E,IAAM7E,QAAQhD,OAAQiC,EAChCiB,EAAI2E,MAAS5F,EAAIe,QAAQY,OAAOV,IACjCA,IAOJ,GALID,QAAQyB,OACVC,QAAQC,MAAM,eAAgB5B,QAASE,EAAG+D,GAAIhF,GAI5CuD,UAAY3D,WAAWI,GACzBgF,IAAM,KAAOhF,EACbuD,UAAW,OAIL,OAAQvD,GACd,IAAK,IAGH,OAAO,EAET,IAAK,KACH2F,iBACApC,UAAW,EACX,SAIF,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IAOH,GANIvC,QAAQyB,OACVC,QAAQC,MAAM,6BAA8B5B,QAASE,EAAG+D,GAAIhF,GAK1DsF,QAAS,CACD,MAANtF,GAAaiB,IAAMuE,WAAa,IAAGxF,EAAI,KAC3CgF,IAAMhF,EACN,SAMF2F,iBACAN,UAAYrF,EAIRgB,QAAQlD,OAAO6H,iBACnB,SAEF,IAAK,IACH,GAAIL,QAAS,CACXN,IAAM,IACN,SAGF,IAAKK,UAAW,CACdL,IAAM,MACN,SAGFI,OAASC,UACTF,iBAAiBlB,KAAK,CAAE4B,KAAMT,OACNxB,MAAO3C,EAAI,EACX6E,QAASd,GAAGjH,SAEpCiH,IAAoB,MAAdK,UAAoB,SAAW,MACrCA,WAAY,EACZ,SAEF,IAAK,IACH,GAAIC,UAAYH,iBAAiBpH,OAAQ,CACvCiH,IAAM,MACN,SAQF,OALAC,UAAW,EACXD,IAAM,IACNI,OAASD,iBAAiB5F,MAAMsG,MAI9B,IAAK,IACHb,IAAM,UACN,MACF,IAAK,IACL,IAAK,IACL,IAAK,IAAKA,IAAMI,OAGlB,SAEF,IAAK,IACH,GAAIE,UAAYH,iBAAiBpH,QAAUwF,SAAU,CACnDyB,IAAM,MACNzB,UAAW,EACX,SAGFyB,IAAM,IACN,SAGF,IAAK,IAIH,GAFAW,iBAEIL,QAAS,CACXN,IAAM,KAAOhF,EACb,SAGFsF,SAAU,EACVE,WAAavE,EACbsE,aAAeP,GAAGjH,OAClBiH,IAAMhF,EACN,SAEF,IAAK,IAKH,GAAIiB,IAAMuE,WAAa,IAAMF,QAAS,CACpCN,IAAM,KAAOhF,EACbuD,UAAW,EACX,SAIF0B,UAAW,EACXK,SAAU,EACVN,IAAMhF,EACN,SAEF,QAEE2F,iBAEIpC,SAEFA,UAAW,GACF3D,WAAWI,IACA,MAANA,GAAasF,UAC3BN,IAAM,MAGRA,IAAMhF,EAQZ,GAAIsF,QAAS,CAKX,IAAIS,GAAKhF,QAAQqC,OAAOoC,WAAa,GACjCQ,GAAKxH,KAAKuE,MAAMgD,GAAIlB,UACxBG,GAAKA,GAAG5B,OAAO,EAAGmC,cAAgB,MAAQS,GAAG,GAC7Cf,SAAWA,UAAYe,GAAG,GAU5B,KAAON,GAAKP,iBAAiB5F,OAAO,CAClC,IAAIkE,KAAOuB,GAAGiB,MAAMP,GAAGI,QAAU,GAEjCrC,KAAOA,KAAKvF,QAAQ,uBAAwB,SAAUgI,EAAGC,GAAIC,IAY3D,OAXKA,KAEHA,GAAK,MASAD,GAAKA,GAAKC,GAAK,MAIxB,IAAI9E,EAAgB,MAAZoE,GAAGG,KAAepG,KACN,MAAZiG,GAAGG,KAAerG,MAClB,KAAOkG,GAAGG,KAElBZ,UAAW,EACXD,GAAKA,GAAGiB,MAAM,EAAGP,GAAGI,SACfxE,EAAI,MACJmC,KAIPkC,iBACIpC,WAEFyB,IAAM,QAKR,IAAIqB,iBAAkB,EACtB,OAAQrB,GAAGrD,OAAO,IAChB,IAAK,IACL,IAAK,IACL,IAAK,IAAK0E,iBAAkB,EAW9B,GALW,KAAPrB,IAAaC,WAAUD,GAAK,QAAUA,IAEtCqB,kBAAiBrB,GAAKS,aAAeT,IAGrCF,QAAUD,SACZ,MAAO,CAAEG,GAAIC,UAMf,IAAKA,SACH,OAAOqB,aAAavF,SAGtB,IAAIwF,MAAQvF,QAAQkE,OAAS,IAAM,GAC/BsB,OAAS,IAAIC,OAAO,IAAMzB,GAAK,IAAKuB,OAKxC,OAHAC,OAAOE,MAAQ3F,QACfyF,OAAOG,KAAO3B,GAEPwB,OAQT,SAASI,SACP,GAAIpI,KAAKwD,SAA0B,IAAhBxD,KAAKwD,OAAkB,OAAOxD,KAAKwD,OAQtD,IAAIvD,IAAMD,KAAKC,IAEf,IAAKA,IAAIV,OAAQ,OAAOS,KAAKwD,QAAS,EACtC,IAAIhB,QAAUxC,KAAKwC,QAEf6F,QAAU7F,QAAQ+D,WAAatF,KAC7BuB,QAAQnD,IAAM6B,WACdC,aACF4G,MAAQvF,QAAQkE,OAAS,IAAM,GAE/BF,GAAKvG,IAAIoE,IAAI,SAAU9B,SACzB,OAAOA,QAAQ8B,IAAI,SAAUnC,GAC3B,OAAQA,IAAM5B,SAAY+H,QACL,iBAANnG,EAAkBoG,aAAapG,GACvCA,EAAEiG,OACR9E,KAAK,SACPA,KAAK,KAIRmD,GAAK,OAASA,GAAK,KAGfxG,KAAKyD,SAAQ+C,GAAK,OAASA,GAAK,QAEpC,IACE,OAAOxG,KAAKwD,OAAS,IAAIyE,OAAOzB,GAAIuB,OACpC,MAAOQ,IACP,OAAOvI,KAAKwD,QAAS,GAgBzB,SAASrB,MAAOvB,EAAG4H,SAIjB,GAAIxI,KAAK0D,QAAS,OAAO,EACzB,GAAI1D,KAAK2D,MAAO,MAAa,KAAN/C,EAEvB,GAAU,MAANA,GAAa4H,QAAS,OAAO,EAEjC,IAAIhG,QAAUxC,KAAKwC,QAIF,UAAbxD,WACF4B,EAAIA,EAAEE,MAAM,MAAMuC,KAAK,MAIzBzC,EAAIA,EAAEE,MAAMW,YACRe,QAAQyB,OACVC,QAAQC,MAAMnE,KAAKuC,QAAS,QAAS3B,GAWvC,IAHA,IAAIX,IAAMD,KAAKC,IAGNwC,EAAI,EAAGkC,EAAI1E,IAAIV,OAAQkD,EAAIkC,EAAGlC,IAAM,CAC3C,IAAIF,QAAUtC,IAAIwC,GACdgG,IACJ,GADUzI,KAAK0I,SAAS9H,EAAG2B,QAASiG,SAElC,QAAIhG,QAAQmG,aACJ3I,KAAKyD,OAMjB,OAAIjB,QAAQmG,YACL3I,KAAKyD,OAgMd,SAASqE,aAAcxG,GACrB,OAAOA,EAAE5B,QAAQ,SAAU,MAI7B,SAAS4I,aAAchH,GACrB,OAAOA,EAAE5B,QAAQ,2BAA4B,QA3S/CD,UAAU2I,OAAS,SAAU7F,QAASC,SACpC,OAAO,IAAI7C,UAAU4C,QAASC,SAAW,IAAI4F,UAG/CzI,UAAUoC,UAAUqG,OAASA,OA0C7B3I,UAAU0C,MAAQ,SAAUO,KAAMH,QAASC,SACzC,IAAIoG,GAAK,IAAIjJ,UAAU4C,QAASC,SAOhC,OANAE,KAAOA,KAAKJ,OAAO,SAAU1B,GAC3B,OAAOgI,GAAGzG,MAAMvB,KAEd4B,QAAQqG,SAAWnG,KAAKnD,QAC1BmD,KAAK+C,KAAKlD,SAELG,MAGT/C,UAAUoC,UAAUI,MAAQA,MAoD5BxC,UAAUoC,UAAU2G,SAAW,SAAUI,KAAMvG,QAASiG,SACtD,IAAIhG,QAAUxC,KAAKwC,QA6KbuG,aA3KFvG,QAAQyB,OACVC,QAAQC,MAAM,WACA,CAAEnE,KAAQA,KACR8I,KAAMA,KACNvG,QAASA,UAGvBC,QAAQhD,WAAgC,IAAnB+C,QAAQhD,SAC/BuJ,KAAOnI,cAAcmI,KAAKzF,KAAK,MAAMvC,MAAM,MAGzC0B,QAAQyB,OACVC,QAAQC,MAAM,WAAY2E,KAAKvJ,OAAQgD,QAAQhD,QAGjD,IAAM,IAAIyJ,GAAK,EACLC,GAAK,EACLC,GAAKJ,KAAKvJ,OACV2H,GAAK3E,QAAQhD,OAChByJ,GAAKE,IAAQD,GAAK/B,GACnB8B,KAAOC,KAAQ,CAEfzG,QAAQyB,OACVC,QAAQC,MAAM,iBAEhB,IAAIjC,EAAIK,QAAQ0G,IACZrI,EAAIkI,KAAKE,IAmGTP,IA3FJ,GANIjG,QAAQyB,OACVC,QAAQC,MAAM5B,QAASL,EAAGtB,IAKlB,IAANsB,EAAa,OAAO,EAExB,GAAIA,IAAM5B,SAAU,CACdkC,QAAQyB,OACVC,QAAQC,MAAM,WAAY,CAAC5B,QAASL,EAAGtB,IAwBzC,IAAIuI,GAAKH,GACLI,GAAKH,GAAK,EACd,GAAIG,KAAOlC,GAAI,CASb,IARI1E,QAAQyB,OACVC,QAAQC,MAAM,iBAOR6E,GAAKE,GAAIF,KACf,GAAiB,MAAbF,KAAKE,KAA4B,OAAbF,KAAKE,MACvBxG,QAAQnD,KAA8B,MAAvByJ,KAAKE,IAAI7F,OAAO,GAAa,OAAO,EAE3D,OAAO,EAITkG,MAAO,KAAOF,GAAKD,IAAI,CACrB,IAAII,UAAYR,KAAKK,IAQrB,GANI3G,QAAQyB,OACVC,QAAQC,MAAM,mBACA2E,KAAMK,GAAI5G,QAAS6G,GAAIE,WAInCtJ,KAAK0I,SAASI,KAAKrB,MAAM0B,IAAK5G,QAAQkF,MAAM2B,IAAKZ,SAInD,OAHIhG,QAAQyB,OACVC,QAAQC,MAAM,wBAAyBgF,GAAID,GAAII,YAE1C,EAIP,GAAkB,MAAdA,WAAmC,OAAdA,YACnB9G,QAAQnD,KAA+B,MAAxBiK,UAAUnG,OAAO,GAAa,CAC7CX,QAAQyB,OACVC,QAAQC,MAAM,gBAAiB2E,KAAMK,GAAI5G,QAAS6G,IACpD,MAAMC,MAIJ7G,QAAQyB,OACVC,QAAQC,MAAM,4CAChBgF,KAMJ,SAAIX,SAGEW,KAAOD,IAyBf,GAhBiB,iBAANhH,GAEPuG,IADEjG,QAAQkE,OACJ9F,EAAE2I,gBAAkBrH,EAAEqH,cAEtB3I,IAAMsB,EAEVM,QAAQyB,OACVC,QAAQC,MAAM,eAAgBjC,EAAGtB,EAAG6H,OAGtCA,IAAM7H,EAAEuB,MAAMD,GACVM,QAAQyB,OACVC,QAAQC,MAAM,gBAAiBjC,EAAGtB,EAAG6H,OAIpCA,IAAK,OAAO,EAenB,GAAIO,KAAOE,IAAMD,KAAO/B,GAGtB,OAAO,EACF,GAAI8B,KAAOE,GAIhB,OAAOV,QACF,GAAIS,KAAO/B,GAMhB,OADoB8B,KAAOE,GAAK,GAAoB,KAAbJ,KAAKE,IAK9C,MAAM,IAAInE,MAAM","sourcesContent":["// This is a slightly modified version of the minimatch library\n// https://github.com/isaacs/minimatch\n// (MIT-licensed, Copyright 2009-2011 Isaac Z. Schlueter)\n//\n// It has been modified to work properly with RequireJS and\n// to export an fnmatch function adapted from the EditorConfig project:\n// https://github.com/editorconfig/editorconfig-core-js/\n// (MIT-licensed, Copyright 2012 EditorConfig Team)\n\n\ndefine(function (r, exports, module, platform) {\n\nmodule.exports = fnmatch;\nminimatch.Minimatch = Minimatch;\n    \nfunction fnmatch(filepath, glob) {\n  var matchOptions = {dot: true, noext: true};\n  \n  // brackets #7374: don't try to match base if a directory name is passed in\n  if (filepath[filepath.length - 1] !== \"/\") {\n    matchOptions.matchBase = true;\n  }\n  \n  glob = glob.replace(/\\*\\*/g, '{*,**/**/**}');\n  return minimatch(filepath, glob, matchOptions);\n};\n\nvar LRU = function LRUCache () {\n        // not quite an LRU, but still space-limited.\n        var cache = {}\n        var cnt = 0\n        this.set = function (k, v) {\n          cnt ++\n          if (cnt >= 100) cache = {}\n          cache[k] = v\n        }\n        this.get = function (k) { return cache[k] }\n      }\n  , cache = minimatch.cache = new LRU({max: 100})\n  , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\n  , sigmund = function sigmund (obj) {\n        return JSON.stringify(obj)\n      };\n\nvar path = { basename: function (f) {\n        f = f.split(/[\\/\\\\]/)\n        var e = f.pop()\n        if (!e) e = f.pop()\n        return e\n      }}\n  // any single thing other than /\n  // don't need to escape / when using new RegExp()\n  , qmark = \"[^/]\"\n\n  // * => any number of characters\n  , star = qmark + \"*?\"\n\n  // ** when dots are allowed.  Anything goes, except .. and .\n  // not (^ or / followed by one or two dots followed by $ or /),\n  // followed by anything, any number of times.\n  , twoStarDot = \"(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?\"\n\n  // not a ^ or / followed by a dot,\n  // followed by anything, any number of times.\n  , twoStarNoDot = \"(?:(?!(?:\\\\\\/|^)\\\\.).)*?\"\n\n  // characters that need to be escaped in RegExp.\n  , reSpecials = charSet(\"().*{}+?[]^$\\\\!\")\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split(\"\").reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.monkeyPatch = monkeyPatch\nfunction monkeyPatch () {\n  var desc = Object.getOwnPropertyDescriptor(String.prototype, \"match\")\n  var orig = desc.value\n  desc.value = function (p) {\n    if (p instanceof Minimatch) return p.match(this)\n    return orig.call(this, p)\n  }\n  Object.defineProperty(String.prototype, desc)\n}\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== \"string\") {\n    throw new TypeError(\"glob pattern string required\")\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === \"#\") {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === \"\") return p === \"\"\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options, cache)\n  }\n\n  if (typeof pattern !== \"string\") {\n    throw new TypeError(\"glob pattern string required\")\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows: need to use /, not \\\n  // On other platforms, \\ is a valid (albeit bad) filename char.\n  if (platform === \"win32\") {\n    pattern = pattern.split(\"\\\\\").join(\"/\")\n  }\n\n  // lru storage.\n  // these things aren't particularly big, but walking down the string\n  // and turning it into a regexp can get pretty costly.\n  var cacheKey = pattern + \"\\n\" + sigmund(options)\n  var cached = minimatch.cache.get(cacheKey)\n  if (cached) return cached\n  minimatch.cache.set(cacheKey, this)\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === \"#\") {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) console.error(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  if (options.debug) console.error(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  if (options.debug) console.error(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return -1 === s.indexOf(false)\n  })\n\n  if (options.debug) console.error(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n    , negate = false\n    , options = this.options\n    , negateOffset = 0\n\n  if (options.nonegate) return\n\n  for ( var i = 0, l = pattern.length\n      ; i < l && pattern.charAt(i) === \"!\"\n      ; i ++) {\n    negate = !negate\n    negateOffset ++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return new Minimatch(pattern, options).braceExpand()\n}\n\nMinimatch.prototype.braceExpand = braceExpand\nfunction braceExpand (pattern, options) {\n  options = options || this.options\n  pattern = typeof pattern === \"undefined\"\n    ? this.pattern : pattern\n\n  if (typeof pattern === \"undefined\") {\n    throw new Error(\"undefined pattern\")\n  }\n\n  if (options.nobrace ||\n      !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  var escaping = false\n\n  // examples and comments refer to this crazy pattern:\n  // a{b,c{d,e},{f,g}h}x{y,z}\n  // expected:\n  // abxy\n  // abxz\n  // acdxy\n  // acdxz\n  // acexy\n  // acexz\n  // afhxy\n  // afhxz\n  // aghxy\n  // aghxz\n\n  // everything before the first \\{ is just a prefix.\n  // So, we pluck that off, and work with the rest,\n  // and then prepend it to everything we find.\n  if (pattern.charAt(0) !== \"{\") {\n    // console.error(pattern)\n    var prefix = null\n    for (var i = 0, l = pattern.length; i < l; i ++) {\n      var c = pattern.charAt(i)\n      // console.error(i, c)\n      if (c === \"\\\\\") {\n        escaping = !escaping\n      } else if (c === \"{\" && !escaping) {\n        prefix = pattern.substr(0, i)\n        break\n      }\n    }\n\n    // actually no sets, all { were escaped.\n    if (prefix === null) {\n      // console.error(\"no sets\")\n      return [pattern]\n    }\n\n    var tail = braceExpand(pattern.substr(i), options)\n    return tail.map(function (t) {\n      return prefix + t\n    })\n  }\n\n  // now we have something like:\n  // {b,c{d,e},{f,g}h}x{y,z}\n  // walk through the set, expanding each part, until\n  // the set ends.  then, we'll expand the suffix.\n  // If the set only has a single member, then'll put the {} back\n\n  // first, handle numeric sets, since they're easier\n  var numset = pattern.match(/^\\{(-?[0-9]+)\\.\\.(-?[0-9]+)\\}/)\n  if (numset) {\n    // console.error(\"numset\", numset[1], numset[2])\n    var suf = braceExpand(pattern.substr(numset[0].length), options)\n      , start = +numset[1]\n      , end = +numset[2]\n      , inc = start > end ? -1 : 1\n      , set = []\n    for (var i = start; i != (end + inc); i += inc) {\n      // append all the suffixes\n      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n        set.push(i + suf[ii])\n      }\n    }\n    return set\n  }\n\n  // ok, walk through the set\n  // We hope, somewhat optimistically, that there\n  // will be a } at the end.\n  // If the closing brace isn't found, then the pattern is\n  // interpreted as braceExpand(\"\\\\\" + pattern) so that\n  // the leading \\{ will be interpreted literally.\n  var i = 1 // skip the \\{\n    , depth = 1\n    , set = []\n    , member = \"\"\n    , sawEnd = false\n    , escaping = false\n\n  function addMember () {\n    set.push(member)\n    member = \"\"\n  }\n\n  // console.error(\"Entering for\")\n  FOR: for (i = 1, l = pattern.length; i < l; i ++) {\n    var c = pattern.charAt(i)\n    // console.error(\"\", i, c)\n\n    if (escaping) {\n      escaping = false\n      member += \"\\\\\" + c\n    } else {\n      switch (c) {\n        case \"\\\\\":\n          escaping = true\n          continue\n\n        case \"{\":\n          depth ++\n          member += \"{\"\n          continue\n\n        case \"}\":\n          depth --\n          // if this closes the actual set, then we're done\n          if (depth === 0) {\n            addMember()\n            // pluck off the close-brace\n            i ++\n            break FOR\n          } else {\n            member += c\n            continue\n          }\n\n        case \",\":\n          if (depth === 1) {\n            addMember()\n          } else {\n            member += c\n          }\n          continue\n\n        default:\n          member += c\n          continue\n      } // switch\n    } // else\n  } // for\n\n  // now we've either finished the set, and the suffix is\n  // pattern.substr(i), or we have *not* closed the set,\n  // and need to escape the leading brace\n  if (depth !== 0) {\n    // console.error(\"didn't close\", pattern)\n    return braceExpand(\"\\\\\" + pattern, options)\n  }\n\n  // x{y,z} -> [\"xy\", \"xz\"]\n  // console.error(\"set\", set)\n  // console.error(\"suffix\", pattern.substr(i))\n  var suf = braceExpand(pattern.substr(i), options)\n  // [\"b\", \"c{d,e}\",\"{f,g}h\"] ->\n  //   [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]]\n  var addBraces = set.length === 1\n  // console.error(\"set pre-expanded\", set)\n  set = set.map(function (p) {\n    return braceExpand(p, options)\n  })\n  // console.error(\"set expanded\", set)\n\n\n  // [[\"b\"], [\"cd\", \"ce\"], [\"fh\", \"gh\"]] ->\n  //   [\"b\", \"cd\", \"ce\", \"fh\", \"gh\"]\n  set = set.reduce(function (l, r) {\n    return l.concat(r)\n  })\n\n  if (addBraces) {\n    set = set.map(function (s) {\n      return \"{\" + s + \"}\"\n    })\n  }\n\n  // now attach the suffixes.\n  var ret = []\n  for (var i = 0, l = set.length; i < l; i ++) {\n    for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\n      ret.push(set[i] + suf[ii])\n    }\n  }\n  return ret\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === \"**\") return GLOBSTAR\n  if (pattern === \"\") return \"\"\n\n  var re = \"\"\n    , hasMagic = !!options.nocase\n    , escaping = false\n    // ? => one single character\n    , patternListStack = []\n    , plType\n    , stateChar\n    , inClass = false\n    , reClassStart = -1\n    , classStart = -1\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.\n    , patternStart = pattern.charAt(0) === \".\" ? \"\" // anything\n      // not (start or / followed by . or .. followed by / or end)\n      : options.dot ? \"(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))\"\n      : \"(?!\\\\.)\"\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case \"*\":\n          re += star\n          hasMagic = true\n          break\n        case \"?\":\n          re += qmark\n          hasMagic = true\n          break\n        default:\n          re += \"\\\\\"+stateChar\n          break\n      }\n      stateChar = false\n    }\n  }\n\n  for ( var i = 0, len = pattern.length, c\n      ; (i < len) && (c = pattern.charAt(i))\n      ; i ++ ) {\n\n    if (options.debug) {\n      console.error(\"%s\\t%s %s %j\", pattern, i, re, c)\n    }\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += \"\\\\\" + c\n      escaping = false\n      continue\n    }\n\n    SWITCH: switch (c) {\n      case \"/\":\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case \"\\\\\":\n        clearStateChar()\n        escaping = true\n        continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case \"?\":\n      case \"*\":\n      case \"+\":\n      case \"@\":\n      case \"!\":\n        if (options.debug) {\n          console.error(\"%s\\t%s %s %j <-- stateChar\", pattern, i, re, c)\n        }\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          if (c === \"!\" && i === classStart + 1) c = \"^\"\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n        continue\n\n      case \"(\":\n        if (inClass) {\n          re += \"(\"\n          continue\n        }\n\n        if (!stateChar) {\n          re += \"\\\\(\"\n          continue\n        }\n\n        plType = stateChar\n        patternListStack.push({ type: plType\n                              , start: i - 1\n                              , reStart: re.length })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === \"!\" ? \"(?:(?!\" : \"(?:\"\n        stateChar = false\n        continue\n\n      case \")\":\n        if (inClass || !patternListStack.length) {\n          re += \"\\\\)\"\n          continue\n        }\n\n        hasMagic = true\n        re += \")\"\n        plType = patternListStack.pop().type\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        switch (plType) {\n          case \"!\":\n            re += \"[^/]*?)\"\n            break\n          case \"?\":\n          case \"+\":\n          case \"*\": re += plType\n          case \"@\": break // the default anyway\n        }\n        continue\n\n      case \"|\":\n        if (inClass || !patternListStack.length || escaping) {\n          re += \"\\\\|\"\n          escaping = false\n          continue\n        }\n\n        re += \"|\"\n        continue\n\n      // these are mostly the same in regexp and glob\n      case \"[\":\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += \"\\\\\" + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n        continue\n\n      case \"]\":\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += \"\\\\\" + c\n          escaping = false\n          continue\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n        continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n                   && !(c === \"^\" && inClass)) {\n          re += \"\\\\\"\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    var cs = pattern.substr(classStart + 1)\n      , sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  var pl\n  while (pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + 3)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2})*)(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = \"\\\\\"\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + \"|\"\n    })\n\n    // console.error(\"tail=%j\\n   %s\", tail, tail)\n    var t = pl.type === \"*\" ? star\n          : pl.type === \"?\" ? qmark\n          : \"\\\\\" + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart)\n       + t + \"\\\\(\"\n       + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += \"\\\\\\\\\"\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case \".\":\n    case \"[\":\n    case \"(\": addPatternStart = true\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== \"\" && hasMagic) re = \"(?=.)\" + re\n\n  if (addPatternStart) re = patternStart + re\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [ re, hasMagic ]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? \"i\" : \"\"\n    , regExp = new RegExp(\"^\" + re + \"$\", flags)\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) return this.regexp = false\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n      : options.dot ? twoStarDot\n      : twoStarNoDot\n    , flags = options.nocase ? \"i\" : \"\"\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n           : (typeof p === \"string\") ? regExpEscape(p)\n           : p._src\n    }).join(\"\\\\\\/\")\n  }).join(\"|\")\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = \"^(?:\" + re + \")$\"\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = \"^(?!\" + re + \").*$\"\n\n  try {\n    return this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    return this.regexp = false\n  }\n}\n\nminimatch.match = function (list, pattern, options) {\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  // console.error(\"match\", f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === \"\"\n\n  if (f === \"/\" && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  // On other platforms, \\ is a valid (albeit bad) filename char.\n  if (platform === \"win32\") {\n    f = f.split(\"\\\\\").join(\"/\")\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  if (options.debug) {\n    console.error(this.pattern, \"split\", f)\n  }\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  // console.error(this.pattern, \"set\", set)\n\n  for (var i = 0, l = set.length; i < l; i ++) {\n    var pattern = set[i]\n    var hit = this.matchOne(f, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  if (options.debug) {\n    console.error(\"matchOne\",\n                  { \"this\": this\n                  , file: file\n                  , pattern: pattern })\n  }\n\n  if (options.matchBase && pattern.length === 1) {\n    file = path.basename(file.join(\"/\")).split(\"/\")\n  }\n\n  if (options.debug) {\n    console.error(\"matchOne\", file.length, pattern.length)\n  }\n\n  for ( var fi = 0\n          , pi = 0\n          , fl = file.length\n          , pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi ++, pi ++ ) {\n\n    if (options.debug) {\n      console.error(\"matchOne loop\")\n    }\n    var p = pattern[pi]\n      , f = file[fi]\n\n    if (options.debug) {\n      console.error(pattern, p, f)\n    }\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      if (options.debug)\n        console.error('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n        , pr = pi + 1\n      if (pr === pl) {\n        if (options.debug)\n          console.error('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for ( ; fi < fl; fi ++) {\n          if (file[fi] === \".\" || file[fi] === \"..\" ||\n              (!options.dot && file[fi].charAt(0) === \".\")) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      WHILE: while (fr < fl) {\n        var swallowee = file[fr]\n\n        if (options.debug) {\n          console.error('\\nglobstar while',\n                        file, fr, pattern, pr, swallowee)\n        }\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          if (options.debug)\n            console.error('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === \".\" || swallowee === \"..\" ||\n              (!options.dot && swallowee.charAt(0) === \".\")) {\n            if (options.debug)\n              console.error(\"dot detected!\", file, fr, pattern, pr)\n            break WHILE\n          }\n\n          // ** swallows a segment, and continue.\n          if (options.debug)\n            console.error('globstar swallow a segment, and continue')\n          fr ++\n        }\n      }\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then \n      if (partial) {\n        // ran out of file\n        // console.error(\"\\n>>> no match, partial?\", file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === \"string\") {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      if (options.debug) {\n        console.error(\"string match\", p, f, hit)\n      }\n    } else {\n      hit = f.match(p)\n      if (options.debug) {\n        console.error(\"pattern match\", p, f, hit)\n      }\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === \"\")\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error(\"wtf?\")\n}\n\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, \"$1\")\n}\n\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\")\n}\n\n});"],"file":"globmatch.js"}
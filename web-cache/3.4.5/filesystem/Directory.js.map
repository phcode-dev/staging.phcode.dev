{"version":3,"sources":["filesystem/Directory.js"],"names":["define","require","exports","module","FileSystemEntry","Directory","fullPath","fileSystem","this","_isDirectory","call","_applyAllCallbacks","callbacks","args","length","callback","pop","apply","undefined","prototype","Object","create","constructor","parentClass","_contents","_contentsStats","_contentsStatsErrors","_clearCachedData","preserveImmediateChildren","forEach","child","dirPath","_fileSystem","_index","visitAll","entry","parentPath","isEmptyAsync","that","Promise","resolve","reject","getContents","err","contents","unlinkEmptyDirectoryAsync","async","entries","getContentsAsync","isEmpty","isDirectory","unlinkAsync","contentStats","contentsStatsErrors","_contentsCallbacks","push","_impl","readdir","names","stats","contentsStats","watched","_isWatched","name","index","entryPath","entryStats","_indexFilter","isFile","getFileForPath","getDirectoryForPath","_stat","currentCallbacks","callbackArgs","bind","createAsync","stat","_beginChange","mkdir","_path","_endChange","parent","_handleDirectoryChange","added","removed","_fireChangeEvent"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var FileSystemEntry = require(\"filesystem/FileSystemEntry\");\n\n    /*\n     * Model for a file system Directory.\n     *\n     * This class should *not* be instantiated directly. Use FileSystem.getDirectoryForPath,\n     * FileSystem.resolve, or Directory.getContents to create an instance of this class.\n     *\n     * Note: Directory.fullPath always has a trailing slash.\n     *\n     * See the FileSystem class for more details.\n     *\n     * @constructor\n     * @param {!string} fullPath The full path for this Directory.\n     * @param {!FileSystem} fileSystem The file system associated with this Directory.\n     */\n    function Directory(fullPath, fileSystem) {\n        this._isDirectory = true;\n        FileSystemEntry.call(this, fullPath, fileSystem);\n    }\n\n    Directory.prototype = Object.create(FileSystemEntry.prototype);\n    Directory.prototype.constructor = Directory;\n    Directory.prototype.parentClass = FileSystemEntry.prototype;\n\n    /**\n     * The contents of this directory. This \"private\" property is used by FileSystem.\n     * @type {Array<FileSystemEntry>}\n     */\n    Directory.prototype._contents = null;\n\n    /**\n     * The stats for the contents of this directory, such that this._contentsStats[i]\n     * corresponds to this._contents[i].\n     * @type {Array.<FileSystemStats>}\n     */\n    Directory.prototype._contentsStats = null;\n\n    /**\n     * The stats errors for the contents of this directory.\n     * @type {object.<string: string>} fullPaths are mapped to FileSystemError strings\n     */\n    Directory.prototype._contentsStatsErrors = null;\n\n    /**\n     * Clear any cached data for this directory. By default, we clear the contents\n     * of immediate children as well, because in some cases file watchers fail\n     * provide precise change notifications. (Sometimes, like after a \"git\n     * checkout\", they just report that some directory has changed when in fact\n     * many of the file within the directory have changed.\n     *\n     * @private\n     * @param {boolean=} preserveImmediateChildren\n     */\n    Directory.prototype._clearCachedData = function (preserveImmediateChildren) {\n        FileSystemEntry.prototype._clearCachedData.apply(this);\n\n        if (!preserveImmediateChildren) {\n            if (this._contents) {\n                this._contents.forEach(function (child) {\n                    child._clearCachedData(true);\n                });\n            } else {\n                // No cached _contents, but child entries may still exist.\n                // Scan the full index to catch all of them.\n                var dirPath = this.fullPath;\n                this._fileSystem._index.visitAll(function (entry) {\n                    if (entry.parentPath === dirPath) {\n                        entry._clearCachedData(true);\n                    }\n                });\n            }\n        }\n\n        this._contents = undefined;\n        this._contentsStats = undefined;\n        this._contentsStatsErrors = undefined;\n    };\n\n    /**\n     * Apply each callback in a list to the provided arguments. Callbacks\n     * can throw without preventing other callbacks from being applied.\n     *\n     * @private\n     * @param {Array.<function>} callbacks The callbacks to apply\n     * @param {Array} args The arguments to which each callback is applied\n     */\n    function _applyAllCallbacks(callbacks, args) {\n        if (callbacks.length > 0) {\n            var callback = callbacks.pop();\n            try {\n                callback.apply(undefined, args);\n            } finally {\n                _applyAllCallbacks(callbacks, args);\n            }\n        }\n    }\n\n    /**\n     * Returns true if is a directory exists and is empty.\n     *\n     * @return {Promise<boolean>} True if directory is empty and it exists, else false.\n     */\n    Directory.prototype.isEmptyAsync = function () {\n        let that = this;\n        return new Promise((resolve, reject)=>{\n            that.getContents((err, contents) =>{\n                if(err){\n                    reject(err);\n                    return;\n                }\n                resolve(contents.length === 0);\n            });\n        });\n    };\n\n    /**\n     * Recursively deletes all empty subdirectories within the current directory. If all subdirectories are empty,\n     * the current directory itself will be deleted.\n     * A directory is considered empty if it doesn't contain any files in its subtree.\n     *\n     * If a subtree contains a large number of nested subdirectories and no files, the whole tree will be deleted.\n     * Only branches that contain a file will be retained.\n     *\n     * @returns {Promise<void>} A Promise that resolves when the operation is finished\n     * @throws {FileSystemError} If an error occurs while accessing the filesystem\n     *\n     * @example\n     *\n     * await dir.unlinkEmptyDirectoryAsync();\n     */\n    Directory.prototype.unlinkEmptyDirectoryAsync = async function () {\n        let that = this;\n        let {entries} = await that.getContentsAsync();\n        for(let entry of entries){\n            if(entry.isDirectory) {\n                await entry.unlinkEmptyDirectoryAsync();\n            }\n        }\n        let isEmpty = await that.isEmptyAsync();\n        if(isEmpty){\n            await that.unlinkAsync();\n        }\n    };\n\n    /**\n     * Read the contents of a Directory, returns a promise. If this Directory is under a watch root,\n     * the listing will exclude any items filtered out by the watch root's filter\n     * function.\n     *\n     * @return {Promise<{entries: FileSystemEntry, contentStats: FileSystemStats, contentsStatsErrors}>} An object\n     * with attributes - entries(an array of file system entries), contentStats and contentsStatsErrors(a map from\n     * content name to error if there is any).\n     */\n    Directory.prototype.getContentsAsync = function () {\n        let that = this;\n        return new Promise((resolve, reject)=>{\n            that.getContents((err, contents, contentStats, contentsStatsErrors) =>{\n                if(err){\n                    reject(err);\n                    return;\n                }\n                resolve({entries: contents, contentStats, contentsStatsErrors});\n            });\n        });\n    };\n\n    /**\n     * Read the contents of a Directory. If this Directory is under a watch root,\n     * the listing will exclude any items filtered out by the watch root's filter\n     * function.\n     *\n     * @param {function (?string, Array.<FileSystemEntry>=, Array.<FileSystemStats>=, Object.<string, string>=)} callback\n     *          Callback that is passed an error code or the stat-able contents\n     *          of the directory along with the stats for these entries and a\n     *          fullPath-to-FileSystemError string map of unstat-able entries\n     *          and their stat errors. If there are no stat errors then the last\n     *          parameter shall remain undefined.\n     */\n    Directory.prototype.getContents = function (callback) {\n        if (this._contentsCallbacks) {\n            // There is already a pending call for this directory's contents.\n            // Push the new callback onto the stack and return.\n            this._contentsCallbacks.push(callback);\n            return;\n        }\n\n        // Return cached contents if the directory is watched\n        if (this._contents) {\n            callback(null, this._contents, this._contentsStats, this._contentsStatsErrors);\n            return;\n        }\n\n        this._contentsCallbacks = [callback];\n\n        this._impl.readdir(this.fullPath, function (err, names, stats) {\n            var contents = [],\n                contentsStats = [],\n                contentsStatsErrors;\n\n            if (err) {\n                this._clearCachedData();\n            } else {\n                // Use the \"relaxed\" parameter to _isWatched because it's OK to\n                // cache data even while watchers are still starting up\n                var watched = this._isWatched(true);\n\n                names.forEach(function (name, index) {\n                    var entryPath = this.fullPath + name;\n\n                    var entryStats = stats[index];\n                    if (this._fileSystem._indexFilter(entryPath, name, entryStats)) {\n                        var entry;\n\n                        // Note: not all entries necessarily have associated stats.\n                        if (typeof entryStats === \"string\") {\n                            // entryStats is an error string\n                            if (contentsStatsErrors === undefined) {\n                                contentsStatsErrors = {};\n                            }\n                            contentsStatsErrors[entryPath] = entryStats;\n                        } else {\n                            // entryStats is a FileSystemStats object\n                            if (entryStats.isFile) {\n                                entry = this._fileSystem.getFileForPath(entryPath);\n                            } else {\n                                entry = this._fileSystem.getDirectoryForPath(entryPath);\n                            }\n\n                            if (watched) {\n                                entry._stat = entryStats;\n                            }\n\n                            contents.push(entry);\n                            contentsStats.push(entryStats);\n                        }\n                    }\n                }, this);\n\n                if (watched) {\n                    this._contents = contents;\n                    this._contentsStats = contentsStats;\n                    this._contentsStatsErrors = contentsStatsErrors;\n                }\n            }\n\n            // Reset the callback list before we begin calling back so that\n            // synchronous reentrant calls are handled correctly.\n            var currentCallbacks = this._contentsCallbacks;\n\n            this._contentsCallbacks = null;\n\n            // Invoke all saved callbacks\n            var callbackArgs = [err, contents, contentsStats, contentsStatsErrors];\n            _applyAllCallbacks(currentCallbacks, callbackArgs);\n        }.bind(this));\n    };\n\n    /**\n     * Create a directory and returns a promise that will resolve to a stat\n     *\n     * @return {Promise<FileSystemStats>} resolves to the stats of the newly created dir.\n     */\n    Directory.prototype.createAsync = function () {\n        let that = this;\n        return new Promise((resolve, reject)=>{\n            that.create((err, stat)=>{\n                if(err){\n                    reject(err);\n                    return;\n                }\n                resolve(stat);\n            });\n        });\n    };\n\n    /**\n     * Create a directory\n     *\n     * @param {function (?string, FileSystemStats=)=} callback Callback resolved with a\n     *      FileSystemError string or the stat object for the created directory.\n     */\n    Directory.prototype.create = function (callback) {\n        callback = callback || function () {};\n\n        // Block external change events until after the write has finished\n        this._fileSystem._beginChange();\n\n        this._impl.mkdir(this._path, function (err, stat) {\n            if (err) {\n                this._clearCachedData();\n                try {\n                    callback(err);\n                    return;\n                } finally {\n                    // Unblock external change events\n                    this._fileSystem._endChange();\n                }\n            }\n\n            var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\n\n            // Update internal filesystem state\n            if (this._isWatched()) {\n                this._stat = stat;\n            }\n\n            this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\n                try {\n                    callback(null, stat);\n                } finally {\n                    if (parent._isWatched()) {\n                        this._fileSystem._fireChangeEvent(parent, added, removed);\n                    }\n                    // Unblock external change events\n                    this._fileSystem._endChange();\n                }\n            }.bind(this));\n        }.bind(this));\n    };\n\n    // Export this class\n    module.exports = Directory;\n});\n"],"file":"Directory.js"}
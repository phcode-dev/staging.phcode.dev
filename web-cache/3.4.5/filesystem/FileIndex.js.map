{"version":3,"sources":["filesystem/FileIndex.js"],"names":["define","require","exports","module","FileUtils","FileIndex","this","_index","_doNotRemoveItems","prototype","clear","doNotRemoveFromIndex","filePath","visitAll","visitor","path","hasOwnProperty","addEntry","entry","fullPath","removeEntry","property","replaceMember","member","console","warn","apply","arguments","entryRenamed","oldPath","newPath","isDirectory","renameMap","oldParentPath","getParentPath","newParentPath","indexOf","substr","length","item","assert","_setPath","oldDirectory","newDirectory","renamedEntry","_contents","filter","push","getEntry"],"mappings":"AA0BAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,UAAYH,QAAQ,kBAKxB,SAASI,YACLC,KAAKC,OAAS,GACdD,KAAKE,kBAAoB,GAQ7BH,UAAUI,UAAUF,OAAS,KAE7BF,UAAUI,UAAUD,kBAAoB,KAKxCH,UAAUI,UAAUC,MAAQ,WACxBJ,KAAKC,OAAS,GACdD,KAAKE,kBAAoB,IAM7BH,UAAUI,UAAUE,qBAAuB,SAAUC,UACjDN,KAAKE,kBAAkBI,WAAY,GAOvCP,UAAUI,UAAUI,SAAW,SAAUC,SACrC,IAAIC,KACJ,IAAKA,QAAQT,KAAKC,OACVD,KAAKC,OAAOS,eAAeD,OAC3BD,QAAQR,KAAKC,OAAOQ,MAAOA,OAUvCV,UAAUI,UAAUQ,SAAW,SAAUC,OACrCZ,KAAKC,OAAOW,MAAMC,UAAYD,OAQlCb,UAAUI,UAAUW,YAAc,SAAUF,OACxC,IAAIH,KAAOG,MAAMC,SACbE,SACJ,IAAGf,KAAKE,kBAAkBO,MAgB1B,IAAKM,mBAFEf,KAAKC,OAAOQ,MAEFG,MACTA,MAAMF,eAAeK,WACrBC,cAAcD,UAdtB,SAASC,cAAcD,UACnB,IAAIE,OAASL,MAAMG,UACG,mBAAXE,SACPL,MAAMG,UAAY,WAEd,OADAG,QAAQC,KAAK,wDAAyDV,MAC/DQ,OAAOG,MAAMR,MAAOS,eAsB3CtB,UAAUI,UAAUmB,aAAe,SAAUC,QAASC,QAASC,aAC3D,IAAIhB,KACAiB,UAAY,GACZC,cAAgB7B,UAAU8B,cAAcL,SACxCM,cAAgB/B,UAAU8B,cAAcJ,SAG5C,IAAKf,QAAQT,KAAKC,OACVD,KAAKC,OAAOS,eAAeD,QAKvBgB,YAAwC,IAA1BhB,KAAKqB,QAAQP,SAAiBd,OAASc,WACrDG,UAAUjB,MAAQe,QAAUf,KAAKsB,OAAOR,QAAQS,SAM5D,IAAKvB,QAAQiB,UACT,GAAIA,UAAUhB,eAAeD,MAAO,CAChC,IAAIwB,KAAOjC,KAAKC,OAAOQ,MAGvBS,QAAQgB,OAAOD,KAAKpB,WAAaJ,aAE1BT,KAAKC,OAAOQ,MACnBT,KAAKC,OAAOyB,UAAUjB,OAASwB,KAC/BA,KAAKE,SAAST,UAAUjB,OAOhC,GAAIkB,gBAAkBE,cAAe,CACjC,IAAIO,aAAepC,KAAKC,OAAO0B,eAC3BU,aAAerC,KAAKC,OAAO4B,eAC3BS,aAEAF,cAAgBA,aAAaG,YAC7BH,aAAaG,UAAYH,aAAaG,UAAUC,OAAO,SAAS5B,OAC5D,OAAIA,MAAMC,WAAaW,UACnBc,aAAe1B,OACR,MAMfyB,cAAgBA,aAAaE,WAAaD,eAC1CA,aAAaH,SAASX,SACtBa,aAAaE,UAAUE,KAAKH,iBAaxCvC,UAAUI,UAAUuC,SAAW,SAAUjC,MACrC,OAAOT,KAAKC,OAAOQ,OAIvBZ,OAAOD,QAAUG","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * FileIndex is an internal module used by FileSystem to maintain an index of all files and directories.\n *\n * This module is *only* used by FileSystem, and should not be called directly.\n */\ndefine(function (require, exports, module) {\n\n\n    var FileUtils = require(\"file/FileUtils\");\n\n    /**\n     * @constructor\n     */\n    function FileIndex() {\n        this._index = {};\n        this._doNotRemoveItems = {};\n    }\n\n    /**\n     * Master index\n     *\n     * @type {Object.<string, File|Directory>} Maps a fullPath to a File or Directory object\n     */\n    FileIndex.prototype._index = null;\n\n    FileIndex.prototype._doNotRemoveItems = null;\n\n    /**\n     * Clear the file index cache.\n     */\n    FileIndex.prototype.clear = function () {\n        this._index = {};\n        this._doNotRemoveItems = {};\n    };\n\n    /**\n     * Will prevent the file from being removed from index. However, it is reset when index is cleared.\n     */\n    FileIndex.prototype.doNotRemoveFromIndex = function (filePath) {\n        this._doNotRemoveItems[filePath] = true;\n    };\n\n    /**\n     * Visits every entry in the entire index; no stopping condition.\n     * @param {!function(FileSystemEntry, string):void} Called with an entry and its fullPath\n     */\n    FileIndex.prototype.visitAll = function (visitor) {\n        var path;\n        for (path in this._index) {\n            if (this._index.hasOwnProperty(path)) {\n                visitor(this._index[path], path);\n            }\n        }\n    };\n\n    /**\n     * Add an entry.\n     *\n     * @param {FileSystemEntry} entry The entry to add.\n     */\n    FileIndex.prototype.addEntry = function (entry) {\n        this._index[entry.fullPath] = entry;\n    };\n\n    /**\n     * Remove an entry.\n     *\n     * @param {FileSystemEntry} entry The entry to remove.\n     */\n    FileIndex.prototype.removeEntry = function (entry) {\n        var path = entry.fullPath,\n            property;\n        if(this._doNotRemoveItems[path]){\n            return;\n        }\n\n        function replaceMember(property) {\n            var member = entry[property];\n            if (typeof member === \"function\") {\n                entry[property] = function () {\n                    console.warn(\"FileSystemEntry used after being removed from index: \", path);\n                    return member.apply(entry, arguments);\n                };\n            }\n        }\n\n        delete this._index[path];\n\n        for (property in entry) {\n            if (entry.hasOwnProperty(property)) {\n                replaceMember(property);\n            }\n        }\n    };\n\n    /**\n     * Notify the index that an entry has been renamed. This updates\n     * all affected entries in the index.\n     *\n     * @param {string} oldPath\n     * @param {string} newPath\n     * @param {boolean} isDirectory\n     */\n    FileIndex.prototype.entryRenamed = function (oldPath, newPath, isDirectory) {\n        var path,\n            renameMap = {},\n            oldParentPath = FileUtils.getParentPath(oldPath),\n            newParentPath = FileUtils.getParentPath(newPath);\n\n        // Find all entries affected by the rename and put into a separate map.\n        for (path in this._index) {\n            if (this._index.hasOwnProperty(path)) {\n                // See if we have a match. For directories, see if the path\n                // starts with the old name. This is safe since paths always end\n                // with '/'. For files, see if there is an exact match between\n                // the path and the old name.\n                if (isDirectory ? path.indexOf(oldPath) === 0 : path === oldPath) {\n                    renameMap[path] = newPath + path.substr(oldPath.length);\n                }\n            }\n        }\n\n        // Do the rename.\n        for (path in renameMap) {\n            if (renameMap.hasOwnProperty(path)) {\n                var item = this._index[path];\n\n                // Sanity check to make sure the item and path still match\n                console.assert(item.fullPath === path);\n\n                delete this._index[path];\n                this._index[renameMap[path]] = item;\n                item._setPath(renameMap[path]);\n            }\n        }\n\n\n        // If file path is changed, i.e the file is moved\n        // Remove the moved entry from old Directory and add it to new Directory\n        if (oldParentPath !== newParentPath) {\n            var oldDirectory = this._index[oldParentPath],\n                newDirectory = this._index[newParentPath],\n                renamedEntry;\n\n            if (oldDirectory && oldDirectory._contents) {\n                oldDirectory._contents = oldDirectory._contents.filter(function(entry) {\n                    if (entry.fullPath === newPath) {\n                        renamedEntry = entry;\n                        return false;\n                    }\n                    return true;\n                });\n            }\n\n            if (newDirectory && newDirectory._contents && renamedEntry) {\n                renamedEntry._setPath(newPath);\n                newDirectory._contents.push(renamedEntry);\n            }\n        }\n    };\n\n    /**\n     * Returns the cached entry for the specified path, or undefined\n     * if the path has not been cached.\n     *\n     * @param {string} path The path of the entry to return.\n     * @return {File|Directory} The entry for the path, or undefined if it hasn't\n     *              been cached yet.\n     */\n    FileIndex.prototype.getEntry = function (path) {\n        return this._index[path];\n    };\n\n    // Export public API\n    module.exports = FileIndex;\n});\n"],"file":"FileIndex.js"}
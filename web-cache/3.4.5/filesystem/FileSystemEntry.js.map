{"version":3,"sources":["filesystem/FileSystemEntry.js"],"names":["define","require","exports","module","FileSystemError","WatchedRoot","VISIT_DEFAULT_MAX_DEPTH","VISIT_DEFAULT_MAX_ENTRIES","nextId","FileSystemEntry","path","fileSystem","this","_setPath","_fileSystem","_id","Object","defineProperties","prototype","fullPath","get","_path","set","Error","name","_name","parentPath","_parentPath","id","isFile","_isFile","isDirectory","_isDirectory","_impl","_stat","_watchedRoot","undefined","_watchedRootFilterResult","_isWatched","relaxed","watchedRoot","filterResult","_findWatchedRootForPath","parentEntry","entry","getDirectoryForPath","filter","status","ACTIVE","STARTING","_clearCachedData","newPath","parts","split","pop","length","join","indexOf","toString","exists","callback","err","bind","existsAsync","async","that","Promise","resolve","reject","stat","statAsync","rename","newFullPath","Phoenix","VFS","ensureTrailingSlash","_beginChange","oldFullPath","_handleRename","_fireRenameEvent","_endChange","unlinkAsync","unlink","parent","_handleDirectoryChange","added","removed","_fireChangeEvent","moveToTrash","_visitHelper","stats","visitedPaths","visitor","options","_currentDepth","self","maxDepth","maxEntries","sortList","totalPathsVisited","_totalPathsVisited","shouldVisitChildren","currentPath","realPath","hasOwnProperty","TOO_MANY_ENTRIES","getContents","entries","entriesStats","i","_entryStats","compare","entry1","entry2","toLocaleLowerCase","localeCompare","sort","e","visit","then","catch"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global Phoenix*/\n\n/*\n * To ensure cache coherence, current and future asynchronous state-changing\n * operations of FileSystemEntry and its subclasses should implement the\n * following high-level sequence of steps:\n *\n * 1. Block external filesystem change events;\n * 2. Execute the low-level state-changing operation;\n * 3. Update the internal filesystem state, including caches;\n * 4. Apply the callback;\n * 5. Fire an appropriate internal change notification; and\n * 6. Unblock external change events.\n *\n * Note that because internal filesystem state is updated first, both the original\n * caller and the change notification listeners observe filesystem state that is\n * current w.r.t. the operation. Furthermore, because external change events are\n * blocked before the operation begins, listeners will only receive the internal\n * change event for the operation and not additional (or possibly inconsistent)\n * external change events.\n *\n * State-changing operations that block external filesystem change events must\n * take care to always subsequently unblock the external change events in all\n * control paths. It is safe to assume, however, that the underlying impl will\n * always apply the callback with some value.\n\n * Caches should be conservative. Consequently, the entry's cached data should\n * always be cleared if the underlying impl's operation fails. This is the case\n * event for read-only operations because an unexpected failure implies that the\n * system is in an unknown state. The entry should communicate this by failing\n * where appropriate, and should not use the cache to hide failure.\n *\n * Only watched entries should make use of cached data because change events are\n * only expected for such entries, and change events are used to granularly\n * invalidate out-of-date caches.\n *\n * By convention, callbacks are optional for asynchronous, state-changing\n * operations, but required for read-only operations. The first argument to the\n * callback should always be a nullable error string from FileSystemError.\n */\ndefine(function (require, exports, module) {\n\n\n    var FileSystemError = require(\"filesystem/FileSystemError\"),\n        WatchedRoot     = require(\"filesystem/WatchedRoot\");\n\n    var VISIT_DEFAULT_MAX_DEPTH = 100,\n        VISIT_DEFAULT_MAX_ENTRIES = 200000;\n\n    /* Counter to give every entry a unique id */\n    var nextId = 0;\n\n    /**\n     * Model for a file system entry. This is the base class for File and Directory,\n     * and is never used directly.\n     *\n     * See the File, Directory, and FileSystem classes for more details.\n     *\n     * @constructor\n     * @param {string} path The path for this entry.\n     * @param {FileSystem} fileSystem The file system associated with this entry.\n     */\n    function FileSystemEntry(path, fileSystem) {\n        this._setPath(path);\n        this._fileSystem = fileSystem;\n        this._id = nextId++;\n    }\n\n    // Add \"fullPath\", \"name\", \"parent\", \"id\", \"isFile\" and \"isDirectory\" getters\n    Object.defineProperties(FileSystemEntry.prototype, {\n        \"fullPath\": {\n            get: function () { return this._path; },\n            set: function () { throw new Error(\"Cannot set fullPath\"); }\n        },\n        \"name\": {\n            get: function () { return this._name; },\n            set: function () { throw new Error(\"Cannot set name\"); }\n        },\n        \"parentPath\": {\n            get: function () { return this._parentPath; },\n            set: function () { throw new Error(\"Cannot set parentPath\"); }\n        },\n        \"id\": {\n            get: function () { return this._id; },\n            set: function () { throw new Error(\"Cannot set id\"); }\n        },\n        \"isFile\": {\n            get: function () { return this._isFile; },\n            set: function () { throw new Error(\"Cannot set isFile\"); }\n        },\n        \"isDirectory\": {\n            get: function () { return this._isDirectory; },\n            set: function () { throw new Error(\"Cannot set isDirectory\"); }\n        },\n        \"_impl\": {\n            get: function () { return this._fileSystem._impl; },\n            set: function () { throw new Error(\"Cannot set _impl\"); }\n        }\n    });\n\n    /**\n     * Cached stat object for this file.\n     * @type {?FileSystemStats}\n     */\n    FileSystemEntry.prototype._stat = null;\n\n    /**\n     * Parent file system.\n     * @type {!FileSystem}\n     */\n    FileSystemEntry.prototype._fileSystem = null;\n\n    /**\n     * The path of this entry.\n     * @type {string}\n     */\n    FileSystemEntry.prototype._path = null;\n\n    /**\n     * The name of this entry.\n     * @type {string}\n     */\n    FileSystemEntry.prototype._name = null;\n\n    /**\n     * The parent of this entry.\n     * @type {string}\n     */\n    FileSystemEntry.prototype._parentPath = null;\n\n    /**\n     * Whether or not the entry is a file\n     * @type {boolean}\n     */\n    FileSystemEntry.prototype._isFile = false;\n\n    /**\n     * Whether or not the entry is a directory\n     * @type {boolean}\n     */\n    FileSystemEntry.prototype._isDirectory = false;\n\n    /**\n     * Cached copy of this entry's watched root\n     * @type {entry: File|Directory, filter: function(FileSystemEntry):boolean, active: boolean}\n     */\n    FileSystemEntry.prototype._watchedRoot = undefined;\n\n    /**\n     * Cached result of _watchedRoot.filter(this.name, this.parentPath).\n     * @type {boolean}\n     */\n    FileSystemEntry.prototype._watchedRootFilterResult = undefined;\n\n    /**\n     * Determines whether or not the entry is watched.\n     * @param {boolean=} relaxed If falsey, the method will only return true if\n     *      the watched root is fully active. If true, the method will return\n     *      true if the watched root is either starting up or fully active.\n     * @return {boolean}\n     */\n    FileSystemEntry.prototype._isWatched = function (relaxed) {\n        var watchedRoot = this._watchedRoot,\n            filterResult = this._watchedRootFilterResult;\n\n        if (!watchedRoot) {\n            watchedRoot = this._fileSystem._findWatchedRootForPath(this._path);\n\n            if (watchedRoot) {\n                this._watchedRoot = watchedRoot;\n                if (watchedRoot.entry !== this) { // avoid creating entries for root's parent\n                    var parentEntry = this._fileSystem.getDirectoryForPath(this._parentPath);\n                    if (parentEntry._isWatched() === false) {\n                        filterResult = false;\n                    } else {\n                        filterResult = watchedRoot.filter(this._name, this._parentPath);\n                    }\n                } else { // root itself is watched\n                    filterResult = true;\n                }\n                this._watchedRootFilterResult = filterResult;\n            }\n        }\n\n        if (watchedRoot) {\n            if (watchedRoot.status === WatchedRoot.ACTIVE ||\n                    (relaxed && watchedRoot.status === WatchedRoot.STARTING)) {\n                return filterResult;\n            }\n                // We had a watched root, but it's no longer active, so it must now be invalid.\n            this._watchedRoot = undefined;\n            this._watchedRootFilterResult = false;\n            this._clearCachedData();\n\n        }\n        return false;\n    };\n\n    /**\n     * Update the path for this entry\n     * @private\n     * @param {String} newPath\n     */\n    FileSystemEntry.prototype._setPath = function (newPath) {\n        var parts = newPath.split(\"/\");\n        if (this.isDirectory) {\n            parts.pop(); // Remove the empty string after last trailing \"/\"\n        }\n        this._name = parts[parts.length - 1];\n        parts.pop(); // Remove name\n\n        if (parts.length > 0) {\n            this._parentPath = parts.join(\"/\") + \"/\";\n        } else {\n            // root directories have no parent path\n            this._parentPath = null;\n        }\n\n        this._path = newPath;\n\n        var watchedRoot = this._watchedRoot;\n        if (watchedRoot) {\n            if (newPath.indexOf(watchedRoot.entry.fullPath) === 0) {\n                // Update watchedRootFilterResult\n                this._watchedRootFilterResult = watchedRoot.filter(this._name, this._parentPath);\n            } else {\n                // The entry was moved outside of the watched root\n                this._watchedRoot = null;\n                this._watchedRootFilterResult = false;\n            }\n        }\n    };\n\n    /**\n     * Clear any cached data for this entry\n     * @private\n     */\n    FileSystemEntry.prototype._clearCachedData = function () {\n        this._stat = undefined;\n    };\n\n    /**\n     * Helpful toString for debugging purposes\n     */\n    FileSystemEntry.prototype.toString = function () {\n        return \"[\" + (this.isDirectory ? \"Directory \" : \"File \") + this._path + \"]\";\n    };\n\n    /**\n     * Check to see if the entry exists on disk. Note that there will NOT be an\n     * error returned if the file does not exist on the disk; in that case the\n     * error parameter will be null and the boolean will be false. The error\n     * parameter will only be truthy when an unexpected error was encountered\n     * during the test, in which case the state of the entry should be considered\n     * unknown.\n     *\n     * @param {function (?string, boolean)} callback Callback with a FileSystemError\n     *      string or a boolean indicating whether or not the file exists.\n     */\n    FileSystemEntry.prototype.exists = function (callback) {\n        if (this._stat) {\n            callback(null, true);\n            return;\n        }\n\n        this._impl.exists(this._path, function (err, exists) {\n            if (err) {\n                this._clearCachedData();\n                callback(err);\n                return;\n            }\n\n            if (!exists) {\n                this._clearCachedData();\n            }\n\n            callback(null, exists);\n        }.bind(this));\n    };\n\n    /**\n     * Async version of exists API. Returns true or false if the entry exists. or error rejects.\n     */\n    FileSystemEntry.prototype.existsAsync = async function () {\n        let that = this;\n        return new Promise((resolve, reject)=>{\n            that.exists((err, exists)=>{\n                if(err){\n                    reject(err);\n                } else {\n                    resolve(exists);\n                }\n            });\n        });\n\n    };\n\n    /**\n     * Returns the stats for the entry.\n     *\n     * @param {function (?string, FileSystemStats=)} callback Callback with a\n     *      FileSystemError string or FileSystemStats object.\n     */\n    FileSystemEntry.prototype.stat = function (callback) {\n        if (this._stat) {\n            callback(null, this._stat);\n            return;\n        }\n\n        this._impl.stat(this._path, function (err, stat) {\n            if (err) {\n                this._clearCachedData();\n                callback(err);\n                return;\n            }\n\n            if (this._isWatched()) {\n                this._stat = stat;\n            }\n\n            callback(null, stat);\n        }.bind(this));\n    };\n\n    /**\n     * Returns a promise that resolves to the stats for the entry.\n     *\n     * @return {Promise<FileSystemStats>}\n     */\n    FileSystemEntry.prototype.statAsync = async function () {\n        let that = this;\n        return new Promise((resolve, reject)=>{\n            that.stat((err, stat)=>{\n                if(err){\n                    reject(err);\n                } else {\n                    resolve(stat);\n                }\n            });\n        });\n    };\n\n    /**\n     * Rename this entry.\n     *\n     * @param {string} newFullPath New path & name for this entry.\n     * @param {function (?string)=} callback Callback with a single FileSystemError\n     *      string parameter.\n     */\n    FileSystemEntry.prototype.rename = function (newFullPath, callback) {\n        callback = callback || function () {};\n        if(this.isDirectory){\n            newFullPath = Phoenix.VFS.ensureTrailingSlash(newFullPath);\n        }\n\n        // Block external change events until after the write has finished\n        this._fileSystem._beginChange();\n\n        this._impl.rename(this._path, newFullPath, function (err) {\n            var oldFullPath = this._path;\n\n            try {\n                if (err) {\n                    this._clearCachedData();\n                    callback(err);\n                    return;\n                }\n\n                // Update internal filesystem state\n                this._fileSystem._handleRename(oldFullPath, newFullPath, this.isDirectory);\n\n                try {\n                    // Notify the caller\n                    callback(null);\n                } finally {\n                    // Notify rename listeners\n                    this._fileSystem._fireRenameEvent(oldFullPath, newFullPath);\n                }\n            } finally {\n                // Unblock external change events\n                this._fileSystem._endChange();\n            }\n        }.bind(this));\n    };\n\n    /**\n     * Permanently delete this entry. For Directories, this will delete the directory\n     * and all of its contents. For reversible delete, see moveToTrash().\n     *\n     * @return {Promise<>} a promise that resolves when delete is success or rejects.\n     */\n    FileSystemEntry.prototype.unlinkAsync = function () {\n        let that = this;\n        return new Promise((resolve, reject)=>{\n            that.unlink((err)=>{\n                if(err){\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    };\n\n    /**\n     * Permanently delete this entry. For Directories, this will delete the directory\n     * and all of its contents. For reversible delete, see moveToTrash().\n     *\n     * @param {function (?string)=} callback Callback with a single FileSystemError\n     *      string parameter.\n     */\n    FileSystemEntry.prototype.unlink = function (callback) {\n        callback = callback || function () {};\n\n        // Block external change events until after the write has finished\n        this._fileSystem._beginChange();\n\n        this._clearCachedData();\n        this._impl.unlink(this._path, function (err) {\n            var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\n\n            // Update internal filesystem state\n            this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\n                try {\n                    // Notify the caller\n                    callback(err);\n                } finally {\n                    if (parent._isWatched()) {\n                        // Notify change listeners\n                        this._fileSystem._fireChangeEvent(parent, added, removed);\n                    }\n\n                    // Unblock external change events\n                    this._fileSystem._endChange();\n                }\n            }.bind(this));\n        }.bind(this));\n    };\n\n    /**\n     * Move this entry to the trash. If the underlying file system doesn't support move\n     * to trash, the item is permanently deleted.\n     *\n     * @param {function (?string)=} callback Callback with a single FileSystemError\n     *      string parameter.\n     */\n    FileSystemEntry.prototype.moveToTrash = function (callback) {\n        if (!this._impl.moveToTrash) {\n            this.unlink(callback);\n            return;\n        }\n\n        callback = callback || function () {};\n\n        // Block external change events until after the write has finished\n        this._fileSystem._beginChange();\n\n        this._clearCachedData();\n        this._impl.moveToTrash(this._path, function (err) {\n            var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\n\n            // Update internal filesystem state\n            this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\n                try {\n                    // Notify the caller\n                    callback(err);\n                } finally {\n                    if (parent._isWatched()) {\n                        // Notify change listeners\n                        this._fileSystem._fireChangeEvent(parent, added, removed);\n                    }\n\n                    // Unblock external change events\n                    this._fileSystem._endChange();\n                }\n            }.bind(this));\n        }.bind(this));\n    };\n\n    /**\n     * Private helper function for FileSystemEntry.visit that requires sanitized options.\n     *\n     * @private\n     * @param {FileSystemStats} stats - the stats for this entry\n     * @param {{string: boolean}} visitedPaths - the set of fullPaths that have already been visited\n     * @param {function(FileSystemEntry): boolean} visitor - A visitor function, which is\n     *      applied to descendent FileSystemEntry objects. If the function returns false for\n     *      a particular Directory entry, that directory's descendents will not be visited.\n     * @param {{maxDepth: number, maxEntries: number, sortList: boolean}} options\n     * @returns {Promise<>} that resolves when the visit is complete\n     */\n    FileSystemEntry.prototype._visitHelper = function (stats, visitedPaths, visitor, options, _currentDepth = 0) {\n        return new Promise((resolve, reject)=>{\n            const self = this;\n            let maxDepth = options.maxDepth,\n                maxEntries = options.maxEntries,\n                sortList = options.sortList,\n                totalPathsVisited = visitedPaths._totalPathsVisited || 0;\n\n            if (self.isDirectory) {\n                var currentPath = stats.realPath || self.fullPath;\n\n                if (visitedPaths.hasOwnProperty(currentPath)) {\n                    // Link cycle detected\n                    resolve();\n                    return;\n                }\n\n                visitedPaths[currentPath] = true;\n            }\n\n            if (visitedPaths._totalPathsVisited >= maxEntries) {\n                reject(FileSystemError.TOO_MANY_ENTRIES);\n                return;\n            }\n\n            visitedPaths._totalPathsVisited = totalPathsVisited + 1;\n            let shouldVisitChildren = visitor(self);\n            if (!shouldVisitChildren || self.isFile || _currentDepth >= maxDepth) {\n                resolve();\n                return;\n            }\n\n            self.getContents(async function (err, entries, entriesStats) {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n\n                for(let i=0; i<entriesStats.length; i++){\n                    entries[i]._entryStats = entriesStats[i];\n                }\n\n                //sort entries if required\n                if (sortList) {\n                    function compare(entry1, entry2) {\n                        return entry1._name.toLocaleLowerCase().localeCompare(entry2._name.toLocaleLowerCase());\n                    }\n                    entries = entries.sort(compare);\n                }\n\n                try{\n                    for(let entry of entries){\n                        // this is left intentionally serial to prevent a chrome crash bug when large number of fs\n                        // access APIs are called. Try to make this parallel in the future after verifying on a large\n                        // folder with more than 100K entries.\n                        await entry._visitHelper(entry._entryStats, visitedPaths, visitor, options, _currentDepth + 1);\n                    }\n                    resolve();\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    };\n\n    /**\n     * Visit this entry and its descendents with the supplied visitor function.\n     * Correctly handles symbolic link cycles and options can be provided to limit\n     * search depth and total number of entries visited. No particular traversal\n     * order is guaranteed; instead of relying on such an order, it is preferable\n     * to use the visit function to build a list of visited entries, sort those\n     * entries as desired, and then process them. Whenever possible, deep\n     * filesystem traversals should use this method.\n     *\n     * @param {function(FileSystemEntry): boolean} visitor - A visitor function, which is\n     *      applied to this entry and all descendent FileSystemEntry objects. If the function returns\n     *      false for a particular Directory entry, that directory's descendents will not be visited.\n     * @param {{maxDepth: number=, maxEntries: number=}=} options\n     * @param {function(?string)=} callback Callback with single FileSystemError string parameter.\n     */\n    FileSystemEntry.prototype.visit = function (visitor, options, callback) {\n        let self = this;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        } else {\n            if (options === undefined) {\n                options = {};\n            }\n\n            callback = callback || function () {};\n        }\n\n        if (options.maxDepth === undefined) {\n            options.maxDepth = VISIT_DEFAULT_MAX_DEPTH;\n        }\n\n        if (options.maxEntries === undefined) {\n            options.maxEntries = VISIT_DEFAULT_MAX_ENTRIES;\n        }\n\n        self.stat(function (err, stats) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            self._visitHelper(stats, {}, visitor, options)\n                .then(()=>{\n                    callback(null);\n                })\n                .catch((err)=>{\n                    callback(err);\n                });\n        });\n    };\n\n    // Export this class\n    module.exports = FileSystemEntry;\n});\n"],"file":"FileSystemEntry.js"}
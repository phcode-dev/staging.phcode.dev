{"version":3,"sources":["extensions/default/CSSPseudoSelectorHints/main.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","CodeHintManager","TokenUtils","PseudoRulesText","PseudoRules","JSON","parse","TOKEN_TYPE_PSEUDO_CLASS","TOKEN_TYPE_PSEUDO_ELEMENT","PUNCTUATION_CHAR","_getPseudoContext","token","cursorText","ctx","slicedToken","contextType","state","substr","start","slice","type","movePrevToken","string","PseudoSelectorHints","_validatePseudoContext","prototype","hasHints","editor","implicitChar","pos","getCursorPos","_codeMirror","getTokenAt","this","getHints","filter","lineTillCursor","getLine","line","getInitialContext","result","context","hints","Object","keys","classes","elements","key","indexOf","sort","match","selectInitial","defaultDescriptionWidth","handleWideResults","insertHint","completion","cursor","startPos","ch","endPos","end","text","document","replaceRange","setCursorPos","appReady","pseudoSelectorHints","registerHintProvider"],"mappings":"AAqBAA,OAAO,SAAUC,QAASC,QAASC,QAI/B,IAAIC,QAAsBC,SAASC,UAAU,iBACzCC,gBAAsBF,SAASC,UAAU,0BACzCE,WAAsBH,SAASC,UAAU,oBACzCG,gBAAsBR,QAAQ,6BAC9BS,YAAsBC,KAAKC,MAAMH,iBAGjCI,wBAA4B,EAC5BC,0BAA4B,EAC5BC,iBAA4B,IAEhC,SAASC,kBAAkBC,MAAOC,WAAYC,KAC1C,IAAIC,YACAC,aAAe,EAiCnB,MAxB0B,WAAtBJ,MAAMK,MAAMA,MACZF,YAAcF,WAAWK,OAAO,EAAGN,MAAMO,MAAQ,GAAGC,OAAO,GACrC,eAAfR,MAAMS,OACbN,YAAcF,WAAWK,OAAO,EAAGN,MAAMO,OAAOC,OAAO,IAGtDL,YAW6B,OAA1BA,YAAYK,OAAO,GACnBJ,YAAcP,0BACmB,MAA1BM,YAAYK,OAAO,KAC1BJ,YAAcR,0BAXlBL,WAAWmB,cAAcR,KAGrBE,YAFAF,IAAIF,MAAMW,SAAWb,iBAEPD,0BAEAD,yBAUfQ,YAMX,SAASQ,uBAGT,SAASC,uBAAuBb,OAC5B,MAA6B,WAAtBA,MAAMK,MAAMA,OAAqC,eAAfL,MAAMS,MAAyBT,MAAMW,SAAWb,iBAK7Fc,oBAAoBE,UAAUC,SAAW,SAAUC,OAAQC,cACvD,IAAIC,IAAMF,OAAOG,eACbnB,MAAQgB,OAAOI,YAAYC,WAAWH,KAK1C,OAHAI,KAAKN,OAASA,OAGPH,uBAAuBb,QAGlCY,oBAAoBE,UAAUS,SAAW,SAAUN,cAC/C,IAAIC,IAAMI,KAAKN,OAAOG,eAClBnB,MAAQsB,KAAKN,OAAOI,YAAYC,WAAWH,KAC3CM,OAAwB,eAAfxB,MAAMS,KAAwBT,MAAMW,OAAS,GACtDc,eAAiBH,KAAKN,OAAOI,YAAYM,QAAQR,IAAIS,MACrDzB,IAAMX,WAAWqC,kBAAkBN,KAAKN,OAAOI,YAAaF,KAiB5DW,OAfJ,OAAKhB,uBAAuBb,QAK5BsB,KAAKQ,QAAU/B,kBAAkBC,MAAOyB,eAAgBvB,MAGlC,IAAlBoB,KAAKQ,QACE,MAGXR,KAAKtB,MAAQA,MASN,CACH+B,MAPSC,OAAOC,KAAKX,KAAKQ,UAAYlC,wBAA0BH,YAAYyC,QAAUzC,YAAY0C,UAAUX,OAAO,SAAUY,KAC7H,GAA4B,IAAxBA,IAAIC,QAAQb,QACZ,OAAOY,MAEZE,OAICC,MAAOf,OACPgB,eAAe,EACfC,yBAAyB,EACzBC,mBAAmB,KAzBZ,MAuCf9B,oBAAoBE,UAAU6B,WAAa,SAAUC,YACjD,IAAIC,OAASvB,KAAKN,OAAOG,eACrB2B,SAAW,CAACnB,KAAMkB,OAAOlB,KAAMoB,GAAIzB,KAAKtB,MAAMO,OAC9CyC,OAAW,CAACrB,KAAMkB,OAAOlB,KAAMoB,GAAIzB,KAAKtB,MAAMiD,KAqBlD,MAnB+B,WAA3B3B,KAAKtB,MAAMK,MAAMA,QAEjByC,SAASC,GAAKD,SAASC,GAAK,EAC5BC,OAASF,UAGTxB,KAAKQ,UAAYlC,0BAGjBgD,WAAanD,YAAYyC,QAAQU,YAAYM,MAAQN,YAGzDtB,KAAKN,OAAOmC,SAASC,aAAaR,WAAYE,SAAUE,QAE3B,MAAzBJ,WAAWpC,OAAO,KAClBqC,OAASvB,KAAKN,OAAOG,eACrBG,KAAKN,OAAOqC,aAAa,CAAC1B,KAAMkB,OAAOlB,KAAMoB,GAAIF,OAAOE,GAAK,MAG1D,GAGX5D,QAAQmE,SAAS,WAEb,IAAIC,oBAAsB,IAAI3C,oBAC9BtB,gBAAgBkE,qBAAqBD,oBAAqB,CAAC,MAAO,OAAQ,QAAS,GAGnFtE,QAAQsE,oBAAsBA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2017 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Load dependent modules\n    var AppInit             = brackets.getModule(\"utils/AppInit\"),\n        CodeHintManager     = brackets.getModule(\"editor/CodeHintManager\"),\n        TokenUtils          = brackets.getModule(\"utils/TokenUtils\"),\n        PseudoRulesText     = require(\"text!PseudoSelectors.json\"),\n        PseudoRules         = JSON.parse(PseudoRulesText);\n\n\n    var TOKEN_TYPE_PSEUDO_CLASS   = 0,\n        TOKEN_TYPE_PSEUDO_ELEMENT = 1,\n        PUNCTUATION_CHAR          = ':';\n\n    function _getPseudoContext(token, cursorText, ctx) {\n        var slicedToken,\n            contextType = -1;\n\n        // Magic code to get around CM's 'pseudo' identification logic\n        // As per CSS3 spec :\n        // -> ':' identifies pseudo classes\n        // -> '::' identifies pseudo elements\n        // We should strictly check for single or double occurance of ':' by slicing\n        // the line text till the token start position\n\n        if (token.state.state === \"pseudo\") {\n            slicedToken = cursorText.substr(0, token.start + 1).slice(-3);\n        } else if (token.type === \"variable-3\") {\n            slicedToken = cursorText.substr(0, token.start).slice(-3);\n        }\n\n        if (!slicedToken) {\n            //We get here when in SCSS mode and the cursor is right after ':'\n            //Test the previous token first\n            TokenUtils.movePrevToken(ctx);\n            if (ctx.token.string === PUNCTUATION_CHAR) {\n                //We are in pseudo element context ('::')\n                contextType = TOKEN_TYPE_PSEUDO_ELEMENT;\n            } else {\n                contextType = TOKEN_TYPE_PSEUDO_CLASS;\n            }\n        } else {\n            if (slicedToken.slice(-2) === \"::\") {\n                contextType = TOKEN_TYPE_PSEUDO_ELEMENT;\n            } else if (slicedToken.slice(-1) === \":\") {\n                contextType = TOKEN_TYPE_PSEUDO_CLASS;\n            }\n        }\n\n        return contextType;\n    }\n\n    /**\n     * @constructor\n     */\n    function PseudoSelectorHints() {\n    }\n\n    function _validatePseudoContext(token) {\n        return token.state.state === \"pseudo\" || token.type === \"variable-3\" || token.string === PUNCTUATION_CHAR;\n    }\n\n    // As we are only going to provide :<pseudo> name hints\n    // we should claim that we don't have hints for anything else\n    PseudoSelectorHints.prototype.hasHints = function (editor, implicitChar) {\n        var pos = editor.getCursorPos(),\n            token = editor._codeMirror.getTokenAt(pos);\n\n        this.editor = editor;\n\n        // Check if we are at ':' pseudo rule or in 'variable-3' 'def' context\n        return _validatePseudoContext(token);\n    };\n\n    PseudoSelectorHints.prototype.getHints = function (implicitChar) {\n        var pos = this.editor.getCursorPos(),\n            token = this.editor._codeMirror.getTokenAt(pos),\n            filter = token.type === \"variable-3\" ? token.string : \"\",\n            lineTillCursor = this.editor._codeMirror.getLine(pos.line),\n            ctx = TokenUtils.getInitialContext(this.editor._codeMirror, pos);\n\n        if (!_validatePseudoContext(token)) {\n            return null;\n        }\n\n        // validate and keep the context in scope so that it can be used while getting description\n        this.context = _getPseudoContext(token, lineTillCursor, ctx);\n\n        // If we are not able to find context, don't proceed\n        if (this.context === -1) {\n            return null;\n        }\n\n        this.token = token;\n\n        // Filter the property list based on the token string\n        var result = Object.keys(this.context === TOKEN_TYPE_PSEUDO_CLASS ? PseudoRules.classes : PseudoRules.elements).filter(function (key) {\n            if (key.indexOf(filter) === 0) {\n                return key;\n            }\n        }).sort();\n\n        return {\n            hints: result,\n            match: filter,\n            selectInitial: true,\n            defaultDescriptionWidth: true,\n            handleWideResults: false\n        };\n    };\n\n    /**\n     * Inserts a given ':<pseudo>' hint into the current editor context.\n     *\n     * @param {string} completion\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    PseudoSelectorHints.prototype.insertHint = function (completion) {\n        var cursor = this.editor.getCursorPos();\n        var startPos = {line: cursor.line, ch: this.token.start},\n            endPos   = {line: cursor.line, ch: this.token.end};\n\n        if (this.token.state.state === \"pseudo\") {\n            // We have just started the 'pseudo' context, start replacing the current token by leaving ':' char\n            startPos.ch = startPos.ch + 1;\n            endPos = startPos;\n        }\n\n        if (this.context === TOKEN_TYPE_PSEUDO_CLASS) {\n            // If the hint label contains annotated data for illustration, then we might have\n            // different text to be inserted.\n            completion = PseudoRules.classes[completion].text || completion;\n        }\n\n        this.editor.document.replaceRange(completion, startPos, endPos);\n\n        if (completion.slice(-1) === \")\") {\n            cursor = this.editor.getCursorPos();\n            this.editor.setCursorPos({line: cursor.line, ch: cursor.ch - 1});\n        }\n\n        return false;\n    };\n\n    AppInit.appReady(function () {\n        // Register code hint providers\n        var pseudoSelectorHints = new PseudoSelectorHints();\n        CodeHintManager.registerHintProvider(pseudoSelectorHints, [\"css\", \"scss\", \"less\"], 0);\n\n        // For test\n        exports.pseudoSelectorHints = pseudoSelectorHints;\n    });\n});\n"],"file":"main.js"}
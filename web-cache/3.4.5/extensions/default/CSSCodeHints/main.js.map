{"version":3,"sources":["extensions/default/CSSCodeHints/main.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","ExtensionUtils","CodeHintManager","CSSUtils","HTMLUtils","LanguageManager","PreferencesManager","TokenUtils","StringMatch","ColorUtils","Strings","CSSProperties","properties","JSON","parse","definePreference","description","DESCRIPTION_CSS_PROP_HINTS","lastContext","stringMatcherOptions","preferPrefixMatches","CssPropHints","this","primaryTriggerKeys","secondaryTriggerKeys","exclusion","formatHints","hints","query","hasColorSwatch","some","token","color","basicMatchSort","map","$hintObj","$","addClass","stringRanges","forEach","item","matched","append","text","value","formatColorHint","prototype","getCssStyleText","getLanguageForPath","editor","document","file","fullPath","getId","styleBlocks","findBlocks","styleBlock","getText","getNamedFlows","namedFlowsCache","cursor","line","flows","extractAllNamedFlows","ch","updateExclusion","propNameOnly","textAfterCursor","info","context","PROP_NAME","name","substr","offset","PROP_VALUE","hasValidExclusion","hasHints","implicitChar","getCursorPos","getInfoAtPos","indexOf","getHints","needle","valueNeedle","valueArray","type","namedFlows","result","selectInitial","isNewItem","index","values","trim","length","splice","concat","COLOR_NAMES","push","pvalue","stringMatch","match","pvalues","pname","handleWideResults","insertHint","hint","start","end","keepHints","adjustCursor","newCursor","ctx","jquery","getInitialContext","_codeMirror","string","test","moveNextToken","moveSkippingWhitespace","parenMatch","replaceRange","setCursorPos","appReady","cssPropHints","registerHintProvider","loadStyleSheet","cssPropHintProvider"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\ndefine(function (require, exports, module) {\n\n\n    var AppInit             = brackets.getModule(\"utils/AppInit\"),\n        ExtensionUtils      = brackets.getModule(\"utils/ExtensionUtils\"),\n        CodeHintManager     = brackets.getModule(\"editor/CodeHintManager\"),\n        CSSUtils            = brackets.getModule(\"language/CSSUtils\"),\n        HTMLUtils           = brackets.getModule(\"language/HTMLUtils\"),\n        LanguageManager     = brackets.getModule(\"language/LanguageManager\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        TokenUtils          = brackets.getModule(\"utils/TokenUtils\"),\n        StringMatch         = brackets.getModule(\"utils/StringMatch\"),\n        ColorUtils          = brackets.getModule(\"utils/ColorUtils\"),\n        Strings             = brackets.getModule(\"strings\"),\n        CSSProperties       = require(\"text!CSSProperties.json\"),\n        properties          = JSON.parse(CSSProperties);\n\n\n    PreferencesManager.definePreference(\"codehint.CssPropHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_CSS_PROP_HINTS\n    });\n\n    // Context of the last request for hints: either CSSUtils.PROP_NAME,\n    // CSSUtils.PROP_VALUE or null.\n    var lastContext,\n        stringMatcherOptions = { preferPrefixMatches: true };\n\n    /**\n     * @constructor\n     */\n    function CssPropHints() {\n        this.primaryTriggerKeys = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-()\";\n        this.secondaryTriggerKeys = \":\";\n        this.exclusion = null;\n    }\n\n    /**\n     * Get the CSS style text of the file open in the editor for this hinting session.\n     * For a CSS file, this is just the text of the file. For an HTML file,\n     * this will be only the text in the <style> tags.\n     *\n     * @return {string} the \"css\" text that can be sent to CSSUtils to extract all named flows.\n     */\n    CssPropHints.prototype.getCssStyleText = function () {\n        if (LanguageManager.getLanguageForPath(this.editor.document.file.fullPath).getId() === \"html\") {\n            // Collect text in all style blocks\n            var text = \"\",\n                styleBlocks = HTMLUtils.findBlocks(this.editor, \"css\");\n\n            styleBlocks.forEach(function (styleBlock) {\n                text += styleBlock.text;\n            });\n\n            return text;\n        }\n            // css file, just return the text\n        return this.editor.document.getText();\n\n    };\n\n    /**\n     * Extract all the named flows from any \"flow-from\" or \"flow-into\" properties\n     * in the current document. If we have the cached list of named flows and the\n     * cursor is still on the same line as the cached cursor, then the cached list\n     * is returned. Otherwise, we recollect all named flows and update the cache.\n     *\n     * @return {Array.<string>} All named flows available in the current document.\n     */\n    CssPropHints.prototype.getNamedFlows = function () {\n        if (this.namedFlowsCache) {\n            // If the cursor is no longer on the same line, then the cache is stale.\n            // Delete cache so we can extract all named flows again.\n            if (this.namedFlowsCache.cursor.line !== this.cursor.line) {\n                this.namedFlowsCache = null;\n            }\n        }\n\n        if (!this.namedFlowsCache) {\n            this.namedFlowsCache = {};\n            this.namedFlowsCache.flows = CSSUtils.extractAllNamedFlows(this.getCssStyleText());\n            this.namedFlowsCache.cursor = { line: this.cursor.line, ch: this.cursor.ch };\n        }\n\n        return this.namedFlowsCache.flows;\n    };\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     *\n     * @param {boolean} propNameOnly\n     * true to indicate that we update the exclusion only if the cursor is inside property name context.\n     * Otherwise, we also update exclusion for property value context.\n     */\n    CssPropHints.prototype.updateExclusion = function (propNameOnly) {\n        var textAfterCursor;\n        if (this.exclusion && this.info) {\n            if (this.info.context === CSSUtils.PROP_NAME) {\n                textAfterCursor = this.info.name.substr(this.info.offset);\n            } else if (!propNameOnly && this.info.context === CSSUtils.PROP_VALUE) {\n                textAfterCursor = this.info.value.substr(this.info.offset);\n            }\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    /**\n     * Determines whether CSS propertyname or -name hints are available in the current editor\n     * context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {String} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {Boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non- null,\n     * whether it is appropriate to do so.\n     */\n    CssPropHints.prototype.hasHints = function (editor, implicitChar) {\n        this.editor = editor;\n        var cursor = this.editor.getCursorPos();\n\n        lastContext = null;\n        this.info = CSSUtils.getInfoAtPos(editor, cursor);\n\n        if (this.info.context !== CSSUtils.PROP_NAME && this.info.context !== CSSUtils.PROP_VALUE) {\n            return false;\n        }\n\n        if (implicitChar) {\n            this.updateExclusion(false);\n            if (this.info.context === CSSUtils.PROP_NAME) {\n                // Check if implicitChar is the first character typed before an existing property name.\n                if (!this.exclusion && this.info.offset === 1 && implicitChar === this.info.name[0]) {\n                    this.exclusion = this.info.name.substr(this.info.offset);\n                }\n            }\n\n            return (this.primaryTriggerKeys.indexOf(implicitChar) !== -1) ||\n                   (this.secondaryTriggerKeys.indexOf(implicitChar) !== -1);\n        } else if (this.info.context === CSSUtils.PROP_NAME) {\n            if (this.info.offset === 0) {\n                this.exclusion = this.info.name;\n            } else {\n                this.updateExclusion(true);\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Returns a sorted and formatted list of hints with the query substring\n     * highlighted.\n     *\n     * @param {Array.<Object>} hints - the list of hints to format\n     * @param {string} query - querystring used for highlighting matched\n     *      portions of each hint\n     * @return {Array.jQuery} sorted Array of jQuery DOM elements to insert\n     */\n    function formatHints(hints, query) {\n        var hasColorSwatch = hints.some(function (token) {\n            return token.color;\n        });\n\n        StringMatch.basicMatchSort(hints);\n        return hints.map(function (token) {\n            var $hintObj = $(\"<span>\").addClass(\"brackets-css-hints\");\n\n            // highlight the matched portion of each hint\n            if (token.stringRanges) {\n                token.stringRanges.forEach(function (item) {\n                    if (item.matched) {\n                        $hintObj.append($(\"<span>\")\n                            .text(item.text)\n                            .addClass(\"matched-hint\"));\n                    } else {\n                        $hintObj.append(item.text);\n                    }\n                });\n            } else {\n                $hintObj.text(token.value);\n            }\n\n            if (hasColorSwatch) {\n                $hintObj = ColorUtils.formatColorHint($hintObj, token.color);\n            }\n\n            return $hintObj;\n        });\n    }\n\n    /**\n     * Returns a list of availble CSS propertyname or -value hints if possible for the current\n     * editor context.\n     *\n     * @param {Editor} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    CssPropHints.prototype.getHints = function (implicitChar) {\n        this.cursor = this.editor.getCursorPos();\n        this.info = CSSUtils.getInfoAtPos(this.editor, this.cursor);\n\n        var needle = this.info.name,\n            valueNeedle = \"\",\n            context = this.info.context,\n            valueArray,\n            type,\n            namedFlows,\n            result,\n            selectInitial = false;\n\n        // Clear the exclusion if the user moves the cursor with left/right arrow key.\n        this.updateExclusion(true);\n\n        if (context === CSSUtils.PROP_VALUE) {\n\n            // Always select initial value\n            selectInitial = true;\n\n            // We need to end the session and begin a new session if the ( char is typed to\n            // get arguments into the list when typing too fast\n            if (implicitChar === \"(\") {\n                return true;\n            }\n\n            // When switching from a NAME to a VALUE context, restart the session\n            // to give other more specialized providers a chance to intervene.\n            if (lastContext === CSSUtils.PROP_NAME) {\n                return true;\n            }\n            lastContext = CSSUtils.PROP_VALUE;\n\n\n            if (!properties[needle]) {\n                return null;\n            }\n\n            // Cursor is in an existing property value or partially typed value\n            if (!this.info.isNewItem && this.info.index !== -1) {\n                valueNeedle = this.info.values[this.info.index].trim();\n                valueNeedle = valueNeedle.substr(0, this.info.offset);\n            }\n\n            valueArray = properties[needle].values;\n            type = properties[needle].type;\n            if (type === \"named-flow\") {\n                namedFlows = this.getNamedFlows();\n\n                if (valueNeedle.length === this.info.offset && namedFlows.indexOf(valueNeedle) !== -1) {\n                    // Exclude the partially typed named flow at cursor since it\n                    // is not an existing one used in other css rule.\n                    namedFlows.splice(namedFlows.indexOf(valueNeedle), 1);\n                }\n\n                valueArray = valueArray.concat(namedFlows);\n            } else if (type === \"color\") {\n                valueArray = valueArray.concat(ColorUtils.COLOR_NAMES.map(function (color) {\n                    return { text: color, color: color };\n                }));\n                valueArray.push(\"transparent\", \"currentColor\");\n            }\n\n            result = $.map(valueArray, function (pvalue) {\n                var result = StringMatch.stringMatch(pvalue.text || pvalue, valueNeedle, stringMatcherOptions);\n                if (result) {\n                    if (pvalue.color) {\n                        result.color = pvalue.color;\n                    }\n\n                    return result;\n                }\n            });\n\n            return {\n                hints: formatHints(result, valueNeedle),\n                match: null, // the CodeHintManager should not format the results\n                selectInitial: selectInitial\n            };\n        } else if (context === CSSUtils.PROP_NAME) {\n\n            // Select initial property if anything has been typed\n            if (this.primaryTriggerKeys.indexOf(implicitChar) !== -1 || needle !== \"\") {\n                selectInitial = true;\n            }\n\n            if (lastContext === CSSUtils.PROP_VALUE) {\n                // close the session if we're coming from a property value\n                // see https://github.com/adobe/brackets/issues/9496\n                return null;\n            }\n\n            lastContext = CSSUtils.PROP_NAME;\n            needle = needle.substr(0, this.info.offset);\n\n            result = $.map(properties, function (pvalues, pname) {\n                var result = StringMatch.stringMatch(pname, needle, stringMatcherOptions);\n                if (result) {\n                    return result;\n                }\n            });\n\n            return {\n                hints: formatHints(result, needle),\n                match: null, // the CodeHintManager should not format the results\n                selectInitial: selectInitial,\n                handleWideResults: false\n            };\n        }\n        return null;\n    };\n\n    /**\n     * Inserts a given CSS protertyname or -value hint into the current editor context.\n     *\n     * @param {String} hint\n     * The hint to be inserted into the editor context.\n     *\n     * @return {Boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    CssPropHints.prototype.insertHint = function (hint) {\n        var offset = this.info.offset,\n            cursor = this.editor.getCursorPos(),\n            start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            keepHints = false,\n            adjustCursor = false,\n            newCursor,\n            ctx;\n\n        if (hint.jquery) {\n            hint = hint.text();\n        }\n\n        if (this.info.context !== CSSUtils.PROP_NAME && this.info.context !== CSSUtils.PROP_VALUE) {\n            return false;\n        }\n\n        start.line = end.line = cursor.line;\n        start.ch = cursor.ch - offset;\n\n        if (this.info.context === CSSUtils.PROP_NAME) {\n            keepHints = true;\n            var textAfterCursor = this.info.name.substr(this.info.offset);\n            if (this.info.name.length === 0 || CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                // It's a new insertion, so append a colon and set keepHints\n                // to show property value hints.\n                hint += \": \";\n                end.ch = start.ch;\n                end.ch += offset;\n\n                if (this.exclusion) {\n                    // Append a space to the end of hint to insert and then adjust\n                    // the cursor before that space.\n                    hint += \" \";\n                    adjustCursor = true;\n                    newCursor = { line: cursor.line,\n                        ch: start.ch + hint.length - 1 };\n                    this.exclusion = null;\n                }\n            } else {\n                // It's a replacement of an existing one or just typed in property.\n                // So we need to check whether there is an existing colon following\n                // the current property name. If a colon already exists, then we also\n                // adjust the cursor position and show code hints for property values.\n                end.ch = start.ch + this.info.name.length;\n                ctx = TokenUtils.getInitialContext(this.editor._codeMirror, cursor);\n                if (ctx.token.string.length > 0 && !/\\S/.test(ctx.token.string)) {\n                    // We're at the very beginning of a property name. So skip it\n                    // before we locate the colon following it.\n                    TokenUtils.moveNextToken(ctx);\n                }\n                if (TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx) && ctx.token.string === \":\") {\n                    adjustCursor = true;\n                    newCursor = { line: cursor.line,\n                        ch: cursor.ch + (hint.length - this.info.name.length) };\n                    // Adjust cursor to the position after any whitespace that follows the colon, if there is any.\n                    if (TokenUtils.moveNextToken(ctx) && ctx.token.string.length > 0 && !/\\S/.test(ctx.token.string)) {\n                        newCursor.ch += ctx.token.string.length;\n                    }\n                } else {\n                    hint += \": \";\n                }\n            }\n        } else {\n            if (!this.info.isNewItem && this.info.index !== -1) {\n                // Replacing an existing property value or partially typed value\n                end.ch = start.ch + this.info.values[this.info.index].length;\n            } else {\n                // Inserting a new property value\n                end.ch = start.ch;\n            }\n\n            var parenMatch = hint.match(/\\(.*?\\)/);\n            if (parenMatch) {\n                // value has (...), so place cursor inside opening paren\n                // and keep hints open\n                adjustCursor = true;\n                newCursor = { line: cursor.line,\n                    ch: start.ch + parenMatch.index + 1 };\n                keepHints = true;\n            }\n        }\n\n        // HACK (tracking adobe/brackets#1688): We talk to the private CodeMirror instance\n        // directly to replace the range instead of using the Document, as we should. The\n        // reason is due to a flaw in our current document synchronization architecture when\n        // inline editors are open.\n        this.editor._codeMirror.replaceRange(hint, start, end);\n\n        if (adjustCursor) {\n            this.editor.setCursorPos(newCursor);\n        }\n\n        return keepHints;\n    };\n\n    AppInit.appReady(function () {\n        var cssPropHints = new CssPropHints();\n        CodeHintManager.registerHintProvider(cssPropHints, [\"css\", \"scss\", \"less\"], 1);\n\n        ExtensionUtils.loadStyleSheet(module, \"styles/brackets-css-hints.css\");\n\n        // For unit testing\n        exports.cssPropHintProvider = cssPropHints;\n    });\n});\n"],"file":"main.js"}
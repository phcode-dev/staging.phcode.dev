{"version":3,"sources":["extensibility/ExtensionManager.js"],"names":["define","require","exports","module","_","EventDispatcher","Package","AppInit","Async","ExtensionLoader","ExtensionUtils","FileSystem","PreferencesManager","Strings","StringUtils","ThemeManager","Metrics","EXTENSION_REGISTRY_LOCAL_STORAGE_KEY","Phoenix","isTestWindow","EXTENSION_REGISTRY_LOCAL_STORAGE_VERSION_KEY","semver","pendingDownloadRegistry","ENABLED","DISABLED","START_FAILED","LOCATION_DEFAULT","LOCATION_DEV","LOCATION_USER","LOCATION_UNKNOWN","FOLDER_AUTOINSTALL","extensions","_idsToRemove","_idsToUpdate","_idsToDisable","synchronizeEntry","id","entry","installInfo","registryInfo","owner","updateAvailable","updateCompatible","currentVersion","metadata","version","lt","lastCompatibleVersionInfo","findLast","versions","versionInfo","brackets","satisfies","apiVersion","lastCompatibleVersion","trigger","loadTheme","extension","theme","loadPackage","_setExtensions","newExtensions","Object","keys","forEach","_reset","_populateExtensions","registry","_shouldUpdateExtensionRegistry","Promise","resolve","reject","currentRegistryVersion","localStorage","getItem","countEvent","EVENT_TYPE","EXTENSIONS","$","ajax","url","config","extension_registry_version","dataType","cache","done","registryVersion","parseInt","registryJson","fail","err","console","error","_patchDownloadCounts","extension_registry_popularity","popularity","JSON","parse","key","totalDownloads","gihubStars","setItem","stringify","downloadRegistry","force","promise","_updateRegistry","newVersion","extension_registry","alreadyResolvedFromCache","always","Deferred","setTimeout","then","catch","_handleExtensionLoad","e","baseURL","setData","locationType","name","userExtensionPath","getUserExtensionPath","path","VFS","getPathForVirtualServingURL","title","indexOf","segments","split","parent","length","status","type","deduceMetadata","match","loadMetadata","disabled","getCompatibilityInfoForVersion","extVersion","requiredVersion","engines","result","isCompatible","compatibleVersion","charAt","requiresNewer","compareVersion","slice","getCompatibilityInfo","fallback","isLatestVersion","i","latestInfo","compatInfo","getExtensionURL","extension_url","remove","format","EXTENSION_NOT_INSTALLED","_enableOrDisable","enable","disable","update","packagePath","keepFile","installUpdate","getFileForPath","unlink","cleanupUpdates","installResult","filename","localPath","unmarkAllForRemoval","markForRemoval","mark","isMarkedForRemoval","hasExtensionsToRemove","markForDisabling","isMarkedForDisabling","hasExtensionsToDisable","unmarkAllForDisabling","updateFromDownload","installationResult","undefined","installationStatus","InstallationStatuses","ALREADY_INSTALLED","NEEDS_UPDATE","SAME_VERSION","OLDER_VERSION","removeUpdate","isMarkedForUpdate","hasExtensionsToUpdate","removeMarkedExtensions","doInParallel_aggregateErrors","disableMarkedExtensions","updateExtensions","getAvailableUpdates","extensionId","extensionInfo","push","installVersion","cleanAvailableUpdates","updates","reduce","arr","updateInfo","extDefinition","installedVersion","stateManager","definePreference","description","SORT_EXTENSION_METHOD","appReady","on","EVENT_EXTENSION_LOADED","EVENT_EXTENSION_LOAD_FAILED","EVENT_EXTENSION_DISABLED","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n/*global Phoenix*/\n/*unittests: ExtensionManager*/\n\n/**\n * The ExtensionManager fetches/caches the extension registry and provides\n * information about the status of installed extensions. ExtensionManager raises the\n * following events:\n * - statusChange - indicates that an extension has been installed/uninstalled or\n *   its status has otherwise changed. Second parameter is the id of the\n *   extension.\n * - registryUpdate - indicates that an existing extension was synchronized\n *   with new data from the registry.\n */\ndefine(function (require, exports, module) {\n\n\n    const _                   = require(\"thirdparty/lodash\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        Package             = require(\"extensibility/Package\"),\n        AppInit             = require(\"utils/AppInit\"),\n        Async               = require(\"utils/Async\"),\n        ExtensionLoader     = require(\"utils/ExtensionLoader\"),\n        ExtensionUtils      = require(\"utils/ExtensionUtils\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        Strings             = require(\"strings\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        ThemeManager        = require(\"view/ThemeManager\"),\n        Metrics = require(\"utils/Metrics\");\n\n    const EXTENSION_REGISTRY_LOCAL_STORAGE_KEY = Phoenix.isTestWindow ?\n            \"test_extension_registry\" : \"extension_registry\",\n        EXTENSION_REGISTRY_LOCAL_STORAGE_VERSION_KEY = Phoenix.isTestWindow ?\n            \"test_extension_registry_version\" : \"extension_registry_version\";\n    // semver.browser is an AMD-compatible module\n    var semver = require(\"thirdparty/semver.browser\");\n\n    /**\n     * @private\n     * @type {$.Deferred} Keeps track of the current registry download so that if a request is already\n     * in progress and another request to download the registry comes in, we don't send yet another request.\n     * This is primarily used when multiple view models need to download the registry at the same time.\n     */\n    var pendingDownloadRegistry = null;\n\n    /**\n     * Extension status constants.\n     */\n    var ENABLED      = \"enabled\",\n        DISABLED     = \"disabled\",\n        START_FAILED = \"startFailed\";\n\n    /**\n     * Extension location constants.\n     */\n    var LOCATION_DEFAULT = \"default\",\n        LOCATION_DEV     = \"dev\",\n        LOCATION_USER    = \"user\",\n        LOCATION_UNKNOWN = \"unknown\";\n\n    /**\n     * Extension auto-install folder. Also used for preferences key.\n     */\n    var FOLDER_AUTOINSTALL = \"auto-install-extensions\";\n\n    /**\n     * @private\n     * @type {Object.<string, {metadata: Object, path: string, status: string}>}\n     * The set of all known extensions, both from the registry and locally installed.\n     * The keys are either \"name\" from package.json (for extensions that have package metadata)\n     * or the last segment of local file paths (for installed legacy extensions\n     * with no package metadata). The fields of each record are:\n     *     registryInfo: object containing the info for this id from the main registry (containing metadata, owner,\n     *         and versions). This will be null for legacy extensions.\n     *     installInfo: object containing the info for a locally-installed extension:\n     *         metadata: the package metadata loaded from the local package.json, or null if it's a legacy extension.\n     *             This will be different from registryInfo.metadata if there's a newer version in the registry.\n     *         path: the local path to the extension folder on disk\n     *         locationType: general type of installation; one of the LOCATION_* constants above\n     *         status: the current status, one of the status constants above\n     */\n    var extensions = {};\n\n    /**\n     * Requested changes to the installed extensions.\n     */\n    var _idsToRemove = {},\n        _idsToUpdate = {},\n        _idsToDisable = {};\n\n    PreferencesManager.stateManager.definePreference(FOLDER_AUTOINSTALL, \"object\", undefined);\n    PreferencesManager.definePreference(\"extensions.sort\", \"string\", \"totalDownloads\", {\n        description: Strings.SORT_EXTENSION_METHOD\n    });\n\n    /**\n     * @private\n     * Synchronizes the information between the public registry and the installed\n     * extensions. Specifically, this makes the `owner` available in each and sets\n     * an `updateAvailable` flag.\n     *\n     * @param {string} id of the extension to synchronize\n     */\n    function synchronizeEntry(id) {\n        var entry = extensions[id];\n\n        // Do nothing if we only have one set of data\n        if (!entry || !entry.installInfo || !entry.registryInfo) {\n            return;\n        }\n\n        entry.installInfo.owner = entry.registryInfo.owner;\n\n        // Assume false\n        entry.installInfo.updateAvailable   = false;\n        entry.registryInfo.updateAvailable  = false;\n        entry.installInfo.updateCompatible  = false;\n        entry.registryInfo.updateCompatible = false;\n\n        var currentVersion = entry.installInfo.metadata ? entry.installInfo.metadata.version : null;\n        if (currentVersion && semver.lt(currentVersion, entry.registryInfo.metadata.version)) {\n            // Note: available update may still be incompatible; we check for this when rendering the Update button in ExtensionManagerView._renderItem()\n            entry.registryInfo.updateAvailable  = true;\n            entry.installInfo.updateAvailable   = true;\n            // Calculate updateCompatible to check if there's an update for current version of Brackets\n            var lastCompatibleVersionInfo = _.findLast(entry.registryInfo.versions, function (versionInfo) {\n                return !versionInfo.brackets || semver.satisfies(brackets.metadata.apiVersion, versionInfo.brackets);\n            });\n            if (lastCompatibleVersionInfo && lastCompatibleVersionInfo.version && semver.lt(currentVersion, lastCompatibleVersionInfo.version)) {\n                entry.installInfo.updateCompatible        = true;\n                entry.registryInfo.updateCompatible       = true;\n                entry.installInfo.lastCompatibleVersion   = lastCompatibleVersionInfo.version;\n                entry.registryInfo.lastCompatibleVersion  = lastCompatibleVersionInfo.version;\n            }\n        }\n\n        exports.trigger(\"registryUpdate\", id);\n    }\n\n\n    /**\n     * @private\n     * Verifies if an extension is a theme based on the presence of the field \"theme\"\n     * in the package.json.  If it is a theme, then the theme file is just loaded by the\n     * ThemeManager\n     *\n     * @param {string} id of the theme extension to load\n     */\n    function loadTheme(id) {\n        var extension = extensions[id];\n        if (extension.installInfo && extension.installInfo.metadata && extension.installInfo.metadata.theme) {\n            ThemeManager.loadPackage(extension.installInfo);\n        }\n    }\n\n\n    /**\n     * @private\n     * Sets our data. For unit testing only.\n     */\n    function _setExtensions(newExtensions) {\n        exports.extensions = extensions = newExtensions;\n        Object.keys(extensions).forEach(function (id) {\n            synchronizeEntry(id);\n        });\n    }\n\n    /**\n     * @private\n     * Clears out our existing data. For unit testing only.\n     */\n    function _reset() {\n        exports.extensions = extensions = {};\n        _idsToRemove = {};\n        _idsToUpdate = {};\n        _idsToDisable = {};\n    }\n\n    function _populateExtensions(registry) {\n        Object.keys(registry).forEach(function (id) {\n            if (!extensions[id]) {\n                extensions[id] = {};\n            }\n            extensions[id].registryInfo = registry[id];\n            synchronizeEntry(id);\n        });\n        exports.trigger(\"registryDownload\");\n    }\n\n    function _shouldUpdateExtensionRegistry() {\n        return new Promise((resolve, reject)=>{\n            const currentRegistryVersion = localStorage.getItem(EXTENSION_REGISTRY_LOCAL_STORAGE_VERSION_KEY) || \"1\";\n            Metrics.countEvent(Metrics.EVENT_TYPE.EXTENSIONS, \"registryVersion\",\n                `${currentRegistryVersion}`);\n            $.ajax({\n                url: brackets.config.extension_registry_version,\n                dataType: \"json\",\n                cache: false\n            })\n                .done(function (registryVersion) {\n                    if(registryVersion.version !== parseInt(currentRegistryVersion)){\n                        resolve(registryVersion.version);\n                    } else {\n                        const registryJson = localStorage.getItem(EXTENSION_REGISTRY_LOCAL_STORAGE_KEY);\n                        if(!registryJson) {\n                            resolve(registryVersion.version);\n                            // if we dont have anything, best to atlest try to fetch the registry now.\n                            return;\n                        }\n                        reject();\n                    }\n                })\n                .fail(function (err) {\n                    console.error(\"error Fetching Extension Registry version\", err);\n                    const registryJson = localStorage.getItem(EXTENSION_REGISTRY_LOCAL_STORAGE_KEY);\n                    if(!registryJson) {\n                        resolve(1); // if we dont have anything, best to atlest try to fetch the registry now.\n                        return;\n                    }\n                    reject();\n                });\n        });\n    }\n\n    function _patchDownloadCounts() {\n        let registryJson = localStorage.getItem(EXTENSION_REGISTRY_LOCAL_STORAGE_KEY);\n        if(!registryJson){\n            return;\n        }\n        $.ajax({\n            url: brackets.config.extension_registry_popularity,\n            dataType: \"json\",\n            cache: false\n        }).done(function (popularity) {\n            registryJson = localStorage.getItem(EXTENSION_REGISTRY_LOCAL_STORAGE_KEY);\n            let registry = JSON.parse(registryJson);\n            for(let key of Object.keys(popularity)){\n                if(registry[key]) {\n                    registry[key].totalDownloads = popularity[key].totalDownloads || registry[key].totalDownloads\n                        || null; // null to not show the section if the counts are 0 or not present\n                    registry[key].gihubStars = popularity[key].gihubStars || registry[key].gihubStars\n                        || null;\n                }\n            }\n            localStorage.setItem(EXTENSION_REGISTRY_LOCAL_STORAGE_KEY, JSON.stringify(registry));\n        });\n    }\n\n    /**\n     * Downloads the registry of Brackets extensions and stores the information in our\n     * extension info.\n     *\n     * @param {boolean} force - true to fetch registry from server fresh every time\n     * @return {$.Promise} a promise that's resolved with the registry JSON data\n     * or rejected if the server can't be reached.\n     */\n    function downloadRegistry(force) {\n        if (pendingDownloadRegistry) {\n            return pendingDownloadRegistry.promise();\n        }\n\n        pendingDownloadRegistry = new $.Deferred();\n\n        function _updateRegistry(newVersion) {\n            $.ajax({\n                url: brackets.config.extension_registry,\n                dataType: \"json\",\n                cache: false\n            })\n                .done(function (registry) {\n                    localStorage.setItem(EXTENSION_REGISTRY_LOCAL_STORAGE_VERSION_KEY, newVersion);\n                    localStorage.setItem(EXTENSION_REGISTRY_LOCAL_STORAGE_KEY, JSON.stringify(registry));\n                    if(!pendingDownloadRegistry.alreadyResolvedFromCache){\n                        _populateExtensions(registry);\n                        pendingDownloadRegistry.resolve();\n                    }\n                })\n                .fail(function (err) {\n                    console.error(\"error Fetching Extension Registry\", err);\n                    if(!pendingDownloadRegistry.alreadyResolvedFromCache){\n                        pendingDownloadRegistry.reject();\n                    }\n                })\n                .always(function () {\n                    // Make sure to clean up the pending registry so that new requests can be made.\n                    pendingDownloadRegistry = null;\n                });\n        }\n\n        if(force){\n            _updateRegistry();\n            return pendingDownloadRegistry.promise();\n        }\n\n        const registryJson = localStorage.getItem(EXTENSION_REGISTRY_LOCAL_STORAGE_KEY);\n        if(registryJson) {\n            // we always immediately but after the promise chain is setup after function return (some bug sigh)\n            // resolve for ui responsiveness and then check for updates.\n            setTimeout(()=>{\n                Metrics.countEvent(Metrics.EVENT_TYPE.EXTENSIONS, \"registry\", \"cachedUse\");\n                _populateExtensions(JSON.parse(registryJson));\n                pendingDownloadRegistry.resolve();\n            }, 0);\n            pendingDownloadRegistry.alreadyResolvedFromCache = true;\n        }\n        // check for latest updates even if we have cache\n        _shouldUpdateExtensionRegistry()\n            .then(_updateRegistry)\n            .catch(()=>{\n                pendingDownloadRegistry = null;\n            });\n        _patchDownloadCounts();\n\n        return pendingDownloadRegistry.promise();\n    }\n\n\n    /**\n     * @private\n     * When an extension is loaded, fetches the package.json and stores the extension in our map.\n     * @param {$.Event} e The event object\n     * @param {string} baseURL The http base url from which the extension is loaded\n     */\n    function _handleExtensionLoad(e, baseURL) {\n        function setData(metadata) {\n            let locationType,\n                id = metadata.name,\n                userExtensionPath = ExtensionLoader.getUserExtensionPath(),\n                path = baseURL;\n            if(Phoenix.VFS.getPathForVirtualServingURL(baseURL)){\n                path = Phoenix.VFS.getPathForVirtualServingURL(baseURL);\n            }\n            metadata.title = metadata.title || metadata.name;\n            if (path.indexOf(userExtensionPath) === 0) {\n                locationType = LOCATION_USER;\n            } else {\n                var segments = path.split(\"/\"), parent;\n                if (segments.length > 2) {\n                    parent = segments[segments.length - 2];\n                }\n                if (parent === \"dev\") {\n                    locationType = LOCATION_DEV;\n                } else if (parent === \"default\") {\n                    locationType = LOCATION_DEFAULT;\n                } else if (parent === \"user\") {\n                    locationType = LOCATION_USER;\n                } else {\n                    locationType = LOCATION_UNKNOWN;\n                }\n            }\n            if (!extensions[id]) {\n                extensions[id] = {};\n            }\n            extensions[id].installInfo = {\n                metadata: metadata,\n                path: baseURL,\n                locationType: locationType,\n                status: (e.type === \"loadFailed\" ? START_FAILED : (e.type === \"disabled\" ? DISABLED : ENABLED))\n            };\n\n            synchronizeEntry(id);\n            loadTheme(id);\n            exports.trigger(\"statusChange\", id);\n        }\n\n        function deduceMetadata() {\n            const match = baseURL.match(/\\/([^\\/]+)$/),\n                name = (match && match[1]) || baseURL,\n                metadata = { name: name, title: name };\n            return metadata;\n        }\n\n        ExtensionUtils.loadMetadata(baseURL)\n            .done(function (metadata) {\n                setData(metadata);\n            })\n            .fail(function (disabled) {\n                // If there's no package.json, this is a legacy extension. It was successfully loaded,\n                // but we don't have an official ID or metadata for it, so we just create an id and\n                // \"title\" for it (which is the last segment of its pathname)\n                // and record that it's enabled.\n                var metadata = deduceMetadata();\n                metadata.disabled = disabled;\n                setData(metadata);\n            });\n    }\n\n    /**\n     * Determines if the given versions[] entry is compatible with the given Brackets API version, and if not\n     * specifies why.\n     * @param {Object} extVersion\n     * @param {string} apiVersion\n     * @return {{isCompatible: boolean, requiresNewer: ?boolean, compatibleVersion: ?string}}\n     */\n    function getCompatibilityInfoForVersion(extVersion, apiVersion) {\n        var requiredVersion = (extVersion.brackets || (extVersion.engines && extVersion.engines.brackets)),\n            result = {};\n        result.isCompatible = !requiredVersion || semver.satisfies(apiVersion, requiredVersion);\n        if (result.isCompatible) {\n            result.compatibleVersion = extVersion.version;\n        } else {\n            // Find out reason for incompatibility\n            if (requiredVersion.charAt(0) === '<') {\n                result.requiresNewer = false;\n            } else if (requiredVersion.charAt(0) === '>') {\n                result.requiresNewer = true;\n            } else if (requiredVersion.charAt(0) === \"~\") {\n                var compareVersion = requiredVersion.slice(1);\n                // Need to add .0s to this style of range in order to compare (since valid version\n                // numbers must have major/minor/patch).\n                if (compareVersion.match(/^[0-9]+$/)) {\n                    compareVersion += \".0.0\";\n                } else if (compareVersion.match(/^[0-9]+\\.[0-9]+$/)) {\n                    compareVersion += \".0\";\n                }\n                result.requiresNewer = semver.lt(apiVersion, compareVersion);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Finds the newest version of the entry that is compatible with the given Brackets API version, if any.\n     * @param {Object} entry The registry entry to check.\n     * @param {string} apiVersion The Brackets API version to check against.\n     * @return {{isCompatible: boolean, requiresNewer: ?boolean, compatibleVersion: ?string, isLatestVersion: boolean}}\n     *      Result contains an \"isCompatible\" member saying whether it's compatible. If compatible, \"compatibleVersion\"\n     *      specifies the newest version that is compatible and \"isLatestVersion\" indicates if this is the absolute\n     *      latest version of the extension or not. If !isCompatible or !isLatestVersion, \"requiresNewer\" says whether\n     *      the latest version is incompatible due to requiring a newer (vs. older) version of Brackets.\n     */\n    function getCompatibilityInfo(entry, apiVersion) {\n        if (!entry.versions) {\n            var fallback = getCompatibilityInfoForVersion(entry.metadata, apiVersion);\n            if (fallback.isCompatible) {\n                fallback.isLatestVersion = true;\n            }\n            return fallback;\n        }\n\n        var i = entry.versions.length - 1,\n            latestInfo = getCompatibilityInfoForVersion(entry.versions[i], apiVersion);\n\n        if (latestInfo.isCompatible) {\n            latestInfo.isLatestVersion = true;\n            return latestInfo;\n        }\n            // Look at earlier versions (skipping very latest version since we already checked it)\n        for (i--; i >= 0; i--) {\n            var compatInfo = getCompatibilityInfoForVersion(entry.versions[i], apiVersion);\n            if (compatInfo.isCompatible) {\n                compatInfo.isLatestVersion = false;\n                compatInfo.requiresNewer = latestInfo.requiresNewer;\n                return compatInfo;\n            }\n        }\n\n            // No version is compatible, so just return info for the latest version\n        return latestInfo;\n\n    }\n\n    /**\n     * Given an extension id and version number, returns the URL for downloading that extension from\n     * the repository. Does not guarantee that the extension exists at that URL.\n     * @param {string} id The extension's name from the metadata.\n     * @param {string} version The version to download.\n     * @return {string} The URL to download the extension from.\n     */\n    function getExtensionURL(id, version) {\n        return `${brackets.config.extension_url}${id}-${version}.zip`;\n    }\n\n    /**\n     * Removes the installed extension with the given id.\n     * @param {string} id The id of the extension to remove.\n     * @return {$.Promise} A promise that's resolved when the extension is removed or\n     *     rejected with an error if there's a problem with the removal.\n     */\n    function remove(id) {\n        var result = new $.Deferred();\n        if (extensions[id] && extensions[id].installInfo) {\n            Package.remove(extensions[id].installInfo.path)\n                .done(function () {\n                    extensions[id].installInfo = null;\n                    result.resolve();\n                    exports.trigger(\"statusChange\", id);\n                })\n                .fail(function (err) {\n                    result.reject(err);\n                });\n        } else {\n            result.reject(StringUtils.format(Strings.EXTENSION_NOT_INSTALLED, id));\n        }\n        return result.promise();\n    }\n\n    /**\n     * @private\n     *\n     * Disables or enables the installed extensions.\n     *\n     * @param {string} id The id of the extension to disable or enable.\n     * @param {boolean} enable A boolean indicating whether to enable or disable.\n     * @return {$.Promise} A promise that's resolved when the extension action is\n     *      completed or rejected with an error that prevents the action from completion.\n     */\n    function _enableOrDisable(id, enable) {\n        var result = new $.Deferred(),\n            extension = extensions[id];\n        if (extension && extension.installInfo) {\n            Package[(enable ? \"enable\" : \"disable\")](extension.installInfo.path)\n                .done(function () {\n                    extension.installInfo.status = enable ? ENABLED : DISABLED;\n                    extension.installInfo.metadata.disabled = !enable;\n                    result.resolve();\n                    exports.trigger(\"statusChange\", id);\n                })\n                .fail(function (err) {\n                    result.reject(err);\n                });\n        } else {\n            result.reject(StringUtils.format(Strings.EXTENSION_NOT_INSTALLED, id));\n        }\n        return result.promise();\n    }\n\n    /**\n     * Disables the installed extension with the given id.\n     *\n     * @param {string} id The id of the extension to disable.\n     * @return {$.Promise} A promise that's resolved when the extenion is disabled or\n     *      rejected with an error that prevented the disabling.\n     */\n    function disable(id) {\n        return _enableOrDisable(id, false);\n    }\n\n    /**\n     * Enables the installed extension with the given id.\n     *\n     * @param {string} id The id of the extension to enable.\n     * @return {$.Promise} A promise that's resolved when the extenion is enabled or\n     *      rejected with an error that prevented the enabling.\n     */\n    function enable(id) {\n        return _enableOrDisable(id, true);\n    }\n\n    /**\n     * Updates an installed extension with the given package file.\n     * @param {string} id of the extension\n     * @param {string} packagePath path to the package file\n     * @param {boolean=} keepFile Flag to keep extension package file, default=false\n     * @return {$.Promise} A promise that's resolved when the extension is updated or\n     *     rejected with an error if there's a problem with the update.\n     */\n    function update(id, packagePath, keepFile) {\n        return Package.installUpdate(packagePath, id).done(function () {\n            if (!keepFile) {\n                FileSystem.getFileForPath(packagePath).unlink();\n            }\n        });\n    }\n\n    /**\n     * Deletes any temporary files left behind by extensions that\n     * were marked for update.\n     */\n    function cleanupUpdates() {\n        Object.keys(_idsToUpdate).forEach(function (id) {\n            var installResult = _idsToUpdate[id],\n                keepFile = installResult.keepFile,\n                filename = installResult.localPath;\n\n            if (filename && !keepFile) {\n                FileSystem.getFileForPath(filename).unlink();\n            }\n        });\n        _idsToUpdate = {};\n    }\n\n    /**\n     * Unmarks all extensions marked for removal.\n     */\n    function unmarkAllForRemoval() {\n        _idsToRemove = {};\n    }\n\n    /**\n     * Marks an extension for later removal, or unmarks an extension previously marked.\n     * @param {string} id The id of the extension to mark for removal.\n     * @param {boolean} mark Whether to mark or unmark it.\n     */\n    function markForRemoval(id, mark) {\n        if (mark) {\n            _idsToRemove[id] = true;\n        } else {\n            delete _idsToRemove[id];\n        }\n        exports.trigger(\"statusChange\", id);\n    }\n\n    /**\n     * Returns true if an extension is marked for removal.\n     * @param {string} id The id of the extension to check.\n     * @return {boolean} true if it's been marked for removal, false otherwise.\n     */\n    function isMarkedForRemoval(id) {\n        return !!(_idsToRemove[id]);\n    }\n\n    /**\n     * Returns true if there are any extensions marked for removal.\n     * @return {boolean} true if there are extensions to remove\n     */\n    function hasExtensionsToRemove() {\n        return Object.keys(_idsToRemove).length > 0;\n    }\n\n    /**\n     * Marks an extension for disabling later, or unmarks an extension previously marked.\n     *\n     * @param {string} id The id of the extension\n     * @param {boolean} mark Whether to mark or unmark the extension.\n     */\n    function markForDisabling(id, mark) {\n        if (mark) {\n            _idsToDisable[id] = true;\n        } else {\n            delete _idsToDisable[id];\n        }\n        exports.trigger(\"statusChange\", id);\n    }\n\n    /**\n     * Returns true if an extension is mark for disabling.\n     *\n     * @param {string} id The id of the extension to check.\n     * @return {boolean} true if it's been mark for disabling, false otherwise.\n     */\n    function isMarkedForDisabling(id) {\n        return !!(_idsToDisable[id]);\n    }\n\n    /**\n     * Returns true if there are any extensions marked for disabling.\n     * @return {boolean} true if there are extensions to disable\n     */\n    function hasExtensionsToDisable() {\n        return Object.keys(_idsToDisable).length > 0;\n    }\n\n    /**\n     * Unmarks all the extensions that have been marked for disabling.\n     */\n    function unmarkAllForDisabling() {\n        _idsToDisable = {};\n    }\n\n    /**\n     * If a downloaded package appears to be an update, mark the extension for update.\n     * If an extension was previously marked for removal, marking for update will\n     * turn off the removal mark.\n     * @param {Object} installationResult info about the install provided by the Package.download function\n     */\n    function updateFromDownload(installationResult) {\n        if (installationResult.keepFile === undefined) {\n            installationResult.keepFile = false;\n        }\n\n        var installationStatus = installationResult.installationStatus;\n        if (installationStatus === Package.InstallationStatuses.ALREADY_INSTALLED ||\n                installationStatus === Package.InstallationStatuses.NEEDS_UPDATE ||\n                installationStatus === Package.InstallationStatuses.SAME_VERSION ||\n                installationStatus === Package.InstallationStatuses.OLDER_VERSION) {\n            var id = installationResult.name;\n            delete _idsToRemove[id];\n            _idsToUpdate[id] = installationResult;\n            exports.trigger(\"statusChange\", id);\n        }\n    }\n\n    /**\n     * Removes the mark for an extension to be updated on restart. Also deletes the\n     * downloaded package file.\n     * @param {string} id The id of the extension for which the update is being removed\n     */\n    function removeUpdate(id) {\n        var installationResult = _idsToUpdate[id];\n        if (!installationResult) {\n            return;\n        }\n        if (installationResult.localPath && !installationResult.keepFile) {\n            FileSystem.getFileForPath(installationResult.localPath).unlink();\n        }\n        delete _idsToUpdate[id];\n        exports.trigger(\"statusChange\", id);\n    }\n\n    /**\n     * Returns true if an extension is marked for update.\n     * @param {string} id The id of the extension to check.\n     * @return {boolean} true if it's been marked for update, false otherwise.\n     */\n    function isMarkedForUpdate(id) {\n        return !!(_idsToUpdate[id]);\n    }\n\n    /**\n     * Returns true if there are any extensions marked for update.\n     * @return {boolean} true if there are extensions to update\n     */\n    function hasExtensionsToUpdate() {\n        return Object.keys(_idsToUpdate).length > 0;\n    }\n\n    /**\n     * Removes extensions previously marked for removal.\n     * @return {$.Promise} A promise that's resolved when all extensions are removed, or rejected\n     *     if one or more extensions can't be removed. When rejected, the argument will be an\n     *     array of error objects, each of which contains an \"item\" property with the id of the\n     *     failed extension and an \"error\" property with the actual error.\n     */\n    function removeMarkedExtensions() {\n        return Async.doInParallel_aggregateErrors(\n            Object.keys(_idsToRemove),\n            function (id) {\n                return remove(id);\n            }\n        );\n    }\n\n    /**\n     * Disables extensions marked for disabling.\n     *\n     * If the return promise is rejected, the argument will contain an array of objects. Each\n     * element is an object identifying the extension failed with \"item\" property set to the\n     * extension id which has failed to be disabled and \"error\" property set to the error.\n     *\n     * @return {$.Promise} A promise that's resolved when all extensions marked for disabling are\n     *      disabled or rejected if one or more extensions can't be disabled.\n     */\n    function disableMarkedExtensions() {\n        return Async.doInParallel_aggregateErrors(\n            Object.keys(_idsToDisable),\n            function (id) {\n                return disable(id);\n            }\n        );\n    }\n\n    /**\n     * Updates extensions previously marked for update.\n     * @return {$.Promise} A promise that's resolved when all extensions are updated, or rejected\n     *     if one or more extensions can't be updated. When rejected, the argument will be an\n     *     array of error objects, each of which contains an \"item\" property with the id of the\n     *     failed extension and an \"error\" property with the actual error.\n     */\n    function updateExtensions() {\n        return Async.doInParallel_aggregateErrors(\n            Object.keys(_idsToUpdate),\n            function (id) {\n                var installationResult = _idsToUpdate[id];\n                return update(installationResult.name, installationResult.localPath, installationResult.keepFile);\n            }\n        );\n    }\n\n    /**\n     * Gets an array of extensions that are currently installed and can be updated to a new version\n     * @return {Array.<{id: string, installVersion: string, registryVersion: string}>}\n     *     where id = extensionId\n     *     installVersion = currently installed version of extension\n     *     registryVersion = latest version compatible with current Brackets\n     */\n    function getAvailableUpdates() {\n        var result = [];\n        Object.keys(extensions).forEach(function (extensionId) {\n            var extensionInfo = extensions[extensionId];\n            // skip extensions that are not installed or are not in the registry\n            if (!extensionInfo.installInfo || !extensionInfo.registryInfo) {\n                return;\n            }\n            if (extensionInfo.registryInfo.updateCompatible) {\n                result.push({\n                    id: extensionId,\n                    installVersion: extensionInfo.installInfo.metadata.version,\n                    registryVersion: extensionInfo.registryInfo.lastCompatibleVersion\n                });\n            }\n        });\n        return result;\n    }\n\n    /**\n     * Takes the array returned from getAvailableUpdates() as an input and removes those entries\n     * that are no longer current - when currently installed version of an extension\n     * is equal or newer than registryVersion returned by getAvailableUpdates().\n     * This function is designed to work without the necessity to download extension registry\n     * @param {Array.<{id: string, installVersion: string, registryVersion: string}>} updates\n     *     previous output of getAvailableUpdates()\n     * @return {Array.<{id: string, installVersion: string, registryVersion: string}>}\n     *     filtered input as function description\n     */\n    function cleanAvailableUpdates(updates) {\n        return updates.reduce(function (arr, updateInfo) {\n            var extDefinition = extensions[updateInfo.id];\n            if (!extDefinition || !extDefinition.installInfo) {\n                // extension has been uninstalled in the meantime\n                return arr;\n            }\n\n            var installedVersion = extDefinition.installInfo.metadata.version;\n            if (semver.lt(installedVersion, updateInfo.registryVersion)) {\n                arr.push(updateInfo);\n            }\n\n            return arr;\n        }, []);\n    }\n\n    AppInit.appReady(function () {\n    });\n\n    // Listen to extension load and loadFailed events\n    ExtensionLoader\n        .on(ExtensionLoader.EVENT_EXTENSION_LOADED, _handleExtensionLoad)\n        .on(ExtensionLoader.EVENT_EXTENSION_LOAD_FAILED, _handleExtensionLoad)\n        .on(ExtensionLoader.EVENT_EXTENSION_DISABLED, _handleExtensionLoad);\n\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // Public exports\n    exports.downloadRegistry        = downloadRegistry;\n    exports.getCompatibilityInfo    = getCompatibilityInfo;\n    exports.getExtensionURL         = getExtensionURL;\n    exports.remove                  = remove;\n    exports.update                  = update;\n    exports.disable                 = disable;\n    exports.enable                  = enable;\n    exports.extensions              = extensions;\n    exports.cleanupUpdates          = cleanupUpdates;\n    exports.markForRemoval          = markForRemoval;\n    exports.isMarkedForRemoval      = isMarkedForRemoval;\n    exports.unmarkAllForRemoval     = unmarkAllForRemoval;\n    exports.hasExtensionsToRemove   = hasExtensionsToRemove;\n    exports.markForDisabling        = markForDisabling;\n    exports.isMarkedForDisabling    = isMarkedForDisabling;\n    exports.unmarkAllForDisabling   = unmarkAllForDisabling;\n    exports.hasExtensionsToDisable  = hasExtensionsToDisable;\n    exports.updateFromDownload      = updateFromDownload;\n    exports.removeUpdate            = removeUpdate;\n    exports.isMarkedForUpdate       = isMarkedForUpdate;\n    exports.hasExtensionsToUpdate   = hasExtensionsToUpdate;\n    exports.removeMarkedExtensions  = removeMarkedExtensions;\n    exports.disableMarkedExtensions = disableMarkedExtensions;\n    exports.updateExtensions        = updateExtensions;\n    exports.getAvailableUpdates     = getAvailableUpdates;\n    exports.cleanAvailableUpdates   = cleanAvailableUpdates;\n\n    exports.ENABLED       = ENABLED;\n    exports.DISABLED      = DISABLED;\n    exports.START_FAILED  = START_FAILED;\n\n    exports.LOCATION_DEFAULT  = LOCATION_DEFAULT;\n    exports.LOCATION_DEV      = LOCATION_DEV;\n    exports.LOCATION_USER     = LOCATION_USER;\n    exports.LOCATION_UNKNOWN  = LOCATION_UNKNOWN;\n\n    // For unit testing only\n    exports._reset                  = _reset;\n    exports._setExtensions          = _setExtensions;\n    if(Phoenix.isTestWindow){\n        exports.EXTENSION_REGISTRY_LOCAL_STORAGE_KEY = EXTENSION_REGISTRY_LOCAL_STORAGE_KEY;\n    }\n});\n"],"file":"ExtensionManager.js"}
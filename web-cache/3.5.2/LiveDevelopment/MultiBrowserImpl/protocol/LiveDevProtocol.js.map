{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol.js"],"names":["define","require","exports","module","EventDispatcher","LiveDevProtocolRemote","DocumentObserver","RemoteFunctions","EditorManager","LiveDevMultiBrowser","PreferencesManager","HTMLInstrumentation","StringUtils","FileViewController","LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME","randomString","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","EVENT_LIVE_PREVIEW_CLICKED","EVENT_LIVE_PREVIEW_RELOAD","_connections","_transport","_nextMsgId","_responseDeferreds","getConnectionIds","Object","keys","_focusEditorIfNeeded","editor","tagName","contentEditable","focusShouldBeInLivePreview","includes","focus","_tagSelectedInLivePreview","tagId","nodeName","highlightPref","getViewState","liveDoc","getCurrentLiveDoc","getActiveEditor","liveDocPath","doc","file","fullPath","activeEditorDocPath","document","selectInActiveDocument","activeEditor","activeFullEditor","getCurrentFullEditor","position","getPositionFromTagId","parseInt","setCursorPos","line","ch","openAndSelectDocument","PROJECT_MANAGER","done","_receive","clientId","msgStr","msg","JSON","parse","event","method","deferred","id","error","reject","resolve","clicked","trigger","_send","clients","result","$","Deferred","send","stringify","promise","_connect","url","_close","setTransport","transport","off","on","start","_getRemoteFunctionsScript","script","config","getRemoteScriptContents","transportScript","getRemoteScript","remoteFunctionsScript","evaluate","params","expression","setStylesheetText","text","getStylesheetText","reload","ignoreCache","close","closeAllConnections","forEach","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Provides the protocol that Brackets uses to talk to a browser instance for live development.\n * Protocol methods are converted to a JSON message format, which is then sent over a provided\n * low-level transport and interpreted in the browser. For messages that expect a response, the\n * response is returned through a promise as an object. Scripts that implement remote logic are\n * provided during the instrumentation stage by \"getRemoteFunctions()\".\n *\n * Events raised by the remote browser are dispatched as jQuery events which type is equal to the 'method'\n * property. The received message object is dispatched as the first parameter and enriched with a\n * 'clientId' property being the client ID of the remote browser.\n *\n * It keeps active connections which are  updated when receiving \"connect\" and \"close\" from the\n * underlying transport. Events \"Connection.connect\"/\"Connection.close\" are triggered as\n * propagation of transport's \"connect\"/\"close\".\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    const EventDispatcher = require(\"utils/EventDispatcher\");\n\n    // Text of the script we'll inject into the browser that handles protocol requests.\n    const LiveDevProtocolRemote = require(\"text!LiveDevelopment/BrowserScripts/LiveDevProtocolRemote.js\"),\n        DocumentObserver      = require(\"text!LiveDevelopment/BrowserScripts/DocumentObserver.js\"),\n        RemoteFunctions       = require(\"text!LiveDevelopment/BrowserScripts/RemoteFunctions.js\"),\n        EditorManager         = require(\"editor/EditorManager\"),\n        LiveDevMultiBrowser   = require(\"LiveDevelopment/LiveDevMultiBrowser\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        HTMLInstrumentation   = require(\"LiveDevelopment/MultiBrowserImpl/language/HTMLInstrumentation\"),\n        StringUtils = require(\"utils/StringUtils\"),\n        FileViewController    = require(\"project/FileViewController\");\n\n    const LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME = `phoenix_live_preview_scripts_instrumented_${StringUtils.randomString(8)}.js`;\n    const LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME = `pageLoaderWorker_${StringUtils.randomString(8)}.js`;\n\n    const EVENT_LIVE_PREVIEW_CLICKED = \"livePreviewClicked\",\n        EVENT_LIVE_PREVIEW_RELOAD = \"livePreviewReload\";\n\n    /**\n     * @private\n     * Active connections.\n     * @type {Object}\n     */\n    var _connections = {};\n\n    /**\n     * @private\n     * The low-level transport we're communicating over, set by `setTransport()`.\n     * @type {{start: function(), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}}\n     */\n    var _transport = null;\n\n    /**\n     * @private\n     * A unique message serial number, used to match up responses with request messages.\n     * @type {number}\n     */\n    var _nextMsgId = 1;\n\n    /**\n     * @private\n     * A map of response IDs to deferreds, for messages that are awaiting responses.\n     * @type {Object}\n     */\n    var _responseDeferreds = {};\n\n    /**\n     * Returns an array of the client IDs that are being managed by this live document.\n     * @return {Array.<number>}\n     */\n    function getConnectionIds() {\n        return Object.keys(_connections);\n    }\n\n    /**\n     * When user clicks on text boxes or other focusable keyboard elements in live preview, we should not\n     * set focus to editor\n     * @private\n     */\n    function _focusEditorIfNeeded(editor, tagName, contentEditable) {\n        const focusShouldBeInLivePreview = ['INPUT', 'TEXTAREA'].includes(tagName) || contentEditable;\n        if(focusShouldBeInLivePreview){\n            return;\n        }\n        editor.focus();\n    }\n\n    function _tagSelectedInLivePreview(tagId, nodeName, contentEditable) {\n        const highlightPref = PreferencesManager.getViewState(\"livedevHighlight\");\n        if(!highlightPref){\n            // live preview highlight and reverse highlight feature is disabled\n            return;\n        }\n        const liveDoc = LiveDevMultiBrowser.getCurrentLiveDoc(),\n            editor = EditorManager.getActiveEditor();\n        const liveDocPath = liveDoc ? liveDoc.doc.file.fullPath : null,\n            activeEditorDocPath = editor ? editor.document.file.fullPath : null;\n        function selectInActiveDocument() {\n            // activeEditor can be either a full or inline(Eg. css inline within html) editor\n            const activeEditor = EditorManager.getActiveEditor();\n            const activeFullEditor = EditorManager.getCurrentFullEditor(); // always full editor\n            const position = HTMLInstrumentation.getPositionFromTagId(activeFullEditor, parseInt(tagId, 10));\n            // should we scan all editors for the file path and update selections on every editor?\n            // currently we do it only for active / full editor.\n            if(position &&\n                activeEditor && activeEditor.document.file.fullPath === activeFullEditor.document.file.fullPath) {\n                activeEditor.setCursorPos(position.line, position.ch, true);\n                _focusEditorIfNeeded(activeEditor, nodeName, contentEditable);\n            }\n            if(position && activeFullEditor) {\n                activeFullEditor.setCursorPos(position.line, position.ch, true);\n                _focusEditorIfNeeded(activeFullEditor, nodeName, contentEditable);\n            }\n        }\n        if(liveDocPath && liveDocPath !== activeEditorDocPath) {\n            FileViewController.openAndSelectDocument(liveDocPath, FileViewController.PROJECT_MANAGER)\n                .done(selectInActiveDocument);\n        } else {\n            selectInActiveDocument();\n        }\n    }\n\n    /**\n     * @private\n     * Handles a message received from the remote protocol handler via the transport.\n     * If the message has an `id` field, it's assumed to be a response to a previous\n     * request, and will be passed along to the original promise returned by `_send()`.\n     * Otherwise, it's treated as an event and dispatched.\n     * TODO: we should probably have a way of returning the results from all clients, not just the first?\n     *\n     * @param {number} clientId ID of the client that sent the message\n     * @param {string} msg The message that was sent, in JSON string format\n     */\n    function _receive(clientId, msgStr) {\n        var msg = JSON.parse(msgStr),\n            event = msg.method || \"event\",\n            deferred;\n        if (msg.id) {\n            deferred = _responseDeferreds[msg.id];\n            if (deferred) {\n                delete _responseDeferreds[msg.id];\n                if (msg.error) {\n                    deferred.reject(msg);\n                } else {\n                    deferred.resolve(msg);\n                }\n            }\n        } else if (msg.clicked && msg.tagId) {\n            _tagSelectedInLivePreview(msg.tagId, msg.nodeName, msg.contentEditable);\n            exports.trigger(EVENT_LIVE_PREVIEW_CLICKED, msg);\n        } else {\n            // enrich received message with clientId\n            msg.clientId = clientId;\n            exports.trigger(event, msg);\n        }\n    }\n\n    /**\n     * @private\n     * Dispatches a message to the remote protocol handler via the transport.\n     *\n     * @param {Object} msg The message to send.\n     * @param {number|Array.<number>} idOrArray ID or IDs of the client(s) that should\n     *     receive the message.\n     * @return {$.Promise} A promise that's fulfilled when the response to the message is received.\n     */\n    function _send(msg, clients) {\n        var id = _nextMsgId++,\n            result = new $.Deferred();\n\n        // broadcast if there are no specific clients\n        clients = clients || getConnectionIds();\n        msg.id = id;\n        _responseDeferreds[id] = result;\n        _transport.send(clients, JSON.stringify(msg));\n        return result.promise();\n    }\n\n     /**\n     * @private\n     * Handles when a connection is made to the live development protocol handler.\n     * Injects the RemoteFunctions script in order to provide highlighting and live DOM editing functionality.\n     * Records the connection's client ID and triggers the \"Coonnection.connect\" event.\n     * @param {number} clientId\n     * @param {string} url\n     */\n    function _connect(clientId, url) {\n        // add new connections\n        // TODO: check URL\n        _connections[clientId] = true;\n\n        exports.trigger(\"ConnectionConnect\", {\n            clientId: clientId,\n            url: url\n        });\n    }\n\n    /**\n     * @private\n     * Handles when a connection is closed.\n     * @param {number} clientId\n     */\n    function _close(clientId) {\n        if(!_connections[clientId]){\n            return;\n        }\n        delete _connections[clientId];\n        exports.trigger(\"ConnectionClose\", {\n            clientId: clientId\n        });\n    }\n\n\n    /**\n     * Sets the transport that should be used by the protocol. See `LiveDevelopment.setTransport()`\n     * for more detail on the transport.\n     * @param {{start: function(string), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}} transport\n     */\n    function setTransport(transport) {\n        if (_transport) {\n            _transport.off(\".livedev\");\n        }\n        _transport = transport;\n\n        _transport\n            .on(\"connect.livedev\", function (event, msg) {\n                _connect(msg[0], msg[1]);\n            })\n            .on(\"message.livedev\", function (event, msg) {\n                _receive(msg[0], msg[1]);\n            })\n            .on(\"close.livedev\", function (event, msg) {\n                _close(msg[0]);\n            });\n        _transport.start();\n    }\n\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to implement remote commands that handle protocol requests.\n     * Includes the <script> tags.\n     * @return {string}\n     */\n    function _getRemoteFunctionsScript() {\n        let script = \"\";\n        // Inject DocumentObserver into the browser (tracks related documents)\n        script += DocumentObserver;\n        // Inject remote functions into the browser.\n        script += \"\\nwindow._LD=(\" + RemoteFunctions + \"(\" + JSON.stringify(LiveDevMultiBrowser.config) + \"))\";\n        return \"\\n\" + script + \"\\n\";\n    }\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to handle protocol requests. Includes the <script> tags.\n     * This script will also include the script required by the transport, if any.\n     * @return {string}\n     */\n    function getRemoteScriptContents() {\n        const transportScript = _transport.getRemoteScript() || \"\";\n        const remoteFunctionsScript = _getRemoteFunctionsScript() || \"\";\n        return transportScript +\n            \"\\n\" + LiveDevProtocolRemote + \"\\n\" +\n            remoteFunctionsScript;\n    }\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to handle protocol requests. Includes the <script> tags.\n     * This script will also include the script required by the transport, if any.\n     * @return {string}\n     */\n    function getRemoteScript() {\n        // give a wrong random file name that wont have a possibility of an actual file name\n        return `\\n\\t\\t<script src=\"${LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME}\"></script>`;\n    }\n\n    /**\n     * Protocol method. Evaluates the given script in the browser (in global context), and returns a promise\n     * that will be fulfilled with the result of the script, if any.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should evaluate\n     *      the script.\n     * @param {string} script The script to evaluate.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the evaluation.\n     */\n    function evaluate(script, clients) {\n        return _send(\n            {\n                method: \"Runtime.evaluate\",\n                params: {\n                    expression: script\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Reloads a CSS styleseet in the browser (by replacing its text) given its url.\n     * @param {string} url Absolute URL of the stylesheet\n     * @param {string} text The new text of the stylesheet\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should evaluate\n     *      the script.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the evaluation.\n     */\n    function setStylesheetText(url, text, clients) {\n        return _send(\n            {\n                method: \"CSS.setStylesheetText\",\n                params: {\n                    url: url,\n                    text: text\n                }\n            }\n        );\n    }\n\n     /**\n     * Protocol method. Rretrieves the content of a given stylesheet (for unit testing)\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should navigate to the given URL.\n     * @param {string} url Absolute URL that identifies the stylesheet.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function getStylesheetText(url, clients) {\n        return _send(\n            {\n                method: \"CSS.getStylesheetText\",\n                params: {\n                    url: url\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Reloads the page that is currently loaded into the browser, optionally ignoring cache.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should reload the page.\n     * @param {boolean} ignoreCache If true, browser cache is ignored.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function reload(ignoreCache, clients) {\n        exports.trigger(EVENT_LIVE_PREVIEW_RELOAD, clients);\n        return _send(\n            {\n                method: \"Page.reload\",\n                params: {\n                    ignoreCache: true\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Closes the connection to the given client. Proxies to the transport.\n     * @param {number} clientId\n     */\n    function close(clientId) {\n        _transport.close(clientId);\n    }\n\n    function closeAllConnections() {\n        getConnectionIds().forEach(function (clientId) {\n            close(clientId);\n        });\n        _connections = {};\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // public API\n    exports.setTransport = setTransport;\n    exports.getRemoteScript = getRemoteScript;\n    exports.getRemoteScriptContents = getRemoteScriptContents;\n    exports.evaluate = evaluate;\n    exports.setStylesheetText = setStylesheetText;\n    exports.getStylesheetText = getStylesheetText;\n    exports.reload = reload;\n    exports.close = close;\n    exports.getConnectionIds = getConnectionIds;\n    exports.closeAllConnections = closeAllConnections;\n    exports.LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME = LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME;\n    exports.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME = LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME;\n    exports.EVENT_LIVE_PREVIEW_CLICKED = EVENT_LIVE_PREVIEW_CLICKED;\n    exports.EVENT_LIVE_PREVIEW_RELOAD = EVENT_LIVE_PREVIEW_RELOAD;\n});\n"],"file":"LiveDevProtocol.js"}
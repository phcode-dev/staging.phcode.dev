{"version":3,"sources":["utils/StringMatch.js"],"names":["define","require","exports","module","_","SearchResult","label","this","findSpecialCharacters","str","i","c","specials","lastSegmentSpecialsIndex","lastWasLowerCase","length","push","toUpperCase","SPECIALS_MATCH","ANY_MATCH","DEBUG_SCORES","_setDebugScores","ds","SPECIAL_POINTS","MATCH_POINTS","UPPER_CASE_MATCH","CONSECUTIVE_MATCHES_POINTS","BEGINNING_OF_NAME_POINTS","LAST_SEGMENT_BOOST","DEDUCTION_FOR_LENGTH","NOT_STARTING_ON_SPECIAL_PENALTY","SpecialMatch","index","upper","NormalMatch","_generateMatchList","query","originalQuery","originalStr","startingSpecial","result","specialsCounter","strCounter","queryCounter","deadBranches","Infinity","state","findMatchingSpecial","backtrack","item","pop","_lastSegmentSearch","lastSegmentStart","matchList","remainder","originalRemainder","extraCharacters","substring","_wholeStringSearch","queryLower","compareLower","remainderMatchList","slice","unshift","apply","_computeRangesAndScore","matchCounter","ranges","lastMatchIndex","lastSegmentScore","currentRangeStartedOnSpecial","score","scoreDebug","special","match","lastSegment","beginning","lengthDeduction","consecutive","notStartingOnSpecial","currentRange","closeRangeGap","includesLastSegment","matched","text","numConsecutive","addMatch","newPoints","boost","lengthPenalty","Math","round","matchGoodness","_prefixMatchResult","Number","MAX_VALUE","substr","stringRanges","stringMatch","options","toLowerCase","preferPrefixMatches","segmentedSearch","compareData","multiFieldSort","searchResults","fieldSpec","comparisons","Array","isArray","forEach","priority","key","sort","a","b","comparison","valueA","valueB","basicMatchSort","StringMatcher","reset","prototype","_specialsCache","_noMatchCache","_lastQuery","has","undefined","_findSpecialCharacters","_SpecialMatch","_NormalMatch"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: StringMatch */\n\ndefine(function (require, exports, module) {\n\n\n    var _ = require(\"thirdparty/lodash\");\n\n    /*\n     * Performs matching that is useful for QuickOpen and similar searches.\n     */\n\n    /** Object representing a search result with associated metadata (added as extra ad hoc fields) */\n    function SearchResult(label) {\n        this.label = label;\n    }\n\n\n\n    /*\n     * Identifies the \"special\" characters in the given string.\n     * Special characters for matching purposes are:\n     *\n     * * the first character\n     * * \"/\" and the character following the \"/\"\n     * * \"_\", \".\" and \"-\" and the character following it\n     * * an uppercase character that follows a lowercase one (think camelCase)\n     *\n     * The returned object contains an array called \"specials\". This array is\n     * a list of indexes into the original string where all of the special\n     * characters are. It also has a property \"lastSegmentSpecialsIndex\" which\n     * is an index into the specials array that denotes which location is the\n     * beginning of the last path segment. (This is used to allow scanning of\n     * the last segment's specials separately.)\n     *\n     * @param {string} input string to break apart (e.g. filename that is being searched)\n     * @return {{specials:Array.<number>, lastSegmentSpecialsIndex:number}}\n     */\n    function findSpecialCharacters(str) {\n        var i, c;\n\n        // the beginning of the string is always special\n        var specials = [0];\n\n        // lastSegmentSpecialsIndex starts off with the assumption that\n        // there are no segments\n        var lastSegmentSpecialsIndex = 0;\n\n        // used to track down the camelCase changeovers\n        var lastWasLowerCase = false;\n\n        for (i = 0; i < str.length; i++) {\n            c = str[i];\n            if (c === \"/\") {\n                // new segment means this character and the next are special\n                specials.push(i++);\n                specials.push(i);\n                lastSegmentSpecialsIndex = specials.length - 1;\n                lastWasLowerCase = false;\n            } else if (c === \".\" || c === \"-\" || c === \"_\") {\n                // _, . and - are separators so they are\n                // special and so is the next character\n                specials.push(i);\n                if (str[i + 1] !== \"/\") {\n                    // if the next key is a slash, handle it separately\n                    // see #10871\n                    specials.push(++i);\n                }\n                lastWasLowerCase = false;\n            } else if (c.toUpperCase() === c) {\n                // this is the check for camelCase changeovers\n                if (lastWasLowerCase) {\n                    specials.push(i);\n                }\n                lastWasLowerCase = false;\n            } else {\n                lastWasLowerCase = true;\n            }\n        }\n        return {\n            specials: specials,\n            lastSegmentSpecialsIndex: lastSegmentSpecialsIndex\n        };\n    }\n\n    // states used during the scanning of the string\n    var SPECIALS_MATCH = 0;\n    var ANY_MATCH = 1;\n\n    // Scores can be hard to make sense of. The DEBUG_SCORES flag\n    // provides a way to peek into the parts that made up a score.\n    // This flag is used for manual debugging and in the unit tests only.\n    var DEBUG_SCORES = false;\n    function _setDebugScores(ds) {\n        DEBUG_SCORES = ds;\n    }\n\n\n    // Constants for scoring\n    var SPECIAL_POINTS = 40;\n    var MATCH_POINTS = 10;\n    var UPPER_CASE_MATCH = 100;\n    var CONSECUTIVE_MATCHES_POINTS = 8;\n    var BEGINNING_OF_NAME_POINTS = 13;\n    var LAST_SEGMENT_BOOST = 1;\n    var DEDUCTION_FOR_LENGTH = 0.2;\n    var NOT_STARTING_ON_SPECIAL_PENALTY = 25;\n\n    // Used in match lists to designate matches of \"special\" characters (see\n    // findSpecialCharacters above\n    function SpecialMatch(index, upper) {\n        this.index = index;\n        if (upper) {\n            this.upper = upper;\n        }\n    }\n\n    // Used in match lists to designate any matched characters that are not special\n    function NormalMatch(index, upper) {\n        this.index = index;\n        if (upper) {\n            this.upper = upper;\n        }\n    }\n\n    /*\n     * Finds the best matches between the query and the string. The query is\n     * compared with str (usually a lower case string with a lower case\n     * query).\n     *\n     * Generally speaking, this function tries to find \"special\" characters\n     * (see findSpecialCharacters above) first. Failing that, it starts scanning\n     * the \"normal\" characters. Sometimes, it will find a special character that matches\n     * but then not be able to match the rest of the query. In cases like that, the\n     * search will backtrack and try to find matches for the whole query earlier in the\n     * string.\n     *\n     * A contrived example will help illustrate how the searching and backtracking works. It's a bit long,\n     * but it illustrates different pieces of the algorithm which can be tricky. Let's say that we're\n     * searching the string \"AzzBzzCzdzezzDgxgEF\" for \"abcdex\".\n     *\n     * To start with, it will match \"abcde\" from the query to \"A B C D E\" in the string (the spaces\n     * represent gaps in the matched part of the string), because those are all \"special characters\".\n     * However, the \"x\" in the query doesn't match the \"F\" which is the only character left in the\n     * string.\n     *\n     * Backtracking kicks in. The \"E\" is pulled off of the match list.\n     * deadBranches[4] is set to the \"g\" before the \"E\". This means that for the 5th\n     * query character (the \"e\") we know that we don't have a match beyond that point in the string.\n     *\n     * To resume searching, the backtrack function looks at the previous match (the \"D\") and starts\n     * searching in character-by-character (ANY_MATCH) mode right after that. It fails to find an\n     * \"e\" before it gets to deadBranches[4], so it has to backtrack again.\n     *\n     * This time, the \"D\" is pulled off the match list.\n     * deadBranches[3] is set to the \"z\" before the \"D\", because we know that for the \"dex\" part of the\n     * query, we can't make it work past the \"D\". We'll resume searching with the \"z\" after the \"C\".\n     *\n     * Doing an ANY_MATCH search, we find the \"d\". We then start searching specials for \"e\", but we\n     * stop before we get to \"E\" because deadBranches[4] tells us that's a dead end. So, we switch\n     * to ANY_MATCH and find the \"e\".\n     *\n     * Finally, we search for the \"x\". We don't find a special that matches, so we start an ANY_MATCH\n     * search. Then we find the \"x\", and we have a successful match.\n     *\n     * Here are some notes on how the algorithm works:\n     *\n     * * We only backtrack() when we're exhausted both special AND normal forward searches past that point,\n     *   for the query remainder we currently have.  For a different query remainder, we may well get further\n     *   along - hence deadBranches[] being dependent on queryCounter; but in order to get a different query\n     *   remainder, we must give up one or more current matches by backtracking.\n     *\n     * * Normal \"any char\" forward search is a superset of special matching mode -- anything that would have\n     *   been matched in special mode *could* also be matched by normal mode. In practice, however,\n     *   any special characters that could have matched would be picked up first by the specials matching\n     *   code.\n     *\n     * * backtrack() always goes at least as far back as str[deadBranches[queryCounter]-1] before allowing\n     *   forward searching to resume\n     *\n     * * When `deadBranches[queryCounter] = strCounter` it means if we're still trying to match\n     *   `queryLower[queryCounter]` and we get to `str[strCounter]`, there's no way we can match the\n     *   remainer of `queryLower` with the remainder of `str` -- either using specials-only or\n     *   full any-char matching.\n     *\n     * * We know this because deadBranches[] is set in backtrack(), and we don't get to backtrack() unless\n     *   either:\n     *   1. We've already exhausted both special AND normal forward searches past that point\n     *      (i.e. backtrack() due to `strCounter >= str.length`, yet `queryCounter < query.length`)\n     *   2. We stopped searching further forward due to a previously set deadBranches[] value\n     *      (i.e. backtrack() due to `strCounter > deadBranches[queryCounter]`, yet\n     *      `queryCounter < query.length`)\n     *\n     * @param {string} query the search string (generally lower cased)\n     * @param {string} str the string to compare with (generally lower cased)\n     * @param {string} originalQuery the \"non-normalized\" query string (used to detect case match priority)\n     * @param {string} originalStr the \"non-normalized\" string to compare with (used to detect case match priority)\n     * @param {Array} specials list of special indexes in str (from findSpecialCharacters)\n     * @param {int} startingSpecial index into specials array to start scanning with\n     * @return {Array.<SpecialMatch|NormalMatch>} matched indexes or null if no matches possible\n     */\n    function _generateMatchList(query, str, originalQuery, originalStr, specials, startingSpecial) {\n        var result = [];\n\n        // used to keep track of which special character we're testing now\n        var specialsCounter = startingSpecial;\n\n        // strCounter and queryCounter are the indexes used for pulling characters\n        // off of the str/compareLower and query.\n        var strCounter = specials[startingSpecial];\n        var queryCounter;\n\n        // the search branches out between special characters and normal characters\n        // that are found via consecutive character scanning. In the process of\n        // performing these scans, we discover that parts of the query will not match\n        // beyond a given point in the string. We keep track of that information\n        // in deadBranches, which has a slot for each character in the query.\n        // The value stored in the slot is the index into the string after which we\n        // are certain there is no match.\n        var deadBranches = [];\n\n        for (queryCounter = 0; queryCounter < query.length; queryCounter++) {\n            deadBranches[queryCounter] = Infinity;\n        }\n\n        queryCounter = 0;\n\n        var state = SPECIALS_MATCH;\n\n        // Compares the current character from the query string against the\n        // special characters in str. Returns true if a match was found,\n        // false otherwise.\n        function findMatchingSpecial() {\n            // used to loop through the specials\n            var i;\n\n            for (i = specialsCounter; i < specials.length; i++) {\n                // short circuit this search when we know there are no matches following\n                if (specials[i] >= deadBranches[queryCounter]) {\n                    break;\n                }\n\n                // First, ensure that we're not comparing specials that\n                // come earlier in the string than our current search position.\n                // This can happen when the string position changes elsewhere.\n                if (specials[i] < strCounter) {\n                    specialsCounter = i;\n                } else if (query[queryCounter] === str[specials[i]]) {\n                    // we have a match! do the required tracking\n                    strCounter = specials[i];\n\n                    // Upper case match check:\n                    // If the query and original string matched, but the original string\n                    // and the lower case version did not, that means that the original\n                    // was upper case.\n                    var upper = originalQuery[queryCounter] === originalStr[strCounter] && originalStr[strCounter] !== str[strCounter];\n                    result.push(new SpecialMatch(strCounter, upper));\n                    specialsCounter = i;\n                    queryCounter++;\n                    strCounter++;\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        // This function implements the backtracking that is done when we fail to find\n        // a match with the query using the \"search for specials first\" approach.\n        //\n        // returns false when it is not able to backtrack successfully\n        function backtrack() {\n\n            // The idea is to pull matches off of our match list, rolling back\n            // characters from the query. We pay special attention to the special\n            // characters since they are searched first.\n            while (result.length > 0) {\n                var item = result.pop();\n\n                // nothing in the list? there's no possible match then.\n                if (!item) {\n                    return false;\n                }\n\n                // we pulled off a match, which means that we need to put a character\n                // back into our query. strCounter is going to be set once we've pulled\n                // off the right special character and know where we're going to restart\n                // searching from.\n                queryCounter--;\n\n                if (item instanceof SpecialMatch) {\n                    // pulled off a special, which means we need to make that special available\n                    // for matching again\n                    specialsCounter--;\n\n                    // check to see if we've gone back as far as we need to\n                    if (item.index < deadBranches[queryCounter]) {\n                        // we now know that this part of the query does not match beyond this\n                        // point\n                        deadBranches[queryCounter] = item.index - 1;\n\n                        // since we failed with the specials along this track, we're\n                        // going to reset to looking for matches consecutively.\n                        state = ANY_MATCH;\n\n                        // we figure out where to start looking based on the new\n                        // last item in the list. If there isn't anything else\n                        // in the match list, we'll start over at the starting special\n                        // (which is generally the beginning of the string, or the\n                        // beginning of the last segment of the string)\n                        item = result[result.length - 1];\n                        if (!item) {\n                            strCounter = specials[startingSpecial] + 1;\n                            return true;\n                        }\n                        strCounter = item.index + 1;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        while (true) {\n\n            // keep looping until we've either exhausted the query or the string\n            while (queryCounter < query.length && strCounter < str.length && strCounter <= deadBranches[queryCounter]) {\n                if (state === SPECIALS_MATCH) {\n                    if (!findMatchingSpecial()) {\n                        state = ANY_MATCH;\n                    }\n                }\n\n                if (state === ANY_MATCH) {\n                    // we look character by character for matches\n                    if (query[queryCounter] === str[strCounter]) {\n                        // got a match! record it, and switch back to searching specials\n\n                        // See the specials section above for a comment on the expression\n                        // for `upper` below.\n                        var upper = originalQuery[queryCounter] === originalStr[strCounter] && originalStr[strCounter] !== str[strCounter];\n                        result.push(new NormalMatch(strCounter++, upper));\n\n                        queryCounter++;\n                        state = SPECIALS_MATCH;\n                    } else {\n                        // no match, keep looking\n                        strCounter++;\n                    }\n                }\n            }\n\n            // if we've finished the query, or we haven't finished the query but we have no\n            // more backtracking we can do, then we're all done searching.\n            if (queryCounter >= query.length || (queryCounter < query.length && !backtrack())) {\n                break;\n            }\n        }\n\n        // return null when we don't find anything\n        if (queryCounter < query.length || result.length === 0) {\n            return null;\n        }\n        return result;\n    }\n\n\n    /*\n     * Seek out the best match in the last segment (generally the filename).\n     * Matches in the filename are preferred, but the query entered could match\n     * any part of the path. So, we find the best match we can get in the filename\n     * and then allow for searching the rest of the string with any characters that\n     * are left from the beginning of the query.\n     *\n     * The parameters and return value are the same as for getMatchRanges,\n     * except this function is always working on the last segment and the\n     * result can optionally include a remainder, which is the characters\n     * at the beginning of the query which did not match in the last segment.\n     *\n     * @param {string} query the search string (generally lower cased)\n     * @param {string} str the string to compare with (generally lower cased)\n     * @param {string} originalQuery the \"non-normalized\" query string (used to detect case match priority)\n     * @param {string} originalStr the \"non-normalized\" string to compare with (used to detect case match priority)\n     * @param {Array} specials list of special indexes in str (from findSpecialCharacters)\n     * @param {int} startingSpecial index into specials array to start scanning with\n     * @param {boolean} lastSegmentStart which character does the last segment start at\n     * @return {{remainder:int, matchList:Array.<SpecialMatch|NormalMatch>}} matched indexes or null if no matches possible\n     */\n    function _lastSegmentSearch(query, str, originalQuery, originalStr, specials, startingSpecial, lastSegmentStart) {\n        var queryCounter, matchList;\n\n        // It's possible that the query is longer than the last segment.\n        // If so, we can chop off the bit that we know couldn't possibly be there.\n        var remainder = \"\",\n            originalRemainder = \"\",\n            extraCharacters = specials[startingSpecial] + query.length - str.length;\n\n        if (extraCharacters > 0) {\n            remainder = query.substring(0, extraCharacters);\n            originalRemainder = originalQuery.substring(0, extraCharacters);\n            query = query.substring(extraCharacters);\n            originalQuery = originalQuery.substring(extraCharacters);\n        }\n\n        for (queryCounter = 0; queryCounter < query.length; queryCounter++) {\n            matchList = _generateMatchList(query.substring(queryCounter),\n                                     str, originalQuery.substring(queryCounter),\n                                     originalStr, specials, startingSpecial);\n\n            // if we've got a match *or* there are no segments in this string, we're done\n            if (matchList || startingSpecial === 0) {\n                break;\n            }\n        }\n\n        if (queryCounter === query.length || !matchList) {\n            return null;\n        }\n        return {\n            remainder: remainder + query.substring(0, queryCounter),\n            originalRemainder: originalRemainder + originalQuery.substring(0, queryCounter),\n            matchList: matchList\n        };\n\n    }\n\n    /*\n     * Implements the top-level search algorithm. Search the last segment first,\n     * then search the rest of the string with the remainder.\n     *\n     * The parameters and return value are the same as for getMatchRanges.\n     *\n     * @param {string} queryLower the search string (will be searched lower case)\n     * @param {string} compareLower the lower-cased string to search\n     * @param {string} originalQuery the \"non-normalized\" query string (used to detect case match priority)\n     * @param {string} originalStr the \"non-normalized\" string to compare with (used to detect case match priority)\n     * @param {Array} specials list of special indexes in str (from findSpecialCharacters)\n     * @param {int} lastSegmentSpecialsIndex index into specials array to start scanning with\n     * @return {Array.<SpecialMatch|NormalMatch>} matched indexes or null if no matches possible\n     */\n    function _wholeStringSearch(queryLower, compareLower, originalQuery, originalStr, specials, lastSegmentSpecialsIndex) {\n        var lastSegmentStart = specials[lastSegmentSpecialsIndex];\n        var result;\n        var matchList;\n\n        result = _lastSegmentSearch(queryLower, compareLower, originalQuery, originalStr, specials, lastSegmentSpecialsIndex, lastSegmentStart);\n\n        if (result) {\n            matchList = result.matchList;\n\n            // Do we have more query characters that did not fit?\n            if (result.remainder) {\n                // Scan with the remainder only through the beginning of the last segment\n                var remainderMatchList = _generateMatchList(result.remainder,\n                                              compareLower.substring(0, lastSegmentStart),\n                                              result.originalRemainder,\n                                              originalStr.substring(0, lastSegmentStart),\n                                              specials.slice(0, lastSegmentSpecialsIndex), 0);\n\n                if (remainderMatchList) {\n                    // add the new matched ranges to the beginning of the set of ranges we had\n                    matchList.unshift.apply(matchList, remainderMatchList);\n                } else {\n                    // no match\n                    return null;\n                }\n            }\n        } else {\n            // No match in the last segment, so we start over searching the whole\n            // string\n            matchList = _generateMatchList(queryLower, compareLower, originalQuery, originalStr, specials, 0);\n        }\n\n        return matchList;\n    }\n\n    /**\n     * Converts a list of matches into a form suitable for returning from stringMatch.\n     *\n     * @param {Array.<SpecialMatch|NormalMatch>} matchList to convert\n     * @param {string} original string\n     * @param {int} character index where last segment begins\n     * @return {{ranges:Array.<{text:string, matched:boolean, includesLastSegment:boolean}>, matchGoodness:int, scoreDebug: Object}} matched ranges and score\n     */\n    function _computeRangesAndScore(matchList, str, lastSegmentStart) {\n        var matchCounter;\n        var ranges = [];\n        var lastMatchIndex = -1;\n        var lastSegmentScore = 0;\n        var currentRangeStartedOnSpecial = false;\n\n        var score = 0;\n        var scoreDebug;\n        if (DEBUG_SCORES) {\n            scoreDebug = {\n                special: 0,\n                match: 0,\n                upper: 0,\n                lastSegment: 0,\n                beginning: 0,\n                lengthDeduction: 0,\n                consecutive: 0,\n                notStartingOnSpecial: 0\n            };\n        }\n\n        var currentRange = null;\n\n        // Records the current range and adds any additional ranges required to\n        // get to character index c. This function is called before starting a new range\n        // or returning from the function.\n        function closeRangeGap(c) {\n            // Close the current range\n            if (currentRange) {\n                currentRange.includesLastSegment = lastMatchIndex >= lastSegmentStart;\n                if (currentRange.matched && currentRange.includesLastSegment) {\n                    if (DEBUG_SCORES) {\n                        scoreDebug.lastSegment += lastSegmentScore * LAST_SEGMENT_BOOST;\n                    }\n                    score += lastSegmentScore * LAST_SEGMENT_BOOST;\n                }\n\n                if (currentRange.matched && !currentRangeStartedOnSpecial) {\n                    if (DEBUG_SCORES) {\n                        scoreDebug.notStartingOnSpecial -= NOT_STARTING_ON_SPECIAL_PENALTY;\n                    }\n                    score -= NOT_STARTING_ON_SPECIAL_PENALTY;\n                }\n                ranges.push(currentRange);\n            }\n\n            // If there was space between the new range and the last,\n            // add a new unmatched range before the new range can be added.\n            if (lastMatchIndex + 1 < c) {\n                ranges.push({\n                    text: str.substring(lastMatchIndex + 1, c),\n                    matched: false,\n                    includesLastSegment: c > lastSegmentStart\n                });\n            }\n            currentRange = null;\n            lastSegmentScore = 0;\n        }\n\n        // In some cases (see the use of this variable below), we accelerate the\n        // bonus the more consecutive matches there are.\n        var numConsecutive = 0;\n\n        // Adds a matched character to the appropriate range\n        function addMatch(match) {\n            // Pull off the character index\n            var c = match.index;\n            var newPoints = 0;\n\n            // A match means that we need to do some scoring bookkeeping.\n            // Start with points added for any match\n            if (DEBUG_SCORES) {\n                scoreDebug.match += MATCH_POINTS;\n            }\n            newPoints += MATCH_POINTS;\n\n            if (match.upper) {\n                if (DEBUG_SCORES) {\n                    scoreDebug.upper += UPPER_CASE_MATCH;\n                }\n                newPoints += UPPER_CASE_MATCH;\n            }\n\n            // A bonus is given for characters that match at the beginning\n            // of the filename\n            if (c === lastSegmentStart) {\n                if (DEBUG_SCORES) {\n                    scoreDebug.beginning += BEGINNING_OF_NAME_POINTS;\n                }\n                newPoints += BEGINNING_OF_NAME_POINTS;\n            }\n\n            // If the new character immediately follows the last matched character,\n            // we award the consecutive matches bonus. The check for score > 0\n            // handles the initial value of lastMatchIndex which is used for\n            // constructing ranges but we don't yet have a true match.\n            if (score > 0 && lastMatchIndex + 1 === c) {\n                // Continue boosting for each additional match at the beginning\n                // of the name\n                if (c - numConsecutive === lastSegmentStart) {\n                    if (DEBUG_SCORES) {\n                        scoreDebug.beginning += BEGINNING_OF_NAME_POINTS;\n                    }\n                    newPoints += BEGINNING_OF_NAME_POINTS;\n                }\n\n                numConsecutive++;\n\n                var boost = CONSECUTIVE_MATCHES_POINTS * numConsecutive;\n\n                // Consecutive matches that started on a special are a\n                // good indicator of intent, so we award an added bonus there.\n                if (currentRangeStartedOnSpecial) {\n                    boost = boost * 2;\n                }\n\n                if (DEBUG_SCORES) {\n                    scoreDebug.consecutive += boost;\n                }\n                newPoints += boost;\n            } else {\n                numConsecutive = 1;\n            }\n\n            // add points for \"special\" character matches\n            if (match instanceof SpecialMatch) {\n                if (DEBUG_SCORES) {\n                    scoreDebug.special += SPECIAL_POINTS;\n                }\n                newPoints += SPECIAL_POINTS;\n            }\n\n            score += newPoints;\n\n            // points accumulated in the last segment get an extra bonus\n            if (c >= lastSegmentStart) {\n                lastSegmentScore += newPoints;\n            }\n\n            // if the last range wasn't a match or there's a gap, we need to close off\n            // the range to start a new one.\n            if ((currentRange && !currentRange.matched) || c > lastMatchIndex + 1) {\n                closeRangeGap(c);\n            }\n            lastMatchIndex = c;\n\n            // set up a new match range or add to the current one\n            if (!currentRange) {\n                currentRange = {\n                    text: str[c],\n                    matched: true\n                };\n\n                // Check to see if this new matched range is starting on a special\n                // character. We penalize those ranges that don't, because most\n                // people will search on the logical boundaries of the name\n                currentRangeStartedOnSpecial = match instanceof SpecialMatch;\n            } else {\n                currentRange.text += str[c];\n            }\n        }\n\n        // scan through the matches, adding each one in turn\n        for (matchCounter = 0; matchCounter < matchList.length; matchCounter++) {\n            var match = matchList[matchCounter];\n            addMatch(match);\n        }\n\n        // add a range for the last part of the string\n        closeRangeGap(str.length);\n\n        // shorter strings that match are often better than longer ones\n        var lengthPenalty = -1 * Math.round(str.length * DEDUCTION_FOR_LENGTH);\n        if (DEBUG_SCORES) {\n            scoreDebug.lengthDeduction = lengthPenalty;\n        }\n        score = score + lengthPenalty;\n\n        var result = {\n            ranges: ranges,\n            matchGoodness: score\n        };\n\n        if (DEBUG_SCORES) {\n            result.scoreDebug = scoreDebug;\n        }\n        return result;\n    }\n\n    /*\n     * If we short circuit normal matching to produce a prefix match,\n     * this function will generate the appropriate SearchResult.\n     * This function assumes that the prefix match check has already\n     * been performed.\n     *\n     * @param {string} str  The string with the prefix match for the query\n     * @param {string} query  The query that matched the beginning of str\n     * @return {{ranges:Array.<{text:string, matched:boolean, includesLastSegment:boolean}>, matchGoodness:int, scoreDebug: Object}} ranges has a matching range for beginning of str\n     *                      and a non-matching range for the end of the str\n     *                      the score is -Number.MAX_VALUE in all cases\n     */\n    function _prefixMatchResult(str, query) {\n        var result = new SearchResult(str);\n\n        result.matchGoodness = -Number.MAX_VALUE;\n\n        if (str.substr(0, query.length) !== query) {\n            // Penalize for not matching case\n            result.matchGoodness *= 0.5;\n        }\n\n        if (DEBUG_SCORES) {\n            result.scoreDebug = {\n                beginning: -result.matchGoodness\n            };\n        }\n\n        result.stringRanges = [{\n            text: str.substr(0, query.length),\n            matched: true,\n            includesLastSegment: true\n        }];\n        if (str.length > query.length) {\n            result.stringRanges.push({\n                text: str.substring(query.length),\n                matched: false,\n                includesLastSegment: true\n            });\n        }\n        return result;\n    }\n\n\n    /*\n     * Match str against the query using the QuickOpen algorithm provided by\n     * the functions above. The general idea is to prefer matches of \"special\" characters and,\n     * optionally, matches that occur in the \"last segment\" (generally, the filename). stringMatch\n     * will try to provide the best match and produces a \"matchGoodness\" score\n     * to allow for relative ranking.\n     *\n     * The result object returned includes \"stringRanges\" which can be used to highlight\n     * the matched portions of the string, in addition to the \"matchGoodness\"\n     * mentioned above. If DEBUG_SCORES is true, scoreDebug is set on the result\n     * to provide insight into the score.\n     *\n     * The matching is done in a case-insensitive manner.\n     *\n     * @param {string} str  The string to search\n     * @param {string} query  The query string to find in string\n     * @param {{preferPrefixMatches:?boolean, segmentedSearch:?boolean}} options to control search behavior.\n     *                  preferPrefixMatches puts an exact case-insensitive prefix match ahead of all other matches,\n     *                  even short-circuiting the match logic. This option implies segmentedSearch=false.\n     *                  When segmentedSearch is true, the string is broken into segments by \"/\" characters\n     *                  and the last segment is searched first and matches there are scored higher.\n     * @param {?Object} special (optional) the specials data from findSpecialCharacters, if already known\n     *                  This is generally just used by StringMatcher for optimization.\n     * @return {{ranges:Array.<{text:string, matched:boolean, includesLastSegment:boolean}>, matchGoodness:int, scoreDebug: Object}} matched ranges and score\n     */\n    function stringMatch(str, query, options, special) {\n        var result;\n\n        options = options || {};\n\n        // No query? Short circuit the normal work done and just\n        // return a single range that covers the whole string.\n        if (!query) {\n            result = new SearchResult(str);\n            result.matchGoodness = 0;\n            if (DEBUG_SCORES) {\n                result.scoreDebug = {};\n            }\n            result.stringRanges = [{\n                text: str,\n                matched: false,\n                includesLastSegment: true\n            }];\n            return result;\n        }\n\n        // comparisons are case insensitive, so switch to lower case here\n        var queryLower = query.toLowerCase();\n        var compareLower = str.toLowerCase();\n\n        if (options.preferPrefixMatches) {\n            options.segmentedSearch = false;\n        }\n\n        if (options.preferPrefixMatches && compareLower.substr(0, queryLower.length) === queryLower) {\n            // NOTE: we compare against the case insensitive match\n            //        above but we pass the case-sensitive version in\n            //        because we want to weight the match to give case-matches\n            //        a higher score\n            return _prefixMatchResult(str, query);\n        }\n\n        // Locate the special characters and then use orderedCompare to do the real\n        // work.\n        if (!special) {\n            special = findSpecialCharacters(str);\n        }\n        var lastSegmentStart, matchList;\n\n        // For strings that are not broken into multiple segments, we can potentially\n        // avoid some extra work\n        if (options.segmentedSearch) {\n            lastSegmentStart = special.specials[special.lastSegmentSpecialsIndex];\n            matchList = _wholeStringSearch(queryLower, compareLower, query, str, special.specials,\n                              special.lastSegmentSpecialsIndex);\n        } else {\n            lastSegmentStart = 0;\n            matchList = _generateMatchList(queryLower, compareLower, query, str, special.specials, 0);\n        }\n\n        // If we get a match, turn this into a SearchResult as expected by the consumers\n        // of this API.\n        if (matchList) {\n            var compareData = _computeRangesAndScore(matchList, str, lastSegmentStart);\n            result = new SearchResult(str);\n            result.stringRanges = compareData.ranges;\n            result.matchGoodness = -1 * compareData.matchGoodness;\n            if (DEBUG_SCORES) {\n                result.scoreDebug = compareData.scoreDebug;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sorts an array of SearchResult objects on a primary field, followed by secondary fields\n     * in case of ties. 'fieldSpec' provides the priority order for fields, where the first entry is the primary field, for example:\n     *      multiFieldSort(bugList, [ \"milestone\", \"severity\" ]);\n     * Would sort a bug list by milestone, and within each milestone sort bugs by severity.\n     *\n     * fieldSpec can also include comparator functions of the form normally used by the sort()\n     * function.\n     *\n     * Any fields that have a string value are compared case-insensitively. Fields used should be\n     * present on all SearchResult objects (no optional/undefined fields).\n     *\n     * @param {!Array.<SearchResult>} searchResults\n     * @param {!Array.<string, function>} fieldSpec\n     */\n    function multiFieldSort(searchResults, fieldSpec) {\n        // Move field names into an array, with primary field first\n        var comparisons;\n        if (Array.isArray(fieldSpec)) {\n            comparisons = fieldSpec;\n        } else {\n            // TODO Deprecate this form of calling this function\n            comparisons = [];\n            _.forEach(fieldSpec, function (priority, key) {\n                comparisons[priority] = key;\n            });\n        }\n\n        searchResults.sort(function (a, b) {\n            var priority;\n            for (priority = 0; priority < comparisons.length; priority++) {\n                var comparison = comparisons[priority];\n                if (typeof comparison === \"function\") {\n                    var result = comparison(a, b);\n                    if (result) {\n                        return result;\n                    }\n                } else {\n                    var valueA = a[comparison];\n                    var valueB = b[comparison];\n                    if (typeof valueA === \"string\") {\n                        valueA = valueA.toLowerCase();\n                        valueB = valueB.toLowerCase();\n                    }\n\n                    if (valueA < valueB) {\n                        return -1;\n                    } else if (valueA > valueB) {\n                        return 1;\n                    }\n                }\n                // otherwise, move on to next sort priority\n            }\n            return 0; // all sort fields are equal\n        });\n    }\n\n    /**\n     * Sorts search results generated by stringMatch(): results are sorted into several\n     * tiers based on how well they matched the search query, then sorted alphabetically\n     * within each tier.\n     */\n    function basicMatchSort(searchResults) {\n        multiFieldSort(searchResults, { matchGoodness: 0, label: 1 });\n    }\n\n    /**\n     * A StringMatcher provides an interface to the stringMatch function with built-in\n     * caching. You should use a StringMatcher for the lifetime of queries over a\n     * single data set.\n     *\n     * You are free to store other data on this object to assist in higher-level caching.\n     * (This object's caches are all stored in \"_\" prefixed properties.)\n     *\n     * @param {{preferPrefixMatches:?boolean, segmentedSearch:?boolean}} options to control search behavior.\n     *                  preferPrefixMatches puts an exact case-insensitive prefix match ahead of all other matches,\n     *                  even short-circuiting the match logic. This option implies segmentedSearch=false.\n     *                  segmentedSearch treats segments of the string specially.\n     */\n    function StringMatcher(options) {\n        this.options = options;\n        this.reset();\n    }\n\n    /**\n     * Map from search-result string to the findSpecialCharacters() result for that string - easy to cache\n     * since this info doesn't change as the query changes.\n     * @type {Object.<string, {specials:Array.<number>, lastSegmentSpecialsIndex:number}>}\n     */\n    StringMatcher.prototype._specialsCache = null;\n\n    /**\n     * Set of search-result strings that we know don't match the query _lastQuery - or any other query with\n     * that prefix.\n     * @type {Object.<string, boolean>}\n     */\n    StringMatcher.prototype._noMatchCache = null;\n\n    /**\n     * Clears the caches. Use this in the event that the caches may be invalid.\n     */\n    StringMatcher.prototype.reset = function () {\n        // We keep track of the last query to know when we need to invalidate.\n        this._lastQuery = null;\n\n        this._specialsCache = {};\n        this._noMatchCache = {};\n    };\n\n    /**\n     * Performs a single match using the stringMatch function. See stringMatch for full documentation.\n     *\n     * @param {string} str  The string to search\n     * @param {string} query  The query string to find in string\n     * @return {{ranges:Array.<{text:string, matched:boolean, includesLastSegment:boolean}>, matchGoodness:int, scoreDebug: Object}} matched ranges and score\n     */\n    StringMatcher.prototype.match = function (str, query) {\n\n        // If the query is not just added characters from the previous query, we invalidate\n        // the no match cache and will re-match everything.\n        if (this._lastQuery !== null && (this._lastQuery !== query.substring(0, this._lastQuery.length))) {\n            this._noMatchCache = {};\n        }\n\n        this._lastQuery = query;\n\n        // Check for a known non-matching string.\n        if (_.has(this._noMatchCache, str)) {\n            return undefined;\n        }\n\n        // Load up the cached specials information (or build it if this is our first time through).\n        var special = _.has(this._specialsCache, str) ? this._specialsCache[str] : undefined;\n        if (special === undefined) {\n            special = findSpecialCharacters(str);\n            this._specialsCache[str] = special;\n        }\n\n        var result = stringMatch(str, query, this.options, special);\n\n        // If this query was not a match, we cache that fact for next time.\n        if (!result) {\n            this._noMatchCache[str] = true;\n        }\n        return result;\n    };\n\n    exports._findSpecialCharacters  = findSpecialCharacters;\n    exports._wholeStringSearch      = _wholeStringSearch;\n    exports._lastSegmentSearch      = _lastSegmentSearch;\n    exports._setDebugScores         = _setDebugScores;\n    exports._generateMatchList      = _generateMatchList;\n    exports._SpecialMatch           = SpecialMatch;\n    exports._NormalMatch            = NormalMatch;\n    exports._computeRangesAndScore  = _computeRangesAndScore;\n\n    // public exports\n    exports.SearchResult            = SearchResult;\n    exports.stringMatch             = stringMatch;\n    exports.basicMatchSort          = basicMatchSort;\n    exports.multiFieldSort          = multiFieldSort;\n    exports.StringMatcher           = StringMatcher;\n});\n"],"file":"StringMatch.js"}
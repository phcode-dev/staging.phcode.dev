{"version":3,"sources":["languageTools/ClientLoader.js"],"names":["define","require","exports","module","ToolingInfo","JSON","parse","NodeDomain","FileUtils","EventDispatcher","BracketsToNodeInterface","makeEventDispatcher","_bracketsPath","getNativeBracketsDirectoryPath","replace","_modulePath","getNativeModuleDirectoryPath","_nodePath","_domainPath","join","clientInfoDomain","clientInfoLoadedPromise","pendingClientsToBeLoaded","syncPrefsWithDomain","languageToolsPrefs","exec","_createNodeDomain","domainName","domainPath","loadLanguageClientDomain","clientName","result","$","Deferred","languageClientDomain","promise","done","console","log","resolve","fail","err","error","reject","createNodeInterfaceForDomain","nodeInterface","_clientLoader","clientFilePath","clientPromise","then","languageClientInterface","name","interface","initiateLanguageClient","state","pendingClient","load","bind","push","sendLanguageClientInfo","logInitializationError","success","Array","isArray","forEach","trigger","initDomainAndHandleNodeCrash","connection","on","event","reconnectedPromise"],"mappings":"AAyBAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,YAAcC,KAAKC,MAAML,QAAQ,wCACjCM,WAAaN,QAAQ,oBACrBO,UAAYP,QAAQ,kBACpBQ,gBAAkBR,QAAQ,yBAC1BS,wBAA0BT,QAAQ,yCAAyCS,wBAE/ED,gBAAgBE,oBAAoBT,SAEpC,IAAIU,cAAgBJ,UAAUK,iCAE9BD,cAAgBA,cAAcE,QAAQ,UAAW,QAEjD,IAAIC,YAAcP,UAAUQ,6BAA6Bb,QACrDc,UACAC,YAAc,CAACN,cAAeG,YADlB,mCAC0CI,KAAK,KAC3DC,iBAAmB,KACnBC,wBAA0B,KAG1BC,yBAA2B,GAE/B,SAASC,oBAAoBC,oBACrBJ,kBACAA,iBAAiBK,KAAK,kBAAmBD,oBAIjD,SAASE,kBAAkBC,WAAYC,YACnC,OAAO,IAAIrB,WAAWoB,WAAYC,YAGtC,SAASC,yBAAyBC,WAAYF,YAE1C,IAAID,WAAaG,WACbC,OAASC,EAAEC,WACXC,qBAAuBR,kBAAkBC,WAAYC,YAiBzD,OAfIM,qBACAA,qBAAqBC,UAChBC,KAAK,WACFC,QAAQC,IAAIV,WAAa,gCACzBG,OAAOQ,QAAQL,wBAElBM,KAAK,SAAUC,KACZJ,QAAQK,MAAMd,WAAa,iCAC3BG,OAAOY,YAGfN,QAAQK,MAAMd,WAAa,iCAC3BG,OAAOY,UAGJZ,OAGX,SAASa,6BAA6BV,sBAClC,IAAIW,cAEJ,OAFoB,IAAInC,wBAAwBwB,sBAKpD,SAASY,cAAchB,WAAYiB,eAAgBC,eAC/CnB,yBAAyBC,WAAYiB,gBAChCE,KAAK,SAAUf,sBACZ,IAAIgB,wBAA0BN,6BAA6BV,sBAE3Dc,cAAcT,QAAQ,CAClBY,KAAMrB,WACNsB,UAAWF,2BAEhBF,cAAcL,QAGzB,SAASU,uBAAuBvB,WAAYiB,gBACxC,IAAIhB,OAASC,EAAEC,WAGf,GAAKZ,yBAA+D,YAApCA,wBAAwBiC,QAMpDR,cAAchB,WAAYiB,eAAgBhB,YANiC,CAC3E,IAAIwB,cAAgB,CAChBC,KAAMV,cAAcW,KAAK,KAAM3B,WAAYiB,eAAgBhB,SAE/DT,yBAAyBoC,KAAKH,eAKlC,OAAOxB,OASX,SAAS4B,yBAIL,SAASC,yBACLvB,QAAQK,MAAM,4DAHlBrB,wBAA0BD,iBAAiBK,KAAK,aAAcb,cAAeR,cAOrD6C,KAAK,SAAUY,SAC9BA,SAKDC,MAAMC,QAAQzC,0BACdA,yBAAyB0C,QAAQ,SAAUT,eACvCA,cAAcC,SAGlBtD,QAAQ+D,QAAQ,mCAEpB3C,yBAA2B,MAXvBsC,0BAYL,WACCA,2BAUR,SAASM,gCACL9C,iBAAmB,IAAIb,WAAW,qBAAsBW,cAEvCiB,UAAUC,KAAK,WAC5BuB,yBAKAvC,iBAAiB+C,WAAWC,GAAG,QAAS,SAAUC,MAAOC,oBACrDA,mBAAmBlC,KAAKuB,4BAE7BnB,KAAK,SAAUC,KACdJ,QAAQK,MAAM,0CAA2CD,OAMjEvC,QAAQmD,uBAAyBA,uBACjCnD,QAAQqB,oBAAsBA","sourcesContent":["/*\n * Copyright (c) 2019 - present Adobe. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*eslint no-console: 0*/\n/*eslint max-len: [\"error\", { \"code\": 200 }]*/\ndefine(function (require, exports, module) {\n\n\n    var ToolingInfo = JSON.parse(require(\"text!languageTools/ToolingInfo.json\")),\n        NodeDomain = require(\"utils/NodeDomain\"),\n        FileUtils = require(\"file/FileUtils\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        BracketsToNodeInterface = require(\"languageTools/BracketsToNodeInterface\").BracketsToNodeInterface;\n\n    EventDispatcher.makeEventDispatcher(exports);\n    //Register paths required for Language Client and also register default brackets capabilities.\n    var _bracketsPath = FileUtils.getNativeBracketsDirectoryPath();\n    // The native directory path ends with either \"test\" or \"src\".\n    _bracketsPath = _bracketsPath.replace(/\\/test$/, \"/src\"); // convert from \"test\" to \"src\"\n\n    var _modulePath = FileUtils.getNativeModuleDirectoryPath(module),\n        _nodePath = \"node/RegisterLanguageClientInfo\",\n        _domainPath = [_bracketsPath, _modulePath, _nodePath].join(\"/\"),\n        clientInfoDomain = null,\n        clientInfoLoadedPromise = null,\n        //Clients that have to be loaded once the LanguageClient info is successfully loaded on the\n        //node side.\n        pendingClientsToBeLoaded = [];\n\n    function syncPrefsWithDomain(languageToolsPrefs) {\n        if (clientInfoDomain) {\n            clientInfoDomain.exec(\"syncPreferences\", languageToolsPrefs);\n        }\n    }\n\n    function _createNodeDomain(domainName, domainPath) {\n        return new NodeDomain(domainName, domainPath);\n    }\n\n    function loadLanguageClientDomain(clientName, domainPath) {\n        //generate a random hash name for the domain, this is the client id\n        var domainName = clientName,\n            result = $.Deferred(),\n            languageClientDomain = _createNodeDomain(domainName, domainPath);\n\n        if (languageClientDomain) {\n            languageClientDomain.promise()\n                .done(function () {\n                    console.log(domainPath + \" domain successfully created\");\n                    result.resolve(languageClientDomain);\n                })\n                .fail(function (err) {\n                    console.error(domainPath + \" domain could not be created.\");\n                    result.reject();\n                });\n        } else {\n            console.error(domainPath + \" domain could not be created.\");\n            result.reject();\n        }\n\n        return result;\n    }\n\n    function createNodeInterfaceForDomain(languageClientDomain) {\n        var nodeInterface = new BracketsToNodeInterface(languageClientDomain);\n\n        return nodeInterface;\n    }\n\n    function _clientLoader(clientName, clientFilePath, clientPromise) {\n        loadLanguageClientDomain(clientName, clientFilePath)\n            .then(function (languageClientDomain) {\n                var languageClientInterface = createNodeInterfaceForDomain(languageClientDomain);\n\n                clientPromise.resolve({\n                    name: clientName,\n                    interface: languageClientInterface\n                });\n            }, clientPromise.reject);\n    }\n\n    function initiateLanguageClient(clientName, clientFilePath) {\n        var result = $.Deferred();\n\n        //Only load clients after the LanguageClient Info has been initialized\n        if (!clientInfoLoadedPromise || clientInfoLoadedPromise.state() === \"pending\") {\n            var pendingClient = {\n                load: _clientLoader.bind(null, clientName, clientFilePath, result)\n            };\n            pendingClientsToBeLoaded.push(pendingClient);\n        } else {\n            _clientLoader(clientName, clientFilePath, result);\n        }\n\n        return result;\n    }\n\n    /**\n     * This function passes Brackets's native directory path as well as the tooling commands\n     * required by the LanguageClient node module. This information is then maintained in memory\n     * in the node process server for succesfully loading and functioning of all language clients\n     * since it is a direct dependency.\n     */\n    function sendLanguageClientInfo() {\n        //Init node with Information required by Language Client\n        clientInfoLoadedPromise = clientInfoDomain.exec(\"initialize\", _bracketsPath, ToolingInfo);\n\n        function logInitializationError() {\n            console.error(\"Failed to Initialize LanguageClient Module Information.\");\n        }\n\n        //Attach success and failure function for the clientInfoLoadedPromise\n        clientInfoLoadedPromise.then(function (success) {\n            if (!success) {\n                logInitializationError();\n                return;\n            }\n\n            if (Array.isArray(pendingClientsToBeLoaded)) {\n                pendingClientsToBeLoaded.forEach(function (pendingClient) {\n                    pendingClient.load();\n                });\n            } else {\n                exports.trigger(\"languageClientModuleInitialized\");\n            }\n            pendingClientsToBeLoaded = null;\n        }, function () {\n            logInitializationError();\n        });\n    }\n\n    /**\n     * This function starts a domain which initializes the LanguageClient node module\n     * required by the Language Server Protocol framework in Brackets. All the LSP clients\n     * can only be successfully initiated once this domain has been successfully loaded and\n     * the LanguageClient info initialized. Refer to sendLanguageClientInfo for more.\n     */\n    function initDomainAndHandleNodeCrash() {\n        clientInfoDomain = new NodeDomain(\"LanguageClientInfo\", _domainPath);\n        //Initialize LanguageClientInfo once the domain has successfully loaded.\n        clientInfoDomain.promise().done(function () {\n            sendLanguageClientInfo();\n            //This is to handle the node failure. If the node process dies, we get an on close\n            //event on the websocket connection object. Brackets then spawns another process and\n            //restablishes the connection. Once the connection is restablished we send reinitialize\n            //the LanguageClient info.\n            clientInfoDomain.connection.on(\"close\", function (event, reconnectedPromise) {\n                reconnectedPromise.done(sendLanguageClientInfo);\n            });\n        }).fail(function (err) {\n            console.error(\"ClientInfo domain could not be loaded: \", err);\n        });\n    }\n    //initDomainAndHandleNodeCrash();\n\n\n    exports.initiateLanguageClient = initiateLanguageClient;\n    exports.syncPrefsWithDomain = syncPrefsWithDomain;\n});\n"],"file":"ClientLoader.js"}
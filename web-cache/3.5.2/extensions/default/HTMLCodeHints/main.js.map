{"version":3,"sources":["extensions/default/HTMLCodeHints/main.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","CodeHintManager","HTMLUtils","PreferencesManager","Strings","NewFileContentManager","HTMLTags","HTMLAttributes","HTMLTemplate","XHTMLTemplate","tags","attributes","TagHints","this","exclusion","AttrHints","globalAttributes","readGlobalAttrHints","cachedHints","NewDocContentProvider","CONTENT_PROVIDER_NAME","definePreference","description","DESCRIPTION_HTML_TAG_HINTS","DESCRIPTION_ATTR_HINTS","prototype","updateExclusion","textAfterCursor","tagInfo","tagName","substr","position","offset","hasValidExclusion","hasHints","editor","implicitChar","pos","getCursorPos","getTagInfo","tokenType","TAG_NAME","getHints","query","result","slice","hints","$","map","value","key","indexOf","sort","match","selectInitial","handleWideResults","insertHint","completion","start","line","ch","end","cursor","charCount","length","document","replaceRange","global","_getValueHintsForAttr","attrName","tagPlusAttr","attrInfo","type","attribOption","attrNameOnly","ATTR_NAME","attr","name","ATTR_VALUE","queryStr","Array","i","foundPrefix","tag","usedAttr","getTagAttributes","filter","unfiltered","concat","grep","inArray","console","assert","item","Object","hasOwnProperty","deferred","Deferred","done","asyncHints","resolveWith","insertedName","replaceExistingOne","valueAssigned","endQuote","shouldReplace","hasEndQuote","quoteChar","setCursorPos","getContent","fileName","Promise","resolve","reject","endsWith","appReady","JSON","parse","tagHints","attrHints","newDocContentProvider","registerHintProvider","registerContentProvider","tagHintProvider","attrHintProvider"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n    require(\"HTMLJumpToDef\");\n\n    // Load dependent modules\n    const AppInit             = brackets.getModule(\"utils/AppInit\"),\n        CodeHintManager     = brackets.getModule(\"editor/CodeHintManager\"),\n        HTMLUtils           = brackets.getModule(\"language/HTMLUtils\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        Strings             = brackets.getModule(\"strings\"),\n        NewFileContentManager = brackets.getModule(\"features/NewFileContentManager\"),\n        HTMLTags            = require(\"text!HtmlTags.json\"),\n        HTMLAttributes      = require(\"text!HtmlAttributes.json\"),\n        HTMLTemplate        = require(\"text!template.html\"),\n        XHTMLTemplate       = require(\"text!template.xhtml\");\n\n    let tags,\n        attributes;\n\n    PreferencesManager.definePreference(\"codehint.TagHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_HTML_TAG_HINTS\n    });\n\n    PreferencesManager.definePreference(\"codehint.AttrHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_ATTR_HINTS\n    });\n\n    /**\n     * @constructor\n     */\n    function TagHints() {\n        this.exclusion = null;\n    }\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     */\n    TagHints.prototype.updateExclusion = function () {\n        var textAfterCursor;\n        if (this.exclusion && this.tagInfo) {\n            textAfterCursor = this.tagInfo.tagName.substr(this.tagInfo.position.offset);\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    /**\n     * Determines whether HTML tag hints are available in the current editor\n     * context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non- null,\n     * whether it is appropriate to do so.\n     */\n    TagHints.prototype.hasHints = function (editor, implicitChar) {\n        var pos = editor.getCursorPos();\n\n        this.tagInfo = HTMLUtils.getTagInfo(editor, pos);\n        this.editor = editor;\n        if (implicitChar === null) {\n            if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n                if (this.tagInfo.position.offset >= 0) {\n                    if (this.tagInfo.position.offset === 0) {\n                        this.exclusion = this.tagInfo.tagName;\n                    } else {\n                        this.updateExclusion();\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (implicitChar === \"<\") {\n            this.exclusion = this.tagInfo.tagName;\n            return true;\n        }\n        return false;\n\n    };\n\n    /**\n     * Returns a list of availble HTML tag hints if possible for the current\n     * editor context.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    TagHints.prototype.getHints = function (implicitChar) {\n        var query,\n            result;\n\n        this.tagInfo = HTMLUtils.getTagInfo(this.editor, this.editor.getCursorPos());\n        if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n            if (this.tagInfo.position.offset >= 0) {\n                this.updateExclusion();\n                query = this.tagInfo.tagName.slice(0, this.tagInfo.position.offset);\n                result = $.map(tags, function (value, key) {\n                    if (key.indexOf(query) === 0) {\n                        return key;\n                    }\n                }).sort();\n\n                return {\n                    hints: result,\n                    match: query,\n                    selectInitial: true,\n                    handleWideResults: false\n                };\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Inserts a given HTML tag hint into the current editor context.\n     *\n     * @param {string} hint\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    TagHints.prototype.insertHint = function (completion) {\n        var start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            cursor = this.editor.getCursorPos(),\n            charCount = 0;\n\n        if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n            var textAfterCursor = this.tagInfo.tagName.substr(this.tagInfo.position.offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = this.tagInfo.position.offset;\n            } else {\n                charCount = this.tagInfo.tagName.length;\n            }\n        }\n\n        end.line = start.line = cursor.line;\n        start.ch = cursor.ch - this.tagInfo.position.offset;\n        end.ch = start.ch + charCount;\n\n        if (this.exclusion || completion !== this.tagInfo.tagName) {\n            if (start.ch !== end.ch) {\n                this.editor.document.replaceRange(completion, start, end);\n            } else {\n                this.editor.document.replaceRange(completion, start);\n            }\n            this.exclusion = null;\n        }\n\n        return false;\n    };\n\n    /**\n     * @constructor\n     */\n    function AttrHints() {\n        this.globalAttributes = this.readGlobalAttrHints();\n        this.cachedHints = null;\n        this.exclusion = \"\";\n    }\n\n    /**\n     * @private\n     * Parse the code hints from JSON data and extract all hints from property names.\n     * @return {!Array.<string>} An array of code hints read from the JSON data source.\n     */\n    AttrHints.prototype.readGlobalAttrHints = function () {\n        return $.map(attributes, function (value, key) {\n            if (value.global === \"true\") {\n                return key;\n            }\n        });\n    };\n\n    /**\n     * Helper function that determines the possible value hints for a given html tag/attribute name pair\n     *\n     * @param {{queryStr: string}} query\n     * The current query\n     *\n     * @param {string} tagName\n     * HTML tag name\n     *\n     * @param {string} attrName\n     * HTML attribute name\n     *\n     * @return {!Array.<string>|$.Deferred}\n     * The (possibly deferred) hints.\n     */\n    AttrHints.prototype._getValueHintsForAttr = function (query, tagName, attrName) {\n        // We look up attribute values with tagName plus a slash and attrName first.\n        // If the lookup fails, then we fall back to look up with attrName only. Most\n        // of the attributes in JSON are using attribute name only as their properties,\n        // but in some cases like \"type\" attribute, we have different properties like\n        // \"script/type\", \"link/type\" and \"button/type\".\n        var hints = [];\n\n        var tagPlusAttr = tagName + \"/\" + attrName,\n            attrInfo = attributes[tagPlusAttr] || attributes[attrName];\n\n        if (attrInfo) {\n            if (attrInfo.type === \"boolean\") {\n                hints = [\"false\", \"true\"];\n            } else if (attrInfo.attribOption) {\n                hints = attrInfo.attribOption;\n            }\n        }\n\n        return hints;\n    };\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     *\n     * @param {boolean} attrNameOnly\n     * true to indicate that we update the exclusion only if the cursor is inside an attribute name context.\n     * Otherwise, we also update exclusion for attribute value context.\n     */\n    AttrHints.prototype.updateExclusion = function (attrNameOnly) {\n        if (this.exclusion && this.tagInfo) {\n            var tokenType = this.tagInfo.position.tokenType,\n                offset = this.tagInfo.position.offset,\n                textAfterCursor;\n\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                textAfterCursor = this.tagInfo.attr.name.substr(offset);\n            } else if (!attrNameOnly && tokenType === HTMLUtils.ATTR_VALUE) {\n                textAfterCursor = this.tagInfo.attr.value.substr(offset);\n            }\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    /**\n     * Determines whether HTML attribute hints are available in the current\n     * editor context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non-null,\n     * whether it is appropriate to do so.\n     */\n    AttrHints.prototype.hasHints = function (editor, implicitChar) {\n        var pos = editor.getCursorPos(),\n            tokenType,\n            offset,\n            query;\n\n        this.editor = editor;\n        this.tagInfo = HTMLUtils.getTagInfo(editor, pos);\n        tokenType = this.tagInfo.position.tokenType;\n        offset = this.tagInfo.position.offset;\n        if (implicitChar === null) {\n            query = null;\n\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                if (offset >= 0) {\n                    query = this.tagInfo.attr.name.slice(0, offset);\n                }\n            } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n                if (this.tagInfo.position.offset >= 0) {\n                    query = this.tagInfo.attr.value.slice(0, offset);\n                } else {\n                    // We get negative offset for a quoted attribute value with some leading whitespaces\n                    // as in <a rel= \"rtl\" where the cursor is just to the right of the \"=\".\n                    // So just set the queryStr to an empty string.\n                    query = \"\";\n                }\n\n                // If we're at an attribute value, check if it's an attribute name that has hintable values.\n                if (this.tagInfo.attr.name) {\n                    var hints = this._getValueHintsForAttr({queryStr: query},\n                                                           this.tagInfo.tagName,\n                                                           this.tagInfo.attr.name);\n                    if (hints instanceof Array) {\n                        // If we got synchronous hints, check if we have something we'll actually use\n                        var i, foundPrefix = false;\n                        for (i = 0; i < hints.length; i++) {\n                            if (hints[i].indexOf(query) === 0) {\n                                foundPrefix = true;\n                                break;\n                            }\n                        }\n                        if (!foundPrefix) {\n                            query = null;\n                        }\n                    }\n                }\n            }\n\n            if (offset >= 0) {\n                if (tokenType === HTMLUtils.ATTR_NAME && offset === 0) {\n                    this.exclusion = this.tagInfo.attr.name;\n                } else {\n                    this.updateExclusion(false);\n                }\n            }\n\n            return query !== null;\n        }\n        if (implicitChar === \" \" || implicitChar === \"'\" ||\n                    implicitChar === \"\\\"\" || implicitChar === \"=\") {\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                this.exclusion = this.tagInfo.attr.name;\n            }\n            return true;\n        }\n        return false;\n\n    };\n\n    /**\n     * Returns a list of availble HTML attribute hints if possible for the\n     * current editor context.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    AttrHints.prototype.getHints = function (implicitChar) {\n        var cursor = this.editor.getCursorPos(),\n            query = {queryStr: null},\n            tokenType,\n            offset,\n            result = [];\n\n        this.tagInfo = HTMLUtils.getTagInfo(this.editor, cursor);\n        tokenType = this.tagInfo.position.tokenType;\n        offset = this.tagInfo.position.offset;\n        if (tokenType === HTMLUtils.ATTR_NAME || tokenType === HTMLUtils.ATTR_VALUE) {\n            query.tag = this.tagInfo.tagName;\n\n            if (offset >= 0) {\n                if (tokenType === HTMLUtils.ATTR_NAME) {\n                    query.queryStr = this.tagInfo.attr.name.slice(0, offset);\n                } else {\n                    query.queryStr = this.tagInfo.attr.value.slice(0, offset);\n                    query.attrName = this.tagInfo.attr.name;\n                }\n                this.updateExclusion(false);\n            } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n                // We get negative offset for a quoted attribute value with some leading whitespaces\n                // as in <a rel= \"rtl\" where the cursor is just to the right of the \"=\".\n                // So just set the queryStr to an empty string.\n                query.queryStr = \"\";\n                query.attrName = this.tagInfo.attr.name;\n            }\n\n            query.usedAttr = HTMLUtils.getTagAttributes(this.editor, cursor);\n        }\n\n        if (query.tag && query.queryStr !== null) {\n            var tagName = query.tag,\n                attrName = query.attrName,\n                filter = query.queryStr,\n                unfiltered = [],\n                hints;\n\n            if (attrName) {\n                hints = this._getValueHintsForAttr(query, tagName, attrName);\n            } else if (tags && tags[tagName] && tags[tagName].attributes) {\n                unfiltered = tags[tagName].attributes.concat(this.globalAttributes);\n                hints = $.grep(unfiltered, function (attr, i) {\n                    return $.inArray(attr, query.usedAttr) < 0;\n                });\n            }\n\n            if (hints instanceof Array && hints.length) {\n                console.assert(!result.length);\n                result = $.map(hints, function (item) {\n                    if (item.indexOf(filter) === 0) {\n                        return item;\n                    }\n                }).sort();\n                return {\n                    hints: result,\n                    match: query.queryStr,\n                    selectInitial: true,\n                    handleWideResults: false\n                };\n            } else if (hints instanceof Object && hints.hasOwnProperty(\"done\")) { // Deferred hints\n                var deferred = $.Deferred();\n                hints.done(function (asyncHints) {\n                    deferred.resolveWith(this, [{\n                        hints: asyncHints,\n                        match: query.queryStr,\n                        selectInitial: true,\n                        handleWideResults: false\n                    }]);\n                });\n                return deferred;\n            }\n            return null;\n\n        }\n\n\n    };\n\n    /**\n     * Inserts a given HTML attribute hint into the current editor context.\n     *\n     * @param {string} hint\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    AttrHints.prototype.insertHint = function (completion) {\n        var cursor = this.editor.getCursorPos(),\n            start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            tokenType = this.tagInfo.position.tokenType,\n            offset = this.tagInfo.position.offset,\n            charCount = 0,\n            insertedName = false,\n            replaceExistingOne = this.tagInfo.attr.valueAssigned,\n            endQuote = \"\",\n            shouldReplace = true,\n            textAfterCursor;\n\n        if (tokenType === HTMLUtils.ATTR_NAME) {\n            textAfterCursor = this.tagInfo.attr.name.substr(offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = offset;\n                replaceExistingOne = false;\n            } else {\n                charCount = this.tagInfo.attr.name.length;\n            }\n            // Append an equal sign and two double quotes if the current attr is not an empty attr\n            // and then adjust cursor location before the last quote that we just inserted.\n            if (!replaceExistingOne && attributes && attributes[completion] &&\n                    attributes[completion].type !== \"flag\") {\n                completion += \"=\\\"\\\"\";\n                insertedName = true;\n            } else if (completion === this.tagInfo.attr.name) {\n                shouldReplace = false;\n            }\n        } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n            textAfterCursor = this.tagInfo.attr.value.substr(offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = offset;\n                // Set exclusion to null only after attribute value insertion,\n                // not after attribute name insertion since we need to keep it\n                // for attribute value insertion.\n                this.exclusion = null;\n            } else {\n                charCount = this.tagInfo.attr.value.length;\n            }\n\n            if (!this.tagInfo.attr.hasEndQuote) {\n                endQuote = this.tagInfo.attr.quoteChar;\n                if (endQuote) {\n                    completion += endQuote;\n                } else if (offset === 0) {\n                    completion = \"\\\"\" + completion + \"\\\"\";\n                }\n            } else if (completion === this.tagInfo.attr.value) {\n                shouldReplace = false;\n            }\n        }\n\n        end.line = start.line = cursor.line;\n        start.ch = cursor.ch - offset;\n        end.ch = start.ch + charCount;\n\n        if (shouldReplace) {\n            if (start.ch !== end.ch) {\n                this.editor.document.replaceRange(completion, start, end);\n            } else {\n                this.editor.document.replaceRange(completion, start);\n            }\n        }\n\n        if (insertedName) {\n            this.editor.setCursorPos(start.line, start.ch + completion.length - 1);\n\n            // Since we're now inside the double-quotes we just inserted,\n            // immediately pop up the attribute value hint.\n            return true;\n        } else if (tokenType === HTMLUtils.ATTR_VALUE && this.tagInfo.attr.hasEndQuote) {\n            // Move the cursor to the right of the existing end quote after value insertion.\n            this.editor.setCursorPos(start.line, start.ch + completion.length + 1);\n        }\n\n        return false;\n    };\n\n    /**\n     * @constructor\n     */\n    function NewDocContentProvider() {\n        this.CONTENT_PROVIDER_NAME = \"HTMLCodeHints\";\n    }\n\n    NewDocContentProvider.prototype.getContent = function(fileName) {\n        return new Promise((resolve, reject)=>{\n            if(fileName.endsWith(\".xhtml\")){\n                resolve(XHTMLTemplate);\n                return;\n            }\n            resolve(HTMLTemplate);\n        });\n    };\n\n    AppInit.appReady(function () {\n        // Parse JSON files\n        tags = JSON.parse(HTMLTags);\n        attributes = JSON.parse(HTMLAttributes);\n\n        // Register code hint providers\n        let tagHints = new TagHints();\n        let attrHints = new AttrHints();\n        let newDocContentProvider = new NewDocContentProvider();\n        CodeHintManager.registerHintProvider(tagHints, [\"html\"], 0);\n        CodeHintManager.registerHintProvider(attrHints, [\"html\"], 0);\n        NewFileContentManager.registerContentProvider(newDocContentProvider, [\"html\"], 0);\n\n        // For unit testing\n        exports.tagHintProvider = tagHints;\n        exports.attrHintProvider = attrHints;\n    });\n});\n"],"file":"main.js"}
{"version":3,"sources":["thirdparty/acorn/dist/walk.js"],"names":["global","factory","exports","module","define","amd","self","acorn","walk","this","simple","node","visitors","baseVisitor","state","override","base","c","st","type","found","ancestor","ancestors","isNew","length","push","pop","recursive","funcs","visitor","make","undefined","makeTest","test","Found","full","callback","last","fullAncestor","findNodeAt","start","end","e","findNodeAround","pos","findNodeAfter","findNodeBefore","max","Object","create","skipThrough","ignore","_node","_st","_c","Program","BlockStatement","StaticBlock","i","list","body","stmt","Statement","EmptyStatement","ExpressionStatement","ParenthesizedExpression","ChainExpression","expression","IfStatement","consequent","alternate","LabeledStatement","BreakStatement","ContinueStatement","WithStatement","object","SwitchStatement","discriminant","i$1","list$1","cases","cs","cons","SwitchCase","ReturnStatement","YieldExpression","AwaitExpression","argument","ThrowStatement","SpreadElement","TryStatement","block","handler","finalizer","CatchClause","param","WhileStatement","DoWhileStatement","ForStatement","init","update","ForInStatement","ForOfStatement","left","right","ForInit","DebuggerStatement","FunctionDeclaration","VariableDeclaration","declarations","decl","VariableDeclarator","id","Function","params","Pattern","VariablePattern","MemberPattern","RestElement","ArrayPattern","elements","elt","ObjectPattern","properties","prop","computed","key","value","Expression","ThisExpression","Super","MetaProperty","ArrayExpression","ObjectExpression","FunctionExpression","ArrowFunctionExpression","SequenceExpression","expressions","expr","TemplateLiteral","quasis","quasi","TemplateElement","UnaryExpression","UpdateExpression","BinaryExpression","LogicalExpression","AssignmentExpression","AssignmentPattern","ConditionalExpression","NewExpression","CallExpression","callee","arguments","arg","MemberExpression","property","ExportNamedDeclaration","ExportDefaultDeclaration","declaration","source","ExportAllDeclaration","exported","ImportDeclaration","specifiers","spec","ImportExpression","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","Identifier","PrivateIdentifier","Literal","TaggedTemplateExpression","tag","ClassDeclaration","ClassExpression","Class","superClass","ClassBody","MethodDefinition","PropertyDefinition","Property","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory((global.acorn = global.acorn || {}, global.acorn.walk = {})));\n}(this, (function (exports) { 'use strict';\n\n  // AST walker module for Mozilla Parser API compatible trees\n\n  // A simple walk is one where you simply specify callbacks to be\n  // called on specific nodes. The last two arguments are optional. A\n  // simple use would be\n  //\n  //     walk.simple(myTree, {\n  //         Expression: function(node) { ... }\n  //     });\n  //\n  // to do something with all expressions. All Parser API node types\n  // can be used to identify node types, as well as Expression and\n  // Statement, which denote categories of nodes.\n  //\n  // The base argument can be used to pass a custom (recursive)\n  // walker, and state can be used to give this walked an initial\n  // state.\n\n  function simple(node, visitors, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type];\n      baseVisitor[type](node, st, c);\n      if (found) { found(node, st); }\n    })(node, state, override);\n  }\n\n  // An ancestor walk keeps an array of ancestor nodes (including the\n  // current node) and passes them to the callback as third parameter\n  // (and also as state parameter when no other state is present).\n  function ancestor(node, visitors, baseVisitor, state, override) {\n    var ancestors = [];\n    if (!baseVisitor) { baseVisitor = base\n    ; }(function c(node, st, override) {\n      var type = override || node.type, found = visitors[type];\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (found) { found(node, st || ancestors, ancestors); }\n      if (isNew) { ancestors.pop(); }\n    })(node, state, override);\n  }\n\n  // A recursive walk is one where your functions override the default\n  // walkers. They can modify and replace the state parameter that's\n  // threaded through the walk, and can opt how and whether to walk\n  // their child nodes (by calling their third argument on these\n  // nodes).\n  function recursive(node, state, funcs, baseVisitor, override) {\n    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\n    ;(function c(node, st, override) {\n      visitor[override || node.type](node, st, c);\n    })(node, state, override);\n  }\n\n  function makeTest(test) {\n    if (typeof test === \"string\")\n      { return function (type) { return type === test; } }\n    else if (!test)\n      { return function () { return true; } }\n    else\n      { return test }\n  }\n\n  var Found = function Found(node, state) { this.node = node; this.state = state; };\n\n  // A full walk triggers the callback on each node\n  function full(node, callback, baseVisitor, state, override) {\n    if (!baseVisitor) { baseVisitor = base; }\n    var last\n    ;(function c(node, st, override) {\n      var type = override || node.type;\n      baseVisitor[type](node, st, c);\n      if (last !== node) {\n        callback(node, st, type);\n        last = node;\n      }\n    })(node, state, override);\n  }\n\n  // An fullAncestor walk is like an ancestor walk, but triggers\n  // the callback on each node\n  function fullAncestor(node, callback, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    var ancestors = [], last\n    ;(function c(node, st, override) {\n      var type = override || node.type;\n      var isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) { ancestors.push(node); }\n      baseVisitor[type](node, st, c);\n      if (last !== node) {\n        callback(node, st || ancestors, ancestors, type);\n        last = node;\n      }\n      if (isNew) { ancestors.pop(); }\n    })(node, state);\n  }\n\n  // Find a node with a given start, end, and type (all are optional,\n  // null can be used as wildcard). Returns a {node, state} object, or\n  // undefined when it doesn't find a matching node.\n  function findNodeAt(node, start, end, test, baseVisitor, state) {\n    if (!baseVisitor) { baseVisitor = base; }\n    test = makeTest(test);\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if ((start == null || node.start <= start) &&\n            (end == null || node.end >= end))\n          { baseVisitor[type](node, st, c); }\n        if ((start == null || node.start === start) &&\n            (end == null || node.end === end) &&\n            test(type, node))\n          { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the innermost node of a given type that contains the given\n  // position. Interface similar to findNodeAt.\n  function findNodeAround(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        var type = override || node.type;\n        if (node.start > pos || node.end < pos) { return }\n        baseVisitor[type](node, st, c);\n        if (test(type, node)) { throw new Found(node, st) }\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node after a given position.\n  function findNodeAfter(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    try {\n      (function c(node, st, override) {\n        if (node.end < pos) { return }\n        var type = override || node.type;\n        if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n        baseVisitor[type](node, st, c);\n      })(node, state);\n    } catch (e) {\n      if (e instanceof Found) { return e }\n      throw e\n    }\n  }\n\n  // Find the outermost matching node before a given position.\n  function findNodeBefore(node, pos, test, baseVisitor, state) {\n    test = makeTest(test);\n    if (!baseVisitor) { baseVisitor = base; }\n    var max\n    ;(function c(node, st, override) {\n      if (node.start > pos) { return }\n      var type = override || node.type;\n      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n        { max = new Found(node, st); }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n    return max\n  }\n\n  // Used to create a custom walker. Will fill in all missing node\n  // type properties with the defaults.\n  function make(funcs, baseVisitor) {\n    var visitor = Object.create(baseVisitor || base);\n    for (var type in funcs) { visitor[type] = funcs[type]; }\n    return visitor\n  }\n\n  function skipThrough(node, st, c) { c(node, st); }\n  function ignore(_node, _st, _c) {}\n\n  // Node walkers.\n\n  var base = {};\n\n  base.Program = base.BlockStatement = base.StaticBlock = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var stmt = list[i];\n\n      c(stmt, st, \"Statement\");\n    }\n  };\n  base.Statement = skipThrough;\n  base.EmptyStatement = ignore;\n  base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =\n    function (node, st, c) { return c(node.expression, st, \"Expression\"); };\n  base.IfStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Statement\");\n    if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n  };\n  base.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\n  base.BreakStatement = base.ContinueStatement = ignore;\n  base.WithStatement = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.SwitchStatement = function (node, st, c) {\n    c(node.discriminant, st, \"Expression\");\n    for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n      var cs = list$1[i$1];\n\n      if (cs.test) { c(cs.test, st, \"Expression\"); }\n      for (var i = 0, list = cs.consequent; i < list.length; i += 1)\n        {\n        var cons = list[i];\n\n        c(cons, st, \"Statement\");\n      }\n    }\n  };\n  base.SwitchCase = function (node, st, c) {\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    for (var i = 0, list = node.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  };\n  base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n    if (node.argument) { c(node.argument, st, \"Expression\"); }\n  };\n  base.ThrowStatement = base.SpreadElement =\n    function (node, st, c) { return c(node.argument, st, \"Expression\"); };\n  base.TryStatement = function (node, st, c) {\n    c(node.block, st, \"Statement\");\n    if (node.handler) { c(node.handler, st); }\n    if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n  };\n  base.CatchClause = function (node, st, c) {\n    if (node.param) { c(node.param, st, \"Pattern\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForStatement = function (node, st, c) {\n    if (node.init) { c(node.init, st, \"ForInit\"); }\n    if (node.test) { c(node.test, st, \"Expression\"); }\n    if (node.update) { c(node.update, st, \"Expression\"); }\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInStatement = base.ForOfStatement = function (node, st, c) {\n    c(node.left, st, \"ForInit\");\n    c(node.right, st, \"Expression\");\n    c(node.body, st, \"Statement\");\n  };\n  base.ForInit = function (node, st, c) {\n    if (node.type === \"VariableDeclaration\") { c(node, st); }\n    else { c(node, st, \"Expression\"); }\n  };\n  base.DebuggerStatement = ignore;\n\n  base.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\n  base.VariableDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.declarations; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      c(decl, st);\n    }\n  };\n  base.VariableDeclarator = function (node, st, c) {\n    c(node.id, st, \"Pattern\");\n    if (node.init) { c(node.init, st, \"Expression\"); }\n  };\n\n  base.Function = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      c(param, st, \"Pattern\");\n    }\n    c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n  };\n\n  base.Pattern = function (node, st, c) {\n    if (node.type === \"Identifier\")\n      { c(node, st, \"VariablePattern\"); }\n    else if (node.type === \"MemberExpression\")\n      { c(node, st, \"MemberPattern\"); }\n    else\n      { c(node, st); }\n  };\n  base.VariablePattern = ignore;\n  base.MemberPattern = skipThrough;\n  base.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\n  base.ArrayPattern = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Pattern\"); }\n    }\n  };\n  base.ObjectPattern = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1) {\n      var prop = list[i];\n\n      if (prop.type === \"Property\") {\n        if (prop.computed) { c(prop.key, st, \"Expression\"); }\n        c(prop.value, st, \"Pattern\");\n      } else if (prop.type === \"RestElement\") {\n        c(prop.argument, st, \"Pattern\");\n      }\n    }\n  };\n\n  base.Expression = skipThrough;\n  base.ThisExpression = base.Super = base.MetaProperty = ignore;\n  base.ArrayExpression = function (node, st, c) {\n    for (var i = 0, list = node.elements; i < list.length; i += 1) {\n      var elt = list[i];\n\n      if (elt) { c(elt, st, \"Expression\"); }\n    }\n  };\n  base.ObjectExpression = function (node, st, c) {\n    for (var i = 0, list = node.properties; i < list.length; i += 1)\n      {\n      var prop = list[i];\n\n      c(prop, st);\n    }\n  };\n  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n  base.SequenceExpression = function (node, st, c) {\n    for (var i = 0, list = node.expressions; i < list.length; i += 1)\n      {\n      var expr = list[i];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateLiteral = function (node, st, c) {\n    for (var i = 0, list = node.quasis; i < list.length; i += 1)\n      {\n      var quasi = list[i];\n\n      c(quasi, st);\n    }\n\n    for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n      {\n      var expr = list$1[i$1];\n\n      c(expr, st, \"Expression\");\n    }\n  };\n  base.TemplateElement = ignore;\n  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n    c(node.argument, st, \"Expression\");\n  };\n  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n    c(node.left, st, \"Expression\");\n    c(node.right, st, \"Expression\");\n  };\n  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n    c(node.left, st, \"Pattern\");\n    c(node.right, st, \"Expression\");\n  };\n  base.ConditionalExpression = function (node, st, c) {\n    c(node.test, st, \"Expression\");\n    c(node.consequent, st, \"Expression\");\n    c(node.alternate, st, \"Expression\");\n  };\n  base.NewExpression = base.CallExpression = function (node, st, c) {\n    c(node.callee, st, \"Expression\");\n    if (node.arguments)\n      { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n        {\n          var arg = list[i];\n\n          c(arg, st, \"Expression\");\n        } }\n  };\n  base.MemberExpression = function (node, st, c) {\n    c(node.object, st, \"Expression\");\n    if (node.computed) { c(node.property, st, \"Expression\"); }\n  };\n  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n    if (node.declaration)\n      { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n    if (node.source) { c(node.source, st, \"Expression\"); }\n  };\n  base.ExportAllDeclaration = function (node, st, c) {\n    if (node.exported)\n      { c(node.exported, st); }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportDeclaration = function (node, st, c) {\n    for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n      {\n      var spec = list[i];\n\n      c(spec, st);\n    }\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportExpression = function (node, st, c) {\n    c(node.source, st, \"Expression\");\n  };\n  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;\n\n  base.TaggedTemplateExpression = function (node, st, c) {\n    c(node.tag, st, \"Expression\");\n    c(node.quasi, st, \"Expression\");\n  };\n  base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\n  base.Class = function (node, st, c) {\n    if (node.id) { c(node.id, st, \"Pattern\"); }\n    if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n    c(node.body, st);\n  };\n  base.ClassBody = function (node, st, c) {\n    for (var i = 0, list = node.body; i < list.length; i += 1)\n      {\n      var elt = list[i];\n\n      c(elt, st);\n    }\n  };\n  base.MethodDefinition = base.PropertyDefinition = base.Property = function (node, st, c) {\n    if (node.computed) { c(node.key, st, \"Expression\"); }\n    if (node.value) { c(node.value, st, \"Expression\"); }\n  };\n\n  exports.ancestor = ancestor;\n  exports.base = base;\n  exports.findNodeAfter = findNodeAfter;\n  exports.findNodeAround = findNodeAround;\n  exports.findNodeAt = findNodeAt;\n  exports.findNodeBefore = findNodeBefore;\n  exports.full = full;\n  exports.fullAncestor = fullAncestor;\n  exports.make = make;\n  exports.recursive = recursive;\n  exports.simple = simple;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"file":"walk.js"}
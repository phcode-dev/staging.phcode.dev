{"version":3,"sources":["thirdparty/tern/plugin/doc_comment.js"],"names":["mod","exports","module","require","define","amd","tern","comment","acorn","walk","infer","WG_MADEUP","WG_STRONG","postParse","ast","text","attachComments","node","ensureCommentsBefore","simple","VariableDeclaration","FunctionDeclaration","MethodDefinition","Property","AssignmentExpression","operator","CallExpression","isDefinePropertyCall","ExportNamedDeclaration","ExportDefaultDeclaration","ClassDeclaration","callee","type","object","name","property","arguments","length","value","postInfer","scope","jsdocParseTypedefs","sourceFile","decl","declarations","id","commentsBefore","interpretComments","getProp","fnType","objType","expressionType","left","state","ObjectExpression","i","properties","prop","propName","Class","proto","getObjType","body","method","kind","Obj","props","declaration","searchVisitor","postLoadDef","data","defs","cx","orig","parent","jsdocTypedefs","maybeInstance","def","parse","stripLeadingChars","lines","head","line","lineHead","match","same","charCodeAt","slice","map","replace","j","found","indexOf","pop","shift","comments","aval","jsdocInterpretComments","AVal","types","origin","curOrigin","doc","split","join","skipSpace","str","pos","test","charAt","isIdentifier","string","isIdentifierStart","isIdentifierChar","parseLabelList","close","labels","madeUp","first","colon","label","push","parseType","end","next","parseTypeAtom","result","parseTypeInner","Arr","union","inner","propagate","isOptional","args","ret","ANull","retType","Fn","fields","field","defProp","initializer","start","word","num","bool","inAngles","key","val","path","parsePath","jsdocPlaceholders","Object","create","getInstance","parseTypeOuter","foundOne","self","parsed","m","exec","undefined","argname","isObjProp","parts","objname","getType","applyType","re","rest","index","propType","propagateWithWeight","target","weight","docComment","isFunExpr","fn","init","right","argNames","known","retval","registerPlugin","server","options","on","strong","fullDocs"],"mappings":"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","sourcesContent":["// Parses comments above variable declarations, function declarations,\n// and object properties as docstrings and JSDoc-style type\n// annotations.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    return mod(require(\"../lib/infer\"), require(\"../lib/tern\"), require(\"../lib/comment\"),\n               require(\"acorn\"), require(\"acorn-walk\"));\n  if (typeof define == \"function\" && define.amd) // AMD\n    return define([\"../lib/infer\", \"../lib/tern\", \"../lib/comment\", \"acorn/dist/acorn\", \"acorn-walk/dist/walk\"], mod);\n  mod(tern, tern, tern.comment, acorn, acorn.walk);\n})(function(infer, tern, comment, acorn, walk) {\n  \"use strict\";\n\n  var WG_MADEUP = 1, WG_STRONG = 101;\n\n  tern.registerPlugin(\"doc_comment\", function(server, options) {\n    server.mod.jsdocTypedefs = Object.create(null);\n    server.on(\"reset\", function() {\n      server.mod.jsdocTypedefs = Object.create(null);\n    });\n    server.mod.docComment = {\n      weight: options && options.strong ? WG_STRONG : undefined,\n      fullDocs: options && options.fullDocs\n    };\n\n    server.on(\"postParse\", postParse);\n    server.on(\"postInfer\", postInfer);\n    server.on(\"postLoadDef\", postLoadDef);\n  });\n\n  function postParse(ast, text) {\n    function attachComments(node) { comment.ensureCommentsBefore(text, node); }\n\n    walk.simple(ast, {\n      VariableDeclaration: attachComments,\n      FunctionDeclaration: attachComments,\n      MethodDefinition: attachComments,\n      Property: attachComments,\n      AssignmentExpression: function(node) {\n        if (node.operator == \"=\") attachComments(node);\n      },\n      CallExpression: function(node) {\n        if (isDefinePropertyCall(node)) attachComments(node);\n      },\n      ExportNamedDeclaration: attachComments,\n      ExportDefaultDeclaration: attachComments,\n      ClassDeclaration: attachComments\n    });\n  }\n\n  function isDefinePropertyCall(node) {\n    return node.callee.type == \"MemberExpression\" &&\n      node.callee.object.name == \"Object\" &&\n      node.callee.property.name == \"defineProperty\" &&\n      node.arguments.length >= 3 &&\n      typeof node.arguments[1].value == \"string\";\n  }\n\n  function postInfer(ast, scope) {\n    jsdocParseTypedefs(ast.sourceFile.text, scope);\n\n    walk.simple(ast, {\n      VariableDeclaration: function(node, scope) {\n        var decl = node.declarations[0].id;\n        if (node.commentsBefore && decl.type == \"Identifier\")\n          interpretComments(node, node.commentsBefore, scope,\n                            scope.getProp(node.declarations[0].id.name));\n      },\n      FunctionDeclaration: function(node, scope) {\n        if (node.commentsBefore)\n          interpretComments(node, node.commentsBefore, scope,\n                            scope.getProp(node.id.name),\n                            node.scope.fnType);\n      },\n      ClassDeclaration: function(node, scope) {\n        if (node.commentsBefore)\n          interpretComments(node, node.commentsBefore, scope,\n                            scope.getProp(node.id.name),\n                            node.objType);\n      },\n      AssignmentExpression: function(node, scope) {\n        if (node.commentsBefore)\n          interpretComments(node, node.commentsBefore, scope,\n                            infer.expressionType({node: node.left, state: scope}));\n      },\n      ObjectExpression: function(node, scope) {\n        for (var i = 0; i < node.properties.length; ++i) {\n          var prop = node.properties[i];\n          if (prop.type == 'SpreadElement') { continue; }\n          var name = infer.propName(prop);\n          if (name != \"<i>\" && prop.commentsBefore)\n            interpretComments(prop, prop.commentsBefore, scope, node.objType.getProp(name));\n        }\n      },\n      Class: function(node, scope) {\n        if (!node.objType) return;\n        var proto = node.objType.getProp(\"prototype\").getObjType();\n        if (!proto) return;\n        for (var i = 0; i < node.body.body.length; i++) {\n          var method = node.body.body[i], name;\n          if (!method.commentsBefore) continue;\n          if (method.kind == \"constructor\")\n            interpretComments(method, method.commentsBefore, scope, node.objType);\n          else if ((name = infer.propName(method)) != \"<i>\")\n            interpretComments(method, method.commentsBefore, scope, proto.getProp(name));\n        }\n      },\n      CallExpression: function(node, scope) {\n        if (node.commentsBefore && isDefinePropertyCall(node)) {\n          var type = infer.expressionType({node: node.arguments[0], state: scope}).getObjType();\n          if (type && type instanceof infer.Obj) {\n            var prop = type.props[node.arguments[1].value];\n            if (prop) interpretComments(node, node.commentsBefore, scope, prop);\n          }\n        }\n      },\n      ExportNamedDeclaration: function(node, scope) {\n        if (node.commentsBefore && node.declaration && node.declaration.type === 'FunctionDeclaration') {\n          interpretComments(node.declaration, node.commentsBefore, scope,\n                            scope.getProp(node.declaration.id.name),\n                            node.declaration.scope.fnType);\n        }\n      },\n      ExportDefaultDeclaration: function(node, scope) {\n        if (node.commentsBefore && node.declaration && node.declaration.type === 'FunctionDeclaration') {\n          interpretComments(node.declaration, node.commentsBefore, scope,\n                            scope.getProp(node.declaration.id.name),\n                            node.declaration.scope.fnType);\n        }\n      }\n    }, infer.searchVisitor, scope);\n  }\n\n  function postLoadDef(data) {\n    var defs = data[\"!typedef\"];\n    var cx = infer.cx(), orig = data[\"!name\"];\n    if (defs) for (var name in defs)\n      cx.parent.mod.jsdocTypedefs[name] =\n        maybeInstance(infer.def.parse(defs[name], orig, name), name);\n  }\n\n  // COMMENT INTERPRETATION\n\n  function stripLeadingChars(lines) {\n    for (var head, i = 1; i < lines.length; i++) {\n      var line = lines[i], lineHead = line.match(/^[\\s\\*]*/)[0];\n      if (lineHead != line) {\n        if (head == null) {\n          head = lineHead;\n        } else {\n          var same = 0;\n          while (same < head.length && head.charCodeAt(same) == lineHead.charCodeAt(same)) ++same;\n          if (same < head.length) head = head.slice(0, same);\n        }\n      }\n    }\n    lines = lines.map(function(line, i) {\n      line = line.replace(/\\s+$/, \"\");\n      if (i == 0 && head != null) {\n        for (var j = 0; j < head.length; j++) {\n          var found = line.indexOf(head.slice(j));\n          if (found == 0) return line.slice(head.length - j);\n        }\n      }\n      if (head == null || i == 0) return line.replace(/^[\\s\\*]*/, \"\");\n      if (line.length < head.length) return \"\";\n      return line.slice(head.length);\n    });\n    while (lines.length && !lines[lines.length - 1]) lines.pop();\n    while (lines.length && !lines[0]) lines.shift();\n    return lines;\n  }\n\n  function interpretComments(node, comments, scope, aval, type) {\n    jsdocInterpretComments(node, scope, aval, comments);\n    var cx = infer.cx();\n\n    if (!type && aval instanceof infer.AVal && aval.types.length) {\n      type = aval.types[aval.types.length - 1];\n      if (!(type instanceof infer.Obj) || type.origin != cx.curOrigin || type.doc)\n        type = null;\n    }\n\n    for (var i = comments.length - 1; i >= 0; i--) {\n      var text = stripLeadingChars(comments[i].split(/\\r\\n?|\\n/)).join(\"\\n\");\n      if (text) {\n        if (aval instanceof infer.AVal) aval.doc = text;\n        if (type) type.doc = text;\n        break;\n      }\n    }\n  }\n\n  // Parses a subset of JSDoc-style comments in order to include the\n  // explicitly defined types in the analysis.\n\n  function skipSpace(str, pos) {\n    while (/\\s/.test(str.charAt(pos))) ++pos;\n    return pos;\n  }\n\n  function isIdentifier(string) {\n    if (!acorn.isIdentifierStart(string.charCodeAt(0))) return false;\n    for (var i = 1; i < string.length; i++)\n      if (!acorn.isIdentifierChar(string.charCodeAt(i))) return false;\n    return true;\n  }\n\n  function parseLabelList(scope, str, pos, close) {\n    var labels = [], types = [], madeUp = false;\n    for (var first = true; ; first = false) {\n      pos = skipSpace(str, pos);\n      if (first && str.charAt(pos) == close) break;\n      var colon = str.indexOf(\":\", pos);\n      if (colon < 0) return null;\n      var label = str.slice(pos, colon);\n      if (!isIdentifier(label)) return null;\n      labels.push(label);\n      pos = colon + 1;\n      var type = parseType(scope, str, pos);\n      if (!type) return null;\n      pos = type.end;\n      madeUp = madeUp || type.madeUp;\n      types.push(type.type);\n      pos = skipSpace(str, pos);\n      var next = str.charAt(pos);\n      ++pos;\n      if (next == close) break;\n      if (next != \",\") return null;\n    }\n    return {labels: labels, types: types, end: pos, madeUp: madeUp};\n  }\n\n  function parseTypeAtom(scope, str, pos) {\n    var result = parseTypeInner(scope, str, pos);\n    if (!result) return null;\n    if (str.slice(result.end, result.end + 2) == \"[]\")\n      return {madeUp: result.madeUp, end: result.end + 2, type: new infer.Arr(result.type)};\n    else return result;\n  }\n\n  function parseType(scope, str, pos) {\n    var type, union = false, madeUp = false;\n    for (;;) {\n      var inner = parseTypeAtom(scope, str, pos);\n      if (!inner) return null;\n      madeUp = madeUp || inner.madeUp;\n      if (union) inner.type.propagate(union);\n      else type = inner.type;\n      pos = skipSpace(str, inner.end);\n      if (str.charAt(pos) != \"|\") break;\n      pos++;\n      if (!union) {\n        union = new infer.AVal;\n        type.propagate(union);\n        type = union;\n      }\n    }\n    var isOptional = false;\n    if (str.charAt(pos) == \"=\") {\n      ++pos;\n      isOptional = true;\n    }\n    return {type: type, end: pos, isOptional: isOptional, madeUp: madeUp};\n  }\n\n  function parseTypeInner(scope, str, pos) {\n    pos = skipSpace(str, pos);\n    if (/[?!]/.test(str.charAt(pos))) pos++;\n    var type, madeUp = false;\n\n    if (str.indexOf(\"function(\", pos) == pos) {\n      var args = parseLabelList(scope, str, pos + 9, \")\"), ret = infer.ANull;\n      if (!args) return null;\n      pos = skipSpace(str, args.end);\n      if (str.charAt(pos) == \":\") {\n        ++pos;\n        var retType = parseType(scope, str, pos + 1);\n        if (!retType) return null;\n        pos = retType.end;\n        ret = retType.type;\n        madeUp = retType.madeUp;\n      }\n      type = new infer.Fn(null, infer.ANull, args.types, args.labels, ret);\n    } else if (str.charAt(pos) == \"[\") {\n      var inner = parseType(scope, str, pos + 1);\n      if (!inner) return null;\n      pos = skipSpace(str, inner.end);\n      madeUp = inner.madeUp;\n      if (str.charAt(pos) != \"]\") return null;\n      ++pos;\n      type = new infer.Arr(inner.type);\n    } else if (str.charAt(pos) == \"{\") {\n      var fields = parseLabelList(scope, str, pos + 1, \"}\");\n      if (!fields) return null;\n      type = new infer.Obj(true);\n      for (var i = 0; i < fields.types.length; ++i) {\n        var field = type.defProp(fields.labels[i]);\n        field.initializer = true;\n        fields.types[i].propagate(field);\n      }\n      pos = fields.end;\n      madeUp = fields.madeUp;\n    } else if (str.charAt(pos) == \"(\") {\n      var inner = parseType(scope, str, pos + 1);\n      if (!inner) return null;\n      pos = skipSpace(str, inner.end);\n      if (str.charAt(pos) != \")\") return null;\n      ++pos;\n      type = inner.type;\n    } else {\n      var start = pos;\n      if (!acorn.isIdentifierStart(str.charCodeAt(pos))) return null;\n      while (acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;\n      if (start == pos) return null;\n      var word = str.slice(start, pos);\n      if (/^(number|integer)$/i.test(word)) type = infer.cx().num;\n      else if (/^bool(ean)?$/i.test(word)) type = infer.cx().bool;\n      else if (/^string$/i.test(word)) type = infer.cx().str;\n      else if (/^(null|undefined)$/i.test(word)) type = infer.ANull;\n      else if (/^array$/i.test(word)) {\n        var inner = null;\n        if (str.charAt(pos) == \".\" && str.charAt(pos + 1) == \"<\") {\n          var inAngles = parseType(scope, str, pos + 2);\n          if (!inAngles) return null;\n          pos = skipSpace(str, inAngles.end);\n          madeUp = inAngles.madeUp;\n          if (str.charAt(pos++) != \">\") return null;\n          inner = inAngles.type;\n        }\n        type = new infer.Arr(inner);\n      } else if (/^object$/i.test(word)) {\n        type = new infer.Obj(true);\n        if (str.charAt(pos) == \".\" && str.charAt(pos + 1) == \"<\") {\n          var key = parseType(scope, str, pos + 2);\n          if (!key) return null;\n          pos = skipSpace(str, key.end);\n          if (str.charAt(pos++) != \",\") return null;\n          var val = parseType(scope, str, pos);\n          if (!val) return null;\n          pos = skipSpace(str, val.end);\n          madeUp = key.madeUp || val.madeUp;\n          if (str.charAt(pos++) != \">\") return null;\n          val.type.propagate(type.defProp(\"<i>\"));\n        }\n      } else {\n        while (str.charCodeAt(pos) == 46 ||\n               acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;\n        var path = str.slice(start, pos);\n        var cx = infer.cx(), defs = cx.parent && cx.parent.mod.jsdocTypedefs, found;\n        if (defs && (path in defs)) {\n          type = defs[path];\n        } else if (found = infer.def.parsePath(path, scope).getObjType()) {\n          type = maybeInstance(found, path);\n        } else {\n          if (!cx.jsdocPlaceholders) cx.jsdocPlaceholders = Object.create(null);\n          if (!(path in cx.jsdocPlaceholders))\n            type = cx.jsdocPlaceholders[path] = new infer.Obj(null, path);\n          else\n            type = cx.jsdocPlaceholders[path];\n          madeUp = true;\n        }\n      }\n    }\n\n    return {type: type, end: pos, madeUp: madeUp};\n  }\n\n  function maybeInstance(type, path) {\n    if (type instanceof infer.Fn && /(?:^|\\.)[A-Z][^\\.]*$/.test(path)) {\n      var proto = type.getProp(\"prototype\").getObjType();\n      if (proto instanceof infer.Obj) return infer.getInstance(proto);\n    }\n    return type;\n  }\n\n  function parseTypeOuter(scope, str, pos) {\n    pos = skipSpace(str, pos || 0);\n    if (str.charAt(pos) != \"{\") return null;\n    var result = parseType(scope, str, pos + 1);\n    if (!result) return null;\n    var end = skipSpace(str, result.end);\n    if (str.charAt(end) != \"}\") return null;\n    result.end = end + 1;\n    return result;\n  }\n\n  function jsdocInterpretComments(node, scope, aval, comments) {\n    var type, args, ret, foundOne, self, parsed;\n\n    for (var i = 0; i < comments.length; ++i) {\n      var comment = comments[i];\n      var decl = /(?:\\n|\\*)\\s*@(type|param|arg(?:ument)?|returns?|this|class|constructor)(?:\\s*?\\n|\\s+(.*))/g, m;\n      while (m = decl.exec(comment)) {\n        if (m[1] == \"class\" || m[1] == \"constructor\") {\n          self = foundOne = true;\n          continue;\n        }\n\n        if (m[2] === undefined) continue; // to avoid tags that require a type argument.\n\n        if (m[1] == \"this\" && (parsed = parseType(scope, m[2], 0))) {\n          self = parsed;\n          foundOne = true;\n          continue;\n        }\n\n        if (!(parsed = parseTypeOuter(scope, m[2]))) continue;\n        foundOne = true;\n\n        switch(m[1]) {\n        case \"returns\": case \"return\":\n          ret = parsed; break;\n        case \"type\":\n          type = parsed; break;\n        case \"param\": case \"arg\": case \"argument\":\n            // Possible jsdoc param name situations:\n            // employee\n            // [employee]\n            // [employee=John Doe]\n            // employee.name\n            // employees[].name\n            var name = m[2].slice(parsed.end).match(/^\\s*(\\[?)\\s*([^\\[\\]\\s=]+(\\[\\][^\\[\\]\\s=]+)?)\\s*(?:=[^\\]]+\\s*)?(\\]?).*/);\n            if (!name) continue;\n            var argname = name[2] + (parsed.isOptional || (name[1] === '[' && name[4] === ']') ? \"?\" : \"\");\n\n            // Check to see if the jsdoc is indicating a property of a previously documented parameter\n            var isObjProp = false;\n            var parts = argname.split('.');\n            if (args && parts.length == 2) {\n              var objname = parts[0];\n              argname = parts[1];\n\n              // Go through each of the previously found parameter to find the\n              // object or array for which this new parameter should be a part\n              // of\n              var key, value;\n              for (key in args) {\n                value = args[key];\n\n                if (key === objname && value.type instanceof infer.Obj) {\n                  isObjProp = true;\n                  parsed.type.propagate(value.type.defProp(argname));\n                }\n                else if (key + '[]' === objname && value.type instanceof infer.Arr) {\n                  isObjProp = true;\n                  parsed.type.propagate(value.type.getProp(\"<i>\").getType().defProp(argname));\n                }\n              }\n            }\n            if (!isObjProp) {\n              (args || (args = Object.create(null)))[argname] = parsed;\n            }\n          break;\n        }\n      }\n    }\n\n    if (foundOne) applyType(type, self, args, ret, node, aval);\n  }\n\n  function jsdocParseTypedefs(text, scope) {\n    var cx = infer.cx();\n\n    var re = /\\s@typedef\\s+(.*)/g, m;\n    while (m = re.exec(text)) {\n      var parsed = parseTypeOuter(scope, m[1]);\n      var name = parsed && m[1].slice(parsed.end).match(/^\\s*(\\S+)/);\n      if (name && parsed.type instanceof infer.Obj) {\n        var rest = text.slice(m.index + m[0].length);\n        while (m = /\\s+@prop(?:erty)?\\s+(.*)/.exec(rest)) {\n          var propType = parseTypeOuter(scope, m[1]), propName;\n          if (propType && (propName = m[1].slice(propType.end).match(/^\\s*(\\S+)/)))\n            propType.type.propagate(parsed.type.defProp(propName[1]));\n          rest = rest.slice(m[0].length);\n        }\n        cx.parent.mod.jsdocTypedefs[name[1]] = parsed.type;\n      }\n    }\n  }\n\n  function propagateWithWeight(type, target) {\n    var weight = infer.cx().parent.mod.docComment.weight;\n    type.type.propagate(target, weight || (type.madeUp ? WG_MADEUP : undefined));\n  }\n\n  function isFunExpr(node) { return node.type == \"FunctionExpression\" || node.type == \"ArrowFunctionExpression\" }\n\n  function applyType(type, self, args, ret, node, aval) {\n    var fn;\n    if (node.type == \"VariableDeclaration\") {\n      var decl = node.declarations[0];\n      if (decl.init && isFunExpr(decl.init)) fn = decl.init.scope.fnType;\n    } else if (node.type == \"FunctionDeclaration\") {\n      fn = node.scope.fnType;\n    } else if (node.type == \"AssignmentExpression\") {\n      if (isFunExpr(node.right))\n        fn = node.right.scope.fnType;\n    } else if (node.type == \"CallExpression\" || node.type === \"ClassDeclaration\") {\n    } else { // An object property\n      if (isFunExpr(node.value)) fn = node.value.scope.fnType;\n    }\n\n    if (fn && (args || ret || self)) {\n      if (args) for (var i = 0; i < fn.argNames.length; ++i) {\n        var name = fn.argNames[i], known = args[name];\n        if (!known && (known = args[name + \"?\"]))\n          fn.argNames[i] += \"?\";\n        if (known) propagateWithWeight(known, fn.args[i]);\n      }\n      if (ret) {\n        if (fn.retval == infer.ANull) fn.retval = new infer.AVal;\n        propagateWithWeight(ret, fn.retval);\n      }\n      if (self === true) {\n        var proto = fn.getProp(\"prototype\").getObjType();\n        self = proto && {type: infer.getInstance(proto, fn)};\n      }\n      if (self) propagateWithWeight(self, fn.self);\n    } else if (type) {\n      propagateWithWeight(type, aval);\n    }\n  }\n});\n"],"file":"doc_comment.js"}
{"version":3,"sources":["thirdparty/CodeMirror/addon/search/searchcursor.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","Pos","doFold","noFold","regexpFlags","regexp","flags","ignoreCase","global","multiline","ensureFlags","current","target","i","length","indexOf","charAt","RegExp","source","maybeMultiline","test","searchRegexpForward","doc","start","line","ch","last","lastLine","lastIndex","string","getLine","match","exec","from","index","to","searchRegexpForwardMultiline","chunk","curLine","before","slice","split","inside","startLine","startCh","lastMatchIn","endMargin","newMatch","end","searchRegexpBackward","first","firstLine","searchRegexpBackwardMultiline","chunkSize","adjustPos","orig","folded","pos","foldFunc","min","max","Math","mid","len","searchStringForward","query","caseFold","fold","lines","search","found","cutFrom","endString","searchStringBackward","lastIndexOf","top","topString","SearchCursor","options","this","atOccurrence","afterEmptyMatch","clipPos","matches","reverse","String","prototype","normalize","str","toLowerCase","findNext","find","findPrevious","head","cmpPos","result","replace","newText","origin","splitLines","replaceRange","defineExtension","defineDocExtension","ranges","cur","getSearchCursor","getCursor","push","anchor","setSelections"],"mappings":"CAGA,SAAUA,KACc,iBAAXC,SAAwC,iBAAVC,OACvCF,IAAIG,QAAQ,yBACY,mBAAVC,QAAwBA,OAAOC,IAC7CD,OAAO,CAAC,wBAAyBJ,KAEjCA,IAAIM,YANR,CAOG,SAASA,YACV,aACA,IAAIC,IAAMD,WAAWC,IAgHjBC,OAAQC,OA9GZ,SAASC,YAAYC,QACnB,IAAIC,MAAQD,OAAOC,MACnB,OAAgB,MAATA,MAAgBA,OAASD,OAAOE,WAAa,IAAM,KACrDF,OAAOG,OAAS,IAAM,KACtBH,OAAOI,UAAY,IAAM,IAGhC,SAASC,YAAYL,OAAQC,OAE3B,IADA,IAAIK,QAAUP,YAAYC,QAASO,OAASD,QACnCE,EAAI,EAAGA,EAAIP,MAAMQ,OAAQD,KAA6C,GAApCD,OAAOG,QAAQT,MAAMU,OAAOH,MACrED,QAAUN,MAAMU,OAAOH,IACzB,OAAOF,SAAWC,OAASP,OAAS,IAAIY,OAAOZ,OAAOa,OAAQN,QAGhE,SAASO,eAAed,QACtB,MAAO,0BAA0Be,KAAKf,OAAOa,QAG/C,SAASG,oBAAoBC,IAAKjB,OAAQkB,OACxClB,OAASK,YAAYL,OAAQ,KAC7B,IAAK,IAAImB,KAAOD,MAAMC,KAAMC,GAAKF,MAAME,GAAIC,KAAOJ,IAAIK,WAAYH,MAAQE,KAAMF,OAAQC,GAAK,EAAG,CAC9FpB,OAAOuB,UAAYH,GACnB,IAAII,OAASP,IAAIQ,QAAQN,MAAOO,MAAQ1B,OAAO2B,KAAKH,QACpD,GAAIE,MACF,MAAO,CAACE,KAAMhC,IAAIuB,KAAMO,MAAMG,OACtBC,GAAIlC,IAAIuB,KAAMO,MAAMG,MAAQH,MAAM,GAAGjB,QACrCiB,MAAOA,QAIrB,SAASK,6BAA6Bd,IAAKjB,OAAQkB,OACjD,IAAKJ,eAAed,QAAS,OAAOgB,oBAAoBC,IAAKjB,OAAQkB,OAErElB,OAASK,YAAYL,OAAQ,MAE7B,IADA,IAAIwB,OAAQQ,MAAQ,EACXb,KAAOD,MAAMC,KAAME,KAAOJ,IAAIK,WAAYH,MAAQE,MAAO,CAMhE,IAAK,IAAIb,EAAI,EAAGA,EAAIwB,SACdb,KAAOE,MADcb,IAAK,CAE9B,IAAIyB,QAAUhB,IAAIQ,QAAQN,QAC1BK,OAAmB,MAAVA,OAAiBS,QAAUT,OAAS,KAAOS,QAEtDD,OAAgB,EAChBhC,OAAOuB,UAAYL,MAAME,GACzB,IAAIM,MAAQ1B,OAAO2B,KAAKH,QACxB,GAAIE,MAAO,CACT,IAAIQ,OAASV,OAAOW,MAAM,EAAGT,MAAMG,OAAOO,MAAM,MAAOC,OAASX,MAAM,GAAGU,MAAM,MAC3EE,UAAYpB,MAAMC,KAAOe,OAAOzB,OAAS,EAAG8B,QAAUL,OAAOA,OAAOzB,OAAS,GAAGA,OACpF,MAAO,CAACmB,KAAMhC,IAAI0C,UAAWC,SACrBT,GAAIlC,IAAI0C,UAAYD,OAAO5B,OAAS,EACX,GAAjB4B,OAAO5B,OAAc8B,QAAUF,OAAO,GAAG5B,OAAS4B,OAAOA,OAAO5B,OAAS,GAAGA,QACpFiB,MAAOA,SAKrB,SAASc,YAAYhB,OAAQxB,OAAQyC,WAEnC,IADA,IAAIf,MAAOE,KAAO,EACXA,MAAQJ,OAAOf,QAAQ,CAC5BT,OAAOuB,UAAYK,KACnB,IAAIc,SAAW1C,OAAO2B,KAAKH,QAC3B,IAAKkB,SAAU,MACf,IAAIC,IAAMD,SAASb,MAAQa,SAAS,GAAGjC,OACvC,GAAIkC,IAAMnB,OAAOf,OAASgC,UAAW,QAChCf,OAASiB,IAAMjB,MAAMG,MAAQH,MAAM,GAAGjB,UACzCiB,MAAQgB,UACVd,KAAOc,SAASb,MAAQ,EAE1B,OAAOH,MAGT,SAASkB,qBAAqB3B,IAAKjB,OAAQkB,OACzClB,OAASK,YAAYL,OAAQ,KAC7B,IAAK,IAAImB,KAAOD,MAAMC,KAAMC,GAAKF,MAAME,GAAIyB,MAAQ5B,IAAI6B,YAAa3B,MAAQ0B,MAAO1B,OAAQC,IAAM,EAAG,CAClG,IAAII,OAASP,IAAIQ,QAAQN,MACrBO,MAAQc,YAAYhB,OAAQxB,OAAQoB,GAAK,EAAI,EAAII,OAAOf,OAASW,IACrE,GAAIM,MACF,MAAO,CAACE,KAAMhC,IAAIuB,KAAMO,MAAMG,OACtBC,GAAIlC,IAAIuB,KAAMO,MAAMG,MAAQH,MAAM,GAAGjB,QACrCiB,MAAOA,QAIrB,SAASqB,8BAA8B9B,IAAKjB,OAAQkB,OAClD,IAAKJ,eAAed,QAAS,OAAO4C,qBAAqB3B,IAAKjB,OAAQkB,OACtElB,OAASK,YAAYL,OAAQ,MAE7B,IADA,IAAIwB,OAAQwB,UAAY,EAAGP,UAAYxB,IAAIQ,QAAQP,MAAMC,MAAMV,OAASS,MAAME,GACrED,KAAOD,MAAMC,KAAM0B,MAAQ5B,IAAI6B,YAAa3B,MAAQ0B,OAAQ,CACnE,IAAK,IAAIrC,EAAI,EAAGA,EAAIwC,WAAa7B,MAAQ0B,MAAOrC,IAAK,CACnD,IAAIyB,QAAUhB,IAAIQ,QAAQN,QAC1BK,OAAmB,MAAVA,OAAiBS,QAAUA,QAAU,KAAOT,OAEvDwB,WAAa,EAEb,IAAItB,MAAQc,YAAYhB,OAAQxB,OAAQyC,WACxC,GAAIf,MAAO,CACT,IAAIQ,OAASV,OAAOW,MAAM,EAAGT,MAAMG,OAAOO,MAAM,MAAOC,OAASX,MAAM,GAAGU,MAAM,MAC3EE,UAAYnB,KAAOe,OAAOzB,OAAQ8B,QAAUL,OAAOA,OAAOzB,OAAS,GAAGA,OAC1E,MAAO,CAACmB,KAAMhC,IAAI0C,UAAWC,SACrBT,GAAIlC,IAAI0C,UAAYD,OAAO5B,OAAS,EACX,GAAjB4B,OAAO5B,OAAc8B,QAAUF,OAAO,GAAG5B,OAAS4B,OAAOA,OAAO5B,OAAS,GAAGA,QACpFiB,MAAOA,SAgBrB,SAASuB,UAAUC,KAAMC,OAAQC,IAAKC,UACpC,GAAIH,KAAKzC,QAAU0C,OAAO1C,OAAQ,OAAO2C,IACzC,IAAK,IAAIE,IAAM,EAAGC,IAAMH,IAAMI,KAAKD,IAAI,EAAGL,KAAKzC,OAAS0C,OAAO1C,UAAW,CACxE,GAAI6C,KAAOC,IAAK,OAAOD,IACvB,IAAIG,IAAOH,IAAMC,KAAQ,EACrBG,IAAML,SAASH,KAAKf,MAAM,EAAGsB,MAAMhD,OACvC,GAAIiD,KAAON,IAAK,OAAOK,IACdC,IAAMN,IAAKG,IAAME,IACrBH,IAAMG,IAAM,GAIrB,SAASE,oBAAoB1C,IAAK2C,MAAO1C,MAAO2C,UAG9C,IAAKD,MAAMnD,OAAQ,OAAO,KAC1B,IAAIqD,KAAOD,SAAWhE,OAASC,OAC3BiE,MAAQD,KAAKF,OAAOxB,MAAM,YAE9B4B,OAAQ,IAAK,IAAI7C,KAAOD,MAAMC,KAAMC,GAAKF,MAAME,GAAIC,KAAOJ,IAAIK,WAAa,EAAIyC,MAAMtD,OAAQU,MAAQE,KAAMF,OAAQC,GAAK,EAAG,CACzH,IAAI8B,KAAOjC,IAAIQ,QAAQN,MAAMgB,MAAMf,IAAKI,OAASsC,KAAKZ,MACtD,GAAoB,GAAhBa,MAAMtD,OAAa,CACrB,IAAIwD,MAAQzC,OAAOd,QAAQqD,MAAM,IACjC,IAAc,GAAVE,MAAa,SAASD,OAC1B,IAAI9C,MAAQ+B,UAAUC,KAAM1B,OAAQyC,MAAOH,MAAQ1C,GACnD,MAAO,CAACQ,KAAMhC,IAAIuB,KAAM8B,UAAUC,KAAM1B,OAAQyC,MAAOH,MAAQ1C,IACvDU,GAAIlC,IAAIuB,KAAM8B,UAAUC,KAAM1B,OAAQyC,MAAQF,MAAM,GAAGtD,OAAQqD,MAAQ1C,KAE/E,IAAI8C,QAAU1C,OAAOf,OAASsD,MAAM,GAAGtD,OACvC,GAAIe,OAAOW,MAAM+B,UAAYH,MAAM,GAAnC,CACA,IAAK,IAAIvD,EAAI,EAAGA,EAAIuD,MAAMtD,OAAS,EAAGD,IACpC,GAAIsD,KAAK7C,IAAIQ,QAAQN,KAAOX,KAAOuD,MAAMvD,GAAI,SAASwD,OACxD,IAAIrB,IAAM1B,IAAIQ,QAAQN,KAAO4C,MAAMtD,OAAS,GAAI0D,UAAYL,KAAKnB,KAAMrB,SAAWyC,MAAMA,MAAMtD,OAAS,GACvG,GAAI0D,UAAUhC,MAAM,EAAGb,SAASb,SAAWa,SAC3C,MAAO,CAACM,KAAMhC,IAAIuB,KAAM8B,UAAUC,KAAM1B,OAAQ0C,QAASJ,MAAQ1C,IACzDU,GAAIlC,IAAIuB,KAAO4C,MAAMtD,OAAS,EAAGwC,UAAUN,IAAKwB,UAAW7C,SAASb,OAAQqD,UAK1F,SAASM,qBAAqBnD,IAAK2C,MAAO1C,MAAO2C,UAC/C,IAAKD,MAAMnD,OAAQ,OAAO,KAC1B,IAAIqD,KAAOD,SAAWhE,OAASC,OAC3BiE,MAAQD,KAAKF,OAAOxB,MAAM,YAE9B4B,OAAQ,IAAK,IAAI7C,KAAOD,MAAMC,KAAMC,GAAKF,MAAME,GAAIyB,MAAQ5B,IAAI6B,YAAc,EAAIiB,MAAMtD,OAAQU,MAAQ0B,MAAO1B,OAAQC,IAAM,EAAG,CAC7H,IAAI8B,KAAOjC,IAAIQ,QAAQN,MACnBC,IAAM,IAAG8B,KAAOA,KAAKf,MAAM,EAAGf,KAClC,IAAII,OAASsC,KAAKZ,MAClB,GAAoB,GAAhBa,MAAMtD,OAAa,CACrB,IAAIwD,MAAQzC,OAAO6C,YAAYN,MAAM,IACrC,IAAc,GAAVE,MAAa,SAASD,OAC1B,MAAO,CAACpC,KAAMhC,IAAIuB,KAAM8B,UAAUC,KAAM1B,OAAQyC,MAAOH,OAC/ChC,GAAIlC,IAAIuB,KAAM8B,UAAUC,KAAM1B,OAAQyC,MAAQF,MAAM,GAAGtD,OAAQqD,QAEvE,IAAIxC,SAAWyC,MAAMA,MAAMtD,OAAS,GACpC,GAAIe,OAAOW,MAAM,EAAGb,SAASb,SAAWa,SAAxC,CACA,IAAK,IAAId,EAAI,EAAGU,MAAQC,KAAO4C,MAAMtD,OAAS,EAAGD,EAAIuD,MAAMtD,OAAS,EAAGD,IACrE,GAAIsD,KAAK7C,IAAIQ,QAAQP,MAAQV,KAAOuD,MAAMvD,GAAI,SAASwD,OACzD,IAAIM,IAAMrD,IAAIQ,QAAQN,KAAO,EAAI4C,MAAMtD,QAAS8D,UAAYT,KAAKQ,KACjE,GAAIC,UAAUpC,MAAMoC,UAAU9D,OAASsD,MAAM,GAAGtD,SAAWsD,MAAM,GACjE,MAAO,CAACnC,KAAMhC,IAAIuB,KAAO,EAAI4C,MAAMtD,OAAQwC,UAAUqB,IAAKC,UAAWD,IAAI7D,OAASsD,MAAM,GAAGtD,OAAQqD,OAC3FhC,GAAIlC,IAAIuB,KAAM8B,UAAUC,KAAM1B,OAAQF,SAASb,OAAQqD,UAKrE,SAASU,aAAavD,IAAK2C,MAAOR,IAAKqB,SAOrC,IAAIZ,SANJa,KAAKC,cAAe,EACpBD,KAAKE,iBAAkB,EACvBF,KAAKzD,IAAMA,IACXmC,IAAMA,IAAMnC,IAAI4D,QAAQzB,KAAOxD,IAAI,EAAG,GACtC8E,KAAKtB,IAAM,CAACxB,KAAMwB,IAAKtB,GAAIsB,KAGL,iBAAXqB,QACTZ,SAAWY,QAAQZ,UAEnBA,SAAWY,QACXA,QAAU,MAGQ,iBAATb,OACO,MAAZC,WAAkBA,UAAW,GACjCa,KAAKI,QAAU,SAASC,QAAS3B,KAC/B,OAAQ2B,QAAUX,qBAAuBT,qBAAqB1C,IAAK2C,MAAOR,IAAKS,aAGjFD,MAAQvD,YAAYuD,MAAO,MACtBa,UAAiC,IAAtBA,QAAQrE,UAKtBsE,KAAKI,QAAU,SAASC,QAAS3B,KAC/B,OAAQ2B,QAAUnC,qBAAuB5B,qBAAqBC,IAAK2C,MAAOR,MAL5EsB,KAAKI,QAAU,SAASC,QAAS3B,KAC/B,OAAQ2B,QAAUhC,8BAAgChB,8BAA8Bd,IAAK2C,MAAOR,OArGhG4B,OAAOC,UAAUC,WACnBrF,OAAS,SAASsF,KAAO,OAAOA,IAAID,UAAU,OAAOE,eACrDtF,OAAS,SAASqF,KAAO,OAAOA,IAAID,UAAU,UAE9CrF,OAAS,SAASsF,KAAO,OAAOA,IAAIC,eACpCtF,OAAS,SAASqF,KAAO,OAAOA,MAyGlCX,aAAaS,UAAY,CACvBI,SAAU,WAAY,OAAOX,KAAKY,MAAK,IACvCC,aAAc,WAAY,OAAOb,KAAKY,MAAK,IAE3CA,KAAM,SAASP,SACb,IAAIS,KAAOd,KAAKzD,IAAI4D,QAAQE,QAAUL,KAAKtB,IAAIxB,KAAO8C,KAAKtB,IAAItB,IAC/D,GAAI4C,KAAKE,iBAAmBF,KAAKC,eAE/Ba,KAAO5F,IAAI4F,KAAKrE,KAAMqE,KAAKpE,IACvB2D,SACFS,KAAKpE,KACDoE,KAAKpE,GAAK,IACZoE,KAAKrE,OACLqE,KAAKpE,IAAMsD,KAAKzD,IAAIQ,QAAQ+D,KAAKrE,OAAS,IAAIV,UAGhD+E,KAAKpE,KACDoE,KAAKpE,IAAMsD,KAAKzD,IAAIQ,QAAQ+D,KAAKrE,OAAS,IAAIV,SAChD+E,KAAKpE,GAAK,EACVoE,KAAKrE,SAG8C,GAAnDxB,WAAW8F,OAAOD,KAAMd,KAAKzD,IAAI4D,QAAQW,QAC1C,OAAOd,KAAKC,cAAe,EAGhC,IAAIe,OAAShB,KAAKI,QAAQC,QAASS,MAGnC,GAFAd,KAAKE,gBAAkBc,QAAuD,GAA7C/F,WAAW8F,OAAOC,OAAO9D,KAAM8D,OAAO5D,IAEnE4D,OAGF,OAFAhB,KAAKtB,IAAMsC,OACXhB,KAAKC,cAAe,EACbD,KAAKtB,IAAI1B,QAAS,EAEzB,IAAIiB,IAAM/C,IAAImF,QAAUL,KAAKzD,IAAI6B,YAAc4B,KAAKzD,IAAIK,WAAa,EAAG,GAExE,OADAoD,KAAKtB,IAAM,CAACxB,KAAMe,IAAKb,GAAIa,KACpB+B,KAAKC,cAAe,GAI/B/C,KAAM,WAAY,GAAI8C,KAAKC,aAAc,OAAOD,KAAKtB,IAAIxB,MACzDE,GAAI,WAAY,GAAI4C,KAAKC,aAAc,OAAOD,KAAKtB,IAAItB,IAEvD6D,QAAS,SAASC,QAASC,QACzB,GAAKnB,KAAKC,aAAV,CACA,IAAIZ,MAAQpE,WAAWmG,WAAWF,SAClClB,KAAKzD,IAAI8E,aAAahC,MAAOW,KAAKtB,IAAIxB,KAAM8C,KAAKtB,IAAItB,GAAI+D,QACzDnB,KAAKtB,IAAItB,GAAKlC,IAAI8E,KAAKtB,IAAIxB,KAAKT,KAAO4C,MAAMtD,OAAS,EACpCsD,MAAMA,MAAMtD,OAAS,GAAGA,QAA0B,GAAhBsD,MAAMtD,OAAciE,KAAKtB,IAAIxB,KAAKR,GAAK,OAI/FzB,WAAWqG,gBAAgB,kBAAmB,SAASpC,MAAOR,IAAKS,UACjE,OAAO,IAAIW,aAAaE,KAAKzD,IAAK2C,MAAOR,IAAKS,YAEhDlE,WAAWsG,mBAAmB,kBAAmB,SAASrC,MAAOR,IAAKS,UACpE,OAAO,IAAIW,aAAaE,KAAMd,MAAOR,IAAKS,YAG5ClE,WAAWqG,gBAAgB,gBAAiB,SAASpC,MAAOC,UAG1D,IAFA,IAAIqC,OAAS,GACTC,IAAMzB,KAAK0B,gBAAgBxC,MAAOc,KAAK2B,UAAU,QAASxC,UACvDsC,IAAId,cACL1F,WAAW8F,OAAOU,IAAIrE,KAAM4C,KAAK2B,UAAU,OAAS,IACxDH,OAAOI,KAAK,CAACC,OAAQJ,IAAIvE,OAAQ4D,KAAMW,IAAIrE,OAEzCoE,OAAOzF,QACTiE,KAAK8B,cAAcN,OAAQ","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp, endMargin) {\n    var match, from = 0\n    while (from <= string.length) {\n      regexp.lastIndex = from\n      var newMatch = regexp.exec(string)\n      if (!newMatch) break\n      var end = newMatch.index + newMatch[0].length\n      if (end > string.length - endMargin) break\n      if (!match || end > match.index + match[0].length)\n        match = newMatch\n      from = newMatch.index + 1\n    }\n    return match\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start)\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunkSize && line >= first; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine : curLine + \"\\n\" + string\n      }\n      chunkSize *= 2\n\n      var match = lastMatchIn(string, regexp, endMargin)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.afterEmptyMatch = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n      if (this.afterEmptyMatch && this.atOccurrence) {\n        // do not return the same 0 width match twice\n        head = Pos(head.line, head.ch)\n        if (reverse) {\n          head.ch--;\n          if (head.ch < 0) {\n            head.line--;\n            head.ch = (this.doc.getLine(head.line) || \"\").length;\n          }\n        } else {\n          head.ch++;\n          if (head.ch > (this.doc.getLine(head.line) || \"\").length) {\n            head.ch = 0;\n            head.line++;\n          }\n        }\n        if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {\n           return this.atOccurrence = false\n        }\n      }\n      var result = this.matches(reverse, head)\n      this.afterEmptyMatch = result && CodeMirror.cmpPos(result.from, result.to) == 0\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n"],"file":"searchcursor.js"}
{"version":3,"sources":["thirdparty/CodeMirror/addon/fold/xml-fold.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","Pos","cmp","a","b","line","ch","nameStartChar","nameChar","xmlTagStart","RegExp","Iter","cm","range","this","text","getLine","min","Math","max","from","firstLine","to","lastLine","tagAt","iter","type","getTokenTypeAt","test","nextLine","prevLine","length","toTagEnd","gt","indexOf","lastSlash","lastIndexOf","selfClose","slice","toTagStart","lt","lastIndex","match","exec","index","toNextTag","found","toPrevTag","findMatchingClose","tag","stack","next","end","startLine","startCh","i","push","findMatchingOpen","prev","endLine","endCh","start","registerHelper","openTag","startPos","endPos","findMatchingTag","pos","here","open","close","at","findEnclosingTag","forward","scanForClosingTag","name"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }\n\n  var nameStartChar = \"A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n  var nameChar = nameStartChar + \"\\-\\:\\.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n  var xmlTagStart = new RegExp(\"<(/?)([\" + nameStartChar + \"][\" + nameChar + \"]*)\", \"g\");\n\n  function Iter(cm, line, ch, range) {\n    this.line = line; this.ch = ch;\n    this.cm = cm; this.text = cm.getLine(line);\n    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();\n    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();\n  }\n\n  function tagAt(iter, ch) {\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\n    return type && /\\btag\\b/.test(type);\n  }\n\n  function nextLine(iter) {\n    if (iter.line >= iter.max) return;\n    iter.ch = 0;\n    iter.text = iter.cm.getLine(++iter.line);\n    return true;\n  }\n  function prevLine(iter) {\n    if (iter.line <= iter.min) return;\n    iter.text = iter.cm.getLine(--iter.line);\n    iter.ch = iter.text.length;\n    return true;\n  }\n\n  function toTagEnd(iter) {\n    for (;;) {\n      var gt = iter.text.indexOf(\">\", iter.ch);\n      if (gt == -1) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n  function toTagStart(iter) {\n    for (;;) {\n      var lt = iter.ch ? iter.text.lastIndexOf(\"<\", iter.ch - 1) : -1;\n      if (lt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }\n      xmlTagStart.lastIndex = lt;\n      iter.ch = lt;\n      var match = xmlTagStart.exec(iter.text);\n      if (match && match.index == lt) return match;\n    }\n  }\n\n  function toNextTag(iter) {\n    for (;;) {\n      xmlTagStart.lastIndex = iter.ch;\n      var found = xmlTagStart.exec(iter.text);\n      if (!found) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }\n      iter.ch = found.index + found[0].length;\n      return found;\n    }\n  }\n  function toPrevTag(iter) {\n    for (;;) {\n      var gt = iter.ch ? iter.text.lastIndexOf(\">\", iter.ch - 1) : -1;\n      if (gt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n\n  function findMatchingClose(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);\n      if (!next || !(end = toTagEnd(iter))) return;\n      if (end == \"selfClose\") continue;\n      if (next[1]) { // closing tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == next[2])) return {\n          tag: next[2],\n          from: Pos(startLine, startCh),\n          to: Pos(iter.line, iter.ch)\n        };\n      } else { // opening tag\n        stack.push(next[2]);\n      }\n    }\n  }\n  function findMatchingOpen(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var prev = toPrevTag(iter);\n      if (!prev) return;\n      if (prev == \"selfClose\") { toTagStart(iter); continue; }\n      var endLine = iter.line, endCh = iter.ch;\n      var start = toTagStart(iter);\n      if (!start) return;\n      if (start[1]) { // closing tag\n        stack.push(start[2]);\n      } else { // opening tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == start[2])) return {\n          tag: start[2],\n          from: Pos(iter.line, iter.ch),\n          to: Pos(endLine, endCh)\n        };\n      }\n    }\n  }\n\n  CodeMirror.registerHelper(\"fold\", \"xml\", function(cm, start) {\n    var iter = new Iter(cm, start.line, 0);\n    for (;;) {\n      var openTag = toNextTag(iter)\n      if (!openTag || iter.line != start.line) return\n      var end = toTagEnd(iter)\n      if (!end) return\n      if (!openTag[1] && end != \"selfClose\") {\n        var startPos = Pos(iter.line, iter.ch);\n        var endPos = findMatchingClose(iter, openTag[2]);\n        return endPos && cmp(endPos.from, startPos) > 0 ? {from: startPos, to: endPos.from} : null\n      }\n    }\n  });\n  CodeMirror.findMatchingTag = function(cm, pos, range) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    if (iter.text.indexOf(\">\") == -1 && iter.text.indexOf(\"<\") == -1) return;\n    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);\n    var start = end && toTagStart(iter);\n    if (!end || !start || cmp(iter, pos) > 0) return;\n    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};\n    if (end == \"selfClose\") return {open: here, close: null, at: \"open\"};\n\n    if (start[1]) { // closing tag\n      return {open: findMatchingOpen(iter, start[2]), close: here, at: \"close\"};\n    } else { // opening tag\n      iter = new Iter(cm, to.line, to.ch, range);\n      return {open: here, close: findMatchingClose(iter, start[2]), at: \"open\"};\n    }\n  };\n\n  CodeMirror.findEnclosingTag = function(cm, pos, range, tag) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    for (;;) {\n      var open = findMatchingOpen(iter, tag);\n      if (!open) break;\n      var forward = new Iter(cm, pos.line, pos.ch, range);\n      var close = findMatchingClose(forward, open.tag);\n      if (close) return {open: open, close: close};\n    }\n  };\n\n  // Used by addon/edit/closetag.js\n  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);\n    return findMatchingClose(iter, name);\n  };\n});\n"],"file":"xml-fold.js"}
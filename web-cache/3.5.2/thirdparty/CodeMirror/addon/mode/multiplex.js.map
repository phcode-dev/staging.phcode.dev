{"version":3,"sources":["thirdparty/CodeMirror/addon/mode/multiplex.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","multiplexingMode","outer","others","Array","prototype","slice","call","arguments","indexOf","string","pattern","from","returnEnd","found","length","m","exec","index","startState","innerActive","inner","startingInner","copyState","state","mode","token","stream","curInner","oldContent","close","sol","this","pos","parseDelimiters","match","delimStyle","innerToken","start","innerStyle","cutOff","Infinity","i","other","open","outerIndent","indent","possibleOuterIndent","Pass","outerToken","textAfter","line","blankLine","electricChars","innerMode"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.multiplexingMode = function(outer /*, others */) {\n  // Others should be {open, close, mode [, delimStyle] [, innerStyle] [, parseDelimiters]} objects\n  var others = Array.prototype.slice.call(arguments, 1);\n\n  function indexOf(string, pattern, from, returnEnd) {\n    if (typeof pattern == \"string\") {\n      var found = string.indexOf(pattern, from);\n      return returnEnd && found > -1 ? found + pattern.length : found;\n    }\n    var m = pattern.exec(from ? string.slice(from) : string);\n    return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;\n  }\n\n  return {\n    startState: function() {\n      return {\n        outer: CodeMirror.startState(outer),\n        innerActive: null,\n        inner: null,\n        startingInner: false\n      };\n    },\n\n    copyState: function(state) {\n      return {\n        outer: CodeMirror.copyState(outer, state.outer),\n        innerActive: state.innerActive,\n        inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner),\n        startingInner: state.startingInner\n      };\n    },\n\n    token: function(stream, state) {\n      if (!state.innerActive) {\n        var cutOff = Infinity, oldContent = stream.string;\n        for (var i = 0; i < others.length; ++i) {\n          var other = others[i];\n          var found = indexOf(oldContent, other.open, stream.pos);\n          if (found == stream.pos) {\n            if (!other.parseDelimiters) stream.match(other.open);\n            state.startingInner = !!other.parseDelimiters\n            state.innerActive = other;\n\n            // Get the outer indent, making sure to handle CodeMirror.Pass\n            var outerIndent = 0;\n            if (outer.indent) {\n              var possibleOuterIndent = outer.indent(state.outer, \"\", \"\");\n              if (possibleOuterIndent !== CodeMirror.Pass) outerIndent = possibleOuterIndent;\n            }\n\n            state.inner = CodeMirror.startState(other.mode, outerIndent);\n            return other.delimStyle && (other.delimStyle + \" \" + other.delimStyle + \"-open\");\n          } else if (found != -1 && found < cutOff) {\n            cutOff = found;\n          }\n        }\n        if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);\n        var outerToken = outer.token(stream, state.outer);\n        if (cutOff != Infinity) stream.string = oldContent;\n        return outerToken;\n      } else {\n        var curInner = state.innerActive, oldContent = stream.string;\n        if (!curInner.close && stream.sol()) {\n          state.innerActive = state.inner = null;\n          return this.token(stream, state);\n        }\n        var found = curInner.close && !state.startingInner ?\n            indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;\n        if (found == stream.pos && !curInner.parseDelimiters) {\n          stream.match(curInner.close);\n          state.innerActive = state.inner = null;\n          return curInner.delimStyle && (curInner.delimStyle + \" \" + curInner.delimStyle + \"-close\");\n        }\n        if (found > -1) stream.string = oldContent.slice(0, found);\n        var innerToken = curInner.mode.token(stream, state.inner);\n        if (found > -1) stream.string = oldContent;\n        else if (stream.pos > stream.start) state.startingInner = false\n\n        if (found == stream.pos && curInner.parseDelimiters)\n          state.innerActive = state.inner = null;\n\n        if (curInner.innerStyle) {\n          if (innerToken) innerToken = innerToken + \" \" + curInner.innerStyle;\n          else innerToken = curInner.innerStyle;\n        }\n\n        return innerToken;\n      }\n    },\n\n    indent: function(state, textAfter, line) {\n      var mode = state.innerActive ? state.innerActive.mode : outer;\n      if (!mode.indent) return CodeMirror.Pass;\n      return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);\n    },\n\n    blankLine: function(state) {\n      var mode = state.innerActive ? state.innerActive.mode : outer;\n      if (mode.blankLine) {\n        mode.blankLine(state.innerActive ? state.inner : state.outer);\n      }\n      if (!state.innerActive) {\n        for (var i = 0; i < others.length; ++i) {\n          var other = others[i];\n          if (other.open === \"\\n\") {\n            state.innerActive = other;\n            state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, \"\", \"\") : 0);\n          }\n        }\n      } else if (state.innerActive.close === \"\\n\") {\n        state.innerActive = state.inner = null;\n      }\n    },\n\n    electricChars: outer.electricChars,\n\n    innerMode: function(state) {\n      return state.inner ? {state: state.inner, mode: state.innerActive.mode} : {state: state.outer, mode: outer};\n    }\n  };\n};\n\n});\n"],"file":"multiplex.js"}
{"version":3,"sources":["search/QuickSearchField.js"],"names":["define","require","exports","module","KeyEvent","PopUpManager","QuickSearchField","$input","options","this","maxResults","_handleInput","bind","_handleKeyDown","undefined","highlightZeroResults","_highlightZeroResults","on","_firstHighlightIndex","firstHighlightIndex","_dropdownTop","offset","top","height","verticalAdjust","prototype","_pending","_commitPending","_displayedQuery","_displayedResults","_highlightIndex","_$dropdown","valueAtEvent","val","self","setTimeout","updateResults","event","keyCode","DOM_VK_RETURN","stopPropagation","preventDefault","_doCommit","DOM_VK_DELETE","onDelete","DOM_VK_DOWN","length","_updateHighlight","DOM_VK_UP","index","item","onCommit","explicit","$items","find","removeClass","eq","addClass","onHighlight","query","results","resultProvider","done","fail","realResults","_render","_closeDropdown","remove","focusLastActiveElementOnClose","_$currentlyFocusedElement","is","focus","_openDropdown","htmlContent","$","document","activeElement","appendTo","css","position","left","width","outerWidth","click","$item","target","closest","html","addPopUp","destroy","onDismiss","popupManagesFocus","error","hasOwnProperty","count","Math","min","i","formatter","setText","value","off"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*\n * Text field with attached dropdown list that is updated (based on a provider) whenever the text changes.\n *\n * For styling, the DOM structure of the popup is as follows:\n *  body\n *      ol.quick-search-container\n *          li\n *          li.highlight\n *          li\n * And the text field is:\n *      input\n *      input.no-results\n */\ndefine(function (require, exports, module) {\n\n\n    const KeyEvent = require(\"utils/KeyEvent\"),\n        PopUpManager      = require(\"widgets/PopUpManager\");\n\n\n    /**\n     * Attaches to an existing <input> tag\n     *\n     * @constructor\n     *\n     * @param {!jQueryObject} $input\n     * @param {!function(string):($.Promise|Array.<*>|{error:?string}} options.resultProvider\n     *          Given the current search text, returns an an array of result objects, an error object, or a\n     *          Promise that yields one of those. If the Promise is still outstanding when the query next\n     *          changes, resultProvider() will be called again (without waiting for the earlier Promise), and\n     *          the Promise's result will be ignored.\n     *          If the provider yields [], or a non-null error string, input is decorated with \".no-results\"; if\n     *          the provider yields a null error string, input is not decorated.\n     *\n     * @param {!function(*, string):string} options.formatter\n     *          Converts one result object to a string of HTML text. Passed the item and the current query. The\n     *          outermost element must be <li>. The \".highlight\" class can be ignored as it is applied automatically.\n     * @param {!function(?*, string, number):void} options.onCommit\n     *          Called when an item is selected by clicking or pressing Enter. Passed the committed item and the current\n     *          query and its index. If the current result list is not up to date with the query text at the time Enter is\n     *          pressed, waits until it is before running this callback. If Enter pressed with no results, passed\n     *          null. The popup remains open after this event.\n     * @param {!function(*, string, boolean):void} options.onHighlight\n     *          Called when an item is highlighted in the list. Passed the item, the current query, and a flag that is\n     *          true if the item was highlighted explicitly (arrow keys), not simply due to a results list update. Since\n     *          the top item in the list is always initially highlighted, every time the list is updated onHighlight()\n     *          is called with the top item and with the explicit flag set to false.\n     * @param {!function(*):void} options.onDelete\n     *          Called when delete key is pressed on a selected item in the list. Passed the item.\n     * @param {!function():void} options.onDismiss\n     *          Called when popup is dismissed with escape key press. Popup is not usable after this point.\n     * @param {?number} options.maxResults\n     *          Maximum number of items from resultProvider() to display in the popup.\n     * @param {?number} options.verticalAdjust\n     *          Number of pixels to position the popup below where $input is when constructor is called. Useful\n     *          if UI is going to animate position after construction, but QuickSearchField may receive input\n     *          before the animation is done.\n     * @param {?number} options.firstHighlightIndex\n     *          Index of the result that is highlighted by default. null to not highlight any result.\n     * @param {?number} options.focusLastActiveElementOnClose if set to true, focuses the last active element on close.\n     *          By default, the editor is always focused.\n     *\n     */\n    function QuickSearchField($input, options) {\n        this.$input = $input;\n        this.options = options || {};\n\n        options.maxResults = options.maxResults || 10;\n\n        this._handleInput   = this._handleInput.bind(this);\n        this._handleKeyDown = this._handleKeyDown.bind(this);\n\n        if (options.highlightZeroResults !== undefined) {\n            this._highlightZeroResults = options.highlightZeroResults;\n        } else {\n            this._highlightZeroResults = true;\n        }\n\n        $input.on(\"input\", this._handleInput);\n        $input.on(\"keydown\", this._handleKeyDown);\n\n        // For search History this value is set to null\n        this._firstHighlightIndex = options.firstHighlightIndex;\n\n        this._dropdownTop = $input.offset().top + $input.height() + (options.verticalAdjust || 0);\n    }\n\n    /** @type {!Object} */\n    QuickSearchField.prototype.options = null;\n\n    /** @type {?$.Promise} Promise corresponding to latest resultProvider call. Any earlier promises ignored */\n    QuickSearchField.prototype._pending = null;\n\n    /** @type {boolean} True if Enter already pressed & just waiting for results to arrive before committing */\n    QuickSearchField.prototype._commitPending = false;\n\n    /** @type {?string} Value of $input corresponding to the _displayedResults list */\n    QuickSearchField.prototype._displayedQuery = null;\n\n    /** @type {?Array.<*>}  Latest resultProvider result */\n    QuickSearchField.prototype._displayedResults = null;\n\n    /** @type {?number} */\n    QuickSearchField.prototype._highlightIndex = null;\n\n    /** @type {?jQueryObject} Dropdown's <ol>, while open; null while closed */\n    QuickSearchField.prototype._$dropdown = null;\n\n    /** @type {!jQueryObject} */\n    QuickSearchField.prototype.$input = null;\n\n\n    /** When text field changes, update results list */\n    QuickSearchField.prototype._handleInput = function () {\n        this._pending = null;  // immediately invalidate any previous Promise\n\n        var valueAtEvent = this.$input.val();\n        var self = this;\n        // The timeout lets us skip over a backlog of multiple keyboard events when the provider is responding\n        // so slowly that JS execution can't keep up. All the remaining input events are serviced before the\n        // first timeout runs; then all the queued-up timeouts run in a row. All except the last one can no-op.\n        setTimeout(function () {\n            if (self.$input && self.$input.val() === valueAtEvent) {\n                self.updateResults();\n            }\n        }, 0);\n    };\n\n    /** Handle special keys: Enter, Up/Down */\n    QuickSearchField.prototype._handleKeyDown = function (event) {\n        if (event.keyCode === KeyEvent.DOM_VK_RETURN) {\n            // Enter should always act on the latest results. If input has changed and we're still waiting for\n            // new results, just flag the 'commit' for later\n            if (this._displayedQuery === this.$input.val()) {\n                event.stopPropagation();\n                event.preventDefault();  // prevents keyup from going to someone else after we close\n                this._doCommit();\n            } else {\n                // Once the current wait resolves, _render() will run the commit\n                this._commitPending = true;\n            }\n        } else if (event.keyCode === KeyEvent.DOM_VK_DELETE) {\n            if (this.options.onDelete && this._$dropdown && this._highlightIndex !== null) {\n                this.options.onDelete(this._highlightIndex);\n                this.updateResults();\n                event.stopPropagation();\n                event.preventDefault();\n            }\n            // if there is nothing selected, we should not preventDefault the delete key event as it\n            // will make delete key not work in the search text box text! Eg. Ctrl-shift-o, type text,\n            // press delete key to remove text chars will fail is we prevent default here without\n            // a valid selection.\n        } else if (event.keyCode === KeyEvent.DOM_VK_DOWN) {\n            // Highlight changes are always done synchronously on the currently shown result list. If the list\n            // later changes, the highlight is reset to the top\n            if (this._displayedResults && this._displayedResults.length) {\n                if (this._highlightIndex === null || this._highlightIndex === this._displayedResults.length - 1) {\n                    this._highlightIndex = 0;\n                } else {\n                    this._highlightIndex++;\n                }\n                this._updateHighlight(true);\n            }\n            event.stopPropagation();\n            event.preventDefault(); // treated as Home key otherwise\n\n        } else if (event.keyCode === KeyEvent.DOM_VK_UP) {\n            if (this._displayedResults && this._displayedResults.length) {\n                if (this._highlightIndex === null || this._highlightIndex === 0) {\n                    this._highlightIndex = this._displayedResults.length - 1;\n                } else {\n                    this._highlightIndex--;\n                }\n                this._updateHighlight(true);\n            }\n            event.preventDefault(); // treated as End key otherwise\n            event.stopPropagation();\n        }\n    };\n\n    /** Call onCommit() immediately */\n    QuickSearchField.prototype._doCommit = function (index) {\n        var item;\n        if (this._displayedResults && this._displayedResults.length) {\n            if (index >= 0) {\n                item = this._displayedResults[index];\n            } else if (this._highlightIndex >= 0) {\n                item = this._displayedResults[this._highlightIndex];\n            }\n        }\n        this.options.onCommit(item, this._displayedQuery, this._highlightIndex);\n    };\n\n    /** Update display to reflect value of _highlightIndex, & call onHighlight() */\n    QuickSearchField.prototype._updateHighlight = function (explicit) {\n        if (this._$dropdown) {\n            var $items = this._$dropdown.find(\"li\");\n            $items.removeClass(\"highlight\");\n            if (this._highlightIndex !== null) {\n                $items.eq(this._highlightIndex).addClass(\"highlight\");\n\n                this.options.onHighlight(this._displayedResults[this._highlightIndex], this.$input.val(), explicit);\n            }\n        }\n    };\n\n    /**\n     * Refresh the results dropdown, as if the user had changed the search text. Useful for providers that\n     * want to show cached data initially, then update the results with fresher data once available.\n     */\n    QuickSearchField.prototype.updateResults = function () {\n        this._pending = null;  // immediately invalidate any previous Promise\n\n        var query = this.$input.val();\n        var results = this.options.resultProvider(query);\n        if (results.done && results.fail) {\n            // Provider returned an async result - mark it as the latest Promise and if it's still latest when\n            // it resolves, render the results then\n            this._pending = results;\n            var self = this;\n            this._pending.done(function (realResults) {\n                if (self._pending === results) {\n                    self._render(realResults, query);\n                    this._pending = null;\n                }\n            });\n            if (this._pending) {\n                this._pending.fail(function () {\n                    if (self._pending === results) {\n                        self._render([], query);\n                        this._pending = null;\n                    }\n                });\n            }\n        } else {\n            // Synchronous result - render immediately\n            this._render(results, query);\n        }\n    };\n\n\n    /** Close dropdown result list if visible */\n    QuickSearchField.prototype._closeDropdown = function () {\n        if (this._$dropdown) {\n            this._$dropdown.remove();\n            this._$dropdown = null;\n        }\n        if(this.options.focusLastActiveElementOnClose && this._$currentlyFocusedElement\n         && this._$currentlyFocusedElement.is(\":visible\")) {\n            this._$currentlyFocusedElement.focus();\n        }\n    };\n\n    /**\n     * Open dropdown result list & populate with the given content\n     * @param {!string} htmlContent\n     */\n    QuickSearchField.prototype._openDropdown = function (htmlContent) {\n        const self = this;\n        this._$currentlyFocusedElement = $(document.activeElement);\n        if (!this._$dropdown) {\n            this._$dropdown = $(\"<ol class='quick-search-container'/>\").appendTo(\"body\")\n                .css({\n                    position: \"absolute\",\n                    top: this._dropdownTop,\n                    left: this.$input.offset().left,\n                    width: this.$input.outerWidth()\n                })\n                .click(function (event) {\n                    // Unlike the Enter key, where we wait to catch up with typing, clicking commits immediately\n                    var $item = $(event.target).closest(\"li\");\n                    if ($item.length) {\n                        self._doCommit($item.index());\n                    }\n                });\n        }\n        this._$dropdown.html(htmlContent);\n        PopUpManager.addPopUp(this._$dropdown, ()=>{\n            self.destroy();\n            if(self.options.onDismiss){\n                self.options.onDismiss();\n            }\n        }, true, {\n            popupManagesFocus: this.options.focusLastActiveElementOnClose\n        });\n    };\n\n    /**\n     * Given finished provider result, format it into HTML and show in dropdown, and update \"no-results\" style.\n     * If an Enter key commit was pending from earlier, process it now.\n     * @param {!Array.<*>} results\n     * @param {!string} query\n     */\n    QuickSearchField.prototype._render = function (results, query) {\n        this._displayedQuery = query;\n        this._displayedResults = results;\n        if (this._highlightIndex) {\n            if(this._highlightIndex >= results.length){\n                this._highlightIndex = results.length - 1;\n            }\n        } else if (this._firstHighlightIndex >= 0) {\n            this._highlightIndex = this._firstHighlightIndex;\n        } else {\n            this._highlightIndex = null;\n        }\n\n        if (results.error || results.length === 0) {\n            this._closeDropdown();\n            if (this._highlightZeroResults) {\n                this.$input.addClass(\"no-results\");\n            }\n        } else if (results.hasOwnProperty(\"error\")) {\n            // Error present but falsy - no results to show, but don't decorate with error style\n            this._closeDropdown();\n            if (this._highlightZeroResults) {\n                this.$input.removeClass(\"no-results\");\n            }\n        } else {\n            if (this._highlightZeroResults) {\n                this.$input.removeClass(\"no-results\");\n            }\n\n            var count = Math.min(results.length, this.options.maxResults),\n                html = \"\",\n                i;\n            for (i = 0; i < count; i++) {\n                html += this.options.formatter(results[i], query);\n            }\n            this._openDropdown(html);\n\n            this._updateHighlight(false);\n        }\n\n        // If Enter key was pressed earlier, handle it now that we've gotten results back\n        if (this._commitPending) {\n            this._commitPending = false;\n            this._doCommit();\n        }\n    };\n\n\n    /**\n     * Programmatically changes the search text and updates the results.\n     * @param {!string} value\n     */\n    QuickSearchField.prototype.setText = function (value) {\n        this.$input.val(value);\n        this.updateResults();  // programmatic changes don't trigger \"input\" event\n    };\n\n    /**\n     * Closes the dropdown, and discards any pending Promises.\n     */\n    QuickSearchField.prototype.destroy = function () {\n        this._pending = null;  // immediately invalidate any pending Promise\n        this._closeDropdown();\n        if(this.$input){\n            this.$input.off(\"input\", this._handleInput);\n            this.$input.off(\"keydown\", this._handleKeyDown);\n            this.$input = null;\n        }\n    };\n\n\n    exports.QuickSearchField = QuickSearchField;\n});\n"],"file":"QuickSearchField.js"}
{"version":3,"sources":["search/QuickOpen.js"],"names":["define","require","exports","module","DocumentManager","EditorManager","MainViewManager","MainViewFactory","CommandManager","Strings","StringUtils","Commands","ProjectManager","LanguageManager","ModalBar","QuickSearchField","StringMatch","ProviderRegistrationHandler","_providerRegistrationHandler","RegistrationHandler","_registerQuickOpenProvider","registerProvider","bind","SymbolKind","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","CURSOR_POS_EXP","RegExp","currentPlugin","fileList","fileListPromise","_curDialog","_getPluginsForCurrentContext","curDoc","getCurrentDocument","languageId","getLanguage","getId","getProvidersForLanguageId","QuickOpenPlugin","name","languageIds","done","search","match","itemFocus","itemSelect","resultsFormatter","matcherOptions","label","this","addQuickOpenPlugin","pluginDef","quickOpenProvider","providerLanguageIds","length","providerPriority","priority","QuickNavigateDialog","$searchField","undefined","_handleCloseBar","_handleItemSelect","_handleItemHighlight","_filterCallback","_resultsFormatterCallback","_filenameMatcher","StringMatcher","segmentedSearch","_matchers","_filenameFromPath","path","includeExtension","end","lastIndexOf","slice","extractCursorPos","query","regInfo","isNaN","local","line","ch","_doSearchFileList","matcher","cursorPos","replace","filteredList","$","map","fileInfo","searchResult","makeProjectRelativeIfPossible","fullPath","filenameWithoutExtension","multiFieldSort","matchGoodness","searchFileList","asyncResult","Deferred","resolve","promise","highlightMatch","item","matchClass","rangeFilter","stringRanges","text","matched","includesLastSegment","displayName","scoreDebug","sd","special","lastSegment","beginning","lengthDeduction","consecutive","notStartingOnSpecial","upper","forEach","range","rangeText","breakableUrl","defaultResultsFormatter","indexOf","_filenameResultsFormatter","fileNameFilter","rightmostSlash","substring","displayPath","getCurrentEditorSelectedText","currentEditor","getActiveEditor","getSelectedText","beginSearch","prefix","initialString","createDialog","showDialog","isOpen","setSearchFieldValue","close","doFileSearch","doGotoLine","doDefinitionSearch","doDefinitionSearchInProject","_canHandleTrigger","trigger","plugins","retval","some","plugin","index","provider","_setMenuItemStateForLanguage","get","NAVIGATE_GOTO_DEFINITION","setEnabled","NAVIGATE_GOTO_DEFINITION_PROJECT","prototype","_closeDeferred","_origDocPath","_origSelections","_origScrollPos","selectedItem","doClose","self","modalBar","prepareClose","execute","CMD_ADD_TO_WORKINGSET_AND_OPEN","editor","getCurrentFullEditor","setCursorPos","always","focusActivePane","explicit","closePromise","event","reason","modalBarClosePromise","console","assert","i","searchField","destroy","CLOSE_ESCAPE","setSelections","setScrollPos","x","y","getFirstVisibleLine","getLastVisibleLine","from","to","setSelection","error","_updateDialogLabel","formatter","setText","setSelectionRange","dialogLabel","charAt","CMD_GOTO_LINE","CMD_GOTO_DEFINITION","CMD_GOTO_DEFINITION_PROJECT","dialog","file","getSelections","getScrollPos","searchBarHTML","FIND_IN_FILES_INDEXING","CMD_QUICK_OPEN","on","$indexingSpinner","maxResults","firstHighlightIndex","verticalAdjust","getRoot","outerHeight","resultProvider","onCommit","onHighlight","getAllFiles","_filter","files","addClass","reset","focus","getLanguageForPath","isBinary","findSuitableFactoryForPath","newFile","newPaneId","oldFile","oldPaneId","newFilePath","newLanguage","newLanguageId","getDocumentForPath","newDoc","changedLanguageId","fail","err","oldFilePath","oldDoc","off","register","NAVIGATE_QUICK_OPEN","NAVIGATE_GOTO_LINE","stringMatch","SearchResult","basicMatchSort"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: QuickOpen*/\n\n/*\n * Displays a search bar where the user can quickly navigate to a different file by searching file names in\n * the project, and/or jump to a line number. Providers can plug in to offer additional search modes.\n */\n\n\ndefine(function (require, exports, module) {\n\n\n    var DocumentManager     = require(\"document/DocumentManager\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        MainViewManager     = require(\"view/MainViewManager\"),\n        MainViewFactory     = require(\"view/MainViewFactory\"),\n        CommandManager      = require(\"command/CommandManager\"),\n        Strings             = require(\"strings\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        Commands            = require(\"command/Commands\"),\n        ProjectManager      = require(\"project/ProjectManager\"),\n        LanguageManager     = require(\"language/LanguageManager\"),\n        ModalBar            = require(\"widgets/ModalBar\").ModalBar,\n        QuickSearchField    = require(\"search/QuickSearchField\").QuickSearchField,\n        StringMatch         = require(\"utils/StringMatch\"),\n        ProviderRegistrationHandler = require(\"features/PriorityBasedRegistration\").RegistrationHandler;\n\n    var _providerRegistrationHandler = new ProviderRegistrationHandler(),\n        _registerQuickOpenProvider = _providerRegistrationHandler.registerProvider.bind(_providerRegistrationHandler);\n\n    var SymbolKind = {\n        \"1\": \"File\",\n        \"2\": \"Module\",\n        \"3\": \"Namespace\",\n        \"4\": \"Package\",\n        \"5\": \"Class\",\n        \"6\": \"Method\",\n        \"7\": \"Property\",\n        \"8\": \"Field\",\n        \"9\": \"Constructor\",\n        \"10\": \"Enum\",\n        \"11\": \"Interface\",\n        \"12\": \"Function\",\n        \"13\": \"Variable\",\n        \"14\": \"Constant\",\n        \"15\": \"String\",\n        \"16\": \"Number\",\n        \"17\": \"Boolean\",\n        \"18\": \"Array\",\n        \"19\": \"Object\",\n        \"20\": \"Key\",\n        \"21\": \"Null\",\n        \"22\": \"EnumMember\",\n        \"23\": \"Struct\",\n        \"24\": \"Event\",\n        \"25\": \"Operator\",\n        \"26\": \"TypeParameter\"\n    };\n\n    /**\n     * The regular expression to check the cursor position\n     * @const {RegExp}\n     */\n    var CURSOR_POS_EXP = new RegExp(\":([^,]+)?(,(.+)?)?\");\n\n    /**\n     * Current plugin\n     * @type {QuickOpenPlugin}\n     */\n    var currentPlugin = null;\n\n    /** @type {Array.<File>} */\n    var fileList;\n\n    /** @type {$.Promise} */\n    var fileListPromise;\n\n    /**\n     * The currently open (or last open) QuickNavigateDialog\n     * @type {?QuickNavigateDialog}\n     */\n    var _curDialog;\n\n    /**\n     * Helper function to get the plugins based on the type of the current document.\n     * @private\n     * @returns {Array} Returns the plugings based on the languageId of the current document.\n     */\n    function _getPluginsForCurrentContext() {\n        var curDoc = DocumentManager.getCurrentDocument();\n\n        if (curDoc) {\n            var languageId = curDoc.getLanguage().getId();\n            return _providerRegistrationHandler.getProvidersForLanguageId(languageId);\n        }\n\n        return _providerRegistrationHandler.getProvidersForLanguageId(); //plugins registered for all\n    }\n\n    /**\n     * Defines API for new QuickOpen plug-ins\n     */\n    function QuickOpenPlugin(name, languageIds, done, search, match, itemFocus, itemSelect, resultsFormatter, matcherOptions, label) {\n        this.name = name;\n        this.languageIds = languageIds;\n        this.done = done;\n        this.search = search;\n        this.match = match;\n        this.itemFocus = itemFocus;\n        this.itemSelect = itemSelect;\n        this.resultsFormatter = resultsFormatter;\n        this.matcherOptions = matcherOptions;\n        this.label = label;\n    }\n\n    /**\n     * Creates and registers a new QuickOpenPlugin\n     *\n     * @param { name: string,\n     *          languageIds: !Array.<string>,\n     *          done: ?function(),\n     *          search: function(string, !StringMatch.StringMatcher):(!Array.<SearchResult|string>|$.Promise),\n     *          match: function(string):boolean,\n     *          itemFocus: ?function(?SearchResult|string, string, boolean),\n     *          itemSelect: function(?SearchResult|string, string),\n     *          resultsFormatter: ?function(SearchResult|string, string):string,\n     *          matcherOptions: ?Object,\n     *          label: ?string\n     *        } pluginDef\n     *\n     * Parameter Documentation:\n     *\n     * name - plug-in name, **must be unique**\n     * languageIds - language Ids array. Example: [\"javascript\", \"css\", \"html\"]. To allow any language, pass []. Required.\n     * done - called when quick open is complete. Plug-in should clear its internal state. Optional.\n     * search - takes a query string and a StringMatcher (the use of which is optional but can speed up your searches) and returns\n     *      an array of strings or result objects that match the query; or a Promise that resolves to such an array. Required.\n     * match - takes a query string and returns true if this plug-in wants to provide\n     *      results for this query. Required.\n     * itemFocus - performs an action when a result has been highlighted (via arrow keys, or by becoming top of the list).\n     *      Passed the highlighted search result item (as returned by search()), the current query string, and a flag that is true\n     *      if the item was highlighted explicitly (arrow keys), not implicitly (at top of list after last search()). Optional.\n     * itemSelect - performs an action when a result is chosen.\n     *      Passed the highlighted search result item (as returned by search()), and the current query string. Required.\n     * resultsFormatter - takes a query string and an item string and returns\n     *      a <LI> item to insert into the displayed search results. Optional.\n     * matcherOptions - options to pass along to the StringMatcher (see StringMatch.StringMatcher\n     *          for available options). Optional.\n     * label - if provided, the label to show before the query field. Optional.\n     *\n     * If itemFocus() makes changes to the current document or cursor/scroll position and then the user\n     * cancels Quick Open (via Esc), those changes are automatically reverted.\n     */\n    function addQuickOpenPlugin(pluginDef) {\n        var quickOpenProvider = new QuickOpenPlugin(\n                pluginDef.name,\n                pluginDef.languageIds,\n                pluginDef.done,\n                pluginDef.search,\n                pluginDef.match,\n                pluginDef.itemFocus,\n                pluginDef.itemSelect,\n                pluginDef.resultsFormatter,\n                pluginDef.matcherOptions,\n                pluginDef.label\n            ),\n            providerLanguageIds = pluginDef.languageIds.length ? pluginDef.languageIds : [\"all\"],\n            providerPriority = pluginDef.priority || 0;\n\n        _registerQuickOpenProvider(quickOpenProvider, providerLanguageIds, providerPriority);\n    }\n\n    /**\n     * QuickNavigateDialog class\n     * @constructor\n     */\n    function QuickNavigateDialog() {\n        this.$searchField = undefined; // defined when showDialog() is called\n\n        // ModalBar event handlers & callbacks\n        this._handleCloseBar           = this._handleCloseBar.bind(this);\n\n        // QuickSearchField callbacks\n        this._handleItemSelect         = this._handleItemSelect.bind(this);\n        this._handleItemHighlight      = this._handleItemHighlight.bind(this);\n        this._filterCallback           = this._filterCallback.bind(this);\n        this._resultsFormatterCallback = this._resultsFormatterCallback.bind(this);\n\n        // StringMatchers that cache in-progress query data.\n        this._filenameMatcher           = new StringMatch.StringMatcher({\n            segmentedSearch: true\n        });\n        this._matchers                  = {};\n    }\n\n    /**\n     * True if the search bar is currently open. Note that this is set to false immediately\n     * when the bar starts closing; it doesn't wait for the ModalBar animation to finish.\n     * @type {boolean}\n     */\n    QuickNavigateDialog.prototype.isOpen = false;\n\n    /**\n     * @private\n     * Handles caching of filename search information for the lifetime of a\n     * QuickNavigateDialog (a single search until the dialog is dismissed)\n     *\n     * @type {StringMatch.StringMatcher}\n     */\n    QuickNavigateDialog.prototype._filenameMatcher = null;\n\n    /**\n     * @private\n     * StringMatcher caches for each QuickOpen plugin that keep track of search\n     * information for the lifetime of a QuickNavigateDialog (a single search\n     * until the dialog is dismissed)\n     *\n     * @type {Object.<string, StringMatch.StringMatcher>}\n     */\n    QuickNavigateDialog.prototype._matchers = null;\n\n    /**\n     * @private\n     * If the dialog is closing, this will contain a deferred that is resolved\n     * when it's done closing.\n     * @type {$.Deferred}\n     */\n    QuickNavigateDialog.prototype._closeDeferred = null;\n\n\n    /**\n     * @private\n     * Remembers the current document that was displayed when showDialog() was called.\n     * @type {?string} full path\n     */\n    QuickNavigateDialog.prototype._origDocPath = null;\n\n    /**\n     * @private\n     * Remembers the selection state in origDocPath that was present when showDialog() was called. Focusing on an\n     * item can change the selection; we restore this original selection if the user presses Escape. Null if\n     * no document was open when Quick Open was invoked.\n     * @type {?Array.<{{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed:boolean}}>}\n     */\n    QuickNavigateDialog.prototype._origSelections = null;\n\n    /**\n     * @private\n     * Remembers the scroll position in origDocPath when showDialog() was called (see origSelection above).\n     * @type {?{x:number, y:number}}\n     */\n    QuickNavigateDialog.prototype._origScrollPos = null;\n\n    function _filenameFromPath(path, includeExtension) {\n        var end;\n        if (includeExtension) {\n            end = path.length;\n        } else {\n            end = path.lastIndexOf(\".\");\n            if (end === -1) {\n                end = path.length;\n            }\n        }\n        return path.slice(path.lastIndexOf(\"/\") + 1, end);\n    }\n\n    /**\n     * Attempts to extract a line number from the query where the line number\n     * is followed by a colon. Callers should explicitly test result with isNaN()\n     *\n     * @param {string} query string to extract line number from\n     * @return {{query: string, local: boolean, line: number, ch: number}} An object with\n     *      the extracted line and column numbers, and two additional fields: query with the original position\n     *      string and local indicating if the cursor position should be applied to the current file.\n     *      Or null if the query is invalid\n     */\n    function extractCursorPos(query) {\n        var regInfo = query.match(CURSOR_POS_EXP);\n\n        if (query.length <= 1 || !regInfo ||\n                (regInfo[1] && isNaN(regInfo[1])) ||\n                (regInfo[3] && isNaN(regInfo[3]))) {\n\n            return null;\n        }\n\n        return {\n            query: regInfo[0],\n            local: query[0] === \":\",\n            line: regInfo[1] - 1 || 0,\n            ch: regInfo[3] - 1 || 0\n        };\n    }\n\n    /**\n     * Navigates to the appropriate file and file location given the selected item\n     * and closes the dialog.\n     *\n     * Note, if selectedItem is null quick search should inspect $searchField for text\n     * that may have not matched anything in the list, but may have information\n     * for carrying out an action (e.g. go to line).\n     */\n    QuickNavigateDialog.prototype._handleItemSelect = function (selectedItem, query) {\n\n        var doClose = true,\n            self = this;\n\n        // Delegate to current plugin\n        if (currentPlugin) {\n            currentPlugin.itemSelect(selectedItem, query);\n        } else {\n            // Extract line/col number, if any\n            var cursorPos = extractCursorPos(query);\n\n            // Navigate to file and line number\n            var fullPath = selectedItem && selectedItem.fullPath;\n            if (fullPath) {\n                // We need to fix up the current editor's scroll pos before switching to the next one. But if\n                // we run the full close() now, ModalBar's animate-out won't be smooth (gets starved of cycles\n                // during creation of the new editor). So we call prepareClose() to do *only* the scroll pos\n                // fixup, and let the full close() be triggered later when the new editor takes focus.\n                doClose = false;\n                this.modalBar.prepareClose();\n                CommandManager.execute(Commands.CMD_ADD_TO_WORKINGSET_AND_OPEN, {fullPath: fullPath})\n                    .done(function () {\n                        if (cursorPos) {\n                            var editor = EditorManager.getCurrentFullEditor();\n                            editor.setCursorPos(cursorPos.line, cursorPos.ch, true);\n                        }\n                    })\n                    .always(function () {\n                        // Ensure we finish closing even if file failed to open, or file was already current (in\n                        // either case, we may not get a blur to trigger ModalBar to auto-close)\n                        self.close();\n                    });\n            } else if (cursorPos) {\n                EditorManager.getCurrentFullEditor().setCursorPos(cursorPos.line, cursorPos.ch, true);\n            }\n        }\n\n        if (doClose) {\n            this.close();\n            MainViewManager.focusActivePane();\n        }\n    };\n\n    /**\n     * Opens the file specified by selected item if there is no current plug-in, otherwise defers handling\n     * to the currentPlugin\n     */\n    QuickNavigateDialog.prototype._handleItemHighlight = function (selectedItem, query, explicit) {\n        if (currentPlugin && currentPlugin.itemFocus) {\n            currentPlugin.itemFocus(selectedItem, query, explicit);\n        }\n    };\n\n    /**\n     * Closes the search bar; if search bar is already closing, returns the Promise that is tracking the\n     * existing close activity.\n     * @return {$.Promise} Resolved when the search bar is entirely closed.\n     */\n    QuickNavigateDialog.prototype.close = function () {\n        if (!this.isOpen) {\n            return this.closePromise;\n        }\n\n        this.modalBar.close();  // triggers _handleCloseBar(), setting closePromise\n\n        return this.closePromise;\n    };\n\n    QuickNavigateDialog.prototype._handleCloseBar = function (event, reason, modalBarClosePromise) {\n        console.assert(!this.closePromise);\n        this.closePromise = modalBarClosePromise;\n        this.isOpen = false;\n\n        var i,\n            plugins = _getPluginsForCurrentContext();\n        for (i = 0; i < plugins.length; i++) {\n            var plugin = plugins[i].provider;\n            if (plugin.done) {\n                plugin.done();\n            }\n        }\n\n        // Close popup & ensure we ignore any still-pending result promises\n        this.searchField.destroy();\n\n        // Restore original selection / scroll pos if closed via Escape\n        if (reason === ModalBar.CLOSE_ESCAPE) {\n            // We can reset the scroll position synchronously on ModalBar's \"close\" event (before close animation\n            // completes) since ModalBar has already resized the editor and done its own scroll adjustment before\n            // this event fired - so anything we set here will override the pos that was (re)set by ModalBar.\n            var editor = EditorManager.getCurrentFullEditor();\n            if (editor && this._origSelections) {\n                editor.setSelections(this._origSelections);\n            }\n            if (editor && this._origScrollPos) {\n                editor.setScrollPos(this._origScrollPos.x, this._origScrollPos.y);\n            }\n        }\n    };\n\n\n    function _doSearchFileList(query, matcher) {\n        // Strip off line/col number suffix so it doesn't interfere with filename search\n        var cursorPos = extractCursorPos(query);\n        if (cursorPos && !cursorPos.local && cursorPos.query !== \"\") {\n            query = query.replace(cursorPos.query, \"\");\n        }\n\n        // First pass: filter based on search string; convert to SearchResults containing extra info\n        // for sorting & display\n        var filteredList = $.map(fileList, function (fileInfo) {\n            // Is it a match at all?\n            // match query against the full path (with gaps between query characters allowed)\n            var searchResult;\n\n            searchResult = matcher.match(ProjectManager.makeProjectRelativeIfPossible(fileInfo.fullPath), query);\n\n            if (searchResult) {\n                searchResult.label = fileInfo.name;\n                searchResult.fullPath = fileInfo.fullPath;\n                searchResult.filenameWithoutExtension = _filenameFromPath(fileInfo.name, false);\n            }\n            return searchResult;\n        });\n\n        // Sort by \"match goodness\" tier first, then within each tier sort alphabetically - first by filename\n        // sans extension, (so that \"abc.js\" comes before \"abc-d.js\"), then by filename, and finally (for\n        // identically-named files) by full path\n        StringMatch.multiFieldSort(filteredList, { matchGoodness: 0, filenameWithoutExtension: 1, label: 2, fullPath: 3 });\n\n        return filteredList;\n    }\n\n    function searchFileList(query, matcher) {\n        // The file index may still be loading asynchronously - if so, can't return a result yet\n        if (!fileList) {\n            var asyncResult = new $.Deferred();\n            fileListPromise.done(function () {\n                // Synchronously re-run the search call and resolve with its results\n                asyncResult.resolve(_doSearchFileList(query, matcher));\n            });\n            return asyncResult.promise();\n\n        }\n        return _doSearchFileList(query, matcher);\n\n    }\n\n    /**\n     * Handles changes to the current query in the search field.\n     * @param {string} query The new query.\n     * @return {$.Promise|Array.<*>|{error:?string}} The filtered list of results, an error object, or a Promise that\n     *                                               yields one of those\n     */\n    QuickNavigateDialog.prototype._filterCallback = function (query) {\n        // Re-evaluate which plugin is active each time query string changes\n        currentPlugin = null;\n\n        // \"Go to line\" mode is special-cased\n        var cursorPos = extractCursorPos(query);\n        if (cursorPos && cursorPos.local) {\n            // Bare Go to Line (no filename search) - can validate & jump to it now, without waiting for Enter/commit\n            var editor = EditorManager.getCurrentFullEditor();\n\n            // Validate (could just use 0 and lineCount() here, but in future might want this to work for inline editors too)\n            if (cursorPos && editor && cursorPos.line >= editor.getFirstVisibleLine() && cursorPos.line <= editor.getLastVisibleLine()) {\n                var from = {line: cursorPos.line, ch: cursorPos.ch},\n                    to   = {line: cursorPos.line};\n                EditorManager.getCurrentFullEditor().setSelection(from, to, true);\n\n                return { error: null };  // no error even though no results listed\n            }\n            return [];  // red error highlight: line number out of range, or no editor open\n\n        }\n        if (query === \":\") {  // treat blank \":\" query as valid, but no-op\n            return { error: null };\n        }\n\n        var i,\n            plugins = _getPluginsForCurrentContext();\n        for (i = 0; i < plugins.length; i++) {\n            var plugin = plugins[i].provider;\n            if(plugin.match(query)) {\n                currentPlugin = plugin;\n\n                // Look up the StringMatcher for this plugin.\n                var matcher = this._matchers[currentPlugin.name];\n                if (!matcher) {\n                    matcher = new StringMatch.StringMatcher(plugin.matcherOptions);\n                    this._matchers[currentPlugin.name] = matcher;\n                }\n                this._updateDialogLabel(plugin, query);\n                return plugin.search(query, matcher);\n            }\n        }\n\n        // Reflect current search mode in UI\n        this._updateDialogLabel(null, query);\n\n        // No matching plugin: use default file search mode\n        return searchFileList(query, this._filenameMatcher);\n    };\n\n    /**\n     * Formats item's label as properly escaped HTML text, highlighting sections that match 'query'.\n     * If item is a SearchResult generated by stringMatch(), uses its metadata about which string ranges\n     * matched; else formats the label with no highlighting.\n     * @param {!string|SearchResult} item\n     * @param {?string} matchClass CSS class for highlighting matched text\n     * @param {?function(boolean, string):string} rangeFilter\n     * @return {!string} bolded, HTML-escaped result\n     */\n    function highlightMatch(item, matchClass, rangeFilter) {\n        var label = item.label || item;\n        matchClass = matchClass || \"quicksearch-namematch\";\n\n        var stringRanges = item.stringRanges;\n        if (!stringRanges) {\n            // If result didn't come from stringMatch(), highlight nothing\n            stringRanges = [{\n                text: label,\n                matched: false,\n                includesLastSegment: true\n            }];\n        }\n\n        var displayName = \"\";\n        if (item.scoreDebug) {\n            var sd = item.scoreDebug;\n            displayName += '<span title=\"sp:' + sd.special + ', m:' + sd.match +\n                ', ls:' + sd.lastSegment + ', b:' + sd.beginning +\n                ', ld:' + sd.lengthDeduction + ', c:' + sd.consecutive + ', nsos: ' +\n                sd.notStartingOnSpecial + ', upper: ' + sd.upper + '\">(' + item.matchGoodness + ') </span>';\n        }\n\n        // Put the path pieces together, highlighting the matched parts\n        stringRanges.forEach(function (range) {\n            if (range.matched) {\n                displayName += \"<span class='\" + matchClass + \"'>\";\n            }\n\n            var rangeText = rangeFilter ? rangeFilter(range.includesLastSegment, range.text) : range.text;\n            displayName += StringUtils.breakableUrl(rangeText);\n\n            if (range.matched) {\n                displayName += \"</span>\";\n            }\n        });\n        return displayName;\n    }\n\n    function defaultResultsFormatter(item, query) {\n        query = query.slice(query.indexOf(\"@\") + 1, query.length);\n\n        var displayName = highlightMatch(item);\n        return \"<li>\" + displayName + \"</li>\";\n    }\n\n    function _filenameResultsFormatter(item, query) {\n        // For main label, we just want filename: drop most of the string\n        function fileNameFilter(includesLastSegment, rangeText) {\n            if (includesLastSegment) {\n                var rightmostSlash = rangeText.lastIndexOf('/');\n                return rangeText.substring(rightmostSlash + 1);  // safe even if rightmostSlash is -1\n            }\n            return \"\";\n\n        }\n        var displayName = highlightMatch(item, null, fileNameFilter);\n        var displayPath = highlightMatch(item, \"quicksearch-pathmatch\");\n\n        return \"<li>\" + displayName + \"<br /><span class='quick-open-path'>\" + displayPath + \"</span></li>\";\n    }\n\n    /**\n     * Formats the entry for the given item to be displayed in the dropdown.\n     * @param {Object} item The item to be displayed.\n     * @return {string} The HTML to be displayed.\n     */\n    QuickNavigateDialog.prototype._resultsFormatterCallback = function (item, query) {\n        var formatter;\n\n        if (currentPlugin) {\n            // Plugins use their own formatter or the default formatter\n            formatter = currentPlugin.resultsFormatter || defaultResultsFormatter;\n        } else {\n            // No plugin: default file search mode uses a special formatter\n            formatter = _filenameResultsFormatter;\n        }\n        return formatter(item, query);\n    };\n\n    /**\n     * Sets the value in the search field, updating the current mode and label based on the\n     * given prefix.\n     * @param {string} prefix The prefix that determines which mode we're in: must be empty (for file search),\n     *      \"@\" for go to definition, or \":\" for go to line.\n     * @param {string} initialString The query string to search for (without the prefix).\n     */\n    QuickNavigateDialog.prototype.setSearchFieldValue = function (prefix, initialString) {\n        prefix = prefix || \"\";\n        initialString = initialString || \"\";\n        initialString = prefix + initialString;\n\n        this.searchField.setText(initialString);\n\n        // Select just the text after the prefix\n        this.$searchField[0].setSelectionRange(prefix.length, initialString.length);\n    };\n\n    /**\n     * Sets the dialog label based on the current plugin (if any) and the current query.\n     * @param {Object} plugin The current Quick Open plugin, or none if there is none.\n     * @param {string} query The user's current query.\n     */\n    QuickNavigateDialog.prototype._updateDialogLabel = function (plugin, query) {\n        var dialogLabel = \"\";\n        if (plugin && plugin.label) {\n            dialogLabel = plugin.label;\n        } else {\n            var prefix = (query.length > 0 ? query.charAt(0) : \"\");\n\n            // Update the dialog label based on the current prefix.\n            switch (prefix) {\n            case \":\":\n                dialogLabel = Strings.CMD_GOTO_LINE + \"\\u2026\";\n                break;\n            case \"@\":\n                dialogLabel = Strings.CMD_GOTO_DEFINITION + \"\\u2026\";\n                break;\n            case \"#\":\n                dialogLabel = Strings.CMD_GOTO_DEFINITION_PROJECT + \"\\u2026\";\n                break;\n            default:\n                dialogLabel = \"\";\n                break;\n            }\n        }\n        $(\".find-dialog-label\", this.dialog).text(dialogLabel);\n    };\n\n    /**\n     * Shows the search dialog and initializes the auto suggestion list with filenames from the current project\n     */\n    QuickNavigateDialog.prototype.showDialog = function (prefix, initialString) {\n        if (this.isOpen) {\n            return;\n        }\n        this.isOpen = true;\n\n        // Record current document & cursor pos so we can restore it if search is canceled\n        // We record scroll pos *before* modal bar is opened since we're going to restore it *after* it's closed\n        var curDoc = DocumentManager.getCurrentDocument();\n        this._origDocPath = curDoc ? curDoc.file.fullPath : null;\n        if (curDoc) {\n            this._origSelections = EditorManager.getCurrentFullEditor().getSelections();\n            this._origScrollPos = EditorManager.getCurrentFullEditor().getScrollPos();\n        } else {\n            this._origSelections = null;\n            this._origScrollPos = null;\n        }\n\n        // Show the search bar\n        var searchBarHTML =`<div align='right'>\n            <div id=\"indexing-spinner\" class=\"indexing-group\">\n                <div class=\"spinner inline spin\"></div>\n                <div id=\"indexing-spinner-message\" class=\"indexing-message\">${Strings.FIND_IN_FILES_INDEXING}</div>\n            </div>\n            <input type='text' autocomplete='off' id='quickOpenSearch'\n            placeholder='${Strings.CMD_QUICK_OPEN}\\u2026' style='width: 30em'>\n            <span class='find-dialog-label'></span>\n        </div>`;\n        this.modalBar = new ModalBar(searchBarHTML, true);\n\n        this.modalBar.on(\"close\", this._handleCloseBar);\n\n        this.$searchField = $(\"input#quickOpenSearch\");\n        this.$indexingSpinner = $(\"#indexing-spinner\");\n\n        this.searchField = new QuickSearchField(this.$searchField, {\n            maxResults: 20,\n            firstHighlightIndex: 0,\n            verticalAdjust: this.modalBar.getRoot().outerHeight(),\n            resultProvider: this._filterCallback,\n            formatter: this._resultsFormatterCallback,\n            onCommit: this._handleItemSelect,\n            onHighlight: this._handleItemHighlight\n        });\n\n        // Return files that are non-binary, or binary files that have a custom viewer\n        function _filter(file) {\n            return !LanguageManager.getLanguageForPath(file.fullPath).isBinary() ||\n                MainViewFactory.findSuitableFactoryForPath(file.fullPath);\n        }\n\n        // Start prefetching the file list, which will be needed the first time the user enters an un-prefixed query. If file index\n        // caches are out of date, this list might take some time to asynchronously build, forcing searchFileList() to wait. In the\n        // meantime we show our old, stale fileList (unless the user has switched projects and we cleared it).\n        fileListPromise = ProjectManager.getAllFiles(_filter, true)\n            .done(function (files) {\n                this.$indexingSpinner.addClass(\"forced-hidden\");\n                fileList = files;\n                fileListPromise = null;\n                this._filenameMatcher.reset();\n            }.bind(this));\n\n        // Prepopulated query\n        this.$searchField.focus();\n        this.setSearchFieldValue(prefix, initialString);\n    };\n\n    function getCurrentEditorSelectedText() {\n        var currentEditor = EditorManager.getActiveEditor();\n        return (currentEditor && currentEditor.getSelectedText()) || \"\";\n    }\n\n    /**\n     * Opens the Quick Open bar prepopulated with the given prefix (to select a mode) and optionally\n     * with the given query text too. Updates text field contents if Quick Open already open.\n     * @param {?string} prefix\n     * @param {?string} initialString\n     */\n    function beginSearch(prefix, initialString) {\n        function createDialog() {\n            _curDialog = new QuickNavigateDialog();\n            _curDialog.showDialog(prefix, initialString);\n        }\n\n        if (_curDialog) {\n            if (_curDialog.isOpen) {\n                // Just start a search using the existing dialog.\n                _curDialog.setSearchFieldValue(prefix, initialString);\n            } else {\n                // The dialog is already closing. Wait till it's done closing,\n                // then open a new dialog. (Calling close() again returns the\n                // promise for the deferred that was already kicked off when it\n                // started closing.)\n                _curDialog.close().done(createDialog);\n            }\n        } else {\n            createDialog();\n        }\n    }\n\n    function doFileSearch() {\n        beginSearch(\"\", getCurrentEditorSelectedText());\n    }\n\n    function doGotoLine() {\n        // TODO: Brackets doesn't support disabled menu items right now, when it does goto line and\n        // goto definition should be disabled when there is not a current document\n        if (DocumentManager.getCurrentDocument()) {\n            beginSearch(\":\", \"\");\n        }\n    }\n\n    function doDefinitionSearch() {\n        if (DocumentManager.getCurrentDocument()) {\n            beginSearch(\"@\", getCurrentEditorSelectedText());\n        }\n    }\n\n    function doDefinitionSearchInProject() {\n        if (DocumentManager.getCurrentDocument()) {\n            beginSearch(\"#\", getCurrentEditorSelectedText());\n        }\n    }\n\n    function _canHandleTrigger(trigger, plugins) {\n        var retval = false;\n\n        plugins.some(function (plugin, index) {\n            var provider = plugin.provider;\n            if (provider.match(trigger)) {\n                retval = true;\n                return true;\n            }\n        });\n\n        return retval;\n    }\n\n    function _setMenuItemStateForLanguage(languageId) {\n        var plugins = _providerRegistrationHandler.getProvidersForLanguageId(languageId);\n        if (_canHandleTrigger(\"@\", plugins)) {\n            CommandManager.get(Commands.NAVIGATE_GOTO_DEFINITION).setEnabled(true);\n        } else {\n            CommandManager.get(Commands.NAVIGATE_GOTO_DEFINITION).setEnabled(false);\n        }\n\n        if (_canHandleTrigger(\"#\", plugins)) {\n            CommandManager.get(Commands.NAVIGATE_GOTO_DEFINITION_PROJECT).setEnabled(true);\n        } else {\n            CommandManager.get(Commands.NAVIGATE_GOTO_DEFINITION_PROJECT).setEnabled(false);\n        }\n    }\n\n    // Listen for a change of project to invalidate our file list\n    ProjectManager.on(\"projectOpen\", function () {\n        fileList = null;\n    });\n\n    MainViewManager.on(\"currentFileChange\", function (event, newFile, newPaneId, oldFile, oldPaneId) {\n        if (!newFile) {\n            CommandManager.get(Commands.NAVIGATE_GOTO_DEFINITION).setEnabled(false);\n            CommandManager.get(Commands.NAVIGATE_GOTO_DEFINITION_PROJECT).setEnabled(false);\n            return;\n        }\n\n        var newFilePath = newFile.fullPath,\n            newLanguage = LanguageManager.getLanguageForPath(newFilePath),\n            newLanguageId = newLanguage.getId();\n\n        if (newLanguage.isBinary()) {\n            CommandManager.get(Commands.NAVIGATE_GOTO_DEFINITION).setEnabled(false);\n            CommandManager.get(Commands.NAVIGATE_GOTO_DEFINITION_PROJECT).setEnabled(false);\n            return;\n        }\n\n        _setMenuItemStateForLanguage(newLanguageId);\n\n        DocumentManager.getDocumentForPath(newFilePath)\n            .done(function (newDoc) {\n                newDoc.on(\"languageChanged.quickFindDefinition\", function () {\n                    var changedLanguageId = LanguageManager.getLanguageForPath(newDoc.file.fullPath).getId();\n                    _setMenuItemStateForLanguage(changedLanguageId);\n                });\n            }).fail(function (err) {\n                console.error(err);\n            });\n\n        if (!oldFile) {\n            return;\n        }\n\n        var oldFilePath = oldFile.fullPath;\n        DocumentManager.getDocumentForPath(oldFilePath)\n            .done(function (oldDoc) {\n                oldDoc.off(\"languageChanged.quickFindDefinition\");\n            }).fail(function (err) {\n                console.error(err);\n            });\n    });\n\n    CommandManager.register(Strings.CMD_QUICK_OPEN,         Commands.NAVIGATE_QUICK_OPEN,       doFileSearch);\n    CommandManager.register(Strings.CMD_GOTO_DEFINITION,    Commands.NAVIGATE_GOTO_DEFINITION,  doDefinitionSearch);\n    CommandManager.register(Strings.CMD_GOTO_DEFINITION_PROJECT,    Commands.NAVIGATE_GOTO_DEFINITION_PROJECT,  doDefinitionSearchInProject);\n    CommandManager.register(Strings.CMD_GOTO_LINE,          Commands.NAVIGATE_GOTO_LINE,        doGotoLine);\n\n    exports.beginSearch             = beginSearch;\n    exports.addQuickOpenPlugin      = addQuickOpenPlugin;\n    exports.highlightMatch          = highlightMatch;\n    exports.SymbolKind              = SymbolKind;\n\n    // Convenience exports for functions that most QuickOpen plugins would need.\n    exports.stringMatch             = StringMatch.stringMatch;\n    exports.SearchResult            = StringMatch.SearchResult;\n    exports.basicMatchSort          = StringMatch.basicMatchSort;\n    exports.multiFieldSort          = StringMatch.multiFieldSort;\n});\n"],"file":"QuickOpen.js"}
{"version":3,"sources":["search/FindInFiles.js"],"names":["define","require","exports","module","_","FileFilters","Async","StringUtils","ProjectManager","DocumentModule","DocumentManager","MainViewManager","FileSystem","LanguageManager","SearchModel","PerfUtils","FindUtils","Metrics","IndexingWorker","projectIndexingComplete","loadScriptInWorker","Phoenix","baseURL","on","EVENT_CRAWL_COMPLETE","_evt","params","workerFileCacheComplete","EVENT_CRAWL_PROGRESS","notifyIndexingProgress","processed","total","searchScopeChanged","findOrReplaceInProgress","changedFileList","ZERO_FILES_TO_SEARCH","MAX_DISPLAY_LENGTH","CACHE_INIT_DELAY_MS","searchModel","_documentChangeHandler","_fileSystemChangeHandler","_processCachedFileSystemEvents","_debouncedFileSystemChangeHandler","_fileNameChangeHandler","clearSearch","FILE_SYSTEM_EVENT_DEBOUNCE_TIME","_removeListeners","off","_addListeners","data","numFiles","numFilesCached","cacheSize","cacheSizeBytes","crawlTime","crawlTimeMs","console","log","test","window","location","pathname","projectRoot","getProjectRoot","projectName","name","error","setInstantSearchDisabled","notifyIndexingFinished","valueEvent","EVENT_TYPE","SEARCH","_getSearchMatches","contents","queryExpr","foundMaximum","search","match","lineNum","line","ch","totalMatchLength","matchedLines","numMatchedLines","lastLineLength","endCh","padding","leftPadding","rightPadding","highlightOffset","highlightEndCh","lines","getLines","matches","exec","offsetToLineNum","index","lastIndexOf","split","length","substr","Math","floor","min","ceil","substring","push","start","end","startOffset","endOffset","result","isChecked","MAX_TOTAL_RESULTS","lastIndex","_updateResults","doc","changeList","i","diff","howMany","resultsChanged","fullPath","file","resultInfo","results","removeResults","forEach","change","from","to","text","getLine","item","splice","join","value","key","Array","prototype","apply","concat","collapsed","timestamp","diskTimestamp","getText","setResults","fireChanged","_subtreeFilter","scope","isDirectory","indexOf","_isReadableFileType","getLanguageForPath","isBinary","getCandidateFiles","filter","isFile","$","Deferred","resolve","promise","getAllFiles","_inSearchScope","findInWorkingSet","ALL_PANES","filterPath","_doSearchInOneFile","getDocumentText","done","fail","_updateDocumentInWorker","docPath","getDocumentForPath","updateObject","filePath","docContents","execPeer","_updateChangedDocs","hasOwnProperty","_doSearch","queryInfo","candidateFilesPromise","queryResult","setQueryInfo","scopeName","perfTimer","markStart","query","then","fileListResult","filterFileList","isReplace","allResultsAvailable","doInParallel","searchDeferred","searchObject","files","entry","map","prioritizeOpenFile","getOpenFilePath","getAllResults","notifyWorkerSearchStarted","searchStatTime","Date","now","rcvd_object","notifyWorkerSearchFinished","numMatches","exceedsMaximum","catch","err","reject","zeroFilesToken","_searchDone","addMeasurement","finalizeMeasurement","doSearchInScope","replaceText","undefined","doReplace","options","performReplacements","always","_replaceDone","event","document","clear","_searchScopeChanged","_searchcollapseResults","isCollapsedResults","filesChanged","fileList","filesInSearchScope","getPathsMatchingFilter","filesRemoved","oldName","newName","removedFiles","changedFiles","replace","added","removed","_removeSearchResultsForEntries","entries","fullPaths","Object","keys","_addSearchResultsForEntries","addedFiles","addedFilePaths","deferred","visitor","child","shouldIndex","visit","foundMatches","addPromise","getContents","_cachedFileSystemEvents","debounce","reduce","obj","_initCache","notifyIndexingStarted","getActiveFilter","patterns","compile","_scheduleCacheInit","setTimeout","getNextPageofSearchResults","resultEntry","toString","getAllSearchResults","isProjectIndexingComplete","SEARCH_FILE_FILTERS_CHANGED","SEARCH_SCOPE_CHANGED","SEARCH_COLLAPSE_RESULTS"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global Phoenix*/\n\n/*\n * The core search functionality used by Find in Files and single-file Replace Batch.\n */\ndefine(function (require, exports, module) {\n\n\n    var _                     = require(\"thirdparty/lodash\"),\n        FileFilters           = require(\"search/FileFilters\"),\n        Async                 = require(\"utils/Async\"),\n        StringUtils           = require(\"utils/StringUtils\"),\n        ProjectManager        = require(\"project/ProjectManager\"),\n        DocumentModule        = require(\"document/Document\"),\n        DocumentManager       = require(\"document/DocumentManager\"),\n        MainViewManager       = require(\"view/MainViewManager\"),\n        FileSystem            = require(\"filesystem/FileSystem\"),\n        LanguageManager       = require(\"language/LanguageManager\"),\n        SearchModel           = require(\"search/SearchModel\").SearchModel,\n        PerfUtils             = require(\"utils/PerfUtils\"),\n        FindUtils             = require(\"search/FindUtils\"),\n        Metrics               = require(\"utils/Metrics\"),\n        IndexingWorker        = require(\"worker/IndexingWorker\");\n\n    let projectIndexingComplete = false;\n\n    IndexingWorker.loadScriptInWorker(`${Phoenix.baseURL}search/worker/search.js`);\n\n    IndexingWorker.on(IndexingWorker.EVENT_CRAWL_COMPLETE, function (_evt, params) {\n        workerFileCacheComplete(params);\n    });\n\n    IndexingWorker.on(IndexingWorker.EVENT_CRAWL_PROGRESS, function (_evt, params) {\n        FindUtils.notifyIndexingProgress(params.processed, params.total);\n    });\n\n    let searchScopeChanged = false,\n        findOrReplaceInProgress = false,\n        changedFileList = {};\n\n    /**\n     * Token used to indicate a specific reason for zero search results\n     * @const @type {!Object}\n     */\n    var ZERO_FILES_TO_SEARCH = {};\n\n    /**\n     * Maximum length of text displayed in search results panel\n     * @const\n     */\n    var MAX_DISPLAY_LENGTH = 200;\n\n    let CACHE_INIT_DELAY_MS = 1000;\n\n    /**\n     * The search query and results model.\n     * @type {SearchModel}\n     */\n    var searchModel = new SearchModel();\n\n    /* Forward declarations */\n    var _documentChangeHandler,\n        _fileSystemChangeHandler,\n        _processCachedFileSystemEvents,\n        _debouncedFileSystemChangeHandler,\n        _fileNameChangeHandler,\n        clearSearch;\n\n    /**\n     * Waits for FS changes to stack up until processing them\n     * (scripts like npm install can do a lot of movements on the disk)\n     * @const\n     */\n    var FILE_SYSTEM_EVENT_DEBOUNCE_TIME = 100;\n\n    /** Remove the listeners that were tracking potential search result changes */\n    function _removeListeners() {\n        DocumentModule.off(\"documentChange\", _documentChangeHandler);\n        FileSystem.off(\"change\", _debouncedFileSystemChangeHandler);\n        DocumentManager.off(\"fileNameChange\", _fileNameChangeHandler);\n    }\n\n    /** Add listeners to track events that might change the search result set */\n    function _addListeners() {\n        // Avoid adding duplicate listeners - e.g. if a 2nd search is run without closing the old results panel first\n        _removeListeners();\n\n        DocumentModule.on(\"documentChange\", _documentChangeHandler);\n        FileSystem.on(\"change\", _debouncedFileSystemChangeHandler);\n        DocumentManager.on(\"fileNameChange\",  _fileNameChangeHandler);\n    }\n\n    function workerFileCacheComplete(data) {\n        let numFiles = data.numFilesCached,\n            cacheSize = data.cacheSizeBytes,\n            crawlTime = data.crawlTimeMs;\n        projectIndexingComplete = true;\n        console.log(`file indexing worker cache complete: ${numFiles} files, size: ${cacheSize} B in ${crawlTime}ms`);\n        if (/\\/test\\/SpecRunner\\.html$/.test(window.location.pathname)) {\n            // Ignore the event in the SpecRunner window\n            return;\n        }\n\n        var projectRoot = ProjectManager.getProjectRoot(),\n            projectName = projectRoot ? projectRoot.name : null;\n\n        if (!projectName) {\n            console.error(\"'File cache complete' event received, but no project root found\");\n            projectName = \"noName00\";\n        }\n\n        FindUtils.setInstantSearchDisabled(false);\n        FindUtils.notifyIndexingFinished();\n        Metrics.valueEvent(Metrics.EVENT_TYPE.SEARCH, \"indexing\", \"numFiles\", numFiles);\n        Metrics.valueEvent(Metrics.EVENT_TYPE.SEARCH, \"indexing\", \"cacheSizeKB\", cacheSize/1024);\n        Metrics.valueEvent(Metrics.EVENT_TYPE.SEARCH, \"indexing\", \"crawlTimeMs\", crawlTime);\n    }\n\n    /**\n     * @private\n     * Searches through the contents and returns an array of matches\n     * @param {string} contents\n     * @param {RegExp} queryExpr\n     * @return {!Array.<{start: {line:number,ch:number}, end: {line:number,ch:number}, line: string}>}\n     */\n    function _getSearchMatches(contents, queryExpr) {\n        // Quick exit if not found or if we hit the limit\n        if (searchModel.foundMaximum || contents.search(queryExpr) === -1) {\n            return [];\n        }\n\n        var match, lineNum, line, ch, totalMatchLength, matchedLines, numMatchedLines, lastLineLength, endCh,\n            padding, leftPadding, rightPadding, highlightOffset, highlightEndCh,\n            lines   = StringUtils.getLines(contents),\n            matches = [];\n\n        while ((match = queryExpr.exec(contents)) !== null) {\n            lineNum          = StringUtils.offsetToLineNum(lines, match.index);\n            line             = lines[lineNum];\n            ch               = match.index - contents.lastIndexOf(\"\\n\", match.index - 1) - 1;  // 0-based index\n            matchedLines     = match[0].split(\"\\n\");\n            numMatchedLines  = matchedLines.length;\n            totalMatchLength = match[0].length;\n            lastLineLength   = matchedLines[matchedLines.length - 1].length;\n            endCh            = (numMatchedLines === 1 ? ch + totalMatchLength : lastLineLength);\n            highlightEndCh   = (numMatchedLines === 1 ? endCh : line.length);\n            highlightOffset  = 0;\n\n            if (highlightEndCh <= MAX_DISPLAY_LENGTH) {\n                // Don't store more than 200 chars per line\n                line = line.substr(0, MAX_DISPLAY_LENGTH);\n            } else if (totalMatchLength > MAX_DISPLAY_LENGTH) {\n                // impossible to display the whole match\n                line = line.substr(ch, ch + MAX_DISPLAY_LENGTH);\n                highlightOffset = ch;\n            } else {\n                // Try to have both beginning and end of match displayed\n                padding = MAX_DISPLAY_LENGTH - totalMatchLength;\n                rightPadding = Math.floor(Math.min(padding / 2, line.length - highlightEndCh));\n                leftPadding = Math.ceil(padding - rightPadding);\n                highlightOffset = ch - leftPadding;\n                line = line.substring(highlightOffset, highlightEndCh + rightPadding);\n            }\n\n            matches.push({\n                start: {line: lineNum, ch: ch},\n                end: {line: lineNum + numMatchedLines - 1, ch: endCh},\n\n                highlightOffset: highlightOffset,\n\n                // Note that the following offsets from the beginning of the file are *not* updated if the search\n                // results change. These are currently only used for multi-file replacement, and we always\n                // abort the replace (by shutting the results panel) if we detect any result changes, so we don't\n                // need to keep them up to date. Eventually, we should either get rid of the need for these (by\n                // doing everything in terms of line/ch offsets, though that will require re-splitting files when\n                // doing a replace) or properly update them.\n                startOffset: match.index,\n                endOffset: match.index + totalMatchLength,\n\n                line: line,\n                result: match,\n                isChecked: true\n            });\n\n            // We have the max hits in just this 1 file. Stop searching this file.\n            // This fixed issue #1829 where code hangs on too many hits.\n            // Adds one over MAX_TOTAL_RESULTS in order to know if the search has exceeded\n            // or is equal to MAX_TOTAL_RESULTS. Additional result removed in SearchModel\n            if (matches.length > SearchModel.MAX_TOTAL_RESULTS) {\n                queryExpr.lastIndex = 0;\n                break;\n            }\n\n            // Pathological regexps like /^/ return 0-length matches. Ensure we make progress anyway\n            if (totalMatchLength === 0) {\n                queryExpr.lastIndex++;\n            }\n        }\n\n        return matches;\n    }\n\n    /**\n     * @private\n     * Update the search results using the given list of changes for the given document\n     * @param {Document} doc  The Document that changed, should be the current one\n     * @param {Array.<{from: {line:number,ch:number}, to: {line:number,ch:number}, text: !Array.<string>}>} changeList\n     *      An array of changes as described in the Document constructor\n     */\n    function _updateResults(doc, changeList) {\n        var i, diff, matches, lines, start, howMany,\n            resultsChanged = false,\n            fullPath       = doc.file.fullPath,\n            resultInfo     = searchModel.results[fullPath];\n\n        // Remove the results before we make any changes, so the SearchModel can accurately update its count.\n        searchModel.removeResults(fullPath);\n\n        changeList.forEach(function (change) {\n            lines = [];\n            start = 0;\n            howMany = 0;\n\n            // There is no from or to positions, so the entire file changed, we must search all over again\n            if (!change.from || !change.to) {\n                // TODO: add unit test exercising timestamp logic in this case\n                // We don't just call _updateSearchMatches() here because we want to continue iterating through changes in\n                // the list and update at the end.\n                resultInfo = {matches: _getSearchMatches(doc.getText(), searchModel.queryExpr), timestamp: doc.diskTimestamp};\n                resultsChanged = true;\n\n            } else {\n                // Get only the lines that changed\n                for (i = 0; i < change.text.length; i++) {\n                    lines.push(doc.getLine(change.from.line + i));\n                }\n\n                // We need to know how many newlines were inserted/deleted in order to update the rest of the line indices;\n                // this is the total number of newlines inserted (which is the length of the lines array minus\n                // 1, since the last line in the array is inserted without a newline after it) minus the\n                // number of original newlines being removed.\n                diff = lines.length - 1 - (change.to.line - change.from.line);\n\n                if (resultInfo) {\n                    // Search the last match before a replacement, the amount of matches deleted and update\n                    // the lines values for all the matches after the change\n                    resultInfo.matches.forEach(function (item) {\n                        if (item.end.line < change.from.line) {\n                            start++;\n                        } else if (item.end.line <= change.to.line) {\n                            howMany++;\n                        } else {\n                            item.start.line += diff;\n                            item.end.line   += diff;\n                        }\n                    });\n\n                    // Delete the lines that where deleted or replaced\n                    if (howMany > 0) {\n                        resultInfo.matches.splice(start, howMany);\n                    }\n                    resultsChanged = true;\n                }\n\n                // Searches only over the lines that changed\n                matches = _getSearchMatches(lines.join(\"\\r\\n\"), searchModel.queryExpr);\n                if (matches.length) {\n                    // Updates the line numbers, since we only searched part of the file\n                    matches.forEach(function (value, key) {\n                        matches[key].start.line += change.from.line;\n                        matches[key].end.line   += change.from.line;\n                    });\n\n                    // If the file index exists, add the new matches to the file at the start index found before\n                    if (resultInfo) {\n                        Array.prototype.splice.apply(resultInfo.matches, [start, 0].concat(matches));\n                    // If not, add the matches to a new file index\n                    } else {\n                        // TODO: add unit test exercising timestamp logic in self case\n                        resultInfo = {\n                            matches: matches,\n                            collapsed: false,\n                            timestamp: doc.diskTimestamp\n                        };\n                    }\n                    resultsChanged = true;\n                }\n            }\n        });\n\n        // Always re-add the results, even if nothing changed.\n        if (resultInfo && resultInfo.matches.length) {\n            searchModel.setResults(fullPath, resultInfo);\n        }\n\n        if (resultsChanged) {\n            // Pass `true` for quickChange here. This will make listeners debounce the change event,\n            // avoiding lots of updates if the user types quickly.\n            searchModel.fireChanged(true);\n        }\n    }\n\n    /**\n     * Checks that the file matches the given subtree scope. To fully check whether the file\n     * should be in the search set, use _inSearchScope() instead - a supserset of this.\n     *\n     * @param {!File} file\n     * @param {?FileSystemEntry} scope Search scope, or null if whole project\n     * @return {boolean}\n     */\n    function _subtreeFilter(file, scope) {\n        if (scope) {\n            if (scope.isDirectory) {\n                // Dirs always have trailing slash, so we don't have to worry about being\n                // a substring of another dir name\n                return file.fullPath.indexOf(scope.fullPath) === 0;\n            }\n            return file.fullPath === scope.fullPath;\n\n        }\n        return true;\n    }\n\n    /**\n     * Filters out files that are known binary types.\n     * @param {string} fullPath\n     * @return {boolean} True if the file's contents can be read as text\n     */\n    function _isReadableFileType(fullPath) {\n        return !LanguageManager.getLanguageForPath(fullPath).isBinary();\n    }\n\n    /**\n     * Finds all candidate files to search in the given scope's subtree that are not binary content. Does NOT apply\n     * the current filter yet.\n     * @param {?FileSystemEntry} scope Search scope, or null if whole project\n     * @return {$.Promise} A promise that will be resolved with the list of files in the scope. Never rejected.\n     */\n    function getCandidateFiles(scope) {\n        function filter(file) {\n            return _subtreeFilter(file, scope) && _isReadableFileType(file.fullPath);\n        }\n\n        // If the scope is a single file, just check if the file passes the filter directly rather than\n        // trying to use ProjectManager.getAllFiles(), both for performance and because an individual\n        // in-memory file might be an untitled document that doesn't show up in getAllFiles().\n        if (scope && scope.isFile) {\n            return new $.Deferred().resolve(filter(scope) ? [scope] : []).promise();\n        }\n        return ProjectManager.getAllFiles(filter, true, true);\n\n    }\n\n    /**\n     * Checks that the file is eligible for inclusion in the search (matches the user's subtree scope and\n     * file exclusion filters, and isn't binary). Used when updating results incrementally - during the\n     * initial search, these checks are done in bulk via getCandidateFiles() and the filterFileList() call\n     * after it.\n     * @param {!File} file\n     * @return {boolean}\n     */\n    function _inSearchScope(file) {\n        // Replicate the checks getCandidateFiles() does\n        if (searchModel && searchModel.scope) {\n            if (!_subtreeFilter(file, searchModel.scope)) {\n                return false;\n            }\n        } else {\n            // Still need to make sure it's within project or working set\n            // In getCandidateFiles(), this is covered by the baseline getAllFiles() itself\n            if (file.fullPath.indexOf(ProjectManager.getProjectRoot().fullPath) !== 0) {\n                if (MainViewManager.findInWorkingSet(MainViewManager.ALL_PANES, file.fullPath) === -1) {\n                    return false;\n                }\n            }\n        }\n\n        if (!_isReadableFileType(file.fullPath)) {\n            return false;\n        }\n\n        // Replicate the filtering filterFileList() does\n        return FileFilters.filterPath(searchModel.filter, file.fullPath);\n    }\n\n\n    /**\n     * @private\n     * Tries to update the search result on document changes\n     * @param {$.Event} event\n     * @param {Document} document\n     * @param {<{from: {line:number,ch:number}, to: {line:number,ch:number}, text: !Array.<string>}>} change\n     *      A change list as described in the Document constructor\n     */\n    _documentChangeHandler = function (event, document, change) {\n        changedFileList[document.file.fullPath] = true;\n        if (findOrReplaceInProgress && _inSearchScope(document.file)) {\n            _updateResults(document, change);\n        }\n    };\n\n    /**\n     * @private\n     * Finds search results in the given file and adds them to 'searchResults.' Resolves with\n     * true if any matches found, false if none found. Errors reading the file are treated the\n     * same as if no results found.\n     *\n     * Does not perform any filtering - assumes caller has already vetted this file as a search\n     * candidate.\n     *\n     * @param {!File} file\n     * @return {$.Promise}\n     */\n    function _doSearchInOneFile(file) {\n        var result = new $.Deferred();\n\n        DocumentManager.getDocumentText(file)\n            .done(function (text, timestamp) {\n                // Note that we don't fire a model change here, since this is always called by some outer batch\n                // operation that will fire it once it's done.\n                var matches = _getSearchMatches(text, searchModel.queryExpr);\n                searchModel.setResults(file.fullPath, {matches: matches, timestamp: timestamp});\n                result.resolve(!!matches.length);\n            })\n            .fail(function () {\n                // Always resolve. If there is an error, this file\n                // is skipped and we move on to the next file.\n                result.resolve(false);\n            });\n\n        return result.promise();\n    }\n\n    /**\n     * @private\n     * Inform worker that the document has changed [along with its contents]\n     * @param {string} docPath the path of the changed document\n     */\n    function _updateDocumentInWorker(docPath) {\n        DocumentManager.getDocumentForPath(docPath).done(function (doc) {\n            if (doc) {\n                var updateObject = {\n                    \"filePath\": docPath,\n                    \"docContents\": doc.getText()\n                };\n                IndexingWorker.execPeer(\"documentChanged\", updateObject);\n            }\n        });\n    }\n\n    /**\n     * @private\n     * sends all changed documents that we have tracked to worker\n     */\n    function _updateChangedDocs() {\n        let key = null;\n        for (key in changedFileList) {\n            if (changedFileList.hasOwnProperty(key)) {\n                _updateDocumentInWorker(key);\n            }\n        }\n        changedFileList = {};\n    }\n\n    /**\n     * @private\n     * Executes the Find in Files search inside the current scope.\n     * @param {{query: string, caseSensitive: boolean, isRegexp: boolean}} queryInfo Query info object\n     * @param {!$.Promise} candidateFilesPromise Promise from getCandidateFiles(), which was called earlier\n     * @param {?string} filter A \"compiled\" filter as returned by FileFilters.compile(), or null for no filter\n     * @return {?$.Promise} A promise that's resolved with the search results (or ZERO_FILES_TO_SEARCH) or rejected when the find competes.\n     *      Will be null if the query is invalid.\n     */\n    function _doSearch(queryInfo, candidateFilesPromise, filter) {\n        searchModel.filter = filter;\n\n        var queryResult = searchModel.setQueryInfo(queryInfo);\n        if (!queryResult) {\n            return null;\n        }\n\n        var scopeName = searchModel.scope ? searchModel.scope.fullPath : ProjectManager.getProjectRoot().fullPath,\n            perfTimer = PerfUtils.markStart(\"FindIn: \" + scopeName + \" - \" + queryInfo.query);\n\n        findOrReplaceInProgress = true;\n\n        return candidateFilesPromise\n            .then(function (fileListResult) {\n                // Filter out files/folders that match user's current exclusion filter\n                fileListResult = FileFilters.filterFileList(filter, fileListResult);\n\n                if (searchModel.isReplace) {\n                    if (fileListResult.length) {\n                        searchModel.allResultsAvailable = true;\n                        return Async.doInParallel(fileListResult, _doSearchInOneFile);\n                    }\n                    return ZERO_FILES_TO_SEARCH;\n\n                }\n\n                var searchDeferred = new $.Deferred();\n\n                if (fileListResult.length) {\n                    var searchObject;\n                    if (searchScopeChanged) {\n                        var files = fileListResult\n                            .filter(function (entry) {\n                                return entry.isFile && _isReadableFileType(entry.fullPath);\n                            })\n                            .map(function (entry) {\n                                return entry.fullPath;\n                            });\n\n                        /* The following line prioritizes the open Document in editor and\n                         * pushes it to the top of the filelist. */\n                        files = FindUtils.prioritizeOpenFile(files, FindUtils.getOpenFilePath());\n\n                        searchObject = {\n                            \"files\": files,\n                            \"queryInfo\": queryInfo,\n                            \"queryExpr\": searchModel.queryExpr\n                        };\n                        searchScopeChanged = false;\n                    } else {\n                        searchObject = {\n                            \"queryInfo\": queryInfo,\n                            \"queryExpr\": searchModel.queryExpr\n                        };\n                    }\n\n                    if (searchModel.isReplace) {\n                        searchObject.getAllResults = true;\n                    }\n                    _updateChangedDocs();\n                    FindUtils.notifyWorkerSearchStarted();\n                    let searchStatTime = Date.now();\n                    IndexingWorker.execPeer(\"doSearch\", searchObject)\n                        .then(function (rcvd_object) {\n                            FindUtils.notifyWorkerSearchFinished();\n                            if (!rcvd_object || !rcvd_object.results) {\n                                console.error('search worker failed, falling back to brackets search', rcvd_object);\n                                searchDeferred.fail();\n                                clearSearch();\n                                return;\n                            }\n                            searchModel.results = rcvd_object.results;\n                            searchModel.numMatches = rcvd_object.numMatches;\n                            searchModel.numFiles = rcvd_object.numFiles;\n                            searchModel.exceedsMaximum = rcvd_object.exceedsMaximum;\n                            searchModel.allResultsAvailable = rcvd_object.allResultsAvailable;\n                            searchDeferred.resolve();\n                            Metrics.valueEvent(Metrics.EVENT_TYPE.SEARCH, \"instantSearch\",\n                                \"timeMs\", Date.now() - searchStatTime);\n                        })\n                        .catch(function (err) {\n                            FindUtils.notifyWorkerSearchFinished();\n                            console.error('worker fails', err);\n                            clearSearch();\n                            searchDeferred.reject();\n                        });\n                    return searchDeferred.promise();\n                }\n                return ZERO_FILES_TO_SEARCH;\n\n            })\n            .then(function (zeroFilesToken) {\n                exports._searchDone = true; // for unit tests\n                PerfUtils.addMeasurement(perfTimer);\n\n                if (zeroFilesToken === ZERO_FILES_TO_SEARCH) {\n                    return zeroFilesToken;\n                }\n                return searchModel.results;\n\n            }, function (err) {\n                console.error(\"find in files failed: \", err);\n                PerfUtils.finalizeMeasurement(perfTimer);\n\n                // In jQuery promises, returning the error here propagates the rejection,\n                // unlike in Promises/A, where we would need to re-throw it to do so.\n                return err;\n            });\n    }\n\n    /**\n     * @private\n     * Clears any previous search information, removing update listeners and clearing the model.\n     * @param {?Entry} scope Project file/subfolder to search within; else searches whole project.\n     */\n    clearSearch = function () {\n        findOrReplaceInProgress = false;\n        searchModel.clear();\n    };\n\n    /**\n     * Does a search in the given scope with the given filter. Used when you want to start a search\n     * programmatically. Make sure that project indexing is complete by calling isProjectIndexingComplete()\n     * Else, an empty result will be returned if search is invoked before any files are indexed.\n     *\n     * @param {{query: string, caseSensitive: boolean, isRegexp: boolean}} queryInfo Query info object\n     * @param {?Entry} scope Project file/subfolder to search within; else searches whole project.\n     * @param {?string} filter A \"compiled\" filter as returned by FileFilters.compile(), or null for no filter\n     * @param {?string} replaceText If this is a replacement, the text to replace matches with. This is just\n     *      stored in the model for later use - the replacement is not actually performed right now.\n     * @param {?$.Promise} candidateFilesPromise If specified, a promise that should resolve with the same set of files that\n     *      getCandidateFiles(scope) would return.\n     * @return {$.Promise} A promise that's resolved with the search results or rejected when the find competes.\n     */\n    function doSearchInScope(queryInfo, scope, filter, replaceText, candidateFilesPromise) {\n        clearSearch();\n        searchModel.scope = scope;\n        if (replaceText !== undefined) {\n            searchModel.isReplace = true;\n            searchModel.replaceText = replaceText;\n        }\n        candidateFilesPromise = candidateFilesPromise || getCandidateFiles(scope);\n        return _doSearch(queryInfo, candidateFilesPromise, filter);\n    }\n\n    /**\n     * Given a set of search results, replaces them with the given replaceText, either on disk or in memory.\n     * @param {Object.<fullPath: string, {matches: Array.<{start: {line:number,ch:number}, end: {line:number,ch:number}, startOffset: number, endOffset: number, line: string}>, collapsed: boolean}>} results\n     *      The list of results to replace, as returned from _doSearch..\n     * @param {string} replaceText The text to replace each result with.\n     * @param {?Object} options An options object:\n     *      forceFilesOpen: boolean - Whether to open all files in editors and do replacements there rather than doing the\n     *          replacements on disk. Note that even if this is false, files that are already open in editors will have replacements\n     *          done in memory.\n     *      isRegexp: boolean - Whether the original query was a regexp. If true, $-substitution is performed on the replaceText.\n     * @return {$.Promise} A promise that's resolved when the replacement is finished or rejected with an array of errors\n     *      if there were one or more errors. Each individual item in the array will be a {item: string, error: string} object,\n     *      where item is the full path to the file that could not be updated, and error is either a FileSystem error or one\n     *      of the `FindInFiles.ERROR_*` constants.\n     */\n    function doReplace(results, replaceText, options) {\n        return FindUtils.performReplacements(results, replaceText, options).always(function () {\n            // For UI integration testing only\n            exports._replaceDone = true;\n        });\n    }\n\n    /**\n     * @private\n     * Flags that the search scope has changed, so that the file list for the following search is recomputed\n     */\n    var _searchScopeChanged = function () {\n        searchScopeChanged = true;\n    };\n\n    /**\n     * Notify worker that the results should be collapsed\n     */\n    function _searchcollapseResults() {\n        IndexingWorker.execPeer(\"collapseResults\", FindUtils.isCollapsedResults());\n    }\n\n    /**\n     * Inform worker that the list of files has changed.\n     * @param {array} fileList The list of files that changed.\n     */\n    function filesChanged(fileList) {\n        if (!fileList || fileList.length === 0) {\n            return;\n        }\n        var updateObject = {\n            \"fileList\": fileList\n        };\n        if (searchModel.filter) {\n            updateObject.filesInSearchScope = FileFilters.getPathsMatchingFilter(searchModel.filter, fileList);\n            _searchScopeChanged();\n        }\n        IndexingWorker.execPeer(\"filesChanged\", updateObject);\n    }\n\n    /**\n     * Inform worker that the list of files have been removed.\n     * @param {array} fileList The list of files that was removed.\n     */\n    function filesRemoved(fileList) {\n        if (!fileList || fileList.length === 0) {\n            return;\n        }\n        var updateObject = {\n            \"fileList\": fileList\n        };\n        if (searchModel.filter) {\n            updateObject.filesInSearchScope = FileFilters.getPathsMatchingFilter(searchModel.filter, fileList);\n            _searchScopeChanged();\n        }\n        IndexingWorker.execPeer(\"filesRemoved\", updateObject);\n    }\n\n    /**\n     * @private\n     * Moves the search results from the previous path to the new one and updates the results list, if required\n     * @param {$.Event} event\n     * @param {string} oldName\n     * @param {string} newName\n     */\n    _fileNameChangeHandler = function (event, oldName, newName) {\n        var resultsChanged = false;\n        let removedFiles = [],\n            changedFiles = [];\n\n        // Update the search results\n        _.forEach(searchModel.results, function (item, fullPath) {\n            if (fullPath.indexOf(oldName) === 0) {\n                // worker search : inform worker about the rename\n                removedFiles.push(fullPath);\n                changedFiles.push(fullPath.replace(oldName, newName));\n\n                if (findOrReplaceInProgress) {\n                    searchModel.removeResults(fullPath);\n                    searchModel.setResults(fullPath.replace(oldName, newName), item);\n                    resultsChanged = true;\n                }\n            }\n        });\n\n        filesRemoved(removedFiles);\n        filesChanged(changedFiles);\n\n        if (resultsChanged) {\n            searchModel.fireChanged();\n        }\n    };\n\n    /**\n     * @private\n     * Updates search results in response to FileSystem \"change\" event\n     * @param {$.Event} event\n     * @param {FileSystemEntry} entry\n     * @param {Array.<FileSystemEntry>=} added Added children\n     * @param {Array.<FileSystemEntry>=} removed Removed children\n     */\n    _fileSystemChangeHandler = function (event, entry, added, removed) {\n        var resultsChanged = false;\n\n        /*\n         * Remove existing search results that match the given entry's path\n         * @param {Array.<(File|Directory)>} entries\n         */\n        function _removeSearchResultsForEntries(entries) {\n            var fullPaths = [];\n            entries.forEach(function (entry) {\n                Object.keys(searchModel.results).forEach(function (fullPath) {\n                    if (fullPath === entry.fullPath ||\n                            (entry.isDirectory && fullPath.indexOf(entry.fullPath) === 0)) {\n                        // worker search : inform worker that the file is removed\n                        fullPaths.push(fullPath);\n                        if (findOrReplaceInProgress) {\n                            searchModel.removeResults(fullPath);\n                            resultsChanged = true;\n                        }\n                    }\n                });\n            });\n            // this should be called once with a large array instead of numerous calls with single items\n            filesRemoved(fullPaths);\n        }\n\n        /*\n         * Add new search results for these entries and all of its children\n         * @param {Array.<(File|Directory)>} entries\n         * @return {jQuery.Promise} Resolves when the results have been added\n         */\n        function _addSearchResultsForEntries(entries) {\n            var fullPaths = [];\n            return Async.doInParallel(entries, function (entry) {\n                var addedFiles = [],\n                    addedFilePaths = [],\n                    deferred = new $.Deferred();\n\n                // gather up added files\n                var visitor = function (child) {\n                    // Replicate filtering that getAllFiles() does\n                    if (ProjectManager.shouldIndex(child)) {\n                        if (child.isFile && _isReadableFileType(child.name)) {\n                            // Re-check the filtering that the initial search applied\n                            if (_inSearchScope(child)) {\n                                addedFiles.push(child);\n                                addedFilePaths.push(child.fullPath);\n                            }\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n                entry.visit(visitor, function (err) {\n                    if (err) {\n                        deferred.reject(err);\n                        return;\n                    }\n\n                    //worker Search : inform worker about the file changes\n                    //filesChanged(addedFilePaths);\n                    fullPaths = fullPaths.concat(addedFilePaths);\n\n                    if (findOrReplaceInProgress) {\n                        // find additional matches in all added files\n                        Async.doInParallel(addedFiles, function (file) {\n                            return _doSearchInOneFile(file)\n                                .done(function (foundMatches) {\n                                    resultsChanged = resultsChanged || foundMatches;\n                                });\n                        }).always(deferred.resolve);\n                    } else {\n                        deferred.resolve();\n                    }\n                });\n\n                return deferred.promise();\n            }).always(function () {\n                // this should be called once with a large array instead of numerous calls with single items\n                filesChanged(fullPaths);\n            });\n        }\n\n        if (!entry) {\n            // TODO: re-execute the search completely?\n            return;\n        }\n\n        var addPromise;\n        if (entry.isDirectory) {\n            if (added.length === 0 && removed.length === 0) {\n                // If the added or removed sets are null, must redo the search for the entire subtree - we\n                // don't know which child files/folders may have been added or removed.\n                _removeSearchResultsForEntries([ entry ]);\n\n                var deferred = $.Deferred();\n                addPromise = deferred.promise();\n                entry.getContents(function (err, entries) {\n                    _addSearchResultsForEntries(entries).always(deferred.resolve);\n                });\n            } else {\n                _removeSearchResultsForEntries(removed);\n                addPromise = _addSearchResultsForEntries(added);\n            }\n        } else { // entry.isFile\n            _removeSearchResultsForEntries([ entry ]);\n            addPromise = _addSearchResultsForEntries([ entry ]);\n        }\n\n        addPromise.always(function () {\n            // Restore the results if needed\n            if (resultsChanged) {\n                searchModel.fireChanged();\n            }\n        });\n    };\n\n    /**\n     * This stores file system events emitted by watchers that were not yet processed\n     */\n    var _cachedFileSystemEvents = [];\n\n    /**\n     * Debounced function to process emitted file system events\n     * for cases when there's a lot of fs events emitted in a very short period of time\n     */\n    _processCachedFileSystemEvents = _.debounce(function () {\n        // we need to reduce _cachedFileSystemEvents not to contain duplicates!\n        _cachedFileSystemEvents = _cachedFileSystemEvents.reduce(function (result, obj) {\n            var fullPath = obj.entry ? obj.entry.fullPath : null;\n            // merge added & removed\n            if (result[fullPath] && obj.isDirectory) {\n                obj.added = obj.added.concat(result[fullPath].added);\n                obj.removed = obj.removed.concat(result[fullPath].removed);\n            }\n            // use the latest event as base\n            result[fullPath] = obj;\n            return result;\n        }, {});\n        _.forEach(_cachedFileSystemEvents, function (obj) {\n            _fileSystemChangeHandler(obj.event, obj.entry, obj.added, obj.removed);\n        });\n        _cachedFileSystemEvents = [];\n    }, FILE_SYSTEM_EVENT_DEBOUNCE_TIME);\n\n    /**\n     * Wrapper function for _fileSystemChangeHandler which handles all incoming fs events\n     * putting them to cache and executing a debounced function\n     */\n    _debouncedFileSystemChangeHandler = function (event, entry, added, removed) {\n        // normalize this here so we don't need to handle null later\n        var isDirectory = false;\n        if (entry && entry.isDirectory) {\n            isDirectory = true;\n            added = added || [];\n            removed = removed || [];\n        }\n        _cachedFileSystemEvents.push({\n            event: event,\n            entry: entry,\n            isDirectory: isDirectory,\n            added: added,\n            removed: removed\n        });\n        _processCachedFileSystemEvents();\n    };\n\n    /**\n     * On project change, inform worker about the new list of files that needs to be crawled.\n     * Instant search is also disabled for the time being till the crawl is complete in worker.\n     *\n     * This should never be called directly and only called via _scheduleCacheInit() below\n     * to not affect project load performance.\n     */\n    var _initCache = function () {\n        projectIndexingComplete = false;\n        function filter(file) {\n            return _subtreeFilter(file, null) && _isReadableFileType(file.fullPath);\n        }\n        FindUtils.setInstantSearchDisabled(true);\n\n        //we always listen for filesytem changes.\n        _addListeners();\n\n        FindUtils.notifyIndexingStarted();\n        ProjectManager.getAllFiles(filter, true, true)\n            .done(function (fileListResult) {\n                var files = fileListResult,\n                    filter = FileFilters.getActiveFilter();\n                if (filter && filter.patterns.length > 0) {\n                    files = FileFilters.filterFileList(FileFilters.compile(filter.patterns), files);\n                }\n                files = files.filter(function (entry) {\n                    return entry.isFile && _isReadableFileType(entry.fullPath);\n                }).map(function (entry) {\n                    return entry.fullPath;\n                });\n                IndexingWorker.execPeer(\"initCache\", files);\n            });\n        _searchScopeChanged();\n    };\n\n    function _scheduleCacheInit() {\n        projectIndexingComplete = false;\n        setTimeout(_initCache, CACHE_INIT_DELAY_MS);\n    }\n\n\n    /**\n     * Gets the next page of search results to append to the result set.\n     * @return {object} A promise that's resolved with the search results or rejected when the find competes.\n     */\n    function getNextPageofSearchResults() {\n        var searchDeferred = $.Deferred();\n        if (searchModel.allResultsAvailable) {\n            return searchDeferred.resolve().promise();\n        }\n        _updateChangedDocs();\n        FindUtils.notifyWorkerSearchStarted();\n        IndexingWorker.execPeer(\"nextPage\")\n            .then(function (rcvd_object) {\n                FindUtils.notifyWorkerSearchFinished();\n                if (searchModel.results) {\n                    var resultEntry;\n                    for (resultEntry in rcvd_object.results ) {\n                        if (rcvd_object.results.hasOwnProperty(resultEntry)) {\n                            searchModel.results[resultEntry.toString()] = rcvd_object.results[resultEntry];\n                        }\n                    }\n                } else {\n                    searchModel.results = rcvd_object.results;\n                }\n                searchModel.fireChanged();\n                searchDeferred.resolve();\n            })\n            .catch(function (err) {\n                FindUtils.notifyWorkerSearchFinished();\n                console.error('search worker fails', err);\n                searchDeferred.reject();\n            });\n        return searchDeferred.promise();\n    }\n\n    function getAllSearchResults() {\n        var searchDeferred = $.Deferred();\n        if (searchModel.allResultsAvailable) {\n            return searchDeferred.resolve().promise();\n        }\n        _updateChangedDocs();\n        FindUtils.notifyWorkerSearchStarted();\n        IndexingWorker.execPeer(\"getAllResults\")\n            .then(function (rcvd_object) {\n                FindUtils.notifyWorkerSearchFinished();\n                searchModel.results = rcvd_object.results;\n                searchModel.numMatches = rcvd_object.numMatches;\n                searchModel.numFiles = rcvd_object.numFiles;\n                searchModel.allResultsAvailable = true;\n                searchModel.fireChanged();\n                searchDeferred.resolve();\n            })\n            .catch(function (err) {\n                FindUtils.notifyWorkerSearchFinished();\n                console.error('search worker fails', err);\n                searchDeferred.reject();\n            });\n        return searchDeferred.promise();\n    }\n\n    function isProjectIndexingComplete() {\n        return projectIndexingComplete;\n    }\n\n    ProjectManager.on(\"projectOpen\", _scheduleCacheInit);\n    FindUtils.on(FindUtils.SEARCH_FILE_FILTERS_CHANGED, _searchScopeChanged);\n    FindUtils.on(FindUtils.SEARCH_SCOPE_CHANGED, _searchScopeChanged);\n    FindUtils.on(FindUtils.SEARCH_COLLAPSE_RESULTS, _searchcollapseResults);\n\n    // Public exports\n    exports.searchModel               = searchModel;\n    exports.isProjectIndexingComplete = isProjectIndexingComplete;\n    exports.doSearchInScope           = doSearchInScope;\n    exports.doReplace                 = doReplace;\n    exports.getCandidateFiles         = getCandidateFiles;\n    exports.clearSearch               = clearSearch;\n    exports.ZERO_FILES_TO_SEARCH      = ZERO_FILES_TO_SEARCH;\n    exports.getNextPageofSearchResults          = getNextPageofSearchResults;\n    exports.getAllSearchResults       = getAllSearchResults;\n\n    // For unit tests only\n    exports._documentChangeHandler = _documentChangeHandler;\n    exports._fileNameChangeHandler = _fileNameChangeHandler;\n    exports._fileSystemChangeHandler = _fileSystemChangeHandler;\n});\n"],"file":"FindInFiles.js"}
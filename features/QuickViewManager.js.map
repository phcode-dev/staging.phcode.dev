{"version":3,"sources":["features/QuickViewManager.js"],"names":["define","require","exports","module","CommandManager","Commands","EditorManager","Menus","PreferencesManager","Strings","ViewUtils","AppInit","ProviderRegistrationHandler","RegistrationHandler","previewContainerHTML","_providerRegistrationHandler","registerQuickViewProvider","registerProvider","bind","removeQuickViewProvider","removeProvider","_getQuickViewProviders","editor","quickViewProviders","language","getLanguageForSelection","enabledProviders","getProvidersForLanguageId","getId","item","push","provider","enabled","prefs","$previewContainer","$previewContent","_currentMousePos","animationRequest","CMD_ENABLE_QUICK_VIEW","QUICK_VIEW_EDITOR_MARKER","HOVER_DELAY","POINTER_HEIGHT","POPOVER_HORZ_MARGIN","getExtensionPrefs","definePreference","description","DESCRIPTION_QUICK_VIEW_ENABLED","popoverState","hidePreview","resizeObserver","disconnect","visible","marker","clear","empty","hide","removeClass","showPreviewQueued","mouseInPreviewContainer","window","clearTimeout","hoverTimer","positionPreview","xpos","ypos","ybot","find","is","previewWidth","outerWidth","top","outerHeight","left","elementRect","height","width","clip","getElementClipSize","$","getRootElement","right","addClass","css","_isResultBeforePopoverStart","popover","result","start","indexFromPos","_isResultAfterPopoverEnd","end","_createPopoverState","popoverResults","length","content","append","startCoord","charCoords","endCoord","ytop","bottom","async","queryPreviewProviders","pos","token","line","document","getLine","providers","popovers","providerPromises","getQuickView","results","Promise","allSettled","status","value","_renderPreview","markText","className","$popoverContent","show","ResizeObserver","observe","showPreview","getHoveredEditor","coordsChar","clientX","clientY","ch","getToken","_isMouseFarFromPopup","previewRect","getBoundingClientRect","docRect","thresholdPercent","_isDistanceExceedThreshold","smaller","larger","total","threshold","x","y","processMouseMove","posWithinRange","setTimeout","handleMouseMove","event","buttons","requestAnimationFrame","onActiveEditorChange","current","previous","off","on","updateMenuItemCheckmark","get","setChecked","mouseOut","_evt","contains","toElement","_mouseEnteredPreviewContainer","_mouseExitedPreviewContainer","setEnabled","_enabled","doNotSave","editorHolder","previewContainer","addEventListener","getActiveEditor","removeEventListener","set","save","toggleEnableQuickView","_forceShow","Math","floor","appReady","appendTo","register","getMenu","AppMenuBar","VIEW_MENU","addMenuItem","AFTER","VIEW_TOGGLE_INSPECTION","_queryPreviewProviders"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * QuickViewManager provides support to add interactive preview popups on hover over the main editors.\n * Extensions can register to provide previews with `QuickViewManager.registerQuickViewProvider` API.\n * ![quick-view-image.png](generatedDocs/images/quick-view-image.png)\n * ![quick-view-youtube.png](generatedDocs/images/quick-view-youtube.png)\n *\n *\n * ## Usage\n * Lets build a \"hello world\" extension that displays \"hello world\" on hover over a text in the editor.\n * In your extension file, add the following code:\n * ```js\n * const QuickViewManager = brackets.getModule(\"features/QuickViewManager\");\n * // replace `all` with language ID(Eg. javascript) if you want to restrict the preview to js files only.\n * QuickViewManager.registerQuickViewProvider(exports, [\"all\"]);\n *\n * // now implement the getQuickView function that will be invoked when ever user hovers over a text in the editor.\n * exports.getQuickView = function(editor, pos, token, line) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 start: {line: pos.line, ch:token.start},\n *                 end: {line: pos.line, ch:token.end},\n *                 content: \"<div>hello world</div>\"\n *             });\n *         });\n *     };\n * ```\n *\n * ### How it works\n * When QuickViewManager determines that the user intents to see QuickView on hover, `getQuickView` function on all\n * registered QuickView providers are invoked to get the quick view popup. `getQuickView` should return a promise\n * that resolves to the popup contents if the provider has a quick view. Else just reject the promise. If multiple\n * providers returns QuickView, all of them are displayed one by one. See detailed API docs for implementation\n * details below:\n *\n * ## API\n * ### registerQuickViewProvider\n * Register a QuickView provider with this api.\n *\n * ```js\n * // syntax\n * QuickViewManager.registerQuickViewProvider(provider, supportedLanguages);\n * ```\n * The API requires three parameters:\n * 1. `provider`: must implement a  `getQuickView` function which will be invoked to get the preview. See API doc below.\n * 1. `supportedLanguages`: An array of languages that the QuickView supports. If `[\"all\"]` is supplied, then the\n *    QuickView will be invoked for all languages. Restrict to specific languages: Eg: `[\"javascript\", \"html\", \"php\"]`\n *\n * ```js\n * // to register a provider that will be invoked for all languages. where provider is any object that implements\n * // a getQuickView function\n * QuickViewManager.registerQuickViewProvider(provider, [\"all\"]);\n *\n * // to register a provider that will be invoked for specific languages\n * QuickViewManager.registerQuickViewProvider(provider, [\"javascript\", \"html\", \"php\"]);\n * ```\n *\n * ### removeQuickViewProvider\n * Removes a registered code hint provider. The API takes the same arguments as `registerQuickViewProvider`.\n * ```js\n * // syntax\n * QuickViewManager.removeQuickViewProvider(provider, supportedLanguages);\n * // Example\n * QuickViewManager.removeQuickViewProvider(provider, [\"javascript\", \"html\"]);\n * ```\n *\n * ### getQuickView\n * Each provider must implement the `getQuickView` function that returns a promise. The promise either resolves with\n * the quick view details object(described below) or rejects if there is no preview for the position.\n * ```js\n * // function signature\n * provider.getQuickView = function(editor, pos, token, line) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 start: {line: pos.line, ch:token.start},\n *                 end: {line: pos.line, ch:token.end},\n *                 content: \"<div>hello world</div>\"\n *             });\n *         });\n *     };\n * ```\n *\n * #### parameters\n * The function will be called with the following arguments:\n * 1. `editor` - The editor over which the user hovers the mouse cursor.\n * 1. `pos` - the cursor position over which the user hovers.\n * 1. `token` - hovered token details\n * 1. `line` - the full line text as string.\n *\n * #### return types\n * The promise returned should resolve with the following contents:\n * 1. `start` : Indicates the start cursor position from which the quick view is valid.\n * 1. `end` : Indicates the end cursor position to which the quick view is valid. These are generally used to highlight\n *    the hovered section of the text in the editor.\n * 1. `content`: Either `HTML` as text, a `DOM Node` or a `Jquery Element`.\n *\n * #### Considerations\n * 1. QuickView won't be displayed till all provider promises are settled. To improve performance, if your QuickView\n *    handler takes time to resolve the QuickView, resolve a dummy quick once you are sure that a QuickView needs\n *    to be shown to the user. The div contents can be later updated as and when more details are available.\n * 1. Note that the QuickView could be hidden/removed any time by the QuickViewManager.\n * 1. If multiple providers returns a valid popup, all of them are displayed.\n *\n * @module features/QuickViewManager\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Brackets modules\n    const CommandManager    = require(\"command/CommandManager\"),\n        Commands            = require(\"command/Commands\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        Menus               = require(\"command/Menus\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        Strings             = require(\"strings\"),\n        ViewUtils           = require(\"utils/ViewUtils\"),\n        AppInit             = require(\"utils/AppInit\"),\n        ProviderRegistrationHandler = require(\"features/PriorityBasedRegistration\").RegistrationHandler;\n\n    const previewContainerHTML       = '<div id=\"quick-view-container\">\\n' +\n        '    <div class=\"preview-content\">\\n' +\n        '    </div>\\n' +\n        '</div>';\n\n    const _providerRegistrationHandler = new ProviderRegistrationHandler(),\n        registerQuickViewProvider = _providerRegistrationHandler.registerProvider.bind(_providerRegistrationHandler),\n        removeQuickViewProvider = _providerRegistrationHandler.removeProvider.bind(_providerRegistrationHandler);\n\n    function _getQuickViewProviders(editor) {\n        let quickViewProviders = [];\n        let language = editor.getLanguageForSelection(),\n            enabledProviders = _providerRegistrationHandler.getProvidersForLanguageId(language.getId());\n\n        for(let item of enabledProviders){\n            quickViewProviders.push(item.provider);\n        }\n        return quickViewProviders;\n    }\n\n    let enabled,                             // Only show preview if true\n        prefs                      = null,   // Preferences\n        $previewContainer,                   // Preview container\n        $previewContent,                     // Preview content holder\n        _currentMousePos,\n        animationRequest;\n\n    // Constants\n    const CMD_ENABLE_QUICK_VIEW       = \"view.enableQuickView\",\n        QUICK_VIEW_EDITOR_MARKER = 'quickViewMark',\n        // Time (ms) mouse must remain over a provider's matched text before popover appears\n        HOVER_DELAY                 = 500,\n        // Pointer height, used to shift popover above pointer (plus a little bit of space)\n        POINTER_HEIGHT              = 15,\n        POPOVER_HORZ_MARGIN         =  5;   // Horizontal margin\n\n    prefs = PreferencesManager.getExtensionPrefs(\"quickview\");\n    prefs.definePreference(\"enabled\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_QUICK_VIEW_ENABLED\n    });\n\n    /**\n     * There are three states for this var:getToken\n     * 1. If null, there is no provider result for the given mouse position.\n     * 2. If non-null, and visible==true, there is a popover currently showing.\n     * 3. If non-null, but visible==false, we're waiting for HOVER_DELAY, which\n     *    is tracked by hoverTimer. The state changes to visible==true as soon as\n     *    there is a provider. If the mouse moves before then, timer is restarted.\n     *\n     * @type {{\n     *      visible: boolean,\n     *      editor: !Editor,\n     *      hoverTimer: number,             - setTimeout() token\n     *      start: !{line, ch},             - start of matched text range\n     *      end: !{line, ch},               - end of matched text range\n     *      content: !string,               - HTML content to display in popover\n     *      onShow: ?function():void,       - called once popover content added to the DOM (may never be called)\n     *        - if specified, must call positionPreview()\n     *      xpos: number,                   - x of center of popover\n     *      ytop: number,                   - y of top of matched text (when popover placed above text, normally)\n     *      ybot: number,                   - y of bottom of matched text (when popover moved below text, avoiding window top)\n     *      marker: ?CodeMirror.TextMarker  - only set once visible==true\n     * }}\n     * @private\n     */\n    let popoverState = null;\n\n\n\n    // Popover widget management ----------------------------------------------\n\n    /**\n     * Cancels whatever popoverState was currently pending and sets it back to null. If the popover was visible,\n     * hides it; if the popover was invisible and still pending, cancels hoverTimer so it will never be shown.\n     * @private\n     */\n    function hidePreview() {\n        if (!popoverState) {\n            return;\n        }\n        if(popoverState.resizeObserver){\n            popoverState.resizeObserver.disconnect();\n        }\n        popoverState.resizeObserver = null;\n\n        if (popoverState.visible) {\n            popoverState.marker.clear();\n\n            $previewContent.empty();\n            $previewContainer.hide();\n            $previewContainer.removeClass(\"active\");\n        } else {\n            showPreviewQueued = false;\n            mouseInPreviewContainer = false;\n            window.clearTimeout(popoverState.hoverTimer);\n        }\n        popoverState = null;\n    }\n\n    function positionPreview(editor, xpos, ypos, ybot) {\n        if ($previewContent.find(\"#quick-view-popover-root\").is(':empty')){\n            hidePreview();\n            return;\n        }\n        let previewWidth  = $previewContainer.outerWidth(),\n            top           = ypos - $previewContainer.outerHeight() - POINTER_HEIGHT,\n            left          = xpos - previewWidth / 2,\n            elementRect = {\n                top: top,\n                left: left - POPOVER_HORZ_MARGIN,\n                height: $previewContainer.outerHeight() + POINTER_HEIGHT,\n                width: previewWidth + 2 * POPOVER_HORZ_MARGIN\n            },\n            clip = ViewUtils.getElementClipSize($(editor.getRootElement()), elementRect);\n\n        // Prevent horizontal clipping\n        if (clip.left > 0) {\n            left += clip.left;\n        } else if (clip.right > 0) {\n            left -= clip.right;\n        }\n\n        // If clipped on top, flip popover below line\n        if (clip.top > 0) {\n            top = ybot + POINTER_HEIGHT;\n            $previewContainer\n                .removeClass(\"preview-bubble-above\")\n                .addClass(\"preview-bubble-below\");\n        } else {\n            $previewContainer\n                .removeClass(\"preview-bubble-below\")\n                .addClass(\"preview-bubble-above\");\n        }\n\n        $previewContainer\n            .css({\n                left: left,\n                top: top\n            })\n            .addClass(\"active\");\n    }\n\n    // Preview hide/show logic ------------------------------------------------\n\n    function _isResultBeforePopoverStart(editor, popover, result){\n        if(!popover.start){\n            return true;\n        }\n        return editor.indexFromPos(result.start) < editor.indexFromPos(popover.start);\n    }\n\n    function _isResultAfterPopoverEnd(editor, popover, result){\n        if(!popover.end){\n            return true;\n        }\n        return editor.indexFromPos(popover.start) > editor.indexFromPos(result.end);\n    }\n\n    function _createPopoverState(editor, popoverResults) {\n        if (popoverResults && popoverResults.length) {\n            let popover = {\n                content: $(\"<div id='quick-view-popover-root'></div>\")\n            };\n            // Each provider return popover { start, end, content}\n            for(let result of popoverResults){\n                if(_isResultBeforePopoverStart(editor, popover, result)){\n                    popover.start = result.start;\n                }\n                if(_isResultAfterPopoverEnd(editor, popover, result)){\n                    popover.end = result.end;\n                }\n                popover.content.append(result.content);\n            }\n\n            let startCoord = editor.charCoords(popover.start),\n                endCoord = editor.charCoords(popover.end);\n            popover.xpos = (endCoord.left - startCoord.left) / 2 + startCoord.left;\n            if(endCoord.left<startCoord.left){\n                // this probably spans multiple lines, just show at start cursor position\n                popover.xpos = startCoord.left;\n            }\n            popover.ytop = startCoord.top;\n            popover.ybot = startCoord.bottom;\n            popover.visible = false;\n            popover.editor  = editor;\n            return popover;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns a 'ready for use' popover state object:\n     * { visible: false, editor, start, end, content, ?onShow, xpos, ytop, ybot }\n     * Lacks only hoverTimer (supplied by handleMouseMove()) and marker (supplied by showPreview()).\n     * @private\n     */\n    async function queryPreviewProviders(editor, pos, token) {\n        let line = editor.document.getLine(pos.line);\n        let providers = _getQuickViewProviders(editor);\n        let popovers = [], providerPromises = [];\n        for(let provider of providers){\n            providerPromises.push(provider.getQuickView(editor, pos, token, line));\n        }\n        let results = await Promise.allSettled(providerPromises);\n        for(let result of results){\n            if(result.status === \"fulfilled\" && result.value){\n                popovers.push(result.value);\n            }\n        }\n\n        return _createPopoverState(editor, popovers);\n    }\n\n    /**\n     * Changes the current hidden popoverState to visible, showing it in the UI and highlighting\n     * its matching text in the editor.\n     * @private\n     */\n    function _renderPreview(editor) {\n        if (popoverState && popoverState.start && popoverState.end) {\n            popoverState.marker = editor.markText(\n                QUICK_VIEW_EDITOR_MARKER,\n                popoverState.start,\n                popoverState.end,\n                {className: \"quick-view-highlight\"}\n            );\n\n            let $popoverContent = $(popoverState.content);\n            $previewContent.append($popoverContent);\n            $previewContainer.show();\n            popoverState.visible = true;\n            positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n\n            popoverState.resizeObserver = new ResizeObserver(() => {\n                positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n            });\n            popoverState.resizeObserver.observe($popoverContent[0]);\n        }\n    }\n\n    async function showPreview(editor) {\n        let token;\n\n        // Figure out which editor we are over\n        if (!editor) {\n            editor = EditorManager.getHoveredEditor(_currentMousePos);\n        }\n\n        if (!editor) {\n            hidePreview();\n            return;\n        }\n\n        // Find char mouse is over\n        let pos = editor.coordsChar({left: _currentMousePos.clientX, top: _currentMousePos.clientY});\n\n        // No preview if mouse is past last char on line\n        if (pos.ch >= editor.document.getLine(pos.line).length) {\n            return;\n        }\n\n        // Query providers and append to popoverState\n        token = editor.getToken(pos);\n        popoverState = await queryPreviewProviders(editor, pos, token);\n        _renderPreview(editor);\n    }\n\n    function _isMouseFarFromPopup() {\n        const previewRect = $previewContainer[0].getBoundingClientRect();\n        const docRect = {\n            height: $(document).height(),\n            width: $(document).width()\n        };\n        const thresholdPercent = 5;\n        function _isDistanceExceedThreshold(smaller, larger, total, threshold) {\n            return ((larger - smaller)/total)*100 > threshold;\n        }\n        let x= _currentMousePos.clientX, y=_currentMousePos.clientY;\n        if((x<previewRect.left && _isDistanceExceedThreshold(x, previewRect.left, docRect.width, thresholdPercent))\n            ||(x>previewRect.right && _isDistanceExceedThreshold(previewRect.right, x, docRect.width, thresholdPercent))\n            ||(y<previewRect.top && _isDistanceExceedThreshold(y, previewRect.top, docRect.height, thresholdPercent))\n            ||(y>previewRect.bottom && _isDistanceExceedThreshold(previewRect.bottom, y, docRect.height, thresholdPercent))){\n            return true;\n        }\n        return false;\n    }\n\n    let showPreviewQueued = false;\n\n    function processMouseMove() {\n        animationRequest = null;\n\n        if (mouseInPreviewContainer) {\n            return;\n        }\n\n        let editor = null;\n\n        if (popoverState && popoverState.visible) {\n            // Only figure out which editor we are over when there is already a popover\n            // showing (otherwise wait until after delay to minimize processing)\n            editor = EditorManager.getHoveredEditor(_currentMousePos);\n            if (editor) {\n                // Find char mouse is over\n                let pos = editor.coordsChar({left: _currentMousePos.clientX, top: _currentMousePos.clientY});\n                if (popoverState.start && popoverState.end &&\n                        editor.posWithinRange(pos, popoverState.start, popoverState.end, true) &&\n                        (pos.ch < editor.document.getLine(pos.line).length)) {\n\n                    // That one's still relevant - nothing more to do\n                    // Note: posWithinRange() includes mouse past end of line, so need to check for that case\n                    return;\n                }\n                if(_isMouseFarFromPopup()){\n                    hidePreview();\n                    return;\n                }\n            }\n        }\n\n        if(!showPreviewQueued){\n            // Initialize popoverState\n            showPreviewQueued = true;\n            popoverState = popoverState || {};\n\n            // Set timer to scan and show. This will get cancelled (in hidePreview())\n            // if mouse movement rendered this popover inapplicable before timer fires.\n            // When showing \"immediately\", still use setTimeout() to make this async\n            // so we return from this mousemove event handler ASAP.\n            popoverState.hoverTimer = window.setTimeout(function () {\n                showPreviewQueued = false;\n                if(!mouseInPreviewContainer){\n                    hidePreview();\n                    popoverState = {};\n                    showPreview(editor);\n                }\n            }, HOVER_DELAY);\n        }\n    }\n\n    function handleMouseMove(event) {\n        // Keep track of mouse position\n        _currentMousePos = {\n            clientX: event.clientX,\n            clientY: event.clientY\n        };\n\n        if (!enabled) {\n            return;\n        }\n\n        if (event.buttons !== 0) {\n            // Button is down - don't show popovers while dragging\n            hidePreview();\n            return;\n        }\n\n        // Prevent duplicate animation frame requests\n        if (!animationRequest) {\n            animationRequest = window.requestAnimationFrame(processMouseMove);\n        }\n    }\n\n    function onActiveEditorChange(event, current, previous) {\n        // Hide preview when editor changes\n        hidePreview();\n\n        if (previous && previous.document) {\n            previous.document.off(\"change\", hidePreview);\n        }\n\n        if (current && current.document) {\n            current.document.on(\"change\", hidePreview);\n        }\n    }\n\n    // Menu command handlers\n    function updateMenuItemCheckmark() {\n        CommandManager.get(CMD_ENABLE_QUICK_VIEW).setChecked(enabled);\n    }\n\n    let mouseInPreviewContainer = false;\n    function mouseOut(_evt) {\n        setTimeout(()=>{\n            if(mouseInPreviewContainer || $previewContainer[0].contains(_evt.toElement)){\n                return;\n            }\n            hidePreview();\n        }, HOVER_DELAY);\n    }\n\n    function _mouseEnteredPreviewContainer() {\n        mouseInPreviewContainer = true;\n    }\n\n    function _mouseExitedPreviewContainer() {\n        mouseInPreviewContainer = false;\n    }\n\n    function setEnabled(_enabled, doNotSave) {\n        if (enabled !== _enabled) {\n            enabled = _enabled;\n            let editorHolder = $(\"#editor-holder\")[0];\n            let previewContainer = $previewContainer[0];\n            if (enabled) {\n                // Note: listening to \"scroll\" also catches text edits, which bubble a scroll\n                // event up from the hidden text area. This means\n                // we auto-hide on text edit, which is probably actually a good thing.\n                editorHolder.addEventListener(\"mousemove\", handleMouseMove, true);\n                editorHolder.addEventListener(\"scroll\", hidePreview, true);\n                editorHolder.addEventListener(\"mouseout\", mouseOut, true);\n                previewContainer.addEventListener(\"mouseover\", _mouseEnteredPreviewContainer, true);\n                previewContainer.addEventListener(\"mouseout\", _mouseExitedPreviewContainer, true);\n\n                // Setup doc \"change\" listener\n                onActiveEditorChange(null, EditorManager.getActiveEditor(), null);\n                EditorManager.on(\"activeEditorChange\", onActiveEditorChange);\n\n            } else {\n                editorHolder.removeEventListener(\"mousemove\", handleMouseMove, true);\n                editorHolder.removeEventListener(\"scroll\", hidePreview, true);\n                editorHolder.removeEventListener(\"mouseout\", mouseOut, true);\n                previewContainer.removeEventListener(\"mouseover\", _mouseEnteredPreviewContainer, true);\n                previewContainer.removeEventListener(\"mouseout\", _mouseExitedPreviewContainer, true);\n\n\n                // Cleanup doc \"change\" listener\n                onActiveEditorChange(null, null, EditorManager.getActiveEditor());\n                EditorManager.off(\"activeEditorChange\", onActiveEditorChange);\n\n                hidePreview();\n            }\n            if (!doNotSave) {\n                prefs.set(\"enabled\", enabled);\n                prefs.save();\n            }\n        }\n        // Always update the checkmark, even if the enabled flag hasn't changed.\n        updateMenuItemCheckmark();\n    }\n\n    function toggleEnableQuickView() {\n        setEnabled(!enabled);\n    }\n\n    function _forceShow(popover) {\n        hidePreview();\n        _currentMousePos = {\n            clientX: popover.xpos,\n            clientY: Math.floor((popover.ybot + popover.ytop) / 2)\n        };\n        popoverState = popover;\n        _renderPreview(popover.editor);\n    }\n\n    AppInit.appReady(function () {\n        // Create the preview container\n        $previewContainer = $(previewContainerHTML).appendTo($(\"body\"));\n        $previewContent = $previewContainer.find(\".preview-content\");\n\n        // Register command\n        // Insert menu at specific pos since this may load before OR after code folding extension\n        CommandManager.register(Strings.CMD_ENABLE_QUICK_VIEW, CMD_ENABLE_QUICK_VIEW, toggleEnableQuickView);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(\n            CMD_ENABLE_QUICK_VIEW, null, Menus.AFTER, Commands.VIEW_TOGGLE_INSPECTION);\n\n        // Setup initial UI state\n        setEnabled(prefs.get(\"enabled\"), true);\n\n        prefs.on(\"change\", \"enabled\", function () {\n            setEnabled(prefs.get(\"enabled\"), true);\n        });\n    });\n\n    // For unit testing\n    exports._queryPreviewProviders  = queryPreviewProviders;\n    exports._forceShow              = _forceShow;\n\n    exports.registerQuickViewProvider = registerQuickViewProvider;\n    exports.removeQuickViewProvider   = removeQuickViewProvider;\n});\n"],"file":"QuickViewManager.js"}
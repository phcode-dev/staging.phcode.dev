{"version":3,"sources":["features/QuickViewManager.js"],"names":["define","require","exports","module","CommandManager","Commands","EditorManager","Menus","PreferencesManager","Strings","ViewUtils","AppInit","WorkspaceManager","ProviderRegistrationHandler","RegistrationHandler","previewContainerHTML","_providerRegistrationHandler","registerQuickViewProvider","registerProvider","bind","removeQuickViewProvider","removeProvider","_getQuickViewProviders","editor","pos","language","getLanguageForPosition","getProvidersForLanguageId","getId","enabled","prefs","$previewContainer","$previewContent","_currentMousePos","animationRequest","quickViewLocked","CMD_ENABLE_QUICK_VIEW","QUICK_VIEW_EDITOR_MARKER","HOVER_DELAY","POINTER_HEIGHT","POPOVER_HORZ_MARGIN","getExtensionPrefs","definePreference","description","DESCRIPTION_QUICK_VIEW_ENABLED","popoverState","hidePreview","visible","marker","clear","empty","hide","removeClass","getActiveEditor","focus","showPreviewQueued","mouseInPreviewContainer","unlockQuickView","window","clearTimeout","hoverTimer","positionPreview","xpos","ypos","ybot","find","is","previewWidth","outerWidth","top","outerHeight","left","elementRect","height","width","clip","getElementClipSize","$","getRootElement","right","addClass","css","_isResultBeforePopoverStart","popover","result","start","indexFromPos","_isResultAfterPopoverEnd","end","_createPopoverState","popoverResults","length","content","editsDoc","append","startCoord","charCoords","endCoord","ytop","bottom","_getPopover","results","providerInfos","popovers","fulfilledProviderInfos","i","status","value","popoverResult","providerInfo","push","provider","filterQuickView","async","queryPreviewProviders","token","line","document","getLine","providerPromises","activeProviderInfos","getQuickView","console","error","Promise","allSettled","_renderPreview","markText","className","$popoverContent","show","addEventListener","currentQueryID","showPreview","getHoveredEditor","coordsChar","clientX","clientY","ch","getToken","savedQueryId","_isMouseFarFromPopup","previewRect","getBoundingClientRect","docRect","thresholdPercent","_isDistanceExceedThreshold","smaller","larger","total","threshold","x","y","processMouseMove","posWithinRange","setTimeout","handleMouseMove","event","contains","activeElement","buttons","requestAnimationFrame","docChanged","onActiveEditorChange","current","previous","off","on","updateMenuItemCheckmark","get","setChecked","mouseOut","_evt","toElement","_mouseEnteredPreviewContainer","_mouseExitedPreviewContainer","setEnabled","_enabled","doNotSave","editorHolder","previewContainer","removeEventListener","set","save","toggleEnableQuickView","enableQuickView","_forceShow","Math","floor","_handleEscapeKeyEvent","isQuickViewShown","preventDefault","stopPropagation","lockQuickView","appReady","appendTo","register","getMenu","AppMenuBar","VIEW_MENU","addMenuItem","AFTER","VIEW_TOGGLE_INSPECTION","addEscapeKeyEventHandler","_queryPreviewProviders"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * QuickViewManager provides support to add interactive preview popups on hover over the main editors.\n * Extensions can register to provide previews with `QuickViewManager.registerQuickViewProvider` API.\n * ![quick-view-image.png](https://docs-images.phcode.dev/phcode-sdk/quick-view-image.png)\n * ![quick-view-youtube.png](https://docs-images.phcode.dev/phcode-sdk/quick-view-youtube.png)\n *\n * ### See Related: SelectionViewManager\n * [features/SelectionViewManager](https://github.com/phcode-dev/phoenix/wiki/SelectionViewManager-API) is similar to\n * QuickViewManager API.\n * * SelectionViews popup only once user selects a text by mouse or hover over a region with text selection.\n * * Quickviews popup on mouse hover.\n * ![image](https://user-images.githubusercontent.com/5336369/186434397-3db55789-6077-4d02-b4e2-78ef3f663399.png)\n *\n *\n * ## Usage\n * Lets build a \"hello world\" extension that displays \"hello world\" on hover over a text in the editor.\n * In your extension file, add the following code:\n * ```js\n * const QuickViewManager = brackets.getModule(\"features/QuickViewManager\");\n * // replace `all` with language ID(Eg. javascript) if you want to restrict the preview to js files only.\n * QuickViewManager.registerQuickViewProvider(exports, [\"all\"]);\n *\n * // provide a helpful name for the QuickView. This will be useful if you implement `filterQuickView` function or\n * // have to debug the quick view.\n * exports.QUICK_VIEW_NAME = \"extension.someName\";\n * // now implement the getQuickView function that will be invoked when ever user hovers over a text in the editor.\n * exports.getQuickView = function(editor, pos, token, line) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 start: {line: pos.line, ch:token.start},\n *                 end: {line: pos.line, ch:token.end},\n *                 content: \"<div>hello world</div>\"\n *             });\n *         });\n *     };\n * // optional filter quick view function to handle multiple quick views\n * exports.filterQuickView = function(popovers){\n *     // popovers will be an array of all popovers rendered by providers\n *     return popovers; // dont filter show everything in this case\n * }\n * ```\n *\n * ### How it works\n * When QuickViewManager determines that the user intents to see QuickView on hover, `getQuickView` function on all\n * registered QuickView providers are invoked to get the quick view popup. `getQuickView` should return a promise\n * that resolves to the popup contents if the provider has a quick view. Else just reject the promise. If multiple\n * providers returns QuickView, all of them are displayed stacked one by one. You can alter this behavior by\n * providing a `filterQuickView` function in the provider where you can modify what previews will be shown.\n * See detailed API docs for implementation details below:\n *\n * ## API\n * ### registerQuickViewProvider\n * Register a QuickView provider with this api.\n *\n * ```js\n * // syntax\n * QuickViewManager.registerQuickViewProvider(provider, supportedLanguages);\n * ```\n * The API requires two parameters:\n * 1. `provider`: must implement a  `getQuickView` function which will be invoked to get the preview. See API doc below.\n * 1. `supportedLanguages`: An array of languages that the QuickView supports. If `[\"all\"]` is supplied, then the\n *    QuickView will be invoked for all languages. Restrict to specific languages: Eg: `[\"javascript\", \"html\", \"php\"]`\n *\n * ```js\n * // to register a provider that will be invoked for all languages. where provider is any object that implements\n * // a getQuickView function\n * QuickViewManager.registerQuickViewProvider(provider, [\"all\"]);\n *\n * // to register a provider that will be invoked for specific languages\n * QuickViewManager.registerQuickViewProvider(provider, [\"javascript\", \"html\", \"php\"]);\n * ```\n *\n * ### removeQuickViewProvider\n * Removes a registered QuickView provider. The API takes the same arguments as `registerQuickViewProvider`.\n * ```js\n * // syntax\n * QuickViewManager.removeQuickViewProvider(provider, supportedLanguages);\n * // Example\n * QuickViewManager.removeQuickViewProvider(provider, [\"javascript\", \"html\"]);\n * ```\n *\n * ### getQuickView\n * Each provider must implement the `getQuickView` function that returns a promise. The promise either resolves with\n * the quick view details object(described below) or rejects if there is no preview for the position.\n * ```js\n * // function signature\n * provider.getQuickView = function(editor, pos, token, line) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 start: {line: pos.line, ch:token.start},\n *                 end: {line: pos.line, ch:token.end},\n *                 content: \"<div>hello world</div>\",\n *                 editsDoc: false // this is optional if the quick view edits the current doc\n *             });\n *         });\n *     };\n * ```\n *\n * #### parameters\n * The function will be called with the following arguments:\n * 1. `editor` - The editor over which the user hovers the mouse cursor.\n * 1. `pos` - the cursor position over which the user hovers.\n * 1. `token` - hovered token details\n * 1. `line` - the full line text as string.\n *\n * #### return types\n * The promise returned should resolve to an object with the following contents:\n * 1. `start` : Indicates the start cursor position from which the quick view is valid.\n * 1. `end` : Indicates the end cursor position to which the quick view is valid. These are generally used to highlight\n *    the hovered section of the text in the editor.\n * 1. `content`: Either `HTML` as text, a `DOM Node` or a `Jquery Element`.\n * 1. `editsDoc`: Optional, set to true if the quick view can edit the active document.\n *\n * #### Modifying the QuickView content after resolving `getQuickView` promise\n * Some advanced/interactive extensions may need to do dom operations on the quick view content.\n * In such cases, it is advised to return a domNode/Jquery element as content in `getQuickView`. Event Handlers\n * or further dom manipulations can be done on the returned content element.\n * The Quick view may be dismissed at any time, so be sure to check if the DOM Node is visible in the editor before\n * performing any operations.\n *\n * #### Considerations\n * 1. QuickView won't be displayed till all provider promises are settled. To improve performance, if your QuickView\n *    handler takes time to resolve the QuickView, resolve a dummy quick once you are sure that a QuickView needs\n *    to be shown to the user. The div contents can be later updated as and when more details are available.\n * 1. Note that the QuickView could be hidden/removed any time by the QuickViewManager.\n * 1. If multiple providers returns a valid popup, all of them are displayed except if the `filterQuickView` modifies\n *    the quick view render list. Note that `filterQuickView` is called only for those providers that\n *    provided a quick view.\n *\n * ### filterQuickView\n * Each provider can optionally implement the `filterQuickView` function to control what among the available\n * quick views should be rendered if multiple providers responded with a QuickView. The function will be called\n * once all `getQuickView` providers provided a valid preview object.\n * ```js\n * // function signature\n * provider.filterQuickView = function(popovers) {\n *          for(let popover of popovers){\n *             // here if we see that a quick view with name `exclusiveQuickView` is present, then we only show that\n *             // QuickView. popover.providerInfo object holds details of what provider provided the quick view.\n *             if(popover.providerInfo.provider.QUICK_VIEW_NAME === \"exclusiveQuickView\"){\n *                 return [popover]\n *             }\n *         }\n *         // if nothing is returned, then the `popovers` param will be used to show popover\n *     };\n * ```\n *\n * #### parameter\n * The function will be called with the `popovers` parameter which is an array of popover objects that was returned\n * by `getQuickView` function of all succeeded providers. Details of each provider that created a popover\n * will be present in `popovers[i].providerInfo` object.\n *\n * #### return\n * An array of popovers that needs to be rendered, or nothing(to render the original popover parameter as is).\n * @module features/QuickViewManager\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Brackets modules\n    const CommandManager    = require(\"command/CommandManager\"),\n        Commands            = require(\"command/Commands\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        Menus               = require(\"command/Menus\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        Strings             = require(\"strings\"),\n        ViewUtils           = require(\"utils/ViewUtils\"),\n        AppInit             = require(\"utils/AppInit\"),\n        WorkspaceManager    = require(\"view/WorkspaceManager\"),\n        ProviderRegistrationHandler = require(\"features/PriorityBasedRegistration\").RegistrationHandler;\n\n    const previewContainerHTML       = '<div id=\"quick-view-container\">\\n' +\n        '    <div class=\"preview-content\">\\n' +\n        '    </div>\\n' +\n        '</div>';\n\n    const _providerRegistrationHandler = new ProviderRegistrationHandler(),\n        registerQuickViewProvider = _providerRegistrationHandler.registerProvider.bind(_providerRegistrationHandler),\n        removeQuickViewProvider = _providerRegistrationHandler.removeProvider.bind(_providerRegistrationHandler);\n\n    function _getQuickViewProviders(editor, pos) {\n        let language = editor.getLanguageForPosition(pos);\n        return  _providerRegistrationHandler.getProvidersForLanguageId(language.getId());\n    }\n\n    let enabled,                             // Only show preview if true\n        prefs                      = null,   // Preferences\n        $previewContainer,                   // Preview container\n        $previewContent,                     // Preview content holder\n        _currentMousePos,\n        animationRequest,\n        quickViewLocked = false;\n\n    // Constants\n    const CMD_ENABLE_QUICK_VIEW       = \"view.enableQuickView\",\n        QUICK_VIEW_EDITOR_MARKER = 'quickViewMark',\n        // Time (ms) mouse must remain over a provider's matched text before popover appears\n        HOVER_DELAY                 = 500,\n        // Pointer height, used to shift popover above pointer (plus a little bit of space)\n        POINTER_HEIGHT              = 10,\n        POPOVER_HORZ_MARGIN         =  5;   // Horizontal margin\n\n    prefs = PreferencesManager.getExtensionPrefs(\"quickview\");\n    prefs.definePreference(\"enabled\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_QUICK_VIEW_ENABLED\n    });\n\n    /**\n     * There are three states for this var:getToken\n     * 1. If null, there is no provider result for the given mouse position.\n     * 2. If non-null, and visible==true, there is a popover currently showing.\n     * 3. If non-null, but visible==false, we're waiting for HOVER_DELAY, which\n     *    is tracked by hoverTimer. The state changes to visible==true as soon as\n     *    there is a provider. If the mouse moves before then, timer is restarted.\n     *\n     * @type {{\n     *      visible: boolean,\n     *      editor: !Editor,\n     *      hoverTimer: number,             - setTimeout() token\n     *      start: !{line, ch},             - start of matched text range\n     *      end: !{line, ch},               - end of matched text range\n     *      content: !string,               - HTML content to display in popover\n     *      xpos: number,                   - x of center of popover\n     *      ytop: number,                   - y of top of matched text (when popover placed above text, normally)\n     *      ybot: number,                   - y of bottom of matched text (when popover moved below text, avoiding window top)\n     *      marker: ?CodeMirror.TextMarker  - only set once visible==true\n     * }}\n     * @private\n     */\n    let popoverState = null;\n\n\n\n    // Popover widget management ----------------------------------------------\n\n    /**\n     * Cancels whatever popoverState was currently pending and sets it back to null. If the popover was visible,\n     * hides it; if the popover was invisible and still pending, cancels hoverTimer so it will never be shown.\n     * @private\n     */\n    function hidePreview() {\n        if (!popoverState) {\n            return;\n        }\n\n        if (popoverState.visible) {\n            popoverState.marker.clear();\n            $previewContent.empty();\n            $previewContainer.hide();\n            $previewContainer.removeClass(\"active\");\n            if(EditorManager.getActiveEditor()){\n                EditorManager.getActiveEditor().focus();\n            }\n        }\n        showPreviewQueued = false;\n        mouseInPreviewContainer = false;\n        unlockQuickView();\n        window.clearTimeout(popoverState.hoverTimer);\n        popoverState = null;\n    }\n\n    function positionPreview(editor, xpos, ypos, ybot) {\n        if ($previewContent.find(\"#quick-view-popover-root\").is(':empty')){\n            hidePreview();\n            return;\n        }\n        let previewWidth  = $previewContainer.outerWidth(),\n            top           = ypos - $previewContainer.outerHeight() - POINTER_HEIGHT,\n            left          = xpos - previewWidth / 2,\n            elementRect = {\n                top: top,\n                left: left - POPOVER_HORZ_MARGIN,\n                height: $previewContainer.outerHeight() + POINTER_HEIGHT,\n                width: previewWidth + 2 * POPOVER_HORZ_MARGIN\n            },\n            clip = ViewUtils.getElementClipSize($(editor.getRootElement()), elementRect);\n\n        // Prevent horizontal clipping\n        if (clip.left > 0) {\n            left += clip.left;\n        } else if (clip.right > 0) {\n            left -= clip.right;\n        }\n\n        // If clipped on top, flip popover below line\n        if (clip.top > 0) {\n            top = ybot + POINTER_HEIGHT;\n            $previewContainer\n                .removeClass(\"preview-bubble-above\")\n                .addClass(\"preview-bubble-below\");\n        } else {\n            $previewContainer\n                .removeClass(\"preview-bubble-below\")\n                .addClass(\"preview-bubble-above\");\n        }\n\n        $previewContainer\n            .css({\n                left: left,\n                top: top\n            })\n            .addClass(\"active\");\n    }\n\n    // Preview hide/show logic ------------------------------------------------\n\n    function _isResultBeforePopoverStart(editor, popover, result){\n        if(!popover.start){\n            return true;\n        }\n        return editor.indexFromPos(result.start) < editor.indexFromPos(popover.start);\n    }\n\n    function _isResultAfterPopoverEnd(editor, popover, result){\n        if(!popover.end){\n            return true;\n        }\n        return editor.indexFromPos(popover.start) > editor.indexFromPos(result.end);\n    }\n\n    function _createPopoverState(editor, popoverResults) {\n        if (popoverResults && popoverResults.length) {\n            let popover = {\n                content: $(\"<div id='quick-view-popover-root'></div>\")\n            };\n            // Each provider return popover { start, end, content}\n            for(let result of popoverResults){\n                if(_isResultBeforePopoverStart(editor, popover, result)){\n                    popover.start = result.start;\n                }\n                if(_isResultAfterPopoverEnd(editor, popover, result)){\n                    popover.end = result.end;\n                }\n                if(result.editsDoc){\n                    popover.editsDoc = true;\n                }\n                popover.content.append(result.content);\n            }\n\n            let startCoord = editor.charCoords(popover.start),\n                endCoord = editor.charCoords(popover.end);\n            popover.xpos = (endCoord.left - startCoord.left) / 2 + startCoord.left;\n            if(endCoord.left<startCoord.left){\n                // this probably spans multiple lines, just show at start cursor position\n                popover.xpos = startCoord.left;\n            }\n            popover.ytop = startCoord.top;\n            popover.ybot = startCoord.bottom;\n            popover.visible = false;\n            popover.editor  = editor;\n            return popover;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns a popover array with the list of popovers to be rendered after filtering from providers.\n     * @param results\n     * @param providerInfos\n     * @return {*[]}\n     * @private\n     */\n    function _getPopover(results, providerInfos) {\n        let popovers = [], fulfilledProviderInfos = [];\n        for(let i=0; i< results.length; i++){\n            let result = results[i];\n            if(result.status === \"fulfilled\" && result.value){\n                let popoverResult = result.value;\n                popoverResult.providerInfo = providerInfos[i];\n                fulfilledProviderInfos.push(providerInfos[i]);\n                popovers.push(popoverResult);\n            }\n        }\n\n        // filterQuickView is called only for those providers that provided a quick view.\n        for(let providerInfo of fulfilledProviderInfos){\n            let provider = providerInfo.provider;\n            if(provider.filterQuickView){\n                popovers = provider.filterQuickView(popovers) || popovers;\n            }\n        }\n\n        return popovers;\n    }\n\n    /**\n     * Returns a 'ready for use' popover state object:\n     * { visible: false, editor, start, end, content, ?onShow, xpos, ytop, ybot }\n     * Lacks only hoverTimer (supplied by handleMouseMove()) and marker (supplied by showPreview()).\n     * @private\n     */\n    async function queryPreviewProviders(editor, pos, token) {\n        let line = editor.document.getLine(pos.line);\n        let providerInfos = _getQuickViewProviders(editor, pos);\n        let providerPromises = [], activeProviderInfos = [];\n        for(let providerInfo of providerInfos){\n            let provider = providerInfo.provider;\n            if(!provider.getQuickView){\n                console.error(\"Quickview provider does not implement the required getQuickView function\", provider);\n                continue;\n            }\n            providerPromises.push(provider.getQuickView(editor, pos, token, line));\n            activeProviderInfos.push(providerInfo);\n        }\n        let results = await Promise.allSettled(providerPromises);\n\n        return _createPopoverState(editor, _getPopover(results, activeProviderInfos));\n    }\n\n    /**\n     * Changes the current hidden popoverState to visible, showing it in the UI and highlighting\n     * its matching text in the editor.\n     * @private\n     */\n    function _renderPreview(editor) {\n        if (popoverState && popoverState.start && popoverState.end) {\n            popoverState.marker = editor.markText(\n                QUICK_VIEW_EDITOR_MARKER,\n                popoverState.start,\n                popoverState.end,\n                {className: \"quick-view-highlight\"}\n            );\n\n            let $popoverContent = $(popoverState.content);\n            $previewContent.append($popoverContent);\n            $previewContainer.show();\n            popoverState.visible = true;\n            positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n\n            $popoverContent[0].addEventListener('DOMSubtreeModified', ()=>{\n                positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n            }, false);\n        }\n    }\n\n    let currentQueryID = 0;\n    async function showPreview(editor) {\n        let token;\n\n        // Figure out which editor we are over\n        if (!editor) {\n            editor = EditorManager.getHoveredEditor(_currentMousePos);\n        }\n\n        if (!editor) {\n            hidePreview();\n            return;\n        }\n\n        // Find char mouse is over\n        let pos = editor.coordsChar({left: _currentMousePos.clientX, top: _currentMousePos.clientY});\n\n        // No preview if mouse is past last char on line\n        if (pos.ch >= editor.document.getLine(pos.line).length) {\n            return;\n        }\n\n        // Query providers and append to popoverState\n        token = editor.getToken(pos);\n        currentQueryID++;\n        let savedQueryId = currentQueryID;\n        popoverState = await queryPreviewProviders(editor, pos, token);\n        if(savedQueryId === currentQueryID){\n            // this is to prevent race conditions. For Eg., if the preview provider takes time to generate a preview,\n            // another query might have happened while the last query is still in progress. So we only render the most\n            // recent QueryID\n            _renderPreview(editor);\n        }\n    }\n\n    function _isMouseFarFromPopup() {\n        const previewRect = $previewContainer[0].getBoundingClientRect();\n        const docRect = {\n            height: $(document).height(),\n            width: $(document).width()\n        };\n        const thresholdPercent = 5;\n        function _isDistanceExceedThreshold(smaller, larger, total, threshold) {\n            return ((larger - smaller)/total)*100 > threshold;\n        }\n        let x= _currentMousePos.clientX, y=_currentMousePos.clientY;\n        if((x<previewRect.left && _isDistanceExceedThreshold(x, previewRect.left, docRect.width, thresholdPercent))\n            ||(x>previewRect.right && _isDistanceExceedThreshold(previewRect.right, x, docRect.width, thresholdPercent))\n            ||(y<previewRect.top && _isDistanceExceedThreshold(y, previewRect.top, docRect.height, thresholdPercent))\n            ||(y>previewRect.bottom && _isDistanceExceedThreshold(previewRect.bottom, y, docRect.height, thresholdPercent))){\n            return true;\n        }\n        return false;\n    }\n\n    let showPreviewQueued = false;\n\n    function processMouseMove() {\n        animationRequest = null;\n\n        if (mouseInPreviewContainer || quickViewLocked) {\n            return;\n        }\n\n        let editor = null;\n\n        if (popoverState && popoverState.visible) {\n            // Only figure out which editor we are over when there is already a popover\n            // showing (otherwise wait until after delay to minimize processing)\n            editor = EditorManager.getHoveredEditor(_currentMousePos);\n            if (editor) {\n                // Find char mouse is over\n                let pos = editor.coordsChar({left: _currentMousePos.clientX, top: _currentMousePos.clientY});\n                if (popoverState.start && popoverState.end &&\n                        editor.posWithinRange(pos, popoverState.start, popoverState.end, true) &&\n                        (pos.ch < editor.document.getLine(pos.line).length)) {\n\n                    // That one's still relevant - nothing more to do\n                    // Note: posWithinRange() includes mouse past end of line, so need to check for that case\n                    return;\n                }\n                if(_isMouseFarFromPopup()){\n                    hidePreview();\n                    return;\n                }\n            }\n        }\n\n        if(!showPreviewQueued){\n            // Initialize popoverState\n            showPreviewQueued = true;\n            popoverState = popoverState || {};\n\n            // Set timer to scan and show. This will get cancelled (in hidePreview())\n            // if mouse movement rendered this popover inapplicable before timer fires.\n            // When showing \"immediately\", still use setTimeout() to make this async\n            // so we return from this mousemove event handler ASAP.\n            popoverState.hoverTimer = window.setTimeout(function () {\n                showPreviewQueued = false;\n                if(!mouseInPreviewContainer && !quickViewLocked){\n                    hidePreview();\n                    popoverState = {};\n                    showPreview(editor);\n                }\n            }, HOVER_DELAY);\n        }\n    }\n\n    function handleMouseMove(event) {\n        // Keep track of mouse position\n        _currentMousePos = {\n            clientX: event.clientX,\n            clientY: event.clientY\n        };\n\n        if (!enabled || quickViewLocked\n            || $previewContainer[0].contains(window.document.activeElement)) {\n            // activeElement check as, if the popup has an active element, say a text input, user may\n            // move the mouse outside popup to type in the input, in which case we should not close popup.\n            return;\n        }\n\n        if (event.buttons !== 0 && !mouseInPreviewContainer) {\n            // Button is down - don't show popovers while dragging\n            hidePreview();\n            return;\n        }\n\n        // Prevent duplicate animation frame requests\n        if (!animationRequest) {\n            animationRequest = window.requestAnimationFrame(processMouseMove);\n        }\n    }\n\n    function docChanged() {\n        if(popoverState && !popoverState.editsDoc){\n            hidePreview();\n        }\n    }\n\n    function onActiveEditorChange(event, current, previous) {\n        // Hide preview when editor changes\n        hidePreview();\n\n        if (previous && previous.document) {\n            previous.document.off(\"change\", docChanged);\n        }\n\n        if (current && current.document) {\n            current.document.on(\"change\", docChanged);\n        }\n    }\n\n    // Menu command handlers\n    function updateMenuItemCheckmark() {\n        CommandManager.get(CMD_ENABLE_QUICK_VIEW).setChecked(enabled);\n    }\n\n    let mouseInPreviewContainer = false;\n    function mouseOut(_evt) {\n        setTimeout(()=>{\n            if(mouseInPreviewContainer || $previewContainer[0].contains(_evt.toElement) || quickViewLocked){\n                return;\n            }\n            hidePreview();\n        }, HOVER_DELAY);\n    }\n\n    function _mouseEnteredPreviewContainer() {\n        mouseInPreviewContainer = true;\n    }\n\n    function _mouseExitedPreviewContainer() {\n        mouseInPreviewContainer = false;\n    }\n\n    function setEnabled(_enabled, doNotSave) {\n        if (enabled !== _enabled) {\n            enabled = _enabled;\n            let editorHolder = $(\"#editor-holder\")[0];\n            let previewContainer = $previewContainer[0];\n            if (enabled) {\n                // Note: listening to \"scroll\" also catches text edits, which bubble a scroll\n                // event up from the hidden text area. This means\n                // we auto-hide on text edit, which is probably actually a good thing.\n                editorHolder.addEventListener(\"mousemove\", handleMouseMove, true);\n                editorHolder.addEventListener(\"scroll\", hidePreview, true);\n                editorHolder.addEventListener(\"mouseout\", mouseOut, true);\n                previewContainer.addEventListener(\"mouseover\", _mouseEnteredPreviewContainer, true);\n                previewContainer.addEventListener(\"mouseout\", _mouseExitedPreviewContainer, true);\n\n                // Setup doc \"change\" listener\n                onActiveEditorChange(null, EditorManager.getActiveEditor(), null);\n                EditorManager.on(\"activeEditorChange\", onActiveEditorChange);\n\n            } else {\n                editorHolder.removeEventListener(\"mousemove\", handleMouseMove, true);\n                editorHolder.removeEventListener(\"scroll\", hidePreview, true);\n                editorHolder.removeEventListener(\"mouseout\", mouseOut, true);\n                previewContainer.removeEventListener(\"mouseover\", _mouseEnteredPreviewContainer, true);\n                previewContainer.removeEventListener(\"mouseout\", _mouseExitedPreviewContainer, true);\n\n\n                // Cleanup doc \"change\" listener\n                onActiveEditorChange(null, null, EditorManager.getActiveEditor());\n                EditorManager.off(\"activeEditorChange\", onActiveEditorChange);\n\n                hidePreview();\n            }\n            if (!doNotSave) {\n                prefs.set(\"enabled\", enabled);\n                prefs.save();\n            }\n        }\n        // Always update the checkmark, even if the enabled flag hasn't changed.\n        updateMenuItemCheckmark();\n    }\n\n    function toggleEnableQuickView() {\n        let enableQuickView = !enabled;\n        if(!enableQuickView){\n            unlockQuickView();\n        }\n        setEnabled(enableQuickView);\n    }\n\n    function _forceShow(popover) {\n        hidePreview();\n        _currentMousePos = {\n            clientX: popover.xpos,\n            clientY: Math.floor((popover.ybot + popover.ytop) / 2)\n        };\n        popoverState = popover;\n        _renderPreview(popover.editor);\n    }\n\n    function _handleEscapeKeyEvent(event) {\n        if(isQuickViewShown()){\n            hidePreview();\n            event.preventDefault();\n            event.stopPropagation();\n            return true;\n        }\n        return false;\n    }\n\n    AppInit.appReady(function () {\n        // Create the preview container\n        $previewContainer = $(previewContainerHTML).appendTo($(\"body\"));\n        $previewContent = $previewContainer.find(\".preview-content\");\n\n        // Register command\n        // Insert menu at specific pos since this may load before OR after code folding extension\n        CommandManager.register(Strings.CMD_ENABLE_QUICK_VIEW, CMD_ENABLE_QUICK_VIEW, toggleEnableQuickView);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(\n            CMD_ENABLE_QUICK_VIEW, null, Menus.AFTER, Commands.VIEW_TOGGLE_INSPECTION);\n\n        // Setup initial UI state\n        setEnabled(prefs.get(\"enabled\"), true);\n\n        prefs.on(\"change\", \"enabled\", function () {\n            setEnabled(prefs.get(\"enabled\"), true);\n        });\n\n        WorkspaceManager.addEscapeKeyEventHandler(\"quickView\", _handleEscapeKeyEvent);\n    });\n\n    /**\n     * If quickview is displayed and visible on screen\n     * @return {boolean}\n     * @type {function}\n     */\n    function isQuickViewShown() {\n        return (popoverState && popoverState.visible) || false;\n    }\n\n    /**\n     * locks the current QuickView if shown to be permanently displayed on screen till the `unlockQuickView` function\n     * is called or document changes.\n     *\n     * @type {function}\n     */\n    function lockQuickView() {\n        if(isQuickViewShown()){\n            quickViewLocked = true;\n        }\n    }\n\n    /**\n     * unlocks the current QuickView locked by `lockQuickView` fucntion.\n     *\n     * @type {function}\n     */\n    function unlockQuickView() {\n        quickViewLocked = false;\n    }\n\n    // For unit testing\n    exports._queryPreviewProviders  = queryPreviewProviders;\n    exports._forceShow              = _forceShow;\n\n    exports.registerQuickViewProvider = registerQuickViewProvider;\n    exports.removeQuickViewProvider   = removeQuickViewProvider;\n    exports.isQuickViewShown = isQuickViewShown;\n    exports.lockQuickView = lockQuickView;\n    exports.unlockQuickView = unlockQuickView;\n});\n"],"file":"QuickViewManager.js"}
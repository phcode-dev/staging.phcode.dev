{"version":3,"sources":["extensibility/Package.js"],"names":["define","require","exports","module","AppInit","FileSystem","FileUtils","StringUtils","Strings","ExtensionLoader","NodeConnection","PreferencesManager","PathUtils","definePreference","undefined","description","DESCRIPTION_PROXY","PREF_EXTENSIONS_DEFAULT_DISABLED","DESCRIPTION_DISABLED_DEFAULT_EXTENSIONS","Errors","ERROR_LOADING","MALFORMED_URL","UNSUPPORTED_PROTOCOL","InstallationStatuses","FAILED","INSTALLED","ALREADY_INSTALLED","SAME_VERSION","OLDER_VERSION","NEEDS_UPDATE","DISABLED","_nodeConnection","_nodeConnectionDeferred","$","Deferred","_uniqueId","_extensionManagerCall","callback","domains","extensionManager","reject","promise","validate","path","options","d","proxy","get","done","result","resolve","errors","metadata","fail","error","install","nameHint","_doUpdate","destinationDirectory","getUserExtensionPath","disabledDirectory","replace","systemDirectory","getNativeBracketsDirectoryPath","operation","systemExtensionDirectory","apiVersion","brackets","keepFile","installationStatus","loadExtension","name","baseUrl","convertWindowsPathToUnixPath","installedTo","then","githubURLFilter","urlInfo","parsed","hostname","match","exec","pathname","url","filenameHint","download","downloadId","parseUrl","protocol","filename","r","downloadFile","localPath","err","cancelDownload","abortDownload","installFromPath","length","disabledReason","installFromURL","STATE_DOWNLOADING","STATE_INSTALLING","STATE_SUCCEEDED","STATE_FAILED","state","downloadResult","getFileForPath","unlink","cancel","formatError","localize","key","console","log","UNKNOWN_ERROR","Array","isArray","format","apply","window","remove","toggleDefaultExtension","enabled","arr","io","indexOf","splice","push","set","disable","file","defaultExtensionPath","getDefaultExtensionPath","fullPath","write","enable","afterEnable","getBaseName","installUpdate","_getNodeConnectionDeferred","appReady","connect","domainPath","getNativeModuleDirectoryPath","loadDomains","arguments"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\n/**\n * Functions for working with extension packages\n */\ndefine(function (require, exports, module) {\n\n\n    var AppInit              = require(\"utils/AppInit\"),\n        FileSystem           = require(\"filesystem/FileSystem\"),\n        FileUtils            = require(\"file/FileUtils\"),\n        StringUtils          = require(\"utils/StringUtils\"),\n        Strings              = require(\"strings\"),\n        ExtensionLoader      = require(\"utils/ExtensionLoader\"),\n        NodeConnection       = require(\"utils/NodeConnection\"),\n        PreferencesManager   = require(\"preferences/PreferencesManager\"),\n        PathUtils            = require(\"thirdparty/path-utils/path-utils\");\n\n    PreferencesManager.definePreference(\"proxy\", \"string\", undefined, {\n        description: Strings.DESCRIPTION_PROXY\n    });\n\n    var PREF_EXTENSIONS_DEFAULT_DISABLED = \"extensions.default.disabled\";\n    PreferencesManager.definePreference(PREF_EXTENSIONS_DEFAULT_DISABLED, \"array\", [], {\n        description: Strings.DESCRIPTION_DISABLED_DEFAULT_EXTENSIONS\n    });\n\n    var Errors = {\n        ERROR_LOADING: \"ERROR_LOADING\",\n        MALFORMED_URL: \"MALFORMED_URL\",\n        UNSUPPORTED_PROTOCOL: \"UNSUPPORTED_PROTOCOL\"\n    };\n\n    var InstallationStatuses = {\n        FAILED: \"FAILED\",\n        INSTALLED: \"INSTALLED\",\n        ALREADY_INSTALLED: \"ALREADY_INSTALLED\",\n        SAME_VERSION: \"SAME_VERSION\",\n        OLDER_VERSION: \"OLDER_VERSION\",\n        NEEDS_UPDATE: \"NEEDS_UPDATE\",\n        DISABLED: \"DISABLED\"\n    };\n\n    /**\n     * @private\n     * @type {NodeConnection}\n     * Connects to ExtensionManagerDomain\n     */\n    var _nodeConnection;\n\n    /**\n     * @private\n     * @type {jQuery.Deferred.<NodeConnection>}\n     * A deferred which is resolved with a NodeConnection or rejected if\n     * we are unable to connect to Node.\n     */\n    var _nodeConnectionDeferred = $.Deferred();\n\n    /**\n     * @type {number} Used to generate unique download ids\n     */\n    var _uniqueId = 0;\n\n    function _extensionManagerCall(callback) {\n        if (_nodeConnection.domains.extensionManager) {\n            return callback(_nodeConnection.domains.extensionManager);\n        }\n        return new $.Deferred().reject(\"extensionManager domain is undefined\").promise();\n\n    }\n\n    /**\n     * TODO: can this go away now that we never call it directly?\n     *\n     * Validates the package at the given path. The actual validation is\n     * handled by the Node server.\n     *\n     * The promise is resolved with an object:\n     * { errors: Array.<{string}>, metadata: { name:string, version:string, ... } }\n     * metadata is pulled straight from package.json and will be undefined\n     * if there are errors or null if the extension did not include package.json.\n     *\n     * @param {string} Absolute path to the package zip file\n     * @param {{requirePackageJSON: ?boolean}} validation options\n     * @return {$.Promise} A promise that is resolved with information about the package\n     */\n    function validate(path, options) {\n        return _extensionManagerCall(function (extensionManager) {\n            var d = new $.Deferred();\n\n            // make sure proxy is attached to options before calling validate\n            // so npm can use it in the domain\n            options = options || {};\n            options.proxy = PreferencesManager.get(\"proxy\");\n\n            extensionManager.validate(path, options)\n                .done(function (result) {\n                    d.resolve({\n                        errors: result.errors,\n                        metadata: result.metadata\n                    });\n                })\n                .fail(function (error) {\n                    d.reject(error);\n                });\n\n            return d.promise();\n        });\n    }\n\n    /**\n     * Validates and installs the package at the given path. Validation and\n     * installation is handled by the Node process.\n     *\n     * The extension will be installed into the user's extensions directory.\n     * If the user already has the extension installed, it will instead go\n     * into their disabled extensions directory.\n     *\n     * The promise is resolved with an object:\n     * { errors: Array.<{string}>, metadata: { name:string, version:string, ... },\n     * disabledReason:string, installedTo:string, commonPrefix:string }\n     * metadata is pulled straight from package.json and is likely to be undefined\n     * if there are errors. It is null if there was no package.json.\n     *\n     * disabledReason is either null or the reason the extension was installed disabled.\n     *\n     * @param {string} path Absolute path to the package zip file\n     * @param {?string} nameHint Hint for the extension folder's name (used in favor of\n     *          path's filename if present, and if no package metadata present).\n     * @param {?boolean} _doUpdate private argument used to signal an update\n     * @return {$.Promise} A promise that is resolved with information about the package\n     *          (which may include errors, in which case the extension was disabled), or\n     *          rejected with an error object.\n     */\n    function install(path, nameHint, _doUpdate) {\n        return _extensionManagerCall(function (extensionManager) {\n            var d                       = new $.Deferred(),\n                destinationDirectory    = ExtensionLoader.getUserExtensionPath(),\n                disabledDirectory       = destinationDirectory.replace(/\\/user$/, \"/disabled\"),\n                systemDirectory         = FileUtils.getNativeBracketsDirectoryPath() + \"/extensions/default/\";\n\n            var operation = _doUpdate ? \"update\" : \"install\";\n            extensionManager[operation](path, destinationDirectory, {\n                disabledDirectory: disabledDirectory,\n                systemExtensionDirectory: systemDirectory,\n                apiVersion: brackets.metadata.apiVersion,\n                nameHint: nameHint,\n                proxy: PreferencesManager.get(\"proxy\")\n            })\n                .done(function (result) {\n                    result.keepFile = false;\n\n                    if (result.installationStatus !== InstallationStatuses.INSTALLED || _doUpdate) {\n                        d.resolve(result);\n                    } else {\n                        // This was a new extension and everything looked fine.\n                        // We load it into Brackets right away.\n                        ExtensionLoader.loadExtension(result.name, {\n                            // On Windows, it looks like Node converts Unix-y paths to backslashy paths.\n                            // We need to convert them back.\n                            baseUrl: FileUtils.convertWindowsPathToUnixPath(result.installedTo)\n                        }, \"main\").then(function () {\n                            d.resolve(result);\n                        }, function () {\n                            d.reject(Errors.ERROR_LOADING);\n                        });\n                    }\n                })\n                .fail(function (error) {\n                    d.reject(error);\n                });\n\n            return d.promise();\n        });\n    }\n\n\n\n    /**\n     * Special case handling to make the common case of downloading from GitHub easier; modifies 'urlInfo' as\n     * needed. Converts a bare GitHub repo URL to the corresponding master ZIP URL; or if given a direct\n     * master ZIP URL already, sets a nicer download filename (both cases use the repo name).\n     *\n     * @param {{url:string, parsed:Array.<string>, filenameHint:string}} urlInfo\n     */\n    function githubURLFilter(urlInfo) {\n        if (urlInfo.parsed.hostname === \"github.com\" || urlInfo.parsed.hostname === \"www.github.com\") {\n            // Is it a URL to the root of a repo? (/user/repo)\n            var match = /^\\/[^\\/?]+\\/([^\\/?]+)(\\/?)$/.exec(urlInfo.parsed.pathname);\n            if (match) {\n                if (!match[2]) {\n                    urlInfo.url += \"/\";\n                }\n                urlInfo.url += \"archive/master.zip\";\n                urlInfo.filenameHint = match[1] + \".zip\";\n\n            } else {\n                // Is it a URL directly to the repo's 'master.zip'? (/user/repo/archive/master.zip)\n                match = /^\\/[^\\/?]+\\/([^\\/?]+)\\/archive\\/master.zip$/.exec(urlInfo.parsed.pathname);\n                if (match) {\n                    urlInfo.filenameHint = match[1] + \".zip\";\n                }\n            }\n        }\n    }\n\n    /**\n     * Downloads from the given URL to a temporary location. On success, resolves with the path of the\n     * downloaded file (typically in a temp folder) and a hint for the real filename. On failure, rejects\n     * with an error object.\n     *\n     * @param {string} url URL of the file to be downloaded\n     * @param {number} downloadId Unique number to identify this request\n     * @return {$.Promise}\n     */\n    function download(url, downloadId) {\n        return _extensionManagerCall(function (extensionManager) {\n            var d = new $.Deferred();\n\n            // Validate URL\n            // TODO: PathUtils fails to parse URLs that are missing the protocol part (e.g. starts immediately with \"www...\")\n            var parsed = PathUtils.parseUrl(url);\n            if (!parsed.hostname) {  // means PathUtils failed to parse at all\n                d.reject(Errors.MALFORMED_URL);\n                return d.promise();\n            }\n            if (parsed.protocol !== \"http:\" && parsed.protocol !== \"https:\") {\n                d.reject(Errors.UNSUPPORTED_PROTOCOL);\n                return d.promise();\n            }\n\n            var urlInfo = { url: url, parsed: parsed, filenameHint: parsed.filename };\n            githubURLFilter(urlInfo);\n\n            // Decide download destination\n            var filename = urlInfo.filenameHint;\n            filename = filename.replace(/[^a-zA-Z0-9_\\- \\(\\)\\.]/g, \"_\"); // make sure it's a valid filename\n            if (!filename) {  // in case of URL ending in \"/\"\n                filename = \"extension.zip\";\n            }\n\n            // Download the bits (using Node since brackets-shell doesn't support binary file IO)\n            var r = extensionManager.downloadFile(downloadId, urlInfo.url, PreferencesManager.get(\"proxy\"));\n            r.done(function (result) {\n                d.resolve({ localPath: FileUtils.convertWindowsPathToUnixPath(result), filenameHint: urlInfo.filenameHint });\n            }).fail(function (err) {\n                d.reject(err);\n            });\n\n            return d.promise();\n        });\n    }\n\n    /**\n     * Attempts to synchronously cancel the given pending download. This may not be possible, e.g.\n     * if the download has already finished.\n     *\n     * @param {number} downloadId Identifier previously passed to download()\n     */\n    function cancelDownload(downloadId) {\n        return _extensionManagerCall(function (extensionManager) {\n            return extensionManager.abortDownload(downloadId);\n        });\n    }\n\n    /**\n     * On success, resolves with an extension metadata object; at that point, the extension has already\n     * started running in Brackets. On failure (including validation errors), rejects with an error object.\n     *\n     * An error object consists of either a string error code OR an array where the first entry is the error\n     * code and the remaining entries are further info. The error code string is one of either\n     * ExtensionsDomain.Errors or Package.Errors. Use formatError() to convert an error object to a friendly,\n     * localized error message.\n     *\n     * @param {string} path Absolute path to the package zip file\n     * @param {?string} filenameHint Hint for the extension folder's name (used in favor of\n     *          path's filename if present, and if no package metadata present).\n     * @return {$.Promise} A promise that is rejected if there are errors during\n     *          install or the extension is disabled.\n     */\n    function installFromPath(path, filenameHint) {\n        var d = new $.Deferred();\n\n        install(path, filenameHint)\n            .done(function (result) {\n                result.keepFile = true;\n\n                var installationStatus = result.installationStatus;\n                if (installationStatus === InstallationStatuses.ALREADY_INSTALLED ||\n                        installationStatus === InstallationStatuses.NEEDS_UPDATE ||\n                        installationStatus === InstallationStatuses.SAME_VERSION ||\n                        installationStatus === InstallationStatuses.OLDER_VERSION) {\n                    d.resolve(result);\n                } else {\n                    if (result.errors && result.errors.length > 0) {\n                        // Validation errors - for now, only return the first one\n                        d.reject(result.errors[0]);\n                    } else if (result.disabledReason) {\n                        // Extension valid but left disabled (wrong API version, extension name collision, etc.)\n                        d.reject(result.disabledReason);\n                    } else {\n                        // Success! Extension is now running in Brackets\n                        d.resolve(result);\n                    }\n                }\n            })\n            .fail(function (err) {\n                d.reject(err);\n            });\n\n        return d.promise();\n    }\n\n    /**\n     * On success, resolves with an extension metadata object; at that point, the extension has already\n     * started running in Brackets. On failure (including validation errors), rejects with an error object.\n     *\n     * An error object consists of either a string error code OR an array where the first entry is the error\n     * code and the remaining entries are further info. The error code string is one of either\n     * ExtensionsDomain.Errors or Package.Errors. Use formatError() to convert an error object to a friendly,\n     * localized error message.\n     *\n     * The returned cancel() function will *attempt* to cancel installation, but it is not guaranteed to\n     * succeed. If cancel() succeeds, the Promise is rejected with a CANCELED error code. If we're unable\n     * to cancel, the Promise is resolved or rejected normally, as if cancel() had never been called.\n     *\n     * @return {{promise: $.Promise, cancel: function():boolean}}\n     */\n    function installFromURL(url) {\n        var STATE_DOWNLOADING = 1,\n            STATE_INSTALLING = 2,\n            STATE_SUCCEEDED = 3,\n            STATE_FAILED = 4;\n\n        var d = new $.Deferred();\n        var state = STATE_DOWNLOADING;\n\n        var downloadId = (_uniqueId++);\n        download(url, downloadId)\n            .done(function (downloadResult) {\n                state = STATE_INSTALLING;\n\n                installFromPath(downloadResult.localPath, downloadResult.filenameHint)\n                    .done(function (result) {\n                        var installationStatus = result.installationStatus;\n\n                        state = STATE_SUCCEEDED;\n                        result.localPath = downloadResult.localPath;\n                        result.keepFile = false;\n\n                        if (installationStatus === InstallationStatuses.INSTALLED) {\n                            // Delete temp file\n                            FileSystem.getFileForPath(downloadResult.localPath).unlink();\n                        }\n\n                        d.resolve(result);\n                    })\n                    .fail(function (err) {\n                        // File IO errors, internal error in install()/validate(), or extension startup crashed\n                        state = STATE_FAILED;\n                        FileSystem.getFileForPath(downloadResult.localPath).unlink();\n                        d.reject(err);  // TODO: needs to be err.message ?\n                    });\n            })\n            .fail(function (err) {\n                // Download error (the Node-side download code cleans up any partial ZIP file)\n                state = STATE_FAILED;\n                d.reject(err);\n            });\n\n        return {\n            promise: d.promise(),\n            cancel: function () {\n                if (state === STATE_DOWNLOADING) {\n                    // This will trigger download()'s fail() handler with CANCELED as the err code\n                    cancelDownload(downloadId);\n                }\n                // Else it's too late to cancel; we'll continue on through the done() chain and emit\n                // a success result (calling done() handlers) if all else goes well.\n            }\n        };\n    }\n\n    /**\n     * Converts an error object as returned by install(), installFromPath() or\n     * installFromURL() into a flattened, localized string.\n     *\n     * @param {string|Array.<string>} error\n     * @return {string}\n     */\n    function formatError(error) {\n        function localize(key) {\n            if (Strings[key]) {\n                return Strings[key];\n            }\n            console.log(\"Unknown installation error\", key);\n            return Strings.UNKNOWN_ERROR;\n        }\n\n        if (Array.isArray(error)) {\n            error[0] = localize(error[0]);\n            return StringUtils.format.apply(window, error);\n        }\n        return localize(error);\n\n    }\n\n    /**\n     * Removes the extension at the given path.\n     *\n     * @param {string} path The absolute path to the extension to remove.\n     * @return {$.Promise} A promise that's resolved when the extension is removed, or\n     *     rejected if there was an error.\n     */\n    function remove(path) {\n        return _extensionManagerCall(function (extensionManager) {\n            return extensionManager.remove(path);\n        });\n    }\n\n    /**\n     * This function manages the PREF_EXTENSIONS_DEFAULT_DISABLED preference\n     * holding an array of default extension paths that should not be loaded\n     * on Brackets startup\n     */\n    function toggleDefaultExtension(path, enabled) {\n        var arr = PreferencesManager.get(PREF_EXTENSIONS_DEFAULT_DISABLED);\n        if (!Array.isArray(arr)) { arr = []; }\n        var io = arr.indexOf(path);\n        if (enabled === true && io !== -1) {\n            arr.splice(io, 1);\n        } else if (enabled === false && io === -1) {\n            arr.push(path);\n        }\n        PreferencesManager.set(PREF_EXTENSIONS_DEFAULT_DISABLED, arr);\n    }\n\n    /**\n     * Disables the extension at the given path.\n     *\n     * @param {string} path The absolute path to the extension to disable.\n     * @return {$.Promise} A promise that's resolved when the extenion is disabled, or\n     *      rejected if there was an error.\n     */\n    function disable(path) {\n        var result = new $.Deferred(),\n            file = FileSystem.getFileForPath(path + \"/.disabled\");\n\n        var defaultExtensionPath = ExtensionLoader.getDefaultExtensionPath();\n        if (file.fullPath.indexOf(defaultExtensionPath) === 0) {\n            toggleDefaultExtension(path, false);\n            result.resolve();\n            return result.promise();\n        }\n\n        file.write(\"\", function (err) {\n            if (err) {\n                return result.reject(err);\n            }\n            result.resolve();\n        });\n        return result.promise();\n    }\n\n    /**\n     * Enables the extension at the given path.\n     *\n     * @param {string} path The absolute path to the extension to enable.\n     * @return {$.Promise} A promise that's resolved when the extenion is enable, or\n     *      rejected if there was an error.\n     */\n    function enable(path) {\n        var result = new $.Deferred(),\n            file = FileSystem.getFileForPath(path + \"/.disabled\");\n\n        function afterEnable() {\n            ExtensionLoader.loadExtension(FileUtils.getBaseName(path), { baseUrl: path }, \"main\")\n                .done(result.resolve)\n                .fail(result.reject);\n        }\n\n        var defaultExtensionPath = ExtensionLoader.getDefaultExtensionPath();\n        if (file.fullPath.indexOf(defaultExtensionPath) === 0) {\n            toggleDefaultExtension(path, true);\n            afterEnable();\n            return result.promise();\n        }\n\n        file.unlink(function (err) {\n            if (err) {\n                return result.reject(err);\n            }\n            afterEnable();\n        });\n        return result.promise();\n    }\n\n    /**\n     * Install an extension update located at path.\n     * This assumes that the installation was previously attempted\n     * and an installationStatus of \"ALREADY_INSTALLED\", \"NEEDS_UPDATE\", \"SAME_VERSION\",\n     * or \"OLDER_VERSION\" was the result.\n     *\n     * This workflow ensures that there should not generally be validation errors\n     * because the first pass at installation the extension looked at the metadata\n     * and installed packages.\n     *\n     * @param {string} path to package file\n     * @param {?string} nameHint Hint for the extension folder's name (used in favor of\n     *          path's filename if present, and if no package metadata present).\n     * @return {$.Promise} A promise that is resolved when the extension is successfully\n     *      installed or rejected if there is a problem.\n     */\n    function installUpdate(path, nameHint) {\n        var d = new $.Deferred();\n        install(path, nameHint, true)\n            .done(function (result) {\n                if (result.installationStatus !== InstallationStatuses.INSTALLED) {\n                    d.reject(result.errors);\n                } else {\n                    d.resolve(result);\n                }\n            })\n            .fail(function (error) {\n                d.reject(error);\n            });\n        return d.promise();\n    }\n\n    /**\n     * Allows access to the deferred that manages the node connection. This\n     * is *only* for unit tests. Messing with this not in testing will\n     * potentially break everything.\n     *\n     * @private\n     * @return {jQuery.Deferred} The deferred that manages the node connection\n     */\n    function _getNodeConnectionDeferred() {\n        return _nodeConnectionDeferred;\n    }\n\n    // Initializes node connection\n    // TODO: duplicates code from StaticServer\n    // TODO: can this be done lazily?\n    AppInit.appReady(function () {\n        _nodeConnection = new NodeConnection();\n        _nodeConnection.connect(true).then(function () {\n            var domainPath = FileUtils.getNativeBracketsDirectoryPath() + \"/\" + FileUtils.getNativeModuleDirectoryPath(module) + \"/node/ExtensionManagerDomain\";\n\n            _nodeConnection.loadDomains(domainPath, true)\n                .then(\n                    function () {\n                        _nodeConnectionDeferred.resolve();\n                    },\n                    function () { // Failed to connect\n                        console.error(\"[Extensions] Failed to connect to node\", arguments);\n                        _nodeConnectionDeferred.reject();\n                    }\n                );\n        });\n    });\n\n    // For unit tests only\n    exports._getNodeConnectionDeferred = _getNodeConnectionDeferred;\n\n    exports.installFromURL          = installFromURL;\n    exports.installFromPath         = installFromPath;\n    exports.validate                = validate;\n    exports.install                 = install;\n    exports.remove                  = remove;\n    exports.disable                 = disable;\n    exports.enable                  = enable;\n    exports.installUpdate           = installUpdate;\n    exports.formatError             = formatError;\n    exports.InstallationStatuses    = InstallationStatuses;\n});\n"],"file":"Package.js"}
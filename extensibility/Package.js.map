{"version":3,"sources":["extensibility/Package.js"],"names":["define","require","exports","module","AppInit","FileSystem","FileUtils","StringUtils","Strings","ExtensionLoader","PreferencesManager","PathUtils","ExtensionDownloader","definePreference","undefined","description","DESCRIPTION_PROXY","DISABLED_EXTENSIONS_KEY","Errors","ERROR_LOADING","MALFORMED_URL","UNSUPPORTED_PROTOCOL","InstallationStatuses","FAILED","INSTALLED","ALREADY_INSTALLED","SAME_VERSION","OLDER_VERSION","NEEDS_UPDATE","DISABLED","_uniqueId","install","path","nameHint","_doUpdate","d","$","Deferred","destinationDirectory","getUserExtensionPath","disabledDirectory","replace","systemDirectory","getNativeBracketsDirectoryPath","operation","systemExtensionDirectory","apiVersion","brackets","metadata","proxy","get","done","result","installationStatus","resolve","loadExtension","name","baseUrl","window","Phoenix","VFS","getVirtualServingURLForPath","installedTo","then","reject","fail","error","promise","githubURLFilter","urlInfo","parsed","hostname","match","exec","pathname","url","filenameHint","_download","downloadId","parseUrl","protocol","filename","convertWindowsPathToUnixPath","r","downloadFile","localPath","err","cancelDownload","abortDownload","installFromPath","errors","length","disabledReason","installFromURL","STATE_DOWNLOADING","STATE_INSTALLING","STATE_SUCCEEDED","STATE_FAILED","state","downloadResult","getFileForPath","unlink","startsWith","config","extension_url","logger","reportError","cancel","formatError","localize","key","console","log","UNKNOWN_ERROR","Array","isArray","format","apply","remove","_toggleDisabledExtension","enabled","arr","JSON","parse","PhStore","getItem","io","indexOf","splice","push","setItem","stringify","disable","enable","getBaseName","installUpdate","appReady","DEFAULT_DISABLED_EXTENSIONS_KEY"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n/*global logger*/\n\n/**\n * Functions for working with extension packages\n */\ndefine(function (require, exports, module) {\n\n\n    var AppInit              = require(\"utils/AppInit\"),\n        FileSystem           = require(\"filesystem/FileSystem\"),\n        FileUtils            = require(\"file/FileUtils\"),\n        StringUtils          = require(\"utils/StringUtils\"),\n        Strings              = require(\"strings\"),\n        ExtensionLoader      = require(\"utils/ExtensionLoader\"),\n        PreferencesManager   = require(\"preferences/PreferencesManager\"),\n        PathUtils            = require(\"thirdparty/path-utils/path-utils\"),\n        ExtensionDownloader  = require(\"extensibility/ExtensionDownloader\");\n\n    PreferencesManager.definePreference(\"proxy\", \"string\", undefined, {\n        description: Strings.DESCRIPTION_PROXY\n    });\n\n    const DISABLED_EXTENSIONS_KEY = \"extensions.disabled\";\n\n    var Errors = {\n        ERROR_LOADING: \"ERROR_LOADING\",\n        MALFORMED_URL: \"MALFORMED_URL\",\n        UNSUPPORTED_PROTOCOL: \"UNSUPPORTED_PROTOCOL\"\n    };\n\n    var InstallationStatuses = {\n        FAILED: \"FAILED\",\n        INSTALLED: \"INSTALLED\",\n        ALREADY_INSTALLED: \"ALREADY_INSTALLED\",\n        SAME_VERSION: \"SAME_VERSION\",\n        OLDER_VERSION: \"OLDER_VERSION\",\n        NEEDS_UPDATE: \"NEEDS_UPDATE\",\n        DISABLED: \"DISABLED\"\n    };\n\n    /**\n     * @type {number} Used to generate unique download ids\n     */\n    var _uniqueId = 0;\n\n    /**\n     * Validates and installs the package at the given path. Validation and\n     * installation is handled by the Node process.\n     *\n     * The extension will be installed into the user's extensions directory.\n     * If the user already has the extension installed, it will instead go\n     * into their disabled extensions directory.\n     *\n     * The promise is resolved with an object:\n     * { errors: Array.<{string}>, metadata: { name:string, version:string, ... },\n     * disabledReason:string, installedTo:string, commonPrefix:string }\n     * metadata is pulled straight from package.json and is likely to be undefined\n     * if there are errors. It is null if there was no package.json.\n     *\n     * disabledReason is either null or the reason the extension was installed disabled.\n     *\n     * @param {string} path Absolute path to the package zip file\n     * @param {?string} nameHint Hint for the extension folder's name (used in favor of\n     *          path's filename if present, and if no package metadata present).\n     * @param {?boolean} _doUpdate private argument used to signal an update\n     * @return {$.Promise} A promise that is resolved with information about the package\n     *          (which may include errors, in which case the extension was disabled), or\n     *          rejected with an error object.\n     */\n    function install(path, nameHint, _doUpdate) {\n        const d                       = new $.Deferred(),\n            destinationDirectory    = ExtensionLoader.getUserExtensionPath(),\n            disabledDirectory       = destinationDirectory.replace(/\\/user$/, \"/disabled\"),\n            systemDirectory         = FileUtils.getNativeBracketsDirectoryPath() + \"/extensions/default/\";\n\n        const operation = _doUpdate ? \"update\" : \"install\";\n        ExtensionDownloader[operation](path, destinationDirectory, {\n            disabledDirectory: disabledDirectory,\n            systemExtensionDirectory: systemDirectory,\n            apiVersion: brackets.metadata.apiVersion,\n            nameHint: nameHint,\n            proxy: PreferencesManager.get(\"proxy\")\n        })\n            .done(function (result) {\n\n                if (result.installationStatus !== InstallationStatuses.INSTALLED || _doUpdate) {\n                    d.resolve(result);\n                } else {\n                    // This was a new extension and everything looked fine.\n                    // We load it into Brackets right away.\n                    ExtensionLoader.loadExtension(result.name, {\n                        // On Windows, it looks like Node converts Unix-y paths to backslashy paths.\n                        // We need to convert them back.\n                        baseUrl: window.Phoenix.VFS.getVirtualServingURLForPath(result.installedTo)\n                    }, \"main\").then(function () {\n                        d.resolve(result);\n                    }, function () {\n                        d.reject(Errors.ERROR_LOADING);\n                    });\n                }\n            })\n            .fail(function (error) {\n                d.reject(error);\n            });\n\n        return d.promise();\n    }\n\n\n\n    /**\n     * Special case handling to make the common case of downloading from GitHub easier; modifies 'urlInfo' as\n     * needed. Converts a bare GitHub repo URL to the corresponding master ZIP URL; or if given a direct\n     * master ZIP URL already, sets a nicer download filename (both cases use the repo name).\n     *\n     * @param {{url:string, parsed:Array.<string>, filenameHint:string}} urlInfo\n     */\n    function githubURLFilter(urlInfo) {\n        if (urlInfo.parsed.hostname === \"github.com\" || urlInfo.parsed.hostname === \"www.github.com\") {\n            // Is it a URL to the root of a repo? (/user/repo)\n            var match = /^\\/[^\\/?]+\\/([^\\/?]+)(\\/?)$/.exec(urlInfo.parsed.pathname);\n            if (match) {\n                if (!match[2]) {\n                    urlInfo.url += \"/\";\n                }\n                urlInfo.url += \"archive/master.zip\";\n                urlInfo.filenameHint = match[1] + \".zip\";\n\n            } else {\n                // Is it a URL directly to the repo's 'master.zip'? (/user/repo/archive/master.zip)\n                match = /^\\/[^\\/?]+\\/([^\\/?]+)\\/archive\\/master.zip$/.exec(urlInfo.parsed.pathname);\n                if (match) {\n                    urlInfo.filenameHint = match[1] + \".zip\";\n                }\n            }\n        }\n    }\n\n    /**\n     * Downloads from the given URL to a temporary location. On success, resolves with the path of the\n     * downloaded file (typically in a temp folder) and a hint for the real filename. On failure, rejects\n     * with an error object.\n     *\n     * @param {string} url URL of the file to be downloaded\n     * @param {number} downloadId Unique number to identify this request\n     * @param {string} destinationDirectory Optional path to download extension to. Defaults to user extension folder\n     * @return {$.Promise}\n     */\n    function _download(url, downloadId, destinationDirectory) {\n        const d = new $.Deferred();\n\n        // Validate URL\n        // TODO: PathUtils fails to parse URLs that are missing the protocol part (e.g. starts immediately with \"www...\")\n        const parsed = PathUtils.parseUrl(url);\n        if (!parsed.hostname) {  // means PathUtils failed to parse at all\n            d.reject(Errors.MALFORMED_URL);\n            return d.promise();\n        }\n        if (!(parsed.protocol === \"http:\" || parsed.protocol === \"https:\"\n            || parsed.protocol === \"phtauri:\" || parsed.protocol === \"asset:\")) {\n            d.reject(Errors.UNSUPPORTED_PROTOCOL);\n            return d.promise();\n        }\n        parsed.filename = FileUtils.convertWindowsPathToUnixPath(parsed.filename);\n        const urlInfo = { url: url, parsed: parsed, filenameHint: parsed.filename, destinationDirectory };\n        githubURLFilter(urlInfo);\n\n        // Decide download destination\n        let filename = urlInfo.filenameHint;\n        filename = filename.replace(/[^a-zA-Z0-9_\\- \\(\\)\\.]/g, \"_\"); // make sure it's a valid filename\n        if (!filename) {  // in case of URL ending in \"/\"\n            filename = \"extension.zip\";\n        }\n\n        const r = ExtensionDownloader.downloadFile(downloadId, urlInfo, PreferencesManager.get(\"proxy\"));\n        r.done(function (result) {\n            d.resolve({\n                localPath: FileUtils.convertWindowsPathToUnixPath(result),\n                filenameHint: urlInfo.filenameHint });\n        }).fail(function (err) {\n            d.reject(err);\n        });\n\n        return d.promise();\n    }\n\n    /**\n     * Attempts to synchronously cancel the given pending download. This may not be possible, e.g.\n     * if the download has already finished.\n     *\n     * @param {number} downloadId Identifier previously passed to download()\n     */\n    function cancelDownload(downloadId) {\n        ExtensionDownloader.abortDownload(downloadId);\n    }\n\n    /**\n     * On success, resolves with an extension metadata object; at that point, the extension has already\n     * started running in Brackets. On failure (including validation errors), rejects with an error object.\n     *\n     * An error object consists of either a string error code OR an array where the first entry is the error\n     * code and the remaining entries are further info. The error code string is one of either\n     * ExtensionsDomain.Errors or Package.Errors. Use formatError() to convert an error object to a friendly,\n     * localized error message.\n     *\n     * @param {string} path Absolute path to the package zip file\n     * @param {?string} filenameHint Hint for the extension folder's name (used in favor of\n     *          path's filename if present, and if no package metadata present).\n     * @return {$.Promise} A promise that is rejected if there are errors during\n     *          install or the extension is disabled.\n     */\n    function installFromPath(path, filenameHint) {\n        const d = new $.Deferred();\n\n        install(path, filenameHint)\n            .done(function (result) {\n\n                let installationStatus = result.installationStatus;\n                if (installationStatus === InstallationStatuses.ALREADY_INSTALLED ||\n                        installationStatus === InstallationStatuses.NEEDS_UPDATE ||\n                        installationStatus === InstallationStatuses.SAME_VERSION ||\n                        installationStatus === InstallationStatuses.OLDER_VERSION) {\n                    d.resolve(result);\n                } else {\n                    if (result.errors && result.errors.length > 0) {\n                        // Validation errors - for now, only return the first one\n                        d.reject(result.errors[0]);\n                    } else if (result.disabledReason) {\n                        // Extension valid but left disabled (wrong API version, extension name collision, etc.)\n                        d.reject(result.disabledReason);\n                    } else {\n                        // Success! Extension is now running in Brackets\n                        d.resolve(result);\n                    }\n                }\n            })\n            .fail(function (err) {\n                d.reject(err);\n            });\n\n        return d.promise();\n    }\n\n    /**\n     * On success, resolves with an extension metadata object; at that point, the extension has already\n     * started running in Brackets. On failure (including validation errors), rejects with an error object.\n     *\n     * An error object consists of either a string error code OR an array where the first entry is the error\n     * code and the remaining entries are further info. The error code string is one of either\n     * ExtensionsDomain.Errors or Package.Errors. Use formatError() to convert an error object to a friendly,\n     * localized error message.\n     *\n     * The returned cancel() function will *attempt* to cancel installation, but it is not guaranteed to\n     * succeed. If cancel() succeeds, the Promise is rejected with a CANCELED error code. If we're unable\n     * to cancel, the Promise is resolved or rejected normally, as if cancel() had never been called.\n     *\n     * @return {{promise: $.Promise, cancel: function():boolean}}\n     */\n    function installFromURL(url, destinationDirectory) {\n        const STATE_DOWNLOADING = 1,\n            STATE_INSTALLING = 2,\n            STATE_SUCCEEDED = 3,\n            STATE_FAILED = 4;\n\n        const d = new $.Deferred();\n        let state = STATE_DOWNLOADING;\n\n        var downloadId = (_uniqueId++);\n        _download(url, downloadId, destinationDirectory)\n            .done(function (downloadResult) {\n                state = STATE_INSTALLING;\n\n                installFromPath(downloadResult.localPath, downloadResult.filenameHint)\n                    .done(function (result) {\n                        state = STATE_SUCCEEDED;\n                        result.localPath = downloadResult.localPath;\n                        d.resolve(result);\n                    })\n                    .fail(function (err) {\n                        // File IO errors, internal error in install()/validate(), or extension startup crashed\n                        state = STATE_FAILED;\n                        FileSystem.getFileForPath(downloadResult.localPath).unlink();\n                        if(!url || url.startsWith(brackets.config.extension_url)) {\n                            // privacy, log error for extensions in registry\n                            logger.reportError(err, \"Failed to install \" + url);\n                        }\n                        d.reject(err);\n                    });\n            })\n            .fail(function (err) {\n                // Download error (the Node-side download code cleans up any partial ZIP file)\n                state = STATE_FAILED;\n                d.reject(err);\n            });\n\n        return {\n            promise: d.promise(),\n            cancel: function () {\n                if (state === STATE_DOWNLOADING) {\n                    // This will trigger download()'s fail() handler with CANCELED as the err code\n                    cancelDownload(downloadId);\n                }\n                // Else it's too late to cancel; we'll continue on through the done() chain and emit\n                // a success result (calling done() handlers) if all else goes well.\n            }\n        };\n    }\n\n    /**\n     * Converts an error object as returned by install(), installFromPath() or\n     * installFromURL() into a flattened, localized string.\n     *\n     * @param {string|Array.<string>} error\n     * @return {string}\n     */\n    function formatError(error) {\n        function localize(key) {\n            if (Strings[key]) {\n                return Strings[key];\n            }\n            console.log(\"Unknown installation error\", key);\n            return Strings.UNKNOWN_ERROR;\n        }\n\n        if (Array.isArray(error)) {\n            error[0] = localize(error[0]);\n            return StringUtils.format.apply(window, error);\n        }\n        return localize(error);\n\n    }\n\n    /**\n     * Removes the extension at the given path.\n     *\n     * @param {string} path The absolute path to the extension to remove.\n     * @return {$.Promise} A promise that's resolved when the extension is removed, or\n     *     rejected if there was an error.\n     */\n    function remove(path) {\n        return ExtensionDownloader.remove(path);\n    }\n\n    /**\n     * function manages state weather an extension is enabled or disabled\n     */\n    function _toggleDisabledExtension(path, enabled) {\n        let arr = JSON.parse(PhStore.getItem(DISABLED_EXTENSIONS_KEY) || \"[]\");\n        const io = arr.indexOf(path);\n        if (enabled === true && io !== -1) {\n            arr.splice(io, 1);\n        } else if (enabled === false && io === -1) {\n            arr.push(path);\n        }\n        PhStore.setItem(DISABLED_EXTENSIONS_KEY, JSON.stringify(arr));\n    }\n\n    /**\n     * Disables the extension at the given path.\n     *\n     * @param {string} path The absolute path to the extension to disable.\n     * @return {$.Promise} A promise that's resolved when the extenion is disabled, or\n     *      rejected if there was an error.\n     */\n    function disable(path) {\n        const result = new $.Deferred();\n        _toggleDisabledExtension(path, false);\n        result.resolve();\n        return result.promise();\n    }\n\n    /**\n     * Enables the extension at the given path.\n     *\n     * @param {string} path The absolute path to the extension to enable.\n     * @return {$.Promise} A promise that's resolved when the extenion is enable, or\n     *      rejected if there was an error.\n     */\n    function enable(path) {\n        const result = new $.Deferred();\n        _toggleDisabledExtension(path, true);\n        ExtensionLoader.loadExtension(FileUtils.getBaseName(path), { baseUrl: path }, \"main\")\n            .done(result.resolve)\n            .fail(result.reject);\n        return result.promise();\n    }\n\n    /**\n     * Install an extension update located at path.\n     * This assumes that the installation was previously attempted\n     * and an installationStatus of \"ALREADY_INSTALLED\", \"NEEDS_UPDATE\", \"SAME_VERSION\",\n     * or \"OLDER_VERSION\" was the result.\n     *\n     * This workflow ensures that there should not generally be validation errors\n     * because the first pass at installation the extension looked at the metadata\n     * and installed packages.\n     *\n     * @param {string} path to package file\n     * @param {?string} nameHint Hint for the extension folder's name (used in favor of\n     *          path's filename if present, and if no package metadata present).\n     * @return {$.Promise} A promise that is resolved when the extension is successfully\n     *      installed or rejected if there is a problem.\n     */\n    function installUpdate(path, nameHint) {\n        const d = new $.Deferred();\n        install(path, nameHint, true)\n            .done(function (result) {\n                if (result.installationStatus !== InstallationStatuses.INSTALLED) {\n                    d.reject(result.errors);\n                } else {\n                    d.resolve(result);\n                }\n            })\n            .fail(function (error) {\n                d.reject(error);\n            });\n        return d.promise();\n    }\n\n    AppInit.appReady(function () {\n    });\n\n    exports.installFromURL          = installFromURL;\n    exports.installFromPath         = installFromPath;\n    exports.install                 = install;\n    exports.remove                  = remove;\n    exports.disable                 = disable;\n    exports.enable                  = enable;\n    exports.installUpdate           = installUpdate;\n    exports.formatError             = formatError;\n    exports.InstallationStatuses    = InstallationStatuses;\n    exports.DEFAULT_DISABLED_EXTENSIONS_KEY = DISABLED_EXTENSIONS_KEY;\n});\n"],"file":"Package.js"}
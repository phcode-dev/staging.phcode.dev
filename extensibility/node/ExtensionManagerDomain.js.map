{"version":3,"sources":["extensibility/node/ExtensionManagerDomain.js"],"names":["semver","require","path","request","fs","temp","validate","track","Errors","API_NOT_COMPATIBLE","MISSING_REQUIRED_OPTIONS","DOWNLOAD_ID_IN_USE","BAD_HTTP_STATUS","NO_SERVER_RESPONSE","CANNOT_WRITE_TEMP","CANCELED","Statuses","FAILED","INSTALLED","ALREADY_INSTALLED","SAME_VERSION","OLDER_VERSION","NEEDS_UPDATE","DISABLED","pendingDownloads","_removeFailedInstallation","installDirectory","remove","err","console","error","_performInstall","packagePath","validationResult","callback","fail","finish","installationStatus","installedTo","mkdirs","sourceDir","join","extractDir","commonPrefix","copy","_removeAndInstall","_checkExistingInstallation","systemInstallDirectory","metadata","readJson","packageObj","lt","version","gt","installedVersion","legacyPackageCheck","legacyDirectory","existsSync","_cmdInstall","destinationDirectory","options","pCallback","_doUpdate","validateCallback","deleteTempAndCallback","localPath","errors","length","extensionName","guessedName","nameHint","basename","name","systemExtensionDirectory","compatible","engines","brackets","satisfies","apiVersion","disabledDirectory","disabledReason","hasLegacyPackage","Error","_cmdUpdate","_endDownload","downloadId","downloadInfo","abort","outStream","end","unlink","_cmdDownloadFile","url","proxy","undefined","req","get","encoding","response","body","statusCode","stream","createWriteStream","write","_cmdAbortDownload","_cmdRemove","extensionDir","init","domainManager","hasDomain","registerDomain","major","minor","registerCommand","type","description","exports","_cmdValidate"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*eslint-env node */\n/*jslint node: true */\n\n\n\nvar semver   = require(\"semver\"),\n    path     = require(\"path\"),\n    request  = require(\"request\"),\n    fs       = require(\"fs-extra\"),\n    temp     = require(\"temp\"),\n    validate = require(\"./package-validator\").validate;\n\n// Automatically clean up temp files on exit\ntemp.track();\n\nvar Errors = {\n    API_NOT_COMPATIBLE: \"API_NOT_COMPATIBLE\",\n    MISSING_REQUIRED_OPTIONS: \"MISSING_REQUIRED_OPTIONS\",\n    DOWNLOAD_ID_IN_USE: \"DOWNLOAD_ID_IN_USE\",\n    BAD_HTTP_STATUS: \"BAD_HTTP_STATUS\",             // {0} is the HTTP status code\n    NO_SERVER_RESPONSE: \"NO_SERVER_RESPONSE\",\n    CANNOT_WRITE_TEMP: \"CANNOT_WRITE_TEMP\",\n    CANCELED: \"CANCELED\"\n};\n\nvar Statuses = {\n    FAILED: \"FAILED\",\n    INSTALLED: \"INSTALLED\",\n    ALREADY_INSTALLED: \"ALREADY_INSTALLED\",\n    SAME_VERSION: \"SAME_VERSION\",\n    OLDER_VERSION: \"OLDER_VERSION\",\n    NEEDS_UPDATE: \"NEEDS_UPDATE\",\n    DISABLED: \"DISABLED\"\n};\n\n/**\n * Maps unique download ID to info about the pending download. No entry if download no longer pending.\n * outStream is only present if we've started receiving the body.\n * @type {Object.<string, {request:!http.ClientRequest, callback:!function(string, string), localPath:string, outStream:?fs.WriteStream}>}\n */\nvar pendingDownloads = {};\n\n/**\n * Private function to remove the installation directory if the installation fails.\n * This does not call any callbacks. It's assumed that the callback has already been called\n * and this cleanup routine will do its best to complete in the background. If there's\n * a problem here, it is simply logged with console.error.\n *\n * @param {string} installDirectory Directory to remove\n */\nfunction _removeFailedInstallation(installDirectory) {\n    fs.remove(installDirectory, function (err) {\n        if (err) {\n            console.error(\"Error while removing directory after failed installation\", installDirectory, err);\n        }\n    });\n}\n\n/**\n * Private function to unzip to the correct directory.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} Absolute path to the destination directory for unzipping\n * @param {Object} the return value with the useful information for the client\n * @param {Function} callback function that is called at the end of the unzipping\n */\nfunction _performInstall(packagePath, installDirectory, validationResult, callback) {\n    validationResult.installedTo = installDirectory;\n\n    function fail(err) {\n        _removeFailedInstallation(installDirectory);\n        callback(err, null);\n    }\n\n    function finish() {\n        // The status may have already been set previously (as in the\n        // DISABLED case.\n        if (!validationResult.installationStatus) {\n            validationResult.installationStatus = Statuses.INSTALLED;\n        }\n        callback(null, validationResult);\n    }\n\n    fs.mkdirs(installDirectory, function (err) {\n        if (err) {\n            callback(err);\n            return;\n        }\n        var sourceDir = path.join(validationResult.extractDir, validationResult.commonPrefix);\n\n        fs.copy(sourceDir, installDirectory, function (err) {\n            if (err) {\n                return fail(err);\n            }\n            finish();\n        });\n    });\n}\n\n/**\n * Private function to remove the target directory and then install.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} Absolute path to the destination directory for unzipping\n * @param {Object} the return value with the useful information for the client\n * @param {Function} callback function that is called at the end of the unzipping\n */\nfunction _removeAndInstall(packagePath, installDirectory, validationResult, callback) {\n    // If this extension was previously installed but disabled, we will overwrite the\n    // previous installation in that directory.\n    fs.remove(installDirectory, function (err) {\n        if (err) {\n            callback(err);\n            return;\n        }\n        _performInstall(packagePath, installDirectory, validationResult, callback);\n    });\n}\n\nfunction _checkExistingInstallation(validationResult, installDirectory, systemInstallDirectory, callback) {\n    // If the extension being installed does not have a package.json, we can't\n    // do any kind of version comparison, so we just signal to the UI that\n    // it already appears to be installed.\n    if (!validationResult.metadata) {\n        validationResult.installationStatus = Statuses.ALREADY_INSTALLED;\n        callback(null, validationResult);\n        return;\n    }\n\n    fs.readJson(path.join(installDirectory, \"package.json\"), function (err, packageObj) {\n        // if the package.json is unreadable, we assume that the new package is an update\n        // that is the first to include a package.json.\n        if (err) {\n            validationResult.installationStatus = Statuses.NEEDS_UPDATE;\n        } else {\n            // Check to see if the version numbers signal an update.\n            if (semver.lt(packageObj.version, validationResult.metadata.version)) {\n                validationResult.installationStatus = Statuses.NEEDS_UPDATE;\n            } else if (semver.gt(packageObj.version, validationResult.metadata.version)) {\n                // Pass a message back to the UI that the new package appears to be an older version\n                // than what's installed.\n                validationResult.installationStatus = Statuses.OLDER_VERSION;\n                validationResult.installedVersion = packageObj.version;\n            } else {\n                // Signal to the UI that it looks like the user is re-installing the\n                // same version.\n                validationResult.installationStatus = Statuses.SAME_VERSION;\n            }\n        }\n        callback(null, validationResult);\n    });\n}\n\n/**\n * A \"legacy package\" is an extension that was installed based on the GitHub name without\n * a package.json file. Checking for the presence of these legacy extensions will help\n * users upgrade if the extension developer puts a different name in package.json than\n * the name of the GitHub project.\n *\n * @param {string} legacyDirectory directory to check for old-style extension.\n */\nfunction legacyPackageCheck(legacyDirectory) {\n    return fs.existsSync(legacyDirectory) && !fs.existsSync(path.join(legacyDirectory, \"package.json\"));\n}\n\n/**\n * Implements the \"install\" command in the \"extensions\" domain.\n *\n * There is no need to call validate independently. Validation is the first\n * thing that is done here.\n *\n * After the extension is validated, it is installed in destinationDirectory\n * unless the extension is already present there. If it is already present,\n * a determination is made about whether the package being installed is\n * an update. If it does appear to be an update, then result.installationStatus\n * is set to NEEDS_UPDATE. If not, then it's set to ALREADY_INSTALLED.\n *\n * If the installation succeeds, then result.installationStatus is set to INSTALLED.\n *\n * The extension is unzipped into a directory in destinationDirectory with\n * the name of the extension (the name is derived either from package.json\n * or the name of the zip file).\n *\n * The destinationDirectory will be created if it does not exist.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} the destination directory\n * @param {{disabledDirectory: !string, apiVersion: !string, nameHint: ?string,\n *      systemExtensionDirectory: !string}} additional settings to control the installation\n * @param {function} callback (err, result)\n * @param {function} pCallback (msg) callback for notifications about operation progress\n * @param {boolean} _doUpdate  private argument to signal that an update should be performed\n */\nfunction _cmdInstall(packagePath, destinationDirectory, options, callback, pCallback, _doUpdate) {\n    if (!options || !options.disabledDirectory || !options.apiVersion || !options.systemExtensionDirectory) {\n        callback(new Error(Errors.MISSING_REQUIRED_OPTIONS), null);\n        return;\n    }\n\n    function validateCallback(err, validationResult) {\n        validationResult.localPath = packagePath;\n\n        // This is a wrapper for the callback that will delete the temporary\n        // directory to which the package was unzipped.\n        function deleteTempAndCallback(err) {\n            if (validationResult.extractDir) {\n                fs.remove(validationResult.extractDir);\n                delete validationResult.extractDir;\n            }\n            callback(err, validationResult);\n        }\n\n        // If there was trouble at the validation stage, we stop right away.\n        if (err || validationResult.errors.length > 0) {\n            validationResult.installationStatus = Statuses.FAILED;\n            deleteTempAndCallback(err);\n            return;\n        }\n\n        // Prefers the package.json name field, but will take the zip\n        // file's name if that's all that's available.\n        var extensionName, guessedName;\n        if (options.nameHint) {\n            guessedName = path.basename(options.nameHint, \".zip\");\n        } else {\n            guessedName = path.basename(packagePath, \".zip\");\n        }\n        if (validationResult.metadata) {\n            extensionName = validationResult.metadata.name;\n        } else {\n            extensionName = guessedName;\n        }\n\n        validationResult.name = extensionName;\n        var installDirectory = path.join(destinationDirectory, extensionName),\n            legacyDirectory = path.join(destinationDirectory, guessedName),\n            systemInstallDirectory = path.join(options.systemExtensionDirectory, extensionName);\n\n        if (validationResult.metadata && validationResult.metadata.engines &&\n                validationResult.metadata.engines.brackets) {\n            var compatible = semver.satisfies(options.apiVersion,\n                                              validationResult.metadata.engines.brackets);\n            if (!compatible) {\n                installDirectory = path.join(options.disabledDirectory, extensionName);\n                validationResult.installationStatus = Statuses.DISABLED;\n                validationResult.disabledReason = Errors.API_NOT_COMPATIBLE;\n                _removeAndInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n                return;\n            }\n        }\n\n        // The \"legacy\" stuff should go away after all of the commonly used extensions\n        // have been upgraded with package.json files.\n        var hasLegacyPackage = validationResult.metadata && legacyPackageCheck(legacyDirectory);\n\n        // If the extension is already there, we signal to the front end that it's already installed\n        // unless the front end has signaled an intent to update.\n        if (hasLegacyPackage || fs.existsSync(installDirectory) || fs.existsSync(systemInstallDirectory)) {\n            if (_doUpdate === true) {\n                if (hasLegacyPackage) {\n                    // When there's a legacy installed extension, remove it first,\n                    // then also remove any new-style directory the user may have.\n                    // This helps clean up if the user is in a state where they have\n                    // both legacy and new extensions installed.\n                    fs.remove(legacyDirectory, function (err) {\n                        if (err) {\n                            deleteTempAndCallback(err);\n                            return;\n                        }\n                        _removeAndInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n                    });\n                } else {\n                    _removeAndInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n                }\n            } else if (hasLegacyPackage) {\n                validationResult.installationStatus = Statuses.NEEDS_UPDATE;\n                validationResult.name = guessedName;\n                deleteTempAndCallback(null);\n            } else {\n                _checkExistingInstallation(validationResult, installDirectory, systemInstallDirectory, deleteTempAndCallback);\n            }\n        } else {\n            // Regular installation with no conflicts.\n            validationResult.disabledReason = null;\n            _performInstall(packagePath, installDirectory, validationResult, deleteTempAndCallback);\n        }\n    }\n\n    validate(packagePath, options, validateCallback);\n}\n\n/**\n * Implements the \"update\" command in the \"extensions\" domain.\n *\n * Currently, this just wraps _cmdInstall, but will remove the existing directory\n * first.\n *\n * There is no need to call validate independently. Validation is the first\n * thing that is done here.\n *\n * After the extension is validated, it is installed in destinationDirectory\n * unless the extension is already present there. If it is already present,\n * a determination is made about whether the package being installed is\n * an update. If it does appear to be an update, then result.installationStatus\n * is set to NEEDS_UPDATE. If not, then it's set to ALREADY_INSTALLED.\n *\n * If the installation succeeds, then result.installationStatus is set to INSTALLED.\n *\n * The extension is unzipped into a directory in destinationDirectory with\n * the name of the extension (the name is derived either from package.json\n * or the name of the zip file).\n *\n * The destinationDirectory will be created if it does not exist.\n *\n * @param {string} Absolute path to the package zip file\n * @param {string} the destination directory\n * @param {{disabledDirectory: !string, apiVersion: !string, nameHint: ?string,\n *      systemExtensionDirectory: !string}} additional settings to control the installation\n * @param {function} callback (err, result)\n * @param {function} pCallback (msg) callback for notifications about operation progress\n */\nfunction _cmdUpdate(packagePath, destinationDirectory, options, callback, pCallback) {\n    _cmdInstall(packagePath, destinationDirectory, options, callback, pCallback, true);\n}\n\n/**\n * Wrap up after the given download has terminated (successfully or not). Closes connections, calls back the\n * client's callback, and IF there was an error, delete any partially-downloaded file.\n *\n * @param {string} downloadId Unique id originally passed to _cmdDownloadFile()\n * @param {?string} error If null, download was treated as successful\n */\nfunction _endDownload(downloadId, error) {\n    var downloadInfo = pendingDownloads[downloadId];\n    delete pendingDownloads[downloadId];\n\n    if (error) {\n        // Abort the download if still pending\n        // Note that this will trigger response's \"end\" event\n        downloadInfo.request.abort();\n\n        // Clean up any partially-downloaded file\n        // (if no outStream, then we never got a response back yet and never created any file)\n        if (downloadInfo.outStream) {\n            downloadInfo.outStream.end(function () {\n                fs.unlink(downloadInfo.localPath);\n            });\n        }\n\n        downloadInfo.callback(error, null);\n\n    } else {\n        // Download completed successfully. Flush stream to disk and THEN signal completion\n        downloadInfo.outStream.end(function () {\n            downloadInfo.callback(null, downloadInfo.localPath);\n        });\n    }\n}\n\n/**\n * Implements \"downloadFile\" command, asynchronously.\n */\nfunction _cmdDownloadFile(downloadId, url, proxy, callback, pCallback) {\n    // Backwards compatibility check, added in 0.37\n    if (typeof proxy === \"function\") {\n        callback = proxy;\n        proxy = undefined;\n    }\n\n    if (pendingDownloads[downloadId]) {\n        callback(Errors.DOWNLOAD_ID_IN_USE, null);\n        return;\n    }\n\n    var req = request.get({\n        url: url,\n        encoding: null,\n        proxy: proxy\n    },\n        // Note: we could use the traditional \"response\"/\"data\"/\"end\" events too if we wanted to stream data\n        // incrementally, limit download size, etc. - but the simple callback is good enough for our needs.\n        function (error, response, body) {\n            if (error) {\n                // Usually means we never got a response - server is down, no DNS entry, etc.\n                _endDownload(downloadId, Errors.NO_SERVER_RESPONSE);\n                return;\n            }\n            if (response.statusCode !== 200) {\n                _endDownload(downloadId, [Errors.BAD_HTTP_STATUS, response.statusCode]);\n                return;\n            }\n\n            var stream = temp.createWriteStream(\"brackets\");\n            if (!stream) {\n                _endDownload(downloadId, Errors.CANNOT_WRITE_TEMP);\n                return;\n            }\n            pendingDownloads[downloadId].localPath = stream.path;\n            pendingDownloads[downloadId].outStream = stream;\n\n            stream.write(body);\n            _endDownload(downloadId);\n        });\n\n    pendingDownloads[downloadId] = { request: req, callback: callback };\n}\n\n/**\n * Implements \"abortDownload\" command, synchronously.\n */\nfunction _cmdAbortDownload(downloadId) {\n    if (!pendingDownloads[downloadId]) {\n        // This may mean the download already completed\n        return false;\n    }\n    _endDownload(downloadId, Errors.CANCELED);\n    return true;\n\n}\n\n/**\n * Implements the remove extension command.\n */\nfunction _cmdRemove(extensionDir, callback, pCallback) {\n    fs.remove(extensionDir, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null);\n        }\n    });\n}\n\n/**\n * Initialize the \"extensions\" domain.\n * The extensions domain handles downloading, unpacking/verifying, and installing extensions.\n */\nfunction init(domainManager) {\n    if (!domainManager.hasDomain(\"extensionManager\")) {\n        domainManager.registerDomain(\"extensionManager\", {major: 0, minor: 1});\n    }\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"validate\",\n        validate,\n        true,\n        \"Verifies that the contents of the given ZIP file are a valid Brackets extension package\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the extension package\"\n        }, {\n            name: \"options\",\n            type: \"{requirePackageJSON: ?boolean}\",\n            description: \"options to control the behavior of the validator\"\n        }],\n        [{\n            name: \"errors\",\n            type: \"string|Array.<string>\",\n            description: \"download error, if any; first string is error code (one of Errors.*); subsequent strings are additional info\"\n        }, {\n            name: \"metadata\",\n            type: \"{name: string, version: string}\",\n            description: \"all package.json metadata (null if there's no package.json)\"\n        }]\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"install\",\n        _cmdInstall,\n        true,\n        \"Installs the given Brackets extension if it is valid (runs validation command automatically)\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the extension package\"\n        }, {\n            name: \"destinationDirectory\",\n            type: \"string\",\n            description: \"absolute filesystem path where this extension should be installed\"\n        }, {\n            name: \"options\",\n            type: \"{disabledDirectory: !string, apiVersion: !string, nameHint: ?string, systemExtensionDirectory: !string, proxy: ?string}\",\n            description: \"installation options: disabledDirectory should be set so that extensions can be installed disabled.\"\n        }],\n        [{\n            name: \"errors\",\n            type: \"string|Array.<string>\",\n            description: \"download error, if any; first string is error code (one of Errors.*); subsequent strings are additional info\"\n        }, {\n            name: \"metadata\",\n            type: \"{name: string, version: string}\",\n            description: \"all package.json metadata (null if there's no package.json)\"\n        }, {\n            name: \"disabledReason\",\n            type: \"string\",\n            description: \"reason this extension was installed disabled (one of Errors.*), none if it was enabled\"\n        }, {\n            name: \"installationStatus\",\n            type: \"string\",\n            description: \"Current status of the installation (an extension can be valid but not installed because it's an update\"\n        }, {\n            name: \"installedTo\",\n            type: \"string\",\n            description: \"absolute path where the extension was installed to\"\n        }, {\n            name: \"commonPrefix\",\n            type: \"string\",\n            description: \"top level directory in the package zip which contains all of the files\"\n        }]\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"update\",\n        _cmdUpdate,\n        true,\n        \"Updates the given Brackets extension (for which install was generally previously attemped). Brackets must be quit after this.\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the extension package\"\n        }, {\n            name: \"destinationDirectory\",\n            type: \"string\",\n            description: \"absolute filesystem path where this extension should be installed\"\n        }, {\n            name: \"options\",\n            type: \"{disabledDirectory: !string, apiVersion: !string, nameHint: ?string, systemExtensionDirectory: !string}\",\n            description: \"installation options: disabledDirectory should be set so that extensions can be installed disabled.\"\n        }],\n        [{\n            name: \"errors\",\n            type: \"string|Array.<string>\",\n            description: \"download error, if any; first string is error code (one of Errors.*); subsequent strings are additional info\"\n        }, {\n            name: \"metadata\",\n            type: \"{name: string, version: string}\",\n            description: \"all package.json metadata (null if there's no package.json)\"\n        }, {\n            name: \"disabledReason\",\n            type: \"string\",\n            description: \"reason this extension was installed disabled (one of Errors.*), none if it was enabled\"\n        }, {\n            name: \"installationStatus\",\n            type: \"string\",\n            description: \"Current status of the installation (an extension can be valid but not installed because it's an update\"\n        }, {\n            name: \"installedTo\",\n            type: \"string\",\n            description: \"absolute path where the extension was installed to\"\n        }, {\n            name: \"commonPrefix\",\n            type: \"string\",\n            description: \"top level directory in the package zip which contains all of the files\"\n        }]\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"remove\",\n        _cmdRemove,\n        true,\n        \"Removes the Brackets extension at the given path.\",\n        [{\n            name: \"path\",\n            type: \"string\",\n            description: \"absolute filesystem path of the installed extension folder\"\n        }],\n        {}\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"downloadFile\",\n        _cmdDownloadFile,\n        true,\n        \"Downloads the file at the given URL, saving it to a temp location. Callback receives path to the downloaded file.\",\n        [{\n            name: \"downloadId\",\n            type: \"string\",\n            description: \"Unique identifier for this download 'session'\"\n        }, {\n            name: \"url\",\n            type: \"string\",\n            description: \"URL to download from\"\n        }, {\n            name: \"proxy\",\n            type: \"string\",\n            description: \"optional proxy URL\"\n        }],\n        {\n            type: \"string\",\n            description: \"Local path to the downloaded file\"\n        }\n    );\n    domainManager.registerCommand(\n        \"extensionManager\",\n        \"abortDownload\",\n        _cmdAbortDownload,\n        false,\n        \"Aborts any pending download with the given id. Ignored if no download pending (may be already complete).\",\n        [{\n            name: \"downloadId\",\n            type: \"string\",\n            description: \"Unique identifier for this download 'session', previously pased to downloadFile\"\n        }],\n        {\n            type: \"boolean\",\n            description: \"True if the download was pending and able to be canceled; false otherwise\"\n        }\n    );\n}\n\n// used in unit tests\nexports._cmdValidate = validate;\nexports._cmdInstall = _cmdInstall;\nexports._cmdRemove = _cmdRemove;\nexports._cmdUpdate = _cmdUpdate;\n\n// used to load the domain\nexports.init = init;\n"],"file":"ExtensionManagerDomain.js"}
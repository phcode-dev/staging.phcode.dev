{"version":3,"sources":["LiveDevelopment/Inspector/Inspector.js"],"names":["define","Inspector","require","exports","module","Async","EventDispatcher","_messageCallbacks","_messageId","_socket","_connectDeferred","_userAgent","_verifySignature","signature","value","undefined","console","assert","optional","name","_send","method","varargs","log","$","Deferred","reject","promise","id","callback","args","i","params","msg","Array","prototype","slice","call","arguments","length","pop","deferred","result","error","resolve","message","send","JSON","stringify","domain","command","_onDisconnect","trigger","_onError","_onConnect","_onMessage","response","parse","data","msgRecord","msgText","domainAndMethod","split","triggerWithArray","getDebuggableWindows","host","port","def","request","XMLHttpRequest","open","onload","onLoad","sockets","onerror","onError","disconnect","readyState","WebSocket","OPEN","onclose","withTimeout","close","onmessage","onopen","connect","socketURL","done","connectToURL","url","onGetAvailableSockets","page","webSocketDebuggerUrl","indexOf","FileError","ERR_NOT_FOUND","fail","onFail","err","connected","getUserAgent","setUserAgent","userAgent","init","theConfig","config","InspectorText","InspectorJSON","j","domains","exportedDomain","makeEventDispatcher","commands","bind","parameters"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint forin: true */\n/*global FileError */\n\n /**\n * Inspector manages the connection to Chrome/Chromium's remote debugger.\n * See inspector.html for the documentation of the remote debugger.\n *\n * __SETUP__\n *\n * To enable remote debugging in Chrome or Chromium open either application\n * with the following parameters:\n *\n *     --enable-remote-debugger --remote-debugging-port=9222\n *\n * This will open an HTTP server on the specified port, which can be used to\n * browse the available remote debugger sessions. In general, every open\n * browser tab can host an individual remote debugger session. The\n * available interfaces can be exported by requesting:\n *\n *     http://127.0.0.1:9222/json\n *\n * The response is a JSON-formatted array that specifies all available remote\n * debugger sessions including the remote debugging web sockets.\n *\n * Inspector can connect directly to a web socket via `connect(socketURL)`, or\n * it can find the web socket that corresponds to the tab at the given URL and\n * connect to it via `connectToURL(url)`. The later returns a promise. To\n * disconnect use `disconnect()`.\n *\n * __EVENTS__\n *\n * Inspector dispatches several connectivity-related events + all remote debugger\n * events (see below). Event handlers are attached via `on(event, function)` and\n * detached via `off(event, function)`.\n *\n *   `connect`    Inspector did successfully connect to the remote debugger\n *   `disconnect` Inspector did disconnect from the remote debugger\n *   `error`      Inspector encountered an error\n *   `message`    Inspector received a message from the remote debugger - this\n *                provides a low-level entry point to remote debugger events\n *\n * __REMOTE DEBUGGER COMMANDS__\n *\n * Commands are executed by calling `{Domain}.{Command}()` with the parameters\n * specified in the order of the remote debugger documentation. These command\n * functions are generated automatically at runtime from Inspector.json. The\n * actual implementation of these functions is found in\n * `_send(method, signature, varargs)`, which verifies, serializes, and\n * transmits the command to the remote debugger. If the last parameter of any\n * command function call is a function, it will be used as the callback.\n *\n * __REMOTE DEBUGGER EVENTS__\n *\n * Debugger events are dispatched as regular events using {Domain}.{Event} as\n * the event name. The handler function will be called with a single parameter\n * that stores all returned values as an object.\n */\ndefine(function Inspector(require, exports, module) {\n\n\n    var Async           = require(\"utils/Async\"),\n        EventDispatcher = require(\"utils/EventDispatcher\");\n\n    /**\n     * Map message IDs to the callback function and original JSON message\n     * @type {Object.<number, {callback: function, message: Object}}\n     */\n    var _messageCallbacks = {};\n\n    var _messageId = 1,     // id used for remote method calls, auto-incrementing\n        _socket,            // remote debugger WebSocket\n        _connectDeferred,   // The deferred connect\n        _userAgent = \"\";    // user agent string\n\n    /** Check a parameter value against the given signature\n     * This only checks for optional parameters, not types\n     * Type checking is complex because of $ref and done on the remote end anyways\n     * @param {signature}\n     * @param {value}\n     */\n    function _verifySignature(signature, value) {\n        if (value === undefined) {\n            console.assert(signature.optional === true, \"Missing argument: \" + signature.name);\n        }\n        return true;\n    }\n\n    /** Send a message to the remote debugger\n     * All passed arguments after the signature are passed on as parameters.\n     * If the last argument is a function, it is used as the callback function.\n     * @param {string} remote method\n     * @param {object} the method signature\n     */\n    function _send(method, signature, varargs) {\n        if (!_socket) {\n            console.log(\"You must connect to the WebSocket before sending messages.\");\n\n            // FUTURE: Our current implementation closes and re-opens an inspector connection whenever\n            // a new HTML file is selected. If done quickly enough, pending requests from the previous\n            // connection could come in before the new socket connection is established. For now we\n            // simply ignore this condition.\n            // This race condition will go away once we support multiple inspector connections and turn\n            // off auto re-opening when a new HTML file is selected.\n            return (new $.Deferred()).reject().promise();\n        }\n\n        var id, callback, args, i, params = {}, promise, msg;\n\n        // extract the parameters, the callback function, and the message id\n        args = Array.prototype.slice.call(arguments, 2);\n        if (typeof args[args.length - 1] === \"function\") {\n            callback = args.pop();\n        } else {\n            var deferred = new $.Deferred();\n            promise = deferred.promise();\n            callback = function (result, error) {\n                if (error) {\n                    deferred.reject(error);\n                } else {\n                    deferred.resolve(result);\n                }\n            };\n        }\n\n        id = _messageId++;\n\n        // verify the parameters against the method signature\n        // this also constructs the params object of type {name -> value}\n        if (signature) {\n            for (i in signature) {\n                if (_verifySignature(args[i], signature[i])) {\n                    params[signature[i].name] = args[i];\n                }\n            }\n        }\n\n        // Store message callback and send message\n        msg = { method: method, id: id, params: params };\n        _messageCallbacks[id] = { callback: callback, message: msg };\n        _socket.send(JSON.stringify(msg));\n\n        return promise;\n    }\n\n    /**\n     * Manually send a message to the remote debugger\n     * All passed arguments after the command are passed on as parameters.\n     * If the last argument is a function, it is used as the callback function.\n     * @param {string} domain\n     * @param {string} command\n     */\n    function send(domain, command, varargs) {\n        return _send(domain + \".\" + command, null, varargs);\n    }\n\n    /** WebSocket did close */\n    function _onDisconnect() {\n        _socket = undefined;\n        exports.trigger(\"disconnect\");\n    }\n\n    /** WebSocket reported an error */\n    function _onError(error) {\n        if (_connectDeferred) {\n            _connectDeferred.reject();\n            _connectDeferred = null;\n        }\n        exports.trigger(\"error\", error);\n    }\n\n    /** WebSocket did open */\n    function _onConnect() {\n        if (_connectDeferred) {\n            _connectDeferred.resolve();\n            _connectDeferred = null;\n        }\n        exports.trigger(\"connect\");\n    }\n\n    /** Received message from the WebSocket\n     * A message can be one of three things:\n     *   1. an error -> report it\n     *   2. the response to a previous command -> run the stored callback\n     *   3. an event -> trigger an event handler method\n     * @param {object} message\n     */\n    function _onMessage(message) {\n        var response    = JSON.parse(message.data),\n            msgRecord   = _messageCallbacks[response.id],\n            callback    = msgRecord && msgRecord.callback,\n            msgText     = (msgRecord && msgRecord.message) || \"No message\";\n\n        if (msgRecord) {\n            // Messages with an ID are a response to a command, fire callback\n            callback(response.result, response.error);\n            delete _messageCallbacks[response.id];\n        } else if (response.method) {\n            // Messages with a method are an event, trigger event handlers\n            var domainAndMethod = response.method.split(\".\"),\n                domain = domainAndMethod[0],\n                method = domainAndMethod[1];\n\n            EventDispatcher.triggerWithArray(exports[domain], method, response.params);\n        }\n\n        // Always fire event handlers for all messages/errors\n        exports.trigger(\"message\", response);\n\n        if (response.error) {\n            exports.trigger(\"error\", response.error, msgText);\n        }\n    }\n\n\n    /** Public Functions *****************************************************/\n\n    /** Get a list of the available windows/tabs/extensions that are remote-debuggable\n     * @param {string} host IP or name\n     * @param {integer} debugger port\n     */\n    function getDebuggableWindows(host, port) {\n        if (!host) {\n            host = \"127.0.0.1\";\n        }\n        if (!port) {\n            port = 9222;\n        }\n        var def = new $.Deferred();\n        var request = new XMLHttpRequest();\n        request.open(\"GET\", \"http://\" + host + \":\" + port + \"/json\");\n        request.onload = function onLoad() {\n            var sockets = JSON.parse(request.response);\n            def.resolve(sockets);\n        };\n        request.onerror = function onError() {\n            def.reject(request.response);\n        };\n\n        request.send(null);\n\n        return def.promise();\n    }\n\n    /**\n     * Disconnect from the remote debugger WebSocket\n     * @return {jQuery.Promise} Promise that is resolved immediately if not\n     *     currently connected or asynchronously when the socket is closed.\n     */\n    function disconnect() {\n        var deferred = new $.Deferred(),\n            promise = deferred.promise();\n\n        if (_socket && (_socket.readyState === WebSocket.OPEN)) {\n            _socket.onclose = function () {\n                // trigger disconnect event\n                _onDisconnect();\n\n                deferred.resolve();\n            };\n\n            promise = Async.withTimeout(promise, 5000);\n\n            _socket.close();\n        } else {\n            if (_socket) {\n                delete _socket.onmessage;\n                delete _socket.onopen;\n                delete _socket.onclose;\n                delete _socket.onerror;\n\n                _socket = undefined;\n            }\n\n            deferred.resolve();\n        }\n\n        return promise;\n    }\n\n    /**\n     * Connect to the remote debugger WebSocket at the given URL.\n     * Clients must listen for the `connect` event.\n     * @param {string} WebSocket URL\n     */\n    function connect(socketURL) {\n        disconnect().done(function () {\n            _socket = new WebSocket(socketURL);\n            _socket.onmessage = _onMessage;\n            _socket.onopen = _onConnect;\n            _socket.onclose = _onDisconnect;\n            _socket.onerror = _onError;\n        });\n    }\n\n    /** Connect to the remote debugger of the page that is at the given URL\n     * @param {string} url\n     */\n    function connectToURL(url) {\n        if (_connectDeferred) {\n            // reject an existing connection attempt\n            _connectDeferred.reject(\"CANCEL\");\n        }\n        var deferred = new $.Deferred();\n        _connectDeferred = deferred;\n        var promise = getDebuggableWindows();\n        promise.done(function onGetAvailableSockets(response) {\n            var i, page;\n            for (i in response) {\n                page = response[i];\n                if (page.webSocketDebuggerUrl && page.url.indexOf(url) === 0) {\n                    connect(page.webSocketDebuggerUrl);\n                    // _connectDeferred may be resolved by onConnect or rejected by onError\n                    return;\n                }\n            }\n            deferred.reject(FileError.ERR_NOT_FOUND); // Reject with a \"not found\" error\n        });\n        promise.fail(function onFail(err) {\n            deferred.reject(err);\n        });\n        return deferred.promise();\n    }\n\n    /** Check if the inspector is connected */\n    function connected() {\n        return _socket !== undefined && _socket.readyState === WebSocket.OPEN;\n    }\n\n    /**\n     * Get user agent string\n     * @return {string}\n     */\n    function getUserAgent() {\n        return _userAgent;\n    }\n\n    /**\n     * Set user agent string\n     * @param {string} userAgent User agent string returned from Chrome\n     */\n    function setUserAgent(userAgent) {\n        _userAgent = userAgent;\n    }\n\n    /** Initialize the Inspector\n     * Read the Inspector.json configuration and define the command objects\n     * -> Inspector.domain.command()\n     */\n    function init(theConfig) {\n        exports.config = theConfig;\n\n        var InspectorText = require(\"text!LiveDevelopment/Inspector/Inspector.json\"),\n            InspectorJSON = JSON.parse(InspectorText);\n\n        var i, j, domain, command;\n        for (i in InspectorJSON.domains) {\n            domain = InspectorJSON.domains[i];\n            var exportedDomain = {};\n            exports[domain.domain] = exportedDomain;\n            EventDispatcher.makeEventDispatcher(exportedDomain);\n            for (j in domain.commands) {\n                command = domain.commands[j];\n                exportedDomain[command.name] = _send.bind(undefined, domain.domain + \".\" + command.name, command.parameters);\n            }\n        }\n    }\n\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // Export public functions\n    exports.connect              = connect;\n    exports.connected            = connected;\n    exports.connectToURL         = connectToURL;\n    exports.disconnect           = disconnect;\n    exports.getDebuggableWindows = getDebuggableWindows;\n    exports.getUserAgent         = getUserAgent;\n    exports.init                 = init;\n    exports.send                 = send;\n    exports.setUserAgent         = setUserAgent;\n});\n"],"file":"Inspector.js"}
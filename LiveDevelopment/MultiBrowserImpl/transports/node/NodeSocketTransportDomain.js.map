{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/transports/node/NodeSocketTransportDomain.js"],"names":["WebSocketServer","require","Server","_","_wsServer","_domainManager","_nextClientId","_clients","SOCKET_PORT","_clientForSocket","ws","find","client","socket","_createServer","port","on","msg","msgObj","console","log","JSON","parse","e","error","type","url","clientId","id","emitEvent","message","stringify","_cmdStart","_cmdSend","idOrArray","msgStr","Array","isArray","forEach","send","_cmdClose","close","init","domainManager","hasDomain","registerDomain","major","minor","registerCommand","name","description","registerEvent","exports"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*eslint-env node */\n/*jslint node: true */\n\n\nvar WebSocketServer = require(\"ws\").Server,\n    _ = require(\"lodash\");\n\n/**\n * @private\n * The WebSocket server we listen for incoming connections on.\n * @type {?WebSocketServer}\n */\nvar _wsServer;\n\n/**\n * @private\n * The Brackets domain manager for registering node extensions.\n * @type {?DomainManager}\n */\nvar _domainManager;\n\n/**\n * @private\n * The ID that should be allocated to the next client that connects to the transport.\n * @type {number}\n */\nvar _nextClientId = 1;\n\n/**\n * @private\n * A map of client IDs to the URL and WebSocket for the given ID.\n * @type {Object.<number, {id: number, url: string, socket: WebSocket}>}\n */\nvar _clients = {};\n\n// This must match the port declared in NodeSocketTransport.js.\n// TODO: randomize this?\nvar SOCKET_PORT = 8123;\n\n/**\n * @private\n * Returns the client info for a given WebSocket, or null if that socket isn't registered.\n * @param {WebSocket} ws\n * @return {?{id: number, url: string, socket: WebSocket}}\n */\nfunction _clientForSocket(ws) {\n    return _.find(_clients, function (client) {\n        return (client.socket === ws);\n    });\n}\n\n/**\n * @private\n * Creates the WebSocketServer and handles incoming connections.\n */\nfunction _createServer() {\n    if (!_wsServer) {\n        // TODO: make port configurable, or use random port\n        _wsServer = new WebSocketServer({port: SOCKET_PORT});\n        _wsServer.on(\"connection\", function (ws) {\n            ws.on(\"message\", function (msg) {\n                console.log(\"WebSocketServer - received - \" + msg);\n                var msgObj;\n                try {\n                    msgObj = JSON.parse(msg);\n                } catch (e) {\n                    console.error(\"nodeSocketTransport: Error parsing message: \" + msg);\n                    return;\n                }\n\n                // See the comment in NodeSocketTransportRemote.connect() for why we have an extra\n                // layer of transport-layer message objects surrounding the protocol messaging.\n\n                if (msgObj.type === \"connect\") {\n                    if (!msgObj.url) {\n                        console.error(\"nodeSocketTransport: Malformed connect message: \" + msg);\n                        return;\n                    }\n                    var clientId = _nextClientId++;\n                    _clients[clientId] = {\n                        id: clientId,\n                        url: msgObj.url,\n                        socket: ws\n                    };\n                    console.log(\"emitting connect event\");\n                    _domainManager.emitEvent(\"nodeSocketTransport\", \"connect\", [clientId, msgObj.url]);\n                } else if (msgObj.type === \"message\") {\n                    var client = _clientForSocket(ws);\n                    if (client) {\n                        _domainManager.emitEvent(\"nodeSocketTransport\", \"message\", [client.id, msgObj.message]);\n                    } else {\n                        console.error(\"nodeSocketTransport: Couldn't locate client for message: \" + msg);\n                    }\n                } else {\n                    console.error(\"nodeSocketTransport: Got bad socket message type: \" + msg);\n                }\n            }).on(\"error\", function (e) {\n                // TODO: emit error event\n                var client = _clientForSocket(ws);\n                console.error(\"nodeSocketTransport: Error on socket for client \" + JSON.stringify(client) + \": \" + e);\n            }).on(\"close\", function () {\n                var client = _clientForSocket(ws);\n                if (client) {\n                    _domainManager.emitEvent(\"nodeSocketTransport\", \"close\", [client.id]);\n                    delete _clients[client.id];\n                } else {\n                    console.error(\"nodeSocketTransport: Socket closed, but couldn't locate client\");\n                }\n            });\n        }).on(\"error\", function (e) {\n            // TODO: emit error event\n            console.error(\"nodeSocketTransport: Error on live preview server creation: \" + e);\n        });\n    }\n}\n\n/**\n * Initializes the socket server.\n * @param {string} url\n */\nfunction _cmdStart(url) {\n    _createServer();\n}\n\n/**\n * Sends a transport-layer message over the socket.\n * @param {number|Array.<number>} idOrArray A client ID or array of client IDs to send the message to.\n * @param {string} msgStr The message to send as a JSON string.\n */\nfunction _cmdSend(idOrArray, msgStr) {\n    if (!Array.isArray(idOrArray)) {\n        idOrArray = [idOrArray];\n    }\n    idOrArray.forEach(function (id) {\n        var client = _clients[id];\n        if (!client) {\n            console.error(\"nodeSocketTransport: Couldn't find client ID: \" + id);\n        } else {\n            client.socket.send(msgStr);\n        }\n    });\n}\n\n/**\n * Closes the connection for a given client ID.\n * @param {number} clientId\n */\nfunction _cmdClose(clientId) {\n    var client = _clients[clientId];\n    if (client) {\n        client.socket.close();\n        delete _clients[clientId];\n    }\n}\n\n/**\n * Initializes the domain and registers commands.\n * @param {DomainManager} domainManager The DomainManager for the server\n */\nfunction init(domainManager) {\n    _domainManager = domainManager;\n    if (!domainManager.hasDomain(\"nodeSocketTransport\")) {\n        domainManager.registerDomain(\"nodeSocketTransport\", {major: 0, minor: 1});\n    }\n    domainManager.registerCommand(\n        \"nodeSocketTransport\",      // domain name\n        \"start\",       // command name\n        _cmdStart,     // command handler function\n        false,          // this command is synchronous in Node\n        \"Creates the WS server\",\n        []\n    );\n    domainManager.registerCommand(\n        \"nodeSocketTransport\",      // domain name\n        \"send\",         // command name\n        _cmdSend,       // command handler function\n        false,          // this command is synchronous in Node\n        \"Sends a message to a given client or list of clients\",\n        [\n            {name: \"idOrArray\", type: \"number|Array.<number>\", description: \"id or array of ids to send the message to\"},\n            {name: \"message\", type: \"string\", description: \"JSON message to send\"}\n        ],\n        []\n    );\n    domainManager.registerCommand(\n        \"nodeSocketTransport\",      // domain name\n        \"close\",         // command name\n        _cmdClose,       // command handler function\n        false,          // this command is synchronous in Node\n        \"Closes the connection to a given client\",\n        [\n            {name: \"id\", type: \"number\", description: \"id of connection to close\"}\n        ],\n        []\n    );\n    domainManager.registerEvent(\n        \"nodeSocketTransport\",\n        \"connect\",\n        [\n            {name: \"clientID\", type: \"number\", description: \"ID of live preview page connecting to live development\"},\n            {name: \"url\", type: \"string\", description: \"URL of page that live preview is connecting from\"}\n        ]\n    );\n    domainManager.registerEvent(\n        \"nodeSocketTransport\",\n        \"message\",\n        [\n            {name: \"clientID\", type: \"number\", description: \"ID of live preview page sending message\"},\n            {name: \"msg\", type: \"string\", description: \"JSON message from client page\"}\n        ]\n    );\n    domainManager.registerEvent(\n        \"nodeSocketTransport\",\n        \"close\",\n        [\n            {name: \"clientID\", type: \"number\", description: \"ID of live preview page being closed\"}\n        ]\n    );\n}\n\nexports.init = init;\n"],"file":"NodeSocketTransportDomain.js"}
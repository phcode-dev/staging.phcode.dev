{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/transports/ServiceWorkerTransport.js"],"names":["define","require","exports","module","LiveDevProtocol","EventDispatcher","Metrics","METRIC_SEND_INTERVAL_MS","transportMessagesRecvCount","transportMessagesSendCount","transportMessagesRecvSizeB","transportMessagesSendSizeB","setInterval","countEvent","EVENT_TYPE","LIVE_PREVIEW","ServiceWorkerTransportRemote","BROADCAST_CHANNEL_ID","Math","round","random","_broadcastChannel","BroadcastChannel","getRemoteScript","Phoenix","PHOENIX_INSTANCE_ID","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","logger","loggingOptions","logLivePreview","makeEventDispatcher","start","addEventListener","postMessage","type","onmessage","event","window","livePreview","log","data","trigger","clientID","url","message","length","console","error","close","send","clientIDs"],"mappings":"AAwBAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,MAAMC,gBAAuBH,QAAQ,6DACjCI,gBAAkBJ,QAAQ,yBAC1BK,QAAUL,QAAQ,iBAEhBM,wBAA0B,IAEhC,IAAIC,2BAA6B,EAC7BC,2BAA6B,EAC7BC,2BAA6B,EAC7BC,2BAA6B,EAKjCC,YAAY,KACLJ,2BAA6B,IAC5BF,QAAQO,WAAWP,QAAQQ,WAAWC,aAAc,UAChD,YAAaN,4BACjBH,QAAQO,WAAWP,QAAQQ,WAAWC,aAAc,UAChD,YAAaP,4BACjBF,QAAQO,WAAWP,QAAQQ,WAAWC,aAAc,UAChD,YAAaJ,4BACjBL,QAAQO,WAAWP,QAAQQ,WAAWC,aAAc,UAChD,YAAaL,4BACjBF,2BAA6B,EAC7BC,2BAA6B,EAC7BC,2BAA6B,EAC7BC,2BAA6B,IAvBL,KA4BhC,MAAMK,6BAA+Bf,QAAQ,uEAGvCgB,wBAA0BC,KAAKC,MAAqB,KAAdD,KAAKE,wBACjD,IAAIC,kBAAoB,IAAIC,iBAAiBL,sBAM7C,SAASM,kBACL,MAAO,sCAC8BC,QAAQC,yEACMR,iFACOb,gBAAgBsB,sFAC/BC,OAAOC,eAAeC,oBAC7Db,6BACA,KAGRX,gBAAgByB,oBAAoB5B,SAGpCA,QAAQqB,gBAAkBA,gBAE1BrB,QAAQ6B,MAAQ,WAIZC,iBAAkB,eAAgB,WAC9BX,kBAAkBY,YAAY,CAC1BC,KAAM,oBAGdb,kBAAkBc,UAAY,CAACC,QAC3BC,OAAOV,OAAOW,YAAYC,IACtB,yEAA0EH,MAAMI,MACpF,MAAMN,KAAOE,MAAMI,KAAKN,KACxB,OAAQA,MACR,IAAK,kBAAmBhC,QAAQuC,QAAQ,UAAW,CAACL,MAAMI,KAAKE,SAAUN,MAAMI,KAAKG,MAAO,MAC3F,IAAK,kBACD,MAAMC,QAAUR,MAAMI,KAAKI,SAAW,GACtC1C,QAAQuC,QAAQ,UAAW,CAACL,MAAMI,KAAKE,SAAUE,UACjDlC,4BAA0DkC,QAAQC,OAClE,MACJ,IAAK,gBAAiB3C,QAAQuC,QAAQ,QAAS,CAACL,MAAMI,KAAKE,WAAY,MACvE,QAASI,QAAQC,MAAM,wEAAyEX,OAEhG5B,gCAIRN,QAAQ8C,MAAQ,aAIhB9C,QAAQ+C,KAAO,SAAUC,UAAWN,SAChCA,QAAUA,SAAW,GACrBvB,kBAAkBY,YAAY,CAC1BC,KAAM,uBACNgB,UAAAA,UACAN,QAAAA,UAEJnC,6BACAE,4BAA0DiC,QAAQC","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// This transport provides a connection between Brackets and a live browser preview via service worker\n// as the intermediary. We also rely on an injected script in the browser for the other end of the transport.\n/*globals logger, Phoenix*/\ndefine(function (require, exports, module) {\n\n\n    const LiveDevProtocol      = require(\"LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        Metrics = require(\"utils/Metrics\");\n\n    const METRIC_SEND_INTERVAL_MS = 1000;\n\n    let transportMessagesRecvCount = 0,\n        transportMessagesSendCount = 0,\n        transportMessagesRecvSizeB = 0,\n        transportMessagesSendSizeB = 0;\n\n    // mix panel and Google Analytics is sending too many request and seems to not have client side aggregation\n    // like core analytics. So we do our own aggregation and send metrics only atmost once a second.\n    // We could remove this once we moe fully to core analytics.\n    setInterval(()=>{\n        if(transportMessagesRecvCount > 0){\n            Metrics.countEvent(Metrics.EVENT_TYPE.LIVE_PREVIEW, \"message\",\n                \"sendCount\", transportMessagesSendCount);\n            Metrics.countEvent(Metrics.EVENT_TYPE.LIVE_PREVIEW, \"message\",\n                \"recvCount\", transportMessagesRecvCount);\n            Metrics.countEvent(Metrics.EVENT_TYPE.LIVE_PREVIEW, \"message\",\n                \"sentBytes\", transportMessagesSendSizeB);\n            Metrics.countEvent(Metrics.EVENT_TYPE.LIVE_PREVIEW, \"message\",\n                \"recvBytes\", transportMessagesRecvSizeB);\n            transportMessagesRecvCount = 0;\n            transportMessagesSendCount = 0;\n            transportMessagesRecvSizeB = 0;\n            transportMessagesSendSizeB = 0;\n        }\n    }, METRIC_SEND_INTERVAL_MS);\n\n    // The script that will be injected into the previewed HTML to handle the other side of the socket connection.\n    const ServiceWorkerTransportRemote = require(\"text!LiveDevelopment/BrowserScripts/ServiceWorkerTransportRemote.js\");\n\n    // Events - setup the service worker communication channel.\n    const BROADCAST_CHANNEL_ID = `${Math.round( Math.random()*1000000000000)}_livePreview`;\n    let _broadcastChannel = new BroadcastChannel(BROADCAST_CHANNEL_ID);\n\n    /**\n     * Returns the script that should be injected into the browser to handle the other end of the transport.\n     * @return {string}\n     */\n    function getRemoteScript() {\n        return \"\\n\" +\n            `window.PHOENIX_INSTANCE_ID = \"${Phoenix.PHOENIX_INSTANCE_ID}\";\\n` +\n            `window.LIVE_PREVIEW_BROADCAST_CHANNEL_ID = \"${BROADCAST_CHANNEL_ID}\";\\n` +\n            `window.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME = \"${LiveDevProtocol.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME}\";\\n` +\n            `window.LIVE_PREVIEW_DEBUG_ENABLED = ${logger.loggingOptions.logLivePreview};\\n` +\n            ServiceWorkerTransportRemote +\n            \"\\n\";\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // Exports\n    exports.getRemoteScript = getRemoteScript;\n\n    exports.start = function () {\n        // Listen to the response\n        // attach to browser tab/window closing event so that we send a cleanup request\n        // to the service worker for the comm ports\n        addEventListener( 'beforeunload', function() {\n            _broadcastChannel.postMessage({\n                type: 'PHOENIX_CLOSE'\n            });\n        });\n        _broadcastChannel.onmessage = (event) => {\n            window.logger.livePreview.log(\n                \"Live Preview: Phoenix received event from Browser preview tab/iframe: \", event.data);\n            const type = event.data.type;\n            switch (type) {\n            case 'BROWSER_CONNECT': exports.trigger('connect', [event.data.clientID, event.data.url]); break;\n            case 'BROWSER_MESSAGE':\n                const message = event.data.message || \"\";\n                exports.trigger('message', [event.data.clientID, message]);\n                transportMessagesRecvSizeB = transportMessagesRecvSizeB + message.length;\n                break;\n            case 'BROWSER_CLOSE': exports.trigger('close', [event.data.clientID]); break;\n            default: console.error(\"ServiceWorkerTransport received unknown message from Browser preview:\", event);\n            }\n            transportMessagesRecvCount++;\n        };\n    };\n\n    exports.close = function () {\n        // no-op the broadcast channel is never broken even though live preview may be on or off.\n    };\n\n    exports.send = function (clientIDs, message) {\n        message = message || \"\";\n        _broadcastChannel.postMessage({\n            type: 'MESSAGE_FROM_PHOENIX',\n            clientIDs,\n            message\n        });\n        transportMessagesSendCount ++;\n        transportMessagesSendSizeB = transportMessagesSendSizeB + message.length;\n    };\n\n});\n"],"file":"ServiceWorkerTransport.js"}
{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol.js"],"names":["define","require","exports","module","EventDispatcher","LiveDevProtocolRemote","DocumentObserver","RemoteFunctions","EditorManager","LiveDevMultiBrowser","HTMLInstrumentation","_connections","_transport","_nextMsgId","_responseDeferreds","getConnectionIds","Object","keys","_receive","clientId","msgStr","msg","JSON","parse","event","method","deferred","id","error","reject","resolve","tagId","editor","getActiveEditor","position","getPositionFromTagId","parseInt","setCursorPos","line","ch","trigger","_send","clients","result","$","Deferred","send","stringify","promise","_connect","url","_close","setTransport","transport","off","on","start","getRemoteFunctionsScript","script","config","getRemoteScript","transportScript","remoteFunctionsScript","evaluate","params","expression","setStylesheetText","text","getStylesheetText","reload","ignoreCache","navigate","close","closeAllConnections","forEach","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Provides the protocol that Brackets uses to talk to a browser instance for live development.\n * Protocol methods are converted to a JSON message format, which is then sent over a provided\n * low-level transport and interpreted in the browser. For messages that expect a response, the\n * response is returned through a promise as an object. Scripts that implement remote logic are\n * provided during the instrumentation stage by \"getRemoteFunctions()\".\n *\n * Events raised by the remote browser are dispatched as jQuery events which type is equal to the 'method'\n * property. The received message object is dispatched as the first parameter and enriched with a\n * 'clientId' property being the client ID of the remote browser.\n *\n * It keeps active connections which are  updated when receiving \"connect\" and \"close\" from the\n * underlying transport. Events \"Connection.connect\"/\"Connection.close\" are triggered as\n * propagation of transport's \"connect\"/\"close\".\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var EventDispatcher = require(\"utils/EventDispatcher\");\n\n    // Text of the script we'll inject into the browser that handles protocol requests.\n    var LiveDevProtocolRemote = require(\"text!LiveDevelopment/MultiBrowserImpl/protocol/remote/LiveDevProtocolRemote.js\"),\n        DocumentObserver      = require(\"text!LiveDevelopment/MultiBrowserImpl/protocol/remote/DocumentObserver.js\"),\n        RemoteFunctions       = require(\"text!LiveDevelopment/Agents/RemoteFunctions.js\"),\n        EditorManager         = require(\"editor/EditorManager\"),\n        LiveDevMultiBrowser   = require(\"LiveDevelopment/LiveDevMultiBrowser\"),\n        HTMLInstrumentation   = require(\"language/HTMLInstrumentation\");\n\n    /**\n     * @private\n     * Active connections.\n     * @type {Object}\n     */\n    var _connections = {};\n\n    /**\n     * @private\n     * The low-level transport we're communicating over, set by `setTransport()`.\n     * @type {{start: function(), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}}\n     */\n    var _transport = null;\n\n    /**\n     * @private\n     * A unique message serial number, used to match up responses with request messages.\n     * @type {number}\n     */\n    var _nextMsgId = 1;\n\n    /**\n     * @private\n     * A map of response IDs to deferreds, for messages that are awaiting responses.\n     * @type {Object}\n     */\n    var _responseDeferreds = {};\n\n    /**\n     * Returns an array of the client IDs that are being managed by this live document.\n     * @return {Array.<number>}\n     */\n    function getConnectionIds() {\n        return Object.keys(_connections);\n    }\n\n    /**\n     * @private\n     * Handles a message received from the remote protocol handler via the transport.\n     * If the message has an `id` field, it's assumed to be a response to a previous\n     * request, and will be passed along to the original promise returned by `_send()`.\n     * Otherwise, it's treated as an event and dispatched.\n     * TODO: we should probably have a way of returning the results from all clients, not just the first?\n     *\n     * @param {number} clientId ID of the client that sent the message\n     * @param {string} msg The message that was sent, in JSON string format\n     */\n    function _receive(clientId, msgStr) {\n        var msg = JSON.parse(msgStr),\n            event = msg.method || \"event\",\n            deferred;\n        if (msg.id) {\n            deferred = _responseDeferreds[msg.id];\n            if (deferred) {\n                delete _responseDeferreds[msg.id];\n                if (msg.error) {\n                    deferred.reject(msg);\n                } else {\n                    deferred.resolve(msg);\n                }\n            }\n        } else if (msg.tagId) {\n            var editor = EditorManager.getActiveEditor(),\n                position = HTMLInstrumentation.getPositionFromTagId(editor, parseInt(msg.tagId, 10));\n            if (position) {\n                editor.setCursorPos(position.line, position.ch, true);\n            }\n        } else {\n            // enrich received message with clientId\n            msg.clientId = clientId;\n            exports.trigger(event, msg);\n        }\n    }\n\n    /**\n     * @private\n     * Dispatches a message to the remote protocol handler via the transport.\n     *\n     * @param {Object} msg The message to send.\n     * @param {number|Array.<number>} idOrArray ID or IDs of the client(s) that should\n     *     receive the message.\n     * @return {$.Promise} A promise that's fulfilled when the response to the message is received.\n     */\n    function _send(msg, clients) {\n        var id = _nextMsgId++,\n            result = new $.Deferred();\n\n        // broadcast if there are no specific clients\n        clients = clients || getConnectionIds();\n        msg.id = id;\n        _responseDeferreds[id] = result;\n        _transport.send(clients, JSON.stringify(msg));\n        return result.promise();\n    }\n\n     /**\n     * @private\n     * Handles when a connection is made to the live development protocol handler.\n     * Injects the RemoteFunctions script in order to provide highlighting and live DOM editing functionality.\n     * Records the connection's client ID and triggers the \"Coonnection.connect\" event.\n     * @param {number} clientId\n     * @param {string} url\n     */\n    function _connect(clientId, url) {\n        // add new connections\n        // TODO: check URL\n        _connections[clientId] = true;\n\n        exports.trigger(\"ConnectionConnect\", {\n            clientId: clientId,\n            url: url\n        });\n    }\n\n    /**\n     * @private\n     * Handles when a connection is closed.\n     * @param {number} clientId\n     */\n    function _close(clientId) {\n        delete _connections[clientId];\n        exports.trigger(\"ConnectionClose\", {\n            clientId: clientId\n        });\n    }\n\n\n    /**\n     * Sets the transport that should be used by the protocol. See `LiveDevelopment.setTransport()`\n     * for more detail on the transport.\n     * @param {{start: function(string), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}} transport\n     */\n    function setTransport(transport) {\n        if (_transport) {\n            _transport.off(\".livedev\");\n        }\n        _transport = transport;\n\n        _transport\n            .on(\"connect.livedev\", function (event, msg) {\n                _connect(msg[0], msg[1]);\n            })\n            .on(\"message.livedev\", function (event, msg) {\n                _receive(msg[0], msg[1]);\n            })\n            .on(\"close.livedev\", function (event, msg) {\n                _close(msg[0]);\n            });\n        _transport.start();\n    }\n\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to implement remote commands that handle protocol requests.\n     * Includes the <script> tags.\n     * @return {string}\n     */\n    function getRemoteFunctionsScript() {\n        var script = \"\";\n        // Inject DocumentObserver into the browser (tracks related documents)\n        script += DocumentObserver;\n        // Inject remote functions into the browser.\n        script += \"window._LD=(\" + RemoteFunctions + \"(\" + JSON.stringify(LiveDevMultiBrowser.config) + \"))\";\n        return \"<script>\\n\" + script + \"</script>\\n\";\n    }\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to handle protocol requests. Includes the <script> tags.\n     * This script will also include the script required by the transport, if any.\n     * @return {string}\n     */\n    function getRemoteScript() {\n        var transportScript = _transport.getRemoteScript() || \"\";\n        var remoteFunctionsScript = getRemoteFunctionsScript() || \"\";\n        return transportScript +\n            \"<script>\\n\" + LiveDevProtocolRemote + \"</script>\\n\" +\n            remoteFunctionsScript;\n    }\n\n    /**\n     * Protocol method. Evaluates the given script in the browser (in global context), and returns a promise\n     * that will be fulfilled with the result of the script, if any.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should evaluate\n     *      the script.\n     * @param {string} script The script to evaluate.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the evaluation.\n     */\n    function evaluate(script, clients) {\n        return _send(\n            {\n                method: \"Runtime.evaluate\",\n                params: {\n                    expression: script\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Reloads a CSS styleseet in the browser (by replacing its text) given its url.\n     * @param {string} url Absolute URL of the stylesheet\n     * @param {string} text The new text of the stylesheet\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should evaluate\n     *      the script.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the evaluation.\n     */\n    function setStylesheetText(url, text, clients) {\n        return _send(\n            {\n                method: \"CSS.setStylesheetText\",\n                params: {\n                    url: url,\n                    text: text\n                }\n            }\n        );\n    }\n\n     /**\n     * Protocol method. Rretrieves the content of a given stylesheet (for unit testing)\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should navigate to the given URL.\n     * @param {string} url Absolute URL that identifies the stylesheet.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function getStylesheetText(url, clients) {\n        return _send(\n            {\n                method: \"CSS.getStylesheetText\",\n                params: {\n                    url: url\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Reloads the page that is currently loaded into the browser, optionally ignoring cache.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should reload the page.\n     * @param {boolean} ignoreCache If true, browser cache is ignored.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function reload(ignoreCache, clients) {\n        return _send(\n            {\n                method: \"Page.reload\",\n                params: {\n                    ignoreCache: true\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Navigates current page to the given URL.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should navigate to the given URL.\n     * @param {string} url URL to navigate the page to.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function navigate(url, clients) {\n        return _send(\n            {\n                method: \"Page.navigate\",\n                params: {\n                    url: url\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Closes the connection to the given client. Proxies to the transport.\n     * @param {number} clientId\n     */\n    function close(clientId) {\n        _transport.close(clientId);\n    }\n\n    function closeAllConnections() {\n        getConnectionIds().forEach(function (clientId) {\n            close(clientId);\n        });\n        _connections = {};\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // public API\n    exports.setTransport = setTransport;\n    exports.getRemoteScript = getRemoteScript;\n    exports.evaluate = evaluate;\n    exports.setStylesheetText = setStylesheetText;\n    exports.getStylesheetText = getStylesheetText;\n    exports.reload = reload;\n    exports.navigate = navigate;\n    exports.close = close;\n    exports.getConnectionIds = getConnectionIds;\n    exports.closeAllConnections = closeAllConnections;\n});\n"],"file":"LiveDevProtocol.js"}
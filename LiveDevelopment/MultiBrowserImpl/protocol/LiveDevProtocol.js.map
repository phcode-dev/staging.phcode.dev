{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol.js"],"names":["define","require","exports","module","EventDispatcher","LiveDevProtocolRemote","DocumentObserver","RemoteFunctions","EditorManager","LiveDevMultiBrowser","HTMLInstrumentation","FileViewController","LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","EVENT_LIVE_PREVIEW_CLICKED","EVENT_LIVE_PREVIEW_RELOAD","_connections","_transport","_nextMsgId","_responseDeferreds","getConnectionIds","Object","keys","_tagSelectedInLivePreview","tagId","liveDoc","getCurrentLiveDoc","editor","getActiveEditor","liveDocPath","doc","file","fullPath","activeEditorDocPath","document","selectInActiveDocument","activeEditor","activeFullEditor","getCurrentFullEditor","position","getPositionFromTagId","parseInt","setCursorPos","line","ch","openAndSelectDocument","PROJECT_MANAGER","done","_receive","clientId","msgStr","msg","JSON","parse","event","method","deferred","id","error","reject","resolve","clicked","trigger","_send","clients","result","$","Deferred","send","stringify","promise","_connect","url","_close","setTransport","transport","off","on","start","_getRemoteFunctionsScript","script","config","getRemoteScriptContents","transportScript","getRemoteScript","remoteFunctionsScript","evaluate","params","expression","setStylesheetText","text","getStylesheetText","reload","ignoreCache","navigate","close","closeAllConnections","forEach","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Provides the protocol that Brackets uses to talk to a browser instance for live development.\n * Protocol methods are converted to a JSON message format, which is then sent over a provided\n * low-level transport and interpreted in the browser. For messages that expect a response, the\n * response is returned through a promise as an object. Scripts that implement remote logic are\n * provided during the instrumentation stage by \"getRemoteFunctions()\".\n *\n * Events raised by the remote browser are dispatched as jQuery events which type is equal to the 'method'\n * property. The received message object is dispatched as the first parameter and enriched with a\n * 'clientId' property being the client ID of the remote browser.\n *\n * It keeps active connections which are  updated when receiving \"connect\" and \"close\" from the\n * underlying transport. Events \"Connection.connect\"/\"Connection.close\" are triggered as\n * propagation of transport's \"connect\"/\"close\".\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    const EventDispatcher = require(\"utils/EventDispatcher\");\n\n    // Text of the script we'll inject into the browser that handles protocol requests.\n    const LiveDevProtocolRemote = require(\"text!LiveDevelopment/BrowserScripts/LiveDevProtocolRemote.js\"),\n        DocumentObserver      = require(\"text!LiveDevelopment/BrowserScripts/DocumentObserver.js\"),\n        RemoteFunctions       = require(\"text!LiveDevelopment/BrowserScripts/RemoteFunctions.js\"),\n        EditorManager         = require(\"editor/EditorManager\"),\n        LiveDevMultiBrowser   = require(\"LiveDevelopment/LiveDevMultiBrowser\"),\n        HTMLInstrumentation   = require(\"LiveDevelopment/MultiBrowserImpl/language/HTMLInstrumentation\"),\n        FileViewController    = require(\"project/FileViewController\");\n\n    const LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME = \"phoenix_live_preview_scripts_instrumented_345Tt96G4.js\";\n    const LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME = \"pageLoaderWorker_345Tt96G4.js\";\n\n    const EVENT_LIVE_PREVIEW_CLICKED = \"livePreviewClicked\",\n        EVENT_LIVE_PREVIEW_RELOAD = \"livePreviewReload\";\n\n    /**\n     * @private\n     * Active connections.\n     * @type {Object}\n     */\n    var _connections = {};\n\n    /**\n     * @private\n     * The low-level transport we're communicating over, set by `setTransport()`.\n     * @type {{start: function(), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}}\n     */\n    var _transport = null;\n\n    /**\n     * @private\n     * A unique message serial number, used to match up responses with request messages.\n     * @type {number}\n     */\n    var _nextMsgId = 1;\n\n    /**\n     * @private\n     * A map of response IDs to deferreds, for messages that are awaiting responses.\n     * @type {Object}\n     */\n    var _responseDeferreds = {};\n\n    /**\n     * Returns an array of the client IDs that are being managed by this live document.\n     * @return {Array.<number>}\n     */\n    function getConnectionIds() {\n        return Object.keys(_connections);\n    }\n\n    function _tagSelectedInLivePreview(tagId) {\n        const liveDoc = LiveDevMultiBrowser.getCurrentLiveDoc(),\n            editor = EditorManager.getActiveEditor();\n        const liveDocPath = liveDoc ? liveDoc.doc.file.fullPath : null,\n            activeEditorDocPath = editor ? editor.document.file.fullPath : null;\n        function selectInActiveDocument() {\n            // activeEditor can be either a full or inline(Eg. css inline within html) editor\n            const activeEditor = EditorManager.getActiveEditor();\n            const activeFullEditor = EditorManager.getCurrentFullEditor(); // always full editor\n            const position = HTMLInstrumentation.getPositionFromTagId(activeFullEditor, parseInt(tagId, 10));\n            // should we scan all editors for the file path and update selections on every editor?\n            // currently we do it only for active / full editor.\n            if(position &&\n                activeEditor && activeEditor.document.file.fullPath === activeFullEditor.document.file.fullPath) {\n                activeEditor.setCursorPos(position.line, position.ch, true);\n            }\n            if(position && activeFullEditor) {\n                activeFullEditor.setCursorPos(position.line, position.ch, true);\n            }\n        }\n        if(liveDocPath !== activeEditorDocPath) {\n            FileViewController.openAndSelectDocument(liveDocPath, FileViewController.PROJECT_MANAGER)\n                .done(selectInActiveDocument);\n        } else {\n            selectInActiveDocument();\n        }\n    }\n\n    /**\n     * @private\n     * Handles a message received from the remote protocol handler via the transport.\n     * If the message has an `id` field, it's assumed to be a response to a previous\n     * request, and will be passed along to the original promise returned by `_send()`.\n     * Otherwise, it's treated as an event and dispatched.\n     * TODO: we should probably have a way of returning the results from all clients, not just the first?\n     *\n     * @param {number} clientId ID of the client that sent the message\n     * @param {string} msg The message that was sent, in JSON string format\n     */\n    function _receive(clientId, msgStr) {\n        var msg = JSON.parse(msgStr),\n            event = msg.method || \"event\",\n            deferred;\n        if (msg.id) {\n            deferred = _responseDeferreds[msg.id];\n            if (deferred) {\n                delete _responseDeferreds[msg.id];\n                if (msg.error) {\n                    deferred.reject(msg);\n                } else {\n                    deferred.resolve(msg);\n                }\n            }\n        } else if (msg.clicked && msg.tagId) {\n            _tagSelectedInLivePreview(msg.tagId);\n            exports.trigger(EVENT_LIVE_PREVIEW_CLICKED, msg);\n        } else {\n            // enrich received message with clientId\n            msg.clientId = clientId;\n            exports.trigger(event, msg);\n        }\n    }\n\n    /**\n     * @private\n     * Dispatches a message to the remote protocol handler via the transport.\n     *\n     * @param {Object} msg The message to send.\n     * @param {number|Array.<number>} idOrArray ID or IDs of the client(s) that should\n     *     receive the message.\n     * @return {$.Promise} A promise that's fulfilled when the response to the message is received.\n     */\n    function _send(msg, clients) {\n        var id = _nextMsgId++,\n            result = new $.Deferred();\n\n        // broadcast if there are no specific clients\n        clients = clients || getConnectionIds();\n        msg.id = id;\n        _responseDeferreds[id] = result;\n        _transport.send(clients, JSON.stringify(msg));\n        return result.promise();\n    }\n\n     /**\n     * @private\n     * Handles when a connection is made to the live development protocol handler.\n     * Injects the RemoteFunctions script in order to provide highlighting and live DOM editing functionality.\n     * Records the connection's client ID and triggers the \"Coonnection.connect\" event.\n     * @param {number} clientId\n     * @param {string} url\n     */\n    function _connect(clientId, url) {\n        // add new connections\n        // TODO: check URL\n        _connections[clientId] = true;\n\n        exports.trigger(\"ConnectionConnect\", {\n            clientId: clientId,\n            url: url\n        });\n    }\n\n    /**\n     * @private\n     * Handles when a connection is closed.\n     * @param {number} clientId\n     */\n    function _close(clientId) {\n        if(!_connections[clientId]){\n            return;\n        }\n        delete _connections[clientId];\n        exports.trigger(\"ConnectionClose\", {\n            clientId: clientId\n        });\n    }\n\n\n    /**\n     * Sets the transport that should be used by the protocol. See `LiveDevelopment.setTransport()`\n     * for more detail on the transport.\n     * @param {{start: function(string), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}} transport\n     */\n    function setTransport(transport) {\n        if (_transport) {\n            _transport.off(\".livedev\");\n        }\n        _transport = transport;\n\n        _transport\n            .on(\"connect.livedev\", function (event, msg) {\n                _connect(msg[0], msg[1]);\n            })\n            .on(\"message.livedev\", function (event, msg) {\n                _receive(msg[0], msg[1]);\n            })\n            .on(\"close.livedev\", function (event, msg) {\n                _close(msg[0]);\n            });\n        _transport.start();\n    }\n\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to implement remote commands that handle protocol requests.\n     * Includes the <script> tags.\n     * @return {string}\n     */\n    function _getRemoteFunctionsScript() {\n        let script = \"\";\n        // Inject DocumentObserver into the browser (tracks related documents)\n        script += DocumentObserver;\n        // Inject remote functions into the browser.\n        script += \"\\nwindow._LD=(\" + RemoteFunctions + \"(\" + JSON.stringify(LiveDevMultiBrowser.config) + \"))\";\n        return \"\\n\" + script + \"\\n\";\n    }\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to handle protocol requests. Includes the <script> tags.\n     * This script will also include the script required by the transport, if any.\n     * @return {string}\n     */\n    function getRemoteScriptContents() {\n        const transportScript = _transport.getRemoteScript() || \"\";\n        const remoteFunctionsScript = _getRemoteFunctionsScript() || \"\";\n        return transportScript +\n            \"\\n\" + LiveDevProtocolRemote + \"\\n\" +\n            remoteFunctionsScript;\n    }\n\n    /**\n     * Returns a script that should be injected into the HTML that's launched in the\n     * browser in order to handle protocol requests. Includes the <script> tags.\n     * This script will also include the script required by the transport, if any.\n     * @return {string}\n     */\n    function getRemoteScript() {\n        // give a wrong random file name that wont have a possibility of an actual file name\n        return `\\n\\t\\t<script src=\"${LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME}\"></script>`;\n    }\n\n    /**\n     * Protocol method. Evaluates the given script in the browser (in global context), and returns a promise\n     * that will be fulfilled with the result of the script, if any.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should evaluate\n     *      the script.\n     * @param {string} script The script to evaluate.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the evaluation.\n     */\n    function evaluate(script, clients) {\n        return _send(\n            {\n                method: \"Runtime.evaluate\",\n                params: {\n                    expression: script\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Reloads a CSS styleseet in the browser (by replacing its text) given its url.\n     * @param {string} url Absolute URL of the stylesheet\n     * @param {string} text The new text of the stylesheet\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should evaluate\n     *      the script.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the evaluation.\n     */\n    function setStylesheetText(url, text, clients) {\n        return _send(\n            {\n                method: \"CSS.setStylesheetText\",\n                params: {\n                    url: url,\n                    text: text\n                }\n            }\n        );\n    }\n\n     /**\n     * Protocol method. Rretrieves the content of a given stylesheet (for unit testing)\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should navigate to the given URL.\n     * @param {string} url Absolute URL that identifies the stylesheet.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function getStylesheetText(url, clients) {\n        return _send(\n            {\n                method: \"CSS.getStylesheetText\",\n                params: {\n                    url: url\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Reloads the page that is currently loaded into the browser, optionally ignoring cache.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should reload the page.\n     * @param {boolean} ignoreCache If true, browser cache is ignored.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function reload(ignoreCache, clients) {\n        exports.trigger(EVENT_LIVE_PREVIEW_RELOAD, clients);\n        return _send(\n            {\n                method: \"Page.reload\",\n                params: {\n                    ignoreCache: true\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Protocol method. Navigates current page to the given URL.\n     * @param {number|Array.<number>} clients A client ID or array of client IDs that should navigate to the given URL.\n     * @param {string} url URL to navigate the page to.\n     * @return {$.Promise} A promise that's resolved with the return value from the first client that responds\n     *      to the method.\n     */\n    function navigate(url, clients) {\n        return _send(\n            {\n                method: \"Page.navigate\",\n                params: {\n                    url: url\n                }\n            },\n            clients\n        );\n    }\n\n    /**\n     * Closes the connection to the given client. Proxies to the transport.\n     * @param {number} clientId\n     */\n    function close(clientId) {\n        _transport.close(clientId);\n    }\n\n    function closeAllConnections() {\n        getConnectionIds().forEach(function (clientId) {\n            close(clientId);\n        });\n        _connections = {};\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // public API\n    exports.setTransport = setTransport;\n    exports.getRemoteScript = getRemoteScript;\n    exports.getRemoteScriptContents = getRemoteScriptContents;\n    exports.evaluate = evaluate;\n    exports.setStylesheetText = setStylesheetText;\n    exports.getStylesheetText = getStylesheetText;\n    exports.reload = reload;\n    exports.navigate = navigate;\n    exports.close = close;\n    exports.getConnectionIds = getConnectionIds;\n    exports.closeAllConnections = closeAllConnections;\n    exports.LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME = LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME;\n    exports.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME = LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME;\n    exports.EVENT_LIVE_PREVIEW_CLICKED = EVENT_LIVE_PREVIEW_CLICKED;\n    exports.EVENT_LIVE_PREVIEW_RELOAD = EVENT_LIVE_PREVIEW_RELOAD;\n});\n"],"file":"LiveDevProtocol.js"}
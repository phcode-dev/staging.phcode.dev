{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/protocol/remote/DocumentObserver.js"],"names":["global","ProtocolManager","_Brackets_LiveDev_ProtocolManager","_document","_transport","related","rel","scripts","stylesheets","i","s","j","length","src","traverseRules","_traverseRules","sheet","base","href","cssRules","e","name","undefined","push","styleSheet","window","document","styleSheets","Utils","isExternalStylesheet","node","nodeName","toUpperCase","isExternalScript","CSS","checkForStylesheetLoaded","self","this","loadInterval","setInterval","clearInterval","notifyStylesheetAdded","onStylesheetRemoved","url","getElementById","parentNode","removeChild","added","current","newStatus","Object","keys","forEach","v","send","JSON","stringify","method","roots","notifyStylesheetRemoved","removed","_onNodesAdded","nodes","_onNodesRemoved","_enableListeners","MutationObserver","WebKitMutationObserver","MozMutationObserver","observer","mutations","mutation","addedNodes","removedNodes","observe","childList","subtree","addEventListener","niLstnr","target","nrLstnr","start","transport","stop","DocumentObserver","setDocumentObserver"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global setInterval, clearInterval */\n\n(function (global) {\n\n\n    var ProtocolManager = global._Brackets_LiveDev_ProtocolManager;\n\n    var _document = null;\n    var _transport;\n\n\n    /**\n     * Retrieves related documents (external CSS and JS files)\n     *\n     * @return {{scripts: object, stylesheets: object}} Related scripts and stylesheets\n     */\n    function related() {\n\n        var rel = {\n            scripts: {},\n            stylesheets: {}\n        };\n        var i;\n        // iterate on document scripts (HTMLCollection doesn't provide forEach iterator).\n        for (i = 0; i < _document.scripts.length; i++) {\n            // add only external scripts\n            if (_document.scripts[i].src) {\n                rel.scripts[_document.scripts[i].src] = true;\n            }\n        }\n\n        var s, j;\n        //traverse @import rules\n        var traverseRules = function _traverseRules(sheet, base) {\n            var i,\n                href = sheet.href,\n                cssRules;\n\n            // Deal with Firefox's SecurityError when accessing sheets\n            // from other domains. Chrome will safely return `undefined`.\n            try {\n                cssRules = sheet.cssRules;\n            } catch (e) {\n                if (e.name !== \"SecurityError\") {\n                    throw e;\n                }\n            }\n\n            if (href && cssRules) {\n                if (rel.stylesheets[href] === undefined) {\n                    rel.stylesheets[href] = [];\n                }\n                rel.stylesheets[href].push(base);\n\n                for (i = 0; i < cssRules.length; i++) {\n                    if (cssRules[i].href) {\n                        traverseRules(cssRules[i].styleSheet, base);\n                    }\n                }\n            }\n        };\n        //iterate on document.stylesheets (StyleSheetList doesn't provide forEach iterator).\n        for (j = 0; j < window.document.styleSheets.length; j++) {\n            s = window.document.styleSheets[j];\n            traverseRules(s, s.href);\n        }\n        return rel;\n    }\n\n    /**\n     * Common functions.\n     */\n    var Utils = {\n\n        isExternalStylesheet: function (node) {\n            return (node.nodeName.toUpperCase() === \"LINK\" && node.rel === \"stylesheet\" && node.href);\n        },\n        isExternalScript: function (node) {\n            return (node.nodeName.toUpperCase() === \"SCRIPT\" && node.src);\n        }\n    };\n\n    /**\n     * CSS related commands and notifications\n     */\n    var CSS = {\n\n            /**\n            * Maintains a map of stylesheets loaded thorugh @import rules and their parents.\n            * Populated by extractImports, consumed by notifyImportsAdded / notifyImportsRemoved.\n            * @type {\n            */\n        stylesheets: {},\n\n            /**\n             * Check the stylesheet that was just added be really loaded\n             * to be able to extract potential import-ed stylesheets.\n             * It invokes notifyStylesheetAdded once the sheet is loaded.\n             * @param  {string} href Absolute URL of the stylesheet.\n             */\n        checkForStylesheetLoaded: function (href) {\n            var self = this;\n\n\n                // Inspect CSSRules for @imports:\n                // styleSheet obejct is required to scan CSSImportRules but\n                // browsers differ on the implementation of MutationObserver interface.\n                // Webkit triggers notifications before stylesheets are loaded,\n                // Firefox does it after loading.\n                // There are also differences on when 'load' event is triggered for\n                // the 'link' nodes. Webkit triggers it before stylesheet is loaded.\n                // Some references to check:\n                //      http://www.phpied.com/when-is-a-stylesheet-really-loaded/\n                //      http://stackoverflow.com/questions/17747616/webkit-dynamically-created-stylesheet-when-does-it-really-load\n                //        http://stackoverflow.com/questions/11425209/are-dom-mutation-observers-slower-than-dom-mutation-events\n                //\n                // TODO: This is just a temporary 'cross-browser' solution, it needs optimization.\n            var loadInterval = setInterval(function () {\n                var i;\n                for (i = 0; i < window.document.styleSheets.length; i++) {\n                    if (window.document.styleSheets[i].href === href) {\n                            //clear interval\n                        clearInterval(loadInterval);\n                            // notify stylesheets added\n                        self.notifyStylesheetAdded(href);\n                        break;\n                    }\n                }\n            }, 50);\n        },\n\n        onStylesheetRemoved: function (url) {\n                // get style node created when setting new text for stylesheet.\n            var s = window.document.getElementById(url);\n                // remove\n            if (s && s.parentNode && s.parentNode.removeChild) {\n                s.parentNode.removeChild(s);\n            }\n        },\n\n            /**\n             * Send a notification for the stylesheet added and\n             * its import-ed styleshets based on document.stylesheets diff\n             * from previous status. It also updates stylesheets status.\n             */\n        notifyStylesheetAdded: function () {\n            var added = {},\n                current,\n                newStatus;\n\n            current = this.stylesheets;\n            newStatus = related().stylesheets;\n\n            Object.keys(newStatus).forEach(function (v, i) {\n                if (!current[v]) {\n                    added[v] = newStatus[v];\n                }\n            });\n\n            Object.keys(added).forEach(function (v, i) {\n                _transport.send(JSON.stringify({\n                    method: \"StylesheetAdded\",\n                    href: v,\n                    roots: [added[v]]\n                }));\n            });\n\n            this.stylesheets = newStatus;\n        },\n\n            /**\n             * Send a notification for the removed stylesheet and\n             * its import-ed styleshets based on document.stylesheets diff\n             * from previous status. It also updates stylesheets status.\n             */\n        notifyStylesheetRemoved: function () {\n\n            var self = this;\n            var removed = {},\n                newStatus,\n                current;\n\n            current = self.stylesheets;\n            newStatus = related().stylesheets;\n\n            Object.keys(current).forEach(function (v, i) {\n                if (!newStatus[v]) {\n                    removed[v] = current[v];\n                        // remove node created by setStylesheetText if any\n                    self.onStylesheetRemoved(current[v]);\n                }\n            });\n\n            Object.keys(removed).forEach(function (v, i) {\n                _transport.send(JSON.stringify({\n                    method: \"StylesheetRemoved\",\n                    href: v,\n                    roots: [removed[v]]\n                }));\n            });\n\n            self.stylesheets = newStatus;\n        }\n    };\n\n\n    /* process related docs added */\n    function _onNodesAdded(nodes) {\n        var i;\n        for (i = 0; i < nodes.length; i++) {\n            //check for Javascript files\n            if (Utils.isExternalScript(nodes[i])) {\n                _transport.send(JSON.stringify({\n                    method: 'ScriptAdded',\n                    src: nodes[i].src\n                }));\n            }\n            //check for stylesheets\n            if (Utils.isExternalStylesheet(nodes[i])) {\n                CSS.checkForStylesheetLoaded(nodes[i].href);\n            }\n        }\n    }\n    /* process related docs removed */\n    function _onNodesRemoved(nodes) {\n        var i;\n        //iterate on removed nodes\n        for (i = 0; i < nodes.length; i++) {\n\n            // check for external JS files\n            if (Utils.isExternalScript(nodes[i])) {\n                _transport.send(JSON.stringify({\n                    method: 'ScriptRemoved',\n                    src: nodes[i].src\n                }));\n            }\n            //check for external StyleSheets\n            if (Utils.isExternalStylesheet(nodes[i])) {\n                CSS.notifyStylesheetRemoved(nodes[i].href);\n            }\n        }\n    }\n\n    function _enableListeners() {\n        // enable MutationOberver if it's supported\n        var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n        if (MutationObserver) {\n            var observer = new MutationObserver(function (mutations) {\n                mutations.forEach(function (mutation) {\n                    if (mutation.addedNodes.length > 0) {\n                        _onNodesAdded(mutation.addedNodes);\n                    }\n                    if (mutation.removedNodes.length > 0) {\n                        _onNodesRemoved(mutation.removedNodes);\n                    }\n                });\n            });\n            observer.observe(_document, {\n                childList: true,\n                subtree: true\n            });\n        } else {\n            // use MutationEvents as fallback\n            window.document.addEventListener('DOMNodeInserted', function niLstnr(e) {\n                _onNodesAdded([e.target]);\n            });\n            window.document.addEventListener('DOMNodeRemoved', function nrLstnr(e) {\n                _onNodesRemoved([e.target]);\n            });\n        }\n    }\n\n\n    /**\n     * Start listening for events and send initial related documents message.\n     *\n     * @param {HTMLDocument} document\n     * @param {object} transport Live development transport connection\n     */\n    function start(document, transport) {\n        _transport = transport;\n        _document = document;\n        // start listening to node changes\n        _enableListeners();\n\n        var rel = related();\n\n        // send the current status of related docs.\n        _transport.send(JSON.stringify({\n            method: \"DocumentRelated\",\n            related: rel\n        }));\n        // initialize stylesheets with current status for further notifications.\n        CSS.stylesheets = rel.stylesheets;\n    }\n\n    /**\n     * Stop listening.\n     * TODO currently a no-op.\n     */\n    function stop() {\n\n    }\n\n    var DocumentObserver = {\n        start: start,\n        stop: stop,\n        related: related\n    };\n\n    ProtocolManager.setDocumentObserver(DocumentObserver);\n\n}(this));\n"],"file":"DocumentObserver.js"}
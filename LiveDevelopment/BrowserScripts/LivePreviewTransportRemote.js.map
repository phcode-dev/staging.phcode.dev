{"version":3,"sources":["LiveDevelopment/BrowserScripts/LivePreviewTransportRemote.js"],"names":["global","_debugLog","args","window","LIVE_PREVIEW_DEBUG_ENABLED","console","log","clientID","Math","round","random","worker","Worker","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","onmessage","event","type","data","location","href","URL","error","postMessage","broadcastChannel","LIVE_PREVIEW_BROADCAST_CHANNEL_ID","WebSocketTransport","_channelOpen","_broadcastMessageChannel","_callbacks","setCallbacks","callbacks","this","connect","self","BroadcastChannel","url","JSON","stringify","message","clientIDs","includes","length","close","addEventListener","send","msgStr","enable","_Brackets_LiveDev_Transport"],"mappings":"CA0BC,SAAUA,QAEP,SAASC,aAAaC,MACfC,OAAOC,4BACNC,QAAQC,OAAOJ,MAIvB,MAAMK,SAAW,GAAKC,KAAKC,MAAqB,IAAdD,KAAKE,UAEjCC,OAAS,IAAIC,OAAOT,OAAOU,0CACjCF,OAAOG,UAAY,CAACC,QAChB,MAAMC,KAAOD,MAAME,KAAKD,KACxB,OAAQA,MACR,IAAK,gBAAiBE,SAASC,KAAOJ,MAAME,KAAKG,IAAK,MACtD,QAASf,QAAQgB,MAAM,kEAAmEN,UAG9FJ,OAAOW,YAAY,CACfN,KAAM,iBACNO,iBAAkBpB,OAAOqB,kCACzBjB,SAAAA,WAEJ,MAAMkB,mBAAqB,CACvBC,cAAc,EAEdC,yBAA0B,KAO1BC,WAAY,KAWZC,aAAc,SAAUC,WACpBC,KAAKH,WAAaE,WAMtBE,QAAS,WACL,MAAMC,KAAOF,KAGbE,KAAKN,yBAA2B,IAAIO,iBAAiB/B,OAAOqB,mCAC5DS,KAAKN,yBAAyBL,YAAY,CACtCN,KAAM,kBACNmB,IAAKnC,OAAOkB,SAASC,KACrBZ,SAAUA,WAId0B,KAAKN,yBAAyBb,UAAY,CAACC,QAEvCd,UAAU,sDAAuDmC,KAAKC,UAAUtB,MAAME,OACtF,MAAMD,KAAOD,MAAME,KAAKD,KACxB,OAAQA,MACR,IAAK,kBACL,IAAK,kBACL,IAAK,gBAAiB,MACtB,IAAK,uBACD,GAAIiB,KAAKL,YAAcK,KAAKL,WAAWU,QAAS,CAC5C,MAAMC,UAAYxB,MAAME,KAAKsB,UACzBD,QAAUvB,MAAME,KAAKqB,SACtBC,UAAUC,SAASjC,WAAkC,IAArBgC,UAAUE,SAEzCR,KAAKL,WAAWU,QAAQA,SAGhC,MACJ,IAAK,gBACDL,KAAKP,cAAe,EACpBO,KAAKN,yBAAyBe,QAC1BT,KAAKL,YAAcK,KAAKL,WAAWc,OACnCT,KAAKL,WAAWc,WAM5BT,KAAKP,cAAe,EAChBO,KAAKL,YAAcK,KAAKL,WAAWI,SACnCC,KAAKL,WAAWI,UAKpBW,iBAAkB,eAAgB,WAC3BV,KAAKP,eACJO,KAAKP,cAAe,EACpBO,KAAKN,yBAAyBL,YAAY,CACtCN,KAAM,gBACNT,SAAUA,eAU1BqC,KAAM,SAAUC,QACZ,MAAMZ,KAAOF,KAAAA,KACRJ,yBAAyBL,YAAY,CACtCN,KAAM,kBACNT,SAAUA,SACV+B,QAASO,UAOjBC,OAAQ,WACJf,KAAKC,YAGbhC,OAAO+C,4BAA8BtB,mBAjIzC,CAkIEM","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// This is a transport injected into the browser via a script that handles the low\n// level communication between the live development protocol handlers on both sides.\n// This transport provides a web socket mechanism. It's injected separately from the\n// protocol handler so that the transport can be changed separately.\n\n(function (global) {\n\n    function _debugLog(...args) {\n        if(window.LIVE_PREVIEW_DEBUG_ENABLED) {\n            console.log(...args);\n        }\n    }\n\n    const clientID = \"\" + Math.round( Math.random()*1000000000);\n\n    const worker = new Worker(window.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME);\n    worker.onmessage = (event) => {\n        const type = event.data.type;\n        switch (type) {\n        case 'REDIRECT_PAGE': location.href = event.data.URL; break;\n        default: console.error(\"Live Preview page loader: received unknown message from worker:\", event);\n        }\n    };\n    worker.postMessage({\n        type: \"setupBroadcast\",\n        broadcastChannel: window.LIVE_PREVIEW_BROADCAST_CHANNEL_ID,\n        clientID});\n\n    const WebSocketTransport = {\n        _channelOpen: false,\n        // message channel used to communicate with service worker\n        _broadcastMessageChannel: null,\n\n        /**\n         * @private\n         * An object that contains callbacks to handle various transport events. See `setCallbacks()`.\n         * @type {?{connect: ?function, message: ?function(string), close: ?function}}\n         */\n        _callbacks: null,\n\n        /**\n         * Sets the callbacks that should be called when various transport events occur. All callbacks\n         * are optional, but you should at least implement \"message\" or nothing interesting will happen :)\n         * @param {?{connect: ?function, message: ?function(string), close: ?function}} callbacks\n         *      The callbacks to set.\n         *      connect - called when a connection is established to Brackets\n         *      message(msgStr) - called with a string message sent from Brackets\n         *      close - called when Brackets closes the connection\n         */\n        setCallbacks: function (callbacks) {\n            this._callbacks = callbacks;\n        },\n\n        /**\n         * Connects to the LivePreviewTransport in Brackets.\n         */\n        connect: function () {\n            const self = this;\n            // message channel to phoenix connect on load itself. The channel id is injected from phoenix\n            // via LivePreviewTransport.js while serving the instrumented html file\n            self._broadcastMessageChannel = new BroadcastChannel(window.LIVE_PREVIEW_BROADCAST_CHANNEL_ID);\n            self._broadcastMessageChannel.postMessage({\n                type: 'BROWSER_CONNECT',\n                url: global.location.href,\n                clientID: clientID\n            });\n\n            // Listen to the response\n            self._broadcastMessageChannel.onmessage = (event) => {\n                // Print the result\n                _debugLog(\"Live Preview: Browser received event from Phoenix: \", JSON.stringify(event.data));\n                const type = event.data.type;\n                switch (type) {\n                case 'BROWSER_CONNECT': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_MESSAGE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_CLOSE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'MESSAGE_FROM_PHOENIX':\n                    if (self._callbacks && self._callbacks.message) {\n                        const clientIDs = event.data.clientIDs,\n                            message = event.data.message;\n                        if(clientIDs.includes(clientID) || clientIDs.length === 0){\n                            // clientIDs.length = 0 if the message is intended for all clients\n                            self._callbacks.message(message);\n                        }\n                    }\n                    break;\n                case 'PHOENIX_CLOSE':\n                    self._channelOpen = false;\n                    self._broadcastMessageChannel.close();\n                    if (self._callbacks && self._callbacks.close) {\n                        self._callbacks.close();\n                    }\n                    break;\n                }\n            };\n\n            self._channelOpen = true;\n            if (self._callbacks && self._callbacks.connect) {\n                self._callbacks.connect();\n            }\n\n            // attach to browser tab/window closing event so that we send a cleanup request\n            // to the service worker for the comm ports\n            addEventListener( 'beforeunload', function() {\n                if(self._channelOpen){\n                    self._channelOpen = false;\n                    self._broadcastMessageChannel.postMessage({\n                        type: 'BROWSER_CLOSE',\n                        clientID: clientID\n                    });\n                }\n            });\n        },\n\n        /**\n         * Sends a message over the transport.\n         * @param {string} msgStr The message to send.\n         */\n        send: function (msgStr) {\n            const self = this;\n            self._broadcastMessageChannel.postMessage({\n                type: 'BROWSER_MESSAGE',\n                clientID: clientID,\n                message: msgStr\n            });\n        },\n\n        /**\n         * Establish web socket connection.\n         */\n        enable: function () {\n            this.connect();\n        }\n    };\n    global._Brackets_LiveDev_Transport = WebSocketTransport;\n}(this));\n"],"file":"LivePreviewTransportRemote.js"}
{"version":3,"sources":["LiveDevelopment/BrowserScripts/LivePreviewTransportRemote.js"],"names":["global","_debugLog","args","window","LIVE_PREVIEW_DEBUG_ENABLED","console","log","clientID","Math","round","random","worker","Worker","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","sentTitle","sentFavIconURL","convertImgToBase64","url","callback","canvas","document","createElement","ctx","getContext","img","Image","crossOrigin","onload","height","width","drawImage","dataURL","toDataURL","src","onmessage","event","type","data","location","href","URL","error","postMessage","broadcastChannel","LIVE_PREVIEW_BROADCAST_CHANNEL_ID","setInterval","favIcon","querySelector","faviconUrl","base64","faviconBase64","title","WebSocketTransport","_channelOpen","_broadcastMessageChannel","_callbacks","setCallbacks","callbacks","this","connect","self","BroadcastChannel","JSON","stringify","message","clientIDs","includes","length","close","addEventListener","send","msgStr","enable","_Brackets_LiveDev_Transport"],"mappings":"CA0BC,SAAUA,QAEP,SAASC,aAAaC,MACfC,OAAOC,4BACNC,QAAQC,OAAOJ,MAIvB,MAAMK,SAAW,GAAKC,KAAKC,MAAqB,IAAdD,KAAKE,UAEjCC,OAAS,IAAIC,OAAOT,OAAOU,0CAYjC,IAAIC,UAAWC,eAEf,SAASC,mBAAmBC,IAAKC,UAC7B,IAAIC,OAASC,SAASC,cAAc,UACpC,MAAMC,IAAMH,OAAOI,WAAW,MACxBC,IAAM,IAAIC,MAChBD,IAAIE,YAAc,YAClBF,IAAIG,OAAS,WACTR,OAAOS,OAASJ,IAAII,OACpBT,OAAOU,MAAQL,IAAIK,MACnBP,IAAIQ,UAAUN,IAAK,EAAG,GACtB,MAAMO,QAAUZ,OAAOa,YACvBd,SAASa,SACTZ,OAAS,MAEbK,IAAIS,IAAMhB,IA1BdN,OAAOuB,UAAY,CAACC,QAChB,MAAMC,KAAOD,MAAME,KAAKD,KACxB,OAAQA,MACR,IAAK,gBAAiBE,SAASC,KAAOJ,MAAME,KAAKG,IAAK,MACtD,QAASnC,QAAQoC,MAAM,kEAAmEN,UAG9FxB,OAAO+B,YAAY,CACfN,KAAM,iBACNO,iBAAkBxC,OAAOyC,kCACzBrC,SAAAA,WAmBJsC,YAAY,KACR,MAAMC,QAAU1B,SAAS2B,cAAc,qBACjCC,WAAaF,SAAWA,QAAQP,KACnCxB,iBAAmBiC,aAClBjC,eAAiBiC,WACjBhC,mBAAmBgC,WAAY,SAASC,QACpCtC,OAAO+B,YAAY,CACfN,KAAM,kBACNc,cAAeD,YAKxBnC,YAAaM,SAAS+B,QACrBrC,UAAYM,SAAS+B,MACrBxC,OAAO+B,YAAY,CACfN,KAAM,kBACNe,MAAO/B,SAAS+B,UAGzB,KAEH,MAAMC,mBAAqB,CACvBC,cAAc,EAEdC,yBAA0B,KAO1BC,WAAY,KAWZC,aAAc,SAAUC,WACpBC,KAAKH,WAAaE,WAMtBE,QAAS,WACL,MAAMC,KAAOF,KAGbE,KAAKN,yBAA2B,IAAIO,iBAAiB1D,OAAOyC,mCAC5DgB,KAAKN,yBAAyBZ,YAAY,CACtCN,KAAM,kBACNnB,IAAKjB,OAAOsC,SAASC,KACrBhC,SAAUA,WAIdqD,KAAKN,yBAAyBpB,UAAY,CAACC,QAEvClC,UAAU,sDAAuD6D,KAAKC,UAAU5B,MAAME,OACtF,MAAMD,KAAOD,MAAME,KAAKD,KACxB,OAAQA,MACR,IAAK,kBACL,IAAK,kBACL,IAAK,gBAAiB,MACtB,IAAK,uBACD,GAAIwB,KAAKL,YAAcK,KAAKL,WAAWS,QAAS,CAC5C,MAAMC,UAAY9B,MAAME,KAAK4B,UACzBD,QAAU7B,MAAME,KAAK2B,SACtBC,UAAUC,SAAS3D,WAAkC,IAArB0D,UAAUE,SAEzCP,KAAKL,WAAWS,QAAQA,SAGhC,MACJ,IAAK,gBACDJ,KAAKP,cAAe,EACpBO,KAAKN,yBAAyBc,QAC1BR,KAAKL,YAAcK,KAAKL,WAAWa,OACnCR,KAAKL,WAAWa,WAM5BR,KAAKP,cAAe,EAChBO,KAAKL,YAAcK,KAAKL,WAAWI,SACnCC,KAAKL,WAAWI,UAKpBU,iBAAkB,eAAgB,WAC3BT,KAAKP,eACJO,KAAKP,cAAe,EACpBO,KAAKN,yBAAyBZ,YAAY,CACtCN,KAAM,gBACN7B,SAAUA,eAU1B+D,KAAM,SAAUC,QACZ,MAAMX,KAAOF,KAAAA,KACRJ,yBAAyBZ,YAAY,CACtCN,KAAM,kBACN7B,SAAUA,SACVyD,QAASO,UAOjBC,OAAQ,WACJd,KAAKC,YAGb3D,OAAOyE,4BAA8BrB,mBAxKzC,CAyKEM","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// This is a transport injected into the browser via a script that handles the low\n// level communication between the live development protocol handlers on both sides.\n// This transport provides a web socket mechanism. It's injected separately from the\n// protocol handler so that the transport can be changed separately.\n\n(function (global) {\n\n    function _debugLog(...args) {\n        if(window.LIVE_PREVIEW_DEBUG_ENABLED) {\n            console.log(...args);\n        }\n    }\n\n    const clientID = \"\" + Math.round( Math.random()*1000000000);\n\n    const worker = new Worker(window.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME);\n    worker.onmessage = (event) => {\n        const type = event.data.type;\n        switch (type) {\n        case 'REDIRECT_PAGE': location.href = event.data.URL; break;\n        default: console.error(\"Live Preview page loader: received unknown message from worker:\", event);\n        }\n    };\n    worker.postMessage({\n        type: \"setupBroadcast\",\n        broadcastChannel: window.LIVE_PREVIEW_BROADCAST_CHANNEL_ID,\n        clientID});\n    let sentTitle, sentFavIconURL;\n\n    function convertImgToBase64(url, callback) {\n        let canvas = document.createElement('CANVAS');\n        const ctx = canvas.getContext('2d');\n        const img = new Image();\n        img.crossOrigin = 'Anonymous';\n        img.onload = function() {\n            canvas.height = img.height;\n            canvas.width = img.width;\n            ctx.drawImage(img, 0, 0);\n            const dataURL = canvas.toDataURL();\n            callback(dataURL);\n            canvas = null;\n        };\n        img.src = url;\n    }\n\n    setInterval(()=>{\n        const favIcon = document.querySelector(\"link[rel~='icon']\");\n        const faviconUrl = favIcon && favIcon.href;\n        if(sentFavIconURL !== faviconUrl){\n            sentFavIconURL = faviconUrl;\n            convertImgToBase64(faviconUrl, function(base64) {\n                worker.postMessage({\n                    type: \"updateTitleIcon\",\n                    faviconBase64: base64\n                });\n            });\n        }\n\n        if(sentTitle!== document.title) {\n            sentTitle = document.title;\n            worker.postMessage({\n                type: \"updateTitleIcon\",\n                title: document.title\n            });\n        }\n    }, 1000);\n\n    const WebSocketTransport = {\n        _channelOpen: false,\n        // message channel used to communicate with service worker\n        _broadcastMessageChannel: null,\n\n        /**\n         * @private\n         * An object that contains callbacks to handle various transport events. See `setCallbacks()`.\n         * @type {?{connect: ?function, message: ?function(string), close: ?function}}\n         */\n        _callbacks: null,\n\n        /**\n         * Sets the callbacks that should be called when various transport events occur. All callbacks\n         * are optional, but you should at least implement \"message\" or nothing interesting will happen :)\n         * @param {?{connect: ?function, message: ?function(string), close: ?function}} callbacks\n         *      The callbacks to set.\n         *      connect - called when a connection is established to Brackets\n         *      message(msgStr) - called with a string message sent from Brackets\n         *      close - called when Brackets closes the connection\n         */\n        setCallbacks: function (callbacks) {\n            this._callbacks = callbacks;\n        },\n\n        /**\n         * Connects to the LivePreviewTransport in Brackets.\n         */\n        connect: function () {\n            const self = this;\n            // message channel to phoenix connect on load itself. The channel id is injected from phoenix\n            // via LivePreviewTransport.js while serving the instrumented html file\n            self._broadcastMessageChannel = new BroadcastChannel(window.LIVE_PREVIEW_BROADCAST_CHANNEL_ID);\n            self._broadcastMessageChannel.postMessage({\n                type: 'BROWSER_CONNECT',\n                url: global.location.href,\n                clientID: clientID\n            });\n\n            // Listen to the response\n            self._broadcastMessageChannel.onmessage = (event) => {\n                // Print the result\n                _debugLog(\"Live Preview: Browser received event from Phoenix: \", JSON.stringify(event.data));\n                const type = event.data.type;\n                switch (type) {\n                case 'BROWSER_CONNECT': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_MESSAGE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_CLOSE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'MESSAGE_FROM_PHOENIX':\n                    if (self._callbacks && self._callbacks.message) {\n                        const clientIDs = event.data.clientIDs,\n                            message = event.data.message;\n                        if(clientIDs.includes(clientID) || clientIDs.length === 0){\n                            // clientIDs.length = 0 if the message is intended for all clients\n                            self._callbacks.message(message);\n                        }\n                    }\n                    break;\n                case 'PHOENIX_CLOSE':\n                    self._channelOpen = false;\n                    self._broadcastMessageChannel.close();\n                    if (self._callbacks && self._callbacks.close) {\n                        self._callbacks.close();\n                    }\n                    break;\n                }\n            };\n\n            self._channelOpen = true;\n            if (self._callbacks && self._callbacks.connect) {\n                self._callbacks.connect();\n            }\n\n            // attach to browser tab/window closing event so that we send a cleanup request\n            // to the service worker for the comm ports\n            addEventListener( 'beforeunload', function() {\n                if(self._channelOpen){\n                    self._channelOpen = false;\n                    self._broadcastMessageChannel.postMessage({\n                        type: 'BROWSER_CLOSE',\n                        clientID: clientID\n                    });\n                }\n            });\n        },\n\n        /**\n         * Sends a message over the transport.\n         * @param {string} msgStr The message to send.\n         */\n        send: function (msgStr) {\n            const self = this;\n            self._broadcastMessageChannel.postMessage({\n                type: 'BROWSER_MESSAGE',\n                clientID: clientID,\n                message: msgStr\n            });\n        },\n\n        /**\n         * Establish web socket connection.\n         */\n        enable: function () {\n            this.connect();\n        }\n    };\n    global._Brackets_LiveDev_Transport = WebSocketTransport;\n}(this));\n"],"file":"LivePreviewTransportRemote.js"}
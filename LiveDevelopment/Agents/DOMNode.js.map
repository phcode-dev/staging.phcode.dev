{"version":3,"sources":["LiveDevelopment/Agents/DOMNode.js"],"names":["define","DOMNodeModule","require","exports","module","DOMHelpers","_fill","string","length","c","undefined","_makeFindCondition","match","findCondition","name","node","bind","toUpperCase","type","console","error","DOMNode","agent","payload","this","children","attributes","extractPayload","setPayload","addNode","TYPE_ELEMENT","TYPE_ATTRIBUTE","TYPE_TEXT","TYPE_COMMENT","TYPE_DOCUMENT","prototype","remove","removeNode","parent","removeChild","i","k","v","nodeId","nodeType","nodeName","nodeValue","value","sourceOffset","location","sourceLength","setChildrenPayload","childNodeCount","requestChildNodes","childrenPayload","appendChild","res","findParentForNextNodeMatchingPayload","canHaveChildren","matchesPayload","findNextNodeMatchingPayload","next","nextNode","r","resolve","def","$","Deferred","objectId","resolveNode","onResolve","object","reject","promise","closed","closing","splice","indexOfChild","insertChildAt","index","insertChildAfter","sibling","insertChildBefore","parseInt","previousSibling","nextSibling","previousNode","each","callback","find","n","findAll","nodes","push","eachParent","findParent","theParent","root","isAtLocation","includeChildren","to","closeLocation","closeLength","isEmpty","test","toString","replace","substr","dump","pre","info"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint forin: true */\n\n/**\n * DOMNode represents a node in the DOM tree. It is constructed from a payload\n * similar to {DOM.Node} and supports all basic tree operations. If a node has\n * a nodeId it is registered with the `DOMAgent` via `addNode()`. The node's\n * sourceOffset and sourceLength is stored as its location and length. Nodes can\n * iterated using `each()` or `find()`. `dump` shows the entire tree on the console.\n */\ndefine(function DOMNodeModule(require, exports, module) {\n\n\n    var DOMHelpers = require(\"LiveDevelopment/Agents/DOMHelpers\");\n\n    /** Fill a string to the given length (used for debug output)\n     * @param {string} source string\n     * @param {integer} length\n     * @param {char} fill character\n     */\n    function _fill(string, length, c) {\n        if (c === undefined) {\n            c = \" \";\n        }\n        while (string.length < length) {\n            string += c;\n        }\n        return string;\n    }\n\n    /** Construct a find condition (used in `find` and `findParent`)\n     * The match can be a callback returning true or false, the node\n     * name or the node type.\n     * @param {function} or {string} or {number} match criteria\n     */\n    function _makeFindCondition(match) {\n        switch (typeof match) {\n        case \"function\":\n            return match;\n        case \"string\":\n            return function findCondition(name, node) {\n                return node.name === name;\n            }.bind(undefined, match.toUpperCase());\n        case \"number\":\n            return function findCondition(type, node) {\n                return node.type === type;\n            }.bind(undefined, match);\n        default:\n            console.error(\"Invalid find condition: \" + match);\n        }\n    }\n\n    /** Constructor\n     * @param {DOMAgent} the agent is passed to avoid circular relationships\n     * @param {DOM.Node} node payload\n     */\n    var DOMNode = function DOMNode(agent, payload) {\n        this.agent = agent;\n        this.children = [];\n        this.attributes = {};\n\n        // set the payload\n        if (typeof payload === \"string\") {\n            payload = DOMHelpers.extractPayload(payload);\n        }\n        if (payload) {\n            this.setPayload(payload);\n        }\n        this.agent.addNode(this);\n    };\n\n    var TYPE_ELEMENT = DOMNode.TYPE_ELEMENT = 1; // element node\n    var TYPE_ATTRIBUTE = DOMNode.TYPE_ATTRIBUTE = 2; // attribute node (unused)\n    var TYPE_TEXT = DOMNode.TYPE_TEXT = 3; // text node\n    var TYPE_COMMENT = DOMNode.TYPE_COMMENT = 8; // comment node <!-- -->\n    var TYPE_DOCUMENT = DOMNode.TYPE_DOCUMENT = 9; // document node <!DOCUMENT>\n\n    /** Remove a node */\n    DOMNode.prototype.remove = function remove() {\n        this.agent.removeNode(this);\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n    };\n\n\n    /** Node Payload ***********************************************************/\n\n    /** Set the node payload\n     * @param {DOM.Node} payload\n     */\n    DOMNode.prototype.setPayload = function setPayload(payload) {\n        this.nodeId = payload.nodeId;\n        this.type = payload.nodeType;\n        if (payload.nodeName) {\n            this.name = payload.nodeName;\n        }\n        if (payload.nodeValue) {\n            this.value = payload.nodeValue;\n        }\n        this.attributes = {};\n        if (payload.attributes) {\n            var i, k, v;\n            for (i = 0; i < payload.attributes.length; i += 2) {\n                k = payload.attributes[i];\n                v = payload.attributes[i + 1];\n                this.attributes[k] = v;\n            }\n        }\n        if (payload.sourceOffset) {\n            this.location = payload.sourceOffset;\n        }\n        if (payload.sourceLength) {\n            this.length = payload.sourceLength;\n        } else {\n            if (this.value) {\n                this.length = this.value.length;\n            } else if (this.name) {\n                this.length = this.name.length + 2;\n            }\n        }\n        if (payload.children) {\n            this.setChildrenPayload(payload.children);\n        } else if (payload.childNodeCount) {\n            this.agent.requestChildNodes(this);\n        }\n    };\n\n    /** Create child nodes from the given payload\n     * @param [{DOM.Node}] payload of the children\n     */\n    DOMNode.prototype.setChildrenPayload = function setChildrenPayload(childrenPayload) {\n        var i, payload, node;\n        for (i in childrenPayload) {\n            payload = childrenPayload[i];\n            node = new DOMNode(this.agent, payload);\n            this.appendChild(node);\n        }\n    };\n\n    /** Construct the payload for this node */\n    DOMNode.prototype.payload = function payload() {\n        var res = { type: this.type };\n        if (this.nodeType === TYPE_ELEMENT) {\n            res.nodeName = this.name;\n        } else {\n            res.value = this.value;\n        }\n        return res;\n    };\n\n    /** Find the next node that matches the given payload\n     * @param {DOM.Node} payload\n     */\n    DOMNode.prototype.findParentForNextNodeMatchingPayload = function findParentForNextNodeMatchingPayload(payload) {\n        var parent = this.canHaveChildren() ? this : this.parent;\n        while (parent && !parent.matchesPayload(payload)) {\n            parent = parent.parent;\n        }\n        return parent;\n    };\n\n    /** Find the next node that matches the given payload\n     * @param {DOM.Node} payload\n     */\n    DOMNode.prototype.findNextNodeMatchingPayload = function findNextNodeMatchingPayload(payload) {\n        var next = this.nextNode();\n        while (next && !next.matchesPayload(payload)) {\n            next = next.nextNode();\n        }\n        return next;\n    };\n\n    /** Test if the node matches the given payload\n     * @param {DOM.Node} payload\n     */\n    DOMNode.prototype.matchesPayload = function matchesPayload(payload) {\n        var r = false;\n        if (this.type === payload.nodeType) {\n            switch (this.type) {\n            case 1:\n                r = this.name === payload.nodeName;\n                break;\n            case 3:\n                // TODO payload.nodeValue's HTML Entities must be decoded\n                // r = this.value === payload.nodeValue;\n                r = true;\n                break;\n            default:\n                r = true;\n            }\n        }\n        // Useful output for debugging this - do not remove\n        // console.debug(this.type + \",\" + this.name + \",\" + this.value + \" = \" + payload.nodeType + \",\" + payload.nodeName + \",\" + payload.value + \" -> \" + r);\n        return r;\n    };\n\n    /** Resolve the node and retrieve its objectId from the remote debugger */\n    DOMNode.prototype.resolve = function resolve() {\n        var def = new $.Deferred();\n        if (this.objectId) {\n            def.resolve(this);\n        } else if (!this.nodeId) {\n            def.reject();\n        } else {\n            this.agent.resolveNode(this, function onResolve(res) {\n                this.objectId = res.object.objectId;\n                def.resolve(this);\n            }.bind(this));\n        }\n        return def.promise();\n    };\n\n\n    /** Tree Operations ******************************************************/\n\n    /** Can the node have children? */\n    DOMNode.prototype.canHaveChildren = function canHaveChildren() {\n        return (this.type === 1 && !this.closed && !this.closing && this.nodeName !== \"LINK\");\n    };\n\n    /** Remove a child\n     * @param {DOMNode} child node to remove\n     */\n    DOMNode.prototype.removeChild = function removeChild(node) {\n        this.children.splice(this.indexOfChild(node), 1);\n        delete node.parent;\n    };\n\n    /** Insert a child node at the given index\n     * @param {DOMNode} node to insert\n     * @param {integer} optional index (node is appended if missing)\n     */\n    DOMNode.prototype.insertChildAt = function insertChildAt(node, index) {\n        if (node.parent) {\n            node.parent.removeChild(node);\n        }\n        if (!index || index < 0 || index > this.children.length) {\n            index = this.children.length;\n        }\n        this.children.splice(index, 0, node);\n        node.parent = this;\n        return node;\n    };\n\n    /** Append a child to this node\n     * @param {DOMNode} child node to append\n     */\n    DOMNode.prototype.appendChild = function appendChild(node) {\n        return this.insertChildAt(node);\n    };\n\n    /** Insert a child node after the given node\n     * @param {DOMNode} child node to insert\n     * @param {DOMNode} existing child node\n     */\n    DOMNode.prototype.insertChildAfter = function insertChildAfter(node, sibling) {\n        var index = this.indexOfChild(sibling);\n        if (index >= 0) {\n            index++;\n        }\n        return this.insertChildAt(node, index);\n    };\n\n    /** Insert a child node before the given node\n     * @param {DOMNode} child node to insert\n     * @param {DOMNode} existing child node\n     */\n    DOMNode.prototype.insertChildBefore = function insertChildBefore(node, sibling) {\n        var index = this.indexOfChild(sibling);\n        return this.insertChildAt(node, index);\n    };\n\n    /** Determine the index of a child node\n     * @param {DOMNode} child node\n     */\n    DOMNode.prototype.indexOfChild = function indexOfChild(node) {\n        if (!node) {\n            return -1;\n        }\n        var i;\n        for (i in this.children) {\n            if (this.children[i] === node) {\n                return parseInt(i, 0);\n            }\n        }\n        return -1;\n    };\n\n    /** Get the previous sibling */\n    DOMNode.prototype.previousSibling = function previousSibling() {\n        if (!this.parent) {\n            return null;\n        }\n        return this.parent.children[this.parent.indexOfChild(this) - 1];\n    };\n\n    /** Get the next sibling */\n    DOMNode.prototype.nextSibling = function nextSibling() {\n        if (!this.parent) {\n            return null;\n        }\n        return this.parent.children[this.parent.indexOfChild(this) + 1];\n    };\n\n    /** Get the previous node */\n    DOMNode.prototype.previousNode = function previousNode() {\n        var node = this.previousSibling();\n        if (node) {\n            if (node.children.length > 0) {\n                node = node.children[node.children.length - 1];\n            }\n        } else {\n            node = this.parent;\n        }\n        return node;\n    };\n\n    /** Get the next node */\n    DOMNode.prototype.nextNode = function nextNode() {\n        if (this.children.length > 0) {\n            // return the first child\n            return this.children[0];\n        }\n        // return this or any ancestor's next sibling\n        var node, parent = this;\n        while (parent) {\n            node = parent.nextSibling();\n            if (node) {\n                return node;\n            }\n            parent = parent.parent;\n        }\n        return null;\n    };\n\n    /** Traverse the tree\n     * @param {function({DOM.Node})} called for this node and all descendants\n     */\n    DOMNode.prototype.each = function each(callback) {\n        if (callback(this) === false) {\n            return false;\n        }\n        var i;\n        for (i in this.children) {\n            if (this.children[i].each(callback) === false) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /** Find a node in the tree\n     * @param {function} or {string} or {integer} find condition\n     */\n    DOMNode.prototype.find = function find(match) {\n        var findCondition = _makeFindCondition(match);\n        var node = null;\n        this.each(function each(n) {\n            if (findCondition(n)) {\n                node = n;\n                return false;\n            }\n        });\n        return node;\n    };\n\n    /** Find all nodes with the given find condition\n     * @param {function} or {string} or {integer} find condition\n     */\n    DOMNode.prototype.findAll = function findAll(match) {\n        var nodes = [];\n        var findCondition = _makeFindCondition(match);\n        this.each(function each(node) {\n            if (findCondition(node)) {\n                nodes.push(node);\n            }\n        });\n        return nodes;\n    };\n\n    /** Iterate over all parent nodes\n     * @param {function({DOM.Node})} called for each ancestor\n     */\n    DOMNode.prototype.eachParent = function eachParent(callback) {\n        var node = this.parent;\n        while (node) {\n            if (callback(node) === false) {\n                return;\n            }\n            node = node.parent;\n        }\n        return null;\n    };\n\n    /** Find a parent node that matches the find condition\n     * @param {function} or {string} or {integer} find condition\n     */\n    DOMNode.prototype.findParent = function findParent(findCondition) {\n        var theParent = null;\n        this.eachParent(function each(parent) {\n            if (findCondition(parent)) {\n                theParent = parent;\n                return false;\n            }\n        });\n        return theParent;\n    };\n\n    /** Find the root of the tree */\n    DOMNode.prototype.root = function root() {\n        var node = this;\n        while (node.parent) {\n            node = node.parent;\n        }\n        return node;\n    };\n\n\n   /** Node Info ***********************************************************/\n\n   /** Test if the given location is inside this node\n    * @param {integer} location\n    * @param {boolean} also include children\n    */\n    DOMNode.prototype.isAtLocation = function isAtLocation(location, includeChildren) {\n        if (includeChildren === undefined) {\n            includeChildren = true;\n        }\n        if (!this.location || location < this.location) {\n            return false;\n        }\n        var to;\n        if (includeChildren && this.closeLocation) {\n            to = this.closeLocation + this.closeLength;\n        } else {\n            to = this.location + this.length;\n        }\n        if (this.type === TYPE_TEXT) {\n            to += 1;\n        }\n        return location < to;\n    };\n\n    /** Test if this node is empty */\n    DOMNode.prototype.isEmpty = function isEmpty() {\n        return this.type === TYPE_TEXT && /^\\s*$/.test(this.value);\n    };\n\n    /** Debug Output */\n    DOMNode.prototype.toString = function toString() {\n        var r;\n        switch (this.type) {\n        case TYPE_ELEMENT:\n            r = \"<\" + this.name + \">\";\n            break;\n        case TYPE_ATTRIBUTE:\n            r = \"[ATTRIBUTE]\";\n            break;\n        case TYPE_TEXT:\n            r = this.value.replace(/\\s+/, \" \").substr(0, 40);\n            break;\n        case TYPE_COMMENT:\n            r = \"<!--\" + this.value.replace(/\\s+/, \" \").substr(0, 33) + \"-->\";\n            break;\n        case TYPE_DOCUMENT:\n            r = \"<!DOCTYPE>\";\n            break;\n        }\n        return r;\n    };\n\n    /** Detailed Debug Output */\n    DOMNode.prototype.dump = function dump(pre) {\n        if (pre === undefined) {\n            pre = \"\";\n        }\n        var r = pre + this.toString();\n        if (this.location) {\n            r = _fill(r, 60);\n            r += \" (\" + this.location + \",\" + (this.location + this.length) + \")\";\n            if (this.closeLocation) {\n                r += \" (\" + this.closeLocation + \",\" + (this.closeLocation + this.closeLength) + \")\";\n            }\n        }\n        if (this.nodeId) {\n            r = _fill(r, 80);\n            r += \" {\" + this.nodeId + \"}\";\n        }\n        console.info(r);\n        pre += \". \";\n        var i;\n        for (i in this.children) {\n            this.children[i].dump(pre);\n        }\n    };\n\n    return DOMNode;\n});\n"],"file":"DOMNode.js"}
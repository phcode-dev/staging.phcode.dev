{"version":3,"sources":["utils/PerfUtils.js"],"names":["define","require","exports","module","_","StringUtils","enabled","brackets","app","getElapsedMilliseconds","perfData","activeTests","updatableTests","_reentTests","PerfMeasurement","id","name","reent","this","createPerfMeasurement","pm","_generatePerfMeasurements","Array","isArray","i","length","undefined","_markStart","time","console","error","startTime","markStart","addMeasurement","elapsedTime","push","updateMeasurement","finalizeMeasurement","isActive","getValueAsString","entry","aggregateStats","sum","avg","min","max","sd","variationSum","forEach","value","Math","round","pow","sqrt","join","getDelimitedPerfData","result","testName","getData","getHealthReport","healthReport","projectLoadTimes","fileOpenTimes","startsWith","AppStartupTime","ModuleDepsResolved","searchData","regExp","keys","Object","filter","key","test","datas","clear","prototype","toString"],"mappings":"AAwBAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,EAAeH,QAAQ,qBACvBI,YAAeJ,QAAQ,qBAG3BA,QAAQ,gBAMR,IAAIK,QAAUC,YAAcA,SAASC,IAAIC,uBAQrCC,SAAW,GAMXC,YAAc,GAOdC,eAAiB,GAOjBC,YAAc,GAUlB,SAASC,gBAAgBC,GAAIC,KAAMC,OAC/BC,KAAKF,KAAOA,KACZE,KAAKD,MAAQA,MAETC,KAAKH,GADLA,KAGU,MAAU,UAAYG,KAAKD,MAAQ,KAAOD,KAAOA,MAmBnE,SAASG,sBAAsBJ,GAAIC,MAC/B,IAAII,GAAK,IAAIN,gBAAgBC,GAAIC,MAGjC,OAFAd,QAAQa,IAAMK,GAEPA,GAOX,SAASC,0BAA0BL,MAE/B,IAAID,GAAOO,MAAMC,QAAQP,MAAkBA,KAAT,CAACA,MAE/BQ,EACJ,IAAKA,EAAI,EAAGA,EAAIT,GAAGU,OAAQD,IACjBT,GAAGS,aAAcV,uBACQY,IAAvBb,YAAYE,GAAGS,IACfX,YAAYE,GAAGS,IAAM,EAErBX,YAAYE,GAAGS,MAEnBT,GAAGS,GAAK,IAAIV,qBAAgBY,EAAWX,GAAGS,GAAIX,YAAYE,GAAGS,MAGrE,OAAOT,GAUX,SAASY,WAAWZ,GAAIa,MAChBjB,YAAYI,GAAGA,KACfc,QAAQC,MAAM,iEAAmEf,GAAGA,IAGxFJ,YAAYI,GAAGA,IAAM,CAAEgB,UAAWH,MAiBtC,SAASI,UAAUhB,MACf,GAAKV,QAAL,CAIA,IAAIsB,KAAOrB,SAASC,IAAIC,yBACpBM,GAAKM,0BAA0BL,MAC/BQ,EAEJ,IAAKA,EAAI,EAAGA,EAAIT,GAAGU,OAAQD,IACvBG,WAAWZ,GAAGS,GAAII,MAEtB,OAAOb,GAAGU,OAAS,EAAIV,GAAKA,GAAG,IAcnC,SAASkB,eAAelB,IACpB,IAAKT,QACD,OAGES,cAAcD,kBAChBC,GAAK,IAAID,gBAAgBC,GAAIA,KAGjC,IAAImB,YAAc3B,SAASC,IAAIC,yBA0B/B,OAxBIE,YAAYI,GAAGA,MACfmB,aAAevB,YAAYI,GAAGA,IAAIgB,iBAC3BpB,YAAYI,GAAGA,KAGtBL,SAASK,IAELO,MAAMC,QAAQb,SAASK,KACvBL,SAASK,IAAIoB,KAAKD,aAGlBxB,SAASK,IAAM,CAACL,SAASK,IAAKmB,aAGlCxB,SAASK,IAAMmB,iBAGFR,IAAbX,GAAGE,QACqB,IAApBJ,YAAYE,WACLF,YAAYE,IAEnBF,YAAYE,OAGbmB,YAuBX,SAASE,kBAAkBrB,IACvB,IAAImB,YAAc3B,SAASC,IAAIC,yBAE3BG,eAAeG,GAAGA,KAElBmB,aAAetB,eAAeG,IAAIgB,UAG9BrB,SAASK,KAAOO,MAAMC,QAAQb,SAASK,KAEvCL,SAASK,IAAIL,SAASK,IAAIU,OAAS,GAAKS,YAGxCxB,SAASK,IAAMmB,cAMfvB,YAAYI,GAAGA,MAEfH,eAAeG,GAAGA,IAAM,CAAEgB,UAAWpB,YAAYI,GAAGA,IAAIgB,YAI5DE,eAAelB,KAYvB,SAASsB,oBAAoBtB,IACrBJ,YAAYI,GAAGA,YACRJ,YAAYI,GAAGA,IAGtBH,eAAeG,GAAGA,YACXH,eAAeG,GAAGA,IAYjC,SAASuB,SAASvB,IACd,QAAQJ,YAAYI,GAAGA,IAY3B,SAASwB,iBAAiBC,MAAOC,gBAC7B,IAAKnB,MAAMC,QAAQiB,OACf,OAAOA,MAGX,GAAIC,eAAgB,CAChB,IAAIC,IAAM,EACNC,IACAC,IAAMxC,EAAEwC,IAAIJ,OACZK,IAAMzC,EAAEyC,IAAIL,OACZM,GACAC,aAAe,EAUnB,OARAP,MAAMQ,QAAQ,SAAUC,OACpBP,KAAOO,QAEXN,IAAMO,KAAKC,MAAMT,IAAMF,MAAMf,QAC7Be,MAAMQ,QAAQ,SAAUC,OACpBF,cAAgBG,KAAKE,IAAIH,MAAQN,IAAK,KAE1CG,GAAKI,KAAKC,MAAMD,KAAKG,KAAKN,aAAeP,MAAMf,SACxCmB,IAAM,IAAMD,IAAM,IAAME,IAAM,IAAMC,GAAK,IAEpD,OAAON,MAAMc,KAAK,MAQtB,SAASC,uBACL,IAAIC,OAAS,GAKb,OAJApD,EAAE4C,QAAQtC,SAAU,SAAU8B,MAAOiB,UACjCD,QAAUjB,iBAAiBC,OAAS,KAAOiB,SAAW,OAGnDD,OAOX,SAASE,QAAQ3C,IACb,OAAKA,GAIEL,SAASK,IAHLL,SAUf,SAASiD,kBACL,IAAIC,aAAe,CACfC,iBAAkB,GAClBC,cAAe,IAenB,OAZA1D,EAAE4C,QAAQtC,SAAU,SAAU8B,MAAOiB,UAC7BpD,YAAY0D,WAAWN,SAAU,uBACjCG,aAAaI,eAAiBzB,iBAAiBC,OACxCnC,YAAY0D,WAAWN,SAAU,yCACxCG,aAAaK,mBAAqB1B,iBAAiBC,OAC5CnC,YAAY0D,WAAWN,SAAU,gBACxCG,aAAaC,kBAAoB,IAAMtB,iBAAiBC,OAAO,GACxDnC,YAAY0D,WAAWN,SAAU,eACxCG,aAAaE,eAAiB,IAAMvB,iBAAiBC,OAAO,MAI7DoB,aAGX,SAASM,WAAWC,QAChB,IAAIC,KAAOC,OAAOD,KAAK1D,UAAU4D,OAAO,SAAUC,KAC9C,OAAOJ,OAAOK,KAAKD,OAGnBE,MAAQ,GAMZ,OAJAL,KAAKpB,QAAQ,SAAUuB,KACnBE,MAAMtC,KAAKzB,SAAS6D,QAGjBE,MAMX,SAASC,QACLhE,SAAW,GACXC,YAAc,GACdC,eAAiB,GACjBC,YAAc,GA/TlBC,gBAAgB6D,UAAUC,SAAW,WACjC,OAAO1D,KAAKF,MAkUhBG,sBAAsB,qBAAsB,8BAC5CA,sBAAsB,sBAAuB,+BAI7CjB,QAAQ+B,eAA0BA,eAClC/B,QAAQmC,oBAA0BA,oBAClCnC,QAAQoC,SAA0BA,SAClCpC,QAAQ8B,UAA0BA,UAClC9B,QAAQwD,QAA0BA,QAClCxD,QAAQgE,WAA0BA,WAClChE,QAAQkC,kBAA0BA,kBAClClC,QAAQqD,qBAA0BA,qBAClCrD,QAAQiB,sBAA0BA,sBAClCjB,QAAQwE,MAA0BA,MAClCxE,QAAQyD,gBAA0BA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * This is a collection of utility functions for gathering performance data.\n */\ndefine(function (require, exports, module) {\n\n\n    var _            = require(\"thirdparty/lodash\"),\n        StringUtils  = require(\"utils/StringUtils\");\n\n    // make sure the global brackets variable is loaded\n    require(\"utils/Global\");\n\n    /**\n     * Flag to enable/disable performance data gathering. Default is true (enabled)\n     * @type {boolean} enabled\n     */\n    var enabled = brackets && !!brackets.app.getElapsedMilliseconds;\n\n    /**\n     * Performance data is stored in this hash object. The key is the name of the\n     * test (passed to markStart/addMeasurement), and the value is the time, in\n     * milliseconds, that it took to run the test. If multiple runs of the same test\n     * are made, the value is an Array with each run stored as an entry in the Array.\n     */\n    var perfData = {};\n\n    /**\n     * Active tests. This is a hash of all tests that have had markStart() called,\n     * but have not yet had addMeasurement() called.\n     */\n    var activeTests = {};\n\n    /**\n     * Updatable tests. This is a hash of all tests that have had markStart() called,\n     * and have had updateMeasurement() called. Caller must explicitly remove tests\n     * from this list using finalizeMeasurement()\n     */\n    var updatableTests = {};\n\n    /**\n     * @private\n     * Keeps the track of measurements sequence number for re-entrant sequences with\n     * the same name currently running. Entries are created and deleted as needed.\n     */\n    var _reentTests = {};\n\n    /**\n     * @private\n     * A unique key to log performance data\n     *\n     * @param {(string|undefined)} id Unique ID for this measurement name\n     * @param {!string} name A short name for this measurement\n     * @param {?number} reent Sequence identifier for parallel tests of the same name\n     */\n    function PerfMeasurement(id, name, reent) {\n        this.name = name;\n        this.reent = reent;\n        if (id) {\n            this.id = id;\n        } else {\n            this.id = (reent) ? \"[reent \" + this.reent + \"] \" + name : name;\n        }\n    }\n\n    /**\n     * Override toString() to allow using PerfMeasurement as an array key without\n     * explicit conversion.\n     */\n    PerfMeasurement.prototype.toString = function () {\n        return this.name;\n    };\n\n    /**\n     * Create a new PerfMeasurement key. Adds itself to the module export.\n     * Can be accessed on the module, e.g. PerfUtils.MY_PERF_KEY.\n     *\n     * @param {!string} id Unique ID for this measurement name\n     * @param {!name} name A short name for this measurement\n     */\n    function createPerfMeasurement(id, name) {\n        var pm = new PerfMeasurement(id, name);\n        exports[id] = pm;\n\n        return pm;\n    }\n\n    /**\n     * @private\n     * Generates PerfMeasurements based on the name or array of names.\n     */\n    function _generatePerfMeasurements(name) {\n        // always convert it to array so that the rest of the routines could rely on it\n        var id = (!Array.isArray(name)) ? [name] : name;\n        // generate unique identifiers for each name\n        var i;\n        for (i = 0; i < id.length; i++) {\n            if (!(id[i] instanceof PerfMeasurement)) {\n                if (_reentTests[id[i]] === undefined) {\n                    _reentTests[id[i]] = 0;\n                } else {\n                    _reentTests[id[i]]++;\n                }\n                id[i] = new PerfMeasurement(undefined, id[i], _reentTests[id[i]]);\n            }\n        }\n        return id;\n    }\n\n    /**\n     * @private\n     * Helper function for markStart()\n     *\n     * @param {Object} id  Timer id.\n     * @param {number} time  Timer start time.\n     */\n    function _markStart(id, time) {\n        if (activeTests[id.id]) {\n            console.error(\"Recursive tests with the same id are not supported. Timer id: \" + id.id);\n        }\n\n        activeTests[id.id] = { startTime: time };\n    }\n\n    /**\n     * Start a new named timer. The name should be as descriptive as possible, since\n     * this name will appear as an entry in the performance report.\n     * For example: \"Open file: /Users/brackets/src/ProjectManager.js\"\n     *\n     * Multiple timers can be opened simultaneously.\n     *\n     * Returns an opaque set of timer ids which can be stored and used for calling\n     * addMeasurement(). Since name is often creating via concatenating strings this\n     * return value allows clients to construct the name once.\n     *\n     * @param {(string|Array.<string>)} name  Single name or an Array of names.\n     * @return {(Object|Array.<Object>)} Opaque timer id or array of timer ids.\n     */\n    function markStart(name) {\n        if (!enabled) {\n            return;\n        }\n\n        var time = brackets.app.getElapsedMilliseconds();\n        var id = _generatePerfMeasurements(name);\n        var i;\n\n        for (i = 0; i < id.length; i++) {\n            _markStart(id[i], time);\n        }\n        return id.length > 1 ? id : id[0];\n    }\n\n    /**\n     * Stop a timer and add its measurements to the performance data.\n     *\n     * Multiple measurements can be stored for any given name. If there are\n     * multiple values for a name, they are stored in an Array.\n     *\n     * If markStart() was not called for the specified timer, the\n     * measured time is relative to app startup.\n     *\n     * @param {Object} id  Timer id.\n     */\n    function addMeasurement(id) {\n        if (!enabled) {\n            return;\n        }\n\n        if (!(id instanceof PerfMeasurement)) {\n            id = new PerfMeasurement(id, id);\n        }\n\n        let elapsedTime = brackets.app.getElapsedMilliseconds();\n\n        if (activeTests[id.id]) {\n            elapsedTime -= activeTests[id.id].startTime;\n            delete activeTests[id.id];\n        }\n\n        if (perfData[id]) {\n            // We have existing data, add to it\n            if (Array.isArray(perfData[id])) {\n                perfData[id].push(elapsedTime);\n            } else {\n                // Current data is a number, convert to Array\n                perfData[id] = [perfData[id], elapsedTime];\n            }\n        } else {\n            perfData[id] = elapsedTime;\n        }\n\n        if (id.reent !== undefined) {\n            if (_reentTests[id] === 0) {\n                delete _reentTests[id];\n            } else {\n                _reentTests[id]--;\n            }\n        }\n        return elapsedTime;\n\n    }\n\n    /**\n     * This function is similar to addMeasurement(), but it allows timing the\n     * *last* event, when you don't know which event will be the last one.\n     *\n     * Tests that are in the activeTests list, have not yet been added, so add\n     * measurements to the performance data, and move test to updatableTests list.\n     * A test is moved to the updatable list so that it no longer passes isActive().\n     *\n     * Tests that are already in the updatableTests list are updated.\n     *\n     * Caller must explicitly remove test from the updatableTests list using\n     * finalizeMeasurement().\n     *\n     * If markStart() was not called for the specified timer, there is no way to\n     * determine if this is the first or subsequent call, so the measurement is\n     * not updatable, and it is handled in addMeasurement().\n     *\n     * @param {Object} id  Timer id.\n     */\n    function updateMeasurement(id) {\n        var elapsedTime = brackets.app.getElapsedMilliseconds();\n\n        if (updatableTests[id.id]) {\n            // update existing measurement\n            elapsedTime -= updatableTests[id].startTime;\n\n            // update\n            if (perfData[id] && Array.isArray(perfData[id])) {\n                // We have existing data and it's an array, so update the last entry\n                perfData[id][perfData[id].length - 1] = elapsedTime;\n            } else {\n                // No current data or a single entry, so set/update it\n                perfData[id] = elapsedTime;\n            }\n\n        } else {\n            // not yet in updatable list\n\n            if (activeTests[id.id]) {\n                // save startTime in updatable list before addMeasurement() deletes it\n                updatableTests[id.id] = { startTime: activeTests[id.id].startTime };\n            }\n\n            // let addMeasurement() handle the initial case\n            addMeasurement(id);\n        }\n    }\n\n    /**\n     * Remove timer from lists so next action starts a new measurement\n     *\n     * updateMeasurement may not have been called, so timer may be\n     * in either or neither list, but should never be in both.\n     *\n     * @param {Object} id  Timer id.\n     */\n    function finalizeMeasurement(id) {\n        if (activeTests[id.id]) {\n            delete activeTests[id.id];\n        }\n\n        if (updatableTests[id.id]) {\n            delete updatableTests[id.id];\n        }\n    }\n\n    /**\n     * Returns whether a timer is active or not, where \"active\" means that\n     * timer has been started with addMark(), but has not been added to perfdata\n     * with addMeasurement().\n     *\n     * @param {Object} id  Timer id.\n     * @return {boolean} Whether a timer is active or not.\n     */\n    function isActive(id) {\n        return (activeTests[id.id]) ? true : false;\n    }\n\n    /**\n     * return single value, or comma separated values for an array or return aggregated values with\n     * <min value, average, max value, standard deviation>\n     * @param   {Array}    entry          An array or a single value\n     * @param   {Boolean} aggregateStats If set, the returned value will be aggregated in the form -\n     *                                   <min(avg)max[standard deviation]>\n     * @return {String}   a single value, or comma separated values in an array or\n     *                     <min(avg)max[standard deviation]> if aggregateStats is set\n     */\n    function getValueAsString(entry, aggregateStats) {\n        if (!Array.isArray(entry)) {\n            return entry;\n        }\n\n        if (aggregateStats) {\n            var sum = 0,\n                avg,\n                min = _.min(entry),\n                max = _.max(entry),\n                sd,\n                variationSum = 0;\n\n            entry.forEach(function (value) {\n                sum += value;\n            });\n            avg = Math.round(sum / entry.length);\n            entry.forEach(function (value) {\n                variationSum += Math.pow(value - avg, 2);\n            });\n            sd = Math.round(Math.sqrt(variationSum / entry.length));\n            return min + \"(\" + avg + \")\" + max + \"[\" + sd + \"]\";\n        }\n        return entry.join(\", \");\n\n    }\n\n    /**\n     * Returns the performance data as a tab delimited string\n     * @return {string}\n     */\n    function getDelimitedPerfData() {\n        var result = \"\";\n        _.forEach(perfData, function (entry, testName) {\n            result += getValueAsString(entry) + \"\\t\" + testName + \"\\n\";\n        });\n\n        return result;\n    }\n\n    /**\n     * Returns the measured value for the given measurement name.\n     * @param {Object} id The measurement to retreive.\n     */\n    function getData(id) {\n        if (!id) {\n            return perfData;\n        }\n\n        return perfData[id];\n    }\n\n    /**\n     * Returns the Performance metrics to be logged for health report\n     * @return {Object} An object with the health data logs to be sent\n     */\n    function getHealthReport() {\n        var healthReport = {\n            projectLoadTimes: \"\",\n            fileOpenTimes: \"\"\n        };\n\n        _.forEach(perfData, function (entry, testName) {\n            if (StringUtils.startsWith(testName, \"Application Startup\")) {\n                healthReport.AppStartupTime = getValueAsString(entry);\n            } else if (StringUtils.startsWith(testName, \"brackets module dependencies resolved\")) {\n                healthReport.ModuleDepsResolved = getValueAsString(entry);\n            } else if (StringUtils.startsWith(testName, \"Load Project\")) {\n                healthReport.projectLoadTimes += \":\" + getValueAsString(entry, true);\n            } else if (StringUtils.startsWith(testName, \"Open File\")) {\n                healthReport.fileOpenTimes += \":\" + getValueAsString(entry, true);\n            }\n        });\n\n        return healthReport;\n    }\n\n    function searchData(regExp) {\n        var keys = Object.keys(perfData).filter(function (key) {\n            return regExp.test(key);\n        });\n\n        var datas = [];\n\n        keys.forEach(function (key) {\n            datas.push(perfData[key]);\n        });\n\n        return datas;\n    }\n\n    /**\n     * Clear all logs including metric data and active tests.\n     */\n    function clear() {\n        perfData = {};\n        activeTests = {};\n        updatableTests = {};\n        _reentTests = {};\n    }\n\n    // create performance measurement constants\n    createPerfMeasurement(\"INLINE_WIDGET_OPEN\", \"Open inline editor or docs\");\n    createPerfMeasurement(\"INLINE_WIDGET_CLOSE\", \"Close inline editor or docs\");\n\n    // extensions may create additional measurement constants during their lifecycle\n\n    exports.addMeasurement          = addMeasurement;\n    exports.finalizeMeasurement     = finalizeMeasurement;\n    exports.isActive                = isActive;\n    exports.markStart               = markStart;\n    exports.getData                 = getData;\n    exports.searchData              = searchData;\n    exports.updateMeasurement       = updateMeasurement;\n    exports.getDelimitedPerfData    = getDelimitedPerfData;\n    exports.createPerfMeasurement   = createPerfMeasurement;\n    exports.clear                   = clear;\n    exports.getHealthReport         = getHealthReport;\n});\n"],"file":"PerfUtils.js"}
{"version":3,"sources":["utils/ExtensionInterface.js"],"names":["define","require","exports","module","EVENT_EXTENSION_INTERFACE_REGISTERED","EventDispatcher","_extensionInterfaceMap","registerExtensionInterface","extensionInterfaceName","interfaceObject","trigger","isExistsExtensionInterface","undefined","waitAndGetExtensionInterface","Promise","resolve","reject","resolveIfInterfaceRegistered","event","registeredInterfaceName","interfaceObj","off","on","makeEventDispatcher"],"mappings":"AA+DAA,OAAO,SAAUC,QAASC,QAASC,QAC/B,MAAMC,qCAAuC,+BAE7C,IAAIC,gBAAkBJ,QAAQ,yBAE1BK,uBAAyB,GAY7B,SAASC,2BAA2BC,uBAAwBC,iBACxDH,uBAAuBE,wBAA0BC,gBACjDP,QAAQQ,QAAQN,qCAAsCI,uBAAwBC,iBASlF,SAASE,2BAA2BH,wBAChC,YAA0DI,IAAnDN,uBAAuBE,wBAoBlC,SAASK,6BAA6BL,wBAClC,OAAO,IAAIM,QAAQ,CAACC,QAASC,UACzB,GAAGL,2BAA2BH,wBAE1B,YADAO,QAAQT,uBAAuBE,yBAGnC,IAAIS,6BAA+B,SAAUC,MAAOC,wBAAyBC,cACtED,0BAA4BX,yBAC3BN,QAAQmB,IAAIjB,qCAAsCa,8BAClDF,QAAQK,gBAGhBlB,QAAQoB,GAAGlB,qCAAsCa,gCAIzDZ,gBAAgBkB,oBAAoBrB,SAEpCA,QAAQK,2BAA6BA,2BACrCL,QAAQW,6BAA+BA,6BACvCX,QAAQS,2BAA6BA,2BAErCT,QAAQE,qCAAuCA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global less */\n// jshint ignore: start\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * ExtensionInterface defines utility methods for communicating between extensions safely.\n * A global `window.ExtensionInterface` object is made available in phoenix that can be called anytime after AppStart.\n *\n * ## Usage\n * For Eg. You may have two extensions installed say `angular` extension which has to call functions made available by\n * `angular-cli` Extension.\n *\n * For Making this possible, the `angular-cli` extension makes a named interface available with the ExtensionInterface\n * module and `angular` extension can get hold of the interface as and when the extension gets loaded.\n *\n * ```js\n * // in angular-cli extension, make a file say cli-interface.js module within the extension, do the following:\n * const ExtensionInterface = brackets.getModule(\"utils/ExtensionInterface\"),\n * // You can replace exports with any object you want to expose outside the extension really.\n * ExtensionInterface.registerExtensionInterface(\"angularCli\", exports);\n * ```\n * Once the interface is registered, the angular extension can get hold of the interface with the following code\n * (inside or outside the extension) by using:\n *\n * ```js\n * let angularCli;\n * ExtensionInterface.waitAndGetExtensionInterface(\"angularCli\").then(interfaceObj=> angularCli = interfaceObj);\n * ...\n * if(angularCli){ // check if angular cli is avilable\n * angularCli.callSomeFunction();\n * }\n * ...\n * ```\n *\n * **Note** that the `angularCli` interface is async populated as and when the cli extension is loaded and the\n * interface made available.\n *\n * **NBB:** Do Not use `await waitAndGetExtensionInterface` on tol level require as the module loading might fail.\n *\n * @module utils/ExtensionInterface\n */\n\ndefine(function (require, exports, module) {\n    const EVENT_EXTENSION_INTERFACE_REGISTERED = \"extensionInterfaceRegistered\";\n\n    let EventDispatcher = require(\"utils/EventDispatcher\");\n\n    let _extensionInterfaceMap = {};\n\n    /**\n     * Registers a named extension interface. Will overwrite if an interface of the same name is already present.\n     *\n     * @example <caption>To register an interface `angularCli`</caption>\n     * ExtensionInterface.registerExtensionInterface(\"angularCli\", exports);\n     *\n     * @param {string} extensionInterfaceName\n     * @param {Object} interfaceObject\n     * @type {function}\n     */\n    function registerExtensionInterface(extensionInterfaceName, interfaceObject) {\n        _extensionInterfaceMap[extensionInterfaceName] = interfaceObject;\n        exports.trigger(EVENT_EXTENSION_INTERFACE_REGISTERED, extensionInterfaceName, interfaceObject);\n    }\n\n    /**\n     * Returns true is an interface of the given name exists.\n     * @param {string} extensionInterfaceName\n     * @return {boolean}\n     * @type {function}\n     */\n    function isExistsExtensionInterface(extensionInterfaceName) {\n        return _extensionInterfaceMap[extensionInterfaceName] !== undefined;\n    }\n\n    /**\n     * Returns a promise that gets resolved only when an ExtensionInterface of the given name is registered. Use this\n     * getter to get hold of extensions interface predictably.\n     *\n     * @example <caption>To get a registered interface `angularCli`</caption>\n     * let angularCli;\n     * ExtensionInterface.waitAndGetExtensionInterface(\"angularCli\").then(interfaceObj=> angularCli = interfaceObj);\n     * ...\n     * if(angularCli){ // check if angular cli is avilable\n     * angularCli.callSomeFunction();\n     * }\n     * ...\n     *\n     * @param extensionInterfaceName\n     * @return {Promise}\n     * @type {function}\n     */\n    function waitAndGetExtensionInterface(extensionInterfaceName) {\n        return new Promise((resolve, reject)=>{\n            if(isExistsExtensionInterface(extensionInterfaceName)){\n                resolve(_extensionInterfaceMap[extensionInterfaceName]);\n                return;\n            }\n            let resolveIfInterfaceRegistered = function (event, registeredInterfaceName, interfaceObj) {\n                if(registeredInterfaceName === extensionInterfaceName){\n                    exports.off(EVENT_EXTENSION_INTERFACE_REGISTERED, resolveIfInterfaceRegistered);\n                    resolve(interfaceObj);\n                }\n            };\n            exports.on(EVENT_EXTENSION_INTERFACE_REGISTERED, resolveIfInterfaceRegistered);\n        });\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n    // Public API\n    exports.registerExtensionInterface = registerExtensionInterface;\n    exports.waitAndGetExtensionInterface = waitAndGetExtensionInterface;\n    exports.isExistsExtensionInterface = isExistsExtensionInterface;\n    // Events\n    exports.EVENT_EXTENSION_INTERFACE_REGISTERED = EVENT_EXTENSION_INTERFACE_REGISTERED;\n});\n"],"file":"ExtensionInterface.js"}
{"version":3,"sources":["../node_modules/es6-promisify/dist/promisify.js","../node_modules/process/browser.js","../node_modules/path-browserify/index.js","path.js","shared.js","constants.js","../node_modules/base64-js/index.js","../node_modules/ieee754/index.js","../node_modules/isarray/index.js","../node_modules/buffer/index.js","providers/indexeddb.js","errors.js","../node_modules/base64-arraybuffer/lib/base64-arraybuffer.js","providers/websql.js","../lib/async.js","providers/memory.js","providers/index.js","shell/environment.js","../node_modules/concat-map/index.js","../node_modules/balanced-match/index.js","../node_modules/brace-expansion/index.js","../node_modules/minimatch/minimatch.js","shell/shell.js","../lib/eventemitter.js","../lib/intercom.js","fs-watcher.js","encoding.js","directory-entry.js","node.js","open-file-description.js","super-node.js","stats.js","filesystem/implementation.js","filesystem/interface.js","index.js"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","nodePath","require","filerPath","Object","create","basename","path","ext","normalize","removeTrailing","isNull","indexOf","addTrailing","replace","generateRandom","template","c","r","Math","random","v","toString","guid","toUpperCase","randomChars","n","repeat","nop","O_READ","O_WRITE","O_CREATE","O_EXCLUSIVE","O_TRUNCATE","O_APPEND","XATTR_CREATE","XATTR_REPLACE","FILE_SYSTEM_NAME","FILE_STORE_NAME","IDB_RO","IDB_RW","WSQL_VERSION","WSQL_SIZE","WSQL_DESC","NODE_TYPE_FILE","NODE_TYPE_DIRECTORY","NODE_TYPE_SYMBOLIC_LINK","NODE_TYPE_META","DEFAULT_DIR_PERMISSIONS","DEFAULT_FILE_PERMISSIONS","FULL_READ_WRITE_EXEC_PERMISSIONS","READ_WRITE_PERMISSIONS","SYMLOOP_MAX","BINARY_MIME_TYPE","JSON_MIME_TYPE","ROOT_DIRECTORY_NAME","FS_FORMAT","FS_NOCTIME","FS_NOMTIME","FS_NODUPEIDCHECK","O_FLAGS","FS_READY","FS_PENDING","FS_ERROR","SUPER_NODE_ID","STDIN","STDOUT","STDERR","FIRST_DESCRIPTOR","ENVIRONMENT","TMP","PATH","fsConstants","O_RDONLY","O_WRONLY","O_RDWR","S_IFMT","S_IFREG","S_IFDIR","S_IFCHR","S_IFBLK","S_IFIFO","S_IFLNK","S_IFSOCK","O_CREAT","O_EXCL","O_NOCTTY","O_TRUNC","O_DIRECTORY","O_NOFOLLOW","O_SYNC","O_DSYNC","O_SYMLINK","O_NONBLOCK","S_IRWXU","S_IRUSR","S_IWUSR","S_IXUSR","S_IRWXG","S_IRGRP","S_IWGRP","S_IXGRP","S_IRWXO","S_IROTH","S_IWOTH","S_IXOTH","F_OK","R_OK","W_OK","X_OK","UV_FS_COPYFILE_EXCL","COPYFILE_EXCL","indexedDB","global","mozIndexedDB","webkitIndexedDB","msIndexedDB","IndexedDBContext","db","mode","IndexedDB","_getObjectStore","objectStore","transaction","clear","callback","request","onsuccess","onerror","event","preventDefault","error","err","_get","key","get","result","target","getObject","getBuffer","arrayBuffer","Buffer","from","_put","value","put","putObject","putBuffer","uint8BackedBuffer","buf","buffer","delete","isSupported","open","that","openRequest","onupgradeneeded","objectStoreNames","contains","deleteObjectStore","createObjectStore","getReadOnlyContext","getReadWriteContext","errors","forEach","errno","split","errName","defaultMessage","FilerError","msg","code","message","stack","constructor","pathInfo","chars","lookup","Uint8Array","charCodeAt","encode","arraybuffer","bytes","base64","substring","decode","bufferLength","encoded1","encoded2","encoded3","encoded4","p","ArrayBuffer","Errors","base64ArrayBuffer","WebSQLContext","isReadOnly","getTransaction","onSuccess","rows","item","data","onError","executeSql","WebSQL","JSON","parse","json","stringify","openDatabase","EINVAL","createIndex","async","setImmediate","fn","eachSeries","arr","iterator","completed","iterate","forEachSeries","define","amd","root","asyncCallback","createDB","pool","hasOwnProperty","MemoryContext","readOnly","Memory","keys","Default","Fallback","NotSupported","defaults","set","promisify","Path","Environment","minimatch","Shell","fs","options","defineProperty","enumerable","cd","resolve","stat","stats","ENOTDIR","type","pwd","promises","methodName","bind","exec","sh","readFile","Function","cmd","touch","updateOnly","createFile","writeFile","updateTimes","now","Date","atime","date","mtime","utimes","cat","files","all","append","filename","ls","list","pathname","readdir","entries","getDirEntry","join","entry","recursive","items","contents","rm","remove","map","rmdir","ENOTEMPTY","unlink","tempDir","tmp","mkdir","mkdirp","_mkdirp","isDirectory","isFile","parent","dirname","find","next","found","maybeProcessPath","rawPath","regex","test","processPath","walk","removeItem","splice","EventEmitter","createInterface","space","methods","slice","self","pvt","_on","_off","_trigger","trigger","pub","unshift","throttle","delay","last","extend","a","b","localStorage","window","getItem","setItem","Intercom","origin","lastMessage","receivedIDs","previousValues","storageHandler","_onStorageEvent","document","attachEvent","addEventListener","_transaction","TIMEOUT","WAIT","executed","listening","waitTimer","lock","activeLock","INDEX_LOCK","unlock","_cleanup_emit","messages","threshold","THRESHOLD_TTL_EMIT","changed","INDEX_EMIT","timestamp","_cleanup_once","table","INDEX_ONCE","_once_expired","ttl","THRESHOLD_TTL_ONCE","_localStorageChanged","field","currentValue","id","payload","_emit","String","packet","delimiter","supported","destroy","getInstance","intercom","FSWatcher","recursivePathPrefix","onchange","start","filename_","persistent_","recursive_","close","string","ensureID","prop","generateMode","nodeType","modePermissions","Node","size","ctime","flags","xattrs","nlinks","permissions","uid","gid","OpenFileDescription","position","getNode","context","check_if_node_exists","node","EBADF","Constants","SuperNode","rnode","dateFromNumeric","num","Number","Stats","fileNode","devName","dev","atimeMs","mtimeMs","ctimeMs","isSymbolicLink","isSocket","isFIFO","isCharacterDevice","isBlockDevice","isAbsolutePath","isAbsolute","isNullPath","shared","Encoding","DirectoryEntry","update_node_times","times","includes","update","complete","changes","make_node","parentNode","parentNodeData","parentPath","EEXIST","ENOENT","create_node","update_parent_node_data","update_time","find_node","create_node_in_parent","parentDirectoryNode","followedCount","read_root_directory_node","nodeData","superNode","check_root_directory_node","EFILESYSTEMERROR","rootDirectoryNode","read_parent_directory_data","get_node_from_parent_directory_data","parentDirectoryData","nodeId","is_symbolic_link","follow_symbolic_link","ELOOP","set_extended_attribute","flag","ENOATTR","ensure_root_directory","directoryNode","directoryData","write_directory_node","write_directory_data","ensure_super_node","existingNode","make_directory","update_parent_directory_data","check_if_directory_exists","access_file","EACCES","remove_directory","EBUSY","check_if_node_is_directory","check_if_directory_is_empty","remove_directory_node","remove_directory_data","open_file","directoryEntry","fileData","read_directory_data","check_if_file_exists","EISDIR","check_if_symbolic_link","write_file_data","set_file_node","undefined","alloc","update_directory_data","handle_update_result","replace_data","ofd","offset","return_nbytes","update_file_node","newData","copy","write_data","update_file_data","EIO","_position","newSize","max","read_file_data","read_data","handle_file_data","stat_file","fstat_file","lstat_file","link_node","oldpath","newpath","oldname","oldParentPath","newname","oldDirectoryNode","oldDirectoryData","newDirectoryNode","newDirectoryData","fileNodeID","newParentPath","read_file_node","check_if_new_file_exists","read_new_directory_data","check_if_old_file_exists","EPERM","read_old_directory_data","unlink_node","delete_file_data","read_directory","handle_directory_data","make_symbolic_link","srcpath","dstpath","symlink_relpath","read_link","check_if_symbolic","truncate_file","truncate_file_data","ftruncate_file","utimes_file","update_times","futimes_file","setxattr_file","setxattr","fsetxattr_file","getxattr_file","get_xattr","fgetxattr_file","removexattr_file","remove_xattr","fremovexattr_file","validate_flags","validate_file_options","enc","fileMode","encoding","pathCheck","allowRelative","validateAndMaskMode","check_result","openFileDescription","fd","allocDescriptor","openFiles","releaseDescriptor","mknod","access","mkdtemp","prefix","fstat","link","read","wrapped_cb","bytesRead","fsync","validateInteger","cleanup","fstatResult","write","appendFile","exists","cb","octalReg","isUint32","def","isInteger","parseInt","chmod_file","update_mode","fchmod_file","chown_file","update_owner","fchown_file","getxattr","fgetxattr","fsetxattr","removexattr","fremovexattr","lseek","whence","update_descriptor_position","toUnixTimestamp","time","getTime","currentTime","futimes","chmod","fchmod","chown","fchown","rename","oldParentDirectory","oldParentData","newParentDirectory","newParentData","oldName","newName","check_node_type","unlink_old_file","read_new_directory","update_old_parent_directory_data","update_new_parent_directory_data","check_if_new_directory_exists","read_new_parent_directory_data","get_new_parent_directory","symlink","readlink","lstat","truncate","ftruncate","ensureRootDirectory","providers","defaultGuidFn","impl","maybeCallback","defaultCallback","console","FileSystem","provider","forceFormatting","readyState","stdin","stdout","stderr","constants","nextDescriptor","wrappedGuidFn","guidWithCheck","queueOrRun","operation","watch","listener","watcher","wrappedContext","broadcastChanges","change","openReadWriteContext","openReadOnlyContext","method","shouldPromisify","lastArgIndex","missingCallback","fnArgs"],"mappings":";AAAA,aAEA,OAAA,eAAA,QAAA,aAAA,CACA,OAAA,IAIA,IAAA,EAAA,OAAA,OAAA,uCAAA,sCAWA,SAAA,EAAA,GAGA,GAAA,mBAAA,EACA,MAAA,IAAA,UAAA,4CAIA,IAAA,EAAA,EAAA,GAIA,EAAA,EAAA,SAAA,QAGA,GAAA,mBAAA,EACA,MAAA,IAAA,MAAA,4DAGA,OAAA,WAGA,IAFA,IAAA,EAAA,KAEA,EAAA,UAAA,OAAA,EAAA,MAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,GAAA,UAAA,GAGA,OAAA,IAAA,EAAA,SAAA,EAAA,GAGA,EAAA,KAAA,SAAA,GAEA,GAAA,EACA,OAAA,EAAA,GAGA,IAAA,IAAA,EAAA,UAAA,OAAA,EAAA,MAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,GAAA,UAAA,GAGA,GAAA,IAAA,EAAA,SAAA,EACA,OAAA,EAAA,EAAA,IAGA,IAAA,EAAA,GACA,EAAA,QAAA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,GACA,IACA,EAAA,GAAA,KAIA,EAAA,KAIA,EAAA,KAAA,MAAA,EAAA,CAAA,GAAA,OAAA,OAMA,EAAA,cAAA,EACA,EAAA,aAAA,EAGA,QAAA,UAAA;;;AClFA,IAOIA,EACAC,EARAC,EAAUC,OAAOC,QAAU,GAU/B,SAASC,IACC,MAAA,IAAIC,MAAM,mCAEpB,SAASC,IACC,MAAA,IAAID,MAAM,qCAsBpB,SAASE,EAAWC,GACZT,GAAAA,IAAqBU,WAEdA,OAAAA,WAAWD,EAAK,GAGvB,IAACT,IAAqBK,IAAqBL,IAAqBU,WAEzDA,OADPV,EAAmBU,WACZA,WAAWD,EAAK,GAEvB,IAEOT,OAAAA,EAAiBS,EAAK,GAC/B,MAAME,GACA,IAEOX,OAAAA,EAAiBY,KAAK,KAAMH,EAAK,GAC1C,MAAME,GAEGX,OAAAA,EAAiBY,KAAK,KAAMH,EAAK,KAMpD,SAASI,EAAgBC,GACjBb,GAAAA,IAAuBc,aAEhBA,OAAAA,aAAaD,GAGpB,IAACb,IAAuBM,IAAwBN,IAAuBc,aAEhEA,OADPd,EAAqBc,aACdA,aAAaD,GAEpB,IAEOb,OAAAA,EAAmBa,GAC5B,MAAOH,GACD,IAEOV,OAAAA,EAAmBW,KAAK,KAAME,GACvC,MAAOH,GAGEV,OAAAA,EAAmBW,KAAK,KAAME,MAjEhD,WACO,IAEId,EADsB,mBAAfU,WACYA,WAEAL,EAEzB,MAAOM,GACLX,EAAmBK,EAEnB,IAEIJ,EADwB,mBAAjBc,aACcA,aAEAR,EAE3B,MAAOI,GACLV,EAAqBM,GAjB5B,GAwED,IAEIS,EAFAC,EAAQ,GACRC,GAAW,EAEXC,GAAc,EAElB,SAASC,IACAF,GAAaF,IAGlBE,GAAW,EACPF,EAAaK,OACbJ,EAAQD,EAAaM,OAAOL,GAE5BE,GAAc,EAEdF,EAAMI,QACNE,KAIR,SAASA,IACDL,IAAAA,EAAAA,CAGAM,IAAAA,EAAUhB,EAAWY,GACzBF,GAAW,EAGLO,IADFA,IAAAA,EAAMR,EAAMI,OACVI,GAAK,CAGA,IAFPT,EAAeC,EACfA,EAAQ,KACCE,EAAaM,GACdT,GACAA,EAAaG,GAAYO,MAGjCP,GAAc,EACdM,EAAMR,EAAMI,OAEhBL,EAAe,KACfE,GAAW,EACXL,EAAgBW,IAiBpB,SAASG,EAAKlB,EAAKmB,GACVnB,KAAAA,IAAMA,EACNmB,KAAAA,MAAQA,EAYjB,SAASC,KA5BT3B,EAAQ4B,SAAW,SAAUrB,GACrBsB,IAAAA,EAAO,IAAIC,MAAMC,UAAUZ,OAAS,GACpCY,GAAAA,UAAUZ,OAAS,EACd,IAAA,IAAIa,EAAI,EAAGA,EAAID,UAAUZ,OAAQa,IAClCH,EAAKG,EAAI,GAAKD,UAAUC,GAGhCjB,EAAMkB,KAAK,IAAIR,EAAKlB,EAAKsB,IACJ,IAAjBd,EAAMI,QAAiBH,GACvBV,EAAWe,IASnBI,EAAKS,UAAUV,IAAM,WACZjB,KAAAA,IAAI4B,MAAM,KAAM,KAAKT,QAE9B1B,EAAQoC,MAAQ,UAChBpC,EAAQqC,SAAU,EAClBrC,EAAQsC,IAAM,GACdtC,EAAQuC,KAAO,GACfvC,EAAQwC,QAAU,GAClBxC,EAAQyC,SAAW,GAInBzC,EAAQ0C,GAAKf,EACb3B,EAAQ2C,YAAchB,EACtB3B,EAAQ4C,KAAOjB,EACf3B,EAAQ6C,IAAMlB,EACd3B,EAAQ8C,eAAiBnB,EACzB3B,EAAQ+C,mBAAqBpB,EAC7B3B,EAAQgD,KAAOrB,EACf3B,EAAQiD,gBAAkBtB,EAC1B3B,EAAQkD,oBAAsBvB,EAE9B3B,EAAQmD,UAAY,SAAUC,GAAe,MAAA,IAE7CpD,EAAQqD,QAAU,SAAUD,GAClB,MAAA,IAAIhD,MAAM,qCAGpBJ,EAAQsD,IAAM,WAAqB,MAAA,KACnCtD,EAAQuD,MAAQ,SAAUC,GAChB,MAAA,IAAIpD,MAAM,mCAEpBJ,EAAQyD,MAAQ,WAAoB,OAAA;;;ACyCpC,IAAA,EAAA,QAAA,WAvMA,SAAA,EAAA,EAAA,GAGA,IADA,IAAA,EAAA,EACA,EAAA,EAAA,OAAA,EAAA,GAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,GACA,MAAA,EACA,EAAA,OAAA,EAAA,GACA,OAAA,GACA,EAAA,OAAA,EAAA,GACA,KACA,IACA,EAAA,OAAA,EAAA,GACA,KAKA,GAAA,EACA,KAAA,IAAA,EACA,EAAA,QAAA,MAIA,OAAA,EAKA,IAAA,EACA,gEACA,EAAA,SAAA,GACA,OAAA,EAAA,KAAA,GAAA,MAAA,IAuJA,SAAA,EAAA,EAAA,GACA,GAAA,EAAA,OAAA,OAAA,EAAA,OAAA,GAEA,IADA,IAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,KAAA,EAAA,IAEA,OAAA,EAxJA,QAAA,QAAA,WAIA,IAHA,IAAA,EAAA,GACA,GAAA,EAEA,EAAA,UAAA,OAAA,EAAA,IAAA,IAAA,EAAA,IAAA,CACA,IAAA,EAAA,GAAA,EAAA,UAAA,GAAA,EAAA,MAGA,GAAA,iBAAA,EACA,MAAA,IAAA,UAAA,6CACA,IAIA,EAAA,EAAA,IAAA,EACA,EAAA,MAAA,EAAA,OAAA,IAWA,OAAA,EAAA,IAAA,KAJA,EAAA,EAAA,EAAA,EAAA,MAAA,KAAA,SAAA,GACA,QAAA,KACA,GAAA,KAAA,OAEA,KAKA,QAAA,UAAA,SAAA,GACA,IAAA,EAAA,QAAA,WAAA,GACA,EAAA,MAAA,EAAA,GAAA,GAcA,OAXA,EAAA,EAAA,EAAA,EAAA,MAAA,KAAA,SAAA,GACA,QAAA,KACA,GAAA,KAAA,OAEA,IACA,EAAA,KAEA,GAAA,IACA,GAAA,MAGA,EAAA,IAAA,IAAA,GAIA,QAAA,WAAA,SAAA,GACA,MAAA,MAAA,EAAA,OAAA,IAIA,QAAA,KAAA,WACA,IAAA,EAAA,MAAA,UAAA,MAAA,KAAA,UAAA,GACA,OAAA,QAAA,UAAA,EAAA,EAAA,SAAA,EAAA,GACA,GAAA,iBAAA,EACA,MAAA,IAAA,UAAA,0CAEA,OAAA,IACA,KAAA,OAMA,QAAA,SAAA,SAAA,EAAA,GAIA,SAAA,EAAA,GAEA,IADA,IAAA,EAAA,EACA,EAAA,EAAA,QACA,KAAA,EAAA,GADA,KAKA,IADA,IAAA,EAAA,EAAA,OAAA,EACA,GAAA,GACA,KAAA,EAAA,GADA,KAIA,OAAA,EAAA,EAAA,GACA,EAAA,MAAA,EAAA,EAAA,EAAA,GAfA,EAAA,QAAA,QAAA,GAAA,OAAA,GACA,EAAA,QAAA,QAAA,GAAA,OAAA,GAsBA,IALA,IAAA,EAAA,EAAA,EAAA,MAAA,MACA,EAAA,EAAA,EAAA,MAAA,MAEA,EAAA,KAAA,IAAA,EAAA,OAAA,EAAA,QACA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,EAAA,KAAA,EAAA,GAAA,CACA,EAAA,EACA,MAIA,IAAA,EAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,EAAA,KAAA,MAKA,OAFA,EAAA,EAAA,OAAA,EAAA,MAAA,KAEA,KAAA,MAGA,QAAA,IAAA,IACA,QAAA,UAAA,IAEA,QAAA,QAAA,SAAA,GACA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,GACA,EAAA,EAAA,GAEA,OAAA,GAAA,GAKA,IAEA,EAAA,EAAA,OAAA,EAAA,EAAA,OAAA,IAGA,EAAA,GARA,KAYA,QAAA,SAAA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,GAAA,GAKA,OAHA,GAAA,EAAA,QAAA,EAAA,EAAA,UAAA,IACA,EAAA,EAAA,OAAA,EAAA,EAAA,OAAA,EAAA,SAEA,GAIA,QAAA,QAAA,SAAA,GACA,OAAA,EAAA,GAAA,IAaA,IAAA,EAAA,MAAA,KAAA,QAAA,GACA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,OAAA,EAAA,IACA,SAAA,EAAA,EAAA,GAEA,OADA,EAAA,IAAA,EAAA,EAAA,OAAA,GACA,EAAA,OAAA,EAAA;;;AC7KA,IAAA,EAAA,QAAA,WA5CAzD,EAAQsD,IAAM,WAAM,MAAA,KAOpB,IAAMI,EAAWC,QAAQ,QACnBC,EAAYC,OAAOC,OAAOJ,GAKhCE,EAAUG,SAAW,SAACC,EAAMC,GACpBF,IAAAA,EAAWL,EAASK,SAASC,EAAMC,GAClCF,MAAa,KAAbA,EAAkB,IAAMA,GAMjCH,EAAUM,UAAY,SAACF,GAEdA,MAAS,OADhBA,EAAON,EAASQ,UAAUF,IACJA,EAAOJ,EAAUO,eAAeH,IAMxDJ,EAAUQ,OAAS,SAAAJ,GAAQ,OAAmC,KAAlC,GAAKA,GAAMK,QAAQ,OAK/CT,EAAUU,YAAc,SAAAN,GAAQA,OAAAA,EAAKO,QAAQ,OAAQ,MAKrDX,EAAUO,eAAiB,SAAAH,GAElBA,MAAS,MADhBA,EAAOA,EAAKO,QAAQ,OAAQ,KACP,IAAMP,GAG7B/D,OAAOC,QAAU0D;;AChDjB,SAASY,EAAeC,GACfA,OAAAA,EAASF,QAAQ,QAAS,SAASG,GACpCC,IAAAA,EAAkB,GAAdC,KAAKC,SAAY,EAClBC,OAD+B,MAANJ,EAAYC,EAAO,EAAFA,EAAM,GAC9CI,SAAS,MAItB,SAASC,IACAR,OAAAA,EAAe,wCAAwCS,cAMhE,SAASC,EAAYC,GAGZX,OAAAA,EADQ,IAAIY,OADnBD,EAAIA,GAAK,IAKX,SAASE,KAETpF,OAAOC,QAAU,CACf8E,KAAMA,EACNK,IAAKA,EACLH,YAAaA;;ACzBf,IAAII,EAAS,OACTC,EAAU,QACVC,EAAW,SACXC,EAAc,YACdC,EAAa,WACbC,EAAW,SACXC,EAAe,SACfC,EAAgB,UAEpB5F,OAAOC,QAAU,CACf4F,iBAAkB,QAElBC,gBAAiB,QAEjBC,OAAQ,WACRC,OAAQ,YAERC,aAAc,IACdC,UAAW,QACXC,UAAW,qBAEXC,eAAgB,OAChBC,oBAAqB,YACrBC,wBAAyB,UACzBC,eAAgB,OAGhBC,wBAAyB,IACzBC,yBAA0B,IAC1BC,iCAAkC,IAClCC,uBAAwB,IAExBC,YAAa,GAEbC,iBAAkB,2BAClBC,eAAgB,mBAEhBC,oBAAqB,IAGrBC,UAAW,SACXC,WAAY,UACZC,WAAY,UACZC,iBAAkB,mBAGlB9B,OAAQA,EACRC,QAASA,EACTC,SAAUA,EACVC,YAAaA,EACbC,WAAYA,EACZC,SAAUA,EAEV0B,QAAS,CACF,EAAA,CAAC/B,GACA,KAAA,CAACA,EAAQC,GACV,EAAA,CAACA,EAASC,EAAUE,GACnB,KAAA,CAACH,EAASD,EAAQE,EAAUE,GAC5B,GAAA,CAACH,EAASC,EAAUC,EAAaC,GAChC,MAAA,CAACH,EAASD,EAAQE,EAAUC,EAAaC,GAC3C,EAAA,CAACH,EAASC,EAAUG,GACnB,KAAA,CAACJ,EAASD,EAAQE,EAAUG,GAC5B,GAAA,CAACJ,EAASC,EAAUC,EAAaE,GAChC,MAAA,CAACJ,EAASD,EAAQE,EAAUC,EAAaE,IAGlDC,aAAcA,EACdC,cAAeA,EAEfyB,SAAU,QACVC,WAAY,UACZC,SAAU,QAEVC,cAAe,uCAGfC,MAAO,EACPC,OAAQ,EACRC,OAAQ,EACRC,iBAAkB,EAElBC,YAAa,CACXC,IAAK,OACLC,KAAM,IAIRC,YAAa,CACXC,SAAU,EACVC,SAAU,EACVC,OAAQ,EACRC,OAAQ,MACRC,QAAS,MACTC,QAAS,MACTC,QAAS,KACTC,QAAS,MACTC,QAAS,KACTC,QAAS,MACTC,SAAU,MACVC,QAAS,IACTC,OAAQ,KACRC,SAAU,OACVC,QAAS,KACTrD,SAAU,EACVsD,YAAa,QACbC,WAAY,IACZC,OAAQ,IACRC,QAAS,QACTC,UAAW,QACXC,WAAY,EACZC,QAAS,IACTC,QAAS,IACTC,QAAS,IACTC,QAAS,GACTC,QAAS,GACTC,QAAS,GACTC,QAAS,GACTC,QAAS,EACTC,QAAS,EACTC,QAAS,EACTC,QAAS,EACTC,QAAS,EACTC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,oBAAqB,EACrBC,cAAe;;AC/HnB,aAEA,QAAA,WAAA,EACA,QAAA,YAAA,EACA,QAAA,cAAA,EAOA,IALA,IAAA,EAAA,GACA,EAAA,GACA,EAAA,oBAAA,WAAA,WAAA,MAEA,EAAA,mEACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EACA,EAAA,GAAA,EAAA,GACA,EAAA,EAAA,WAAA,IAAA,EAQA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,OAEA,GAAA,EAAA,EAAA,EACA,MAAA,IAAA,MAAA,kDAKA,IAAA,EAAA,EAAA,QAAA,KAOA,OANA,IAAA,IAAA,EAAA,GAMA,CAAA,EAJA,IAAA,EACA,EACA,EAAA,EAAA,GAMA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,GACA,EAAA,EAAA,GACA,OAAA,GAAA,EAAA,GAAA,EAAA,EAGA,SAAA,EAAA,EAAA,EAAA,GACA,OAAA,GAAA,EAAA,GAAA,EAAA,EAGA,SAAA,EAAA,GAeA,IAdA,IAAA,EACA,EAAA,EAAA,GACA,EAAA,EAAA,GACA,EAAA,EAAA,GAEA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAEA,EAAA,EAGA,EAAA,EAAA,EACA,EAAA,EACA,EAEA,EAAA,EAAA,EAAA,EAAA,GAAA,EACA,EACA,EAAA,EAAA,WAAA,KAAA,GACA,EAAA,EAAA,WAAA,EAAA,KAAA,GACA,EAAA,EAAA,WAAA,EAAA,KAAA,EACA,EAAA,EAAA,WAAA,EAAA,IACA,EAAA,KAAA,GAAA,GAAA,IACA,EAAA,KAAA,GAAA,EAAA,IACA,EAAA,KAAA,IAAA,EAmBA,OAhBA,IAAA,IACA,EACA,EAAA,EAAA,WAAA,KAAA,EACA,EAAA,EAAA,WAAA,EAAA,KAAA,EACA,EAAA,KAAA,IAAA,GAGA,IAAA,IACA,EACA,EAAA,EAAA,WAAA,KAAA,GACA,EAAA,EAAA,WAAA,EAAA,KAAA,EACA,EAAA,EAAA,WAAA,EAAA,KAAA,EACA,EAAA,KAAA,GAAA,EAAA,IACA,EAAA,KAAA,IAAA,GAGA,EAGA,SAAA,EAAA,GACA,OAAA,EAAA,GAAA,GAAA,IACA,EAAA,GAAA,GAAA,IACA,EAAA,GAAA,EAAA,IACA,EAAA,GAAA,GAGA,SAAA,EAAA,EAAA,EAAA,GAGA,IAFA,IAAA,EACA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,GAAA,EACA,GACA,EAAA,IAAA,GAAA,WACA,EAAA,EAAA,IAAA,EAAA,QACA,IAAA,EAAA,EAAA,IACA,EAAA,KAAA,EAAA,IAEA,OAAA,EAAA,KAAA,IAGA,SAAA,EAAA,GAQA,IAPA,IAAA,EACA,EAAA,EAAA,OACA,EAAA,EAAA,EACA,EAAA,GAIA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAHA,MAIA,EAAA,KAAA,EACA,EAAA,EAAA,EALA,MAKA,EAAA,EAAA,EALA,QA2BA,OAjBA,IAAA,GACA,EAAA,EAAA,EAAA,GACA,EAAA,KACA,EAAA,GAAA,GACA,EAAA,GAAA,EAAA,IACA,OAEA,IAAA,IACA,GAAA,EAAA,EAAA,IAAA,GAAA,EAAA,EAAA,GACA,EAAA,KACA,EAAA,GAAA,IACA,EAAA,GAAA,EAAA,IACA,EAAA,GAAA,EAAA,IACA,MAIA,EAAA,KAAA,IAnIA,EAAA,IAAA,WAAA,IAAA,GACA,EAAA,IAAA,WAAA,IAAA;;ACnBA,QAAA,KAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EACA,GAAA,GAAA,GAAA,EACA,EAAA,GAAA,EACA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,GAAA,EAAA,EACA,EAAA,EAAA,EAAA,GAOA,IALA,GAAA,EAEA,EAAA,GAAA,IAAA,GAAA,EACA,KAAA,EACA,GAAA,EACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAKA,IAHA,EAAA,GAAA,IAAA,GAAA,EACA,KAAA,EACA,GAAA,EACA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,GAEA,GAAA,IAAA,EACA,EAAA,EAAA,MACA,CAAA,GAAA,IAAA,EACA,OAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAEA,GAAA,KAAA,IAAA,EAAA,GACA,GAAA,EAEA,OAAA,GAAA,EAAA,GAAA,EAAA,KAAA,IAAA,EAAA,EAAA,IAGA,QAAA,MAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EACA,GAAA,GAAA,GAAA,EACA,EAAA,GAAA,EACA,EAAA,KAAA,EAAA,KAAA,IAAA,GAAA,IAAA,KAAA,IAAA,GAAA,IAAA,EACA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,GAAA,EACA,EAAA,EAAA,GAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAmCA,IAjCA,EAAA,KAAA,IAAA,GAEA,MAAA,IAAA,IAAA,EAAA,GACA,EAAA,MAAA,GAAA,EAAA,EACA,EAAA,IAEA,EAAA,KAAA,MAAA,KAAA,IAAA,GAAA,KAAA,KACA,GAAA,EAAA,KAAA,IAAA,GAAA,IAAA,IACA,IACA,GAAA,IAGA,GADA,EAAA,GAAA,EACA,EAAA,EAEA,EAAA,KAAA,IAAA,EAAA,EAAA,IAEA,GAAA,IACA,IACA,GAAA,GAGA,EAAA,GAAA,GACA,EAAA,EACA,EAAA,GACA,EAAA,GAAA,GACA,GAAA,EAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GACA,GAAA,IAEA,EAAA,EAAA,KAAA,IAAA,EAAA,EAAA,GAAA,KAAA,IAAA,EAAA,GACA,EAAA,IAIA,GAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,GAAA,EAAA,GAAA,IAAA,GAAA,GAIA,IAFA,EAAA,GAAA,EAAA,EACA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,GAAA,EAAA,GAAA,IAAA,GAAA,GAEA,EAAA,EAAA,EAAA,IAAA,IAAA;;AClFA,IAAA,EAAA,GAAA,SAEA,OAAA,QAAA,MAAA,SAAA,SAAA,GACA,MAAA,kBAAA,EAAA,KAAA;;;;AC0vDA,IAAA,EAAA,UAAA,GAnvDA,EAAA,QAAA,aACA,EAAA,QAAA,WACA,EAAA,QAAA,WAuCA,SAAA,IACA,IACA,IAAA,EAAA,IAAA,WAAA,GAEA,OADA,EAAA,UAAA,CAAA,UAAA,WAAA,UAAA,IAAA,WAAA,OAAA,KACA,KAAA,EAAA,OACA,mBAAA,EAAA,UACA,IAAA,EAAA,SAAA,EAAA,GAAA,WACA,MAAA,GACA,OAAA,GAIA,SAAA,IACA,OAAA,EAAA,oBACA,WACA,WAGA,SAAA,EAAA,EAAA,GACA,GAAA,IAAA,EACA,MAAA,IAAA,WAAA,8BAcA,OAZA,EAAA,qBAEA,EAAA,IAAA,WAAA,IACA,UAAA,EAAA,WAGA,OAAA,IACA,EAAA,IAAA,EAAA,IAEA,EAAA,OAAA,GAGA,EAaA,SAAA,EAAA,EAAA,EAAA,GACA,KAAA,EAAA,qBAAA,gBAAA,GACA,OAAA,IAAA,EAAA,EAAA,EAAA,GAIA,GAAA,iBAAA,EAAA,CACA,GAAA,iBAAA,EACA,MAAA,IAAA,MACA,qEAGA,OAAA,EAAA,KAAA,GAEA,OAAA,EAAA,KAAA,EAAA,EAAA,GAWA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,iBAAA,EACA,MAAA,IAAA,UAAA,yCAGA,MAAA,oBAAA,aAAA,aAAA,YACA,EAAA,EAAA,EAAA,EAAA,GAGA,iBAAA,EACA,EAAA,EAAA,EAAA,GAGA,EAAA,EAAA,GA4BA,SAAA,EAAA,GACA,GAAA,iBAAA,EACA,MAAA,IAAA,UAAA,oCACA,GAAA,EAAA,EACA,MAAA,IAAA,WAAA,wCAIA,SAAA,EAAA,EAAA,EAAA,EAAA,GAEA,OADA,EAAA,GACA,GAAA,EACA,EAAA,EAAA,QAEA,IAAA,EAIA,iBAAA,EACA,EAAA,EAAA,GAAA,KAAA,EAAA,GACA,EAAA,EAAA,GAAA,KAAA,GAEA,EAAA,EAAA,GAWA,SAAA,EAAA,EAAA,GAGA,GAFA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KACA,EAAA,oBACA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EACA,EAAA,GAAA,EAGA,OAAA,EAgBA,SAAA,EAAA,EAAA,EAAA,GAKA,GAJA,iBAAA,GAAA,KAAA,IACA,EAAA,SAGA,EAAA,WAAA,GACA,MAAA,IAAA,UAAA,8CAGA,IAAA,EAAA,EAAA,EAAA,EAAA,GAGA,GAFA,EAAA,EAAA,EAAA,IAEA,MAAA,EAAA,GASA,OAPA,IAAA,IAIA,EAAA,EAAA,MAAA,EAAA,IAGA,EAGA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,QACA,EAAA,EAAA,EAAA,GACA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,GAAA,IAAA,EAAA,GAEA,OAAA,EAGA,SAAA,EAAA,EAAA,EAAA,EAAA,GAGA,GAFA,EAAA,WAEA,EAAA,GAAA,EAAA,WAAA,EACA,MAAA,IAAA,WAAA,6BAGA,GAAA,EAAA,WAAA,GAAA,GAAA,GACA,MAAA,IAAA,WAAA,6BAmBA,OAfA,OADA,IAAA,QAAA,IAAA,EACA,IAAA,WAAA,QACA,IAAA,EACA,IAAA,WAAA,EAAA,GAEA,IAAA,WAAA,EAAA,EAAA,GAGA,EAAA,qBAEA,EAAA,GACA,UAAA,EAAA,UAGA,EAAA,EAAA,EAAA,GAEA,EAGA,SAAA,EAAA,EAAA,GACA,GAAA,EAAA,SAAA,GAAA,CACA,IAAA,EAAA,EAAA,EAAA,EAAA,QAGA,OAAA,KAFA,EAAA,EAAA,EAAA,IAEA,OACA,GAGA,EAAA,KAAA,EAAA,EAAA,EAAA,GACA,GAGA,GAAA,EAAA,CACA,GAAA,oBAAA,aACA,EAAA,kBAAA,aAAA,WAAA,EACA,MAAA,iBAAA,EAAA,QAAA,EAAA,EAAA,QACA,EAAA,EAAA,GAEA,EAAA,EAAA,GAGA,GAAA,WAAA,EAAA,MAAA,EAAA,EAAA,MACA,OAAA,EAAA,EAAA,EAAA,MAIA,MAAA,IAAA,UAAA,sFAGA,SAAA,EAAA,GAGA,GAAA,GAAA,IACA,MAAA,IAAA,WAAA,0DACA,IAAA,SAAA,IAAA,UAEA,OAAA,EAAA,EAGA,SAAA,EAAA,GAIA,OAHA,GAAA,IACA,EAAA,GAEA,EAAA,OAAA,GA+EA,SAAA,EAAA,EAAA,GACA,GAAA,EAAA,SAAA,GACA,OAAA,EAAA,OAEA,GAAA,oBAAA,aAAA,mBAAA,YAAA,SACA,YAAA,OAAA,IAAA,aAAA,aACA,OAAA,EAAA,WAEA,iBAAA,IACA,EAAA,GAAA,GAGA,IAAA,EAAA,EAAA,OACA,GAAA,IAAA,EAAA,OAAA,EAIA,IADA,IAAA,GAAA,IAEA,OAAA,GACA,IAAA,QACA,IAAA,SACA,IAAA,SACA,OAAA,EACA,IAAA,OACA,IAAA,QACA,UAAA,EACA,OAAA,EAAA,GAAA,OACA,IAAA,OACA,IAAA,QACA,IAAA,UACA,IAAA,WACA,OAAA,EAAA,EACA,IAAA,MACA,OAAA,IAAA,EACA,IAAA,SACA,OAAA,EAAA,GAAA,OACA,QACA,GAAA,EAAA,OAAA,EAAA,GAAA,OACA,GAAA,GAAA,GAAA,cACA,GAAA,GAMA,SAAA,EAAA,EAAA,EAAA,GACA,IAAA,GAAA,EAcA,SALA,IAAA,GAAA,EAAA,KACA,EAAA,GAIA,EAAA,KAAA,OACA,MAAA,GAOA,SAJA,IAAA,GAAA,EAAA,KAAA,UACA,EAAA,KAAA,QAGA,GAAA,EACA,MAAA,GAOA,IAHA,KAAA,KACA,KAAA,GAGA,MAAA,GAKA,IAFA,IAAA,EAAA,UAGA,OAAA,GACA,IAAA,MACA,OAAA,EAAA,KAAA,EAAA,GAEA,IAAA,OACA,IAAA,QACA,OAAA,EAAA,KAAA,EAAA,GAEA,IAAA,QACA,OAAA,EAAA,KAAA,EAAA,GAEA,IAAA,SACA,IAAA,SACA,OAAA,EAAA,KAAA,EAAA,GAEA,IAAA,SACA,OAAA,EAAA,KAAA,EAAA,GAEA,IAAA,OACA,IAAA,QACA,IAAA,UACA,IAAA,WACA,OAAA,EAAA,KAAA,EAAA,GAEA,QACA,GAAA,EAAA,MAAA,IAAA,UAAA,qBAAA,GACA,GAAA,EAAA,IAAA,cACA,GAAA,GASA,SAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,GACA,EAAA,GAAA,EAAA,GACA,EAAA,GAAA,EAmIA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAEA,GAAA,IAAA,EAAA,OAAA,OAAA,EAmBA,GAhBA,iBAAA,GACA,EAAA,EACA,EAAA,GACA,EAAA,WACA,EAAA,WACA,GAAA,aACA,GAAA,YAEA,GAAA,EACA,MAAA,KAEA,EAAA,EAAA,EAAA,EAAA,OAAA,GAIA,EAAA,IAAA,EAAA,EAAA,OAAA,GACA,GAAA,EAAA,OAAA,CACA,GAAA,EAAA,OAAA,EACA,EAAA,EAAA,OAAA,OACA,GAAA,EAAA,EAAA,CACA,IAAA,EACA,OAAA,EADA,EAAA,EAUA,GALA,iBAAA,IACA,EAAA,EAAA,KAAA,EAAA,IAIA,EAAA,SAAA,GAEA,OAAA,IAAA,EAAA,QACA,EAEA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,iBAAA,EAEA,OADA,GAAA,IACA,EAAA,qBACA,mBAAA,WAAA,UAAA,QACA,EACA,WAAA,UAAA,QAAA,KAAA,EAAA,EAAA,GAEA,WAAA,UAAA,YAAA,KAAA,EAAA,EAAA,GAGA,EAAA,EAAA,CAAA,GAAA,EAAA,EAAA,GAGA,MAAA,IAAA,UAAA,wCAGA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,IA0BA,EA1BA,EAAA,EACA,EAAA,EAAA,OACA,EAAA,EAAA,OAEA,QAAA,IAAA,IAEA,UADA,EAAA,OAAA,GAAA,gBACA,UAAA,GACA,YAAA,GAAA,aAAA,GAAA,CACA,GAAA,EAAA,OAAA,GAAA,EAAA,OAAA,EACA,OAAA,EAEA,EAAA,EACA,GAAA,EACA,GAAA,EACA,GAAA,EAIA,SAAA,EAAA,EAAA,GACA,OAAA,IAAA,EACA,EAAA,GAEA,EAAA,aAAA,EAAA,GAKA,GAAA,EAAA,CACA,IAAA,GAAA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,KAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,IAEA,IADA,IAAA,IAAA,EAAA,GACA,EAAA,EAAA,IAAA,EAAA,OAAA,EAAA,OAEA,IAAA,IAAA,GAAA,EAAA,GACA,GAAA,OAKA,IADA,EAAA,EAAA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,GAAA,EAAA,IAAA,CAEA,IADA,IAAA,GAAA,EACA,EAAA,EAAA,EAAA,EAAA,IACA,GAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,GAAA,CACA,GAAA,EACA,MAGA,GAAA,EAAA,OAAA,EAIA,OAAA,EAeA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,OAAA,IAAA,EACA,IAAA,EAAA,EAAA,OAAA,EACA,GAGA,EAAA,OAAA,IACA,IACA,EAAA,GAJA,EAAA,EASA,IAAA,EAAA,EAAA,OACA,GAAA,EAAA,GAAA,EAAA,MAAA,IAAA,UAAA,sBAEA,EAAA,EAAA,IACA,EAAA,EAAA,GAEA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EAAA,CACA,IAAA,EAAA,SAAA,EAAA,OAAA,EAAA,EAAA,GAAA,IACA,GAAA,MAAA,GAAA,OAAA,EACA,EAAA,EAAA,GAAA,EAEA,OAAA,EAGA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,OAAA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,EAAA,EAAA,GAGA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,OAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAGA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,OAAA,EAAA,EAAA,EAAA,EAAA,GAGA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,OAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAGA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,OAAA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,EAAA,EAAA,GAkFA,SAAA,EAAA,EAAA,EAAA,GACA,OAAA,IAAA,GAAA,IAAA,EAAA,OACA,EAAA,cAAA,GAEA,EAAA,cAAA,EAAA,MAAA,EAAA,IAIA,SAAA,EAAA,EAAA,EAAA,GACA,EAAA,KAAA,IAAA,EAAA,OAAA,GAIA,IAHA,IAAA,EAAA,GAEA,EAAA,EACA,EAAA,GAAA,CACA,IAQA,EAAA,EAAA,EAAA,EARA,EAAA,EAAA,GACA,EAAA,KACA,EAAA,EAAA,IAAA,EACA,EAAA,IAAA,EACA,EAAA,IAAA,EACA,EAEA,GAAA,EAAA,GAAA,EAGA,OAAA,GACA,KAAA,EACA,EAAA,MACA,EAAA,GAEA,MACA,KAAA,EAEA,MAAA,KADA,EAAA,EAAA,EAAA,OAEA,GAAA,GAAA,IAAA,EAAA,GAAA,GACA,MACA,EAAA,GAGA,MACA,KAAA,EACA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GACA,MAAA,IAAA,IAAA,MAAA,IAAA,KACA,GAAA,GAAA,IAAA,IAAA,GAAA,IAAA,EAAA,GAAA,GACA,OAAA,EAAA,OAAA,EAAA,SACA,EAAA,GAGA,MACA,KAAA,EACA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GACA,EAAA,EAAA,EAAA,GACA,MAAA,IAAA,IAAA,MAAA,IAAA,IAAA,MAAA,IAAA,KACA,GAAA,GAAA,IAAA,IAAA,GAAA,IAAA,IAAA,GAAA,IAAA,EAAA,GAAA,GACA,OAAA,EAAA,UACA,EAAA,GAMA,OAAA,GAGA,EAAA,MACA,EAAA,GACA,EAAA,QAEA,GAAA,MACA,EAAA,KAAA,IAAA,GAAA,KAAA,OACA,EAAA,MAAA,KAAA,GAGA,EAAA,KAAA,GACA,GAAA,EAGA,OAAA,EAAA,GA98BA,QAAA,OAAA,EACA,QAAA,WAAA,EACA,QAAA,kBAAA,GA0BA,EAAA,yBAAA,IAAA,EAAA,oBACA,EAAA,oBACA,IAKA,QAAA,WAAA,IAkEA,EAAA,SAAA,KAGA,EAAA,SAAA,SAAA,GAEA,OADA,EAAA,UAAA,EAAA,UACA,GA2BA,EAAA,KAAA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,KAAA,EAAA,EAAA,IAGA,EAAA,sBACA,EAAA,UAAA,UAAA,WAAA,UACA,EAAA,UAAA,WACA,oBAAA,QAAA,OAAA,SACA,EAAA,OAAA,WAAA,GAEA,OAAA,eAAA,EAAA,OAAA,QAAA,CACA,MAAA,KACA,cAAA,KAiCA,EAAA,MAAA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,KAAA,EAAA,EAAA,IAiBA,EAAA,YAAA,SAAA,GACA,OAAA,EAAA,KAAA,IAKA,EAAA,gBAAA,SAAA,GACA,OAAA,EAAA,KAAA,IAiHA,EAAA,SAAA,SAAA,GACA,QAAA,MAAA,IAAA,EAAA,YAGA,EAAA,QAAA,SAAA,EAAA,GACA,IAAA,EAAA,SAAA,KAAA,EAAA,SAAA,GACA,MAAA,IAAA,UAAA,6BAGA,GAAA,IAAA,EAAA,OAAA,EAKA,IAHA,IAAA,EAAA,EAAA,OACA,EAAA,EAAA,OAEA,EAAA,EAAA,EAAA,KAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EACA,GAAA,EAAA,KAAA,EAAA,GAAA,CACA,EAAA,EAAA,GACA,EAAA,EAAA,GACA,MAIA,OAAA,EAAA,GAAA,EACA,EAAA,EAAA,EACA,GAGA,EAAA,WAAA,SAAA,GACA,OAAA,OAAA,GAAA,eACA,IAAA,MACA,IAAA,OACA,IAAA,QACA,IAAA,QACA,IAAA,SACA,IAAA,SACA,IAAA,SACA,IAAA,OACA,IAAA,QACA,IAAA,UACA,IAAA,WACA,OAAA,EACA,QACA,OAAA,IAIA,EAAA,OAAA,SAAA,EAAA,GACA,IAAA,EAAA,GACA,MAAA,IAAA,UAAA,+CAGA,GAAA,IAAA,EAAA,OACA,OAAA,EAAA,MAAA,GAGA,IAAA,EACA,QAAA,IAAA,EAEA,IADA,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,SAAA,EACA,GAAA,EAAA,GAAA,OAIA,IAAA,EAAA,EAAA,YAAA,GACA,EAAA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,SAAA,EAAA,CACA,IAAA,EAAA,EAAA,GACA,IAAA,EAAA,SAAA,GACA,MAAA,IAAA,UAAA,+CAEA,EAAA,KAAA,EAAA,GACA,GAAA,EAAA,OAEA,OAAA,GA8CA,EAAA,WAAA,EA0EA,EAAA,UAAA,WAAA,EAQA,EAAA,UAAA,OAAA,WACA,IAAA,EAAA,KAAA,OACA,GAAA,EAAA,GAAA,EACA,MAAA,IAAA,WAAA,6CAEA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,KAAA,EAAA,EAAA,GAEA,OAAA,MAGA,EAAA,UAAA,OAAA,WACA,IAAA,EAAA,KAAA,OACA,GAAA,EAAA,GAAA,EACA,MAAA,IAAA,WAAA,6CAEA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,KAAA,EAAA,EAAA,GACA,EAAA,KAAA,EAAA,EAAA,EAAA,GAEA,OAAA,MAGA,EAAA,UAAA,OAAA,WACA,IAAA,EAAA,KAAA,OACA,GAAA,EAAA,GAAA,EACA,MAAA,IAAA,WAAA,6CAEA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EACA,EAAA,KAAA,EAAA,EAAA,GACA,EAAA,KAAA,EAAA,EAAA,EAAA,GACA,EAAA,KAAA,EAAA,EAAA,EAAA,GACA,EAAA,KAAA,EAAA,EAAA,EAAA,GAEA,OAAA,MAGA,EAAA,UAAA,SAAA,WACA,IAAA,EAAA,EAAA,KAAA,OACA,OAAA,IAAA,EAAA,GACA,IAAA,UAAA,OAAA,EAAA,KAAA,EAAA,GACA,EAAA,MAAA,KAAA,YAGA,EAAA,UAAA,OAAA,SAAA,GACA,IAAA,EAAA,SAAA,GAAA,MAAA,IAAA,UAAA,6BACA,OAAA,OAAA,GACA,IAAA,EAAA,QAAA,KAAA,IAGA,EAAA,UAAA,QAAA,WACA,IAAA,EAAA,GACA,EAAA,QAAA,kBAKA,OAJA,KAAA,OAAA,IACA,EAAA,KAAA,SAAA,MAAA,EAAA,GAAA,MAAA,SAAA,KAAA,KACA,KAAA,OAAA,IAAA,GAAA,UAEA,WAAA,EAAA,KAGA,EAAA,UAAA,QAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,SAAA,GACA,MAAA,IAAA,UAAA,6BAgBA,QAbA,IAAA,IACA,EAAA,QAEA,IAAA,IACA,EAAA,EAAA,EAAA,OAAA,QAEA,IAAA,IACA,EAAA,QAEA,IAAA,IACA,EAAA,KAAA,QAGA,EAAA,GAAA,EAAA,EAAA,QAAA,EAAA,GAAA,EAAA,KAAA,OACA,MAAA,IAAA,WAAA,sBAGA,GAAA,GAAA,GAAA,GAAA,EACA,OAAA,EAEA,GAAA,GAAA,EACA,OAAA,EAEA,GAAA,GAAA,EACA,OAAA,EAQA,GAAA,OAAA,EAAA,OAAA,EASA,IAPA,IAAA,GAJA,KAAA,IADA,KAAA,GAMA,GAPA,KAAA,IADA,KAAA,GASA,EAAA,KAAA,IAAA,EAAA,GAEA,EAAA,KAAA,MAAA,EAAA,GACA,EAAA,EAAA,MAAA,EAAA,GAEA,EAAA,EAAA,EAAA,IAAA,EACA,GAAA,EAAA,KAAA,EAAA,GAAA,CACA,EAAA,EAAA,GACA,EAAA,EAAA,GACA,MAIA,OAAA,EAAA,GAAA,EACA,EAAA,EAAA,EACA,GA6HA,EAAA,UAAA,SAAA,SAAA,EAAA,EAAA,GACA,OAAA,IAAA,KAAA,QAAA,EAAA,EAAA,IAGA,EAAA,UAAA,QAAA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,KAAA,EAAA,EAAA,GAAA,IAGA,EAAA,UAAA,YAAA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,KAAA,EAAA,EAAA,GAAA,IAkDA,EAAA,UAAA,MAAA,SAAA,EAAA,EAAA,EAAA,GAEA,QAAA,IAAA,EACA,EAAA,OACA,EAAA,KAAA,OACA,EAAA,OAEA,QAAA,IAAA,GAAA,iBAAA,EACA,EAAA,EACA,EAAA,KAAA,OACA,EAAA,MAEA,CAAA,IAAA,SAAA,GAWA,MAAA,IAAA,MACA,2EAXA,GAAA,EACA,SAAA,IACA,GAAA,OACA,IAAA,IAAA,EAAA,UAEA,EAAA,EACA,OAAA,GASA,IAAA,EAAA,KAAA,OAAA,EAGA,SAFA,IAAA,GAAA,EAAA,KAAA,EAAA,GAEA,EAAA,OAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA,KAAA,OACA,MAAA,IAAA,WAAA,0CAGA,IAAA,EAAA,QAGA,IADA,IAAA,GAAA,IAEA,OAAA,GACA,IAAA,MACA,OAAA,EAAA,KAAA,EAAA,EAAA,GAEA,IAAA,OACA,IAAA,QACA,OAAA,EAAA,KAAA,EAAA,EAAA,GAEA,IAAA,QACA,OAAA,EAAA,KAAA,EAAA,EAAA,GAEA,IAAA,SACA,IAAA,SACA,OAAA,EAAA,KAAA,EAAA,EAAA,GAEA,IAAA,SAEA,OAAA,EAAA,KAAA,EAAA,EAAA,GAEA,IAAA,OACA,IAAA,QACA,IAAA,UACA,IAAA,WACA,OAAA,EAAA,KAAA,EAAA,EAAA,GAEA,QACA,GAAA,EAAA,MAAA,IAAA,UAAA,qBAAA,GACA,GAAA,GAAA,GAAA,cACA,GAAA,IAKA,EAAA,UAAA,OAAA,WACA,MAAA,CACA,KAAA,SACA,KAAA,MAAA,UAAA,MAAA,KAAA,KAAA,MAAA,KAAA,KAwFA,IAAA,EAAA,KAEA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,OACA,GAAA,GAAA,EACA,OAAA,OAAA,aAAA,MAAA,OAAA,GAMA,IAFA,IAAA,EAAA,GACA,EAAA,EACA,EAAA,GACA,GAAA,OAAA,aAAA,MACA,OACA,EAAA,MAAA,EAAA,GAAA,IAGA,OAAA,EAGA,SAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,GACA,EAAA,KAAA,IAAA,EAAA,OAAA,GAEA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EACA,GAAA,OAAA,aAAA,IAAA,EAAA,IAEA,OAAA,EAGA,SAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,GACA,EAAA,KAAA,IAAA,EAAA,OAAA,GAEA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EACA,GAAA,OAAA,aAAA,EAAA,IAEA,OAAA,EAGA,SAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,SAEA,GAAA,EAAA,KAAA,EAAA,KACA,GAAA,EAAA,GAAA,EAAA,KAAA,EAAA,GAGA,IADA,IAAA,EAAA,GACA,EAAA,EAAA,EAAA,IAAA,EACA,GAAA,EAAA,EAAA,IAEA,OAAA,EAGA,SAAA,EAAA,EAAA,EAAA,GAGA,IAFA,IAAA,EAAA,EAAA,MAAA,EAAA,GACA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,EACA,GAAA,OAAA,aAAA,EAAA,GAAA,IAAA,EAAA,EAAA,IAEA,OAAA,EA0CA,SAAA,EAAA,EAAA,EAAA,GACA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,IAAA,WAAA,sBACA,GAAA,EAAA,EAAA,EAAA,MAAA,IAAA,WAAA,yCA+JA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,SAAA,GAAA,MAAA,IAAA,UAAA,+CACA,GAAA,EAAA,GAAA,EAAA,EAAA,MAAA,IAAA,WAAA,qCACA,GAAA,EAAA,EAAA,EAAA,OAAA,MAAA,IAAA,WAAA,sBAkDA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,IAAA,EAAA,MAAA,EAAA,GACA,IAAA,IAAA,EAAA,EAAA,EAAA,KAAA,IAAA,EAAA,OAAA,EAAA,GAAA,EAAA,IAAA,EACA,EAAA,EAAA,IAAA,EAAA,KAAA,GAAA,EAAA,EAAA,EAAA,MACA,GAAA,EAAA,EAAA,EAAA,GA8BA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,EAAA,IAAA,EAAA,WAAA,EAAA,GACA,IAAA,IAAA,EAAA,EAAA,EAAA,KAAA,IAAA,EAAA,OAAA,EAAA,GAAA,EAAA,IAAA,EACA,EAAA,EAAA,GAAA,IAAA,GAAA,EAAA,EAAA,EAAA,GAAA,IAmJA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GACA,GAAA,EAAA,EAAA,EAAA,OAAA,MAAA,IAAA,WAAA,sBACA,GAAA,EAAA,EAAA,MAAA,IAAA,WAAA,sBAGA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAKA,OAJA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,uBAAA,uBAEA,EAAA,MAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GACA,EAAA,EAWA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAKA,OAJA,GACA,EAAA,EAAA,EAAA,EAAA,EAAA,wBAAA,wBAEA,EAAA,MAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GACA,EAAA,EA/cA,EAAA,UAAA,MAAA,SAAA,EAAA,GACA,IAoBA,EApBA,EAAA,KAAA,OAqBA,IApBA,IAAA,GAGA,GACA,GAAA,GACA,IAAA,EAAA,GACA,EAAA,IACA,EAAA,IANA,OAAA,IAAA,EAAA,IAAA,GASA,GACA,GAAA,GACA,IAAA,EAAA,GACA,EAAA,IACA,EAAA,GAGA,EAAA,IAAA,EAAA,GAGA,EAAA,qBACA,EAAA,KAAA,SAAA,EAAA,IACA,UAAA,EAAA,cACA,CACA,IAAA,EAAA,EAAA,EACA,EAAA,IAAA,EAAA,OAAA,GACA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EACA,EAAA,GAAA,KAAA,EAAA,GAIA,OAAA,GAWA,EAAA,UAAA,WAAA,SAAA,EAAA,EAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,EAAA,EAAA,KAAA,QAKA,IAHA,IAAA,EAAA,KAAA,GACA,EAAA,EACA,EAAA,IACA,EAAA,IAAA,GAAA,MACA,GAAA,KAAA,EAAA,GAAA,EAGA,OAAA,GAGA,EAAA,UAAA,WAAA,SAAA,EAAA,EAAA,GACA,GAAA,EACA,GAAA,EACA,GACA,EAAA,EAAA,EAAA,KAAA,QAKA,IAFA,IAAA,EAAA,KAAA,IAAA,GACA,EAAA,EACA,EAAA,IAAA,GAAA,MACA,GAAA,KAAA,IAAA,GAAA,EAGA,OAAA,GAGA,EAAA,UAAA,UAAA,SAAA,EAAA,GAEA,OADA,GAAA,EAAA,EAAA,EAAA,KAAA,QACA,KAAA,IAGA,EAAA,UAAA,aAAA,SAAA,EAAA,GAEA,OADA,GAAA,EAAA,EAAA,EAAA,KAAA,QACA,KAAA,GAAA,KAAA,EAAA,IAAA,GAGA,EAAA,UAAA,aAAA,SAAA,EAAA,GAEA,OADA,GAAA,EAAA,EAAA,EAAA,KAAA,QACA,KAAA,IAAA,EAAA,KAAA,EAAA,IAGA,EAAA,UAAA,aAAA,SAAA,EAAA,GAGA,OAFA,GAAA,EAAA,EAAA,EAAA,KAAA,SAEA,KAAA,GACA,KAAA,EAAA,IAAA,EACA,KAAA,EAAA,IAAA,IACA,SAAA,KAAA,EAAA,IAGA,EAAA,UAAA,aAAA,SAAA,EAAA,GAGA,OAFA,GAAA,EAAA,EAAA,EAAA,KAAA,QAEA,SAAA,KAAA,IACA,KAAA,EAAA,IAAA,GACA,KAAA,EAAA,IAAA,EACA,KAAA,EAAA,KAGA,EAAA,UAAA,UAAA,SAAA,EAAA,EAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,EAAA,EAAA,KAAA,QAKA,IAHA,IAAA,EAAA,KAAA,GACA,EAAA,EACA,EAAA,IACA,EAAA,IAAA,GAAA,MACA,GAAA,KAAA,EAAA,GAAA,EAMA,OAFA,IAFA,GAAA,OAEA,GAAA,KAAA,IAAA,EAAA,EAAA,IAEA,GAGA,EAAA,UAAA,UAAA,SAAA,EAAA,EAAA,GACA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,EAAA,EAAA,KAAA,QAKA,IAHA,IAAA,EAAA,EACA,EAAA,EACA,EAAA,KAAA,IAAA,GACA,EAAA,IAAA,GAAA,MACA,GAAA,KAAA,IAAA,GAAA,EAMA,OAFA,IAFA,GAAA,OAEA,GAAA,KAAA,IAAA,EAAA,EAAA,IAEA,GAGA,EAAA,UAAA,SAAA,SAAA,EAAA,GAEA,OADA,GAAA,EAAA,EAAA,EAAA,KAAA,QACA,IAAA,KAAA,IACA,GAAA,IAAA,KAAA,GAAA,GADA,KAAA,IAIA,EAAA,UAAA,YAAA,SAAA,EAAA,GACA,GAAA,EAAA,EAAA,EAAA,KAAA,QACA,IAAA,EAAA,KAAA,GAAA,KAAA,EAAA,IAAA,EACA,OAAA,MAAA,EAAA,WAAA,EAAA,GAGA,EAAA,UAAA,YAAA,SAAA,EAAA,GACA,GAAA,EAAA,EAAA,EAAA,KAAA,QACA,IAAA,EAAA,KAAA,EAAA,GAAA,KAAA,IAAA,EACA,OAAA,MAAA,EAAA,WAAA,EAAA,GAGA,EAAA,UAAA,YAAA,SAAA,EAAA,GAGA,OAFA,GAAA,EAAA,EAAA,EAAA,KAAA,QAEA,KAAA,GACA,KAAA,EAAA,IAAA,EACA,KAAA,EAAA,IAAA,GACA,KAAA,EAAA,IAAA,IAGA,EAAA,UAAA,YAAA,SAAA,EAAA,GAGA,OAFA,GAAA,EAAA,EAAA,EAAA,KAAA,QAEA,KAAA,IAAA,GACA,KAAA,EAAA,IAAA,GACA,KAAA,EAAA,IAAA,EACA,KAAA,EAAA,IAGA,EAAA,UAAA,YAAA,SAAA,EAAA,GAEA,OADA,GAAA,EAAA,EAAA,EAAA,KAAA,QACA,EAAA,KAAA,KAAA,GAAA,EAAA,GAAA,IAGA,EAAA,UAAA,YAAA,SAAA,EAAA,GAEA,OADA,GAAA,EAAA,EAAA,EAAA,KAAA,QACA,EAAA,KAAA,KAAA,GAAA,EAAA,GAAA,IAGA,EAAA,UAAA,aAAA,SAAA,EAAA,GAEA,OADA,GAAA,EAAA,EAAA,EAAA,KAAA,QACA,EAAA,KAAA,KAAA,GAAA,EAAA,GAAA,IAGA,EAAA,UAAA,aAAA,SAAA,EAAA,GAEA,OADA,GAAA,EAAA,EAAA,EAAA,KAAA,QACA,EAAA,KAAA,KAAA,GAAA,EAAA,GAAA,IASA,EAAA,UAAA,YAAA,SAAA,EAAA,EAAA,EAAA,IACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,IAEA,EAAA,KAAA,EAAA,EAAA,EADA,KAAA,IAAA,EAAA,EAAA,GAAA,EACA,GAGA,IAAA,EAAA,EACA,EAAA,EAEA,IADA,KAAA,GAAA,IAAA,IACA,EAAA,IAAA,GAAA,MACA,KAAA,EAAA,GAAA,EAAA,EAAA,IAGA,OAAA,EAAA,GAGA,EAAA,UAAA,YAAA,SAAA,EAAA,EAAA,EAAA,IACA,GAAA,EACA,GAAA,EACA,GAAA,EACA,IAEA,EAAA,KAAA,EAAA,EAAA,EADA,KAAA,IAAA,EAAA,EAAA,GAAA,EACA,GAGA,IAAA,EAAA,EAAA,EACA,EAAA,EAEA,IADA,KAAA,EAAA,GAAA,IAAA,IACA,GAAA,IAAA,GAAA,MACA,KAAA,EAAA,GAAA,EAAA,EAAA,IAGA,OAAA,EAAA,GAGA,EAAA,UAAA,WAAA,SAAA,EAAA,EAAA,GAMA,OALA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,IAAA,GACA,EAAA,sBAAA,EAAA,KAAA,MAAA,IACA,KAAA,GAAA,IAAA,EACA,EAAA,GAWA,EAAA,UAAA,cAAA,SAAA,EAAA,EAAA,GAUA,OATA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,MAAA,GACA,EAAA,qBACA,KAAA,GAAA,IAAA,EACA,KAAA,EAAA,GAAA,IAAA,GAEA,EAAA,KAAA,EAAA,GAAA,GAEA,EAAA,GAGA,EAAA,UAAA,cAAA,SAAA,EAAA,EAAA,GAUA,OATA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,MAAA,GACA,EAAA,qBACA,KAAA,GAAA,IAAA,EACA,KAAA,EAAA,GAAA,IAAA,GAEA,EAAA,KAAA,EAAA,GAAA,GAEA,EAAA,GAUA,EAAA,UAAA,cAAA,SAAA,EAAA,EAAA,GAYA,OAXA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,WAAA,GACA,EAAA,qBACA,KAAA,EAAA,GAAA,IAAA,GACA,KAAA,EAAA,GAAA,IAAA,GACA,KAAA,EAAA,GAAA,IAAA,EACA,KAAA,GAAA,IAAA,GAEA,EAAA,KAAA,EAAA,GAAA,GAEA,EAAA,GAGA,EAAA,UAAA,cAAA,SAAA,EAAA,EAAA,GAYA,OAXA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,WAAA,GACA,EAAA,qBACA,KAAA,GAAA,IAAA,GACA,KAAA,EAAA,GAAA,IAAA,GACA,KAAA,EAAA,GAAA,IAAA,EACA,KAAA,EAAA,GAAA,IAAA,GAEA,EAAA,KAAA,EAAA,GAAA,GAEA,EAAA,GAGA,EAAA,UAAA,WAAA,SAAA,EAAA,EAAA,EAAA,GAGA,GAFA,GAAA,EACA,GAAA,GACA,EAAA,CACA,IAAA,EAAA,KAAA,IAAA,EAAA,EAAA,EAAA,GAEA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAGA,IAAA,EAAA,EACA,EAAA,EACA,EAAA,EAEA,IADA,KAAA,GAAA,IAAA,IACA,EAAA,IAAA,GAAA,MACA,EAAA,GAAA,IAAA,GAAA,IAAA,KAAA,EAAA,EAAA,KACA,EAAA,GAEA,KAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,IAGA,OAAA,EAAA,GAGA,EAAA,UAAA,WAAA,SAAA,EAAA,EAAA,EAAA,GAGA,GAFA,GAAA,EACA,GAAA,GACA,EAAA,CACA,IAAA,EAAA,KAAA,IAAA,EAAA,EAAA,EAAA,GAEA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAGA,IAAA,EAAA,EAAA,EACA,EAAA,EACA,EAAA,EAEA,IADA,KAAA,EAAA,GAAA,IAAA,IACA,GAAA,IAAA,GAAA,MACA,EAAA,GAAA,IAAA,GAAA,IAAA,KAAA,EAAA,EAAA,KACA,EAAA,GAEA,KAAA,EAAA,IAAA,EAAA,GAAA,GAAA,EAAA,IAGA,OAAA,EAAA,GAGA,EAAA,UAAA,UAAA,SAAA,EAAA,EAAA,GAOA,OANA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,KAAA,KACA,EAAA,sBAAA,EAAA,KAAA,MAAA,IACA,EAAA,IAAA,EAAA,IAAA,EAAA,GACA,KAAA,GAAA,IAAA,EACA,EAAA,GAGA,EAAA,UAAA,aAAA,SAAA,EAAA,EAAA,GAUA,OATA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,OAAA,OACA,EAAA,qBACA,KAAA,GAAA,IAAA,EACA,KAAA,EAAA,GAAA,IAAA,GAEA,EAAA,KAAA,EAAA,GAAA,GAEA,EAAA,GAGA,EAAA,UAAA,aAAA,SAAA,EAAA,EAAA,GAUA,OATA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,OAAA,OACA,EAAA,qBACA,KAAA,GAAA,IAAA,EACA,KAAA,EAAA,GAAA,IAAA,GAEA,EAAA,KAAA,EAAA,GAAA,GAEA,EAAA,GAGA,EAAA,UAAA,aAAA,SAAA,EAAA,EAAA,GAYA,OAXA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,YAAA,YACA,EAAA,qBACA,KAAA,GAAA,IAAA,EACA,KAAA,EAAA,GAAA,IAAA,EACA,KAAA,EAAA,GAAA,IAAA,GACA,KAAA,EAAA,GAAA,IAAA,IAEA,EAAA,KAAA,EAAA,GAAA,GAEA,EAAA,GAGA,EAAA,UAAA,aAAA,SAAA,EAAA,EAAA,GAaA,OAZA,GAAA,EACA,GAAA,EACA,GAAA,EAAA,KAAA,EAAA,EAAA,EAAA,YAAA,YACA,EAAA,IAAA,EAAA,WAAA,EAAA,GACA,EAAA,qBACA,KAAA,GAAA,IAAA,GACA,KAAA,EAAA,GAAA,IAAA,GACA,KAAA,EAAA,GAAA,IAAA,EACA,KAAA,EAAA,GAAA,IAAA,GAEA,EAAA,KAAA,EAAA,GAAA,GAEA,EAAA,GAgBA,EAAA,UAAA,aAAA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAGA,EAAA,UAAA,aAAA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAWA,EAAA,UAAA,cAAA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAGA,EAAA,UAAA,cAAA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAIA,EAAA,UAAA,KAAA,SAAA,EAAA,EAAA,EAAA,GAQA,GAPA,IAAA,EAAA,GACA,GAAA,IAAA,IAAA,EAAA,KAAA,QACA,GAAA,EAAA,SAAA,EAAA,EAAA,QACA,IAAA,EAAA,GACA,EAAA,GAAA,EAAA,IAAA,EAAA,GAGA,IAAA,EAAA,OAAA,EACA,GAAA,IAAA,EAAA,QAAA,IAAA,KAAA,OAAA,OAAA,EAGA,GAAA,EAAA,EACA,MAAA,IAAA,WAAA,6BAEA,GAAA,EAAA,GAAA,GAAA,KAAA,OAAA,MAAA,IAAA,WAAA,6BACA,GAAA,EAAA,EAAA,MAAA,IAAA,WAAA,2BAGA,EAAA,KAAA,SAAA,EAAA,KAAA,QACA,EAAA,OAAA,EAAA,EAAA,IACA,EAAA,EAAA,OAAA,EAAA,GAGA,IACA,EADA,EAAA,EAAA,EAGA,GAAA,OAAA,GAAA,EAAA,GAAA,EAAA,EAEA,IAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EACA,EAAA,EAAA,GAAA,KAAA,EAAA,QAEA,GAAA,EAAA,MAAA,EAAA,oBAEA,IAAA,EAAA,EAAA,EAAA,IAAA,EACA,EAAA,EAAA,GAAA,KAAA,EAAA,QAGA,WAAA,UAAA,IAAA,KACA,EACA,KAAA,SAAA,EAAA,EAAA,GACA,GAIA,OAAA,GAOA,EAAA,UAAA,KAAA,SAAA,EAAA,EAAA,EAAA,GAEA,GAAA,iBAAA,EAAA,CASA,GARA,iBAAA,GACA,EAAA,EACA,EAAA,EACA,EAAA,KAAA,QACA,iBAAA,IACA,EAAA,EACA,EAAA,KAAA,QAEA,IAAA,EAAA,OAAA,CACA,IAAA,EAAA,EAAA,WAAA,GACA,EAAA,MACA,EAAA,GAGA,QAAA,IAAA,GAAA,iBAAA,EACA,MAAA,IAAA,UAAA,6BAEA,GAAA,iBAAA,IAAA,EAAA,WAAA,GACA,MAAA,IAAA,UAAA,qBAAA,OAEA,iBAAA,IACA,GAAA,KAIA,GAAA,EAAA,GAAA,KAAA,OAAA,GAAA,KAAA,OAAA,EACA,MAAA,IAAA,WAAA,sBAGA,GAAA,GAAA,EACA,OAAA,KAQA,IAAA,EACA,GANA,KAAA,EACA,OAAA,IAAA,EAAA,KAAA,OAAA,IAAA,EAEA,IAAA,EAAA,GAGA,iBAAA,EACA,IAAA,EAAA,EAAA,EAAA,IAAA,EACA,KAAA,GAAA,MAEA,CACA,IAAA,EAAA,EAAA,SAAA,GACA,EACA,EAAA,IAAA,EAAA,EAAA,GAAA,YACA,EAAA,EAAA,OACA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EACA,KAAA,EAAA,GAAA,EAAA,EAAA,GAIA,OAAA,MAMA,IAAA,EAAA,qBAEA,SAAA,EAAA,GAIA,IAFA,EAAA,EAAA,GAAA,QAAA,EAAA,KAEA,OAAA,EAAA,MAAA,GAEA,KAAA,EAAA,OAAA,GAAA,GACA,GAAA,IAEA,OAAA,EAGA,SAAA,EAAA,GACA,OAAA,EAAA,KAAA,EAAA,OACA,EAAA,QAAA,aAAA,IAGA,SAAA,EAAA,GACA,OAAA,EAAA,GAAA,IAAA,EAAA,SAAA,IACA,EAAA,SAAA,IAGA,SAAA,EAAA,EAAA,GAEA,IAAA,EADA,EAAA,GAAA,EAAA,EAMA,IAJA,IAAA,EAAA,EAAA,OACA,EAAA,KACA,EAAA,GAEA,EAAA,EAAA,EAAA,IAAA,EAAA,CAIA,IAHA,EAAA,EAAA,WAAA,IAGA,OAAA,EAAA,MAAA,CAEA,IAAA,EAAA,CAEA,GAAA,EAAA,MAAA,EAEA,GAAA,IAAA,GAAA,EAAA,KAAA,IAAA,IAAA,KACA,SACA,GAAA,EAAA,IAAA,EAAA,EAEA,GAAA,IAAA,GAAA,EAAA,KAAA,IAAA,IAAA,KACA,SAIA,EAAA,EAEA,SAIA,GAAA,EAAA,MAAA,EACA,GAAA,IAAA,GAAA,EAAA,KAAA,IAAA,IAAA,KACA,EAAA,EACA,SAIA,EAAA,OAAA,EAAA,OAAA,GAAA,EAAA,YACA,IAEA,GAAA,IAAA,GAAA,EAAA,KAAA,IAAA,IAAA,KAMA,GAHA,EAAA,KAGA,EAAA,IAAA,CACA,IAAA,GAAA,GAAA,EAAA,MACA,EAAA,KAAA,QACA,GAAA,EAAA,KAAA,CACA,IAAA,GAAA,GAAA,EAAA,MACA,EAAA,KACA,GAAA,EAAA,IACA,GAAA,EAAA,UAEA,GAAA,EAAA,MAAA,CACA,IAAA,GAAA,GAAA,EAAA,MACA,EAAA,KACA,GAAA,GAAA,IACA,GAAA,EAAA,GAAA,IACA,GAAA,EAAA,SAEA,CAAA,KAAA,EAAA,SASA,MAAA,IAAA,MAAA,sBARA,IAAA,GAAA,GAAA,EAAA,MACA,EAAA,KACA,GAAA,GAAA,IACA,GAAA,GAAA,GAAA,IACA,GAAA,EAAA,GAAA,IACA,GAAA,EAAA,MAOA,OAAA,EAGA,SAAA,EAAA,GAEA,IADA,IAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,SAAA,EAEA,EAAA,KAAA,IAAA,EAAA,WAAA,IAEA,OAAA,EAGA,SAAA,EAAA,EAAA,GAGA,IAFA,IAAA,EAAA,EAAA,EACA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,WACA,GAAA,GAAA,KADA,EAIA,GADA,EAAA,EAAA,WAAA,KACA,EACA,EAAA,EAAA,IACA,EAAA,KAAA,GACA,EAAA,KAAA,GAGA,OAAA,EAGA,SAAA,EAAA,GACA,OAAA,EAAA,YAAA,EAAA,IAGA,SAAA,EAAA,EAAA,EAAA,EAAA,GACA,IAAA,IAAA,EAAA,EAAA,EAAA,KACA,EAAA,GAAA,EAAA,QAAA,GAAA,EAAA,UADA,EAEA,EAAA,EAAA,GAAA,EAAA,GAEA,OAAA,EAGA,SAAA,EAAA,GACA,OAAA,GAAA;;;;AC1lDA,IAAA,EAAA,UAAA,GAAA,EAAA,QAAA,UAAA,OAjKI1E,EAAmBnC,QAAQ,mBAAmBmC,iBAC9CC,EAAkBpC,QAAQ,mBAAmBoC,gBAC7CE,EAAStC,QAAQ,mBAAmBsC,OACpCD,EAASrC,QAAQ,mBAAmBqC,OAEpCyE,EAAYC,EAAOD,WACPC,EAAOC,cACPD,EAAOE,iBACPF,EAAOG,YAEvB,SAASC,EAAiBC,EAAIC,GACvBD,KAAAA,GAAKA,EACLC,KAAAA,KAAOA,EAmGd,SAASC,EAAU7H,GACZA,KAAAA,KAAOA,GAAQ0C,EACfiF,KAAAA,GAAK,KAlGZD,EAAiB5I,UAAUgJ,gBAAkB,WACxC,GAAA,KAAKC,YACC,OAAA,KAAKA,YAGVC,IAAAA,EAAc,KAAKL,GAAGK,YAAYrF,EAAiB,KAAKiF,MAErD,OADFG,KAAAA,YAAcC,EAAYD,YAAYpF,GACpC,KAAKoF,aAGdL,EAAiB5I,UAAUmJ,MAAQ,SAASC,GACtC,IACEH,IACAI,EADc,KAAKL,kBACGG,QAC1BE,EAAQC,UAAY,WAClBF,KAEFC,EAAQE,QAAU,SAASC,GACzBA,EAAMC,iBACNL,EAASI,EAAME,QAEjB,MAAMC,GACNP,EAASO,KAIbf,EAAiB5I,UAAU4J,KAAO,SAASC,EAAKT,GAC1C,IACEH,IACAI,EADc,KAAKL,kBACGc,IAAID,GAC9BR,EAAQC,UAAY,SAAmBE,GACjCO,IAAAA,EAASP,EAAMQ,OAAOD,OAC1BX,EAAS,KAAMW,IAEjBV,EAAQE,QAAU,SAASC,GACzBA,EAAMC,iBACNL,EAASI,EAAME,QAEjB,MAAMC,GACNP,EAASO,KAGbf,EAAiB5I,UAAUiK,UAAY,SAASJ,EAAKT,GAC9CQ,KAAAA,KAAKC,EAAKT,IAEjBR,EAAiB5I,UAAUkK,UAAY,SAASL,EAAKT,GAC9CQ,KAAAA,KAAKC,EAAK,SAASF,EAAKQ,GACxBR,GAAAA,EACMP,OAAAA,EAASO,GAElBP,EAAS,KAAMgB,EAAOC,KAAKF,OAI/BvB,EAAiB5I,UAAUsK,KAAO,SAAST,EAAKU,EAAOnB,GACjD,IACEH,IACAI,EADc,KAAKL,kBACGwB,IAAID,EAAOV,GACrCR,EAAQC,UAAY,SAAmBE,GACjCO,IAAAA,EAASP,EAAMQ,OAAOD,OAC1BX,EAAS,KAAMW,IAEjBV,EAAQE,QAAU,SAASC,GACzBA,EAAMC,iBACNL,EAASI,EAAME,QAEjB,MAAMC,GACNP,EAASO,KAGbf,EAAiB5I,UAAUyK,UAAY,SAASZ,EAAKU,EAAOnB,GACrDkB,KAAAA,KAAKT,EAAKU,EAAOnB,IAExBR,EAAiB5I,UAAU0K,UAAY,SAASb,EAAKc,EAAmBvB,GAClEwB,IAAAA,EAAMD,EAAkBE,OACvBP,KAAAA,KAAKT,EAAKe,EAAKxB,IAGtBR,EAAiB5I,UAAU8K,OAAS,SAASjB,EAAKT,GAC5C,IACEH,IACAI,EADc,KAAKL,kBACG8B,OAAOjB,GACjCR,EAAQC,UAAY,SAAmBE,GACjCO,IAAAA,EAASP,EAAMQ,OAAOD,OAC1BX,EAAS,KAAMW,IAEjBV,EAAQE,QAAU,SAASC,GACzBA,EAAMC,iBACNL,EAASI,EAAME,QAEjB,MAAMC,GACNP,EAASO,KASbZ,EAAUgC,YAAc,WACf,QAAExC,GAGXQ,EAAU/I,UAAUgL,KAAO,SAAS5B,GAC9B6B,IAAAA,EAAO,KAGRA,GAAAA,EAAKpC,GACCO,OAAAA,IAGL,IAEE8B,IAAAA,EAAc3C,EAAUyC,KAAKC,EAAK/J,MAGtCgK,EAAYC,gBAAkB,SAAyB3B,GACjDX,IAAAA,EAAKW,EAAMQ,OAAOD,OAEnBlB,EAAGuC,iBAAiBC,SAASxH,IAC9BgF,EAAGyC,kBAAkBzH,GAEvBgF,EAAG0C,kBAAkB1H,IAGvBqH,EAAY5B,UAAY,SAAmBE,GACzCyB,EAAKpC,GAAKW,EAAMQ,OAAOD,OACvBX,KAEF8B,EAAY3B,QAAU,SAAiBC,GACrCA,EAAMC,iBACNL,EAASI,EAAME,QAEjB,MAAMC,GACNP,EAASO,KAIbZ,EAAU/I,UAAUwL,mBAAqB,WAChC,OAAA,IAAI5C,EAAiB,KAAKC,GAAI/E,IAEvCiF,EAAU/I,UAAUyL,oBAAsB,WACjC,OAAA,IAAI7C,EAAiB,KAAKC,GAAI9E,IAGvChG,OAAOC,QAAU+K;;ACjKjB,IAAI2C,EAAS,GACb,CAQE,6BAMA,8BACA,mCAQA,6BASA,6BACA,6CAMA,sCAaA,gCAGA,mCACA,+CAEA,mCAEA,mBASA,+BACA,oFACA,yCAEAC,QAAQ,SAASpN,GAEbqN,IAAAA,IADJrN,EAAIA,EAAEsN,MAAM,MACG,GACXC,EAAUvN,EAAE,GACZwN,EAAiBxN,EAAE,GAEdyN,SAAAA,EAAWC,EAAKnK,GACvB5D,MAAMM,KAAK,MAEN0C,KAAAA,KAAO4K,EACPI,KAAAA,KAAOJ,EACPF,KAAAA,MAAQA,EACRO,KAAAA,QAAUF,GAAOF,EACnBjK,IACIA,KAAAA,KAAOA,GAETsK,KAAAA,MAAS,IAAIlO,MAAM,KAAKiO,SAAUC,MAEzCJ,EAAWhM,UAAY2B,OAAOC,OAAO1D,MAAM8B,WAC3CgM,EAAWhM,UAAUqM,YAAcL,EACnCA,EAAWhM,UAAU6C,SAAW,WAC1ByJ,IAAAA,EAAW,KAAKxK,KAAQ,MAAS,KAAKA,KAAO,IAAQ,GAClD,OAAA,KAAKZ,KAAO,KAAO,KAAKiL,QAAUG,GAI3CZ,EAAOI,GAAWJ,EAAOE,GAASI,IAGpCjO,OAAOC,QAAU0N;;CChGjB,WACE,aAMK,IAJDa,IAAAA,EAAQ,mEAGRC,EAAS,IAAIC,WAAW,KACnB3M,EAAI,EAAGA,EAAIyM,EAAMtN,OAAQa,IAChC0M,EAAOD,EAAMG,WAAW5M,IAAMA,EAGhC9B,QAAQ2O,OAAS,SAASC,GACpBC,IACJ/M,EADI+M,EAAQ,IAAIJ,WAAWG,GACxBvN,EAAMwN,EAAM5N,OAAQ6N,EAAS,GAE3BhN,IAAAA,EAAI,EAAGA,EAAIT,EAAKS,GAAG,EACtBgN,GAAUP,EAAMM,EAAM/M,IAAM,GAC5BgN,GAAUP,GAAmB,EAAXM,EAAM/M,KAAW,EAAM+M,EAAM/M,EAAI,IAAM,GACzDgN,GAAUP,GAAuB,GAAfM,EAAM/M,EAAI,KAAY,EAAM+M,EAAM/M,EAAI,IAAM,GAC9DgN,GAAUP,EAAqB,GAAfM,EAAM/M,EAAI,IASrBgN,OANFzN,EAAM,GAAO,EAChByN,EAASA,EAAOC,UAAU,EAAGD,EAAO7N,OAAS,GAAK,IACzCI,EAAM,GAAM,IACrByN,EAASA,EAAOC,UAAU,EAAGD,EAAO7N,OAAS,GAAK,MAG7C6N,GAGT9O,QAAQgP,OAAU,SAASF,GACrBG,IACiBnN,EACrBoN,EAAUC,EAAUC,EAAUC,EAF1BJ,EAA+B,IAAhBH,EAAO7N,OAC1BI,EAAMyN,EAAO7N,OAAWqO,EAAI,EAGM,MAA9BR,EAAOA,EAAO7N,OAAS,KACzBgO,IACkC,MAA9BH,EAAOA,EAAO7N,OAAS,IACzBgO,KAIAL,IAAAA,EAAc,IAAIW,YAAYN,GAClCJ,EAAQ,IAAIJ,WAAWG,GAElB9M,IAAAA,EAAI,EAAGA,EAAIT,EAAKS,GAAG,EACtBoN,EAAWV,EAAOM,EAAOJ,WAAW5M,IACpCqN,EAAWX,EAAOM,EAAOJ,WAAW5M,EAAE,IACtCsN,EAAWZ,EAAOM,EAAOJ,WAAW5M,EAAE,IACtCuN,EAAWb,EAAOM,EAAOJ,WAAW5M,EAAE,IAEtC+M,EAAMS,KAAQJ,GAAY,EAAMC,GAAY,EAC5CN,EAAMS,MAAoB,GAAXH,IAAkB,EAAMC,GAAY,EACnDP,EAAMS,MAAoB,EAAXF,IAAiB,EAAiB,GAAXC,EAGjCT,OAAAA,GAzDX;;;;ACkKA,IAAA,EAAA,QAAA,UAAA,OAAA,EAAA,UAAA,GAzKIhJ,EAAmBnC,QAAQ,mBAAmBmC,iBAC9CC,EAAkBpC,QAAQ,mBAAmBoC,gBAC7CG,EAAevC,QAAQ,mBAAmBuC,aAC1CC,EAAYxC,QAAQ,mBAAmBwC,UACvCC,EAAYzC,QAAQ,mBAAmByC,UACvCsJ,EAAS/L,QAAQ,gBACjBgM,EAAoBhM,QAAQ,sBAEhC,SAASiM,EAAc7E,EAAI8E,GACrB1C,IAAAA,EAAO,KACN2C,KAAAA,eAAiB,SAASxE,GAC1B6B,EAAK/B,YACNE,EAAS6B,EAAK/B,aAIhBL,EAAG8E,EAAa,kBAAoB,eAAe,SAASzE,GAC1D+B,EAAK/B,YAAcA,EACnBE,EAASF,MAkBf,SAASU,EAAKgE,EAAgB/D,EAAKT,GACxByE,SAAAA,EAAU3E,EAAaa,GAE1BQ,IAAAA,EAA+B,IAAvBR,EAAO+D,KAAK7O,OAAe,KAAO8K,EAAO+D,KAAKC,KAAK,GAAGC,KAClE5E,EAAS,KAAMmB,GAER0D,SAAAA,EAAQ/E,EAAaQ,GAC5BN,EAASM,GAEXkE,EAAe,SAAS1E,GACtBA,EAAYgF,WAAW,oBAAsBrK,EAAkB,yBAC7D,CAACgG,GAAMgE,EAAWI,KAoCxB,SAAS3D,EAAKsD,EAAgB/D,EAAKU,EAAOnB,GAC/ByE,SAAAA,IACPzE,EAAS,MAEF6E,SAAAA,EAAQ/E,EAAaQ,GAC5BN,EAASM,GAEXkE,EAAe,SAAS1E,GACtBA,EAAYgF,WAAW,0BAA4BrK,EAAkB,6BACnE,CAACgG,EAAKU,GAAQsD,EAAWI,KA0B/B,SAASE,EAAOjN,GACTA,KAAAA,KAAOA,GAAQ0C,EACfiF,KAAAA,GAAK,KAjGZ6E,EAAc1N,UAAUmJ,MAAQ,SAASC,GAC9B6E,SAAAA,EAAQ/E,EAAaQ,GAC5BN,EAASM,GAEFmE,SAAAA,IACPzE,EAAS,MAENwE,KAAAA,eAAe,SAAS1E,GAC3BA,EAAYgF,WAAW,eAAiBrK,EAAkB,IACxD,GAAIgK,EAAWI,MAkBrBP,EAAc1N,UAAUiK,UAAY,SAASJ,EAAKT,GAChDQ,EAAK,KAAKgE,eAAgB/D,EAAK,SAASF,EAAKI,GACxCJ,GAAAA,EACMP,OAAAA,EAASO,GAGd,IACCI,IACDA,EAASqE,KAAKC,MAAMtE,IAEtB,MAAMxL,GACC6K,OAAAA,EAAS7K,GAGlB6K,EAAS,KAAMW,MAGnB2D,EAAc1N,UAAUkK,UAAY,SAASL,EAAKT,GAChDQ,EAAK,KAAKgE,eAAgB/D,EAAK,SAASF,EAAKI,GACxCJ,GAAAA,EACMP,OAAAA,EAASO,GAIfI,GAAAA,GAAqB,KAAXA,EAAe,CACtBI,IAAAA,EAAcsD,EAAkBT,OAAOjD,GAC3CA,EAASK,EAAOC,KAAKF,GAGvBf,EAAS,KAAMW,MAgBnB2D,EAAc1N,UAAUyK,UAAY,SAASZ,EAAKU,EAAOnB,GACnDkF,IAAAA,EAAOF,KAAKG,UAAUhE,GAC1BD,EAAK,KAAKsD,eAAgB/D,EAAKyE,EAAMlF,IAEvCsE,EAAc1N,UAAU0K,UAAY,SAASb,EAAKc,EAAmBvB,GAC/D0D,IAAAA,EAASW,EAAkBd,OAAOhC,EAAkBE,QACxDP,EAAK,KAAKsD,eAAgB/D,EAAKiD,EAAQ1D,IAGzCsE,EAAc1N,UAAU8K,OAAS,SAASjB,EAAKT,GACpCyE,SAAAA,IACPzE,EAAS,MAEF6E,SAAAA,EAAQ/E,EAAaQ,GAC5BN,EAASM,GAENkE,KAAAA,eAAe,SAAS1E,GAC3BA,EAAYgF,WAAW,eAAiBrK,EAAkB,iBACxD,CAACgG,GAAMgE,EAAWI,MASxBE,EAAOpD,YAAc,WACZ,QAAEvC,EAAOgG,cAGlBL,EAAOnO,UAAUgL,KAAO,SAAS5B,GAC3B6B,IAAAA,EAAO,KAGRA,GAAAA,EAAKpC,GACCO,OAAAA,IAGLP,IAAAA,EAAKL,EAAOgG,aAAavD,EAAK/J,KAAM8C,EAAcE,EAAWD,GAMxDgK,SAAAA,EAAQ/E,EAAaQ,GACT,IAAfA,EAAMwC,MACR9C,EAAS,IAAIoE,EAAOiB,OAAO,2EAE7BrF,EAASM,GAEFmE,SAAAA,IACP5C,EAAKpC,GAAKA,EACVO,IAbEP,EAiBJA,EAAGK,YAAY,SAASA,GAMtBA,EAAYgF,WAAW,8BAAgCrK,EAAkB,2BACvE,GANO6K,SAAYxF,GACnBA,EAAYgF,WAAW,kCAAoCrK,EAAkB,UAC7CA,EAAkB,SAClD,GAAIgK,EAAWI,IAGEA,KAvBnB7E,EAAS,sCA0Bb+E,EAAOnO,UAAUwL,mBAAqB,WAC7B,OAAA,IAAIkC,EAAc,KAAK7E,IAAI,IAEpCsF,EAAOnO,UAAUyL,oBAAsB,WAC9B,OAAA,IAAIiC,EAAc,KAAK7E,IAAI,IAGpC9K,OAAOC,QAAUmQ;;;;AClKjB,IAAA,EAAA,EAAA,QAAA,YAAC,WAEOQ,IAAAA,EAAQ,QAKW,IAAZ7Q,GAA6BA,EAAQ4B,UAgB5CiP,EAAMjP,SAAW5B,EAAQ4B,SACG,oBAAjBkP,aACPD,EAAMC,aAAe,SAAUC,GAE7BD,aAAaC,IAIfF,EAAMC,aAAeD,EAAMjP,UAvBH,mBAAjBkP,cACPD,EAAMjP,SAAW,SAAUmP,GAEvBD,aAAaC,IAEjBF,EAAMC,aAAeD,EAAMjP,WAG3BiP,EAAMjP,SAAW,SAAUmP,GACvBvQ,WAAWuQ,EAAI,IAEnBF,EAAMC,aAAeD,EAAMjP,UAgBnCiP,EAAMG,WAAa,SAAUC,EAAKC,EAAU5F,GAEpC,GADJA,EAAWA,GAAY,cAClB2F,EAAI9P,OACEmK,OAAAA,IAEP6F,IAAAA,EAAY,GACF,SAAVC,IACAF,EAASD,EAAIE,GAAY,SAAUtF,GAC3BA,GACAP,EAASO,GACTP,EAAW,eAGX6F,GAAa,IACIF,EAAI9P,OACjBmK,IAGA8F,MAKhBA,IAEJP,EAAMQ,cAAgBR,EAAMG,gBAGN,IAAXM,GAA0BA,EAAOC,IACxCD,EAAO,GAAI,WACAT,OAAAA,IAIY,oBAAX5Q,QAA0BA,OAAOC,QAC7CD,OAAOC,QAAU2Q,EAIjBW,KAAKX,MAAQA,EA1EpB;;ACPD,IAAI/K,EAAmBnC,QAAQ,mBAAmBmC,iBAG9C2L,EAAgB9N,QAAQ,sBAAsBmN,aAK9CY,EAAY,WACVC,IAAAA,EAAO,GACJ,OAAA,SAAqBvO,GAInBuO,OAHHA,EAAKC,eAAexO,KACtBuO,EAAKvO,GAAQ,IAERuO,EAAKvO,IANA,GAUhB,SAASyO,EAAc9G,EAAI+G,GACpBA,KAAAA,SAAWA,EACX3G,KAAAA,YAAcJ,EAmDrB,SAASgH,EAAO3O,GACTA,KAAAA,KAAOA,GAAQ0C,EAjDtB+L,EAAc3P,UAAUmJ,MAAQ,SAASC,GACpC,GAAA,KAAKwG,SACNL,EAAc,WACZnG,EAAS,qEAFV,CAMCH,IAAAA,EAAc,KAAKA,YACvBtH,OAAOmO,KAAK7G,GAAa0C,QAAQ,SAAS9B,UACjCZ,EAAYY,KAErB0F,EAAcnG,KAIhBuG,EAAc3P,UAAUiK,UACxB0F,EAAc3P,UAAUkK,UACxB,SAASL,EAAKT,GACR6B,IAAAA,EAAO,KACXsE,EAAc,WACZnG,EAAS,KAAM6B,EAAKhC,YAAYY,OAGpC8F,EAAc3P,UAAUyK,UACxBkF,EAAc3P,UAAU0K,UACxB,SAASb,EAAKU,EAAOnB,GAChB,KAAKwG,SACNL,EAAc,WACZnG,EAAS,kEAIRH,KAAAA,YAAYY,GAAOU,EACxBgF,EAAcnG,KAGhBuG,EAAc3P,UAAU8K,OAAS,SAASjB,EAAKT,GAC1C,KAAKwG,SACNL,EAAc,WACZnG,EAAS,yEAIN,KAAKH,YAAYY,GACxB0F,EAAcnG,KAOhByG,EAAO9E,YAAc,WACZ,OAAA,GAGT8E,EAAO7P,UAAUgL,KAAO,SAAS5B,GAC1BP,KAAAA,GAAK2G,EAAS,KAAKtO,MACxBqO,EAAcnG,IAEhByG,EAAO7P,UAAUwL,mBAAqB,WAC7B,OAAA,IAAImE,EAAc,KAAK9G,IAAI,IAEpCgH,EAAO7P,UAAUyL,oBAAsB,WAC9B,OAAA,IAAIkE,EAAc,KAAK9G,IAAI,IAGpC9K,OAAOC,QAAU6R;;ACzFjB,IAAI9G,EAAYtH,QAAQ,kBACpB0M,EAAS1M,QAAQ,eACjBoO,EAASpO,QAAQ,eAErB1D,OAAOC,QAAU,CACf+K,UAAWA,EACXoF,OAAQA,EACR0B,OAAQA,EAORE,QAAShH,EAGTiH,SAAW,WACNjH,GAAAA,EAAUgC,cACJhC,OAAAA,EAGNoF,GAAAA,EAAOpD,cACDoD,OAAAA,EAGA8B,SAAAA,IACD,KAAA,kEAKDA,OAHPA,EAAalF,YAAc,WAClB,OAAA,GAEFkF,EAfE;;ACjBb,IAAIC,EAAWzO,QAAQ,mBAAmBmE,YAE1C7H,OAAOC,QAAU,SAAqBoC,IACpCA,EAAMA,GAAO,IACTyF,IAAMzF,EAAIyF,KAAOqK,EAASrK,IAC9BzF,EAAI0F,KAAO1F,EAAI0F,MAAQoK,EAASpK,KAE3BgE,KAAAA,IAAM,SAAS5I,GACXd,OAAAA,EAAIc,IAGRiP,KAAAA,IAAM,SAASjP,EAAMqJ,GACxBnK,EAAIc,GAAQqJ;;ACZhB,OAAA,QAAA,SAAA,EAAA,GAEA,IADA,IAAA,EAAA,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CACA,IAAA,EAAA,EAAA,EAAA,GAAA,GACA,EAAA,GAAA,EAAA,KAAA,MAAA,EAAA,GACA,EAAA,KAAA,GAEA,OAAA,GAGA,IAAA,EAAA,MAAA,SAAA,SAAA,GACA,MAAA,mBAAA,OAAA,UAAA,SAAA,KAAA;;ACXA,aAEA,SAAA,EAAA,EAAA,EAAA,GACA,aAAA,SAAA,EAAA,EAAA,EAAA,IACA,aAAA,SAAA,EAAA,EAAA,EAAA,IAEA,IAAA,EAAA,EAAA,EAAA,EAAA,GAEA,OAAA,GAAA,CACA,MAAA,EAAA,GACA,IAAA,EAAA,GACA,IAAA,EAAA,MAAA,EAAA,EAAA,IACA,KAAA,EAAA,MAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IACA,KAAA,EAAA,MAAA,EAAA,GAAA,EAAA,SAIA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,MAAA,GACA,OAAA,EAAA,EAAA,GAAA,KAIA,SAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,EAAA,EAAA,EACA,EAAA,EAAA,QAAA,GACA,EAAA,EAAA,QAAA,EAAA,EAAA,GACA,EAAA,EAEA,GAAA,GAAA,GAAA,EAAA,EAAA,CAIA,IAHA,EAAA,GACA,EAAA,EAAA,OAEA,GAAA,IAAA,GACA,GAAA,GACA,EAAA,KAAA,GACA,EAAA,EAAA,QAAA,EAAA,EAAA,IACA,GAAA,EAAA,OACA,EAAA,CAAA,EAAA,MAAA,KAEA,EAAA,EAAA,OACA,IACA,EAAA,EACA,EAAA,GAGA,EAAA,EAAA,QAAA,EAAA,EAAA,IAGA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAGA,EAAA,SACA,EAAA,CAAA,EAAA,IAIA,OAAA,EAxDA,OAAA,QAAA,EAqBA,EAAA,MAAA;;ACtBA,IAAA,EAAA,QAAA,cACA,EAAA,QAAA,kBAEA,OAAA,QAAA,EAEA,IAAA,EAAA,UAAA,KAAA,SAAA,KACA,EAAA,SAAA,KAAA,SAAA,KACA,EAAA,UAAA,KAAA,SAAA,KACA,EAAA,UAAA,KAAA,SAAA,KACA,EAAA,WAAA,KAAA,SAAA,KAEA,SAAA,EAAA,GACA,OAAA,SAAA,EAAA,KAAA,EACA,SAAA,EAAA,IACA,EAAA,WAAA,GAGA,SAAA,EAAA,GACA,OAAA,EAAA,MAAA,QAAA,KAAA,GACA,MAAA,OAAA,KAAA,GACA,MAAA,OAAA,KAAA,GACA,MAAA,OAAA,KAAA,GACA,MAAA,OAAA,KAAA,GAGA,SAAA,EAAA,GACA,OAAA,EAAA,MAAA,GAAA,KAAA,MACA,MAAA,GAAA,KAAA,KACA,MAAA,GAAA,KAAA,KACA,MAAA,GAAA,KAAA,KACA,MAAA,GAAA,KAAA,KAOA,SAAA,EAAA,GACA,IAAA,EACA,MAAA,CAAA,IAEA,IAAA,EAAA,GACA,EAAA,EAAA,IAAA,IAAA,GAEA,IAAA,EACA,OAAA,EAAA,MAAA,KAEA,IAAA,EAAA,EAAA,IACA,EAAA,EAAA,KACA,EAAA,EAAA,KACA,EAAA,EAAA,MAAA,KAEA,EAAA,EAAA,OAAA,IAAA,IAAA,EAAA,IACA,IAAA,EAAA,EAAA,GAQA,OAPA,EAAA,SACA,EAAA,EAAA,OAAA,IAAA,EAAA,QACA,EAAA,KAAA,MAAA,EAAA,IAGA,EAAA,KAAA,MAAA,EAAA,GAEA,EAGA,SAAA,EAAA,GACA,OAAA,GASA,OAAA,EAAA,OAAA,EAAA,KACA,EAAA,SAAA,EAAA,OAAA,IAGA,EAAA,EAAA,IAAA,GAAA,IAAA,IAZA,GAeA,SAAA,EAAA,GACA,OAAA,EAGA,SAAA,EAAA,GACA,MAAA,IAAA,EAAA,IAEA,SAAA,EAAA,GACA,MAAA,SAAA,KAAA,GAGA,SAAA,EAAA,EAAA,GACA,OAAA,GAAA,EAEA,SAAA,EAAA,EAAA,GACA,OAAA,GAAA,EAGA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,GAEA,EAAA,EAAA,IAAA,IAAA,GACA,IAAA,GAAA,MAAA,KAAA,EAAA,KAAA,MAAA,CAAA,GAEA,IAaA,EAbA,EAAA,iCAAA,KAAA,EAAA,MACA,EAAA,uCAAA,KAAA,EAAA,MACA,EAAA,GAAA,EACA,EAAA,EAAA,KAAA,QAAA,MAAA,EACA,IAAA,IAAA,EAEA,OAAA,EAAA,KAAA,MAAA,SAEA,EADA,EAAA,EAAA,IAAA,IAAA,EAAA,KAAA,EAAA,EAAA,MAGA,CAAA,GAIA,GAAA,EACA,EAAA,EAAA,KAAA,MAAA,aAGA,GAAA,KADA,EAAA,EAAA,EAAA,OACA,QAGA,KADA,EAAA,EAAA,EAAA,IAAA,GAAA,IAAA,IACA,OAIA,OAHA,EAAA,EAAA,KAAA,OACA,EAAA,EAAA,MAAA,GACA,CAAA,KACA,IAAA,SAAA,GACA,OAAA,EAAA,IAAA,EAAA,GAAA,IAUA,IAKA,EALA,EAAA,EAAA,IACA,EAAA,EAAA,KAAA,OACA,EAAA,EAAA,MAAA,GACA,CAAA,IAIA,GAAA,EAAA,CACA,IAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,EAAA,IACA,EAAA,KAAA,IAAA,EAAA,GAAA,OAAA,EAAA,GAAA,QACA,EAAA,GAAA,EAAA,OACA,KAAA,IAAA,EAAA,EAAA,KACA,EACA,EAAA,EACA,EAAA,IAEA,IAAA,EACA,EAAA,GAEA,IAAA,EAAA,EAAA,KAAA,GAEA,EAAA,GAEA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,CACA,IAAA,EACA,GAAA,EAEA,QADA,EAAA,OAAA,aAAA,MAEA,EAAA,SAGA,GADA,EAAA,OAAA,GACA,EAAA,CACA,IAAA,EAAA,EAAA,EAAA,OACA,GAAA,EAAA,EAAA,CACA,IAAA,EAAA,IAAA,MAAA,EAAA,GAAA,KAAA,KAEA,EADA,EAAA,EACA,IAAA,EAAA,EAAA,MAAA,GAEA,EAAA,GAIA,EAAA,KAAA,SAGA,EAAA,EAAA,EAAA,SAAA,GAAA,OAAA,EAAA,GAAA,KAGA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IACA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CACA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,KACA,GAAA,GAAA,IACA,EAAA,KAAA,GAIA,OAAA;;ACtMA,OAAA,QAAA,EACA,EAAA,UAAA,EAEA,IAAA,EAAA,CAAA,IAAA,KACA,IACA,EAAA,QAAA,QACA,MAAA,IAEA,IAAA,EAAA,EAAA,SAAA,EAAA,SAAA,GACA,EAAA,QAAA,mBAEA,EAAA,CACA,IAAA,CAAA,KAAA,YAAA,MAAA,aACA,IAAA,CAAA,KAAA,MAAA,MAAA,MACA,IAAA,CAAA,KAAA,MAAA,MAAA,MACA,IAAA,CAAA,KAAA,MAAA,MAAA,MACA,IAAA,CAAA,KAAA,MAAA,MAAA,MAKA,EAAA,OAGA,EAAA,EAAA,KAKA,EAAA,0CAIA,EAAA,0BAGA,EAAA,EAAA,mBAGA,SAAA,EAAA,GACA,OAAA,EAAA,MAAA,IAAA,OAAA,SAAA,EAAA,GAEA,OADA,EAAA,IAAA,EACA,GACA,IAIA,IAAA,EAAA,MAGA,SAAA,EAAA,EAAA,GAEA,OADA,EAAA,GAAA,GACA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,EAAA,EAAA,IAIA,SAAA,EAAA,EAAA,GACA,EAAA,GAAA,GACA,EAAA,GAAA,GACA,IAAA,EAAA,GAOA,OANA,OAAA,KAAA,GAAA,QAAA,SAAA,GACA,EAAA,GAAA,EAAA,KAEA,OAAA,KAAA,GAAA,QAAA,SAAA,GACA,EAAA,GAAA,EAAA,KAEA,EAwBA,SAAA,EAAA,EAAA,EAAA,GACA,GAAA,iBAAA,EACA,MAAA,IAAA,UAAA,gCAMA,OAHA,IAAA,EAAA,OAGA,EAAA,WAAA,MAAA,EAAA,OAAA,MAKA,KAAA,EAAA,OAAA,KAAA,EAEA,IAAA,EAAA,EAAA,GAAA,MAAA,IAGA,SAAA,EAAA,EAAA,GACA,KAAA,gBAAA,GACA,OAAA,IAAA,EAAA,EAAA,GAGA,GAAA,iBAAA,EACA,MAAA,IAAA,UAAA,gCAGA,IAAA,EAAA,IACA,EAAA,EAAA,OAGA,MAAA,EAAA,MACA,EAAA,EAAA,MAAA,EAAA,KAAA,KAAA,MAGA,KAAA,QAAA,EACA,KAAA,IAAA,GACA,KAAA,QAAA,EACA,KAAA,OAAA,KACA,KAAA,QAAA,EACA,KAAA,SAAA,EACA,KAAA,OAAA,EAGA,KAAA,OAMA,SAAA,IAEA,IAAA,KAAA,MAAA,CAEA,IAAA,EAAA,KAAA,QACA,EAAA,KAAA,QAGA,GAAA,EAAA,WAAA,MAAA,EAAA,OAAA,GAIA,GAAA,EAAA,CAMA,KAAA,cAGA,IAAA,EAAA,KAAA,QAAA,KAAA,cAEA,EAAA,QAAA,KAAA,MAAA,QAAA,OAEA,KAAA,MAAA,KAAA,QAAA,GAOA,EAAA,KAAA,UAAA,EAAA,IAAA,SAAA,GACA,OAAA,EAAA,MAAA,KAGA,KAAA,MAAA,KAAA,QAAA,GAGA,EAAA,EAAA,IAAA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,IAAA,KAAA,MAAA,OACA,MAEA,KAAA,MAAA,KAAA,QAAA,GAGA,EAAA,EAAA,OAAA,SAAA,GACA,OAAA,IAAA,EAAA,SAAA,KAGA,KAAA,MAAA,KAAA,QAAA,GAEA,KAAA,IAAA,OAvCA,KAAA,OAAA,OAJA,KAAA,SAAA,GA+CA,SAAA,IACA,IAAA,EAAA,KAAA,QACA,GAAA,EAEA,EAAA,EAEA,IAHA,KAAA,QAGA,SAAA,CAEA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OACA,EAAA,GAAA,MAAA,EAAA,OAAA,GACA,IACA,GAAA,EACA,IAGA,IAAA,KAAA,QAAA,EAAA,OAAA,IACA,KAAA,OAAA,GAmBA,SAAA,EAAA,EAAA,GAYA,GAXA,IAEA,EADA,gBAAA,EACA,KAAA,QAEA,SAOA,KAHA,OAAA,IAAA,EACA,KAAA,QAAA,GAGA,MAAA,IAAA,UAAA,qBAGA,OAAA,EAAA,UACA,EAAA,MAAA,UAEA,CAAA,GAGA,EAAA,GA7MA,EAAA,OAAA,EAqBA,EAAA,SAAA,SAAA,GACA,IAAA,IAAA,OAAA,KAAA,GAAA,OAAA,OAAA,EAEA,IAAA,EAAA,EAEA,EAAA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,UAAA,EAAA,EAAA,EAAA,EAAA,KAOA,OAJA,EAAA,UAAA,SAAA,EAAA,GACA,OAAA,IAAA,EAAA,UAAA,EAAA,EAAA,EAAA,KAGA,GAGA,EAAA,SAAA,SAAA,GACA,OAAA,GAAA,OAAA,KAAA,GAAA,OACA,EAAA,SAAA,GAAA,UADA,GAmDA,EAAA,UAAA,MAAA,aAEA,EAAA,UAAA,KAAA,EAwDA,EAAA,UAAA,YAAA,EA8BA,EAAA,YAAA,SAAA,EAAA,GACA,OAAA,EAAA,EAAA,IAGA,EAAA,UAAA,YAAA,EAsCA,EAAA,UAAA,MAAA,EACA,IAAA,EAAA,GACA,SAAA,EAAA,EAAA,GACA,GAAA,EAAA,OAAA,MACA,MAAA,IAAA,UAAA,uBAGA,IAAA,EAAA,KAAA,QAGA,IAAA,EAAA,YAAA,OAAA,EAAA,OAAA,EACA,GAAA,KAAA,EAAA,MAAA,GAEA,IAMA,EANA,EAAA,GACA,IAAA,EAAA,OACA,GAAA,EAEA,EAAA,GACA,EAAA,GAEA,GAAA,EACA,GAAA,EACA,GAAA,EAGA,EAAA,MAAA,EAAA,OAAA,GAAA,GAEA,EAAA,IAAA,iCACA,UACA,EAAA,KAEA,SAAA,IACA,GAAA,EAAA,CAGA,OAAA,GACA,IAAA,IACA,GAAA,EACA,GAAA,EACA,MACA,IAAA,IACA,GAAA,EACA,GAAA,EACA,MACA,QACA,GAAA,KAAA,EAGA,EAAA,MAAA,uBAAA,EAAA,GACA,GAAA,GAIA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OACA,EAAA,IAAA,EAAA,EAAA,OAAA,IACA,IAIA,GAHA,KAAA,MAAA,eAAA,EAAA,EAAA,EAAA,GAGA,GAAA,EAAA,GACA,GAAA,KAAA,EACA,GAAA,OAIA,OAAA,GACA,IAAA,IAGA,OAAA,EAEA,IAAA,KACA,IACA,GAAA,EACA,SAIA,IAAA,IACA,IAAA,IACA,IAAA,IACA,IAAA,IACA,IAAA,IAKA,GAJA,KAAA,MAAA,6BAAA,EAAA,EAAA,EAAA,GAIA,EAAA,CACA,KAAA,MAAA,cACA,MAAA,GAAA,IAAA,EAAA,IAAA,EAAA,KACA,GAAA,EACA,SAMA,EAAA,MAAA,yBAAA,GACA,IACA,EAAA,EAIA,EAAA,OAAA,IACA,SAEA,IAAA,IACA,GAAA,EAAA,CACA,GAAA,IACA,SAGA,IAAA,EAAA,CACA,GAAA,MACA,SAGA,EAAA,KAAA,CACA,KAAA,EACA,MAAA,EAAA,EACA,QAAA,EAAA,OACA,KAAA,EAAA,GAAA,KACA,MAAA,EAAA,GAAA,QAGA,GAAA,MAAA,EAAA,YAAA,MACA,KAAA,MAAA,eAAA,EAAA,GACA,GAAA,EACA,SAEA,IAAA,IACA,GAAA,IAAA,EAAA,OAAA,CACA,GAAA,MACA,SAGA,IACA,GAAA,EACA,IAAA,EAAA,EAAA,MAGA,GAAA,EAAA,MACA,MAAA,EAAA,MACA,EAAA,KAAA,GAEA,EAAA,MAAA,EAAA,OACA,SAEA,IAAA,IACA,GAAA,IAAA,EAAA,QAAA,EAAA,CACA,GAAA,MACA,GAAA,EACA,SAGA,IACA,GAAA,IACA,SAGA,IAAA,IAIA,GAFA,IAEA,EAAA,CACA,GAAA,KAAA,EACA,SAGA,GAAA,EACA,EAAA,EACA,EAAA,EAAA,OACA,GAAA,EACA,SAEA,IAAA,IAKA,GAAA,IAAA,EAAA,IAAA,EAAA,CACA,GAAA,KAAA,EACA,GAAA,EACA,SAKA,GAAA,EAAA,CAQA,IAAA,EAAA,EAAA,UAAA,EAAA,EAAA,GACA,IACA,OAAA,IAAA,EAAA,KACA,MAAA,GAEA,IAAA,EAAA,KAAA,MAAA,EAAA,GACA,EAAA,EAAA,OAAA,EAAA,GAAA,MAAA,EAAA,GAAA,MACA,EAAA,GAAA,EAAA,GACA,GAAA,EACA,UAKA,GAAA,EACA,GAAA,EACA,GAAA,EACA,SAEA,QAEA,IAEA,EAEA,GAAA,GACA,EAAA,IACA,MAAA,GAAA,IACA,GAAA,MAGA,GAAA,EAwBA,IAjBA,IAKA,EAAA,EAAA,OAAA,EAAA,GACA,EAAA,KAAA,MAAA,EAAA,GACA,EAAA,EAAA,OAAA,EAAA,GAAA,MAAA,EAAA,GACA,EAAA,GAAA,EAAA,IASA,EAAA,EAAA,MAAA,EAAA,EAAA,EAAA,MAAA,CACA,IAAA,EAAA,EAAA,MAAA,EAAA,QAAA,EAAA,KAAA,QACA,KAAA,MAAA,eAAA,EAAA,GAEA,EAAA,EAAA,QAAA,4BAAA,SAAA,EAAA,EAAA,GAYA,OAXA,IAEA,EAAA,MASA,EAAA,EAAA,EAAA,MAGA,KAAA,MAAA,iBAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,MAAA,EAAA,KAAA,EACA,MAAA,EAAA,KAAA,EACA,KAAA,EAAA,KAEA,GAAA,EACA,EAAA,EAAA,MAAA,EAAA,EAAA,SAAA,EAAA,MAAA,EAIA,IACA,IAEA,GAAA,QAKA,IAAA,GAAA,EACA,OAAA,EAAA,OAAA,IACA,IAAA,IACA,IAAA,IACA,IAAA,IAAA,GAAA,EAQA,IAAA,IAAA,EAAA,EAAA,OAAA,EAAA,GAAA,EAAA,IAAA,CACA,IAAA,EAAA,EAAA,GAEA,EAAA,EAAA,MAAA,EAAA,EAAA,SACA,EAAA,EAAA,MAAA,EAAA,QAAA,EAAA,MAAA,GACA,EAAA,EAAA,MAAA,EAAA,MAAA,EAAA,EAAA,OACA,EAAA,EAAA,MAAA,EAAA,OAEA,GAAA,EAKA,IAAA,EAAA,EAAA,MAAA,KAAA,OAAA,EACA,EAAA,EACA,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,EAAA,EAAA,QAAA,WAAA,IAIA,IAAA,EAAA,GACA,MAHA,EAAA,IAGA,IAAA,IACA,EAAA,KAGA,EADA,EAAA,EAAA,EAAA,EAAA,EAgBA,GATA,KAAA,GAAA,IACA,EAAA,QAAA,GAGA,IACA,EAAA,EAAA,GAIA,IAAA,EACA,MAAA,CAAA,EAAA,GAMA,IAAA,EACA,OAAA,EAAA,GAGA,IAAA,EAAA,EAAA,OAAA,IAAA,GACA,IACA,IAAA,EAAA,IAAA,OAAA,IAAA,EAAA,IAAA,GACA,MAAA,GAKA,OAAA,IAAA,OAAA,MAMA,OAHA,EAAA,MAAA,EACA,EAAA,KAAA,EAEA,EAQA,SAAA,IACA,GAAA,KAAA,SAAA,IAAA,KAAA,OAAA,OAAA,KAAA,OAQA,IAAA,EAAA,KAAA,IAEA,IAAA,EAAA,OAEA,OADA,KAAA,QAAA,EACA,KAAA,OAEA,IAAA,EAAA,KAAA,QAEA,EAAA,EAAA,WAAA,EACA,EAAA,IAAA,EACA,EACA,EAAA,EAAA,OAAA,IAAA,GAEA,EAAA,EAAA,IAAA,SAAA,GACA,OAAA,EAAA,IAAA,SAAA,GACA,OAAA,IAAA,EAAA,EACA,iBAAA,EAAA,EAAA,GACA,EAAA,OACA,KAAA,SACA,KAAA,KAIA,EAAA,OAAA,EAAA,KAGA,KAAA,SAAA,EAAA,OAAA,EAAA,QAEA,IACA,KAAA,OAAA,IAAA,OAAA,EAAA,GACA,MAAA,GACA,KAAA,QAAA,EAEA,OAAA,KAAA,OAgBA,SAAA,EAAA,EAAA,GAIA,GAHA,KAAA,MAAA,QAAA,EAAA,KAAA,SAGA,KAAA,QAAA,OAAA,EACA,GAAA,KAAA,MAAA,MAAA,KAAA,EAEA,GAAA,MAAA,GAAA,EAAA,OAAA,EAEA,IAAA,EAAA,KAAA,QAGA,MAAA,EAAA,MACA,EAAA,EAAA,MAAA,EAAA,KAAA,KAAA,MAIA,EAAA,EAAA,MAAA,GACA,KAAA,MAAA,KAAA,QAAA,QAAA,GAOA,IAIA,EACA,EALA,EAAA,KAAA,IAMA,IALA,KAAA,MAAA,KAAA,QAAA,MAAA,GAKA,EAAA,EAAA,OAAA,EAAA,GAAA,KACA,EAAA,EAAA,IADA,KAKA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CACA,IAAA,EAAA,EAAA,GACA,EAAA,EAKA,GAJA,EAAA,WAAA,IAAA,EAAA,SACA,EAAA,CAAA,IAEA,KAAA,SAAA,EAAA,EAAA,GAEA,QAAA,EAAA,aACA,KAAA,OAMA,OAAA,EAAA,YACA,KAAA,OAqKA,SAAA,EAAA,GACA,OAAA,EAAA,QAAA,SAAA,MAGA,SAAA,EAAA,GACA,OAAA,EAAA,QAAA,2BAAA,QA7RA,EAAA,OAAA,SAAA,EAAA,GACA,OAAA,IAAA,EAAA,EAAA,GAAA,IAAA,UAGA,EAAA,UAAA,OAAA,EA8CA,EAAA,MAAA,SAAA,EAAA,EAAA,GAEA,IAAA,EAAA,IAAA,EAAA,EADA,EAAA,GAAA,IAQA,OANA,EAAA,EAAA,OAAA,SAAA,GACA,OAAA,EAAA,MAAA,KAEA,EAAA,QAAA,SAAA,EAAA,QACA,EAAA,KAAA,GAEA,GAGA,EAAA,UAAA,MAAA,EA6DA,EAAA,UAAA,SAAA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,KAAA,QAEA,KAAA,MAAA,WACA,CAAA,KAAA,KAAA,KAAA,EAAA,QAAA,IAEA,KAAA,MAAA,WAAA,EAAA,OAAA,EAAA,QAEA,IAAA,IAAA,EAAA,EACA,EAAA,EACA,EAAA,EAAA,OACA,EAAA,EAAA,OACA,EAAA,GAAA,EAAA,EACA,IAAA,IAAA,CACA,KAAA,MAAA,iBACA,IA2FA,EA3FA,EAAA,EAAA,GACA,EAAA,EAAA,GAMA,GAJA,KAAA,MAAA,EAAA,EAAA,IAIA,IAAA,EAAA,OAAA,EAEA,GAAA,IAAA,EAAA,CACA,KAAA,MAAA,WAAA,CAAA,EAAA,EAAA,IAwBA,IAAA,EAAA,EACA,EAAA,EAAA,EACA,GAAA,IAAA,EAAA,CAQA,IAPA,KAAA,MAAA,iBAOA,EAAA,EAAA,IACA,GAAA,MAAA,EAAA,IAAA,OAAA,EAAA,KACA,EAAA,KAAA,MAAA,EAAA,GAAA,OAAA,GAAA,OAAA,EAEA,OAAA,EAIA,KAAA,EAAA,GAAA,CACA,IAAA,EAAA,EAAA,GAKA,GAHA,KAAA,MAAA,mBAAA,EAAA,EAAA,EAAA,EAAA,GAGA,KAAA,SAAA,EAAA,MAAA,GAAA,EAAA,MAAA,GAAA,GAGA,OAFA,KAAA,MAAA,wBAAA,EAAA,EAAA,IAEA,EAIA,GAAA,MAAA,GAAA,OAAA,IACA,EAAA,KAAA,MAAA,EAAA,OAAA,GAAA,CACA,KAAA,MAAA,gBAAA,EAAA,EAAA,EAAA,GACA,MAIA,KAAA,MAAA,4CACA,IAOA,SAAA,IAEA,KAAA,MAAA,2BAAA,EAAA,EAAA,EAAA,GACA,IAAA,IAqBA,GAZA,iBAAA,GAEA,EADA,EAAA,OACA,EAAA,gBAAA,EAAA,cAEA,IAAA,EAEA,KAAA,MAAA,eAAA,EAAA,EAAA,KAEA,EAAA,EAAA,MAAA,GACA,KAAA,MAAA,gBAAA,EAAA,EAAA,KAGA,EAAA,OAAA,EAeA,GAAA,IAAA,GAAA,IAAA,EAGA,OAAA,EACA,GAAA,IAAA,EAIA,OAAA,EACA,GAAA,IAAA,EAMA,OADA,IAAA,EAAA,GAAA,KAAA,EAAA,GAKA,MAAA,IAAA,MAAA;;ACh5BkB9I,IAAAA,EAAAA,QAAQ,iBAArB2O,EAAAA,EAAAA,UACDC,EAAO5O,QAAQ,cACf+L,EAAS/L,QAAQ,gBACjB6O,EAAc7O,QAAQ,oBACtBkN,EAAQlN,QAAQ,sBAChB8O,EAAY9O,QAAQ,aAExB,SAAS+O,EAAMC,EAAIC,GAAS,IAAA,EAAA,KAGtBtQ,EAAM,IAAIkQ,GAFdI,EAAUA,GAAW,IAEatQ,KAC9BgB,EAAM,IAKVO,OAAOgP,eAAe,KAAM,KAAM,CAChC7G,IAAK,WAAoB2G,OAAAA,GACzBG,YAAY,IAQdjP,OAAOgP,eAAe,KAAM,MAAO,CACjC7G,IAAK,WAAoB1J,OAAAA,GACzBwQ,YAAY,IAQTC,KAAAA,GAAK,SAAS/O,EAAMsH,GACvBtH,EAAOuO,EAAKS,QAAQ1P,EAAKU,GAEzB2O,EAAGM,KAAKjP,EAAM,SAAS6H,EAAKqH,GACvBrH,EACDP,EAAS,IAAIoE,EAAOyD,QAAQ,KAAMnP,IAGlB,cAAfkP,EAAME,MACP9P,EAAMU,EACNsH,KAEAA,EAAS,IAAIoE,EAAOyD,QAAQ,KAAMnP,OAQnCqP,KAAAA,IAAM,WACF/P,OAAAA,GAGJgQ,KAAAA,SAAW,GAKd,CAAA,KACA,OACA,QACA,MACA,KACA,KACA,UACA,SACA,QACAzF,QAAQ,SAAC0F,GACT,EAAKD,SAASC,GAAcjB,EAAU,EAAKiB,GAAYC,KAAK,MAoBhEd,EAAMxQ,UAAUuR,KAAO,SAASzP,EAAMnC,EAAMyJ,GAEtCoI,IACAf,EADK,KACGA,GACO,mBAAT9Q,IACRyJ,EAAWzJ,EACXA,EAAO,IAETA,EAAOA,GAAQ,GACfyJ,EAAWA,GAAY,aACvBtH,EAAOuO,EAAKS,QARH,KAQcK,MAAOrP,GAE9B2O,EAAGgB,SAAS3P,EAAM,OAAQ,SAAS4H,EAAOsE,GACrCtE,GAAAA,EACDN,EAASM,QAGP,IACQ,IAAIgI,SAAS,KAAM,OAAQ,WAAY1D,EACjD2D,CAAIlB,EAAI9Q,EAAMyJ,GACd,MAAM7K,GACN6K,EAAS7K,OAYfiS,EAAMxQ,UAAU4R,MAAQ,SAAS9P,EAAM4O,EAAStH,GAC1CoI,IACAf,EADK,KACGA,GACU,mBAAZC,IACRtH,EAAWsH,EACXA,EAAU,IAEZA,EAAUA,GAAW,GACrBtH,EAAWA,GAAY,aACvBtH,EAAOuO,EAAKS,QARH,KAQcK,MAAOrP,GAc9B2O,EAAGM,KAAKjP,EAAM,SAAS4H,GAClBA,GACyB,IAAvBgH,EAAQmB,WACTzI,IAfG0I,SAAWhQ,GAClB2O,EAAGsB,UAAUjQ,EAAM,GAAIsH,GAgBnB0I,CAAWhQ,GAbRkQ,SAAYlQ,GACfmQ,IAAAA,EAAMC,KAAKD,MACXE,EAAQzB,EAAQ0B,MAAQH,EACxBI,EAAQ3B,EAAQ0B,MAAQH,EAE5BxB,EAAG6B,OAAOxQ,EAAMqQ,EAAOE,EAAOjJ,GAW5B4I,CAAYlQ,MAWlB0O,EAAMxQ,UAAUuS,IAAM,SAASC,EAAOpJ,GAChCoI,IAAAA,EAAK,KACLf,EAAKe,EAAGf,GACRgC,EAAM,GACVrJ,EAAWA,GAAY,aAEnBoJ,GAKJA,EAAyB,iBAAVA,EAAqB,CAAEA,GAAUA,EAchD7D,EAAMG,WAAW0D,EAZRE,SAAO3E,EAAM3E,GAChBuJ,IAAAA,EAAWtC,EAAKS,QAAQU,EAAGL,MAAOpD,GACtC0C,EAAGgB,SAASkB,EAAU,OAAQ,SAASjJ,EAAOsE,GACzCtE,EACDN,EAASM,IAGX+I,GAAOzE,EAAO,KACd5E,QAI4B,SAASM,GACpCA,EACDN,EAASM,GAETN,EAAS,KAAMqJ,EAAIpQ,QAAQ,MAAO,QAtBpC+G,EAAS,IAAIoE,EAAOiB,OAAO,4BA4C/B+B,EAAMxQ,UAAU4S,GAAK,SAAStR,EAAKoP,EAAStH,GACtCoI,IAAAA,EAAK,KACLf,EAAKe,EAAGf,GACU,mBAAZC,IACRtH,EAAWsH,EACXA,EAAU,IAEZA,EAAUA,GAAW,GACrBtH,EAAWA,GAAY,aAEnB9H,EAKKuR,SAAAA,EAAK/Q,EAAMsH,GACd0J,IAAAA,EAAWzC,EAAKS,QAAQU,EAAGL,MAAOrP,GAClCiI,EAAS,GAEb0G,EAAGsC,QAAQD,EAAU,SAASpJ,EAAOsJ,GAChCtJ,EACDN,EAASM,GA8BXiF,EAAMG,WAAWkE,EA1BRC,SAAY/R,EAAMkI,GACzBlI,EAAOmP,EAAK6C,KAAKJ,EAAU5R,GAC3BuP,EAAGM,KAAK7P,EAAM,SAASwI,EAAOsH,GACzBtH,GAAAA,EACDN,EAASM,OADRA,CAICyJ,IAAAA,EAAQnC,EAETN,EAAQ0C,WAA4B,cAAfpC,EAAME,KAC5B2B,EAAKxC,EAAK6C,KAAKJ,EAAUK,EAAMjS,MAAO,SAASwI,EAAO2J,GACjD3J,EACDN,EAASM,IAGXyJ,EAAMG,SAAWD,EACjBtJ,EAAOhK,KAAKoT,GACZ/J,QAGFW,EAAOhK,KAAKoT,GACZ/J,SAKiC,SAASM,GAC9CN,EAASM,EAAOK,OAKtB8I,CAAKvR,EAAK8H,GA9CRA,EAAS,IAAIoE,EAAOiB,OAAO,0BAwD/B+B,EAAMxQ,UAAUuT,GAAK,SAASzR,EAAM4O,EAAStH,GACvCoI,IAAAA,EAAK,KACLf,EAAKe,EAAGf,GACU,mBAAZC,IACRtH,EAAWsH,EACXA,EAAU,IAEZA,EAAUA,GAAW,GACrBtH,EAAWA,GAAY,aAEnBtH,EAKK0R,SAAAA,EAAOV,EAAU1J,GACxB0J,EAAWzC,EAAKS,QAAQU,EAAGL,MAAO2B,GAClCrC,EAAGM,KAAK+B,EAAU,SAASpJ,EAAOsH,GAC7BtH,EACDN,EAASM,GAKO,SAAfsH,EAAME,KAMTT,EAAGsC,QAAQD,EAAU,SAASpJ,EAAOsJ,GAChCtJ,EACDN,EAASM,GAKW,IAAnBsJ,EAAQ/T,OAMPyR,EAAQ0C,WAMZJ,EAAUA,EAAQS,IAAI,SAASd,GAEtBtC,OAAAA,EAAK6C,KAAKJ,EAAUH,KAE7BhE,EAAMG,WAAWkE,EAASQ,EAAQ,SAAS9J,GACtCA,EACDN,EAASM,GAGX+G,EAAGiD,MAAMZ,EAAU1J,MAdnBA,EAAS,IAAIoE,EAAOmG,UAAU,KAAMb,IANpCrC,EAAGiD,MAAMZ,EAAU1J,KAbrBqH,EAAGmD,OAAOd,EAAU1J,KAuC1BoK,CAAO1R,EAAMsH,GArDXA,EAAS,IAAIoE,EAAOiB,OAAO,2BA6D/B+B,EAAMxQ,UAAU6T,QAAU,SAASzK,GAC7BoI,IACAf,EADK,KACGA,GACRqD,EAFK,KAEI1T,IAAI0J,IAAI,OACrBV,EAAWA,GAAY,aAIvBqH,EAAGsD,MAAMD,EAAK,WACZ1K,EAAS,KAAM0K,MAWnBtD,EAAMxQ,UAAUgU,OAAS,SAASlS,EAAMsH,GAClCoI,IACAf,EADK,KACGA,GACZrH,EAAWA,GAAY,aAEnBtH,EAIc,MAATA,EAIAmS,SAAAA,EAAQnS,EAAMsH,GACrBqH,EAAGM,KAAKjP,EAAM,SAAU6H,EAAKoH,GACxBA,GAAAA,EAAM,CACJA,GAAAA,EAAKmD,cAEN,YADA9K,IAGG,GAAI2H,EAAKoD,SAEZ,YADA/K,EAAS,IAAIoE,EAAOyD,QAAQ,KAAMnP,QAIjC,CAAA,GAAI6H,GAAoB,WAAbA,EAAIuC,KAElB,YADA9C,EAASO,GAILyK,IAAAA,EAAS/D,EAAKgE,QAAQvS,GACZ,MAAXsS,EACD3D,EAAGsD,MAAMjS,EAAM,SAAU6H,GACnBA,GAAoB,WAAbA,EAAIuC,KACb9C,EAASO,GAGXP,MAKF6K,EAAQG,EAAQ,SAAUzK,GACpBA,GAAAA,EAAK,OAAOP,EAASO,GACzB8G,EAAGsD,MAAMjS,EAAM,SAAU6H,GACnBA,GAAoB,WAAbA,EAAIuC,KACb9C,EAASO,GAGXP,WASZ6K,CAAQnS,EAAMsH,GAhDZA,IAJAA,EAAS,IAAIoE,EAAOiB,OAAO,2BAkE/B+B,EAAMxQ,UAAUsU,KAAO,SAASxS,EAAM4O,EAAStH,GACzCoI,IAAAA,EAAK,KACLf,EAAKe,EAAGf,GACU,mBAAZC,IACRtH,EAAWsH,EACXA,EAAU,IAGZtH,EAAWA,GAAY,aAEnBmI,IAAAA,GAHJb,EAAUA,GAAW,IAGFa,MAAQ,SAASzP,EAAMyS,GAAQA,KAC9CC,EAAQ,GAmBHC,SAAAA,EAAiB3S,EAAMsH,GAG1BsL,IAAAA,EAAUrE,EAAKpO,eAAeH,IAG/B4O,EAAQiE,OAAUjE,EAAQiE,MAAMC,KAAKF,GAMrChE,EAAQxP,OAASqP,EAAUF,EAAKxO,SAAS6S,GAAUhE,EAAQxP,OAM3DwP,EAAQ5O,OAASyO,EAAUF,EAAKgE,QAAQK,GAAUhE,EAAQ5O,MAL3DsH,IAzBKyL,SAAY/S,EAAMsH,GACzBmI,EAAKzP,EAAM,SAAS6H,GACfA,EACDP,EAASO,IAIX6K,EAAMzU,KAAK+B,GACXsH,OA2BFyL,CAAY/S,EAAMsH,GAhBhBA,IAmBK0L,SAAAA,EAAKhT,EAAMsH,GAClBtH,EAAOuO,EAAKS,QAAQU,EAAGL,MAAOrP,GAK9B2O,EAAGsC,QAAQjR,EAAM,SAAS6H,EAAKqJ,GAC1BrJ,EACe,YAAbA,EAAIuC,KACLuI,EAAiB3S,EAAMsH,GAEvBA,EAASO,GAMb8K,EAAiBpE,EAAKjO,YAAYN,GAAO,SAAS6H,GAC7CA,EACDP,EAASO,IAIXqJ,EAAUA,EAAQS,IAAI,SAASN,GACtB9C,OAAAA,EAAK6C,KAAKpR,EAAMqR,KAGzBxE,EAAMG,WAAWkE,EAAS8B,EAAM,SAASnL,GACvCP,EAASO,EAAK6K,UAvElB1S,EA8EJ2O,EAAGM,KAAKjP,EAAM,SAAS6H,EAAKqH,GACvBrH,EACDP,EAASO,GAGPqH,EAAMkD,cAKVY,EAAKhT,EAAMsH,GAJTA,EAAS,IAAIoE,EAAOyD,QAAQ,KAAMnP,MAnFpCsH,EAAS,IAAIoE,EAAOiB,OAAO,2BA2F/B1Q,OAAOC,QAAUwS;;ACziBjB,SAASuE,EAAWhH,EAAMvO,GACnB,IAAA,IAAIM,EAAIN,EAAMP,OAAS,EAAGa,GAAK,EAAGA,IACjCN,EAAMM,KAAOiO,GACfvO,EAAMwV,OAAOlV,EAAG,GAGbN,OAAAA,EAGT,IAAIyV,EAAe,aAEnBA,EAAaC,gBAAkB,SAASC,GAClCC,IAAAA,EAAU,CAEdA,GAAa,SAASlU,EAAM2N,QACC,IAAhB,KAAKsG,KACTA,KAAAA,GAAS,IAEX,KAAKA,GAAOzF,eAAexO,KACzBiU,KAAAA,GAAOjU,GAAQ,IAEjBiU,KAAAA,GAAOjU,GAAMnB,KAAK8O,IAGzBuG,IAAc,SAASlU,EAAM2N,QACA,IAAhB,KAAKsG,IACZ,KAAKA,GAAOzF,eAAexO,IAC7B6T,EAAWlG,EAAI,KAAKsG,GAAOjU,KAI/BkU,QAAkB,SAASlU,GACrB,QAAuB,IAAhB,KAAKiU,IAA0B,KAAKA,GAAOzF,eAAexO,GAE9D,IADDvB,IAAAA,EAAOC,MAAMI,UAAUqV,MAAM7W,KAAKqB,UAAW,GACxCC,EAAI,EAAGA,EAAI,KAAKqV,GAAOjU,GAAMjC,OAAQa,IACvCqV,KAAAA,GAAOjU,GAAMpB,GAAGG,MAAM,KAAKkV,GAAOjU,GAAMpB,GAAIH,IAKvDyV,mBAA6B,SAASlU,GAChC,QAAuB,IAAhB,KAAKiU,GAAZ,CACAG,IAAAA,EAAO,KACXA,EAAKH,GAAOjU,GAAMyK,QAAQ,SAASkD,GACjCyG,EAAK3U,IAAIO,EAAM2N,QAIZuG,OAAAA,GAGT,IAAIG,EAAMN,EAAaC,gBAAgB,aACvCD,EAAajV,UAAUwV,IAAMD,EAAI/U,GACjCyU,EAAajV,UAAUyV,KAAOF,EAAI5U,IAClCsU,EAAajV,UAAU0V,SAAWH,EAAII,QAEtC,IAAIC,EAAMX,EAAaC,gBAAgB,YACvCD,EAAajV,UAAUQ,GAAK,WAC1BoV,EAAIpV,GAAGP,MAAM,KAAMJ,WACnBD,MAAMI,UAAU6V,QAAQrX,KAAKqB,UAAW,MACnC6V,KAAAA,SAASzV,MAAM,KAAMJ,YAE5BoV,EAAajV,UAAUW,IAAMiV,EAAIjV,IACjCsU,EAAajV,UAAU2V,QAAUC,EAAID,QACrCV,EAAajV,UAAUa,mBAAqB+U,EAAI/U,mBAEhD9C,OAAOC,QAAUiX;;;ACuPjB,IAAA,EAAA,UAAA,GAAA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GAzTA,IAAIA,EAAexT,QAAQ,qBACvBqB,EAAOrB,QAAQ,oBAAoBqB,KAEvC,SAASgT,EAASC,EAAOlH,GACnBmH,IAAAA,EAAO,EACJ,OAAA,WACD/D,IAAAA,EAAMC,KAAKD,MACXA,EAAM+D,EAAOD,IACfC,EAAO/D,EACPpD,EAAG5O,MAAM,KAAMJ,aAKrB,SAASoW,EAAOC,EAAGC,GAEb,QADa,IAAND,GAAsBA,IAAKA,EAAI,IACzB,WAAb,EAAOC,GACJ,IAAA,IAAItM,KAAOsM,EACVA,EAAEzG,eAAe7F,KACnBqM,EAAErM,GAAOsM,EAAEtM,IAIVqM,OAAAA,EAGT,IAAIE,EAAgB,SAASC,GACvB,YAAkB,IAAXA,QACwB,IAAxBA,EAAOD,aACT,CACLE,QAAU,aACVC,QAAU,aACVxB,WAAa,cAGVsB,EAAOD,aATI,CAUlB5N,GAEF,SAASgO,IACHlB,IAAAA,EAAO,KACPrD,EAAMC,KAAKD,MAEVwE,KAAAA,OAAiB3T,IACjB4T,KAAAA,YAAiBzE,EACjB0E,KAAAA,YAAiB,GACjBC,KAAAA,eAAiB,GAElBC,IAAAA,EAAiB,WACnBvB,EAAKwB,gBAAgB7W,MAAMqV,EAAMzV,YAIX,oBAAbkX,WAIPA,SAASC,YACXD,SAASC,YAAY,YAAaH,GAElCrO,EAAOyO,iBAAiB,UAAWJ,GAAgB,IAIvDL,EAASxW,UAAUkX,aAAe,SAASrI,GACrCsI,IAAAA,EAAY,IACZC,EAAY,GACZ9B,EAAY,KACZ+B,GAAY,EACZC,GAAY,EACZC,EAAY,KAEPC,SAAAA,IACHH,IAAAA,EAAAA,CAIApF,IAAAA,EAAMC,KAAKD,MACXwF,EAA8C,EAAjCrB,EAAaE,QAAQoB,GAClCD,GAAAA,GAAcxF,EAAMwF,EAAaN,EAMnC,OALKG,IACHhC,EAAKE,IAAI,UAAWgC,GACpBF,GAAY,QAEdC,EAAYjZ,WAAWkZ,EAAMJ,IAG/BC,GAAW,EACXjB,EAAaG,QAAQmB,EAAYzF,GAEjCpD,IAIO8I,WACHL,GACFhC,EAAKG,KAAK,UAAW+B,GAEnBD,GACF5Y,aAAa4Y,GAEfnB,EAAarB,WAAW2C,GAVxBC,IAaFH,KAGFhB,EAASxW,UAAU4X,cAAgB9B,EAAS,IAAK,WACpC,KAENoB,aAAa,WACZjF,IAGA4F,EAFAC,EADM5F,KAAKD,MACO8F,EAClBC,EAAU,EAGV,IACFH,EAAWzJ,KAAKC,MAAM+H,EAAaE,QAAQ2B,IAAe,MAC1D,MAAM1Z,GACNsZ,EAAW,GAER,IAAA,IAAI/X,EAAI+X,EAAS5Y,OAAS,EAAGa,GAAK,EAAGA,IACpC+X,EAAS/X,GAAGoY,UAAYJ,IAC1BD,EAAS7C,OAAOlV,EAAG,GACnBkY,KAGAA,EAAU,GACZ5B,EAAaG,QAAQ0B,EAAY7J,KAAKG,UAAUsJ,QAKtDrB,EAASxW,UAAUmY,cAAgBrC,EAAS,IAAK,WAC3CR,IAAAA,EAAO,KAEXA,EAAK4B,aAAa,WAGLhF,KAAKD,MAFZiG,IAAgBrO,EAChBuO,EAEAJ,EAAU,EAEV,IACFI,EAAQhK,KAAKC,MAAM+H,EAAaE,QAAQ+B,IAAe,MACvD,MAAM9Z,GACN6Z,EAAQ,GAELvO,IAAAA,KAAOuO,EACN9C,EAAKgD,cAAczO,EAAKuO,YACnBA,EAAMvO,GACbmO,KAIAA,EAAU,GACZ5B,EAAaG,QAAQ8B,EAAYjK,KAAKG,UAAU6J,QAKtD5B,EAASxW,UAAUsY,cAAgB,SAASzO,EAAKuO,GAC3C,IAACA,EACI,OAAA,EAEL,IAACA,EAAM1I,eAAe7F,GACjB,OAAA,EAEL,GAAsB,WAAtB,EAAOuO,EAAMvO,IACR,OAAA,EAGL0O,IAAAA,EAAMH,EAAMvO,GAAK0O,KAAOC,EACxBvG,EAAMC,KAAKD,MAERiG,OADSE,EAAMvO,GAAKqO,UACRjG,EAAMsG,GAG3B/B,EAASxW,UAAUyY,qBAAuB,SAASjP,EAAOkP,GACpDlP,GAAAA,GAASA,EAAMK,IACVL,OAAAA,EAAMK,MAAQ6O,EAGnBC,IAAAA,EAAevC,EAAaE,QAAQoC,GACpCC,OAAAA,IAAiB,KAAK/B,eAAe8B,KAGpC9B,KAAAA,eAAe8B,GAASC,GACtB,IAGTnC,EAASxW,UAAU8W,gBAAkB,SAAStN,GAC5CA,EAAQA,GAAShB,EAAOgB,MACpB8L,IAAAA,EAAO,KAEP,KAAKmD,qBAAqBjP,EAAOyO,IAC9Bf,KAAAA,aAAa,WACZjF,IAEA4F,EAFA5F,EAAMC,KAAKD,MACXjE,EAAOoI,EAAaE,QAAQ2B,GAG5B,IACFJ,EAAWzJ,KAAKC,MAAML,GAAQ,MAC9B,MAAMzP,GACNsZ,EAAW,GAER,IAAA,IAAI/X,EAAI,EAAGA,EAAI+X,EAAS5Y,OAAQa,IAC/B+X,GAAAA,EAAS/X,GAAG2W,SAAWnB,EAAKmB,UAC5BoB,EAAS/X,GAAGoY,UAAY5C,EAAKoB,aAA7BmB,CACAA,GAAAA,EAAS/X,GAAG8Y,GAAI,CACdtD,GAAAA,EAAKqB,YAAYjH,eAAemI,EAAS/X,GAAG8Y,IAAK,SACrDtD,EAAKqB,YAAYkB,EAAS/X,GAAG8Y,KAAM,EAErCtD,EAAKK,QAAQkC,EAAS/X,GAAGoB,KAAM2W,EAAS/X,GAAG+Y,SAE7CvD,EAAKoB,YAAczE,IAIlByD,KAAAA,SAAS,UAAWlM,IAG3BgN,EAASxW,UAAU8Y,MAAQ,SAAS5X,EAAMiL,EAASyM,GAE7CA,IADJA,EAAoB,iBAAPA,GAAiC,iBAAPA,EAAmBG,OAAOH,GAAM,OAC7DA,EAAG3Z,OAAQ,CACf,GAAA,KAAK0X,YAAYjH,eAAekJ,GAAK,OACpCjC,KAAAA,YAAYiC,IAAM,EAGrBI,IAAAA,EAAS,CACXJ,GAAYA,EACZ1X,KAAYA,EACZuV,OAAY,KAAKA,OACjByB,UAAYhG,KAAKD,MACjB4G,QAAY1M,GAGVmJ,EAAO,KACN4B,KAAAA,aAAa,WACZlJ,IAAAA,EAAOoI,EAAaE,QAAQ2B,IAAe,KAC3CgB,EAAsB,OAATjL,EAAiB,GAAK,IACvCA,EAAO,CAACA,EAAKjB,UAAU,EAAGiB,EAAK/O,OAAS,GAAIga,EAAW7K,KAAKG,UAAUyK,GAAS,KAAK9F,KAAK,IACzFkD,EAAaG,QAAQ0B,EAAYjK,GACjCsH,EAAKK,QAAQzU,EAAMiL,GAEnB7N,WAAW,WACTgX,EAAKsC,iBACJ,OAIPpB,EAASxW,UAAUc,KAAO,SAASI,EAAMiL,GAClC2M,KAAAA,MAAM7Y,MAAM,KAAMJ,WAClB6V,KAAAA,SAAS,OAAQxU,EAAMiL,IAG9BqK,EAASxW,UAAUU,KAAO,SAASmJ,EAAKgF,EAAI0J,GACtC,GAAC/B,EAAS0C,UAAV,CAIA5D,IAAAA,EAAO,KACN4B,KAAAA,aAAa,WACZlJ,IAAAA,EACA,IACFA,EAAOI,KAAKC,MAAM+H,EAAaE,QAAQ+B,IAAe,MACtD,MAAM9Z,GACNyP,EAAO,GAEJsH,EAAKgD,cAAczO,EAAKmE,KAI7BA,EAAKnE,GAAO,GACZmE,EAAKnE,GAAKqO,UAAYhG,KAAKD,MACR,iBAARsG,IACTvK,EAAKnE,GAAK0O,IAAY,IAANA,GAGlBnC,EAAaG,QAAQ8B,EAAYjK,KAAKG,UAAUP,IAChDa,IAEAvQ,WAAW,WACTgX,EAAK6C,iBACJ,SAIPlC,EAAOO,EAASxW,UAAWiV,EAAajV,WAExCwW,EAAS0C,eAAqC,IAAjB9C,EAE7B,IAAI6B,EAAa,WACbI,EAAa,gBACbX,EAAa,gBAEbK,EAAqB,IACrBS,EAAqB,KAEzBhC,EAAS2C,QAAU,WACjB/C,EAAarB,WAAW2C,GACxBtB,EAAarB,WAAWkD,GACxB7B,EAAarB,WAAWsD,IAG1B7B,EAAS4C,YAAe,WAClBC,IAAAA,EACG,OAAA,WAIEA,OAHFA,IACHA,EAAW,IAAI7C,GAEV6C,GANa,GAUxBtb,OAAOC,QAAUwY;;AC7TjB,IAAIvB,EAAexT,QAAQ,0BACvB4O,EAAO5O,QAAQ,aACf+U,EAAW/U,QAAQ,sBAMvB,SAAS6X,IACPrE,EAAazW,KAAK,MACd8W,IAEAiE,EACA5G,EAHA2C,EAAO,KACPlC,GAAY,EAIPoG,SAAAA,EAAS1X,IAEb6Q,IAAa7Q,GAASsR,GAAmD,IAAtCtR,EAAKK,QAAQoX,KACjDjE,EAAKK,QAAQ,SAAU,SAAU7T,GAKrCwT,EAAKmE,MAAQ,SAASC,EAAWC,EAAaC,GAEzCjH,IAAAA,EAAAA,CAIAtC,GAAAA,EAAKnO,OAAOwX,GACP,MAAA,IAAIxb,MAAM,6CAOlByU,EAAWtC,EAAKrO,UAAU0X,IAG1BtG,GAA2B,IAAfwG,KAKVL,EAAmC,MAAb5G,EAAmB,IAAMA,EAAW,KAG7C6D,EAAS4C,cACf5Y,GAAG,SAAUgZ,KAGxBlE,EAAKuE,MAAQ,WACIrD,EAAS4C,cACfzY,IAAI,SAAU6Y,GACvBlE,EAAKzU,mBAAmB,WAG5ByY,EAAUtZ,UAAY,IAAIiV,EAC1BqE,EAAUtZ,UAAUqM,YAAciN,EAElCvb,OAAOC,QAAUsb;;;AC7DjB,IAAA,EAAA,QAAA,UAAA,OAAAvb,OAAOC,QAAU,CACf2O,OAAQ,SAAAmN,GAAU1P,OAAAA,EAAOC,KAAKyP,IAC9B9M,OAAQ,SAAAnC,GAAUA,OAAAA,EAAOhI,SAAS;;ACFpC,IAAIsB,EAAiB1C,QAAQ,kBAAkB0C,eAE/CpG,OAAOC,QAAU,SAAwB4a,EAAI1H,GACtC0H,KAAAA,GAAKA,EACL1H,KAAAA,KAAOA,GAAQ/M;;ACmHtB,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAjHI1C,IAAAA,EAAAA,QAAQ,eALV0C,EAAAA,EAAAA,eACAC,EAAAA,EAAAA,oBACAC,EAAAA,EAAAA,wBACAG,EAAAA,EAAAA,yBACAD,EAAAA,EAAAA,wBAME9C,EAAAA,QAAQ,eAAesE,YAHzBK,EAAAA,EAAAA,QACAC,EAAAA,EAAAA,QACAI,EAAAA,EAAAA,QAOF,SAASsT,EAASrJ,EAASsJ,EAAM5Q,GAC5BsH,GAAAA,EAAQsJ,GACF5Q,OAAAA,IAGTsH,EAAQ5N,KAAK,SAAS6G,EAAKiP,GACtBjP,GAAAA,EACMP,OAAAA,EAASO,GAElB+G,EAAQsJ,GAAQpB,EAChBxP,MAQJ,SAAS6Q,EAAaC,EAAUC,GACvBD,OAAAA,GACF9V,KAAAA,EACI,OAAC+V,GAAmB5V,GAA2B8B,EACnDhC,KAAAA,EACI,OAAC8V,GAAmB3V,GAA4BiC,EACpDtC,KAAAA,EAEL,QACS,OAACgW,GAAmB3V,GAA4B4B,GAOrDgU,IAAAA,EAoEN,WAnEc1J,SAAAA,EAAAA,GAAS,EAAA,KAAA,GACfuB,IAAAA,EAAMC,KAAKD,MAEV2G,KAAAA,GAAKlI,EAAQkI,GACb5K,KAAAA,KAAO0C,EAAQ1C,KACfqM,KAAAA,KAAO3J,EAAQ2J,MAAQ,EACvBlI,KAAAA,MAAQzB,EAAQyB,OAASF,EACzBqI,KAAAA,MAAQ5J,EAAQ4J,OAASrI,EACzBI,KAAAA,MAAQ3B,EAAQ2B,OAASJ,EACzBsI,KAAAA,MAAQ7J,EAAQ6J,OAAS,GACzBC,KAAAA,OAAS9J,EAAQ8J,QAAU,GAC3BC,KAAAA,OAAS/J,EAAQ+J,QAAU,EAQL,iBAAjB/J,EAAQQ,KACXA,KAAAA,KAAOR,EAAQQ,KACY,iBAAjBR,EAAQ5H,KAClBoI,KAAAA,KAAOR,EAAQ5H,KAEfoI,KAAAA,KAAO/M,EAITuW,KAAAA,YAAchK,EAAQgK,aAAeT,EAAa,KAAK/I,MACvDyJ,KAAAA,IAAMjK,EAAQiK,KAAO,EACrBC,KAAAA,IAAMlK,EAAQkK,KAAO,EAqC9B,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,SA9BW,MAAA,WACA,MAAA,CACLhC,GAAI,KAAKA,GACT5K,KAAM,KAAKA,KACXqM,KAAM,KAAKA,KACXlI,MAAO,KAAKA,MACZmI,MAAO,KAAKA,MACZjI,MAAO,KAAKiI,MACZC,MAAO,KAAKA,MACZC,OAAQ,KAAKA,OACbC,OAAQ,KAAKA,OAEb3R,KAAM,KAAKoI,KACXwJ,YAAa,KAAKA,YAClBC,IAAK,KAAKA,IACVC,IAAK,KAAKA,OAehB,CAAA,IAAA,OATa,IAAA,WACFX,OAAAA,EAAa,KAAK/I,KAAM,KAAKwJ,cAG7BnQ,IAAAA,SAAAA,GACFmQ,KAAAA,YAAcnQ,MAIvB,EAAA,GAAAxM,OAAOC,QAAQ4D,OAAS,SAAgB8O,EAAStH,GAE/C2Q,EAASrJ,EAAS,KAAM,SAAS/G,GAC5BA,GAAAA,EACMP,OAAAA,EAASO,GAGlBoQ,EAASrJ,EAAS,OAAQ,SAAS/G,GAC9BA,GAAAA,EACMP,OAAAA,EAASO,GAGlBP,EAAS,KAAM,IAAIgR,EAAK1J;;ACnI9B,IAAMlD,EAAS/L,QAAQ,eACjB2Y,EAAO3Y,QAAQ,UAErB,SAASoZ,EAAoB/Y,EAAM8W,EAAI2B,EAAOO,GACvChZ,KAAAA,KAAOA,EACP8W,KAAAA,GAAKA,EACL2B,KAAAA,MAAQA,EACRO,KAAAA,SAAWA,EAKlBD,EAAoB7a,UAAU+a,QAAU,SAASC,EAAS5R,GACpDwP,IAAAA,EAAK,KAAKA,GACV9W,EAAO,KAAKA,KAchBkZ,EAAQ/Q,UAAU2O,EAZTqC,SAAqBvR,EAAOwR,GAChCxR,OAAAA,EACMN,EAASM,GAGdwR,OAIJd,EAAKxY,OAAOsZ,EAAM9R,GAHTA,EAAS,IAAIoE,EAAO2N,MAAM,yCAA0CrZ,OASjF/D,OAAOC,QAAU6c;;AC/BjB,IAAIO,EAAY3Z,QAAQ,kBAExB,SAAS4Z,EAAU3K,GACbuB,IAAAA,EAAMC,KAAKD,MAEV2G,KAAAA,GAAKwC,EAAU7V,cACf2L,KAAAA,KAAOkK,EAAU9W,eACjB6N,KAAAA,MAAQzB,EAAQyB,OAASF,EACzBqI,KAAAA,MAAQ5J,EAAQ4J,OAASrI,EACzBI,KAAAA,MAAQ3B,EAAQ2B,OAASJ,EAEzBqJ,KAAAA,MAAQ5K,EAAQ4K,MAGvBD,EAAUzZ,OAAS,SAAS8O,EAAStH,GACnCsH,EAAQ5N,KAAK,SAAS6G,EAAK2R,GACtB3R,EACDP,EAASO,IAGX+G,EAAQ4K,MAAQ5K,EAAQ4K,OAASA,EACjClS,EAAS,KAAM,IAAIiS,EAAU3K,QAIjC3S,OAAOC,QAAUqd;;ACzBjB,IAAID,EAAY3Z,QAAQ,kBACpB4O,EAAO5O,QAAQ,aAGnB,SAAS8Z,EAAgBC,GAChB,OAAA,IAAItJ,KAAmB,IAAduJ,OAAOD,IAGzB,SAASE,EAAM5Z,EAAM6Z,EAAUC,GACxBC,KAAAA,IAAMD,EACNV,KAAAA,KAAOS,EAAS/C,GAChB1H,KAAAA,KAAOyK,EAASzK,KAChBmJ,KAAAA,KAAOsB,EAAStB,KAChBI,KAAAA,OAASkB,EAASlB,OAElBtI,KAAAA,MAAQoJ,EAAgBI,EAASxJ,OACjCE,KAAAA,MAAQkJ,EAAgBI,EAAStJ,OACjCiI,KAAAA,MAAQiB,EAAgBI,EAASrB,OAEjCwB,KAAAA,QAAUH,EAASxJ,MACnB4J,KAAAA,QAAUJ,EAAStJ,MACnB2J,KAAAA,QAAUL,EAASrB,MACnBha,KAAAA,QAAUqb,EAASrb,QACnBwI,KAAAA,KAAO6S,EAAS7S,KAChB6R,KAAAA,IAAMgB,EAAShB,IACfC,KAAAA,IAAMe,EAASf,IACf1Z,KAAAA,KAAOmP,EAAKxO,SAASC,GAG5B4Z,EAAM1b,UAAUmU,OAAS,WAChB,OAAA,KAAKjD,OAASkK,EAAUjX,gBAGjCuX,EAAM1b,UAAUkU,YAAc,WACrB,OAAA,KAAKhD,OAASkK,EAAUhX,qBAGjCsX,EAAM1b,UAAUic,eAAiB,WACxB,OAAA,KAAK/K,OAASkK,EAAU/W,yBAIjCqX,EAAM1b,UAAUkc,SAChBR,EAAM1b,UAAUmc,OAChBT,EAAM1b,UAAUoc,kBAChBV,EAAM1b,UAAUqc,cAChB,WACS,OAAA,GAGTte,OAAOC,QAAU0d;;;AC61EjB,IAAA,EAAA,QAAA,UAAA,OAAA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GA/4EA,IAAIrL,EAAO5O,QAAQ,cACfO,EAAYqO,EAAKrO,UACjBqS,EAAUhE,EAAKgE,QACfxS,EAAWwO,EAAKxO,SAChBya,EAAiBjM,EAAKkM,WACtBC,EAAanM,EAAKnO,OAClBua,EAAShb,QAAQ,gBAEjB2Z,EAAY3Z,QAAQ,mBACpB0C,EAAiBiX,EAAUjX,eAC3BC,EAAsBgX,EAAUhX,oBAChCC,EAA0B+W,EAAU/W,wBACpCC,EAAiB8W,EAAU9W,eAE3BG,EAAmC2W,EAAU3W,iCAE7CK,EAAsBsW,EAAUtW,oBAChCS,EAAgB6V,EAAU7V,cAC1BZ,EAAcyW,EAAUzW,YAExBvB,EAASgY,EAAUhY,OACnBC,EAAU+X,EAAU/X,QACpBC,EAAW8X,EAAU9X,SACrBC,EAAc6X,EAAU7X,YACxBE,EAAW2X,EAAU3X,SACrB0B,EAAUiW,EAAUjW,QAEpBzB,EAAe0X,EAAU1X,aACzBC,EAAgByX,EAAUzX,cAC1BsB,EAAamW,EAAUnW,WACvBD,EAAaoW,EAAUpW,WAEvB0X,EAAWjb,QAAQ,kBACnB+L,EAAS/L,QAAQ,gBACjBkb,EAAiBlb,QAAQ,yBACzBoZ,EAAsBpZ,QAAQ,+BAC9B4Z,EAAY5Z,QAAQ,oBACpB2Y,EAAO3Y,QAAQ,cACfia,EAAQja,QAAQ,eAMpB,SAASmb,EAAkB5B,EAASlZ,EAAMoZ,EAAM2B,EAAOzT,GAEjDmR,IAAAA,EAAQS,EAAQT,MACjBA,EAAMuC,SAAS9X,WACT6X,EAAMvC,MAEZC,EAAMuC,SAAS7X,WACT4X,EAAMxK,MAIX0K,IAAAA,GAAS,EAkBJC,SAAAA,EAAStT,GAGhBsR,EAAQiC,QAAQld,KAAK,CAAEyJ,MAAO,SAAU1H,KAAMA,IAC9CsH,EAASM,GArBRmT,EAAMvC,QACPY,EAAKZ,MAAQuC,EAAMvC,MAEnBY,EAAK/I,MAAQ0K,EAAMvC,MACnByC,GAAS,GAERF,EAAM1K,QAGP+I,EAAK/I,MAAQ0K,EAAM1K,MACnB4K,GAAS,GAERF,EAAMxK,QACP6I,EAAK7I,MAAQwK,EAAMxK,MACnB0K,GAAS,GAURA,EACD/B,EAAQvQ,UAAUyQ,EAAKtC,GAAIsC,EAAM8B,GAEjCA,IASJ,SAASE,EAAUlC,EAASlZ,EAAMoP,EAAM9H,GACnC8H,GAAAA,IAAS9M,GAAuB8M,IAAS/M,EACnCiF,OAAAA,EAAS,IAAIoE,EAAOiB,OAAO,mCAAoC3M,IAGxEA,EAAOE,EAAUF,GAEbZ,IAEAic,EACAC,EACAlC,EAJAha,EAAOW,EAASC,GAChBub,EAAahJ,EAAQvS,GAkBhBmZ,SAAAA,EAAqBvR,EAAOK,IAC/BL,GAASK,EACXX,EAAS,IAAIoE,EAAO8P,OAAO,2BAA4Bxb,KAC/C4H,GAAWA,aAAiB8D,EAAO+P,OAG3CvC,EAAQ/Q,UAAUkT,EAAWnP,KAAMwP,GAFnCpU,EAASM,GAOJ8T,SAAAA,EAAY9T,EAAOK,GACvBL,EACDN,EAASM,IAET0T,EAAiBrT,EACjBqQ,EAAKxY,OAAO,CACVkB,KAAMkY,EAAQlY,KACdoO,KAAMA,GACL,SAASxH,EAAOK,GACdL,EACDN,EAASM,KAGXwR,EAAOnR,GACF0Q,QAAU,EACfO,EAAQvQ,UAAUyQ,EAAKtC,GAAIsC,EAAMuC,OAM9BC,SAAAA,EAAYhU,GAChBA,GAAAA,EACDN,EAASM,OACJ,CACDuI,IAAAA,EAAMC,KAAKD,MACf2K,EAAkB5B,EAASqC,EAAYnC,EAAM,CAAE7I,MAAOJ,EAAKqI,MAAOrI,GAAO7I,IAKpEqU,SAAAA,EAAwB/T,GAC5BA,EACDN,EAASM,IAET0T,EAAelc,GAAQ,IAAIyb,EAAezB,EAAKtC,GAAI1H,GACnD8J,EAAQvQ,UAAU0S,EAAWnP,KAAMoP,EAAgBM,IAKvDC,EAAU3C,EAASqC,EAhEVO,SAAsBlU,EAAOmU,GACjCnU,EACDN,EAASM,GACDmU,EAAoB3M,OAAS9M,EACrCgF,EAAS,IAAIoE,EAAOyD,QAAQ,oDAAqDnP,KAEjFqb,EAAaU,EACbF,EAAU3C,EAASlZ,EAAMmZ,MAiE/B,SAAS0C,EAAU3C,EAASlZ,EAAMsH,GAE7B,KADHtH,EAAOE,EAAUF,IAERsH,OAAAA,EAAS,IAAIoE,EAAO+P,OAAO,4BAEhCrc,IAAAA,EAAOW,EAASC,GAChBub,EAAahJ,EAAQvS,GACrBgc,EAAgB,EAEXC,SAAAA,EAAyBrU,EAAOsU,GACpCtU,GAAAA,EACMN,OAAAA,EAASM,GAIZuU,IAAAA,EAAY,IAAI5C,EAAU2C,GAE5BC,GAAaA,EAAU/M,OAAS5M,GAAmB2Z,EAAU3C,MAG/DN,EAAQ/Q,UAAUgU,EAAU3C,MAAO4C,GAFnC9U,EAAS,IAAIoE,EAAO2Q,kBAMfD,SAAAA,EAA0BxU,EAAO0U,GACrC1U,EACDN,EAASM,GACA0U,EAGThE,EAAKxY,OAAOwc,EAAmBhV,GAF/BA,EAAS,IAAIoE,EAAO+P,QAQfc,SAAAA,EAA2B3U,EAAOmU,GACtCnU,EACDN,EAASM,GACDmU,EAAoB3M,OAAS9M,GAAwByZ,EAAoB7P,KAGjFgN,EAAQ/Q,UAAU4T,EAAoB7P,KAAMsQ,GAF5ClV,EAAS,IAAIoE,EAAOyD,QAAQ,oDAAqDnP,IAQ5Ewc,SAAAA,EAAoC5U,EAAO6U,GAC/C7U,GAAAA,EACDN,EAASM,QAEN,GAAC6U,EAAoB7O,eAAexO,GAEhC,CACDsd,IAAAA,EAASD,EAAoBrd,GAAM0X,GACvCoC,EAAQ/Q,UAAUuU,EAAQhB,QAH1BpU,EAAS,IAAIoE,EAAO+P,OAAO,KAAMzb,IAQ9B0b,SAAAA,EAAY9T,EAAOsE,GACvBtE,GAAAA,EACMN,OAAAA,EAASM,GAElB0Q,EAAKxY,OAAOoM,EAAMyQ,GAGXA,SAAAA,EAAiB/U,EAAOwR,GAiBxBwD,IAAqB1Q,EAhBzBtE,EACDN,EAASM,GAENwR,EAAKhK,OAAS7M,IACfyZ,EACmBnZ,EACjByE,EAAS,IAAIoE,EAAOmR,MAAM,KAAM7c,KAUVkM,EARDkN,EAAKlN,KAShCA,EAAOhM,EAAUgM,GACjBqP,EAAahJ,EAAQrG,GACrB9M,EAAOW,EAASmM,GACblJ,IAAwB5D,EACzB8Z,EAAQ/Q,UAAU1E,EAAewY,GAEjCJ,EAAU3C,EAASqC,EAAYgB,IAZ7BjV,EAAS,KAAM8R,GAgBlBpW,IAAwB5D,EACzB8Z,EAAQ/Q,UAAU1E,EAAewY,GAEjCJ,EAAU3C,EAASqC,EAAYgB,GAQnC,SAASO,EAAwB5D,EAASlZ,EAAMoZ,EAAMha,EAAMqJ,EAAOsU,EAAMzV,GASnEoR,IAAAA,EAASU,EAAKV,OAEdqE,IAASnb,GAAgB8W,EAAO9K,eAAexO,GACjDkI,EAAS,IAAIoE,EAAO8P,OAAO,2BAA4Bxb,IAEhD+c,IAASlb,GAAkB6W,EAAO9K,eAAexO,IAIxDsZ,EAAOtZ,GAAQqJ,EACfyQ,EAAQvQ,UAAUyQ,EAAKtC,GAAIsC,EAlBpBwC,SAAYhU,GAChBA,EACDN,EAASM,GAETkT,EAAkB5B,EAASlZ,EAAMoZ,EAAM,CAAEZ,MAAOpI,KAAKD,OAAS7I,MAUhEA,EAAS,IAAIoE,EAAOsR,QAAQ,KAAMhd,IAetC,SAASid,EAAsB/D,EAAS5R,GAClC6U,IAAAA,EACAe,EACAC,EAoBKC,SAAAA,EAAqBxV,GACzBA,EACDN,EAASM,GAET0Q,EAAKxY,OAAO,CACVkB,KAAMkY,EAAQlY,KACd8V,GAAIqF,EAAU3C,MACdpK,KAAM9M,GACL,SAASsF,EAAOK,GACdL,EACDN,EAASM,KAGXsV,EAAgBjV,GACF0Q,QAAU,EACxBO,EAAQvQ,UAAUuU,EAAcpG,GAAIoG,EAAeG,MAKhDA,SAAAA,EAAqBzV,GACzBA,EACDN,EAASM,IAETuV,EAAgB,GAChBjE,EAAQvQ,UAAUuU,EAAchR,KAAMiR,EAAe7V,IAIzD4R,EAAQ/Q,UAAU1E,EA/CT6Z,SAAkB1V,EAAO2V,IAC5B3V,GAAS2V,EAEXjW,KACQM,GAAWA,aAAiB8D,EAAO+P,OAG3ClC,EAAUzZ,OAAO,CAACkB,KAAMkY,EAAQlY,MAAO,SAAS4G,EAAOK,GAClDL,EACDN,EAASM,IAGXuU,EAAYlU,EACZiR,EAAQvQ,UAAUwT,EAAUrF,GAAIqF,EAAWiB,MAR7C9V,EAASM,KAgDf,SAAS4V,EAAetE,EAASlZ,EAAMsH,GACrCtH,EAAOE,EAAUF,GACbZ,IAGA8d,EACAC,EACApB,EACAU,EANArd,EAAOW,EAASC,GAChBub,EAAahJ,EAAQvS,GAiBhBuc,SAAAA,EAA2B3U,EAAOK,GACtCL,EACDN,EAASM,IAETmU,EAAsB9T,EACtBiR,EAAQ/Q,UAAU4T,EAAoB7P,KAAMkR,IAIvCA,SAAAA,EAAqBxV,EAAOK,GAChCL,EACDN,EAASM,IAET6U,EAAsBxU,EACtBqQ,EAAKxY,OAAO,CACVkB,KAAMkY,EAAQlY,KACdoO,KAAM9M,GACL,SAASsF,EAAOK,GACdL,EACDN,EAASM,KAGXsV,EAAgBjV,GACF0Q,QAAU,EACxBO,EAAQvQ,UAAUuU,EAAcpG,GAAIoG,EAAeG,OAKhDA,SAAAA,EAAqBzV,GACzBA,EACDN,EAASM,IAETuV,EAAgB,GAChBjE,EAAQvQ,UAAUuU,EAAchR,KAAMiR,EAAeM,IAIhD7B,SAAAA,EAAYhU,GAChBA,GAAAA,EACDN,EAASM,OACJ,CACDuI,IAAAA,EAAMC,KAAKD,MACf2K,EAAkB5B,EAASqC,EAAYQ,EAAqB,CAAExL,MAAOJ,EAAKqI,MAAOrI,GAAO7I,IAInFmW,SAAAA,EAA6B7V,GACjCA,EACDN,EAASM,IAET6U,EAAoBrd,GAAQ,IAAIyb,EAAeqC,EAAcpG,GAAIxU,GACjE4W,EAAQvQ,UAAUoT,EAAoB7P,KAAMuQ,EAAqBb,IAIrEC,EAAU3C,EAASlZ,EAlEV0d,SAA0B9V,EAAOK,IACpCL,GAASK,EACXX,EAAS,IAAIoE,EAAO8P,OAAO,KAAMxb,KACzB4H,GAAWA,aAAiB8D,EAAO+P,OAG3CI,EAAU3C,EAASqC,EAAYgB,GAF/BjV,EAASM,KAiEf,SAAS+V,EAAYzE,EAASlZ,EAAMgH,EAAMM,GAExCuU,EAAU3C,EADVlZ,EAAOE,EAAUF,GACQ,SAAU6H,EAAKuR,GAClCvR,OAAAA,EACKP,EAASO,GAEfb,IAASsS,EAAUnT,KACbmB,EAAS,QAEZN,EAAOsS,EAAUhT,OAAU8S,EAAKpS,MAAQsS,EAAUrV,YAAYyB,QAAU4T,EAAUrV,YAAY6B,QAAUwT,EAAUrV,YAAYiC,SAC3HoB,EAAS,WAElBA,EAAS,IAAIoE,EAAOkS,OAAO,oBAAoB5d,MAOnD,SAAS6d,EAAiB3E,EAASlZ,EAAMsH,GACvCtH,EAAOE,EAAUF,GACbZ,IAGA8d,EACAC,EACApB,EACAU,EANArd,EAAOW,EAASC,GAChBub,EAAahJ,EAAQvS,GAgBhBmZ,SAAAA,EAAqBvR,EAAOK,GAChCL,EACDN,EAASM,GACD5E,IAAwB5D,EAChCkI,EAAS,IAAIoE,EAAOoS,MAAM,KAAM9d,IACvBiI,EAAO2F,eAAexO,IAI/B8d,GADAT,EAAsBxU,GACc7I,GAAM0X,GAC1CoC,EAAQ/Q,UAAU+U,EAAea,IAJjCzW,EAAS,IAAIoE,EAAO+P,OAAO,KAAMzb,IAQ5B+d,SAAAA,EAA2BnW,EAAOK,GACtCL,EACDN,EAASM,GACDK,EAAOmH,OAAS9M,EACxBgF,EAAS,IAAIoE,EAAOyD,QAAQ,KAAMnP,KAElCkd,EAAgBjV,EAChBiR,EAAQ/Q,UAAU+U,EAAchR,KAAM8R,IAIjCA,SAAAA,EAA4BpW,EAAOK,GACvCL,EACDN,EAASM,IAETuV,EAAgBlV,EACbpI,OAAOmO,KAAKmP,GAAehgB,OAAS,EACrCmK,EAAS,IAAIoE,EAAOmG,UAAU,KAAM7R,YAiBjCyc,EAAoBrd,GAC3B8Z,EAAQvQ,UAAUoT,EAAoB7P,KAAMuQ,EAAqBb,KAX1DA,SAAAA,EAAYhU,GAChBA,GAAAA,EACDN,EAASM,OACJ,CACDuI,IAAAA,EAAMC,KAAKD,MACf2K,EAAkB5B,EAASqC,EAAYQ,EAAqB,CAAExL,MAAOJ,EAAKqI,MAAOrI,GAAO8N,IASnFA,SAAAA,EAAsBrW,GAC1BA,EACDN,EAASM,GAETsR,EAAQlQ,OAAOkU,EAAcpG,GAAIoH,GAI5BA,SAAAA,EAAsBtW,GAC1BA,EACDN,EAASM,GAETsR,EAAQlQ,OAAOkU,EAAchR,KAAM5E,GAIvCuU,EAAU3C,EAASqC,EA7EVgB,SAA2B3U,EAAOK,GACtCL,EACDN,EAASM,IAETmU,EAAsB9T,EACtBiR,EAAQ/Q,UAAU4T,EAAoB7P,KAAMiN,MA2ElD,SAASgF,EAAUjF,EAASlZ,EAAMyY,EAAOzR,EAAMM,GACzB,mBAATN,IACTM,EAAWN,EACXA,EAAO,MAEThH,EAAOE,EAAUF,GACbZ,IAGA8d,EACAC,EACAiB,EACAvE,EACAwE,EAPAjf,EAAOW,EAASC,GAChBub,EAAahJ,EAAQvS,GAQrBgc,EAAgB,EAYXsC,SAAAA,EAAoB1W,EAAOK,GAC/BL,EACDN,EAASM,GACDK,EAAOmH,OAAS9M,EACxBgF,EAAS,IAAIoE,EAAO+P,OAAO,KAAMzb,KAEjCkd,EAAgBjV,EAChBiR,EAAQ/Q,UAAU+U,EAAchR,KAAMqS,IAIjCA,SAAAA,EAAqB3W,EAAOK,GAChCL,EACDN,EAASM,IAETuV,EAAgBlV,GACC2F,eAAexO,GAC3BqZ,EAAMuC,SAASvZ,GAChB6F,EAAS,IAAIoE,EAAO+P,OAAO,8DAA+Dzb,KAE1Foe,EAAiBjB,EAAc/d,IACbgQ,OAAS9M,GAAuBmW,EAAMuC,SAASzZ,GAC/D+F,EAAS,IAAIoE,EAAO8S,OAAO,mDAAoDxe,IAE/EkZ,EAAQ/Q,UAAUiW,EAAetH,GAAI2H,GAIrChG,EAAMuC,SAASxZ,GAmDvB8W,EAAKxY,OAAO,CACVkB,KAAMkY,EAAQlY,KACdoO,KAAM/M,GACL,SAASuF,EAAOK,GACdL,EACDN,EAASM,KAGXiS,EAAW5R,GACF0Q,QAAU,EAChB3R,IACD6S,EAAS7S,KAAOA,GAElBkS,EAAQvQ,UAAUkR,EAAS/C,GAAI+C,EAAU6E,MA/DrCpX,EAAS,IAAIoE,EAAO+P,OAAO,wDAAyDzb,IAQnFye,SAAAA,EAAuB7W,EAAOK,GAClCL,GAAAA,EACDN,EAASM,OACJ,CACDwR,IAAAA,EAAOnR,EACRmR,EAAKhK,OAAS7M,IACfyZ,EACmBnZ,EACjByE,EAAS,IAAIoE,EAAOmR,MAAM,KAAM7c,IAU/B4c,SAAqB1Q,GAC5BA,EAAOhM,EAAUgM,GACjBqP,EAAahJ,EAAQrG,GACrB9M,EAAOW,EAASmM,GACblJ,IAAwB5D,IACtBqZ,EAAMuC,SAASzZ,GAChB+F,EAAS,IAAIoE,EAAO8S,OAAO,mDAAoDxe,IAE/E6b,EAAU3C,EAASlZ,EAAM2e,IAG7B9C,EAAU3C,EAASqC,EAAY+C,GAnBzB1B,CAAqBxD,EAAKlN,MAG5ByS,OAAcC,EAAWxF,IAmBtBuF,SAAAA,EAAc/W,EAAOK,GACzBL,EACDN,EAASM,GAGTN,EAAS,KADTuS,EAAW5R,GAuBNyW,SAAAA,EAAgB9W,GACpBA,EACDN,EAASM,IAETyW,EAAW/V,EAAOuW,MAAM,GACxB3F,EAAQtQ,UAAUiR,EAAS3N,KAAMmS,EAAUS,IAItClD,SAAAA,EAAYhU,GAChBA,GAAAA,EACDN,EAASM,OACJ,CACDuI,IAAAA,EAAMC,KAAKD,MACf2K,EAAkB5B,EAASqC,EAAY2B,EAAe,CAAE3M,MAAOJ,EAAKqI,MAAOrI,GAAO4O,IAI7ED,SAAAA,EAAsBlX,GAC1BA,EACDN,EAASM,IAETuV,EAAc/d,GAAQ,IAAIyb,EAAehB,EAAS/C,GAAIzU,GACtD6W,EAAQvQ,UAAUuU,EAAchR,KAAMiR,EAAevB,IAIhDmD,SAAAA,EAAqBnX,GACzBA,EACDN,EAASM,GAETN,EAAS,KAAMuS,GAzIhB7W,IAAwB5D,EACtBqZ,EAAMuC,SAASzZ,GAChB+F,EAAS,IAAIoE,EAAO8S,OAAO,mDAAoDxe,IAE/E6b,EAAU3C,EAASlZ,EAAM2e,GAG3B9C,EAAU3C,EAASqC,EAAY+C,GAuInC,SAASU,EAAa9F,EAAS+F,EAAKlW,EAAQmW,EAAQ/hB,EAAQmK,GACtDuS,IAAAA,EAEKsF,SAAAA,EAAcvX,GAClBA,EACDN,EAASM,GAETN,EAAS,KAAMnK,GAIVye,SAAAA,EAAYhU,GAChBA,GAAAA,EACDN,EAASM,OACJ,CACDuI,IAAAA,EAAMC,KAAKD,MACf2K,EAAkB5B,EAAS+F,EAAIjf,KAAM6Z,EAAU,CAAEtJ,MAAOJ,EAAKqI,MAAOrI,GAAOgP,IAItEC,SAAAA,EAAiBxX,GACrBA,EACDN,EAASM,GAETsR,EAAQvQ,UAAUkR,EAAS/C,GAAI+C,EAAU+B,GAqB7C1C,EAAQ/Q,UAAU8W,EAAInI,GAjBb4H,SAAgB9W,EAAOK,GAC3BL,GAAAA,EACDN,EAASM,OACJ,CACLiS,EAAW5R,EAEPoX,IAAAA,EAAU/W,EAAOuW,MAAM1hB,GAC3B4L,EAAOuW,KAAKD,EAAS,EAAGH,EAAQA,EAAS/hB,GACzC8hB,EAAIjG,SAAW7b,EAEf0c,EAAStB,KAAOpb,EAChB0c,EAASrb,SAAW,EAEpB0a,EAAQtQ,UAAUiR,EAAS3N,KAAMmT,EAASD,MAOhD,SAASG,EAAWrG,EAAS+F,EAAKlW,EAAQmW,EAAQ/hB,EAAQ6b,EAAU1R,GAC9DuS,IAAAA,EACAwE,EAEKc,SAAAA,EAAcvX,GAClBA,EACDN,EAASM,GAETN,EAAS,KAAMnK,GAIVye,SAAAA,EAAYhU,GAChBA,GAAAA,EACDN,EAASM,OACJ,CACDuI,IAAAA,EAAMC,KAAKD,MACf2K,EAAkB5B,EAAS+F,EAAIjf,KAAM6Z,EAAU,CAAEtJ,MAAOJ,EAAKqI,MAAOrI,GAAOgP,IAItEC,SAAAA,EAAiBxX,GACrBA,EACDN,EAASM,GAETsR,EAAQvQ,UAAUkR,EAAS/C,GAAI+C,EAAU+B,GAIpC4D,SAAAA,EAAiB5X,EAAOK,GAC5BL,GAAAA,EACDN,EAASM,OACJ,CAEF,KADHyW,EAAWpW,GAEFX,OAAAA,EAAS,IAAIoE,EAAO+T,IAAI,oBAE7BC,IAAAA,EAAed,MAAc5F,EAAkCA,EAAWiG,EAAIjG,SAC9E2G,EAAU/e,KAAKgf,IAAIvB,EAASlhB,OAAQuiB,EAAYviB,GAChDkiB,EAAU/W,EAAOuW,MAAMc,GACxBtB,GACDA,EAASiB,KAAKD,GAEhBtW,EAAOuW,KAAKD,EAASK,EAAWR,EAAQA,EAAS/hB,QAC9CyhB,IAAc5F,IACfiG,EAAIjG,UAAY7b,GAGlB0c,EAAStB,KAAOoH,EAChB9F,EAASrb,SAAW,EAEpB0a,EAAQtQ,UAAUiR,EAAS3N,KAAMmT,EAASD,IAa9ClG,EAAQ/Q,UAAU8W,EAAInI,GATb+I,SAAejY,EAAOK,GAC1BL,EACDN,EAASM,IAETiS,EAAW5R,EACXiR,EAAQ9Q,UAAUyR,EAAS3N,KAAMsT,MAOvC,SAASM,EAAU5G,EAAS+F,EAAKlW,EAAQmW,EAAQ/hB,EAAQ6b,EAAU1R,GAC7DuS,IAAAA,EACAwE,EAEK0B,SAAAA,EAAiBnY,EAAOK,GAC5BL,GAAAA,EACDN,EAASM,OACJ,CAEF,KADHyW,EAAWpW,GAEFX,OAAAA,EAAS,IAAIoE,EAAO+T,IAAI,oBAE7BC,IAAAA,EAAed,MAAc5F,EAAkCA,EAAWiG,EAAIjG,SAClF7b,EAAUuiB,EAAYviB,EAAS4L,EAAO5L,OAAUA,EAASuiB,EAAYviB,EACrEkhB,EAASiB,KAAKvW,EAAQmW,EAAQQ,EAAWA,EAAYviB,QAClDyhB,IAAc5F,IACfiG,EAAIjG,UAAY7b,GAElBmK,EAAS,KAAMnK,IAenB+b,EAAQ/Q,UAAU8W,EAAInI,GAXb+I,SAAejY,EAAOK,GAC1BL,EACDN,EAASM,GACDK,EAAOmH,OAAS9M,EACxBgF,EAAS,IAAIoE,EAAO8S,OAAO,gCAAiCS,EAAIjf,QAEhE6Z,EAAW5R,EACXiR,EAAQ9Q,UAAUyR,EAAS3N,KAAM6T,MAOvC,SAASC,EAAU9G,EAASlZ,EAAMsH,GAEhCuU,EAAU3C,EADVlZ,EAAOE,EAAUF,GACQsH,GAG3B,SAAS2Y,EAAW/G,EAAS+F,EAAK3X,GAChC2X,EAAIhG,QAAQC,EAAS5R,GAGvB,SAAS4Y,EAAWhH,EAASlZ,EAAMsH,GACjCtH,EAAOE,EAAUF,GACbZ,IAGA8d,EACAC,EAJA/d,EAAOW,EAASC,GAChBub,EAAahJ,EAAQvS,GAoBhBue,SAAAA,EAAqB3W,EAAOK,GAChCL,EACDN,EAASM,IAETuV,EAAgBlV,GACE2F,eAAexO,GAG/B8Z,EAAQ/Q,UAAUgV,EAAc/d,GAAM0X,GAAIxP,GAF1CA,EAAS,IAAIoE,EAAO+P,OAAO,yDAA0Dzb,IArBxFgD,IAAwB5D,EACzByc,EAAU3C,EAASlZ,EAAMsH,GAEzBuU,EAAU3C,EAASqC,EAGZ+C,SAAoB1W,EAAOK,GAC/BL,EACDN,EAASM,IAETsV,EAAgBjV,EAChBiR,EAAQ/Q,UAAU+U,EAAchR,KAAMqS,MAkB5C,SAAS4B,EAAUjH,EAASkH,EAASC,EAAS/Y,GAC5C8Y,EAAUlgB,EAAUkgB,GAChBE,IAAAA,EAAUvgB,EAASqgB,GACnBG,EAAgBhO,EAAQ6N,GAE5BC,EAAUngB,EAAUmgB,GAChBG,IAIAC,EACAC,EACAC,EACAC,EACAC,EACAhH,EATA2G,EAAUzgB,EAASsgB,GACnBS,EAAgBvO,EAAQ8N,GACxB7H,EAAQpI,KAAKD,MASRyL,SAAAA,EAAYhU,GAChBA,EACDN,EAASM,GAETkT,EAAkB5B,EAASmH,EAASxG,EAAU,CAAErB,MAAOA,GAASlR,GAI3D8X,SAAAA,EAAiBxX,EAAOK,GAC5BL,EACDN,EAASM,KAETiS,EAAW5R,GACF0Q,QAAU,EACnBO,EAAQvQ,UAAUkR,EAAS/C,GAAI+C,EAAU+B,IAIpCmF,SAAAA,EAAenZ,GACnBA,EACDN,EAASM,GAETsR,EAAQ/Q,UAAU0Y,EAAYzB,GAIzB4B,SAAAA,EAAyBpZ,EAAOK,GACpCL,EACDN,EAASM,IAETgZ,EAAmB3Y,GACC2F,eAAe4S,GACjClZ,EAAS,IAAIoE,EAAO8P,OAAO,uCAAwCgF,KAEnEI,EAAiBJ,GAAWE,EAAiBJ,GAC7CO,EAAaD,EAAiBJ,GAAS1J,GACvCoC,EAAQvQ,UAAUgY,EAAiBzU,KAAM0U,EAAkBG,IAKxDE,SAAAA,EAAwBrZ,EAAOK,GACnCL,EACDN,EAASM,IAET+Y,EAAmB1Y,EACnBiR,EAAQ/Q,UAAUwY,EAAiBzU,KAAM8U,IAIpCE,SAAAA,EAAyBtZ,EAAOK,GACpCL,EACDN,EAASM,IAET8Y,EAAmBzY,GACE2F,eAAe0S,GAE1BI,EAAiBJ,GAASlR,OAAS9M,EAC3CgF,EAAS,IAAIoE,EAAOyV,MAAM,kCAE1BtF,EAAU3C,EAAS4H,EAAeG,GAJlC3Z,EAAS,IAAIoE,EAAO+P,OAAO,mDAAoD6E,IAkBrFzE,EAAU3C,EAASqH,EATVa,SAAwBxZ,EAAOK,GACnCL,EACDN,EAASM,IAET6Y,EAAmBxY,EACnBiR,EAAQ/Q,UAAUsY,EAAiBvU,KAAMgV,MAO/C,SAASG,EAAYnI,EAASlZ,EAAMsH,GAClCtH,EAAOE,EAAUF,GACbZ,IAGA8d,EACAC,EACAtD,EALAza,EAAOW,EAASC,GAChBub,EAAahJ,EAAQvS,GAMhB8e,SAAAA,EAAsBlX,GAC1BA,EACDN,EAASM,WAEFuV,EAAc/d,GACrB8Z,EAAQvQ,UAAUuU,EAAchR,KAAMiR,EAAe,SAASvV,GACzDA,GAAAA,EACDN,EAASM,OACJ,CACDuI,IAAAA,EAAMC,KAAKD,MACf2K,EAAkB5B,EAASqC,EAAY2B,EAAe,CAAE3M,MAAOJ,EAAKqI,MAAOrI,GAAO7I,OAMjFga,SAAAA,EAAiB1Z,GACrBA,EACDN,EAASM,GAETsR,EAAQlQ,OAAO6Q,EAAS3N,KAAM4S,GAwBzBf,SAAAA,EAA2BnW,EAAOK,GACtCL,EACDN,EAASM,GACDK,EAAOmH,OAAS9M,EACxBgF,EAAS,IAAIoE,EAAOyV,MAAM,sCAAuC/hB,IAxB5DggB,SAAiBxX,EAAOK,GAC5BL,EACDN,EAASM,KAETiS,EAAW5R,GACF0Q,QAAU,EAChBkB,EAASlB,OAAS,EACnBO,EAAQlQ,OAAO6Q,EAAS/C,GAAIwK,GAE5BpI,EAAQvQ,UAAUkR,EAAS/C,GAAI+C,EAAU,SAASjS,GAC7CA,EACDN,EAASM,GAETkT,EAAkB5B,EAASlZ,EAAM6Z,EAAU,CAAErB,MAAOpI,KAAKD,OAAS2O,MAaxEM,CAAiB,KAAMnX,GAIlBsW,SAAAA,EAAqB3W,EAAOK,GAChCL,EACDN,EAASM,IAETuV,EAAgBlV,GACE2F,eAAexO,GAG/B8Z,EAAQ/Q,UAAUgV,EAAc/d,GAAM0X,GAAIiH,GAF1CzW,EAAS,IAAIoE,EAAO+P,OAAO,yDAA0Drc,IAgB3Fyc,EAAU3C,EAASqC,EATV+C,SAAoB1W,EAAOK,GAC/BL,EACDN,EAASM,IAETsV,EAAgBjV,EAChBiR,EAAQ/Q,UAAU+U,EAAchR,KAAMqS,MAO5C,SAASgD,EAAerI,EAASlZ,EAAMsH,GAGjC4V,IAAAA,EACAC,EAEKqE,SAAAA,EAAsB5Z,EAAOK,GACjCL,GAAAA,EACDN,EAASM,OACJ,CACLuV,EAAgBlV,EACZyI,IAAAA,EAAQ7Q,OAAOmO,KAAKmP,GACxB7V,EAAS,KAAMoJ,IAXnB1Q,EAAOE,EAAUF,GA0BjB6b,EAAU3C,EAASlZ,EAXVse,SAAoB1W,EAAOK,GAC/BL,EACDN,EAASM,GACDK,EAAOmH,OAAS9M,EACxBgF,EAAS,IAAIoE,EAAOyD,QAAQ,KAAMnP,KAElCkd,EAAgBjV,EAChBiR,EAAQ/Q,UAAU+U,EAAchR,KAAMsV,MAO5C,SAASC,EAAmBvI,EAASwI,EAASC,EAASra,GACrDqa,EAAUzhB,EAAUyhB,GAChBviB,IAGA8d,EACAC,EACAtD,EALAza,EAAOW,EAAS4hB,GAChBpG,EAAahJ,EAAQoP,GAqBhBpD,SAAAA,EAAqB3W,EAAOK,GAChCL,EACDN,EAASM,IAETuV,EAAgBlV,GACC2F,eAAexO,GAC9BkI,EAAS,IAAIoE,EAAO8P,OAAO,KAAMpc,IAQrCkZ,EAAKxY,OAAO,CACVkB,KAAMkY,EAAQlY,KACdoO,KAAM7M,GACL,SAASqF,EAAOK,GACdL,EACDN,EAASM,KAGXiS,EAAW5R,GACF0Q,QAAU,EAIf6B,EAAekH,KACjB7H,EAAS+H,gBAAkBF,EAC3BA,EAAUnT,EAAKS,QAAQuM,EAAYmG,IAGrC7H,EAAStB,KAAOmJ,EAAQvkB,OACxB0c,EAAS3N,KAAOwV,EAEhBxI,EAAQvQ,UAAUkR,EAAS/C,GAAI+C,EAAUiF,MAIpClD,SAAAA,EAAYhU,GAChBA,GAAAA,EACDN,EAASM,OACJ,CACDuI,IAAAA,EAAMC,KAAKD,MACf2K,EAAkB5B,EAASqC,EAAY2B,EAAe,CAAE3M,MAAOJ,EAAKqI,MAAOrI,GAAO7I,IAI7EwX,SAAAA,EAAsBlX,GAC1BA,EACDN,EAASM,IAETuV,EAAc/d,GAAQ,IAAIyb,EAAehB,EAAS/C,GAAIvU,GACtD2W,EAAQvQ,UAAUuU,EAAchR,KAAMiR,EAAevB,IApEtD5Y,IAAwB5D,EACzBkI,EAAS,IAAIoE,EAAO8P,OAAO,KAAMpc,IAEjCyc,EAAU3C,EAASqC,EAGZ+C,SAAoB1W,EAAOK,GAC/BL,EACDN,EAASM,IAETsV,EAAgBjV,EAChBiR,EAAQ/Q,UAAU+U,EAAchR,KAAMqS,MA8D5C,SAASsD,GAAU3I,EAASlZ,EAAMsH,GAChCtH,EAAOE,EAAUF,GACbZ,IAGA8d,EACAC,EAJA/d,EAAOW,EAASC,GAChBub,EAAahJ,EAAQvS,GAgBhBue,SAAAA,EAAqB3W,EAAOK,GAChCL,EACDN,EAASM,IAETuV,EAAgBlV,GACE2F,eAAexO,GAG/B8Z,EAAQ/Q,UAAUgV,EAAc/d,GAAM0X,GAAIgL,GAF1Cxa,EAAS,IAAIoE,EAAO+P,OAAO,yDAA0Drc,IAOlF0iB,SAAAA,EAAkBla,EAAOiS,GAC7BjS,GAAAA,EACDN,EAASM,QAENiS,GAAAA,EAASzK,OAAS7M,EACnB+E,EAAS,IAAIoE,EAAOiB,OAAO,2BAA4B3M,QAClD,CAGDkI,IAAAA,EAAS2R,EAAS+H,gBAAkB/H,EAAS+H,gBAAkB/H,EAAS3N,KAC5E5E,EAAS,KAAMY,IAlCrB2T,EAAU3C,EAASqC,EAEV+C,SAAoB1W,EAAOK,GAC/BL,EACDN,EAASM,IAETsV,EAAgBjV,EAChBiR,EAAQ/Q,UAAU+U,EAAchR,KAAMqS,MAiC5C,SAASwD,GAAc7I,EAASlZ,EAAM7C,EAAQmK,GAGxCuS,IAAAA,EAaKmI,SAAAA,EAAmBpa,EAAOyW,GAC7BzW,GAAAA,EACFN,EAASM,OACJ,CACF,IAACyW,EACK/W,OAAAA,EAAS,IAAIoE,EAAO+T,IAAI,oBAE7BvT,IAAAA,EAAO5D,EAAOuW,MAAM1hB,GACrBkhB,GACDA,EAASiB,KAAKpT,GAEhBgN,EAAQtQ,UAAUiR,EAAS3N,KAAMA,EAAMkT,IAIlCxD,SAAAA,EAAYhU,GAChBA,GAAAA,EACDN,EAASM,OACJ,CACDuI,IAAAA,EAAMC,KAAKD,MACf2K,EAAkB5B,EAASlZ,EAAM6Z,EAAU,CAAEtJ,MAAOJ,EAAKqI,MAAOrI,GAAO7I,IAIlE8X,SAAAA,EAAkBxX,GACtBA,EACDN,EAASM,IAETiS,EAAStB,KAAOpb,EAChB0c,EAASrb,SAAW,EACpB0a,EAAQvQ,UAAUkR,EAAS/C,GAAI+C,EAAU+B,IA7C7C5b,EAAOE,EAAUF,GAiDd7C,EAAS,EACVmK,EAAS,IAAIoE,EAAOiB,OAAO,8BAE3BkP,EAAU3C,EAASlZ,EAhDZ6f,SAAgBjY,EAAOwR,GAC1BxR,EACFN,EAASM,GACDwR,EAAKhK,OAAS9M,EACtBgF,EAAS,IAAIoE,EAAO8S,OAAO,KAAMxe,KAEjC6Z,EAAWT,EACXF,EAAQ9Q,UAAUyR,EAAS3N,KAAM8V,MA6CvC,SAASC,GAAe/I,EAAS+F,EAAK9hB,EAAQmK,GACxCuS,IAAAA,EAaKmI,SAAAA,EAAmBpa,EAAOyW,GAC7BzW,GAAAA,EACFN,EAASM,OACJ,CACDsE,IAAAA,EACD,IAACmS,EACK/W,OAAAA,EAAS,IAAIoE,EAAO+T,IAAI,oBAG/BvT,EADCmS,EACMA,EAAS9K,MAAM,EAAGpW,GAElBmL,EAAOuW,MAAM1hB,GAEtB+b,EAAQtQ,UAAUiR,EAAS3N,KAAMA,EAAMkT,IAIlCxD,SAAAA,EAAYhU,GAChBA,GAAAA,EACDN,EAASM,OACJ,CACDuI,IAAAA,EAAMC,KAAKD,MACf2K,EAAkB5B,EAAS+F,EAAIjf,KAAM6Z,EAAU,CAAEtJ,MAAOJ,EAAKqI,MAAOrI,GAAO7I,IAItE8X,SAAAA,EAAkBxX,GACtBA,EACDN,EAASM,IAETiS,EAAStB,KAAOpb,EAChB0c,EAASrb,SAAW,EACpB0a,EAAQvQ,UAAUkR,EAAS/C,GAAI+C,EAAU+B,IAI1Cze,EAAS,EACVmK,EAAS,IAAIoE,EAAOiB,OAAO,8BAE3BsS,EAAIhG,QAAQC,EAlDL2G,SAAgBjY,EAAOwR,GAC1BxR,EACFN,EAASM,GACDwR,EAAKhK,OAAS9M,EACtBgF,EAAS,IAAIoE,EAAO8S,SAEpB3E,EAAWT,EACXF,EAAQ9Q,UAAUyR,EAAS3N,KAAM8V,MA+CvC,SAASE,GAAYhJ,EAASlZ,EAAMqQ,EAAOE,EAAOjJ,GAChDtH,EAAOE,EAAUF,GAUI,iBAAVqQ,GAAuC,iBAAVE,EACtCjJ,EAAS,IAAIoE,EAAOiB,OAAO,iCAAkC3M,IAEtDqQ,EAAQ,GAAKE,EAAQ,EAC5BjJ,EAAS,IAAIoE,EAAOiB,OAAO,4CAA6C3M,IAGxE6b,EAAU3C,EAASlZ,EAfZmiB,SAAava,EAAOwR,GACvBxR,EACFN,EAASM,GAETkT,EAAkB5B,EAASlZ,EAAMoZ,EAAM,CAAE/I,MAAOA,EAAOmI,MAAOjI,EAAOA,MAAOA,GAASjJ,KAe3F,SAAS8a,GAAalJ,EAAS+F,EAAK5O,EAAOE,EAAOjJ,GAU3B,iBAAV+I,GAAuC,iBAAVE,EACtCjJ,EAAS,IAAIoE,EAAOiB,OAAO,qCAEpB0D,EAAQ,GAAKE,EAAQ,EAC5BjJ,EAAS,IAAIoE,EAAOiB,OAAO,8CAG3BsS,EAAIhG,QAAQC,EAfLiJ,SAAcva,EAAOwR,GACxBxR,EACFN,EAASM,GAETkT,EAAkB5B,EAAS+F,EAAIjf,KAAMoZ,EAAM,CAAE/I,MAAOA,EAAOmI,MAAOjI,EAAOA,MAAOA,GAASjJ,KAe/F,SAAS+a,GAAcnJ,EAASlZ,EAAMZ,EAAMqJ,EAAOsU,EAAMzV,GACvDtH,EAAOE,EAAUF,GASG,iBAATZ,EACTkI,EAAS,IAAIoE,EAAOiB,OAAO,kCAAmC3M,IAEtDZ,EAGQ,OAAT2d,GACAA,IAASnb,GAAgBmb,IAASlb,EACzCyF,EAAS,IAAIoE,EAAOiB,OAAO,4DAA6D3M,IAGxF6b,EAAU3C,EAASlZ,EAlBZsiB,SAAS1a,EAAOwR,GACpBxR,GAAAA,EACMN,OAAAA,EAASM,GAElBkV,EAAuB5D,EAASlZ,EAAMoZ,EAAMha,EAAMqJ,EAAOsU,EAAMzV,KAO/DA,EAAS,IAAIoE,EAAOiB,OAAO,2CAA4C3M,IAW3E,SAASuiB,GAAgBrJ,EAAS+F,EAAK7f,EAAMqJ,EAAOsU,EAAMzV,GAQpC,iBAATlI,EACTkI,EAAS,IAAIoE,EAAOiB,OAAO,oCAEnBvN,EAGQ,OAAT2d,GACAA,IAASnb,GAAgBmb,IAASlb,EACzCyF,EAAS,IAAIoE,EAAOiB,OAAO,8DAG3BsS,EAAIhG,QAAQC,EAlBLoJ,SAAS1a,EAAOwR,GACpBxR,GAAAA,EACMN,OAAAA,EAASM,GAElBkV,EAAuB5D,EAAS+F,EAAIjf,KAAMoZ,EAAMha,EAAMqJ,EAAOsU,EAAMzV,KAOnEA,EAAS,IAAIoE,EAAOiB,OAAO,6CAW/B,SAAS6V,GAAetJ,EAASlZ,EAAMZ,EAAMkI,GAC3CtH,EAAOE,EAAUF,GAiBG,iBAATZ,EACTkI,EAAS,IAAIoE,EAAOiB,OAAO,kCAAmC3M,IAEtDZ,EAIRyc,EAAU3C,EAASlZ,EAtBZyiB,SAAU7a,EAAOwR,GACrBxR,GAAAA,EACMN,OAAAA,EAASM,GAGd8Q,IAAAA,EAASU,EAAKV,OAEbA,EAAO9K,eAAexO,GAIzBkI,EAAS,KAAMoR,EAAOtZ,IAHtBkI,EAAS,IAAIoE,EAAOsR,QAAQ,KAAMhd,MAWpCsH,EAAS,IAAIoE,EAAOiB,OAAO,2CAA4C3M,IAO3E,SAAS0iB,GAAgBxJ,EAAS+F,EAAK7f,EAAMkI,GAiBvB,iBAATlI,EACTkI,EAAS,IAAIoE,EAAOiB,QAEZvN,EAIR6f,EAAIhG,QAAQC,EAtBLuJ,SAAW7a,EAAOwR,GACrBxR,GAAAA,EACKN,OAAAA,EAASM,GAGd8Q,IAAAA,EAASU,EAAKV,OAEbA,EAAO9K,eAAexO,GAIzBkI,EAAS,KAAMoR,EAAOtZ,IAHtBkI,EAAS,IAAIoE,EAAOsR,WAWtB1V,EAAS,IAAIoE,EAAOiB,OAAO,6CAO/B,SAASgW,GAAkBzJ,EAASlZ,EAAMZ,EAAMkI,GAC9CtH,EAAOE,EAAUF,GA0BG,iBAATZ,EACTkI,EAAS,IAAIoE,EAAOiB,OAAO,kCAAmC3M,IAEtDZ,EAIRyc,EAAU3C,EAASlZ,EA/BZ4iB,SAAchb,EAAOwR,GACxBxR,GAAAA,EACKN,OAAAA,EAASM,GAWd8Q,IAAAA,EAASU,EAAKV,OAEbA,EAAO9K,eAAexO,WAIlBsZ,EAAOtZ,GACd8Z,EAAQvQ,UAAUyQ,EAAKtC,GAAIsC,EAfpBwC,SAAYhU,GAChBA,EACDN,EAASM,GAETkT,EAAkB5B,EAASlZ,EAAMoZ,EAAM,CAAEZ,MAAOpI,KAAKD,OAAS7I,MAOhEA,EAAS,IAAIoE,EAAOsR,QAAQ,KAAMhd,MAYpCsH,EAAS,IAAIoE,EAAOiB,OAAO,2CAA4C3M,IAO3E,SAAS6iB,GAAmB3J,EAAS+F,EAAK7f,EAAMkI,GA0B1B,iBAATlI,EACTkI,EAAS,IAAIoE,EAAOiB,OAAO,oCAEnBvN,EAIR6f,EAAIhG,QAAQC,EA/BL0J,SAAchb,EAAOwR,GACxBxR,GAAAA,EACKN,OAAAA,EAASM,GAWd8Q,IAAAA,EAASU,EAAKV,OAEbA,EAAO9K,eAAexO,WAIlBsZ,EAAOtZ,GACd8Z,EAAQvQ,UAAUyQ,EAAKtC,GAAIsC,EAfpBwC,SAAYhU,GAChBA,EACDN,EAASM,GAETkT,EAAkB5B,EAAS+F,EAAIjf,KAAMoZ,EAAM,CAAEZ,MAAOpI,KAAKD,OAAS7I,MAOpEA,EAAS,IAAIoE,EAAOsR,WAYtB1V,EAAS,IAAIoE,EAAOiB,OAAO,6CAO/B,SAASmW,GAAerK,GACfpV,OAAAA,EAAQuK,eAAe6K,GAASpV,EAAQoV,GAAS,KAG1D,SAASsK,GAAsBnU,EAASoU,EAAKC,GAQpCrU,OAPHA,EAEyB,mBAAZA,EACfA,EAAU,CAAEsU,SAAUF,EAAKjG,KAAMkG,GACN,iBAAZrU,IACfA,EAAU,CAAEsU,SAAUtU,EAASmO,KAAMkG,IAJrCrU,EAAU,CAAEsU,SAAUF,EAAKjG,KAAMkG,GAM5BrU,EAGT,SAASuU,GAAUnjB,EAAMojB,EAAe9b,GAClCO,IAAAA,EAeDA,MAbyB,mBAAlBub,IACR9b,EAAW8b,EACXA,GAAgB,GAGdpjB,EAEM0a,EAAW1a,GACnB6H,EAAM,IAAI6D,EAAOiB,OAAO,4CAA6C3M,GAC5DojB,GAAkB5I,EAAexa,KAC1C6H,EAAM,IAAI6D,EAAOiB,OAAO,yBAA0B3M,IAJlD6H,EAAM,IAAI6D,EAAOiB,OAAO,wBAAyB3M,IAOhD6H,IACDP,EAASO,IACF,GAMX,SAASqB,GAAKyF,EAAIuK,EAASlZ,EAAMyY,EAAOzR,EAAMM,GASzC,GARCvJ,UAAUZ,OAAS,GACrBmK,EAAWvJ,UAAUA,UAAUZ,OAAS,GACxC6J,EAAO,KAGPA,EAAOqc,GAAoBrc,EAAMrE,EAAkC2E,GAGjE6b,GAAUnjB,EAAMsH,GAAjB,CAmBA,KADHmR,EAAQqK,GAAerK,IAEdnR,OAAAA,EAAS,IAAIoE,EAAOiB,OAAO,sBAAuB3M,GAG3Dme,EAAUjF,EAASlZ,EAAMyY,EAAOzR,EArBvBsc,SAAa1b,EAAOiS,GACxBjS,GAAAA,EACDN,EAASM,OACJ,CACDoR,IAAAA,EAEFA,EADCP,EAAMuC,SAASrZ,GACLkY,EAAStB,KAET,EAETgL,IAAAA,EAAsB,IAAIxK,EAAoB/Y,EAAM6Z,EAAS/C,GAAI2B,EAAOO,GACxEwK,EAAK7U,EAAG8U,gBAAgBF,GAC5Bjc,EAAS,KAAMkc,OAYrB,SAASzL,GAAMpJ,EAAIuK,EAASsK,EAAIlc,GAC1BqH,EAAG+U,UAAUF,IAGf7U,EAAGgV,kBAAkBH,GACrBlc,EAAS,OAHTA,EAAS,IAAIoE,EAAO2N,OAOxB,SAASuK,GAAMjV,EAAIuK,EAASlZ,EAAMoP,EAAM9H,GAClC6b,GAAUnjB,EAAMsH,IACpB8T,EAAUlC,EAASlZ,EAAMoP,EAAM9H,GAGjC,SAAS2K,GAAMtD,EAAIuK,EAASlZ,EAAMgH,EAAMM,GAClCvJ,GAAAA,UAAUZ,OAAS,EACrBmK,EAAWN,EACXA,EAAOrE,OAGJ,KADHqE,EAAOqc,GAAoBrc,EAAMrE,EAAkC2E,IACzD,OAGR6b,GAAUnjB,EAAMsH,IACpBkW,EAAetE,EAASlZ,EAAMsH,GAGhC,SAASuc,GAAOlV,EAAIuK,EAASlZ,EAAMgH,EAAMM,GACnB,mBAATN,IACTM,EAAWN,EACXA,EAAOsS,EAAUrV,YAAYkC,MAG1Bgd,GAAUnjB,EAAMsH,IAErBqW,EAAYzE,EAASlZ,EADrBgH,GAAcsS,EAAUrV,YAAYkC,KACHmB,GAGnC,SAASwc,GAAQnV,EAAIuK,EAAS6K,EAAQnV,EAAStH,GAE1C,GADHA,EAAWvJ,UAAUA,UAAUZ,OAAS,IACpC4mB,EACKzc,OAAAA,EAAS,IAAIlL,MAAM,gCAGxByE,IACAb,EAAO+jB,EAAS,IADPpJ,EAAOzZ,YAAY,GAG5BiiB,GAAUnjB,EAAMsH,IACpBkW,EAAetE,EAASlZ,EAAM,SAAS4H,GACrCN,EAASM,EAAO5H,KAIpB,SAAS4R,GAAMjD,EAAIuK,EAASlZ,EAAMsH,GAC5B6b,GAAUnjB,EAAMsH,IACpBuW,EAAiB3E,EAASlZ,EAAMsH,GAGlC,SAAS2H,GAAKN,EAAIuK,EAASlZ,EAAMsH,GAC3B6b,GAAUnjB,EAAMsH,IAWpB0Y,EAAU9G,EAASlZ,EATVsjB,SAAa1b,EAAOK,GACxBL,GAAAA,EACDN,EAASM,OACJ,CACDsH,IAAAA,EAAQ,IAAI0K,EAAM5Z,EAAMiI,EAAQ0G,EAAGvP,MACvCkI,EAAS,KAAM4H,MAOrB,SAAS8U,GAAMrV,EAAIuK,EAASsK,EAAIlc,GAU1B2X,IAAAA,EAAMtQ,EAAG+U,UAAUF,GACnBvE,EAGFgB,EAAW/G,EAAS+F,EAbbqE,SAAa1b,EAAOK,GACxBL,GAAAA,EACDN,EAASM,OACJ,CACDsH,IAAAA,EAAQ,IAAI0K,EAAMqF,EAAIjf,KAAMiI,EAAQ0G,EAAGvP,MAC3CkI,EAAS,KAAM4H,MAMjB5H,EAAS,IAAIoE,EAAO2N,OAMxB,SAAS4K,GAAKtV,EAAIuK,EAASkH,EAASC,EAAS/Y,GACvC6b,GAAU/C,EAAS9Y,IACnB6b,GAAU9C,EAAS/Y,IACvB6Y,EAAUjH,EAASkH,EAASC,EAAS/Y,GAGvC,SAASwK,GAAOnD,EAAIuK,EAASlZ,EAAMsH,GAC7B6b,GAAUnjB,EAAMsH,IACpB+Z,EAAYnI,EAASlZ,EAAMsH,GAG7B,SAAS4c,GAAKvV,EAAIuK,EAASsK,EAAIza,EAAQmW,EAAQ/hB,EAAQ6b,EAAU1R,GAO/D4X,OAAUN,IAAcM,EAAU,EAAIA,EACtC/hB,OAAUyhB,IAAczhB,EAAU4L,EAAO5L,OAAS+hB,EAAS/hB,EAC3DmK,EAAWvJ,UAAUA,UAAUZ,OAAS,GAEpC8hB,IAAAA,EAAMtQ,EAAG+U,UAAUF,GACnBvE,EAEOA,EAAIxG,MAAMuC,SAAS1Z,GAG5Bwe,EAAU5G,EAAS+F,EAAKlW,EAAQmW,EAAQ/hB,EAAQ6b,EAfzCmL,SAAWtc,EAAKuc,GAEvB9c,EAASO,EAAKuc,GAAa,EAAGrb,KAW9BzB,EAAS,IAAIoE,EAAO2N,MAAM,uCAF1B/R,EAAS,IAAIoE,EAAO2N,OAQxB,SAASgL,GAAM1V,EAAIuK,EAASsK,EAAIlc,GAC3Bgd,GAAgBd,EAAIlc,KAAckc,IAC3B7U,EAAG+U,UAAUF,GAIrBlc,IAFAA,EAAS,IAAIoE,EAAO2N,QAMxB,SAAS1J,GAAShB,EAAIuK,EAASlZ,EAAM4O,EAAStH,GAIzC,GAHHA,EAAWvJ,UAAUA,UAAUZ,OAAS,GACxCyR,EAAUmU,GAAsBnU,EAAS,KAAM,KAE3CuU,GAAUnjB,EAAMsH,GAAjB,CAECmR,IAAAA,EAAQqK,GAAelU,EAAQmO,MAAQ,KACxC,IAACtE,EACKnR,OAAAA,EAAS,IAAIoE,EAAOiB,OAAO,qBAAsB3M,IAG1Dme,EAAUjF,EAASlZ,EAAMyY,EAAO,SAAS5Q,EAAKgS,GACzChS,GAAAA,EACMP,OAAAA,EAASO,GAEdoX,IAAAA,EAAM,IAAIlG,EAAoB/Y,EAAM6Z,EAAS/C,GAAI2B,EAAO,GACxD+K,EAAK7U,EAAG8U,gBAAgBxE,GAEnBsF,SAAAA,IACP5V,EAAGgV,kBAAkBH,GAGvBvD,EAAW/G,EAAS+F,EAAK,SAASpX,EAAK2c,GAClC3c,GAAAA,EAEMP,OADPid,IACOjd,EAASO,GAGdqH,IAAAA,EAAQ,IAAI0K,EAAMqF,EAAIjf,KAAMwkB,EAAa7V,EAAGvP,MAE7C8P,GAAAA,EAAMkD,cAEA9K,OADPid,IACOjd,EAAS,IAAIoE,EAAO8S,OAAO,iCAAkCxe,IAGlEuY,IAAAA,EAAOrJ,EAAMqJ,KACbxP,EAAST,EAAOuW,MAAMtG,GAE1BuH,EAAU5G,EAAS+F,EAAKlW,EAAQ,EAAGwP,EAAM,EAAG,SAAS1Q,GAGhDA,GAFH0c,IAEG1c,EACMP,OAAAA,EAASO,GAGdqE,IAAAA,EAEFA,EADsB,SAArB0C,EAAQsU,SACFtI,EAAS1P,OAAOnC,GAEhBA,EAETzB,EAAS,KAAM4E,UAMvB,SAASuY,GAAM9V,EAAIuK,EAASsK,EAAIza,EAAQmW,EAAQ/hB,EAAQ6b,EAAU1R,GAChEA,EAAWvJ,UAAUA,UAAUZ,OAAS,GACxC+hB,OAAUN,IAAcM,EAAU,EAAIA,EACtC/hB,OAAUyhB,IAAczhB,EAAU4L,EAAO5L,OAAS+hB,EAAS/hB,EAEvD8hB,IAAAA,EAAMtQ,EAAG+U,UAAUF,GACnBvE,EAEOA,EAAIxG,MAAMuC,SAASzZ,GAEpBwH,EAAO5L,OAAS+hB,EAAS/hB,EACjCmK,EAAS,IAAIoE,EAAO+T,IAAI,8BAExBF,EAAWrG,EAAS+F,EAAKlW,EAAQmW,EAAQ/hB,EAAQ6b,EAAU1R,GAJ3DA,EAAS,IAAIoE,EAAO2N,MAAM,uCAF1B/R,EAAS,IAAIoE,EAAO2N,OAUxB,SAASpJ,GAAUtB,EAAIuK,EAASlZ,EAAMkM,EAAM0C,EAAStH,GAIhD,GAHHA,EAAWvJ,UAAUA,UAAUZ,OAAS,GACxCyR,EAAUmU,GAAsBnU,EAAS,OAAQ,KAE7CuU,GAAUnjB,EAAMsH,GAAjB,CAECmR,IAAAA,EAAQqK,GAAelU,EAAQmO,MAAQ,KACxC,IAACtE,EACKnR,OAAAA,EAAS,IAAIoE,EAAOiB,OAAO,qBAAsB3M,IAIvC,iBADnBkM,EAAOA,GAAQ,MAEbA,EAAO,GAAKA,GAEK,iBAATA,GAA0C,SAArB0C,EAAQsU,WACrChX,EAAO0O,EAAS/P,OAAOqB,IAGzBiS,EAAUjF,EAASlZ,EAAMyY,EAAO,SAAS5Q,EAAKgS,GACzChS,GAAAA,EACMP,OAAAA,EAASO,GAEdoX,IAAAA,EAAM,IAAIlG,EAAoB/Y,EAAM6Z,EAAS/C,GAAI2B,EAAO,GACxD+K,EAAK7U,EAAG8U,gBAAgBxE,GAE5BD,EAAa9F,EAAS+F,EAAK/S,EAAM,EAAGA,EAAK/O,OAAQ,SAAS0K,GAGrDA,GAFH8G,EAAGgV,kBAAkBH,GAElB3b,EACMP,OAAAA,EAASO,GAElBP,EAAS,WAKf,SAASod,GAAW/V,EAAIuK,EAASlZ,EAAMkM,EAAM0C,EAAStH,GAIjD,GAHHA,EAAWvJ,UAAUA,UAAUZ,OAAS,GACxCyR,EAAUmU,GAAsBnU,EAAS,OAAQ,KAE7CuU,GAAUnjB,EAAMsH,GAAjB,CAECmR,IAAAA,EAAQqK,GAAelU,EAAQmO,MAAQ,KACxC,IAACtE,EACKnR,OAAAA,EAAS,IAAIoE,EAAOiB,OAAO,qBAAsB3M,IAIvC,iBADnBkM,EAAOA,GAAQ,MAEbA,EAAO,GAAKA,GAEK,iBAATA,GAA0C,SAArB0C,EAAQsU,WACrChX,EAAO0O,EAAS/P,OAAOqB,IAGzBiS,EAAUjF,EAASlZ,EAAMyY,EAAO,SAAS5Q,EAAKgS,GACzChS,GAAAA,EACMP,OAAAA,EAASO,GAEdoX,IAAAA,EAAM,IAAIlG,EAAoB/Y,EAAM6Z,EAAS/C,GAAI2B,EAAOoB,EAAStB,MACjEiL,EAAK7U,EAAG8U,gBAAgBxE,GAE5BM,EAAWrG,EAAS+F,EAAK/S,EAAM,EAAGA,EAAK/O,OAAQ8hB,EAAIjG,SAAU,SAASnR,GAGjEA,GAFH8G,EAAGgV,kBAAkBH,GAElB3b,EACMP,OAAAA,EAASO,GAElBP,EAAS,WAKf,SAASqd,GAAOhW,EAAIuK,EAASlZ,EAAMsH,GAIjC2H,GAAKN,EAAIuK,EAASlZ,EAHT4kB,SAAG/c,GACVP,GAASO,KAKb,SAASyc,GAAgB7b,EAAOnB,GAC1B,GAAiB,iBAAVmB,EAKJA,OAAAA,EAJLnB,EAAS,IAAIoE,EAAOiB,OAAO,mBAAoBlE,IAQnD,IAAIoc,GAAW,WACf,SAASC,GAASrc,GACTA,OAAAA,IAAWA,IAAU,EAI9B,SAAS4a,GAAoB5a,EAAOsc,EAAKzd,GAMnCwd,MALc,mBAARC,IACRzd,EAAWyd,EACXA,OAAMnG,GAGJkG,GAASrc,GACJA,EAAQ9F,EAGI,iBAAV8F,GACJkR,OAAOqL,UAAUvc,GAKpBnB,EAAS,IAAIoE,EAAOiB,OAAO,oCAAqClE,KACzD,GAIU,iBAAVA,EACJoc,GAAS/R,KAAKrK,GAINwc,SAASxc,EAAO,GACb9F,GAJd2E,EAAS,IAAIoE,EAAOiB,OAAO,gCAAiClE,KACrD,QAOCmW,IAARmG,EACKA,GAGTzd,EAAS,IAAIoE,EAAOiB,OAAO,iBAAkBlE,KACtC,GAGT,SAASyc,GAAWhM,EAASlZ,EAAMgH,EAAMM,GACvCtH,EAAOE,EAAUF,GAWG,iBAATgH,EACTM,EAAS,IAAIoE,EAAOiB,OAAO,sBAAuB3M,IAGlD6b,EAAU3C,EAASlZ,EAbZmlB,SAAYvd,EAAOwR,GACtBxR,EACFN,EAASM,IAETwR,EAAKpS,KAAOA,EACZ8T,EAAkB5B,EAASlZ,EAAMoZ,EAAM,CAAE7I,MAAOH,KAAKD,OAAS7I,MAYpE,SAAS8d,GAAYlM,EAAS+F,EAAKjY,EAAMM,GAUnB,iBAATN,EACTM,EAAS,IAAIoE,EAAOiB,OAAO,0BAG3BsS,EAAIhG,QAAQC,EAbLiM,SAAYvd,EAAOwR,GACtBxR,EACFN,EAASM,IAETwR,EAAKpS,KAAOA,EACZ8T,EAAkB5B,EAAS+F,EAAIjf,KAAMoZ,EAAM,CAAE7I,MAAOH,KAAKD,OAAS7I,MAYxE,SAAS+d,GAAWnM,EAASlZ,EAAM6Y,EAAKC,EAAKxR,GAC3CtH,EAAOE,EAAUF,GAYjB6b,EAAU3C,EAASlZ,EAVVslB,SAAa1d,EAAOwR,GACvBxR,EACFN,EAASM,IAETwR,EAAKP,IAAMA,EACXO,EAAKN,IAAMA,EACXgC,EAAkB5B,EAASlZ,EAAMoZ,EAAM,CAAE7I,MAAOH,KAAKD,OAAS7I,MAOpE,SAASie,GAAYrM,EAAS+F,EAAKpG,EAAKC,EAAKxR,GAW3C2X,EAAIhG,QAAQC,EAVHoM,SAAa1d,EAAOwR,GACvBxR,EACFN,EAASM,IAETwR,EAAKP,IAAMA,EACXO,EAAKN,IAAMA,EACXgC,EAAkB5B,EAAS+F,EAAIjf,KAAMoZ,EAAM,CAAE7I,MAAOH,KAAKD,OAAS7I,MAOxE,SAASke,GAAS7W,EAAIuK,EAASlZ,EAAMZ,EAAMkI,GACpC6b,GAAUnjB,EAAMsH,IACrBkb,GAActJ,EAASlZ,EAAMZ,EAAMkI,GAGrC,SAASme,GAAU9W,EAAIuK,EAASsK,EAAIpkB,EAAMkI,GACpC2X,IAAAA,EAAMtQ,EAAG+U,UAAUF,GAClBvE,EAIHyD,GAAexJ,EAAS+F,EAAK7f,EAAMkI,GAHnCA,EAAS,IAAIoE,EAAO2N,OAOxB,SAASiJ,GAAS3T,EAAIuK,EAASlZ,EAAMZ,EAAMqJ,EAAOsU,EAAMzV,GACnC,mBAATyV,IACRzV,EAAWyV,EACXA,EAAO,MAGJoG,GAAUnjB,EAAMsH,IACrB+a,GAAcnJ,EAASlZ,EAAMZ,EAAMqJ,EAAOsU,EAAMzV,GAGlD,SAASoe,GAAU/W,EAAIuK,EAASsK,EAAIpkB,EAAMqJ,EAAOsU,EAAMzV,GAClC,mBAATyV,IACRzV,EAAWyV,EACXA,EAAO,MAGLkC,IAAAA,EAAMtQ,EAAG+U,UAAUF,GAClBvE,EAGKA,EAAIxG,MAAMuC,SAASzZ,GAI3BghB,GAAerJ,EAAS+F,EAAK7f,EAAMqJ,EAAOsU,EAAMzV,GAHhDA,EAAS,IAAIoE,EAAO2N,MAAM,uCAH1B/R,EAAS,IAAIoE,EAAO2N,OAUxB,SAASsM,GAAYhX,EAAIuK,EAASlZ,EAAMZ,EAAMkI,GACvC6b,GAAUnjB,EAAMsH,IACrBqb,GAAiBzJ,EAASlZ,EAAMZ,EAAMkI,GAGxC,SAASse,GAAajX,EAAIuK,EAASsK,EAAIpkB,EAAMkI,GACvC2X,IAAAA,EAAMtQ,EAAG+U,UAAUF,GAClBvE,EAGKA,EAAIxG,MAAMuC,SAASzZ,GAI3BshB,GAAkB3J,EAAS+F,EAAK7f,EAAMkI,GAHtCA,EAAS,IAAIoE,EAAO2N,MAAM,uCAH1B/R,EAAS,IAAIoE,EAAO2N,OAUxB,SAASwM,GAAMlX,EAAIuK,EAASsK,EAAItE,EAAQ4G,EAAQxe,GAc1C2X,IAAAA,EAAMtQ,EAAG+U,UAAUF,GACnBvE,GACF3X,EAAS,IAAIoE,EAAO2N,OAGnB,QAAUyM,EACR5G,EAAS,EACV5X,EAAS,IAAIoE,EAAOiB,OAAO,6CAE3BsS,EAAIjG,SAAWkG,EACf5X,EAAS,KAAM2X,EAAIjG,WAEb,QAAU8M,EACf7G,EAAIjG,SAAWkG,EAAS,EACzB5X,EAAS,IAAIoE,EAAOiB,OAAO,6CAE3BsS,EAAIjG,UAAYkG,EAChB5X,EAAS,KAAM2X,EAAIjG,WAEb,QAAU8M,EAClB7F,EAAW/G,EAAS+F,EAjCb8G,SAA2Bne,EAAOsH,GACtCtH,EACDN,EAASM,GAENsH,EAAMqJ,KAAO2G,EAAS,EACvB5X,EAAS,IAAIoE,EAAOiB,OAAO,6CAE3BsS,EAAIjG,SAAW9J,EAAMqJ,KAAO2G,EAC5B5X,EAAS,KAAM2X,EAAIjG,aA2BvB1R,EAAS,IAAIoE,EAAOiB,OAAO,0CAI/B,SAASsE,GAAQtC,EAAIuK,EAASlZ,EAAMsH,GAC9B6b,GAAUnjB,EAAMsH,IACpBia,EAAerI,EAASlZ,EAAMsH,GAGhC,SAAS0e,GAAgBC,GACnB,MAAgB,iBAATA,EACFA,EAEW,WAAhB,EAAOA,IAA6C,mBAAjBA,EAAKC,QACnCD,EAAKC,UAAY,SADtB,EAKN,SAAS1V,GAAO7B,EAAIuK,EAASlZ,EAAMqQ,EAAOE,EAAOjJ,GAC5C,GAAC6b,GAAUnjB,EAAMsH,GAAjB,CAEC6e,IAAAA,EAAc/V,KAAKD,MAIvB+R,GAAYhJ,EAASlZ,EAHrBqQ,EAAkB2V,GAAT3V,GAAkD8V,GAC3D5V,EAAkByV,GAATzV,GAAkD4V,GAElB7e,IAG3C,SAAS8e,GAAQzX,EAAIuK,EAASsK,EAAInT,EAAOE,EAAOjJ,GAC1C6e,IAAAA,EAAc/V,KAAKD,MACvBE,EAAkB2V,GAAT3V,GAAkD8V,GAC3D5V,EAAkByV,GAATzV,GAAkD4V,GAEvDlH,IAAAA,EAAMtQ,EAAG+U,UAAUF,GACnBvE,EAEOA,EAAIxG,MAAMuC,SAASzZ,GAG5B6gB,GAAalJ,EAAS+F,EAAK5O,EAAOE,EAAOjJ,GAFzCA,EAAS,IAAIoE,EAAO2N,MAAM,uCAF1B/R,EAAS,IAAIoE,EAAO2N,OAQxB,SAASgN,GAAM1X,EAAIuK,EAASlZ,EAAMgH,EAAMM,GAClC6b,GAAUnjB,EAAMsH,KACpBN,EAAOqc,GAAoBrc,EAAM,OAAQM,KAGzC4d,GAAWhM,EAASlZ,EAAMgH,EAAMM,GAGlC,SAASgf,GAAO3X,EAAIuK,EAASsK,EAAIxc,EAAMM,GAElC,GADHN,EAAOqc,GAAoBrc,EAAM,OAAQM,GACtC,CAEC2X,IAAAA,EAAMtQ,EAAG+U,UAAUF,GACnBvE,EAEOA,EAAIxG,MAAMuC,SAASzZ,GAG5B6jB,GAAYlM,EAAS+F,EAAKjY,EAAMM,GAFhCA,EAAS,IAAIoE,EAAO2N,MAAM,uCAF1B/R,EAAS,IAAIoE,EAAO2N,QAQxB,SAASkN,GAAM5X,EAAIuK,EAASlZ,EAAM6Y,EAAKC,EAAKxR,GACvC,GAAC6b,GAAUnjB,EAAMsH,GACjB,OAACwd,GAASjM,GAGTiM,GAAShM,QAIbuM,GAAWnM,EAASlZ,EAAM6Y,EAAKC,EAAKxR,GAH3BA,EAAS,IAAIoE,EAAOiB,OAAO,8BAA+BmM,IAH1DxR,EAAS,IAAIoE,EAAOiB,OAAO,8BAA+BkM,IASrE,SAAS2N,GAAO7X,EAAIuK,EAASsK,EAAI3K,EAAKC,EAAKxR,GACtC,IAACwd,GAASjM,GACJvR,OAAAA,EAAS,IAAIoE,EAAOiB,OAAO,8BAA+BkM,IAEhE,IAACiM,GAAShM,GACJxR,OAAAA,EAAS,IAAIoE,EAAOiB,OAAO,8BAA+BmM,IAG/DmG,IAAAA,EAAMtQ,EAAG+U,UAAUF,GACnBvE,EAEOA,EAAIxG,MAAMuC,SAASzZ,GAG5BgkB,GAAYrM,EAAS+F,EAAKpG,EAAKC,EAAKxR,GAFpCA,EAAS,IAAIoE,EAAO2N,MAAM,uCAF1B/R,EAAS,IAAIoE,EAAO2N,OAQxB,SAASoN,GAAO9X,EAAIuK,EAASkH,EAASC,EAAS/Y,GAC1C,GAAC6b,GAAU/C,EAAS9Y,IACnB6b,GAAU9C,EAAS/Y,GAApB,CAEH8Y,EAAUlgB,EAAUkgB,GACpBC,EAAUngB,EAAUmgB,GAEhBE,IAIAmG,EAAoBC,EACpBC,EAAoBC,EALpBtG,EAAgBhS,EAAKgE,QAAQ6N,GAC7BU,EAAgBvS,EAAKgE,QAAQ6N,GAC7B0G,EAAUvY,EAAKxO,SAASqgB,GACxB2G,EAAUxY,EAAKxO,SAASsgB,GAGxB7H,EAAQpI,KAAKD,MAmGjB0L,EAAU3C,EAASkH,EAVV4G,SAAgBpf,EAAOwR,GAC3BxR,EACDN,EAASM,GACDwR,EAAKhK,OAAS9M,EACtBuZ,EAAU3C,EAASqH,EAAehE,GAElC4D,EAAUjH,EAASkH,EAASC,EAAS4G,KA5FhC9E,SAAAA,EAAava,EAAOK,GACxBL,EACDN,EAASM,GAGTkT,EAAkB5B,EAASmH,EADhBpY,EACmC,CAAEuQ,MAAOA,GAASlR,GAI3D4f,SAAAA,EAAmBtf,GACvBA,EACDN,EAASM,GAETsR,EAAQ/Q,UAAU0e,EAAcE,GAASjQ,GAAIqL,GAIxCgF,SAAAA,EAAiCvf,GACrCA,EACDN,EAASM,IAEN8e,EAAmB5P,KAAO8P,EAAmB9P,KAC9C6P,EAAgBE,UAEXF,EAAcG,GACrB5N,EAAQvQ,UAAU+d,EAAmBxa,KAAMya,EAAeO,IAIrDE,SAAAA,EAAiCxf,GACrCA,EACDN,EAASM,IAETif,EAAcE,GAAWJ,EAAcG,GACvC5N,EAAQvQ,UAAUie,EAAmB1a,KAAM2a,EAAeM,IAIrDE,SAAAA,EAA8Bzf,EAAOK,GACzCL,EACDN,EAASM,IAETif,EAAgB5e,GACC2F,eAAemZ,GAC9BlJ,EAAiB3E,EAASmH,EAAS+G,GAEnCA,IAKGE,SAAAA,EAA+B1f,EAAOK,GAC1CL,EACDN,EAASM,IAETgf,EAAqB3e,EACrBiR,EAAQ/Q,UAAUye,EAAmB1a,KAAMmb,IAItCE,SAAAA,EAAyB3f,EAAOK,GACpCL,EACDN,EAASM,IAET+e,EAAgB1e,EAChB4T,EAAU3C,EAAS4H,EAAewG,IAI7B/K,SAAAA,EAA2B3U,EAAOK,GACtCL,EACDN,EAASM,IAET8e,EAAqBze,EACrBiR,EAAQ/Q,UAAUF,EAAOiE,KAAMqb,IAI1BN,SAAAA,EAAgBrf,GACpBA,EACDN,EAASM,GAETyZ,EAAYnI,EAASkH,EAAS9Y,IAiBpC,SAASkgB,GAAQ7Y,EAAIuK,EAASwI,EAASC,EAASvS,EAAM9H,GAMhD6b,GAAUzB,GAAS,EAJvBpa,EAAWvJ,UAAUA,UAAUZ,OAAS,KAKpCgmB,GAAUxB,EAASra,IAEvBma,EAAmBvI,EAASwI,EAASC,EAASra,GAGhD,SAASmgB,GAAS9Y,EAAIuK,EAASlZ,EAAMsH,GAC/B6b,GAAUnjB,EAAMsH,IACpBua,GAAU3I,EAASlZ,EAAMsH,GAG3B,SAASogB,GAAM/Y,EAAIuK,EAASlZ,EAAMsH,GAC5B6b,GAAUnjB,EAAMsH,IAWpB4Y,EAAWhH,EAASlZ,EATXsjB,SAAa1b,EAAOK,GACxBL,GAAAA,EACDN,EAASM,OACJ,CACDsH,IAAAA,EAAQ,IAAI0K,EAAM5Z,EAAMiI,EAAQ0G,EAAGvP,MACvCkI,EAAS,KAAM4H,MAOrB,SAASyY,GAAShZ,EAAIuK,EAASlZ,EAAM7C,EAAQmK,GAG3CnK,EAASA,GAAU,EAEfgmB,GAAUnjB,EAHdsH,EAAWvJ,UAAUA,UAAUZ,OAAS,KAIrCmnB,GAAgBnnB,EAAQmK,KAAcnK,GAEzC4kB,GAAc7I,EAASlZ,EAAM7C,EAAQmK,GAGvC,SAASsgB,GAAUjZ,EAAIuK,EAASsK,EAAIrmB,EAAQmK,GAE1CA,EAAWvJ,UAAUA,UAAUZ,OAAS,GACxCA,EAASA,GAAU,EAEf8hB,IAAAA,EAAMtQ,EAAG+U,UAAUF,GACpB,GAACvE,EAEG,GAAIA,EAAIxG,MAAMuC,SAASzZ,GAEvB,CACF+iB,GAAAA,GAAgBnnB,EAAQmK,KAAcnK,EAAQ,OACjD8kB,GAAe/I,EAAS+F,EAAK9hB,EAAQmK,QAHrCA,EAAS,IAAIoE,EAAO2N,MAAM,4CAF1B/R,EAAS,IAAIoE,EAAO2N,OASxBpd,OAAOC,QAAU,CACf2rB,oBAAqB5K,EACrB/T,KAAMA,GACNmd,MAAOA,GACPxC,OAAQA,GACRyC,OAAQA,GACRC,MAAOA,GACPC,OAAQA,GACRzO,MAAOA,GACP6L,MAAOA,GACP3R,MAAOA,GACP6R,QAASA,GACTlS,MAAOA,GACPE,OAAQA,GACR7C,KAAMA,GACN+U,MAAOA,GACPC,KAAMA,GACNI,MAAOA,GACPH,KAAMA,GACNvU,SAAUA,GACV8U,MAAOA,GACPxU,UAAWA,GACXyU,WAAYA,GACZC,OAAQA,GACRa,SAAUA,GACVC,UAAWA,GACXnD,SAAUA,GACVoD,UAAWA,GACXC,YAAaA,GACbC,aAAcA,GACdC,MAAOA,GACP5U,QAASA,GACTT,OAAQA,GACR4V,QAASA,GACTK,OAAQA,GACRe,QAASA,GACTC,SAAUA,GACVC,MAAOA,GACPC,SAAUA,GACVC,UAAWA;;ACt7EOjoB,IAAAA,EAAAA,QAAQ,iBAAtB2O,EAAAA,EAAAA,UAEFoM,EAAa/a,QAAQ,cAAcS,OACnCiB,EAAM1B,QAAQ,gBAAgB0B,IAE9BiY,EAAY3Z,QAAQ,mBACpBmC,EAAmBwX,EAAUxX,iBAC7BmB,EAAYqW,EAAUrW,UACtBK,EAAWgW,EAAUhW,SACrBC,EAAa+V,EAAU/V,WACvBC,EAAW8V,EAAU9V,SACrBJ,EAAmBkW,EAAUlW,iBAE7B0kB,EAAYnoB,QAAQ,yBAEpB+O,EAAQ/O,QAAQ,qBAChB+U,EAAW/U,QAAQ,yBACnB6X,EAAY7X,QAAQ,oBACpB+L,EAAS/L,QAAQ,gBACjBooB,EAAgBpoB,QAAQ,gBAAgBqB,KAExC0C,EAAQ4V,EAAU5V,MAClBC,EAAS2V,EAAU3V,OACnBC,EAAS0V,EAAU1V,OACnBC,EAAmByV,EAAUzV,iBAG7BmkB,EAAOroB,QAAQ,uBAGnB,SAASsoB,EAAc3gB,GAClB,MAAoB,mBAAbA,EACDA,EAEF,SAASO,GACXA,GAAAA,EACKA,MAAAA,GAMZ,SAASqgB,EAAgBrgB,GACpBA,GAEDsgB,QAAQvgB,MAAM,gBAAiBC,GAgCnC,SAASugB,EAAWxZ,EAAStH,GAE3BA,EAAWA,GAAY4gB,EAEnBzP,IAAAA,GAHJ7J,EAAUA,GAAW,IAGD6J,OAAS,GACzBzX,EAAO4N,EAAQ5N,KAAO4N,EAAQ5N,KAAO+mB,EACrCM,EAAWzZ,EAAQyZ,UAAY,IAAIP,EAAU7Z,QAAQW,EAAQxP,MAAQ0C,GAErE1C,EAAOwP,EAAQxP,MAAQipB,EAASjpB,KAChCkpB,EAAkB7P,EAAMuC,SAAS/X,GAEjC0L,EAAK,KACTA,EAAG4Z,WAAahlB,EAChBoL,EAAGvP,KAAOA,EACVuP,EAAG/G,MAAQ,KAEX+G,EAAG6Z,MAAQ9kB,EACXiL,EAAG8Z,OAAS9kB,EACZgL,EAAG+Z,OAAS9kB,EAGZ+K,EAAGga,UAAYrP,EAAUrV,YAGpByK,KAAAA,MAAQA,EAAMc,UAAKoP,EAAW,MAI/B8E,IAAAA,EAAY,GACZkF,EAAiB/kB,EACrBhE,OAAOgP,eAAe,KAAM,YAAa,CACvC7G,IAAK,WAAoB0b,OAAAA,KAEtBD,KAAAA,gBAAkB,SAASF,GAC1BC,IAAAA,EAAKoF,IAEFpF,OADPE,EAAUF,GAAMD,EACTC,GAEJG,KAAAA,kBAAoB,SAASH,UACzBE,EAAUF,IAIfzmB,IAAAA,EAAQ,GAyCH8rB,SAAAA,EAAc3P,GACd,OAAA,SAAS5R,GAEXmR,EAAMuC,SAAS5X,GAChBkE,EAAS,KAAMtG,KAKR8nB,SAAAA,EAAcxhB,GACjBwP,IAAAA,EAAK9V,IACTkY,EAAQ/Q,UAAU2O,EAAI,SAASjP,EAAKY,GAC/BZ,EACDP,EAASO,GAKPY,EAGFqgB,EAAcxhB,GAFdA,EAAS,KAAMwP,KAMrBgS,CAAcxhB,IAjEbyhB,KAAAA,WAAa,SAASC,GACrBphB,IAAAA,EAUGA,OARJtE,IAAaqL,EAAG4Z,WACjBS,EAAUtsB,KAAKiS,GACPnL,IAAamL,EAAG4Z,WACxB3gB,EAAQ,IAAI8D,EAAO2Q,iBAAiB,iBAEpCtf,EAAMkB,KAAK+qB,GAGNphB,GAUJqhB,KAAAA,MAAQ,SAASpY,EAAUjC,EAASsa,GACpCxO,GAAAA,EAAW7J,GACN,MAAA,IAAIzU,MAAM,6CAEI,mBAAZwS,IACRsa,EAAWta,EACXA,EAAU,IAEZA,EAAUA,GAAW,GACrBsa,EAAWA,GAAY7nB,EAEnB8nB,IAAAA,EAAU,IAAI3R,EAIX2R,OAHPA,EAAQxR,MAAM9G,GAAU,EAAOjC,EAAQ0C,WACvC6X,EAAQzqB,GAAG,SAAUwqB,GAEdC,GA8CTd,EAASnf,KAAK,SAASrB,GACZqT,SAAAA,EAAStT,GACPwhB,SAAAA,EAAe7Z,GAClB2J,IAAAA,EAAUmP,EAAS9Y,KAYhB2J,OAXPA,EAAQT,MAAQA,EAChBS,EAAQiC,QAAU,GAClBjC,EAAQlY,KAAO6nB,EAAc3P,GAG7BA,EAAQnB,MAAQ,WACVoD,IAAAA,EAAUjC,EAAQiC,SArBrBkO,SAAiBlO,GACrB,GAACA,EAAQhe,OAAT,CAGCoa,IAAAA,EAAW7C,EAAS4C,cACxB6D,EAAQtR,QAAQ,SAASyf,GACvB/R,EAASvY,KAAKsqB,EAAO5hB,MAAO4hB,EAAOtpB,SAgB/BqpB,CAAiBlO,GACjBA,EAAQhe,OAAS,GAGZ+b,EAOTvK,EAAG0Z,SAAW,CACZkB,qBAAsB,WACbH,OAAAA,EAAe,wBAExBI,oBAAqB,WACZJ,OAAAA,EAAe,wBAKxBza,EAAG4Z,WADF3gB,EACepE,EAEAF,EAtGpBvG,EAAM8M,QAAQ,SAASmf,GACrBA,EAAUtsB,KAAK,OACf8S,KAAKb,IACP5R,EAAQ,KAsGNuK,EAASM,EAAO+G,GAGf9G,GAAAA,EACMqT,OAAAA,EAASrT,GAGdqR,IAAAA,EAAUmP,EAAS1e,sBACvBuP,EAAQlY,KAAO6nB,EAAc3P,GAG1BoP,EAEDpP,EAAQ7R,MAAM,SAASQ,GAClBA,GAAAA,EACMqT,OAAAA,EAASrT,GAElBmgB,EAAKH,oBAAoB3O,EAASgC,KAIpC8M,EAAKH,oBAAoB3O,EAASgC,KAGtCkN,EAAWlqB,UAAUoR,SAAW,GAQ9B,CAAA,CAAElQ,KAAM,OAAQkQ,UAAU,GAC1B,CAAElQ,KAAM,SAAUkQ,UAAU,GAC5B,CAAElQ,KAAM,QAASkQ,UAAU,GAC3B,CAAElQ,KAAM,UACR,CAAEA,KAAM,QAASkQ,UAAU,GAC3B,CAAElQ,KAAM,UACR,CAAEA,KAAM,SACR,CAAEA,KAAM,QAASkQ,UAAU,GAC3B,CAAElQ,KAAM,QAASkQ,UAAU,GAC3B,CAAElQ,KAAM,UAAWkQ,UAAU,GAC7B,CAAElQ,KAAM,QAASkQ,UAAU,GAC3B,CAAElQ,KAAM,OAAQkQ,UAAU,GAC1B,CAAElQ,KAAM,SACR,CAAEA,KAAM,SACR,CAAEA,KAAM,OAAQkQ,UAAU,GAC1B,CAAElQ,KAAM,SAAUkQ,UAAU,GAC5B,CAAElQ,KAAM,QACR,CAAEA,KAAM,WAAYkQ,UAAU,GAC9B,CAAElQ,KAAM,SACR,CAAEA,KAAM,YAAakQ,UAAU,GAC/B,CAAElQ,KAAM,aAAckQ,UAAU,GAChC,CAAElQ,KAAM,UACR,CAAEA,KAAM,SACR,CAAEA,KAAM,UAAWkQ,UAAU,GAC7B,CAAElQ,KAAM,SAAUkQ,UAAU,GAC5B,CAAElQ,KAAM,WAAYkQ,UAAU,GAC9B,CAAElQ,KAAM,UAAWkQ,UAAU,GAC7B,CAAElQ,KAAM,QAASkQ,UAAU,GAC3B,CAAElQ,KAAM,WAAYkQ,UAAU,GAC9B,CAAElQ,KAAM,aACR,CAAEA,KAAM,SAAUkQ,UAAU,GAC5B,CAAElQ,KAAM,WACR,CAAEA,KAAM,WAAYkQ,UAAU,GAC9B,CAAElQ,KAAM,WAAYkQ,UAAU,GAC9B,CAAElQ,KAAM,aACR,CAAEA,KAAM,aACR,CAAEA,KAAM,cAAekQ,UAAU,GACjC,CAAElQ,KAAM,iBACRyK,QAAQ,SAAS4f,GACbla,IAAAA,EAAaka,EAAOrqB,KACpBsqB,GAAsC,IAApBD,EAAOna,SAE7B8Y,EAAWlqB,UAAUqR,GAAc,WAC7BZ,IAAAA,EAAK,KACL9Q,EAAOC,MAAMI,UAAUqV,MAAM7W,KAAKqB,UAAW,GAC7C4rB,EAAe9rB,EAAKV,OAAS,EAI7BysB,EAAgD,mBAAvB/rB,EAAK8rB,GAC9BriB,EAAW2gB,EAAcpqB,EAAK8rB,IAE9B/hB,EAAQ+G,EAAGoa,WAAW,WACpB7P,IAAAA,EAAUvK,EAAG0Z,SAASkB,uBAIvB/lB,GAAAA,IAAamL,EAAG4Z,WAAY,CACzB1gB,IAAAA,EAAM,IAAI6D,EAAO2Q,iBAAiB,8CAC/B/U,OAAAA,EAAS5K,KAAKiS,EAAI9G,GAIlBqT,SAAAA,IACPhC,EAAQnB,QACRzQ,EAASnJ,MAAMwQ,EAAI5Q,WAIlB6rB,EACD/rB,EAAKI,KAAKid,GAEVrd,EAAK8rB,GAAgBzO,EAMnB2O,IAAAA,EAAS,CAAClb,EAAIuK,GAAS9b,OAAOS,GAClCmqB,EAAKzY,GAAYpR,MAAM,KAAM0rB,KAE5BjiB,GACDN,EAASM,IAKV8hB,IACDtB,EAAWlqB,UAAUoR,SAASC,GAAcjB,EAAU8Z,EAAWlqB,UAAUqR,GAAYC,KAAKb,OAOlGyZ,EAAWN,UAAYA,EAEvB7rB,OAAOC,QAAUksB;;;ACjXjB,IAAA,EAAA,QAAA,UAAA,OAAAnsB,OAAOC,QAAU,CACfksB,WAAYzoB,QAAQ,6BACpB2I,OAAQA,EACRiG,KAAM5O,QAAQ,aACd+L,OAAQ/L,QAAQ,eAChB+O,MAAO/O,QAAQ","file":"filer.min.map","sourceRoot":"../src","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// Symbols is a better way to do this, but if we don't have support we'll just\n// have to make do with an unlikely token\nvar customArgumentsToken = Symbol ? Symbol(\"__ES6-PROMISIFY--CUSTOM-ARGUMENTS__\") : \"__ES6-PROMISIFY--CUSTOM-ARGUMENTS__\";\n\n/**\n * promisify()\n * Transforms callback-based function -- func(arg1, arg2 .. argN, callback) -- into\n * an ES6-compatible Promise. Promisify provides a default callback of the form (error, result)\n * and rejects when `error` is truthy.\n *\n * @param {function} original - The function to promisify\n * @return {function} A promisified version of `original`\n */\nfunction promisify(original) {\n\n    // Ensure the argument is a function\n    if (typeof original !== \"function\") {\n        throw new TypeError(\"Argument to promisify must be a function\");\n    }\n\n    // If the user has asked us to decode argument names for them, honour that\n    var argumentNames = original[customArgumentsToken];\n\n    // If the user has supplied a custom Promise implementation, use it. Otherwise\n    // fall back to whatever we can find on the global object.\n    var ES6Promise = promisify.Promise || Promise;\n\n    // If we can find no Promise implemention, then fail now.\n    if (typeof ES6Promise !== \"function\") {\n        throw new Error(\"No Promise implementation found; do you need a polyfill?\");\n    }\n\n    return function () {\n        var _this = this;\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        return new ES6Promise(function (resolve, reject) {\n\n            // Append the callback bound to the context\n            args.push(function callback(err) {\n\n                if (err) {\n                    return reject(err);\n                }\n\n                for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                    values[_key2 - 1] = arguments[_key2];\n                }\n\n                if (values.length === 1 || !argumentNames) {\n                    return resolve(values[0]);\n                }\n\n                var o = {};\n                values.forEach(function (value, index) {\n                    var name = argumentNames[index];\n                    if (name) {\n                        o[name] = value;\n                    }\n                });\n\n                resolve(o);\n            });\n\n            // Call the function.\n            original.call.apply(original, [_this].concat(args));\n        });\n    };\n}\n\n// Attach this symbol to the exported function, so users can use it\npromisify.argumentNames = customArgumentsToken;\npromisify.Promise = undefined;\n\n// Export the public API\nexports.promisify = promisify;","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","/**\n * Patch process to add process.cwd(), always giving the root dir.\n * NOTE: this line needs to happen *before* we require in `path`.\n */\nprocess.cwd = () => '/';\n\n/**\n * https://github.com/browserify/path-browserify via Parcel.\n * We use is as a base for our own Filer.Path, and patch/add\n * a few things we need for the browser environment.\n */\nconst nodePath = require('path');\nconst filerPath = Object.create(nodePath);\n\n/**\n * Patch path.basename() to return / vs. ''\n */\nfilerPath.basename = (path, ext) => {\n  const basename = nodePath.basename(path, ext);\n  return basename === '' ? '/' : basename;\n};\n\n/**\n * Patch path.normalize() to not add a trailing /\n */\nfilerPath.normalize = (path) => {\n  path = nodePath.normalize(path);\n  return path === '/' ? path : filerPath.removeTrailing(path);\n};\n\n/**\n * Add new utility method isNull() to path: check for null paths.\n */\nfilerPath.isNull = path => ('' + path).indexOf('\\u0000') !== -1;\n\n/**\n * Add new utility method addTrailing() to add trailing / without doubling to //.\n */\nfilerPath.addTrailing = path => path.replace(/\\/*$/, '/');\n\n/**\n * Add new utility method removeTrailing() to remove trailing /, dealing with multiple\n */\nfilerPath.removeTrailing = path => {\n  path = path.replace(/\\/*$/, '');\n  return path === '' ? '/' : path;\n};\n\nmodule.exports = filerPath;\n","function generateRandom(template) {\n  return template.replace(/[xy]/g, function(c) {\n    var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);\n    return v.toString(16);\n  });\n}\n\nfunction guid() {\n  return generateRandom('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx').toUpperCase();\n}\n\n/**\n * Generate a string of n random characters.  Defaults to n=6.\n */ \nfunction randomChars(n) {\n  n = n || 6;\n  var template = 'x'.repeat(n);\n  return generateRandom(template);\n}\n\nfunction nop() {}\n\nmodule.exports = {\n  guid: guid,\n  nop: nop,\n  randomChars: randomChars\n};\n","var O_READ = 'READ';\nvar O_WRITE = 'WRITE';\nvar O_CREATE = 'CREATE';\nvar O_EXCLUSIVE = 'EXCLUSIVE';\nvar O_TRUNCATE = 'TRUNCATE';\nvar O_APPEND = 'APPEND';\nvar XATTR_CREATE = 'CREATE';\nvar XATTR_REPLACE = 'REPLACE';\n\nmodule.exports = {\n  FILE_SYSTEM_NAME: 'local',\n\n  FILE_STORE_NAME: 'files',\n\n  IDB_RO: 'readonly',\n  IDB_RW: 'readwrite',\n\n  WSQL_VERSION: '1',\n  WSQL_SIZE: 5 * 1024 * 1024,\n  WSQL_DESC: 'FileSystem Storage',\n\n  NODE_TYPE_FILE: 'FILE',\n  NODE_TYPE_DIRECTORY: 'DIRECTORY',\n  NODE_TYPE_SYMBOLIC_LINK: 'SYMLINK',\n  NODE_TYPE_META: 'META',\n\n\n  DEFAULT_DIR_PERMISSIONS: 0x1ED, // 755\n  DEFAULT_FILE_PERMISSIONS: 0x1A4, // 644\n  FULL_READ_WRITE_EXEC_PERMISSIONS: 0x1FF, // 777\n  READ_WRITE_PERMISSIONS: 0x1B6, /// 666\n  \n  SYMLOOP_MAX: 10,\n\n  BINARY_MIME_TYPE: 'application/octet-stream',\n  JSON_MIME_TYPE: 'application/json',\n\n  ROOT_DIRECTORY_NAME: '/', // basename(normalize(path))\n\n  // FS Mount Flags\n  FS_FORMAT: 'FORMAT',\n  FS_NOCTIME: 'NOCTIME',\n  FS_NOMTIME: 'NOMTIME',\n  FS_NODUPEIDCHECK: 'FS_NODUPEIDCHECK',\n\n  // FS File Open Flags\n  O_READ: O_READ,\n  O_WRITE: O_WRITE,\n  O_CREATE: O_CREATE,\n  O_EXCLUSIVE: O_EXCLUSIVE,\n  O_TRUNCATE: O_TRUNCATE,\n  O_APPEND: O_APPEND,\n\n  O_FLAGS: {\n    'r': [O_READ],\n    'r+': [O_READ, O_WRITE],\n    'w': [O_WRITE, O_CREATE, O_TRUNCATE],\n    'w+': [O_WRITE, O_READ, O_CREATE, O_TRUNCATE],\n    'wx': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],\n    'wx+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],\n    'a': [O_WRITE, O_CREATE, O_APPEND],\n    'a+': [O_WRITE, O_READ, O_CREATE, O_APPEND],\n    'ax': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_APPEND],\n    'ax+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_APPEND]\n  },\n\n  XATTR_CREATE: XATTR_CREATE,\n  XATTR_REPLACE: XATTR_REPLACE,\n\n  FS_READY: 'READY',\n  FS_PENDING: 'PENDING',\n  FS_ERROR: 'ERROR',\n\n  SUPER_NODE_ID: '00000000-0000-0000-0000-000000000000',\n\n  // Reserved File Descriptors for streams\n  STDIN: 0,\n  STDOUT: 1,\n  STDERR: 2,\n  FIRST_DESCRIPTOR: 3,\n\n  ENVIRONMENT: {\n    TMP: '/tmp',\n    PATH: ''\n  },\n\n  // Duplicate Node's fs.constants\n  fsConstants: {\n    O_RDONLY: 0,\n    O_WRONLY: 1,\n    O_RDWR: 2,\n    S_IFMT: 61440,\n    S_IFREG: 32768,\n    S_IFDIR: 16384,\n    S_IFCHR: 8192,\n    S_IFBLK: 24576,\n    S_IFIFO: 4096,\n    S_IFLNK: 40960,\n    S_IFSOCK: 49152,\n    O_CREAT: 512,\n    O_EXCL: 2048,\n    O_NOCTTY: 131072,\n    O_TRUNC: 1024,\n    O_APPEND: 8,\n    O_DIRECTORY: 1048576,\n    O_NOFOLLOW: 256,\n    O_SYNC: 128,\n    O_DSYNC: 4194304,\n    O_SYMLINK: 2097152,\n    O_NONBLOCK: 4,\n    S_IRWXU: 448,\n    S_IRUSR: 256,\n    S_IWUSR: 128,\n    S_IXUSR: 64,\n    S_IRWXG: 56,\n    S_IRGRP: 32,\n    S_IWGRP: 16,\n    S_IXGRP: 8,\n    S_IRWXO: 7,\n    S_IROTH: 4,\n    S_IWOTH: 2,\n    S_IXOTH: 1,\n    F_OK: 0,\n    R_OK: 4,\n    W_OK: 2,\n    X_OK: 1,\n    UV_FS_COPYFILE_EXCL: 1,\n    COPYFILE_EXCL: 1\n  }\n};\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\nvar FILE_STORE_NAME = require('../constants.js').FILE_STORE_NAME;\nvar IDB_RW = require('../constants.js').IDB_RW;\nvar IDB_RO = require('../constants.js').IDB_RO;\n\nvar indexedDB = global.indexedDB       ||\n                global.mozIndexedDB    ||\n                global.webkitIndexedDB ||\n                global.msIndexedDB;\n\nfunction IndexedDBContext(db, mode) {\n  this.db = db;\n  this.mode = mode;\n}\n\nIndexedDBContext.prototype._getObjectStore = function() {\n  if(this.objectStore) {\n    return this.objectStore;\n  }\n\n  var transaction = this.db.transaction(FILE_STORE_NAME, this.mode);\n  this.objectStore = transaction.objectStore(FILE_STORE_NAME);\n  return this.objectStore;\n};\n\nIndexedDBContext.prototype.clear = function(callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.clear();\n    request.onsuccess = function() {\n      callback();\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\n\nIndexedDBContext.prototype._get = function(key, callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.get(key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\nIndexedDBContext.prototype.getObject = function(key, callback) {\n  this._get(key, callback);\n};\nIndexedDBContext.prototype.getBuffer = function(key, callback) {\n  this._get(key, function(err, arrayBuffer) {\n    if(err) {\n      return callback(err);\n    }\n    callback(null, Buffer.from(arrayBuffer));\n  });\n};\n\nIndexedDBContext.prototype._put = function(key, value, callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.put(value, key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\nIndexedDBContext.prototype.putObject = function(key, value, callback) {\n  this._put(key, value, callback);\n};\nIndexedDBContext.prototype.putBuffer = function(key, uint8BackedBuffer, callback) {\n  var buf = uint8BackedBuffer.buffer;\n  this._put(key, buf, callback);\n};\n\nIndexedDBContext.prototype.delete = function(key, callback) {\n  try {\n    var objectStore = this._getObjectStore();\n    var request = objectStore.delete(key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\n\n\nfunction IndexedDB(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n  this.db = null;\n}\nIndexedDB.isSupported = function() {\n  return !!indexedDB;\n};\n\nIndexedDB.prototype.open = function(callback) {\n  var that = this;\n\n  // Bail if we already have a db open\n  if(that.db) {\n    return callback();\n  }\n\n  try {\n    // NOTE: we're not using versioned databases.\n    var openRequest = indexedDB.open(that.name);\n\n    // If the db doesn't exist, we'll create it\n    openRequest.onupgradeneeded = function onupgradeneeded(event) {\n      var db = event.target.result;\n\n      if(db.objectStoreNames.contains(FILE_STORE_NAME)) {\n        db.deleteObjectStore(FILE_STORE_NAME);\n      }\n      db.createObjectStore(FILE_STORE_NAME);\n    };\n\n    openRequest.onsuccess = function onsuccess(event) {\n      that.db = event.target.result;\n      callback();\n    };\n    openRequest.onerror = function onerror(event) {\n      event.preventDefault();\n      callback(event.error);\n    };\n  } catch(err) {\n    callback(err);\n  }\n};\n\nIndexedDB.prototype.getReadOnlyContext = function() {\n  return new IndexedDBContext(this.db, IDB_RO);\n};\nIndexedDB.prototype.getReadWriteContext = function() {\n  return new IndexedDBContext(this.db, IDB_RW);\n};\n\nmodule.exports = IndexedDB;\n","var errors = {};\n[\n  /**\n   * node.js errors - we only use some of these, add as needed.\n   */\n  //'-1:UNKNOWN:unknown error',\n  //'0:OK:success',\n  //'1:EOF:end of file',\n  //'2:EADDRINFO:getaddrinfo error',\n  '3:EACCES:permission denied',\n  //'4:EAGAIN:resource temporarily unavailable',\n  //'5:EADDRINUSE:address already in use',\n  //'6:EADDRNOTAVAIL:address not available',\n  //'7:EAFNOSUPPORT:address family not supported',\n  //'8:EALREADY:connection already in progress',\n  '9:EBADF:bad file descriptor',\n  '10:EBUSY:resource busy or locked',\n  //'11:ECONNABORTED:software caused connection abort',\n  //'12:ECONNREFUSED:connection refused',\n  //'13:ECONNRESET:connection reset by peer',\n  //'14:EDESTADDRREQ:destination address required',\n  //'15:EFAULT:bad address in system call argument',\n  //'16:EHOSTUNREACH:host is unreachable',\n  //'17:EINTR:interrupted system call',\n  '18:EINVAL:invalid argument',\n  //'19:EISCONN:socket is already connected',\n  //'20:EMFILE:too many open files',\n  //'21:EMSGSIZE:message too long',\n  //'22:ENETDOWN:network is down',\n  //'23:ENETUNREACH:network is unreachable',\n  //'24:ENFILE:file table overflow',\n  //'25:ENOBUFS:no buffer space available',\n  //'26:ENOMEM:not enough memory',\n  '27:ENOTDIR:not a directory',\n  '28:EISDIR:illegal operation on a directory',\n  //'29:ENONET:machine is not on the network',\n  // errno 30 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n  //'31:ENOTCONN:socket is not connected',\n  //'32:ENOTSOCK:socket operation on non-socket',\n  //'33:ENOTSUP:operation not supported on socket',\n  '34:ENOENT:no such file or directory',\n  //'35:ENOSYS:function not implemented',\n  //'36:EPIPE:broken pipe',\n  //'37:EPROTO:protocol error',\n  //'38:EPROTONOSUPPORT:protocol not supported',\n  //'39:EPROTOTYPE:protocol wrong type for socket',\n  //'40:ETIMEDOUT:connection timed out',\n  //'41:ECHARSET:invalid Unicode character',\n  //'42:EAIFAMNOSUPPORT:address family for hostname not supported',\n  // errno 43 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n  //'44:EAISERVICE:servname not supported for ai_socktype',\n  //'45:EAISOCKTYPE:ai_socktype not supported',\n  //'46:ESHUTDOWN:cannot send after transport endpoint shutdown',\n  '47:EEXIST:file already exists',\n  //'48:ESRCH:no such process',\n  //'49:ENAMETOOLONG:name too long',\n  '50:EPERM:operation not permitted',\n  '51:ELOOP:too many symbolic links encountered',\n  //'52:EXDEV:cross-device link not permitted',\n  '53:ENOTEMPTY:directory not empty',\n  //'54:ENOSPC:no space left on device',\n  '55:EIO:i/o error',\n  //'56:EROFS:read-only file system',\n  //'57:ENODEV:no such device',\n  //'58:ESPIPE:invalid seek',\n  //'59:ECANCELED:operation canceled',\n\n  /**\n   * Filer specific errors\n   */\n  '1000:ENOTMOUNTED:not mounted',\n  '1001:EFILESYSTEMERROR:missing super node, use \\'FORMAT\\' flag to format filesystem.',\n  '1002:ENOATTR:attribute does not exist'\n\n].forEach(function(e) {\n  e = e.split(':');\n  var errno = +e[0];\n  var errName = e[1];\n  var defaultMessage = e[2];\n\n  function FilerError(msg, path) {\n    Error.call(this);\n\n    this.name = errName;\n    this.code = errName;\n    this.errno = errno;\n    this.message = msg || defaultMessage;\n    if(path) {\n      this.path = path;\n    }\n    this.stack = (new Error(this.message)).stack;\n  }\n  FilerError.prototype = Object.create(Error.prototype);\n  FilerError.prototype.constructor = FilerError;\n  FilerError.prototype.toString = function() {\n    var pathInfo = this.path ? (', \\'' + this.path + '\\'') : '';\n    return this.name + ': ' + this.message + pathInfo;\n  };\n\n  // We expose the error as both Errors.EINVAL and Errors[18]\n  errors[errName] = errors[errno] = FilerError;\n});\n\nmodule.exports = errors;\n","/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(){\n  \"use strict\";\n\n  var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  // Use a lookup table to find the index.\n  var lookup = new Uint8Array(256);\n  for (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n  }\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = lookup[base64.charCodeAt(i)];\n      encoded2 = lookup[base64.charCodeAt(i+1)];\n      encoded3 = lookup[base64.charCodeAt(i+2)];\n      encoded4 = lookup[base64.charCodeAt(i+3)];\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})();\n","var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\nvar FILE_STORE_NAME = require('../constants.js').FILE_STORE_NAME;\nvar WSQL_VERSION = require('../constants.js').WSQL_VERSION;\nvar WSQL_SIZE = require('../constants.js').WSQL_SIZE;\nvar WSQL_DESC = require('../constants.js').WSQL_DESC;\nvar Errors = require('../errors.js');\nvar base64ArrayBuffer = require('base64-arraybuffer');\n\nfunction WebSQLContext(db, isReadOnly) {\n  var that = this;\n  this.getTransaction = function(callback) {\n    if(that.transaction) {\n      callback(that.transaction);\n      return;\n    }\n    // Either do readTransaction() (read-only) or transaction() (read/write)\n    db[isReadOnly ? 'readTransaction' : 'transaction'](function(transaction) {\n      that.transaction = transaction;\n      callback(transaction);\n    });\n  };\n}\n\nWebSQLContext.prototype.clear = function(callback) {\n  function onError(transaction, error) {\n    callback(error);\n  }\n  function onSuccess() {\n    callback(null);\n  }\n  this.getTransaction(function(transaction) {\n    transaction.executeSql('DELETE FROM ' + FILE_STORE_NAME + ';',\n      [], onSuccess, onError);\n  });\n};\n\nfunction _get(getTransaction, key, callback) {\n  function onSuccess(transaction, result) {\n    // If the key isn't found, return null\n    var value = result.rows.length === 0 ? null : result.rows.item(0).data;\n    callback(null, value);\n  }\n  function onError(transaction, error) {\n    callback(error);\n  }\n  getTransaction(function(transaction) {\n    transaction.executeSql('SELECT data FROM ' + FILE_STORE_NAME + ' WHERE id = ? LIMIT 1;',\n      [key], onSuccess, onError);\n  });\n}\nWebSQLContext.prototype.getObject = function(key, callback) {\n  _get(this.getTransaction, key, function(err, result) {\n    if(err) {\n      return callback(err);\n    }\n\n    try {\n      if(result) {\n        result = JSON.parse(result);\n      }\n    } catch(e) {\n      return callback(e);\n    }\n\n    callback(null, result);\n  });\n};\nWebSQLContext.prototype.getBuffer = function(key, callback) {\n  _get(this.getTransaction, key, function(err, result) {\n    if(err) {\n      return callback(err);\n    }\n\n    // Deal with zero-length ArrayBuffers, which will be encoded as ''\n    if(result || result === '') {\n      var arrayBuffer = base64ArrayBuffer.decode(result);\n      result = Buffer.from(arrayBuffer);\n    }\n\n    callback(null, result);\n  });\n};\n\nfunction _put(getTransaction, key, value, callback) {\n  function onSuccess() {\n    callback(null);\n  }\n  function onError(transaction, error) {\n    callback(error);\n  }\n  getTransaction(function(transaction) {\n    transaction.executeSql('INSERT OR REPLACE INTO ' + FILE_STORE_NAME + ' (id, data) VALUES (?, ?);',\n      [key, value], onSuccess, onError);\n  });\n}\nWebSQLContext.prototype.putObject = function(key, value, callback) {\n  var json = JSON.stringify(value);\n  _put(this.getTransaction, key, json, callback);\n};\nWebSQLContext.prototype.putBuffer = function(key, uint8BackedBuffer, callback) {\n  var base64 = base64ArrayBuffer.encode(uint8BackedBuffer.buffer);\n  _put(this.getTransaction, key, base64, callback);\n};\n\nWebSQLContext.prototype.delete = function(key, callback) {\n  function onSuccess() {\n    callback(null);\n  }\n  function onError(transaction, error) {\n    callback(error);\n  }\n  this.getTransaction(function(transaction) {\n    transaction.executeSql('DELETE FROM ' + FILE_STORE_NAME + ' WHERE id = ?;',\n      [key], onSuccess, onError);\n  });\n};\n\n\nfunction WebSQL(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n  this.db = null;\n}\nWebSQL.isSupported = function() {\n  return !!global.openDatabase;\n};\n\nWebSQL.prototype.open = function(callback) {\n  var that = this;\n\n  // Bail if we already have a db open\n  if(that.db) {\n    return callback();\n  }\n\n  var db = global.openDatabase(that.name, WSQL_VERSION, WSQL_DESC, WSQL_SIZE);\n  if(!db) {\n    callback('[WebSQL] Unable to open database.');\n    return;\n  }\n\n  function onError(transaction, error) {\n    if (error.code === 5) {\n      callback(new Errors.EINVAL('WebSQL cannot be accessed. If private browsing is enabled, disable it.'));\n    }\n    callback(error);\n  }\n  function onSuccess() {\n    that.db = db;\n    callback();\n  }\n\n  // Create the table and index we'll need to store the fs data.\n  db.transaction(function(transaction) {\n    function createIndex(transaction) {\n      transaction.executeSql('CREATE INDEX IF NOT EXISTS idx_' + FILE_STORE_NAME + '_id' +\n                             ' on ' + FILE_STORE_NAME + ' (id);',\n      [], onSuccess, onError);\n    }\n    transaction.executeSql('CREATE TABLE IF NOT EXISTS ' + FILE_STORE_NAME + ' (id unique, data TEXT);',\n      [], createIndex, onError);\n  });\n};\nWebSQL.prototype.getReadOnlyContext = function() {\n  return new WebSQLContext(this.db, true);\n};\nWebSQL.prototype.getReadWriteContext = function() {\n  return new WebSQLContext(this.db, false);\n};\n\nmodule.exports = WebSQL;\n","/*global setImmediate: false, setTimeout: false, console: false */\n\n/**\n * async.js shim, based on https://raw.github.com/caolan/async/master/lib/async.js Feb 18, 2014\n * Used under MIT - https://github.com/caolan/async/blob/master/LICENSE\n */\n\n(function () {\n\n    var async = {};\n\n    // async.js functions used in Filer\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\n// NOTE: prefer setImmediate to nextTick for proper recursion yielding.\n// see https://github.com/js-platform/filer/pull/24\nvar asyncCallback = require('../../lib/async.js').setImmediate;\n\n/**\n * Make shared in-memory DBs possible when using the same name.\n */\nvar createDB = (function() {\n  var pool = {};\n  return function getOrCreate(name) {\n    if(!pool.hasOwnProperty(name)) {\n      pool[name] = {};\n    }\n    return pool[name];\n  };\n}());\n\nfunction MemoryContext(db, readOnly) {\n  this.readOnly = readOnly;\n  this.objectStore = db;\n}\n\nMemoryContext.prototype.clear = function(callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback('[MemoryContext] Error: write operation on read only context');\n    });\n    return;\n  }\n  var objectStore = this.objectStore;\n  Object.keys(objectStore).forEach(function(key){\n    delete objectStore[key];\n  });\n  asyncCallback(callback);\n};\n\n// Memory context doesn't care about differences between Object and Buffer\nMemoryContext.prototype.getObject =\nMemoryContext.prototype.getBuffer =\nfunction(key, callback) {\n  var that = this;\n  asyncCallback(function() {\n    callback(null, that.objectStore[key]);\n  });\n};\nMemoryContext.prototype.putObject =\nMemoryContext.prototype.putBuffer =\nfunction(key, value, callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback('[MemoryContext] Error: write operation on read only context');\n    });\n    return;\n  }\n  this.objectStore[key] = value;\n  asyncCallback(callback);\n};\n\nMemoryContext.prototype.delete = function(key, callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback('[MemoryContext] Error: write operation on read only context');\n    });\n    return;\n  }\n  delete this.objectStore[key];\n  asyncCallback(callback);\n};\n\n\nfunction Memory(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n}\nMemory.isSupported = function() {\n  return true;\n};\n\nMemory.prototype.open = function(callback) {\n  this.db = createDB(this.name);\n  asyncCallback(callback);\n};\nMemory.prototype.getReadOnlyContext = function() {\n  return new MemoryContext(this.db, true);\n};\nMemory.prototype.getReadWriteContext = function() {\n  return new MemoryContext(this.db, false);\n};\n\nmodule.exports = Memory;\n","var IndexedDB = require('./indexeddb.js');\nvar WebSQL = require('./websql.js');\nvar Memory = require('./memory.js');\n\nmodule.exports = {\n  IndexedDB: IndexedDB,\n  WebSQL: WebSQL,\n  Memory: Memory,\n\n  /**\n   * Convenience Provider references\n   */\n\n  // The default provider to use when none is specified\n  Default: IndexedDB,\n\n  // The Fallback provider does automatic fallback checks\n  Fallback: (function() {\n    if(IndexedDB.isSupported()) {\n      return IndexedDB;\n    }\n\n    if(WebSQL.isSupported()) {\n      return WebSQL;\n    }\n\n    function NotSupported() {\n      throw '[Filer Error] Your browser doesn\\'t support IndexedDB or WebSQL.';\n    }\n    NotSupported.isSupported = function() {\n      return false;\n    };\n    return NotSupported;\n  }())\n};\n","var defaults = require('../constants.js').ENVIRONMENT;\n\nmodule.exports = function Environment(env) {\n  env = env || {};\n  env.TMP = env.TMP || defaults.TMP;\n  env.PATH = env.PATH || defaults.PATH;\n\n  this.get = function(name) {\n    return env[name];\n  };\n\n  this.set = function(name, value) {\n    env[name] = value;\n  };\n};\n","module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n","module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n","var {promisify} = require('es6-promisify');\nvar Path = require('../path.js');\nvar Errors = require('../errors.js');\nvar Environment = require('./environment.js');\nvar async = require('../../lib/async.js');\nvar minimatch = require('minimatch');\n\nfunction Shell(fs, options) {\n  options = options || {};\n\n  var env = new Environment(options.env);\n  var cwd = '/';\n\n  /**\n   * The bound FileSystem (cannot be changed)\n   */\n  Object.defineProperty(this, 'fs', {\n    get: function() { return fs; },\n    enumerable: true\n  });\n\n  /**\n   * The shell's environment (e.g., for things like\n   * path, tmp, and other env vars). Use env.get()\n   * and env.set() to work with variables.\n   */\n  Object.defineProperty(this, 'env', {\n    get: function() { return env; },\n    enumerable: true\n  });\n\n  /**\n   * Change the current working directory. We\n   * include `cd` on the `this` vs. proto so that\n   * we can access cwd without exposing it externally.\n   */\n  this.cd = function(path, callback) {\n    path = Path.resolve(cwd, path);\n    // Make sure the path actually exists, and is a dir\n    fs.stat(path, function(err, stats) {\n      if(err) {\n        callback(new Errors.ENOTDIR(null, path));\n        return;\n      }\n      if(stats.type === 'DIRECTORY') {\n        cwd = path;\n        callback();\n      } else {\n        callback(new Errors.ENOTDIR(null, path));\n      }\n    });\n  };\n\n  /**\n   * Get the current working directory (changed with `cd()`)\n   */\n  this.pwd = function() {\n    return cwd;\n  };\n\n  this.promises = {};\n  /**\n  * Public API for Shell converted to Promise based\n  */\n  [\n    'cd',\n    'exec',\n    'touch',\n    'cat',\n    'ls',\n    'rm',\n    'tempDir',\n    'mkdirp',\n    'find'\n  ].forEach((methodName)=>{\n    this.promises[methodName] = promisify(this[methodName].bind(this));\n  });\n}\n\n/**\n * Execute the .js command located at `path`. Such commands\n * should assume the existence of 3 arguments, which will be\n * defined at runtime:\n *\n *   * fs - the current shell's bound filesystem object\n *   * args - a list of arguments for the command, or an empty list if none\n *   * callback - a callback function(error, result) to call when done.\n *\n * The .js command's contents should be the body of a function\n * that looks like this:\n *\n * function(fs, args, callback) {\n *   // .js code here\n * }\n */\nShell.prototype.exec = function(path, args, callback) {\n  /* jshint evil:true */\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof args === 'function') {\n    callback = args;\n    args = [];\n  }\n  args = args || [];\n  callback = callback || function(){};\n  path = Path.resolve(sh.pwd(), path);\n\n  fs.readFile(path, 'utf8', function(error, data) {\n    if(error) {\n      callback(error);\n      return;\n    }\n    try {\n      var cmd = new Function('fs', 'args', 'callback', data);\n      cmd(fs, args, callback);\n    } catch(e) {\n      callback(e);\n    }\n  });\n};\n\n/**\n * Create a file if it does not exist, or update access and\n * modified times if it does. Valid options include:\n *\n *  * updateOnly - whether to create the file if missing (defaults to false)\n *  * date - use the provided Date value instead of current date/time\n */\nShell.prototype.touch = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n  path = Path.resolve(sh.pwd(), path);\n\n  function createFile(path) {\n    fs.writeFile(path, '', callback);\n  }\n\n  function updateTimes(path) {\n    var now = Date.now();\n    var atime = options.date || now;\n    var mtime = options.date || now;\n\n    fs.utimes(path, atime, mtime, callback);\n  }\n\n  fs.stat(path, function(error) {\n    if(error) {\n      if(options.updateOnly === true) {\n        callback();\n      } else {\n        createFile(path);\n      }\n    } else {\n      updateTimes(path);\n    }\n  });\n};\n\n/**\n * Concatenate multiple files into a single String, with each\n * file separated by a newline. The `files` argument should\n * be a String (path to single file) or an Array of Strings\n * (multiple file paths).\n */\nShell.prototype.cat = function(files, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  var all = '';\n  callback = callback || function(){};\n\n  if(!files) {\n    callback(new Errors.EINVAL('Missing files argument'));\n    return;\n  }\n\n  files = typeof files === 'string' ? [ files ] : files;\n\n  function append(item, callback) {\n    var filename = Path.resolve(sh.pwd(), item);\n    fs.readFile(filename, 'utf8', function(error, data) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      all += data + '\\n';\n      callback();\n    });\n  }\n\n  async.eachSeries(files, append, function(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, all.replace(/\\n$/, ''));\n    }\n  });\n};\n\n/**\n * Get the listing of a directory, returning an array of\n * file entries in the following form:\n *\n * {\n *   path: <String> the basename of the directory entry\n *   links: <Number> the number of links to the entry\n *   size: <Number> the size in bytes of the entry\n *   modified: <Number> the last modified date/time\n *   type: <String> the type of the entry\n *   contents: <Array> an optional array of child entries\n * }\n *\n * By default ls() gives a shallow listing. If you want\n * to follow directories as they are encountered, use\n * the `recursive=true` option.\n */\nShell.prototype.ls = function(dir, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  if(!dir) {\n    callback(new Errors.EINVAL('Missing dir argument'));\n    return;\n  }\n\n  function list(path, callback) {\n    var pathname = Path.resolve(sh.pwd(), path);\n    var result = [];\n\n    fs.readdir(pathname, function(error, entries) {\n      if(error) {\n        callback(error);\n        return;\n      }\n\n      function getDirEntry(name, callback) {\n        name = Path.join(pathname, name);\n        fs.stat(name, function(error, stats) {\n          if(error) {\n            callback(error);\n            return;\n          }\n          var entry = stats;\n\n          if(options.recursive && stats.type === 'DIRECTORY') {\n            list(Path.join(pathname, entry.name), function(error, items) {\n              if(error) {\n                callback(error);\n                return;\n              }\n              entry.contents = items;\n              result.push(entry);\n              callback();\n            });\n          } else {\n            result.push(entry);\n            callback();\n          }\n        });\n      }\n\n      async.eachSeries(entries, getDirEntry, function(error) {\n        callback(error, result);\n      });\n    });\n  }\n\n  list(dir, callback);\n};\n\n/**\n * Removes the file or directory at `path`. If `path` is a file\n * it will be removed. If `path` is a directory, it will be\n * removed if it is empty, otherwise the callback will receive\n * an error. In order to remove non-empty directories, use the\n * `recursive=true` option.\n */\nShell.prototype.rm = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n\n  function remove(pathname, callback) {\n    pathname = Path.resolve(sh.pwd(), pathname);\n    fs.stat(pathname, function(error, stats) {\n      if(error) {\n        callback(error);\n        return;\n      }\n\n      // If this is a file, delete it and we're done\n      if(stats.type === 'FILE') {\n        fs.unlink(pathname, callback);\n        return;\n      }\n\n      // If it's a dir, check if it's empty\n      fs.readdir(pathname, function(error, entries) {\n        if(error) {\n          callback(error);\n          return;\n        }\n\n        // If dir is empty, delete it and we're done\n        if(entries.length === 0) {\n          fs.rmdir(pathname, callback);\n          return;\n        }\n\n        // If not, see if we're allowed to delete recursively\n        if(!options.recursive) {\n          callback(new Errors.ENOTEMPTY(null, pathname));\n          return;\n        }\n\n        // Remove each dir entry recursively, then delete the dir.\n        entries = entries.map(function(filename) {\n          // Root dir entries absolutely\n          return Path.join(pathname, filename);\n        });\n        async.eachSeries(entries, remove, function(error) {\n          if(error) {\n            callback(error);\n            return;\n          }\n          fs.rmdir(pathname, callback);\n        });\n      });\n    });\n  }\n\n  remove(path, callback);\n};\n\n/**\n * Gets the path to the temporary directory, creating it if not\n * present. The directory used is the one specified in\n * env.TMP. The callback receives (error, tempDirName).\n */\nShell.prototype.tempDir = function(callback) {\n  var sh = this;\n  var fs = sh.fs;\n  var tmp = sh.env.get('TMP');\n  callback = callback || function(){};\n\n  // Try and create it, and it will either work or fail\n  // but either way it's now there.\n  fs.mkdir(tmp, function() {\n    callback(null, tmp);\n  });\n};\n\n/**\n * Recursively creates the directory at `path`. If the parent\n * of `path` does not exist, it will be created.\n * Based off EnsureDir by Sam X. Xu\n * https://www.npmjs.org/package/ensureDir\n * MIT License\n */\nShell.prototype.mkdirp = function(path, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  callback = callback || function(){};\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n  else if (path === '/') {\n    callback();\n    return;\n  }\n  function _mkdirp(path, callback) {\n    fs.stat(path, function (err, stat) {\n      if(stat) {\n        if(stat.isDirectory()) {\n          callback();\n          return;\n        }\n        else if (stat.isFile()) {\n          callback(new Errors.ENOTDIR(null, path));\n          return;\n        }\n      }\n      else if (err && err.code !== 'ENOENT') {\n        callback(err);\n        return;\n      }\n      else {\n        var parent = Path.dirname(path);\n        if(parent === '/') {\n          fs.mkdir(path, function (err) {\n            if (err && err.code !== 'EEXIST') {\n              callback(err);\n              return;\n            }\n            callback();\n            return;\n          });\n        }\n        else {\n          _mkdirp(parent, function (err) {\n            if (err) return callback(err);\n            fs.mkdir(path, function (err) {\n              if (err && err.code !== 'EEXIST') {\n                callback(err);\n                return;\n              }\n              callback();\n              return;\n            });\n          });\n        }\n      }\n    });\n  }\n\n  _mkdirp(path, callback);\n};\n\n/**\n * Recursively walk a directory tree, reporting back all paths\n * that were found along the way. The `path` must be a dir.\n * Valid options include a `regex` for pattern matching paths\n * and an `exec` function of the form `function(path, next)` where\n * `path` is the current path that was found (dir paths have an '/'\n * appended) and `next` is a callback to call when done processing\n * the current path, passing any error object back as the first argument.\n * `find` returns a flat array of absolute paths for all matching/found\n * paths as the final argument to the callback.\n */\nShell.prototype.find = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  var exec = options.exec || function(path, next) { next(); };\n  var found = [];\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n\n  function processPath(path, callback) {\n    exec(path, function(err) {\n      if(err) {\n        callback(err);\n        return;\n      }\n\n      found.push(path);\n      callback();\n    });\n  }\n\n  function maybeProcessPath(path, callback) {\n    // Test the path against the user's regex, name, path primaries (if any)\n    // and remove any trailing slashes added previously.\n    var rawPath = Path.removeTrailing(path);\n\n    // Check entire path against provided regex, if any\n    if(options.regex && !options.regex.test(rawPath)) {\n      callback();\n      return;\n    }\n\n    // Check basename for matches against name primary, if any\n    if(options.name && !minimatch(Path.basename(rawPath), options.name)) {\n      callback();\n      return;\n    }\n\n    // Check dirname for matches against path primary, if any\n    if(options.path && !minimatch(Path.dirname(rawPath), options.path)) {\n      callback();\n      return;\n    }\n\n    processPath(path, callback);\n  }\n\n  function walk(path, callback) {\n    path = Path.resolve(sh.pwd(), path);\n\n    // The path is either a file or dir, and instead of doing\n    // a stat() to determine it first, we just try to readdir()\n    // and it will either work or not, and we handle the non-dir error.\n    fs.readdir(path, function(err, entries) {\n      if(err) {\n        if(err.code === 'ENOTDIR' /* file case, ignore error */) {\n          maybeProcessPath(path, callback);\n        } else {\n          callback(err);\n        }\n        return;\n      }\n\n      // Path is really a dir, add a trailing / and report it found\n      maybeProcessPath(Path.addTrailing(path), function(err) {\n        if(err) {\n          callback(err);\n          return;\n        }\n\n        entries = entries.map(function(entry) {\n          return Path.join(path, entry);\n        });\n\n        async.eachSeries(entries, walk, function(err) {\n          callback(err, found);\n        });\n      });\n    });\n  }\n\n  // Make sure we are starting with a dir path\n  fs.stat(path, function(err, stats) {\n    if(err) {\n      callback(err);\n      return;\n    }\n    if(!stats.isDirectory()) {\n      callback(new Errors.ENOTDIR(null, path));\n      return;\n    }\n\n    walk(path, callback);\n  });\n};\n\nmodule.exports = Shell;\n","// Based on https://github.com/diy/intercom.js/blob/master/lib/events.js\n// Copyright 2012 DIY Co Apache License, Version 2.0\n// http://www.apache.org/licenses/LICENSE-2.0\n\nfunction removeItem(item, array) {\n  for (var i = array.length - 1; i >= 0; i--) {\n    if (array[i] === item) {\n      array.splice(i, 1);\n    }\n  }\n  return array;\n}\n\nvar EventEmitter = function() {};\n\nEventEmitter.createInterface = function(space) {\n  var methods = {};\n\n  methods.on = function(name, fn) {\n    if (typeof this[space] === 'undefined') {\n      this[space] = {};\n    }\n    if (!this[space].hasOwnProperty(name)) {\n      this[space][name] = [];\n    }\n    this[space][name].push(fn);\n  };\n\n  methods.off = function(name, fn) {\n    if (typeof this[space] === 'undefined') return;\n    if (this[space].hasOwnProperty(name)) {\n      removeItem(fn, this[space][name]);\n    }\n  };\n\n  methods.trigger = function(name) {\n    if (typeof this[space] !== 'undefined' && this[space].hasOwnProperty(name)) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      for (var i = 0; i < this[space][name].length; i++) {\n        this[space][name][i].apply(this[space][name][i], args);\n      }\n    }\n  };\n\n  methods.removeAllListeners = function(name) {\n    if (typeof this[space] === 'undefined') return;\n    var self = this;\n    self[space][name].forEach(function(fn) {\n      self.off(name, fn);\n    });\n  };\n\n  return methods;\n};\n\nvar pvt = EventEmitter.createInterface('_handlers');\nEventEmitter.prototype._on = pvt.on;\nEventEmitter.prototype._off = pvt.off;\nEventEmitter.prototype._trigger = pvt.trigger;\n\nvar pub = EventEmitter.createInterface('handlers');\nEventEmitter.prototype.on = function() {\n  pub.on.apply(this, arguments);\n  Array.prototype.unshift.call(arguments, 'on');\n  this._trigger.apply(this, arguments);\n};\nEventEmitter.prototype.off = pub.off;\nEventEmitter.prototype.trigger = pub.trigger;\nEventEmitter.prototype.removeAllListeners = pub.removeAllListeners;\n\nmodule.exports = EventEmitter;\n","// Based on https://github.com/diy/intercom.js/blob/master/lib/intercom.js\n// Copyright 2012 DIY Co Apache License, Version 2.0\n// http://www.apache.org/licenses/LICENSE-2.0\n\nvar EventEmitter = require('./eventemitter.js');\nvar guid = require('../src/shared.js').guid;\n\nfunction throttle(delay, fn) {\n  var last = 0;\n  return function() {\n    var now = Date.now();\n    if (now - last > delay) {\n      last = now;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nfunction extend(a, b) {\n  if (typeof a === 'undefined' || !a) { a = {}; }\n  if (typeof b === 'object') {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n  }\n  return a;\n}\n\nvar localStorage = (function(window) {\n  if (typeof window === 'undefined' ||\n      typeof window.localStorage === 'undefined') {\n    return {\n      getItem : function() {},\n      setItem : function() {},\n      removeItem : function() {}\n    };\n  }\n  return window.localStorage;\n}(global));\n\nfunction Intercom() {\n  var self = this;\n  var now = Date.now();\n\n  this.origin         = guid();\n  this.lastMessage    = now;\n  this.receivedIDs    = {};\n  this.previousValues = {};\n\n  var storageHandler = function() {\n    self._onStorageEvent.apply(self, arguments);\n  };\n\n  // If we're in node.js, skip event registration\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  if (document.attachEvent) {\n    document.attachEvent('onstorage', storageHandler);\n  } else {\n    global.addEventListener('storage', storageHandler, false);\n  }\n}\n\nIntercom.prototype._transaction = function(fn) {\n  var TIMEOUT   = 1000;\n  var WAIT      = 20;\n  var self      = this;\n  var executed  = false;\n  var listening = false;\n  var waitTimer = null;\n\n  function lock() {\n    if (executed) {\n      return;\n    }\n\n    var now = Date.now();\n    var activeLock = localStorage.getItem(INDEX_LOCK)|0;\n    if (activeLock && now - activeLock < TIMEOUT) {\n      if (!listening) {\n        self._on('storage', lock);\n        listening = true;\n      }\n      waitTimer = setTimeout(lock, WAIT);\n      return;\n    }\n    executed = true;\n    localStorage.setItem(INDEX_LOCK, now);\n\n    fn();\n    unlock();\n  }\n\n  function unlock() {\n    if (listening) {\n      self._off('storage', lock);\n    }\n    if (waitTimer) {\n      clearTimeout(waitTimer);\n    }\n    localStorage.removeItem(INDEX_LOCK);\n  }\n\n  lock();\n};\n\nIntercom.prototype._cleanup_emit = throttle(100, function() {\n  var self = this;\n\n  self._transaction(function() {\n    var now = Date.now();\n    var threshold = now - THRESHOLD_TTL_EMIT;\n    var changed = 0;\n    var messages;\n\n    try {\n      messages = JSON.parse(localStorage.getItem(INDEX_EMIT) || '[]');\n    } catch(e) {\n      messages = [];\n    }\n    for (var i = messages.length - 1; i >= 0; i--) {\n      if (messages[i].timestamp < threshold) {\n        messages.splice(i, 1);\n        changed++;\n      }\n    }\n    if (changed > 0) {\n      localStorage.setItem(INDEX_EMIT, JSON.stringify(messages));\n    }\n  });\n});\n\nIntercom.prototype._cleanup_once = throttle(100, function() {\n  var self = this;\n\n  self._transaction(function() {\n    var timestamp, ttl, key;\n    var table;\n    var now  = Date.now();\n    var changed = 0;\n\n    try {\n      table = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');\n    } catch(e) {\n      table = {};\n    }\n    for (key in table) {\n      if (self._once_expired(key, table)) {\n        delete table[key];\n        changed++;\n      }\n    }\n\n    if (changed > 0) {\n      localStorage.setItem(INDEX_ONCE, JSON.stringify(table));\n    }\n  });\n});\n\nIntercom.prototype._once_expired = function(key, table) {\n  if (!table) {\n    return true;\n  }\n  if (!table.hasOwnProperty(key)) {\n    return true;\n  }\n  if (typeof table[key] !== 'object') {\n    return true;\n  }\n\n  var ttl = table[key].ttl || THRESHOLD_TTL_ONCE;\n  var now = Date.now();\n  var timestamp = table[key].timestamp;\n  return timestamp < now - ttl;\n};\n\nIntercom.prototype._localStorageChanged = function(event, field) {\n  if (event && event.key) {\n    return event.key === field;\n  }\n\n  var currentValue = localStorage.getItem(field);\n  if (currentValue === this.previousValues[field]) {\n    return false;\n  }\n  this.previousValues[field] = currentValue;\n  return true;\n};\n\nIntercom.prototype._onStorageEvent = function(event) {\n  event = event || global.event;\n  var self = this;\n\n  if (this._localStorageChanged(event, INDEX_EMIT)) {\n    this._transaction(function() {\n      var now = Date.now();\n      var data = localStorage.getItem(INDEX_EMIT);\n      var messages;\n\n      try {\n        messages = JSON.parse(data || '[]');\n      } catch(e) {\n        messages = [];\n      }\n      for (var i = 0; i < messages.length; i++) {\n        if (messages[i].origin === self.origin) continue;\n        if (messages[i].timestamp < self.lastMessage) continue;\n        if (messages[i].id) {\n          if (self.receivedIDs.hasOwnProperty(messages[i].id)) continue;\n          self.receivedIDs[messages[i].id] = true;\n        }\n        self.trigger(messages[i].name, messages[i].payload);\n      }\n      self.lastMessage = now;\n    });\n  }\n\n  this._trigger('storage', event);\n};\n\nIntercom.prototype._emit = function(name, message, id) {\n  id = (typeof id === 'string' || typeof id === 'number') ? String(id) : null;\n  if (id && id.length) {\n    if (this.receivedIDs.hasOwnProperty(id)) return;\n    this.receivedIDs[id] = true;\n  }\n\n  var packet = {\n    id        : id,\n    name      : name,\n    origin    : this.origin,\n    timestamp : Date.now(),\n    payload   : message\n  };\n\n  var self = this;\n  this._transaction(function() {\n    var data = localStorage.getItem(INDEX_EMIT) || '[]';\n    var delimiter = (data === '[]') ? '' : ',';\n    data = [data.substring(0, data.length - 1), delimiter, JSON.stringify(packet), ']'].join('');\n    localStorage.setItem(INDEX_EMIT, data);\n    self.trigger(name, message);\n\n    setTimeout(function() {\n      self._cleanup_emit();\n    }, 50);\n  });\n};\n\nIntercom.prototype.emit = function(name, message) {\n  this._emit.apply(this, arguments);\n  this._trigger('emit', name, message);\n};\n\nIntercom.prototype.once = function(key, fn, ttl) {\n  if (!Intercom.supported) {\n    return;\n  }\n\n  var self = this;\n  this._transaction(function() {\n    var data;\n    try {\n      data = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');\n    } catch(e) {\n      data = {};\n    }\n    if (!self._once_expired(key, data)) {\n      return;\n    }\n\n    data[key] = {};\n    data[key].timestamp = Date.now();\n    if (typeof ttl === 'number') {\n      data[key].ttl = ttl * 1000;\n    }\n\n    localStorage.setItem(INDEX_ONCE, JSON.stringify(data));\n    fn();\n\n    setTimeout(function() {\n      self._cleanup_once();\n    }, 50);\n  });\n};\n\nextend(Intercom.prototype, EventEmitter.prototype);\n\nIntercom.supported = (typeof localStorage !== 'undefined');\n\nvar INDEX_EMIT = 'intercom';\nvar INDEX_ONCE = 'intercom_once';\nvar INDEX_LOCK = 'intercom_lock';\n\nvar THRESHOLD_TTL_EMIT = 50000;\nvar THRESHOLD_TTL_ONCE = 1000 * 3600;\n\nIntercom.destroy = function() {\n  localStorage.removeItem(INDEX_LOCK);\n  localStorage.removeItem(INDEX_EMIT);\n  localStorage.removeItem(INDEX_ONCE);\n};\n\nIntercom.getInstance = (function() {\n  var intercom;\n  return function() {\n    if (!intercom) {\n      intercom = new Intercom();\n    }\n    return intercom;\n  };\n})();\n\nmodule.exports = Intercom;\n","var EventEmitter = require('../lib/eventemitter.js');\nvar Path = require('./path.js');\nvar Intercom = require('../lib/intercom.js');\n\n/**\n * FSWatcher based on node.js' FSWatcher\n * see https://github.com/joyent/node/blob/master/lib/fs.js\n */\nfunction FSWatcher() {\n  EventEmitter.call(this);\n  var self = this;\n  var recursive = false;\n  var recursivePathPrefix;\n  var filename;\n\n  function onchange(path) {\n    // Watch for exact filename, or parent path when recursive is true.\n    if(filename === path || (recursive && path.indexOf(recursivePathPrefix) === 0)) {\n      self.trigger('change', 'change', path);\n    }\n  }\n\n  // We support, but ignore the second arg, which node.js uses.\n  self.start = function(filename_, persistent_, recursive_) {\n    // Bail if we've already started (and therefore have a filename);\n    if(filename) {\n      return;\n    }\n\n    if(Path.isNull(filename_)) {\n      throw new Error('Path must be a string without null bytes.');\n    }\n\n    // TODO: get realpath for symlinks on filename...\n\n    // Filer's Path.normalize strips trailing slashes, which we use here.\n    // See https://github.com/js-platform/filer/issues/105\n    filename = Path.normalize(filename_);\n\n    // Whether to watch beneath this path or not\n    recursive = recursive_ === true;\n    // If recursive, construct a path prefix portion for comparisons later\n    // (i.e., '/path' becomes '/path/' so we can search within a filename for the\n    // prefix). We also take care to allow for '/' on its own.\n    if(recursive) {\n      recursivePathPrefix = filename === '/' ? '/' : filename + '/';\n    }\n\n    var intercom = Intercom.getInstance();\n    intercom.on('change', onchange);\n  };\n\n  self.close = function() {\n    var intercom = Intercom.getInstance();\n    intercom.off('change', onchange);\n    self.removeAllListeners('change');\n  };\n}\nFSWatcher.prototype = new EventEmitter();\nFSWatcher.prototype.constructor = FSWatcher;\n\nmodule.exports = FSWatcher;\n","module.exports = {\n  encode: string => Buffer.from(string),\n  decode: buffer => buffer.toString('utf8')\n};\n","var NODE_TYPE_FILE = require('./constants.js').NODE_TYPE_FILE;\n\nmodule.exports = function DirectoryEntry(id, type) {\n  this.id = id;\n  this.type = type || NODE_TYPE_FILE;\n};\n","const {\n  NODE_TYPE_FILE,\n  NODE_TYPE_DIRECTORY,\n  NODE_TYPE_SYMBOLIC_LINK,\n  DEFAULT_FILE_PERMISSIONS,\n  DEFAULT_DIR_PERMISSIONS\n} = require('./constants');\nconst {\n  S_IFREG,\n  S_IFDIR,\n  S_IFLNK\n} = require('./constants').fsConstants;\n\n/**\n * Make sure the options object has an id on property,\n * either from caller or one we generate using supplied guid fn.\n */\nfunction ensureID(options, prop, callback) {\n  if(options[prop]) {\n    return callback();\n  }\n\n  options.guid(function(err, id) {\n    if(err) {\n      return callback(err);\n    }\n    options[prop] = id;\n    callback();\n  });\n}\n\n/**\n * Generate a POSIX mode (integer) for the node type and permissions.\n * Use default permissions if we aren't passed any.\n */\nfunction generateMode(nodeType, modePermissions) {\n  switch(nodeType) {\n  case NODE_TYPE_DIRECTORY:\n    return (modePermissions || DEFAULT_DIR_PERMISSIONS) | S_IFDIR;\n  case NODE_TYPE_SYMBOLIC_LINK:\n    return (modePermissions || DEFAULT_FILE_PERMISSIONS) | S_IFLNK;\n  case NODE_TYPE_FILE:\n    // falls through\n  default:\n    return (modePermissions || DEFAULT_FILE_PERMISSIONS) | S_IFREG;\n  }\n}\n\n/**\n * Common properties for the layout of a Node\n */\nclass Node {\n  constructor(options) {\n    var now = Date.now();\n\n    this.id = options.id;\n    this.data = options.data; // id for data object\n    this.size = options.size || 0; // size (bytes for files, entries for directories)\n    this.atime = options.atime || now; // access time (will mirror ctime after creation)\n    this.ctime = options.ctime || now; // creation/change time\n    this.mtime = options.mtime || now; // modified time\n    this.flags = options.flags || []; // file flags\n    this.xattrs = options.xattrs || {}; // extended attributes\n    this.nlinks = options.nlinks || 0; // links count\n\n    // Historically, Filer's node layout has referred to the\n    // node type as `mode`, and done so using a String.  In\n    // a POSIX filesystem, the mode is a number that combines\n    // both node type and permission bits. Internal we use `type`,\n    // but store it in the database as `mode` for backward\n    // compatibility.\n    if(typeof options.type === 'string') {\n      this.type = options.type;\n    } else if(typeof options.mode === 'string') {\n      this.type = options.mode;\n    } else {\n      this.type = NODE_TYPE_FILE;\n    }\n\n    // Extra mode permissions and ownership info\n    this.permissions = options.permissions || generateMode(this.type);\n    this.uid = options.uid || 0x0; // owner name\n    this.gid = options.gid || 0x0; // group name\n  }\n\n  /**\n   * Serialize a Node to JSON.  Everything is as expected except\n   * that we use `mode` for `type` to maintain backward compatibility.\n   */\n  toJSON() {\n    return {\n      id: this.id,\n      data: this.data,\n      size: this.size,\n      atime: this.atime,\n      ctime: this.ctime,\n      mtime: this.ctime,\n      flags: this.flags,\n      xattrs: this.xattrs,\n      nlinks: this.nlinks,\n      // Use `mode` for `type` to keep backward compatibility\n      mode: this.type,\n      permissions: this.permissions,\n      uid: this.uid,\n      gid: this.gid\n    };\n  }\n\n  // Return complete POSIX `mode` for node type + permissions. See:\n  // http://man7.org/linux/man-pages/man2/chmod.2.html\n  get mode() {\n    return generateMode(this.type, this.permissions);\n  }\n  // When setting the `mode` we assume permissions bits only (not changing type)\n  set mode(value) {\n    this.permissions = value;\n  }\n}\n\nmodule.exports.create = function create(options, callback) {\n  // We expect both options.id and options.data to be provided/generated.\n  ensureID(options, 'id', function(err) {\n    if(err) {\n      return callback(err);\n    }\n\n    ensureID(options, 'data', function(err) {\n      if(err) {\n        return callback(err);\n      }\n\n      callback(null, new Node(options));\n    });\n  });\n};\n","const Errors = require('./errors.js');\nconst Node = require('./node');\n\nfunction OpenFileDescription(path, id, flags, position) {\n  this.path = path;\n  this.id = id;\n  this.flags = flags;\n  this.position = position;\n}\n\n// Tries to find the node associated with an ofd's `id`.\n// If not found, an error is returned on the callback.\nOpenFileDescription.prototype.getNode = function(context, callback) {\n  var id = this.id;\n  var path = this.path;\n\n  function check_if_node_exists(error, node) {\n    if(error) {\n      return callback(error);\n    }\n\n    if(!node) {\n      return callback(new Errors.EBADF('file descriptor refers to unknown node', path));\n    }\n\n    Node.create(node, callback);\n  }\n\n  context.getObject(id, check_if_node_exists);\n};\n\nmodule.exports = OpenFileDescription;\n","var Constants = require('./constants.js');\n\nfunction SuperNode(options) {\n  var now = Date.now();\n\n  this.id = Constants.SUPER_NODE_ID;\n  this.type = Constants.NODE_TYPE_META;\n  this.atime = options.atime || now;\n  this.ctime = options.ctime || now;\n  this.mtime = options.mtime || now;\n  // root node id (randomly generated)\n  this.rnode = options.rnode;\n}\n\nSuperNode.create = function(options, callback) {\n  options.guid(function(err, rnode) {\n    if(err) {\n      callback(err);\n      return;\n    }\n    options.rnode = options.rnode || rnode;\n    callback(null, new SuperNode(options));\n  });\n};\n\nmodule.exports = SuperNode;\n","var Constants = require('./constants.js');\nvar Path = require('./path.js');\n\n// https://github.com/nodejs/node/blob/4f1297f259b09d129ac01afbd4c674263b7ac124/lib/internal/fs/utils.js#L231\nfunction dateFromNumeric(num) {\n  return new Date(Number(num) * 1000);\n}\n\nfunction Stats(path, fileNode, devName) {\n  this.dev = devName;\n  this.node = fileNode.id;\n  this.type = fileNode.type;\n  this.size = fileNode.size;\n  this.nlinks = fileNode.nlinks;\n  // Date objects\n  this.atime = dateFromNumeric(fileNode.atime);\n  this.mtime = dateFromNumeric(fileNode.mtime);\n  this.ctime = dateFromNumeric(fileNode.ctime);\n  // Unix timestamp Numbers\n  this.atimeMs = fileNode.atime;\n  this.mtimeMs = fileNode.mtime;\n  this.ctimeMs = fileNode.ctime;\n  this.version = fileNode.version;\n  this.mode = fileNode.mode;\n  this.uid = fileNode.uid;\n  this.gid = fileNode.gid;\n  this.name = Path.basename(path);\n}\n\nStats.prototype.isFile = function() {\n  return this.type === Constants.NODE_TYPE_FILE;\n};\n\nStats.prototype.isDirectory = function() {\n  return this.type === Constants.NODE_TYPE_DIRECTORY;\n};\n\nStats.prototype.isSymbolicLink = function() {\n  return this.type === Constants.NODE_TYPE_SYMBOLIC_LINK;\n};\n\n// These will always be false in Filer.\nStats.prototype.isSocket          =\nStats.prototype.isFIFO            =\nStats.prototype.isCharacterDevice =\nStats.prototype.isBlockDevice     =\nfunction() {\n  return false;\n};\n\nmodule.exports = Stats;\n","var Path = require('../path.js');\nvar normalize = Path.normalize;\nvar dirname = Path.dirname;\nvar basename = Path.basename;\nvar isAbsolutePath = Path.isAbsolute;\nvar isNullPath = Path.isNull;\nvar shared = require('../shared.js');\n\nvar Constants = require('../constants.js');\nvar NODE_TYPE_FILE = Constants.NODE_TYPE_FILE;\nvar NODE_TYPE_DIRECTORY = Constants.NODE_TYPE_DIRECTORY;\nvar NODE_TYPE_SYMBOLIC_LINK = Constants.NODE_TYPE_SYMBOLIC_LINK;\nvar NODE_TYPE_META = Constants.NODE_TYPE_META;\n\nvar FULL_READ_WRITE_EXEC_PERMISSIONS = Constants.FULL_READ_WRITE_EXEC_PERMISSIONS;\n\nvar ROOT_DIRECTORY_NAME = Constants.ROOT_DIRECTORY_NAME;\nvar SUPER_NODE_ID = Constants.SUPER_NODE_ID;\nvar SYMLOOP_MAX = Constants.SYMLOOP_MAX;\n\nvar O_READ = Constants.O_READ;\nvar O_WRITE = Constants.O_WRITE;\nvar O_CREATE = Constants.O_CREATE;\nvar O_EXCLUSIVE = Constants.O_EXCLUSIVE;\nvar O_APPEND = Constants.O_APPEND;\nvar O_FLAGS = Constants.O_FLAGS;\n\nvar XATTR_CREATE = Constants.XATTR_CREATE;\nvar XATTR_REPLACE = Constants.XATTR_REPLACE;\nvar FS_NOMTIME = Constants.FS_NOMTIME;\nvar FS_NOCTIME = Constants.FS_NOCTIME;\n\nvar Encoding = require('../encoding.js');\nvar Errors = require('../errors.js');\nvar DirectoryEntry = require('../directory-entry.js');\nvar OpenFileDescription = require('../open-file-description.js');\nvar SuperNode = require('../super-node.js');\nvar Node = require('../node.js');\nvar Stats = require('../stats.js');\n\n/**\n * Update node times. Only passed times are modified (undefined times are ignored)\n * and filesystem flags are examined in order to override update logic.\n */\nfunction update_node_times(context, path, node, times, callback) {\n  // Honour mount flags for how we update times\n  var flags = context.flags;\n  if(flags.includes(FS_NOCTIME)) {\n    delete times.ctime;\n  }\n  if(flags.includes(FS_NOMTIME)) {\n    delete times.mtime;\n  }\n\n  // Only do the update if required (i.e., times are still present)\n  var update = false;\n  if(times.ctime) {\n    node.ctime = times.ctime;\n    // We don't do atime tracking for perf reasons, but do mirror ctime\n    node.atime = times.ctime;\n    update = true;\n  }\n  if(times.atime) {\n    // The only time we explicitly pass atime is when utimes(), futimes() is called.\n    // Override ctime mirror here if so\n    node.atime = times.atime;\n    update = true;\n  }\n  if(times.mtime) {\n    node.mtime = times.mtime;\n    update = true;\n  }\n\n  function complete(error) {\n    // Queue this change so we can send watch events.\n    // Unlike node.js, we send the full path vs. basename/dirname only.\n    context.changes.push({ event: 'change', path: path });\n    callback(error);\n  }\n\n  if(update) {\n    context.putObject(node.id, node, complete);\n  } else {\n    complete();\n  }\n}\n\n/**\n * make_node()\n */\n// in: file or directory path\n// out: new node representing file/directory\nfunction make_node(context, path, type, callback) {\n  if(type !== NODE_TYPE_DIRECTORY && type !== NODE_TYPE_FILE) {\n    return callback(new Errors.EINVAL('type must be a directory or file', path));\n  }\n\n  path = normalize(path);\n\n  var name = basename(path);\n  var parentPath = dirname(path);\n  var parentNode;\n  var parentNodeData;\n  var node;\n\n  // Check if the parent node exists\n  function create_node_in_parent(error, parentDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(parentDirectoryNode.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));\n    } else {\n      parentNode = parentDirectoryNode;\n      find_node(context, path, check_if_node_exists);\n    }\n  }\n\n  // Check if the node to be created already exists\n  function check_if_node_exists(error, result) {\n    if(!error && result) {\n      callback(new Errors.EEXIST('path name already exists', path));\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      context.getObject(parentNode.data, create_node);\n    }\n  }\n\n  // Create the new node\n  function create_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentNodeData = result;\n      Node.create({\n        guid: context.guid,\n        type: type\n      }, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        node = result;\n        node.nlinks += 1;\n        context.putObject(node.id, node, update_parent_node_data);\n      });\n    }\n  }\n\n  // Update parent node time\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, node, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  // Update the parent nodes data\n  function update_parent_node_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      parentNodeData[name] = new DirectoryEntry(node.id, type);\n      context.putObject(parentNode.data, parentNodeData, update_time);\n    }\n  }\n\n  // Find the parent node\n  find_node(context, parentPath, create_node_in_parent);\n}\n\n/**\n * find_node\n */\n// in: file or directory path\n// out: node structure, or error\nfunction find_node(context, path, callback) {\n  path = normalize(path);\n  if(!path) {\n    return callback(new Errors.ENOENT('path is an empty string'));\n  }\n  var name = basename(path);\n  var parentPath = dirname(path);\n  var followedCount = 0;\n\n  function read_root_directory_node(error, nodeData) {\n    if(error) {\n      return callback(error);\n    }\n\n    // Parse existing node as SuperNode\n    const superNode = new SuperNode(nodeData);\n\n    if(!superNode || superNode.type !== NODE_TYPE_META || !superNode.rnode) {\n      callback(new Errors.EFILESYSTEMERROR());\n    } else {\n      context.getObject(superNode.rnode, check_root_directory_node);\n    }\n  }\n\n  function check_root_directory_node(error, rootDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(!rootDirectoryNode) {\n      callback(new Errors.ENOENT());\n    } else {\n      Node.create(rootDirectoryNode, callback);\n    }\n  }\n\n  // in: parent directory node\n  // out: parent directory data\n  function read_parent_directory_data(error, parentDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(parentDirectoryNode.type !== NODE_TYPE_DIRECTORY || !parentDirectoryNode.data) {\n      callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));\n    } else {\n      context.getObject(parentDirectoryNode.data, get_node_from_parent_directory_data);\n    }\n  }\n\n  // in: parent directory data\n  // out: searched node\n  function get_node_from_parent_directory_data(error, parentDirectoryData) {\n    if(error) {\n      callback(error);\n    } else {\n      if(!parentDirectoryData.hasOwnProperty(name)) {\n        callback(new Errors.ENOENT(null, path));\n      } else {\n        var nodeId = parentDirectoryData[name].id;\n        context.getObject(nodeId, create_node);\n      }\n    }\n  }\n\n  function create_node(error, data) {\n    if(error) {\n      return callback(error);\n    }\n    Node.create(data, is_symbolic_link);\n  }\n\n  function is_symbolic_link(error, node) {\n    if(error) {\n      callback(error);\n    } else {\n      if(node.type === NODE_TYPE_SYMBOLIC_LINK) {\n        followedCount++;\n        if(followedCount > SYMLOOP_MAX){\n          callback(new Errors.ELOOP(null, path));\n        } else {\n          follow_symbolic_link(node.data);\n        }\n      } else {\n        callback(null, node);\n      }\n    }\n  }\n\n  function follow_symbolic_link(data) {\n    data = normalize(data);\n    parentPath = dirname(data);\n    name = basename(data);\n    if(ROOT_DIRECTORY_NAME === name) {\n      context.getObject(SUPER_NODE_ID, read_root_directory_node);\n    } else {\n      find_node(context, parentPath, read_parent_directory_data);\n    }\n  }\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    context.getObject(SUPER_NODE_ID, read_root_directory_node);\n  } else {\n    find_node(context, parentPath, read_parent_directory_data);\n  }\n}\n\n\n/**\n * set extended attribute (refactor)\n */\nfunction set_extended_attribute (context, path, node, name, value, flag, callback) {\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      update_node_times(context, path, node, { ctime: Date.now() }, callback);\n    }\n  }\n\n  var xattrs = node.xattrs;\n\n  if (flag === XATTR_CREATE && xattrs.hasOwnProperty(name)) {\n    callback(new Errors.EEXIST('attribute already exists', path));\n  }\n  else if (flag === XATTR_REPLACE && !xattrs.hasOwnProperty(name)) {\n    callback(new Errors.ENOATTR(null, path));\n  }\n  else {\n    xattrs[name] = value;\n    context.putObject(node.id, node, update_time);\n  }\n}\n\n/**\n * ensure_root_directory. Creates a root node if necessary.\n *\n * Note: this should only be invoked when formatting a new file system.\n * Multiple invocations of this by separate instances will still result\n * in only a single super node.\n */\nfunction ensure_root_directory(context, callback) {\n  var superNode;\n  var directoryNode;\n  var directoryData;\n\n  function ensure_super_node(error, existingNode) {\n    if(!error && existingNode) {\n      // Another instance has beat us and already created the super node.\n      callback();\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      SuperNode.create({guid: context.guid}, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        superNode = result;\n        context.putObject(superNode.id, superNode, write_directory_node);\n      });\n    }\n  }\n\n  function write_directory_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      Node.create({\n        guid: context.guid,\n        id: superNode.rnode,\n        type: NODE_TYPE_DIRECTORY\n      }, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        directoryNode = result;\n        directoryNode.nlinks += 1;\n        context.putObject(directoryNode.id, directoryNode, write_directory_data);\n      });\n    }\n  }\n\n  function write_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = {};\n      context.putObject(directoryNode.data, directoryData, callback);\n    }\n  }\n\n  context.getObject(SUPER_NODE_ID, ensure_super_node);\n}\n\n/**\n * make_directory\n */\nfunction make_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var parentDirectoryNode;\n  var parentDirectoryData;\n\n  function check_if_directory_exists(error, result) {\n    if(!error && result) {\n      callback(new Errors.EEXIST(null, path));\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      find_node(context, parentPath, read_parent_directory_data);\n    }\n  }\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryNode = result;\n      context.getObject(parentDirectoryNode.data, write_directory_node);\n    }\n  }\n\n  function write_directory_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryData = result;\n      Node.create({\n        guid: context.guid,\n        type: NODE_TYPE_DIRECTORY\n      }, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        directoryNode = result;\n        directoryNode.nlinks += 1;\n        context.putObject(directoryNode.id, directoryNode, write_directory_data);\n      });\n    }\n  }\n\n  function write_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = {};\n      context.putObject(directoryNode.data, directoryData, update_parent_directory_data);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, parentDirectoryNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_parent_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryData[name] = new DirectoryEntry(directoryNode.id, NODE_TYPE_DIRECTORY);\n      context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);\n    }\n  }\n\n  find_node(context, path, check_if_directory_exists);\n}\n\nfunction access_file(context, path, mode, callback) {\n  path = normalize(path);\n  find_node(context, path, function (err, node) {\n    if (err) {\n      return callback(err);\n    }\n    if(mode === Constants.F_OK){\n      return callback(null);\n    }\n    if (!(mode & Constants.X_OK) || (node.mode & (Constants.fsConstants.S_IXUSR | Constants.fsConstants.S_IXGRP | Constants.fsConstants.S_IXOTH))){\n      return callback(null);\n    }\n    callback(new Errors.EACCES('permission denied',path)) ; \n  });\n}\n\n/**\n * remove_directory\n */\nfunction remove_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var parentDirectoryNode;\n  var parentDirectoryData;\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryNode = result;\n      context.getObject(parentDirectoryNode.data, check_if_node_exists);\n    }\n  }\n\n  function check_if_node_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else if(ROOT_DIRECTORY_NAME === name) {\n      callback(new Errors.EBUSY(null, path));\n    } else if(!result.hasOwnProperty(name)) {\n      callback(new Errors.ENOENT(null, path));\n    } else {\n      parentDirectoryData = result;\n      directoryNode = parentDirectoryData[name].id;\n      context.getObject(directoryNode, check_if_node_is_directory);\n    }\n  }\n\n  function check_if_node_is_directory(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOTDIR(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_directory_is_empty);\n    }\n  }\n\n  function check_if_directory_is_empty(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(Object.keys(directoryData).length > 0) {\n        callback(new Errors.ENOTEMPTY(null, path));\n      } else {\n        remove_directory_entry_from_parent_directory_node();\n      }\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, parentDirectoryNode, { mtime: now, ctime: now }, remove_directory_node);\n    }\n  }\n\n  function remove_directory_entry_from_parent_directory_node() {\n    delete parentDirectoryData[name];\n    context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);\n  }\n\n  function remove_directory_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(directoryNode.id, remove_directory_data);\n    }\n  }\n\n  function remove_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(directoryNode.data, callback);\n    }\n  }\n\n  find_node(context, parentPath, read_parent_directory_data);\n}\n\nfunction open_file(context, path, flags, mode, callback) {\n  if (typeof mode === 'function'){\n    callback = mode;\n    mode = null;\n  }\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var directoryEntry;\n  var fileNode;\n  var fileData;\n\n  var followedCount = 0;\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    if(flags.includes(O_WRITE)) {\n      callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n    } else {\n      find_node(context, path, set_file_node);\n    }\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOENT(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(directoryData.hasOwnProperty(name)) {\n        if(flags.includes(O_EXCLUSIVE)) {\n          callback(new Errors.ENOENT('O_CREATE and O_EXCLUSIVE are set, and the named file exists', path));\n        } else {\n          directoryEntry = directoryData[name];\n          if(directoryEntry.type === NODE_TYPE_DIRECTORY && flags.includes(O_WRITE)) {\n            callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n          } else {\n            context.getObject(directoryEntry.id, check_if_symbolic_link);\n          }\n        }\n      } else {\n        if(!flags.includes(O_CREATE)) {\n          callback(new Errors.ENOENT('O_CREATE is not set and the named file does not exist', path));\n        } else {\n          write_file_node();\n        }\n      }\n    }\n  }\n\n  function check_if_symbolic_link(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var node = result;\n      if(node.type === NODE_TYPE_SYMBOLIC_LINK) {\n        followedCount++;\n        if(followedCount > SYMLOOP_MAX){\n          callback(new Errors.ELOOP(null, path));\n        } else {\n          follow_symbolic_link(node.data);\n        }\n      } else {\n        set_file_node(undefined, node);\n      }\n    }\n  }\n\n  function follow_symbolic_link(data) {\n    data = normalize(data);\n    parentPath = dirname(data);\n    name = basename(data);\n    if(ROOT_DIRECTORY_NAME === name) {\n      if(flags.includes(O_WRITE)) {\n        callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n      } else {\n        find_node(context, path, set_file_node);\n      }\n    }\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function set_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      callback(null, fileNode);\n    }\n  }\n\n  function write_file_node() {\n    Node.create({\n      guid: context.guid,\n      type: NODE_TYPE_FILE\n    }, function(error, result) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      fileNode = result;\n      fileNode.nlinks += 1;\n      if(mode){\n        fileNode.mode = mode;\n      }\n      context.putObject(fileNode.id, fileNode, write_file_data);\n    });\n  }\n\n  function write_file_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = Buffer.alloc(0);\n      context.putBuffer(fileNode.data, fileData, update_directory_data);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, handle_update_result);\n    }\n  }\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData[name] = new DirectoryEntry(fileNode.id, NODE_TYPE_FILE);\n      context.putObject(directoryNode.data, directoryData, update_time);\n    }\n  }\n\n  function handle_update_result(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, fileNode);\n    }\n  }\n}\n\nfunction replace_data(context, ofd, buffer, offset, length, callback) {\n  var fileNode;\n\n  function return_nbytes(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, length);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, return_nbytes);\n    }\n  }\n\n  function update_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function write_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n\n      var newData = Buffer.alloc(length);\n      buffer.copy(newData, 0, offset, offset + length);\n      ofd.position = length;\n\n      fileNode.size = length;\n      fileNode.version += 1;\n\n      context.putBuffer(fileNode.data, newData, update_file_node);\n    }\n  }\n\n  context.getObject(ofd.id, write_file_data);\n}\n\nfunction write_data(context, ofd, buffer, offset, length, position, callback) {\n  var fileNode;\n  var fileData;\n\n  function return_nbytes(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, length);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, return_nbytes);\n    }\n  }\n\n  function update_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function update_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = result;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var _position = (!(undefined === position || null === position)) ? position : ofd.position;\n      var newSize = Math.max(fileData.length, _position + length);\n      var newData = Buffer.alloc(newSize);\n      if(fileData) {\n        fileData.copy(newData);\n      }\n      buffer.copy(newData, _position, offset, offset + length);\n      if(undefined === position) {\n        ofd.position += length;\n      }\n\n      fileNode.size = newSize;\n      fileNode.version += 1;\n\n      context.putBuffer(fileNode.data, newData, update_file_node);\n    }\n  }\n\n  function read_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      context.getBuffer(fileNode.data, update_file_data);\n    }\n  }\n\n  context.getObject(ofd.id, read_file_data);\n}\n\nfunction read_data(context, ofd, buffer, offset, length, position, callback) {\n  var fileNode;\n  var fileData;\n\n  function handle_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = result;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var _position = (!(undefined === position || null === position)) ? position : ofd.position;\n      length = (_position + length > buffer.length) ? length - _position : length;\n      fileData.copy(buffer, offset, _position, _position + length);\n      if(undefined === position) {\n        ofd.position += length;\n      }\n      callback(null, length);\n    }\n  }\n\n  function read_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type === NODE_TYPE_DIRECTORY) {\n      callback(new Errors.EISDIR('the named file is a directory', ofd.path));\n    } else {\n      fileNode = result;\n      context.getBuffer(fileNode.data, handle_file_data);\n    }\n  }\n\n  context.getObject(ofd.id, read_file_data);\n}\n\nfunction stat_file(context, path, callback) {\n  path = normalize(path);\n  find_node(context, path, callback);\n}\n\nfunction fstat_file(context, ofd, callback) {\n  ofd.getNode(context, callback);\n}\n\nfunction lstat_file(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    find_node(context, path, callback);\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!directoryData.hasOwnProperty(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', path));\n      } else {\n        context.getObject(directoryData[name].id, callback);\n      }\n    }\n  }\n}\n\nfunction link_node(context, oldpath, newpath, callback) {\n  oldpath = normalize(oldpath);\n  var oldname = basename(oldpath);\n  var oldParentPath = dirname(oldpath);\n\n  newpath = normalize(newpath);\n  var newname = basename(newpath);\n  var newParentPath = dirname(newpath);\n  var ctime = Date.now();\n\n  var oldDirectoryNode;\n  var oldDirectoryData;\n  var newDirectoryNode;\n  var newDirectoryData;\n  var fileNodeID;\n  var fileNode;\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      update_node_times(context, newpath, fileNode, { ctime: ctime }, callback);\n    }\n  }\n\n  function update_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      fileNode.nlinks += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function read_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.getObject(fileNodeID, update_file_node);\n    }\n  }\n\n  function check_if_new_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newDirectoryData = result;\n      if(newDirectoryData.hasOwnProperty(newname)) {\n        callback(new Errors.EEXIST('newpath resolves to an existing file', newname));\n      } else {\n        newDirectoryData[newname] = oldDirectoryData[oldname];\n        fileNodeID = newDirectoryData[newname].id;\n        context.putObject(newDirectoryNode.data, newDirectoryData, read_file_node);\n      }\n    }\n  }\n\n  function read_new_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newDirectoryNode = result;\n      context.getObject(newDirectoryNode.data, check_if_new_file_exists);\n    }\n  }\n\n  function check_if_old_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldDirectoryData = result;\n      if(!oldDirectoryData.hasOwnProperty(oldname)) {\n        callback(new Errors.ENOENT('a component of either path prefix does not exist', oldname));\n      } else if(oldDirectoryData[oldname].type === NODE_TYPE_DIRECTORY) {\n        callback(new Errors.EPERM('oldpath refers to a directory'));\n      } else {\n        find_node(context, newParentPath, read_new_directory_data);\n      }\n    }\n  }\n\n  function read_old_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldDirectoryNode = result;\n      context.getObject(oldDirectoryNode.data, check_if_old_file_exists);\n    }\n  }\n\n  find_node(context, oldParentPath, read_old_directory_data);\n}\n\nfunction unlink_node(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var fileNode;\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      delete directoryData[name];\n      context.putObject(directoryNode.data, directoryData, function(error) {\n        if(error) {\n          callback(error);\n        } else {\n          var now = Date.now();\n          update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, callback);\n        }\n      });\n    }\n  }\n\n  function delete_file_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(fileNode.data, update_directory_data);\n    }\n  }\n\n  function update_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      fileNode.nlinks -= 1;\n      if(fileNode.nlinks < 1) {\n        context.delete(fileNode.id, delete_file_data);\n      } else {\n        context.putObject(fileNode.id, fileNode, function(error) {\n          if(error) {\n            callback(error);\n          } else {          \n            update_node_times(context, path, fileNode, { ctime: Date.now() }, update_directory_data);\n          }\n        });\n      }\n    }\n  }\n\n  function check_if_node_is_directory(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type === NODE_TYPE_DIRECTORY) {\n      callback(new Errors.EPERM('unlink not permitted on directories', name));\n    } else {\n      update_file_node(null, result);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!directoryData.hasOwnProperty(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', name));\n      } else {\n        context.getObject(directoryData[name].id, check_if_node_is_directory);\n      }\n    }\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  find_node(context, parentPath, read_directory_data);\n}\n\nfunction read_directory(context, path, callback) {\n  path = normalize(path);\n\n  var directoryNode;\n  var directoryData;\n\n  function handle_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      var files = Object.keys(directoryData);\n      callback(null, files);\n    }\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.type !== NODE_TYPE_DIRECTORY) {\n      callback(new Errors.ENOTDIR(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, handle_directory_data);\n    }\n  }\n\n  find_node(context, path, read_directory_data);\n}\n\nfunction make_symbolic_link(context, srcpath, dstpath, callback) {\n  dstpath = normalize(dstpath);\n  var name = basename(dstpath);\n  var parentPath = dirname(dstpath);\n\n  var directoryNode;\n  var directoryData;\n  var fileNode;\n\n  if(ROOT_DIRECTORY_NAME === name) {\n    callback(new Errors.EEXIST(null, name));\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(directoryData.hasOwnProperty(name)) {\n        callback(new Errors.EEXIST(null, name));\n      } else {\n        write_file_node();\n      }\n    }\n  }\n\n  function write_file_node() {\n    Node.create({\n      guid: context.guid,\n      type: NODE_TYPE_SYMBOLIC_LINK\n    }, function(error, result) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      fileNode = result;\n      fileNode.nlinks += 1;\n\n      // If the srcpath isn't absolute, resolve it relative to the dstpath\n      // but store both versions, since we'll use the relative one in readlink().\n      if(!isAbsolutePath(srcpath)) {\n        fileNode.symlink_relpath = srcpath;\n        srcpath = Path.resolve(parentPath, srcpath); \n      }\n\n      fileNode.size = srcpath.length;\n      fileNode.data = srcpath;\n      \n      context.putObject(fileNode.id, fileNode, update_directory_data);\n    });\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData[name] = new DirectoryEntry(fileNode.id, NODE_TYPE_SYMBOLIC_LINK);\n      context.putObject(directoryNode.data, directoryData, update_time);\n    }\n  }\n}\n\nfunction read_link(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n\n  find_node(context, parentPath, read_directory_data);\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!directoryData.hasOwnProperty(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', name));\n      } else {\n        context.getObject(directoryData[name].id, check_if_symbolic);\n      }\n    }\n  }\n\n  function check_if_symbolic(error, fileNode) {\n    if(error) {\n      callback(error);\n    } else {\n      if(fileNode.type !== NODE_TYPE_SYMBOLIC_LINK) {\n        callback(new Errors.EINVAL('path not a symbolic link', path));\n      } else {\n        // If we were originally given a relative path, return that now vs. the\n        // absolute path we've generated and use elsewhere internally.\n        var target = fileNode.symlink_relpath ? fileNode.symlink_relpath : fileNode.data;\n        callback(null, target);\n      }\n    }\n  }\n}\n\nfunction truncate_file(context, path, length, callback) {\n  path = normalize(path);\n\n  var fileNode;\n\n  function read_file_data (error, node) {\n    if (error) {\n      callback(error);\n    } else if(node.type === NODE_TYPE_DIRECTORY ) {\n      callback(new Errors.EISDIR(null, path));\n    } else{\n      fileNode = node;\n      context.getBuffer(fileNode.data, truncate_file_data);\n    }\n  }\n\n  function truncate_file_data(error, fileData) {\n    if (error) {\n      callback(error);\n    } else {\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var data = Buffer.alloc(length);\n      if(fileData) {\n        fileData.copy(data);\n      }\n      context.putBuffer(fileNode.data, data, update_file_node);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, path, fileNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_file_node (error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode.size = length;\n      fileNode.version += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  if(length < 0) {\n    callback(new Errors.EINVAL('length cannot be negative'));\n  } else {\n    find_node(context, path, read_file_data);\n  }\n}\n\nfunction ftruncate_file(context, ofd, length, callback) {\n  var fileNode;\n\n  function read_file_data (error, node) {\n    if (error) {\n      callback(error);\n    } else if(node.type === NODE_TYPE_DIRECTORY ) {\n      callback(new Errors.EISDIR());\n    } else{\n      fileNode = node;\n      context.getBuffer(fileNode.data, truncate_file_data);\n    }\n  }\n\n  function truncate_file_data(error, fileData) {\n    if (error) {\n      callback(error);\n    } else {\n      var data;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      if(fileData) {\n        data = fileData.slice(0, length);\n      } else {\n        data = Buffer.alloc(length);\n      }\n      context.putBuffer(fileNode.data, data, update_file_node);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_file_node (error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode.size = length;\n      fileNode.version += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  if(length < 0) {\n    callback(new Errors.EINVAL('length cannot be negative'));\n  } else {\n    ofd.getNode(context, read_file_data);\n  }\n}\n\nfunction utimes_file(context, path, atime, mtime, callback) {\n  path = normalize(path);\n\n  function update_times(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      update_node_times(context, path, node, { atime: atime, ctime: mtime, mtime: mtime }, callback);\n    }\n  }\n\n  if (typeof atime !== 'number' || typeof mtime !== 'number') {\n    callback(new Errors.EINVAL('atime and mtime must be number', path));\n  }\n  else if (atime < 0 || mtime < 0) {\n    callback(new Errors.EINVAL('atime and mtime must be positive integers', path));\n  }\n  else {\n    find_node(context, path, update_times);\n  }\n}\n\nfunction futimes_file(context, ofd, atime, mtime, callback) {\n\n  function update_times (error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      update_node_times(context, ofd.path, node, { atime: atime, ctime: mtime, mtime: mtime }, callback);\n    }\n  }\n\n  if (typeof atime !== 'number' || typeof mtime !== 'number') {\n    callback(new Errors.EINVAL('atime and mtime must be a number'));\n  }\n  else if (atime < 0 || mtime < 0) {\n    callback(new Errors.EINVAL('atime and mtime must be positive integers'));\n  }\n  else {\n    ofd.getNode(context, update_times);\n  }\n}\n\nfunction setxattr_file(context, path, name, value, flag, callback) {\n  path = normalize(path);\n\n  function setxattr(error, node) {\n    if(error) {\n      return callback(error);\n    }\n    set_extended_attribute(context, path, node, name, value, flag, callback);\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else if (flag !== null &&\n           flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {\n    callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE', path));\n  }\n  else {\n    find_node(context, path, setxattr);\n  }\n}\n\nfunction fsetxattr_file (context, ofd, name, value, flag, callback) {\n  function setxattr(error, node) {\n    if(error) {\n      return callback(error);\n    }\n    set_extended_attribute(context, ofd.path, node, name, value, flag, callback);\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string'));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else if (flag !== null &&\n           flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {\n    callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE'));\n  }\n  else {\n    ofd.getNode(context, setxattr);\n  }\n}\n\nfunction getxattr_file (context, path, name, callback) {\n  path = normalize(path);\n\n  function get_xattr(error, node) {\n    if(error) {\n      return callback(error);\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR(null, path));\n    }\n    else {\n      callback(null, xattrs[name]);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else {\n    find_node(context, path, get_xattr);\n  }\n}\n\nfunction fgetxattr_file (context, ofd, name, callback) {\n\n  function get_xattr (error, node) {\n    if (error) {\n      return callback(error);\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR());\n    }\n    else {\n      callback(null, xattrs[name]);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL());\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else {\n    ofd.getNode(context, get_xattr);\n  }\n}\n\nfunction removexattr_file (context, path, name, callback) {\n  path = normalize(path);\n\n  function remove_xattr (error, node) {\n    if (error) {\n      return callback(error);\n    }\n\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR(null, path));\n    }\n    else {\n      delete xattrs[name];\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else {\n    find_node(context, path, remove_xattr);\n  }\n}\n\nfunction fremovexattr_file (context, ofd, name, callback) {\n\n  function remove_xattr (error, node) {\n    if (error) {\n      return callback(error);\n    }\n\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, ofd.path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    var xattrs = node.xattrs;\n\n    if (!xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR());\n    }\n    else {\n      delete xattrs[name];\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof name !== 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string'));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else {\n    ofd.getNode(context, remove_xattr);\n  }\n}\n\nfunction validate_flags(flags) {\n  return O_FLAGS.hasOwnProperty(flags) ? O_FLAGS[flags] : null;\n}\n\nfunction validate_file_options(options, enc, fileMode){\n  if(!options) {\n    options = { encoding: enc, flag: fileMode };\n  } else if(typeof options === 'function') {\n    options = { encoding: enc, flag: fileMode };\n  } else if(typeof options === 'string') {\n    options = { encoding: options, flag: fileMode };\n  }\n  return options;\n}\n\nfunction pathCheck(path, allowRelative, callback) {\n  var err;\n\n  if(typeof allowRelative === 'function') {\n    callback = allowRelative;\n    allowRelative = false;\n  }\n\n  if(!path) {\n    err = new Errors.EINVAL('Path must be a string', path);\n  } else if(isNullPath(path)) {\n    err = new Errors.EINVAL('Path must be a string without null bytes.', path);\n  } else if(!allowRelative && !isAbsolutePath(path)) {\n    err = new Errors.EINVAL('Path must be absolute.', path);\n  }\n\n  if(err) {\n    callback(err);\n    return false;\n  }\n  return true;\n}\n\n\nfunction open(fs, context, path, flags, mode, callback) {\n  if (arguments.length < 6 ){\n    callback = arguments[arguments.length - 1];\n    mode = 0o644;\n  }\n  else {\n    mode = validateAndMaskMode(mode, FULL_READ_WRITE_EXEC_PERMISSIONS, callback);\n  }\n    \n  if(!pathCheck(path, callback)) return;\n\n  function check_result(error, fileNode) {\n    if(error) {\n      callback(error);\n    } else {\n      var position;\n      if(flags.includes(O_APPEND)) {\n        position = fileNode.size;\n      } else {\n        position = 0;\n      }\n      var openFileDescription = new OpenFileDescription(path, fileNode.id, flags, position);\n      var fd = fs.allocDescriptor(openFileDescription);\n      callback(null, fd);\n    }\n  }\n\n  flags = validate_flags(flags);\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid'), path);\n  }\n\n  open_file(context, path, flags, mode, check_result);\n}\n\nfunction close(fs, context, fd, callback) {\n  if(!fs.openFiles[fd]) {\n    callback(new Errors.EBADF());\n  } else {\n    fs.releaseDescriptor(fd);\n    callback(null);\n  }\n}\n\nfunction mknod(fs, context, path, type, callback) {\n  if(!pathCheck(path, callback)) return;\n  make_node(context, path, type, callback);\n}\n\nfunction mkdir(fs, context, path, mode, callback) {\n  if (arguments.length < 5) {\n    callback = mode;\n    mode = FULL_READ_WRITE_EXEC_PERMISSIONS;\n  } else {\n    mode = validateAndMaskMode(mode, FULL_READ_WRITE_EXEC_PERMISSIONS, callback);\n    if(!mode) return;\n  }\n \n  if(!pathCheck(path, callback)) return;\n  make_directory(context, path, callback);\n}\n\nfunction access(fs, context, path, mode, callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = Constants.fsConstants.F_OK;\n  }\n\n  if (!pathCheck(path, callback)) return;\n  mode = mode | Constants.fsConstants.F_OK;\n  access_file(context, path, mode, callback);\n}\n\nfunction mkdtemp(fs, context, prefix, options, callback) { \n  callback = arguments[arguments.length - 1];\n  if(!prefix) {\n    return callback(new Error('filename prefix is required'));\n  } \n\n  let random = shared.randomChars(6);\n  var path = prefix + '-' + random; \n\n  if(!pathCheck(path, callback)) return;\n  make_directory(context, path, function(error) {\n    callback(error, path);\n  });  \n}\n\nfunction rmdir(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  remove_directory(context, path, callback);\n}\n\nfunction stat(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(path, result, fs.name);\n      callback(null, stats);\n    }\n  }\n\n  stat_file(context, path, check_result);\n}\n\nfunction fstat(fs, context, fd, callback) {\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(ofd.path, result, fs.name);\n      callback(null, stats);\n    }\n  }\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else {\n    fstat_file(context, ofd, check_result);\n  }\n}\n\nfunction link(fs, context, oldpath, newpath, callback) {\n  if(!pathCheck(oldpath, callback)) return;\n  if(!pathCheck(newpath, callback)) return;\n  link_node(context, oldpath, newpath, callback);\n}\n\nfunction unlink(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  unlink_node(context, path, callback);\n}\n\nfunction read(fs, context, fd, buffer, offset, length, position, callback) {\n  // Follow how node.js does this\n  function wrapped_cb(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, bytesRead || 0, buffer);\n  }\n\n  offset = (undefined === offset) ? 0 : offset;\n  length = (undefined === length) ? buffer.length - offset : length;\n  callback = arguments[arguments.length - 1];\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_READ)) {\n    callback(new Errors.EBADF('descriptor does not permit reading'));\n  } else {\n    read_data(context, ofd, buffer, offset, length, position, wrapped_cb);\n  }\n}\n\nfunction fsync(fs, context, fd, callback) {\n  if(validateInteger(fd, callback) !== fd) return;\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else {\n    callback();\n  }\n}\n\nfunction readFile(fs, context, path, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, null, 'r');\n\n  if(!pathCheck(path, callback)) return;\n\n  var flags = validate_flags(options.flag || 'r');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);\n    var fd = fs.allocDescriptor(ofd);\n\n    function cleanup() {\n      fs.releaseDescriptor(fd);\n    }\n\n    fstat_file(context, ofd, function(err, fstatResult) {\n      if(err) {\n        cleanup();\n        return callback(err);\n      }\n\n      var stats = new Stats(ofd.path, fstatResult, fs.name);\n\n      if(stats.isDirectory()) {\n        cleanup();\n        return callback(new Errors.EISDIR('illegal operation on directory', path));\n      }\n\n      var size = stats.size;\n      var buffer = Buffer.alloc(size);\n\n      read_data(context, ofd, buffer, 0, size, 0, function(err) {\n        cleanup();\n\n        if(err) {\n          return callback(err);\n        }\n\n        var data;\n        if(options.encoding === 'utf8') {\n          data = Encoding.decode(buffer);\n        } else {\n          data = buffer;\n        }\n        callback(null, data);\n      });\n    });\n  });\n}\n\nfunction write(fs, context, fd, buffer, offset, length, position, callback) {\n  callback = arguments[arguments.length - 1];\n  offset = (undefined === offset) ? 0 : offset;\n  length = (undefined === length) ? buffer.length - offset : length;\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else if(buffer.length - offset < length) {\n    callback(new Errors.EIO('input buffer is too small'));\n  } else {\n    write_data(context, ofd, buffer, offset, length, position, callback);\n  }\n}\n\nfunction writeFile(fs, context, path, data, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, 'utf8', 'w');\n\n  if(!pathCheck(path, callback)) return;\n\n  var flags = validate_flags(options.flag || 'w');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  data = data || '';\n  if(typeof data === 'number') {\n    data = '' + data;\n  }\n  if(typeof data === 'string' && options.encoding === 'utf8') {\n    data = Encoding.encode(data);\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);\n    var fd = fs.allocDescriptor(ofd);\n\n    replace_data(context, ofd, data, 0, data.length, function(err) {\n      fs.releaseDescriptor(fd);\n\n      if(err) {\n        return callback(err);\n      }\n      callback(null);\n    });\n  });\n}\n\nfunction appendFile(fs, context, path, data, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, 'utf8', 'a');\n\n  if(!pathCheck(path, callback)) return;\n\n  var flags = validate_flags(options.flag || 'a');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  data = data || '';\n  if(typeof data === 'number') {\n    data = '' + data;\n  }\n  if(typeof data === 'string' && options.encoding === 'utf8') {\n    data = Encoding.encode(data);\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, fileNode.size);\n    var fd = fs.allocDescriptor(ofd);\n\n    write_data(context, ofd, data, 0, data.length, ofd.position, function(err) {\n      fs.releaseDescriptor(fd);\n\n      if(err) {\n        return callback(err);\n      }\n      callback(null);\n    });\n  });\n}\n\nfunction exists(fs, context, path, callback) {\n  function cb(err) {\n    callback(err ? false : true);\n  }\n  stat(fs, context, path, cb);\n}\n\nfunction validateInteger(value, callback) {\n  if (typeof value !== 'number') {\n    callback(new Errors.EINVAL('Expected integer', value));\n    return;\n  }\n\n  return value;\n}\n\n// Based on https://github.com/nodejs/node/blob/c700cc42da9cf73af9fec2098520a6c0a631d901/lib/internal/validators.js#L21\nvar octalReg = /^[0-7]+$/;\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n// Validator for mode_t (the S_* constants). Valid numbers or octal strings\n// will be masked with 0o777 to be consistent with the behavior in POSIX APIs.\nfunction validateAndMaskMode(value, def, callback) {\n  if(typeof def === 'function') {\n    callback = def;\n    def = undefined;\n  }\n\n  if (isUint32(value)) {\n    return value & FULL_READ_WRITE_EXEC_PERMISSIONS;\n  }\n\n  if (typeof value === 'number') {\n    if (!Number.isInteger(value)) {\n      callback(new Errors.EINVAL('mode not a valid an integer value', value));\n      return false;\n    } else {\n      // 2 ** 32 === 4294967296\n      callback(new Errors.EINVAL('mode not a valid an integer value', value));\n      return false;\n    }\n  }\n\n  if (typeof value === 'string') {\n    if (!octalReg.test(value)) {\n      callback(new Errors.EINVAL('mode not a valid octal string', value));\n      return false;\n    }\n    var parsed = parseInt(value, 8);\n    return parsed & FULL_READ_WRITE_EXEC_PERMISSIONS;\n  }\n\n  // TODO(BridgeAR): Only return `def` in case `value === null`\n  if (def !== undefined) {\n    return def;\n  }\n\n  callback(new Errors.EINVAL('mode not valid', value));\n  return false;\n}\n\nfunction chmod_file(context, path, mode, callback) {\n  path = normalize(path);\n\n  function update_mode(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.mode = mode;\n      update_node_times(context, path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  if (typeof mode !== 'number') {\n    callback(new Errors.EINVAL('mode must be number', path));\n  }\n  else {\n    find_node(context, path, update_mode);\n  }\n}\n\nfunction fchmod_file(context, ofd, mode, callback) {\n  function update_mode(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.mode = mode;\n      update_node_times(context, ofd.path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  if (typeof mode !== 'number') {\n    callback(new Errors.EINVAL('mode must be a number'));\n  }\n  else {\n    ofd.getNode(context, update_mode);\n  }\n}\n\nfunction chown_file(context, path, uid, gid, callback) {\n  path = normalize(path);\n\n  function update_owner(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.uid = uid;\n      node.gid = gid;\n      update_node_times(context, path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  find_node(context, path, update_owner);\n}\n\nfunction fchown_file(context, ofd, uid, gid, callback) {\n  function update_owner(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      node.uid = uid;\n      node.gid = gid;\n      update_node_times(context, ofd.path, node, { mtime: Date.now() }, callback);\n    }\n  }\n\n  ofd.getNode(context, update_owner);\n}\n\nfunction getxattr(fs, context, path, name, callback) {\n  if (!pathCheck(path, callback)) return;\n  getxattr_file(context, path, name, callback);\n}\n\nfunction fgetxattr(fs, context, fd, name, callback) {\n  var ofd = fs.openFiles[fd];\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else {\n    fgetxattr_file(context, ofd, name, callback);\n  }\n}\n\nfunction setxattr(fs, context, path, name, value, flag, callback) {\n  if(typeof flag === 'function') {\n    callback = flag;\n    flag = null;\n  }\n\n  if (!pathCheck(path, callback)) return;\n  setxattr_file(context, path, name, value, flag, callback);\n}\n\nfunction fsetxattr(fs, context, fd, name, value, flag, callback) {\n  if(typeof flag === 'function') {\n    callback = flag;\n    flag = null;\n  }\n\n  var ofd = fs.openFiles[fd];\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else if (!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  }\n  else {\n    fsetxattr_file(context, ofd, name, value, flag, callback);\n  }\n}\n\nfunction removexattr(fs, context, path, name, callback) {\n  if (!pathCheck(path, callback)) return;\n  removexattr_file(context, path, name, callback);\n}\n\nfunction fremovexattr(fs, context, fd, name, callback) {\n  var ofd = fs.openFiles[fd];\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else if (!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  }\n  else {\n    fremovexattr_file(context, ofd, name, callback);\n  }\n}\n\nfunction lseek(fs, context, fd, offset, whence, callback) {\n  function update_descriptor_position(error, stats) {\n    if(error) {\n      callback(error);\n    } else {\n      if(stats.size + offset < 0) {\n        callback(new Errors.EINVAL('resulting file offset would be negative'));\n      } else {\n        ofd.position = stats.size + offset;\n        callback(null, ofd.position);\n      }\n    }\n  }\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  }\n\n  if('SET' === whence) {\n    if(offset < 0) {\n      callback(new Errors.EINVAL('resulting file offset would be negative'));\n    } else {\n      ofd.position = offset;\n      callback(null, ofd.position);\n    }\n  } else if('CUR' === whence) {\n    if(ofd.position + offset < 0) {\n      callback(new Errors.EINVAL('resulting file offset would be negative'));\n    } else {\n      ofd.position += offset;\n      callback(null, ofd.position);\n    }\n  } else if('END' === whence) {\n    fstat_file(context, ofd, update_descriptor_position);\n  } else {\n    callback(new Errors.EINVAL('whence argument is not a proper value'));\n  }\n}\n\nfunction readdir(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  read_directory(context, path, callback);\n}\n\nfunction toUnixTimestamp(time) {\n  if (typeof time === 'number') {\n    return time;\n  }\n  if (typeof time === 'object' && typeof time.getTime === 'function') {\n    return time.getTime() / 1000;\n  }\n}\n\nfunction utimes(fs, context, path, atime, mtime, callback) {\n  if(!pathCheck(path, callback)) return;\n\n  var currentTime = Date.now();\n  atime = (atime) ? toUnixTimestamp(atime) : toUnixTimestamp(currentTime);\n  mtime = (mtime) ? toUnixTimestamp(mtime) : toUnixTimestamp(currentTime);\n\n  utimes_file(context, path, atime, mtime, callback);\n}\n\nfunction futimes(fs, context, fd, atime, mtime, callback) {\n  var currentTime = Date.now();\n  atime = (atime) ? toUnixTimestamp(atime) : toUnixTimestamp(currentTime);\n  mtime = (mtime) ? toUnixTimestamp(mtime) : toUnixTimestamp(currentTime);\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    futimes_file(context, ofd, atime, mtime, callback);\n  }\n}\n\nfunction chmod(fs, context, path, mode, callback) {\n  if(!pathCheck(path, callback)) return;\n  mode = validateAndMaskMode(mode, 'mode', callback);\n  if(!mode) return;\n\n  chmod_file(context, path, mode, callback);\n}\n\nfunction fchmod(fs, context, fd, mode, callback) {\n  mode = validateAndMaskMode(mode, 'mode', callback);\n  if(!mode) return;\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    fchmod_file(context, ofd, mode, callback);\n  }\n}\n\nfunction chown(fs, context, path, uid, gid, callback) {\n  if(!pathCheck(path, callback)) return;\n  if(!isUint32(uid)) {\n    return callback(new Errors.EINVAL('uid must be a valid integer', uid));\n  }\n  if(!isUint32(gid)) {\n    return callback(new Errors.EINVAL('gid must be a valid integer', gid));\n  }\n\n  chown_file(context, path, uid, gid, callback);\n}\n\nfunction fchown(fs, context, fd, uid, gid, callback) {\n  if(!isUint32(uid)) {\n    return callback(new Errors.EINVAL('uid must be a valid integer', uid));\n  }\n  if(!isUint32(gid)) {\n    return callback(new Errors.EINVAL('gid must be a valid integer', gid));\n  }\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    fchown_file(context, ofd, uid, gid, callback);\n  }\n}\n\nfunction rename(fs, context, oldpath, newpath, callback) {\n  if(!pathCheck(oldpath, callback)) return;\n  if(!pathCheck(newpath, callback)) return;\n\n  oldpath = normalize(oldpath);\n  newpath = normalize(newpath);\n\n  var oldParentPath = Path.dirname(oldpath);\n  var newParentPath = Path.dirname(oldpath);\n  var oldName = Path.basename(oldpath);\n  var newName = Path.basename(newpath);\n  var oldParentDirectory, oldParentData;\n  var newParentDirectory, newParentData;\n  var ctime = Date.now();\n  var fileNode;\n\n  function update_times(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      update_node_times(context, newpath, fileNode, { ctime: ctime }, callback);\n    }\n  }\n\n  function read_new_directory(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.getObject(newParentData[newName].id, update_times);\n    }\n  }\n\n  function update_old_parent_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      if(oldParentDirectory.id === newParentDirectory.id) {\n        oldParentData = newParentData;\n      }\n      delete oldParentData[oldName];\n      context.putObject(oldParentDirectory.data, oldParentData, read_new_directory);\n    }\n  }\n\n  function update_new_parent_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      newParentData[newName] = oldParentData[oldName];\n      context.putObject(newParentDirectory.data, newParentData, update_old_parent_directory_data);\n    }\n  }\n\n  function check_if_new_directory_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newParentData = result;\n      if(newParentData.hasOwnProperty(newName)) {\n        remove_directory(context, newpath, update_new_parent_directory_data);\n      } else {\n        update_new_parent_directory_data();\n      }\n    }\n  }\n\n  function read_new_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newParentDirectory = result;\n      context.getObject(newParentDirectory.data, check_if_new_directory_exists);\n    }\n  }\n\n  function get_new_parent_directory(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldParentData = result;\n      find_node(context, newParentPath, read_new_parent_directory_data);\n    }\n  }\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldParentDirectory = result;\n      context.getObject(result.data, get_new_parent_directory);\n    }\n  }\n\n  function unlink_old_file(error) {\n    if(error) {\n      callback(error);\n    } else {\n      unlink_node(context, oldpath, callback);\n    }\n  }\n\n  function check_node_type(error, node) {\n    if(error) {\n      callback(error);\n    } else if(node.type === NODE_TYPE_DIRECTORY) {\n      find_node(context, oldParentPath, read_parent_directory_data);\n    } else {\n      link_node(context, oldpath, newpath, unlink_old_file);\n    }\n  }\n\n  find_node(context, oldpath, check_node_type);\n}\n\nfunction symlink(fs, context, srcpath, dstpath, type, callback) {\n  // NOTE: we support passing the `type` arg, but ignore it.\n  callback = arguments[arguments.length - 1];\n\n  // Special Case: allow srcpath to be relative, which we normally don't permit.\n  // If the srcpath is relative, we assume it's relative to the dirpath of dstpath.\n  if(!pathCheck(srcpath, true, callback)) return;\n  if(!pathCheck(dstpath, callback)) return;\n\n  make_symbolic_link(context, srcpath, dstpath, callback);\n}\n\nfunction readlink(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  read_link(context, path, callback);\n}\n\nfunction lstat(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(path, result, fs.name);\n      callback(null, stats);\n    }\n  }\n\n  lstat_file(context, path, check_result);\n}\n\nfunction truncate(fs, context, path, length, callback) {\n  // NOTE: length is optional\n  callback = arguments[arguments.length - 1];\n  length = length || 0;\n\n  if(!pathCheck(path, callback)) return;\n  if(validateInteger(length, callback) !== length) return;\n\n  truncate_file(context, path, length, callback);\n}\n\nfunction ftruncate(fs, context, fd, length, callback) {\n  // NOTE: length is optional\n  callback = arguments[arguments.length - 1];\n  length = length || 0;\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!ofd.flags.includes(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    if(validateInteger(length, callback) !== length) return;\n    ftruncate_file(context, ofd, length, callback);\n  }\n}\n\nmodule.exports = {\n  ensureRootDirectory: ensure_root_directory,\n  open: open,\n  chmod: chmod,\n  access: access,\n  fchmod: fchmod,\n  chown: chown,\n  fchown: fchown,\n  close: close,\n  mknod: mknod,\n  mkdir: mkdir,\n  mkdtemp: mkdtemp,\n  rmdir: rmdir,\n  unlink: unlink,\n  stat: stat,\n  fstat: fstat,\n  link: link,\n  fsync: fsync,\n  read: read,\n  readFile: readFile,\n  write: write,\n  writeFile: writeFile,\n  appendFile: appendFile,\n  exists: exists,\n  getxattr: getxattr,\n  fgetxattr: fgetxattr,\n  setxattr: setxattr,\n  fsetxattr: fsetxattr,\n  removexattr: removexattr,\n  fremovexattr: fremovexattr,\n  lseek: lseek,\n  readdir: readdir,\n  utimes: utimes,\n  futimes: futimes,\n  rename: rename,\n  symlink: symlink,\n  readlink: readlink,\n  lstat: lstat,\n  truncate: truncate,\n  ftruncate: ftruncate\n};\n","var { promisify } = require('es6-promisify');\n\nvar isNullPath = require('../path.js').isNull;\nvar nop = require('../shared.js').nop;\n\nvar Constants = require('../constants.js');\nvar FILE_SYSTEM_NAME = Constants.FILE_SYSTEM_NAME;\nvar FS_FORMAT = Constants.FS_FORMAT;\nvar FS_READY = Constants.FS_READY;\nvar FS_PENDING = Constants.FS_PENDING;\nvar FS_ERROR = Constants.FS_ERROR;\nvar FS_NODUPEIDCHECK = Constants.FS_NODUPEIDCHECK;\n\nvar providers = require('../providers/index.js');\n\nvar Shell = require('../shell/shell.js');\nvar Intercom = require('../../lib/intercom.js');\nvar FSWatcher = require('../fs-watcher.js');\nvar Errors = require('../errors.js');\nvar defaultGuidFn = require('../shared.js').guid;\n\nvar STDIN = Constants.STDIN;\nvar STDOUT = Constants.STDOUT;\nvar STDERR = Constants.STDERR;\nvar FIRST_DESCRIPTOR = Constants.FIRST_DESCRIPTOR;\n\n// The core fs operations live on impl\nvar impl = require('./implementation.js');\n\n// node.js supports a calling pattern that leaves off a callback.\nfunction maybeCallback(callback) {\n  if(typeof callback === 'function') {\n    return callback;\n  }\n  return function(err) {\n    if(err) {\n      throw err;\n    }\n  };\n}\n\n// Default callback that logs an error if passed in\nfunction defaultCallback(err) {\n  if(err) {\n    /* eslint no-console: 0 */\n    console.error('Filer error: ', err);\n  }\n}\n\n/**\n * FileSystem\n *\n * A FileSystem takes an `options` object, which can specify a number of,\n * options.  All options are optional, and include:\n *\n * name: the name of the file system, defaults to \"local\"\n *\n * flags: one or more flags to use when creating/opening the file system.\n *        For example: \"FORMAT\" will cause the file system to be formatted.\n *        No explicit flags are set by default.\n *\n * provider: an explicit storage provider to use for the file\n *           system's database context provider.  A number of context\n *           providers are included (see /src/providers), and users\n *           can write one of their own and pass it in to be used.\n *           By default an IndexedDB provider is used.\n *\n * guid: a function for generating unique IDs for nodes in the filesystem.\n *       Use this to override the built-in UUID generation. (Used mainly for tests).\n *\n * callback: a callback function to be executed when the file system becomes\n *           ready for use. Depending on the context provider used, this might\n *           be right away, or could take some time. The callback should expect\n *           an `error` argument, which will be null if everything worked.  Also\n *           users should check the file system's `readyState` and `error`\n *           properties to make sure it is usable.\n */\nfunction FileSystem(options, callback) {\n  options = options || {};\n  callback = callback || defaultCallback;\n\n  var flags = options.flags || [];\n  var guid = options.guid ? options.guid : defaultGuidFn;\n  var provider = options.provider || new providers.Default(options.name || FILE_SYSTEM_NAME);\n  // If we're given a provider, match its name unless we get an explicit name\n  var name = options.name || provider.name;\n  var forceFormatting = flags.includes(FS_FORMAT);\n\n  var fs = this;\n  fs.readyState = FS_PENDING;\n  fs.name = name;\n  fs.error = null;\n\n  fs.stdin = STDIN;\n  fs.stdout = STDOUT;\n  fs.stderr = STDERR;\n\n  // Expose Node's fs.constants to users\n  fs.constants = Constants.fsConstants;\n\n  // Expose Shell constructor\n  this.Shell = Shell.bind(undefined, this);\n\n  // Safely expose the list of open files and file\n  // descriptor management functions\n  var openFiles = {};\n  var nextDescriptor = FIRST_DESCRIPTOR;\n  Object.defineProperty(this, 'openFiles', {\n    get: function() { return openFiles; }\n  });\n  this.allocDescriptor = function(openFileDescription) {\n    var fd = nextDescriptor ++;\n    openFiles[fd] = openFileDescription;\n    return fd;\n  };\n  this.releaseDescriptor = function(fd) {\n    delete openFiles[fd];\n  };\n\n  // Safely expose the operation queue\n  var queue = [];\n  this.queueOrRun = function(operation) {\n    var error;\n\n    if(FS_READY === fs.readyState) {\n      operation.call(fs);\n    } else if(FS_ERROR === fs.readyState) {\n      error = new Errors.EFILESYSTEMERROR('unknown error');\n    } else {\n      queue.push(operation);\n    }\n\n    return error;\n  };\n  function runQueued() {\n    queue.forEach(function(operation) {\n      operation.call(this);\n    }.bind(fs));\n    queue = null;\n  }\n\n  // We support the optional `options` arg from node, but ignore it\n  this.watch = function(filename, options, listener) {\n    if(isNullPath(filename)) {\n      throw new Error('Path must be a string without null bytes.');\n    }\n    if(typeof options === 'function') {\n      listener = options;\n      options = {};\n    }\n    options = options || {};\n    listener = listener || nop;\n\n    var watcher = new FSWatcher();\n    watcher.start(filename, false, options.recursive);\n    watcher.on('change', listener);\n\n    return watcher;\n  };\n\n  // Deal with various approaches to node ID creation\n  function wrappedGuidFn(context) {\n    return function(callback) {\n      // Skip the duplicate ID check if asked to\n      if(flags.includes(FS_NODUPEIDCHECK)) {\n        callback(null, guid());\n        return;\n      }\n\n      // Otherwise (default) make sure this id is unused first\n      function guidWithCheck(callback) {\n        var id = guid();\n        context.getObject(id, function(err, value) {\n          if(err) {\n            callback(err);\n            return;\n          }\n\n          // If this id is unused, use it, otherwise find another\n          if(!value) {\n            callback(null, id);\n          } else {\n            guidWithCheck(callback);\n          }\n        });\n      }\n      guidWithCheck(callback);\n    };\n  }\n\n  // Let other instances (in this or other windows) know about\n  // any changes to this fs instance.\n  function broadcastChanges(changes) {\n    if(!changes.length) {\n      return;\n    }\n    var intercom = Intercom.getInstance();\n    changes.forEach(function(change) {\n      intercom.emit(change.event, change.path);\n    });\n  }\n\n  // Open file system storage provider\n  provider.open(function(err) {\n    function complete(error) {\n      function wrappedContext(methodName) {\n        var context = provider[methodName]();\n        context.flags = flags;\n        context.changes = [];\n        context.guid = wrappedGuidFn(context);\n\n        // When the context is finished, let the fs deal with any change events\n        context.close = function() {\n          var changes = context.changes;\n          broadcastChanges(changes);\n          changes.length = 0;\n        };\n\n        return context;\n      }\n\n      // Wrap the provider so we can extend the context with fs flags and\n      // an array of changes (e.g., watch event 'change' and 'rename' events\n      // for paths updated during the lifetime of the context). From this\n      // point forward we won't call open again, so it's safe to drop it.\n      fs.provider = {\n        openReadWriteContext: function() {\n          return wrappedContext('getReadWriteContext');\n        },\n        openReadOnlyContext: function() {\n          return wrappedContext('getReadOnlyContext');\n        }\n      };\n\n      if(error) {\n        fs.readyState = FS_ERROR;\n      } else {\n        fs.readyState = FS_READY;\n      }\n      runQueued();\n      callback(error, fs);\n    }\n\n    if(err) {\n      return complete(err);\n    }\n\n    var context = provider.getReadWriteContext();\n    context.guid = wrappedGuidFn(context);\n\n    // Mount the filesystem, formatting if necessary\n    if(forceFormatting) {\n      // Wipe the storage provider, then write root block\n      context.clear(function(err) {\n        if(err) {\n          return complete(err);\n        }\n        impl.ensureRootDirectory(context, complete);\n      });\n    } else {\n      // Use existing (or create new) root and mount\n      impl.ensureRootDirectory(context, complete);\n    }\n  });\n  FileSystem.prototype.promises = {};\n  /**\n   * Public API for FileSystem. All node.js methods that are\n   * exposed on fs.promises include `promise: true`.  We also\n   * include our own extra methods, but skip the fd versions\n   * to match node.js, which puts these on a FileHandle object.\n   */\n  [\n    { name: 'open', promises: true },\n    { name: 'access', promises: true },\n    { name: 'chmod', promises: true },\n    { name: 'fchmod' },\n    { name: 'chown', promises: true },\n    { name: 'fchown' },\n    { name: 'close' },\n    { name: 'mknod', promises: true },\n    { name: 'mkdir', promises: true },\n    { name: 'mkdtemp', promises: true },\n    { name: 'rmdir', promises: true },\n    { name: 'stat', promises: true },\n    { name: 'fstat' },\n    { name: 'fsync' },\n    { name: 'link', promises: true },\n    { name: 'unlink', promises: true },\n    { name: 'read' },\n    { name: 'readFile', promises: true },\n    { name: 'write' },\n    { name: 'writeFile', promises: true },\n    { name: 'appendFile', promises: true },\n    { name: 'exists' },\n    { name: 'lseek' },\n    { name: 'readdir', promises: true },\n    { name: 'rename', promises: true },\n    { name: 'readlink', promises: true },\n    { name: 'symlink', promises: true },\n    { name: 'lstat', promises: true },\n    { name: 'truncate', promises: true },\n    { name: 'ftruncate' },\n    { name: 'utimes', promises: true },\n    { name: 'futimes' },\n    { name: 'setxattr', promises: true },\n    { name: 'getxattr', promises: true },\n    { name: 'fsetxattr' },\n    { name: 'fgetxattr' },\n    { name: 'removexattr', promises: true },\n    { name: 'fremovexattr' }\n  ].forEach(function(method) {\n    var methodName = method.name;\n    var shouldPromisify = method.promises === true;\n\n    FileSystem.prototype[methodName] = function() {\n      var fs = this;\n      var args = Array.prototype.slice.call(arguments, 0);\n      var lastArgIndex = args.length - 1;\n\n      // We may or may not get a callback, and since node.js supports\n      // fire-and-forget style fs operations, we have to dance a bit here.\n      var missingCallback = typeof args[lastArgIndex] !== 'function';\n      var callback = maybeCallback(args[lastArgIndex]);\n\n      var error = fs.queueOrRun(function() {\n        var context = fs.provider.openReadWriteContext();\n\n        // Fail early if the filesystem is in an error state (e.g.,\n        // provider failed to open.\n        if(FS_ERROR === fs.readyState) {\n          var err = new Errors.EFILESYSTEMERROR('filesystem unavailable, operation canceled');\n          return callback.call(fs, err);\n        }\n\n        // Wrap the callback so we can explicitly close the context\n        function complete() {\n          context.close();\n          callback.apply(fs, arguments);\n        }\n\n        // Either add or replace the callback with our wrapper complete()\n        if(missingCallback) {\n          args.push(complete);\n        } else {\n          args[lastArgIndex] = complete;\n        }\n\n        // Forward this call to the impl's version, using the following\n        // call signature, with complete() as the callback/last-arg now:\n        // fn(fs, context, arg0, arg1, ... , complete);\n        var fnArgs = [fs, context].concat(args);\n        impl[methodName].apply(null, fnArgs);\n      });\n      if(error) {\n        callback(error);\n      }\n    };\n    \n    // Add to fs.promises if appropriate\n    if(shouldPromisify) {\n      FileSystem.prototype.promises[methodName] = promisify(FileSystem.prototype[methodName].bind(fs));\n    }\n  });\n\n}\n\n// Expose storage providers on FileSystem constructor\nFileSystem.providers = providers;\n\nmodule.exports = FileSystem;\n","module.exports = {\n  FileSystem: require('./filesystem/interface.js'),\n  Buffer: Buffer,\n  Path: require('./path.js'),\n  Errors: require('./errors.js'),\n  Shell: require('./shell/shell.js')\n};\n"]}
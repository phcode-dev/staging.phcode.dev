{"version":3,"sources":["thirdparty/mustache/mustache.js"],"names":["root","factory","exports","mustache","define","amd","Mustache","this","whiteRe","spaceRe","nonSpaceRe","eqRe","curlyRe","tagRe","RegExp_test","RegExp","prototype","test","testRegExp","re","string","call","isWhitespace","Object_toString","Object","toString","isArray","Array","obj","escapeRegExp","replace","entityMap","&","<",">","\"","'","/","escapeHtml","String","s","Scanner","tail","pos","Context","view","parent","_cache","Writer","clearCache","renderTokens","tokens","writer","context","template","buffer","token","tokenValue","value","i","len","length","lookup","j","jlen","push","text","slice","render","getPartial","escape","nestTokens","tree","collector","sections","section","pop","squashTokens","squashedTokens","lastToken","escapeTags","tags","parseTemplate","split","Error","join","tagRes","scanner","spaces","hasTag","nonSpace","start","type","chr","openSection","stripSpace","eos","scanUntil","charAt","scan","match","index","substring","search","make","name","indexOf","names","_partialCache","compile","fn","parse","compileTokens","compilePartial","_loadPartial","self","partials","version","defaultWriter","to_html","send","result"],"mappings":"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","sourcesContent":["/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\n(function (root, factory) {\n  if (typeof exports === \"object\" && exports) {\n    factory(exports); // CommonJS\n  } else {\n    var mustache = {};\n    factory(mustache);\n    if (typeof define === \"function\" && define.amd) {\n      define(mustache); // AMD\n    } else {\n      root.Mustache = mustache; // <script>\n    }\n  }\n}(this, function (mustache) {\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var nonSpaceRe = /\\S/;\n  var eqRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var RegExp_test = RegExp.prototype.test;\n  function testRegExp(re, string) {\n    return RegExp_test.call(re, string);\n  }\n\n  function isWhitespace(string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var Object_toString = Object.prototype.toString;\n  var isArray = Array.isArray || function (obj) {\n    return Object_toString.call(obj) === '[object Array]';\n  };\n\n  function escapeRegExp(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      this.tail = this.tail.substring(match[0].length);\n      this.pos += match[0].length;\n      return match[0];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var match, pos = this.tail.search(re);\n\n    switch (pos) {\n    case -1:\n      match = this.tail;\n      this.pos += this.tail.length;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, pos);\n      this.tail = this.tail.substring(pos);\n      this.pos += pos;\n    }\n\n    return match;\n  };\n\n  function Context(view, parent) {\n    this.view = view || {};\n    this.parent = parent;\n    this._cache = {};\n  }\n\n  Context.make = function (view) {\n    return (view instanceof Context) ? view : new Context(view);\n  };\n\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  Context.prototype.lookup = function (name) {\n    var value = this._cache[name];\n\n    if (!value) {\n      if (name == '.') {\n        value = this.view;\n      } else {\n        var context = this;\n\n        while (context) {\n          if (name.indexOf('.') > 0) {\n            value = context.view;\n            var names = name.split('.'), i = 0;\n            while (value && i < names.length) {\n              value = value[names[i++]];\n            }\n          } else {\n            value = context.view[name];\n          }\n\n          if (value != null) break;\n\n          context = context.parent;\n        }\n      }\n\n      this._cache[name] = value;\n    }\n\n    if (typeof value === 'function') value = value.call(this.view);\n\n    return value;\n  };\n\n  function Writer() {\n    this.clearCache();\n  }\n\n  Writer.prototype.clearCache = function () {\n    this._cache = {};\n    this._partialCache = {};\n  };\n\n  Writer.prototype.compile = function (template, tags) {\n    var fn = this._cache[template];\n\n    if (!fn) {\n      var tokens = mustache.parse(template, tags);\n      fn = this._cache[template] = this.compileTokens(tokens, template);\n    }\n\n    return fn;\n  };\n\n  Writer.prototype.compilePartial = function (name, template, tags) {\n    var fn = this.compile(template, tags);\n    this._partialCache[name] = fn;\n    return fn;\n  };\n\n  Writer.prototype.getPartial = function (name) {\n    if (!(name in this._partialCache) && this._loadPartial) {\n      this.compilePartial(name, this._loadPartial(name));\n    }\n\n    return this._partialCache[name];\n  };\n\n  Writer.prototype.compileTokens = function (tokens, template) {\n    var self = this;\n    return function (view, partials) {\n      if (partials) {\n        if (typeof partials === 'function') {\n          self._loadPartial = partials;\n        } else {\n          for (var name in partials) {\n            self.compilePartial(name, partials[name]);\n          }\n        }\n      }\n\n      return renderTokens(tokens, self, Context.make(view), template);\n    };\n  };\n\n  Writer.prototype.render = function (template, view, partials) {\n    return this.compile(template)(view, partials);\n  };\n\n  /**\n   * Low-level function that renders the given `tokens` using the given `writer`\n   * and `context`. The `template` string is only needed for templates that use\n   * higher-order sections to extract the portion of the original template that\n   * was contained in that section.\n   */\n  function renderTokens(tokens, writer, context, template) {\n    var buffer = '';\n\n    var token, tokenValue, value;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      tokenValue = token[1];\n\n      switch (token[0]) {\n      case '#':\n        value = context.lookup(tokenValue);\n\n        if (typeof value === 'object') {\n          if (isArray(value)) {\n            for (var j = 0, jlen = value.length; j < jlen; ++j) {\n              buffer += renderTokens(token[4], writer, context.push(value[j]), template);\n            }\n          } else if (value) {\n            buffer += renderTokens(token[4], writer, context.push(value), template);\n          }\n        } else if (typeof value === 'function') {\n          var text = template == null ? null : template.slice(token[3], token[5]);\n          value = value.call(context.view, text, function (template) {\n            return writer.render(template, context);\n          });\n          if (value != null) buffer += value;\n        } else if (value) {\n          buffer += renderTokens(token[4], writer, context, template);\n        }\n\n        break;\n      case '^':\n        value = context.lookup(tokenValue);\n\n        // Use JavaScript's definition of falsy. Include empty arrays.\n        // See https://github.com/janl/mustache.js/issues/186\n        if (!value || (isArray(value) && value.length === 0)) {\n          buffer += renderTokens(token[4], writer, context, template);\n        }\n\n        break;\n      case '>':\n        value = writer.getPartial(tokenValue);\n        if (typeof value === 'function') buffer += value(context);\n        break;\n      case '&':\n        value = context.lookup(tokenValue);\n        if (value != null) buffer += value;\n        break;\n      case 'name':\n        value = context.lookup(tokenValue);\n        if (value != null) buffer += mustache.escape(value);\n        break;\n      case 'text':\n        buffer += tokenValue;\n        break;\n      }\n    }\n\n    return buffer;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens(tokens) {\n    var tree = [];\n    var collector = tree;\n    var sections = [];\n\n    var token;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      switch (token[0]) {\n      case '#':\n      case '^':\n        sections.push(token);\n        collector.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        var section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : tree;\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    return tree;\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          lastToken = token;\n          squashedTokens.push(token);\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  function escapeTags(tags) {\n    return [\n      new RegExp(escapeRegExp(tags[0]) + \"\\\\s*\"),\n      new RegExp(\"\\\\s*\" + escapeRegExp(tags[1]))\n    ];\n  }\n\n  /**\n   * Breaks up the given `template` string into a tree of token objects. If\n   * `tags` is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [\"<%\", \"%>\"]). Of\n   * course, the default is to use mustaches (i.e. Mustache.tags).\n   */\n  function parseTemplate(template, tags) {\n    template = template || '';\n    tags = tags || mustache.tags;\n\n    if (typeof tags === 'string') tags = tags.split(spaceRe);\n    if (tags.length !== 2) throw new Error('Invalid tags: ' + tags.join(', '));\n\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          delete tokens[spaces.pop()];\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr, token;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(tagRes[0]);\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push(['text', chr, start, start + 1]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr == '\\n') stripSpace();\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(tagRes[0])) break;\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(eqRe);\n        scanner.scan(eqRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === '{') {\n        value = scanner.scanUntil(new RegExp('\\\\s*' + escapeRegExp('}' + tags[1])));\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(tagRes[1])) throw new Error('Unclosed tag at ' + scanner.pos);\n\n      token = [type, value, start, scanner.pos];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        if (sections.length === 0) throw new Error('Unopened section \"' + value + '\" at ' + start);\n        var openSection = sections.pop();\n        if (openSection[1] !== value) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        tags = value.split(spaceRe);\n        if (tags.length !== 2) throw new Error('Invalid tags at ' + start + ': ' + tags.join(', '));\n        tagRes = escapeTags(tags);\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    var openSection = sections.pop();\n    if (openSection) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n    tokens = squashTokens(tokens);\n\n    return nestTokens(tokens);\n  }\n\n  mustache.name = \"mustache.js\";\n  mustache.version = \"0.7.2\";\n  mustache.tags = [\"{{\", \"}}\"];\n\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n  mustache.parse = parseTemplate;\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // All Mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates and partials in the default writer.\n   */\n  mustache.clearCache = function () {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Compiles the given `template` to a reusable function using the default\n   * writer.\n   */\n  mustache.compile = function (template, tags) {\n    return defaultWriter.compile(template, tags);\n  };\n\n  /**\n   * Compiles the partial with the given `name` and `template` to a reusable\n   * function using the default writer.\n   */\n  mustache.compilePartial = function (name, template, tags) {\n    return defaultWriter.compilePartial(name, template, tags);\n  };\n\n  /**\n   * Compiles the given array of tokens (the output of a parse) to a reusable\n   * function using the default writer.\n   */\n  mustache.compileTokens = function (tokens, template) {\n    return defaultWriter.compileTokens(tokens, template);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  mustache.render = function (template, view, partials) {\n    return defaultWriter.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  mustache.to_html = function (template, view, partials, send) {\n    var result = mustache.render(template, view, partials);\n\n    if (typeof send === \"function\") {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n}));\n"],"file":"mustache.js"}
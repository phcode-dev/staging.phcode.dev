{"version":3,"sources":["language/JSUtils.js"],"names":["define","require","exports","module","_","Acorn","AcornLoose","ASTWalker","CodeMirror","Async","DocumentManager","ChangedDocumentTracker","FileSystem","FileUtils","PerfUtils","StringUtils","_changedDocumentTracker","_findAllFunctionsInText","text","AST","results","functionName","resultNode","memberPrefix","match","markStart","JSUTILS_REGEXP","parse","locations","e","_addResult","node","offset","prefix","id","key","name","Array","isArray","push","offsetStart","start","label","location","loc","simple","FunctionDeclaration","ClassDeclaration","MethodDefinition","methodNode","VariableDeclarator","init","type","AssignmentExpression","right","left","property","Property","value","LabeledStatement","body","addMeasurement","_getFunctionEndOffset","mode","getMode","state","startState","stream","style","token","curOffset","length","blockCount","lineStart","foundStartBrace","nextLine","lineEnd","indexOf","StringStream","slice","nextToken","pos","eol","current","_computeOffsets","doc","functions","rangeResults","getText","lines","getLines","forEach","funcEntry","offsetEnd","JSUTILS_END_OFFSET","offsetToLineNum","document","_readFile","fileInfo","result","getDocumentForPath","fullPath","done","allFunctions","JSUtils","timestamp","diskTimestamp","resolve","fail","error","reject","_shouldGetFromCache","$","Deferred","isChanged","isPathChanged","getOpenDocumentForPath","file","isDirty","getFileForPath","stat","err","getTime","mtime","promise","_getOffsetsForFunction","docEntries","matchedDocuments","docEntry","has","functionsInDocument","doInParallel","oneResult","fetchedDoc","always","_getFunctionsForFile","useCache","_getFunctionsInFiles","fileInfos","JSUTILS_GET_ALL_FUNCTIONS","docInfo","reset","findMatchingFunctions","keepAllFiles","jsFiles","filter","getFileExtension","toLowerCase","findAllMatchingFunctionsInText","searchName","split","endOffset","nameLineStart","line","nameLineEnd","end","columnStart","column","columnEnd","createPerfMeasurement"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Set of utilities for simple parsing of JS text.\n */\ndefine(function (require, exports, module) {\n\n\n    var _          = require(\"thirdparty/lodash\"),\n        Acorn      = require(\"thirdparty/acorn/dist/acorn\"),\n        AcornLoose = require(\"thirdparty/acorn/dist/acorn_loose\"),\n        ASTWalker  = require(\"thirdparty/acorn/dist/walk\");\n\n    // Load brackets modules\n    var CodeMirror              = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        Async                   = require(\"utils/Async\"),\n        DocumentManager         = require(\"document/DocumentManager\"),\n        ChangedDocumentTracker  = require(\"document/ChangedDocumentTracker\"),\n        FileSystem              = require(\"filesystem/FileSystem\"),\n        FileUtils               = require(\"file/FileUtils\"),\n        PerfUtils               = require(\"utils/PerfUtils\"),\n        StringUtils             = require(\"utils/StringUtils\");\n\n    /**\n     * Tracks dirty documents between invocations of findMatchingFunctions.\n     * @type {ChangedDocumentTracker}\n     */\n    var _changedDocumentTracker = new ChangedDocumentTracker();\n\n    /**\n     * @private\n     * Return an object mapping function name to offset info for all functions in the specified text.\n     * Offset info is an array, since multiple functions of the same name can exist.\n     * @param {!string} text Document text\n     * @return {Object.<string, Array.<{offsetStart: number, offsetEnd: number}>}\n     */\n    function _findAllFunctionsInText(text) {\n        var AST,\n            results = {},\n            functionName,\n            resultNode,\n            memberPrefix,\n            match;\n\n        PerfUtils.markStart(PerfUtils.JSUTILS_REGEXP);\n\n        try {\n            AST = Acorn.parse(text, {locations: true});\n        } catch (e) {\n            AST = AcornLoose.parse(text, {locations: true});\n        }\n\n        function _addResult(node, offset, prefix) {\n            memberPrefix = prefix ? prefix + \" - \" : \"\";\n            resultNode = node.id || node.key || node;\n            functionName = resultNode.name;\n            if (!Array.isArray(results[functionName])) {\n                results[functionName] = [];\n            }\n\n            results[functionName].push(\n                {\n                    offsetStart: offset || node.start,\n                    label: memberPrefix ? memberPrefix + functionName : null,\n                    location: resultNode.loc\n                }\n            );\n        }\n\n        ASTWalker.simple(AST, {\n            /*\n                function <functionName> () {}\n            */\n            FunctionDeclaration: function (node) {\n                // As acorn_loose marks identifier names with '✖' under erroneous declarations\n                // we should have a check to discard such 'FunctionDeclaration' nodes\n                if (node.id.name !== '✖') {\n                    _addResult(node);\n                }\n            },\n            /*\n                class <className> () {}\n            */\n            ClassDeclaration: function (node) {\n                _addResult(node);\n                ASTWalker.simple(node, {\n                    /*\n                        class <className> () {\n                            <methodName> () {\n\n                            }\n                        }\n                    */\n                    MethodDefinition: function (methodNode) {\n                        _addResult(methodNode, methodNode.key.start, node.id.name);\n                    }\n                });\n            },\n            /*\n                var <functionName> = function () {}\n\n                or\n\n                var <functionName> = () => {}\n            */\n            VariableDeclarator: function (node) {\n                if (node.init && (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n                    _addResult(node);\n                }\n            },\n            /*\n                SomeFunction.prototype.<functionName> = function () {}\n            */\n            AssignmentExpression: function (node) {\n                if (node.right && node.right.type === \"FunctionExpression\") {\n                    if (node.left && node.left.type === \"MemberExpression\" && node.left.property) {\n                        _addResult(node.left.property);\n                    }\n                }\n            },\n            /*\n                {\n                    <functionName>: function() {}\n                }\n            */\n            Property: function (node) {\n                if (node.value && node.value.type === \"FunctionExpression\") {\n                    if (node.key && node.key.type === \"Identifier\") {\n                        _addResult(node.key);\n                    }\n                }\n            },\n            /*\n                <functionName>: function() {}\n            */\n            LabeledStatement: function (node) {\n                if (node.body && node.body.type === \"FunctionDeclaration\") {\n                    if (node.label) {\n                        _addResult(node.label);\n                    }\n                }\n            }\n        });\n\n        PerfUtils.addMeasurement(PerfUtils.JSUTILS_REGEXP);\n\n        return results;\n    }\n\n    // Given the start offset of a function definition (before the opening brace), find\n    // the end offset for the function (the closing \"}\"). Returns the position one past the\n    // close brace. Properly ignores braces inside comments, strings, and regexp literals.\n    function _getFunctionEndOffset(text, offsetStart) {\n        var mode = CodeMirror.getMode({}, \"javascript\");\n        var state = CodeMirror.startState(mode), stream, style, token;\n        var curOffset = offsetStart, length = text.length, blockCount = 0, lineStart;\n        var foundStartBrace = false;\n\n        // Get a stream for the next line, and update curOffset and lineStart to point to the\n        // beginning of that next line. Returns false if we're at the end of the text.\n        function nextLine() {\n            if (stream) {\n                curOffset++; // account for \\n\n                if (curOffset >= length) {\n                    return false;\n                }\n            }\n            lineStart = curOffset;\n            var lineEnd = text.indexOf(\"\\n\", lineStart);\n            if (lineEnd === -1) {\n                lineEnd = length;\n            }\n            stream = new CodeMirror.StringStream(text.slice(curOffset, lineEnd));\n            return true;\n        }\n\n        // Get the next token, updating the style and token to refer to the current\n        // token, and updating the curOffset to point to the end of the token (relative\n        // to the start of the original text).\n        function nextToken() {\n            if (curOffset >= length) {\n                return false;\n            }\n            if (stream) {\n                // Set the start of the next token to the current stream position.\n                stream.start = stream.pos;\n            }\n            while (!stream || stream.eol()) {\n                if (!nextLine()) {\n                    return false;\n                }\n            }\n            style = mode.token(stream, state);\n            token = stream.current();\n            curOffset = lineStart + stream.pos;\n            return true;\n        }\n\n        while (nextToken()) {\n            if (style !== \"comment\" && style !== \"regexp\" && style !== \"string\" && style !== \"string-2\") {\n                if (token === \"{\") {\n                    foundStartBrace = true;\n                    blockCount++;\n                } else if (token === \"}\") {\n                    blockCount--;\n                }\n            }\n\n            // blockCount starts at 0, so we don't want to check if it hits 0\n            // again until we've actually gone past the start of the function body.\n            if (foundStartBrace && blockCount <= 0) {\n                return curOffset;\n            }\n        }\n\n        // Shouldn't get here, but if we do, return the end of the text as the offset.\n        return length;\n    }\n\n    /**\n     * @private\n     * Computes function offsetEnd, lineStart and lineEnd. Appends a result record to rangeResults.\n     * @param {!Document} doc\n     * @param {!string} functionName\n     * @param {!Array.<{offsetStart: number, offsetEnd: number}>} functions\n     * @param {!Array.<{document: Document, name: string, lineStart: number, lineEnd: number}>} rangeResults\n     */\n    function _computeOffsets(doc, functionName, functions, rangeResults) {\n        var text    = doc.getText(),\n            lines   = StringUtils.getLines(text);\n\n        functions.forEach(function (funcEntry) {\n            if (!funcEntry.offsetEnd) {\n                PerfUtils.markStart(PerfUtils.JSUTILS_END_OFFSET);\n\n                funcEntry.offsetEnd = _getFunctionEndOffset(text, funcEntry.offsetStart);\n                funcEntry.lineStart = StringUtils.offsetToLineNum(lines, funcEntry.offsetStart);\n                funcEntry.lineEnd   = StringUtils.offsetToLineNum(lines, funcEntry.offsetEnd);\n\n                PerfUtils.addMeasurement(PerfUtils.JSUTILS_END_OFFSET);\n            }\n\n            rangeResults.push({\n                document: doc,\n                name: functionName,\n                lineStart: funcEntry.lineStart,\n                lineEnd: funcEntry.lineEnd\n            });\n        });\n    }\n\n    /**\n     * @private\n     * Read a file and build a function list. Result is cached in fileInfo.\n     * @param {!FileInfo} fileInfo File to parse\n     * @param {!$.Deferred} result Deferred to resolve with all functions found and the document\n     */\n    function _readFile(fileInfo, result) {\n        DocumentManager.getDocumentForPath(fileInfo.fullPath)\n            .done(function (doc) {\n                var allFunctions = _findAllFunctionsInText(doc.getText());\n\n                // Cache the result in the fileInfo object\n                fileInfo.JSUtils = {};\n                fileInfo.JSUtils.functions = allFunctions;\n                fileInfo.JSUtils.timestamp = doc.diskTimestamp;\n\n                result.resolve({doc: doc, functions: allFunctions});\n            })\n            .fail(function (error) {\n                result.reject(error);\n            });\n    }\n\n    /**\n     * Determines if the document function cache is up to date.\n     * @param {FileInfo} fileInfo\n     * @return {$.Promise} A promise resolved with true with true when a function cache is available for the document. Resolves\n     *   with false when there is no cache or the cache is stale.\n     */\n    function _shouldGetFromCache(fileInfo) {\n        var result = new $.Deferred(),\n            isChanged = _changedDocumentTracker.isPathChanged(fileInfo.fullPath);\n\n        if (isChanged && fileInfo.JSUtils) {\n            // See if it's dirty and in the working set first\n            var doc = DocumentManager.getOpenDocumentForPath(fileInfo.fullPath);\n\n            if (doc && doc.isDirty) {\n                result.resolve(false);\n            } else {\n                // If a cache exists, check the timestamp on disk\n                var file = FileSystem.getFileForPath(fileInfo.fullPath);\n\n                file.stat(function (err, stat) {\n                    if (!err) {\n                        result.resolve(fileInfo.JSUtils.timestamp.getTime() === stat.mtime.getTime());\n                    } else {\n                        result.reject(err);\n                    }\n                });\n            }\n        } else {\n            // Use the cache if the file did not change and the cache exists\n            result.resolve(!isChanged && fileInfo.JSUtils);\n        }\n\n        return result.promise();\n    }\n\n    /**\n     * @private\n     * Compute lineStart and lineEnd for each matched function\n     * @param {!Array.<{doc: Document, fileInfo: FileInfo, functions: Array.<offsetStart: number, offsetEnd: number>}>} docEntries\n     * @param {!string} functionName\n     * @param {!Array.<document: Document, name: string, lineStart: number, lineEnd: number>} rangeResults\n     * @return {$.Promise} A promise resolved with an array of document ranges to populate a MultiRangeInlineEditor.\n     */\n    function _getOffsetsForFunction(docEntries, functionName) {\n        // Filter for documents that contain the named function\n        var result              = new $.Deferred(),\n            matchedDocuments    = [],\n            rangeResults        = [];\n\n        docEntries.forEach(function (docEntry) {\n            // Need to call _.has here since docEntry.functions could have an\n            // entry for \"hasOwnProperty\", which results in an error if trying\n            // to invoke docEntry.functions.hasOwnProperty().\n            if (_.has(docEntry.functions, functionName)) {\n                var functionsInDocument = docEntry.functions[functionName];\n                matchedDocuments.push({doc: docEntry.doc, fileInfo: docEntry.fileInfo, functions: functionsInDocument});\n            }\n        });\n\n        Async.doInParallel(matchedDocuments, function (docEntry) {\n            var doc         = docEntry.doc,\n                oneResult   = new $.Deferred();\n\n            // doc will be undefined if we hit the cache\n            if (!doc) {\n                DocumentManager.getDocumentForPath(docEntry.fileInfo.fullPath)\n                    .done(function (fetchedDoc) {\n                        _computeOffsets(fetchedDoc, functionName, docEntry.functions, rangeResults);\n                    })\n                    .always(function () {\n                        oneResult.resolve();\n                    });\n            } else {\n                _computeOffsets(doc, functionName, docEntry.functions, rangeResults);\n                oneResult.resolve();\n            }\n\n            return oneResult.promise();\n        }).done(function () {\n            result.resolve(rangeResults);\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Resolves with a record containing the Document or FileInfo and an Array of all\n     * function names with offsets for the specified file. Results may be cached.\n     * @param {FileInfo} fileInfo\n     * @return {$.Promise} A promise resolved with a document info object that\n     *   contains a map of all function names from the document and each function's start offset.\n     */\n    function _getFunctionsForFile(fileInfo) {\n        var result = new $.Deferred();\n\n        _shouldGetFromCache(fileInfo)\n            .done(function (useCache) {\n                if (useCache) {\n                    // Return cached data. doc property is undefined since we hit the cache.\n                    // _getOffsets() will fetch the Document if necessary.\n                    result.resolve({/*doc: undefined,*/fileInfo: fileInfo, functions: fileInfo.JSUtils.functions});\n                } else {\n                    _readFile(fileInfo, result);\n                }\n            }).fail(function (err) {\n                result.reject(err);\n            });\n\n        return result.promise();\n    }\n\n    /**\n     * @private\n     * Get all functions for each FileInfo.\n     * @param {Array.<FileInfo>} fileInfos\n     * @return {$.Promise} A promise resolved with an array of document info objects that each\n     *   contain a map of all function names from the document and each function's start offset.\n     */\n    function _getFunctionsInFiles(fileInfos) {\n        var result      = new $.Deferred(),\n            docEntries  = [];\n\n        PerfUtils.markStart(PerfUtils.JSUTILS_GET_ALL_FUNCTIONS);\n\n        Async.doInParallel(fileInfos, function (fileInfo) {\n            var oneResult = new $.Deferred();\n\n            _getFunctionsForFile(fileInfo)\n                .done(function (docInfo) {\n                    docEntries.push(docInfo);\n                })\n                .always(function (error) {\n                    // If one file fails, continue to search\n                    oneResult.resolve();\n                });\n\n            return oneResult.promise();\n        }).always(function () {\n            // Reset ChangedDocumentTracker now that the cache is up to date.\n            _changedDocumentTracker.reset();\n\n            PerfUtils.addMeasurement(PerfUtils.JSUTILS_GET_ALL_FUNCTIONS);\n            result.resolve(docEntries);\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Return all functions that have the specified name, searching across all the given files.\n     *\n     * @param {!String} functionName The name to match.\n     * @param {!Array.<File>} fileInfos The array of files to search.\n     * @param {boolean=} keepAllFiles If true, don't ignore non-javascript files.\n     * @return {$.Promise} that will be resolved with an Array of objects containing the\n     *      source document, start line, and end line (0-based, inclusive range) for each matching function list.\n     *      Does not addRef() the documents returned in the array.\n     */\n    function findMatchingFunctions(functionName, fileInfos, keepAllFiles) {\n        var result  = new $.Deferred(),\n            jsFiles = [];\n\n        if (!keepAllFiles) {\n            // Filter fileInfos for .js files\n            jsFiles = fileInfos.filter(function (fileInfo) {\n                return FileUtils.getFileExtension(fileInfo.fullPath).toLowerCase() === \"js\";\n            });\n        } else {\n            jsFiles = fileInfos;\n        }\n\n        // RegExp search (or cache lookup) for all functions in the project\n        _getFunctionsInFiles(jsFiles).done(function (docEntries) {\n            // Compute offsets for all matched functions\n            _getOffsetsForFunction(docEntries, functionName).done(function (rangeResults) {\n                result.resolve(rangeResults);\n            });\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Finds all instances of the specified searchName in \"text\".\n     * Returns an Array of Objects with start and end properties.\n     *\n     * @param text {!String} JS text to search\n     * @param searchName {!String} function name to search for\n     * @return {Array.<{offset:number, functionName:string}>}\n     *      Array of objects containing the start offset for each matched function name.\n     */\n    function findAllMatchingFunctionsInText(text, searchName) {\n        var allFunctions = _findAllFunctionsInText(text);\n        var result = [];\n        var lines = text.split(\"\\n\");\n\n        _.forEach(allFunctions, function (functions, functionName) {\n            if (functionName === searchName || searchName === \"*\") {\n                functions.forEach(function (funcEntry) {\n                    var endOffset = _getFunctionEndOffset(text, funcEntry.offsetStart);\n                    result.push({\n                        name: functionName,\n                        label: funcEntry.label,\n                        lineStart: StringUtils.offsetToLineNum(lines, funcEntry.offsetStart),\n                        lineEnd: StringUtils.offsetToLineNum(lines, endOffset),\n                        nameLineStart: funcEntry.location.start.line - 1,\n                        nameLineEnd: funcEntry.location.end.line - 1,\n                        columnStart: funcEntry.location.start.column,\n                        columnEnd: funcEntry.location.end.column\n                    });\n                });\n            }\n        });\n\n        return result;\n    }\n\n    PerfUtils.createPerfMeasurement(\"JSUTILS_GET_ALL_FUNCTIONS\", \"Parallel file search across project\");\n    PerfUtils.createPerfMeasurement(\"JSUTILS_REGEXP\", \"RegExp search for all functions\");\n    PerfUtils.createPerfMeasurement(\"JSUTILS_END_OFFSET\", \"Find end offset for a single matched function\");\n\n    exports.findAllMatchingFunctionsInText = findAllMatchingFunctionsInText;\n    exports._getFunctionEndOffset = _getFunctionEndOffset; // For testing only\n    exports.findMatchingFunctions = findMatchingFunctions;\n});\n"],"file":"JSUtils.js"}
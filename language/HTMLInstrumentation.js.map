{"version":3,"sources":["language/HTMLInstrumentation.js"],"names":["define","require","exports","module","DocumentManager","HTMLSimpleDOM","HTMLDOMDiff","_","allowIncremental","_cachedValues","_removeDocFromCache","evt","document","hasOwnProperty","file","fullPath","off","_posEq","pos1","pos2","line","ch","getPositionFromTagId","editor","tagId","marks","_codeMirror","getAllMarks","i","markFound","find","mark","tagID","from","_getSortedTagMarks","markCache","filter","map","range","sort","mark1","mark2","_getMarkerAtDocumentPos","pos","preferParent","match","findMarksAt","length","pop","to","_dumpMarks","nodeMap","forEach","markInfo","console","log","tag","_getTagIDAtDocumentPos","_markTags","cm","node","children","childNode","isElement","markText","startPos","endPos","_markTextFromDOM","dom","operation","clear","DOMUpdater","previousDOM","changeList","text","startOffset","startOffsetPos","isDangerousEdit","test","this","isIncremental","change","removed","startMark","getRange","changedTagID","indexFromPos","getText","Builder","call","_hasAncestorWithID","id","ancestor","parent","_updateDOM","undefined","updater","result","update","errors","edits","domdiff","oldSubtree","newSubtree","newDOM","_wasIncremental","getUnappliedEditList","cachedValue","invalid","timestamp","diskTimestamp","dirty","_processBrowserSimpleDOM","browserRoot","editorRootTagID","root","_processElement","elem","attributes","child","isText","getTextNodeID","_getBrowserDiff","browserSimpleDOM","editorRoot","diff","browser","scanDocument","doc","on","isDirty","build","generateInstrumentedHTML","orig","gen","lastIndex","walk","attrText","insertIndex","start","substr","_markText","cache","error","_resetCache","prototype","Object","create","getID","newTag","currentTagID","_offsetPos","getNewID","oldNode","_updateMarkedRanges","updateIDs","keys","splice","indexOf","String","Number","_buildNodeMap","_handleDeletions","oldSubtreeMap","newSubtreeMap","deletedIDs","key","push","childIndex","$","extend","curParent","_allowIncremental"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: HTML Instrumentation*/\n\n/**\n * HTMLInstrumentation\n *\n * This module contains functions for \"instrumenting\" html code so that we can track\n * the relationship of source code to DOM nodes in the browser. This functionality is\n * used by both live highlighting and live HTML editing.\n *\n * During live HTML development, the HTML source code is parsed to identify tag boundaries.\n * Each tag is assigned an ID which is stored in markers that are inserted into the editor.\n * These IDs are also included in \"data-brackets-id\" attributes that are inserted in the\n * HTML code that's served to the browser via the Live Development server.\n *\n * The primary function for that functionality is generateInstrumentedHTML(). This does just\n * what it says - it will read the HTML content in the doc and generate instrumented code by\n * injecting \"data-brackets-id\" attributes. Additionally, it caches the parsed DOM for use\n * by future updates.\n *\n * As the user makes edits in the editor, we determine how the DOM structure should change\n * based on the edits to the source code; those edits are generated by getUnappliedEditList().\n * HTMLDocument (in LiveDevelopment) takes those edits and sends them to the browser (via\n * RemoteFunctions) so that the DOM structure in the live preview can be updated accordingly.\n *\n * There are also helper functions for returning the tagID associated with a specified\n * position in the document--this is used in live highlighting.\n */\ndefine(function (require, exports, module) {\n\n\n    var DocumentManager = require(\"document/DocumentManager\"),\n        HTMLSimpleDOM   = require(\"./HTMLSimpleDOM\"),\n        HTMLDOMDiff     = require(\"./HTMLDOMDiff\"),\n        _               = require(\"thirdparty/lodash\");\n\n    var allowIncremental = true;\n\n    // Hash of scanned documents. Key is the full path of the doc. Value is an object\n    // with two properties: timestamp and dom. Timestamp is the document timestamp,\n    // dom is the root node of a simple DOM tree.\n    var _cachedValues = {};\n\n    /**\n     * @private\n     * Removes the cached information (DOM, timestamp, etc.) used by HTMLInstrumentation\n     * for the given document.\n     * @param {$.Event} event (unused)\n     * @param {Document} document The document to clear from the cache.\n     */\n    function _removeDocFromCache(evt, document) {\n        if (_cachedValues.hasOwnProperty(document.file.fullPath)) {\n            delete _cachedValues[document.file.fullPath];\n            document.off(\".htmlInstrumentation\");\n        }\n    }\n\n    /**\n     * @private\n     * Checks if two CodeMirror-style {line, ch} positions are equal.\n     * @param {{line: number, ch: number}} pos1\n     * @param {{line: number, ch: number}} pos2\n     * @return {boolean} true if pos1 and pos2 are equal. Fails if either of them is falsy.\n     */\n    function _posEq(pos1, pos2) {\n        return pos1 && pos2 && pos1.line === pos2.line && pos1.ch === pos2.ch;\n    }\n\n    function getPositionFromTagId(editor, tagId) {\n        var marks = editor._codeMirror.getAllMarks(),\n            i,\n            markFound;\n\n        markFound = _.find(marks, function (mark) {\n            return (mark.tagID === tagId);\n        });\n        if (markFound) {\n            return markFound.find().from;\n        }\n        return null;\n\n    }\n\n    /**\n     * @private\n     * Filters the given marks to find the ones that correspond to instrumented tags,\n     * sorts them by their starting position, and looks up and/or stores their ranges\n     * in the given markCache.\n     * @param {Array} marks An array of mark objects returned by CodeMirror.\n     * @param {Object} markCache An object that maps tag IDs to {mark, range} objects.\n     *     If a mark in the marks array is already in the cache, we use the cached range info,\n     *     otherwise we look up its range in CodeMirror and store it in the cache.\n     * @return {Array.<{mark: Object, range: {line: number, ch: number}}>} The filtered and\n     *     sorted array of mark info objects (each of which contains the mark and its range,\n     *     so the range doesn't need to be looked up again).\n     */\n    function _getSortedTagMarks(marks, markCache) {\n        marks = marks.filter(function (mark) {\n            return !!mark.tagID;\n        }).map(function (mark) {\n            // All marks should exist since we just got them from CodeMirror.\n            if (!markCache[mark.tagID]) {\n                markCache[mark.tagID] = {mark: mark, range: mark.find()};\n            }\n            return markCache[mark.tagID];\n        });\n        marks.sort(function (mark1, mark2) {\n            return (mark1.range.from.line === mark2.range.from.line ?\n                    mark1.range.from.ch - mark2.range.from.ch :\n                    mark1.range.from.line - mark2.range.from.line);\n        });\n\n        return marks;\n    }\n\n    /**\n     * @private\n     * Finds the mark for the DOM node at the given position in the editor.\n     * @param {Editor} editor The editor containing the instrumented document.\n     * @param {{line: number, ch: number}} pos The position to find the DOM marker for.\n     * @param {boolean} preferParent If true, and the pos is at one or the other edge of the\n     *     innermost marked range, return the immediately enclosing mark instead.\n     * @param {Object=} markCache An optional cache to look up positions of existing\n     *     markers. (This avoids calling the find() operation on marks multiple times,\n     *     which is expensive.)\n     * @return {Object} The CodeMirror mark object that represents the DOM node at the\n     *     given position.\n     */\n    function _getMarkerAtDocumentPos(editor, pos, preferParent, markCache) {\n        var marks, match;\n\n        markCache = markCache || {};\n        marks = _getSortedTagMarks(editor._codeMirror.findMarksAt(pos), markCache);\n        if (!marks.length) {\n            return null;\n        }\n\n        // The mark with the latest start is the innermost one.\n        match = marks.pop();\n        if (preferParent) {\n            // If the match is exactly at the edge of the range and preferParent is set,\n            // we want to pop upwards. If pos is exactly between two marks, we need to pop upwards twice.\n            while (match && (_posEq(match.range.from, pos) || _posEq(match.range.to, pos))) {\n                match = marks.pop();\n            }\n        }\n\n        return match && match.mark;\n    }\n\n    /**\n     * @private\n     * Dumps the current list of mark ranges for instrumented tags to the console. Used for debugging.\n     * @param {Editor} editor The editor to find the mark ranges for.\n     * @param {Object=} nodeMap If specified, a map of tag IDs to DOM nodes, used so we can indicate which tag name\n     *     the DOM thinks corresponds to the given mark.\n     */\n    function _dumpMarks(editor, nodeMap) {\n        var markCache = {},\n            marks = _getSortedTagMarks(editor._codeMirror.getAllMarks(), markCache);\n        marks.forEach(function (markInfo) {\n            var mark = markInfo.mark,\n                range = markInfo.range;\n            console.log(\"<\" + nodeMap[mark.tagID].tag + \"> (\" + mark.tagID + \") \" +\n                        range.from.line + \":\" + range.from.ch + \" - \" + range.to.line + \":\" + range.to.ch);\n        });\n    }\n    // Workaround for JSHint to not complain about the unused function\n    void(_dumpMarks);\n\n    /**\n     * Get the instrumented tagID at the specified position. Returns -1 if\n     * there are no instrumented tags at the location.\n     * The _markText() function must be called before calling this function.\n     *\n     * NOTE: This function is \"private\" for now (has a leading underscore), since\n     * the API is likely to change in the future.\n     *\n     * @param {Editor} editor The editor to scan.\n     * @param {{line: number, ch: number}} pos The position to find the DOM marker for.\n     * @param {Object=} markCache An optional cache to look up positions of existing\n     *     markers. (This avoids calling the find() operation on marks multiple times,\n     *     which is expensive.)\n     * @return {number} tagID at the specified position, or -1 if there is no tag\n     */\n    function _getTagIDAtDocumentPos(editor, pos, markCache) {\n        var match = _getMarkerAtDocumentPos(editor, pos, false, markCache);\n\n        return (match) ? match.tagID : -1;\n    }\n\n    /**\n     * Recursively walks the SimpleDOM starting at node and marking\n     * all tags in the CodeMirror instance. The more useful interface\n     * is the _markTextFromDOM function which clears existing marks\n     * before calling this function to create new ones.\n     *\n     * @param {CodeMirror} cm CodeMirror instance in which to mark tags\n     * @param {Object} node SimpleDOM node to use as the root for marking\n     */\n    function _markTags(cm, node) {\n        node.children.forEach(function (childNode) {\n            if (childNode.isElement()) {\n                _markTags(cm, childNode);\n            }\n        });\n        var mark = cm.markText(node.startPos, node.endPos);\n        mark.tagID = node.tagID;\n    }\n\n    /**\n     * Clears the marks from the document and creates new ones.\n     *\n     * @param {Editor} editor Editor object holding this document\n     * @param {Object} dom SimpleDOM root object that contains the parsed structure\n     */\n    function _markTextFromDOM(editor, dom) {\n        var cm = editor._codeMirror;\n\n        // Remove existing marks\n        var marks = cm.getAllMarks();\n        cm.operation(function () {\n            marks.forEach(function (mark) {\n                if (mark.hasOwnProperty(\"tagID\")) {\n                    mark.clear();\n                }\n            });\n        });\n\n        // Mark\n        _markTags(cm, dom);\n    }\n\n    /**\n     * Subclass of HTMLSimpleDOM.Builder that builds an updated DOM after changes have been made,\n     * and maps nodes from the new DOM to the old DOM by tag ID. For non-structural edits, avoids reparsing\n     * the whole editor. Also updates marks in the editor based on the new DOM state.\n     *\n     * @constructor\n     * @param {Object} previousDOM The root of the HTMLSimpleDOM tree representing a previous state of the DOM.\n     * @param {Editor} editor The editor containing the instrumented HTML.\n     * @param {Array=} changeList An optional array of CodeMirror change records representing the\n     *     edits the user made in the editor since previousDOM was built. If provided, and the\n     *     edits are not structural, DOMUpdater will do a fast incremental reparse. If not provided,\n     *     or if one of the edits changes the DOM structure, DOMUpdater will reparse the whole DOM.\n     */\n    function DOMUpdater(previousDOM, editor, changeList) {\n        var text, startOffset = 0, startOffsetPos;\n\n        this.isIncremental = false;\n\n        function isDangerousEdit(text) {\n            // We don't consider & dangerous since entities only affect text content, not\n            // overall DOM structure.\n            return (/[<>\\/=\\\"\\']/).test(text);\n        }\n\n        // If there's more than one change, be conservative and assume we have to do a full reparse.\n        if (changeList && changeList.length === 1) {\n            // If the inserted or removed text doesn't have any characters that could change the\n            // structure of the DOM (e.g. by adding or removing a tag boundary), then we can do\n            // an incremental reparse of just the parent tag containing the edit. This should just\n            // be the marked range that contains the beginning of the edit range, since that position\n            // isn't changed by the edit.\n            var change = changeList[0];\n            if (!isDangerousEdit(change.text) && !isDangerousEdit(change.removed)) {\n                // If the edit is right at the beginning or end of a tag, we want to be conservative\n                // and use the parent as the edit range.\n                var startMark = _getMarkerAtDocumentPos(editor, change.from, true);\n                if (startMark) {\n                    var range = startMark.find();\n                    if (range) {\n                        text = editor._codeMirror.getRange(range.from, range.to);\n                        this.changedTagID = startMark.tagID;\n                        startOffsetPos = range.from;\n                        startOffset = editor._codeMirror.indexFromPos(startOffsetPos);\n                        this.isIncremental = true;\n                    }\n                }\n            }\n        }\n\n        if (!this.changedTagID) {\n            // We weren't able to incrementally update, so just rebuild and diff everything.\n            text = editor.document.getText();\n        }\n\n        HTMLSimpleDOM.Builder.call(this, text, startOffset, startOffsetPos);\n        this.editor = editor;\n        this.cm = editor._codeMirror;\n        this.previousDOM = previousDOM;\n    }\n\n    DOMUpdater.prototype = Object.create(HTMLSimpleDOM.Builder.prototype);\n\n    /**\n     * @private\n     * Returns true if the given node has an ancestor whose tagID is the given ID.\n     * @param {Object} node A node from an HTMLSimpleDOM structure.\n     * @param {number} id The ID of the tag to check for.\n     * @return {boolean} true if the node has an ancestor with that ID.\n     */\n    function _hasAncestorWithID(node, id) {\n        var ancestor = node.parent;\n        while (ancestor && ancestor.tagID !== id) {\n            ancestor = ancestor.parent;\n        }\n        return !!ancestor;\n    }\n\n    /**\n     * Overrides the `getID` method to return the tag ID from the document. If a viable tag\n     * ID cannot be found in the document marks, then a new ID is returned. This will also\n     * assign a new ID if the tag changed between the previous and current versions of this\n     * node.\n     *\n     * @param {Object} newTag tag object for the current element\n     * @return {int} best ID\n     */\n    DOMUpdater.prototype.getID = function (newTag, markCache) {\n        // Get the mark at the start of the tagname (not before the beginning of the tag, because that's\n        // actually inside the parent).\n        var currentTagID = _getTagIDAtDocumentPos(this.editor, HTMLSimpleDOM._offsetPos(newTag.startPos, 1), markCache);\n\n        // If the new tag is in an unmarked range, or the marked range actually corresponds to an\n        // ancestor tag, then this must be a newly inserted tag, so give it a new tag ID.\n        if (currentTagID === -1 || _hasAncestorWithID(newTag, currentTagID)) {\n            currentTagID = this.getNewID();\n        } else {\n            // If the tag has changed between the previous DOM and the new one, we assign a new ID\n            // so that the old tag will be deleted and the new one inserted.\n            var oldNode = this.previousDOM.nodeMap[currentTagID];\n            if (!oldNode || oldNode.tag !== newTag.tag) {\n                currentTagID = this.getNewID();\n            }\n        }\n        return currentTagID;\n    };\n\n    /**\n     * Updates the CodeMirror marks in the editor to reflect the new bounds of nodes in\n     * the given nodeMap.\n     * @param {Object} nodeMap The node map from the new DOM.\n     * @param {Object} markCache The cache of existing mark ranges built during the latest parse.\n     */\n    DOMUpdater.prototype._updateMarkedRanges = function (nodeMap, markCache) {\n        // FUTURE: this is somewhat inefficient (getting all the marks involves passing linearly through\n        // the document once), but it doesn't seem to be a hotspot right now.\n        var updateIDs = Object.keys(nodeMap),\n            cm = this.cm,\n            marks = cm.getAllMarks();\n\n        cm.operation(function () {\n            marks.forEach(function (mark) {\n                if (mark.hasOwnProperty(\"tagID\") && nodeMap[mark.tagID]) {\n                    var node = nodeMap[mark.tagID],\n                        markInfo = markCache[mark.tagID];\n                    // If the mark's bounds already match, avoid destroying and recreating the mark,\n                    // since that incurs some overhead.\n                    if (!(markInfo && _posEq(markInfo.range.from, node.startPos) && _posEq(markInfo.range.to, node.endPos))) {\n                        mark.clear();\n                        mark = cm.markText(node.startPos, node.endPos);\n                        mark.tagID = node.tagID;\n                    }\n                    updateIDs.splice(updateIDs.indexOf(String(node.tagID)), 1);\n                }\n            });\n\n            // Any remaining updateIDs are new.\n            updateIDs.forEach(function (id) {\n                var node = nodeMap[id], mark;\n                if (node.isElement()) {\n                    mark = cm.markText(node.startPos, node.endPos);\n                    mark.tagID = Number(id);\n                }\n            });\n        });\n    };\n\n    /**\n     * @private\n     * Creates a map from tagIDs to nodes in the given HTMLSimpleDOM subtree and\n     * stores it on the root.\n     * @param {Object} root The root of an HTMLSimpleDOM tree.\n     */\n    DOMUpdater.prototype._buildNodeMap = function (root) {\n        var nodeMap = {};\n\n        function walk(node) {\n            if (node.tagID) {\n                nodeMap[node.tagID] = node;\n            }\n            if (node.isElement()) {\n                node.children.forEach(walk);\n            }\n        }\n\n        walk(root);\n        root.nodeMap = nodeMap;\n    };\n\n    /**\n     * @private\n     * Removes all nodes deleted between the oldSubtree and the newSubtree from the given nodeMap,\n     * and clears marks associated with those nodes.\n     * @param {Object} nodeMap The nodeMap to update to remove deleted items.\n     * @param {Object} oldSubtreeMap The nodeMap for the original subtree (which should be a subset of the\n     *     first nodeMap).\n     * @param {Object} newSubtreeMap The nodeMap for the new subtree.\n     */\n    DOMUpdater.prototype._handleDeletions = function (nodeMap, oldSubtreeMap, newSubtreeMap) {\n        var deletedIDs = [];\n        Object.keys(oldSubtreeMap).forEach(function (key) {\n            if (!newSubtreeMap.hasOwnProperty(key)) {\n                deletedIDs.push(key);\n                delete nodeMap[key];\n            }\n        });\n\n        if (deletedIDs.length) {\n            // FUTURE: would be better to cache the mark for each node. Also, could\n            // conceivably combine this with _updateMarkedRanges().\n            var marks = this.cm.getAllMarks();\n            marks.forEach(function (mark) {\n                if (mark.hasOwnProperty(\"tagID\") && deletedIDs.indexOf(mark.tagID) !== -1) {\n                    mark.clear();\n                }\n            });\n        }\n    };\n\n    /**\n     * Reparses the document (or a portion of it if we can do it incrementally).\n     * Note that in an incremental update, the old DOM is actually mutated (the new\n     * subtree is swapped in for the old subtree).\n     * @return {?{newDOM: Object, oldSubtree: Object, newSubtree: Object}} newDOM is\n     *      the full new DOM. For a full update, oldSubtree is the full old DOM\n     *      and newSubtree is the same as newDOM; for an incremental update,\n     *      oldSubtree is the portion of the old tree that was reparsed,\n     *      newSubtree is the updated version, and newDOM is actually the same\n     *      as the original DOM (with newSubtree swapped in for oldSubtree).\n     *      If the document can't be parsed due to invalid HTML, returns null.\n     */\n    DOMUpdater.prototype.update = function () {\n        var markCache = {},\n            newSubtree = this.build(true, markCache),\n            result = {\n                // default result if we didn't identify a changed portion\n                newDOM: newSubtree,\n                oldSubtree: this.previousDOM,\n                newSubtree: newSubtree\n            };\n\n        if (!newSubtree) {\n            return null;\n        }\n\n        if (this.changedTagID) {\n            // Find the old subtree that's going to get swapped out.\n            var oldSubtree = this.previousDOM.nodeMap[this.changedTagID],\n                parent = oldSubtree.parent;\n\n            // If we didn't have a parent, then the whole tree changed anyway, so\n            // we'll just return the default result.\n            if (parent) {\n                var childIndex = parent.children.indexOf(oldSubtree);\n                if (childIndex === -1) {\n                    // This should never happen...\n                    console.error(\"DOMUpdater.update(): couldn't locate old subtree in tree\");\n                } else {\n                    // Swap the new subtree in place of the old subtree.\n                    oldSubtree.parent = null;\n                    newSubtree.parent = parent;\n                    parent.children[childIndex] = newSubtree;\n\n                    // Overwrite any node mappings in the parent DOM with the\n                    // mappings for the new subtree. We keep the nodeMap around\n                    // on the new subtree so that the differ can use it later.\n                    $.extend(this.previousDOM.nodeMap, newSubtree.nodeMap);\n\n                    // Update marked ranges for all items in the new subtree.\n                    this._updateMarkedRanges(newSubtree.nodeMap, markCache);\n\n                    // Build a local nodeMap for the old subtree so the differ can\n                    // use it.\n                    this._buildNodeMap(oldSubtree);\n\n                    // Clean up the info for any deleted nodes that are no longer in\n                    // the new tree.\n                    this._handleDeletions(this.previousDOM.nodeMap, oldSubtree.nodeMap, newSubtree.nodeMap);\n\n                    // Update the signatures for all parents of the new subtree.\n                    var curParent = parent;\n                    while (curParent) {\n                        curParent.update();\n                        curParent = curParent.parent;\n                    }\n\n                    result.newDOM = this.previousDOM;\n                    result.oldSubtree = oldSubtree;\n                }\n            }\n        } else {\n            _markTextFromDOM(this.editor, result.newDOM);\n        }\n\n        return result;\n    };\n\n    /**\n     * @private\n     * Builds a new DOM for the current state of the editor, diffs it against the\n     * previous DOM, and generates a DOM edit list that can be used to replay the\n     * diffs in the browser.\n     * @param {Object} previousDOM The HTMLSimpleDOM corresponding to the previous state of the editor.\n     *     Note that in the case of an incremental edit, this will be mutated to create the new DOM\n     *     (by swapping out the subtree corresponding to the changed portion).\n     * @param {Editor} editor The editor containing the instrumented HTML.\n     * @param {Array=} changeList If specified, a CodeMirror changelist reflecting all the\n     *     text changes in the editor since previousDOM was built. If specified, we will\n     *     attempt to do an incremental update (although we might fall back to a full update\n     *     in various cases). If not specified, we will always do a full update.\n     * @return {{dom: Object, edits: Array}} The new DOM representing the current state of the\n     *     editor, and an array of edits that can be applied to update the browser (see\n     *     HTMLDOMDiff for more information on the edit format).\n     */\n    function _updateDOM(previousDOM, editor, changeList) {\n        if (!allowIncremental) {\n            changeList = undefined;\n        }\n        var updater = new DOMUpdater(previousDOM, editor, changeList);\n        var result = updater.update();\n        if (!result) {\n            return { errors: updater.errors };\n        }\n\n        var edits = HTMLDOMDiff.domdiff(result.oldSubtree, result.newSubtree);\n\n        // We're done with the nodeMap that was added to the subtree by the updater.\n        if (result.newSubtree !== result.newDOM) {\n            delete result.newSubtree.nodeMap;\n        }\n\n        return {\n            dom: result.newDOM,\n            edits: edits,\n            _wasIncremental: updater.isIncremental // for unit tests only\n        };\n    }\n\n    /**\n     * Calculates the DOM edits that are needed to update the browser from the state the\n     * editor was in the last time that scanDocument(), getInstrumentedHTML(), or\n     * getUnappliedEditList() was called (whichever is most recent). Caches this state so\n     * it can be used as the base state for the next getUnappliedEditList().\n     *\n     * For simple text edits, this update is done quickly and incrementally. For structural\n     * edits (edits that change the DOM structure or add/remove attributes), the update\n     * requires a full reparse.\n     *\n     * If the document currently contains invalid HTML, no edits will be generated until\n     * getUnappliedEditList() is called when the document is valid, at which point the edits\n     * will reflect all the changes needed to catch the browser up with all the edits\n     * made while the document was invalid.\n     *\n     * @param {Editor} editor The editor containing the instrumented HTML\n     * @param {Array} changeList A CodeMirror change list describing the text changes made\n     *     in the editor since the last update. If specified, we will attempt to do an\n     *     incremental update.\n     * @return {Array} edits A list of edits to apply in the browser. See HTMLDOMDiff for\n     *     more information on the format of these edits.\n     */\n    function getUnappliedEditList(editor, changeList) {\n        var cachedValue = _cachedValues[editor.document.file.fullPath];\n\n        // We might not have a previous DOM if the document was empty before this edit.\n        if (!cachedValue || !cachedValue.dom || _cachedValues[editor.document.file.fullPath].invalid) {\n            // We were in an invalid state, so do a full rebuild.\n            changeList = null;\n        }\n\n        var result = _updateDOM(cachedValue && cachedValue.dom, editor, changeList);\n\n        if (!result.errors) {\n            _cachedValues[editor.document.file.fullPath] = {\n                timestamp: editor.document.diskTimestamp,\n                dom: result.dom,\n                dirty: false\n            };\n            return { edits: result.edits };\n        }\n        if (cachedValue) {\n            cachedValue.invalid = true;\n        }\n        return { errors: result.errors };\n\n    }\n\n    /**\n     * @private\n     * Add SimpleDOMBuilder metadata to browser DOM tree JSON representation\n     * @param {Object} root\n     */\n    function _processBrowserSimpleDOM(browserRoot, editorRootTagID) {\n        var nodeMap         = {},\n            root;\n\n        function _processElement(elem) {\n            elem.tagID = elem.attributes[\"data-brackets-id\"];\n\n            // remove data-brackets-id attribute for diff\n            delete elem.attributes[\"data-brackets-id\"];\n\n            elem.children.forEach(function (child) {\n                // set parent\n                child.parent = elem;\n\n                if (child.isElement()) {\n                    _processElement(child);\n                } else if (child.isText()) {\n                    child.update();\n                    child.tagID = HTMLSimpleDOM.getTextNodeID(child);\n\n                    nodeMap[child.tagID] = child;\n                }\n            });\n\n            elem.update();\n\n            nodeMap[elem.tagID] = elem;\n\n            // Choose the root element based on the root tag in the editor.\n            // The browser may insert html, head and body elements if missing.\n            if (elem.tagID === editorRootTagID) {\n                root = elem;\n            }\n        }\n\n        _processElement(browserRoot);\n\n        root = root || browserRoot;\n        root.nodeMap = nodeMap;\n\n        return root;\n    }\n\n    /**\n     * @private\n     * Diff the browser DOM with the in-editor DOM\n     * @param {Editor} editor\n     * @param {Object} browserSimpleDOM\n     */\n    function _getBrowserDiff(editor, browserSimpleDOM) {\n        var cachedValue = _cachedValues[editor.document.file.fullPath],\n            editorRoot  = cachedValue.dom,\n            browserRoot;\n\n        browserRoot = _processBrowserSimpleDOM(browserSimpleDOM, editorRoot.tagID);\n\n        return {\n            diff: HTMLDOMDiff.domdiff(editorRoot, browserRoot),\n            browser: browserRoot,\n            editor: editorRoot\n        };\n    }\n\n    DocumentManager.on(\"beforeDocumentDelete\", _removeDocFromCache);\n\n    /**\n     * Parses the document, returning an HTMLSimpleDOM structure and caching it as the\n     * initial state of the document. Will return a cached copy of the DOM if the\n     * document hasn't changed since the last time scanDocument was called.\n     *\n     * This is called by generateInstrumentedHTML(), but it can be useful to call it\n     * ahead of time so the DOM is cached and doesn't need to be rescanned when the\n     * instrumented HTML is requested by the browser.\n     *\n     * @param {Document} doc The doc to scan.\n     * @return {Object} Root DOM node of the document.\n     */\n    function scanDocument(doc) {\n        if (!_cachedValues.hasOwnProperty(doc.file.fullPath)) {\n            doc.on(\"change.htmlInstrumentation\", function () {\n                if (_cachedValues[doc.file.fullPath]) {\n                    _cachedValues[doc.file.fullPath].dirty = true;\n                }\n            });\n\n            // Assign to cache, but don't set a value yet\n            _cachedValues[doc.file.fullPath] = null;\n        }\n\n        var cachedValue = _cachedValues[doc.file.fullPath];\n        if (!doc.isDirty && cachedValue && !cachedValue.dirty && cachedValue.timestamp === doc.diskTimestamp) {\n            return cachedValue.dom;\n        }\n\n        var text = doc.getText(),\n            dom = HTMLSimpleDOM.build(text);\n\n        if (dom) {\n            // Cache results\n            _cachedValues[doc.file.fullPath] = {\n                timestamp: doc.diskTimestamp,\n                dom: dom,\n                dirty: false\n            };\n        }\n\n        return dom;\n    }\n\n    /**\n     * Generate instrumented HTML for the specified editor's document, and mark the associated tag\n     * ranges in the editor. Each tag has a \"data-brackets-id\" attribute with a unique ID for its\n     * value. For example, \"<div>\" becomes something like \"<div data-brackets-id='45'>\". The attribute\n     * value is just a number that is guaranteed to be unique.\n     *\n     * Also stores marks in the given editor that correspond to the tag ranges. These marks are used\n     * to track the DOM structure for in-browser highlighting and live HTML updating.\n     *\n     * This only needs to be done once on load of a document. As the document is edited in memory,\n     * the instrumentation is kept up to date via the diffs and edits that are generated on change\n     * events. Call this again only if you want to do a full re-sync of the editor's DOM state.\n     *\n     * @param {Editor} editor The editor whose document we're instrumenting, and which we should\n     *     mark ranges in.\n     * @return {string} instrumented html content\n     */\n    function generateInstrumentedHTML(editor) {\n        var doc = editor.document,\n            dom = scanDocument(doc),\n            orig = doc.getText(),\n            gen = \"\",\n            lastIndex = 0;\n\n        if (!dom) {\n            return null;\n        }\n\n        // Ensure that the marks in the editor are up to date with respect to the given DOM.\n        _markTextFromDOM(editor, dom);\n\n        // Walk through the dom nodes and insert the 'data-brackets-id' attribute at the\n        // end of the open tag\n        function walk(node) {\n            if (node.tag) {\n                var attrText = \" data-brackets-id='\" + node.tagID + \"'\";\n\n                // Insert the attribute as the first attribute in the tag.\n                var insertIndex = node.start + node.tag.length + 1;\n                gen += orig.substr(lastIndex, insertIndex - lastIndex) + attrText;\n                lastIndex = insertIndex;\n            }\n\n            if (node.isElement()) {\n                node.children.forEach(walk);\n            }\n        }\n\n        walk(dom);\n        gen += orig.substr(lastIndex);\n\n        return gen;\n    }\n\n    /**\n     * Mark the text for the specified editor. Either scanDocument() or\n     * generateInstrumentedHTML() must be called before this function\n     * is called.\n     *\n     * NOTE: This function is \"private\" for now (has a leading underscore), since\n     * the API is likely to change in the future.\n     *\n     * @param {Editor} editor The editor whose text should be marked.\n     * @return none\n     */\n    function _markText(editor) {\n        var cache = _cachedValues[editor.document.file.fullPath],\n            dom = cache && cache.dom;\n\n        if (!dom) {\n            console.error(\"Couldn't find the dom for \" + editor.document.file.fullPath);\n            return;\n        }\n\n        _markTextFromDOM(editor, dom);\n    }\n\n    /**\n     * @private\n     * Clear the DOM cache. For unit testing only.\n     */\n    function _resetCache() {\n        _cachedValues = {};\n    }\n\n    // private methods\n    exports._markText                   = _markText;\n    exports._getMarkerAtDocumentPos     = _getMarkerAtDocumentPos;\n    exports._getTagIDAtDocumentPos      = _getTagIDAtDocumentPos;\n    exports.getPositionFromTagId        = getPositionFromTagId;\n    exports._markTextFromDOM            = _markTextFromDOM;\n    exports._updateDOM                  = _updateDOM;\n    exports._allowIncremental           = allowIncremental;\n    exports._getBrowserDiff             = _getBrowserDiff;\n    exports._resetCache                 = _resetCache;\n\n    // public API\n    exports.scanDocument                = scanDocument;\n    exports.generateInstrumentedHTML    = generateInstrumentedHTML;\n    exports.getUnappliedEditList        = getUnappliedEditList;\n});\n"],"file":"HTMLInstrumentation.js"}
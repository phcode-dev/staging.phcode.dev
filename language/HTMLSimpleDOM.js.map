{"version":3,"sources":["language/HTMLSimpleDOM.js"],"names":["define","require","exports","module","Tokenizer","MurmurHash3","PerfUtils","seed","Math","floor","random","tagID","openImpliesClose","li","dt","dd","address","p","article","aside","blockquote","colgroup","caption","details","dir","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","main","menu","nav","ol","pre","section","table","ul","rb","rt","rtc","rp","optgroup","option","tbody","thead","tfoot","tr","th","td","body","head","optionalClose","html","voidElements","area","base","basefont","br","col","command","embed","frame","img","input","isindex","keygen","link","menuitem","meta","param","source","track","wbr","SimpleNode","properties","$","extend","this","getTextNodeID","textNode","childIndex","parent","children","indexOf","_addPos","pos1","pos2","line","ch","_offsetPos","pos","offset","Builder","text","startOffset","startOffsetPos","stack","t","currentTag","build","strict","builder","_dumpDOM","root","result","indent","walk","node","tag","JSON","stringify","attributes","content","isElement","forEach","slice","prototype","update","i","subtreeHashes","childHashes","child","length","String","attributeSignature","subtreeSignature","textSignature","childSignature","hashString","updateAttributeSignature","attributeString","isText","_logError","token","error","startPos","endPos","errors","push","markCache","self","lastClosedTag","lastTextNode","attributeName","nodeMap","timerBuildFull","timerBuildPart","timers","closeTag","endIndex","pop","end","markStart","nextToken","type","finalizeMeasurement","addMeasurement","newTagName","contents","toLowerCase","newTag","hasOwnProperty","closable","start","getID","getNewID","closeTagName","newNode","_indexPos","dom","_getTextNodeID","_seed"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: HTML Instrumentation*/\n\ndefine(function (require, exports, module) {\n\n\n    var Tokenizer   = require(\"language/HTMLTokenizer\").Tokenizer,\n        MurmurHash3 = require(\"thirdparty/murmurhash3_gc\"),\n        PerfUtils   = require(\"utils/PerfUtils\");\n\n    var seed = Math.floor(Math.random() * 65535);\n\n    var tagID = 1;\n\n    /**\n     * A list of tags whose start causes any of a given set of immediate parent\n     * tags to close. This mostly comes from the HTML5 spec section on omitted close tags:\n     * http://www.w3.org/html/wg/drafts/html/master/syntax.html#optional-tags\n     * This doesn't handle general content model violations.\n     */\n    var openImpliesClose = {\n        li: { li: true },\n        dt: { dd: true, dt: true },\n        dd: { dd: true, dt: true },\n        address: { p: true },\n        article: { p: true },\n        aside: { p: true },\n        blockquote: { p: true },\n        colgroup: { caption: true },\n        details: { p: true },\n        dir: { p: true },\n        div: { p: true },\n        dl: { p: true },\n        fieldset: { p: true },\n        figcaption: { p: true },\n        figure: { p: true },\n        footer: { p: true },\n        form: { p: true },\n        h1: { p: true },\n        h2: { p: true },\n        h3: { p: true },\n        h4: { p: true },\n        h5: { p: true },\n        h6: { p: true },\n        header: { p: true },\n        hgroup: { p: true },\n        hr: { p: true },\n        main: { p: true },\n        menu: { p: true },\n        nav: { p: true },\n        ol: { p: true },\n        p: { p: true },\n        pre: { p: true },\n        section: { p: true },\n        table: { p: true },\n        ul: { p: true },\n        rb: { rb: true, rt: true, rtc: true, rp: true },\n        rp: { rb: true, rt: true, rp: true },\n        rt: { rb: true, rt: true, rp: true },\n        rtc: { rb: true, rt: true, rtc: true, rp: true },\n        optgroup: { optgroup: true, option: true },\n        option: { option: true },\n        tbody: { caption: true, colgroup: true, thead: true, tbody: true, tfoot: true },\n        tfoot: { caption: true, colgroup: true, thead: true, tbody: true },\n        thead: { caption: true, colgroup: true },\n        tr: { tr: true, th: true, td: true, caption: true },\n        th: { th: true, td: true },\n        td: { th: true, td: true },\n        body: { head: true }\n    };\n\n    /**\n     * A list of elements which are automatically closed when their parent is closed:\n     * http://www.w3.org/html/wg/drafts/html/master/syntax.html#optional-tags\n     */\n    var optionalClose = {\n        html: true,\n        body: true,\n        li: true,\n        dd: true,\n        dt: true, // This is not actually correct, but showing a syntax error is not helpful\n        p: true,\n        rb: true,\n        rt: true,\n        rtc: true,\n        rp: true,\n        optgroup: true,\n        option: true,\n        colgroup: true,\n        caption: true,\n        tbody: true,\n        tfoot: true,\n        tr: true,\n        td: true,\n        th: true\n    };\n\n    // TODO: handle optional start tags\n\n    /**\n     * A list of tags that are self-closing (do not contain other elements).\n     * Mostly taken from http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n     */\n    var voidElements = {\n        area: true,\n        base: true,\n        basefont: true,\n        br: true,\n        col: true,\n        command: true,\n        embed: true,\n        frame: true,\n        hr: true,\n        img: true,\n        input: true,\n        isindex: true,\n        keygen: true,\n        link: true,\n        menuitem: true,\n        meta: true,\n        param: true,\n        source: true,\n        track: true,\n        wbr: true\n    };\n\n    /**\n     * A SimpleNode represents one node in a SimpleDOM tree. Each node can have\n     * any set of properties on it, though there are a couple of assumptions made.\n     * Elements will have `children` and `attributes` properties. Text nodes will have a `content`\n     * property. All Elements will have a `tagID` and text nodes *can* have one.\n     *\n     * @constructor\n     *\n     * @param {Object} properties the properties provided will be set on the new object.\n     */\n    function SimpleNode(properties) {\n        $.extend(this, properties);\n    }\n\n    SimpleNode.prototype = {\n\n        /**\n         * Updates signatures used to optimize the number of comparisons done during\n         * diffing. This is important to call if you change:\n         *\n         * * children\n         * * child node attributes\n         * * text content of a text node\n         * * child node text\n         */\n        update: function () {\n            if (this.isElement()) {\n                var i,\n                    subtreeHashes = \"\",\n                    childHashes = \"\",\n                    child;\n                for (i = 0; i < this.children.length; i++) {\n                    child = this.children[i];\n                    if (child.isElement()) {\n                        childHashes += String(child.tagID);\n                        subtreeHashes += String(child.tagID) + child.attributeSignature + child.subtreeSignature;\n                    } else {\n                        childHashes += child.textSignature;\n                        subtreeHashes += child.textSignature;\n                    }\n                }\n                this.childSignature = MurmurHash3.hashString(childHashes, childHashes.length, seed);\n                this.subtreeSignature = MurmurHash3.hashString(subtreeHashes, subtreeHashes.length, seed);\n            } else {\n                this.textSignature = MurmurHash3.hashString(this.content, this.content.length, seed);\n            }\n        },\n\n        /**\n         * Updates the signature of this node's attributes. Call this after making attribute changes.\n         */\n        updateAttributeSignature: function () {\n            var attributeString = JSON.stringify(this.attributes);\n            this.attributeSignature = MurmurHash3.hashString(attributeString, attributeString.length, seed);\n        },\n\n        /**\n         * Is this node an element node?\n         *\n         * @return {bool} true if it is an element\n         */\n        isElement: function () {\n            return !!this.children;\n        },\n\n        /**\n         * Is this node a text node?\n         *\n         * @return {bool} true if it is text\n         */\n        isText: function () {\n            return !this.children;\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Generates a synthetic ID for text nodes. These IDs are only used\n     * for convenience when reading a SimpleDOM that is dumped to the console.\n     *\n     * @param {Object} textNode new node for which we are generating an ID\n     * @return {string} ID for the node\n     */\n    function getTextNodeID(textNode) {\n        var childIndex = textNode.parent.children.indexOf(textNode);\n        if (childIndex === 0) {\n            return textNode.parent.tagID + \".0\";\n        }\n        return textNode.parent.children[childIndex - 1].tagID + \"t\";\n    }\n\n    /**\n     * @private\n     *\n     * Adds two {line, ch}-style positions, returning a new pos.\n     */\n    function _addPos(pos1, pos2) {\n        return {line: pos1.line + pos2.line, ch: (pos2.line === 0 ? pos1.ch + pos2.ch : pos2.ch)};\n    }\n\n    /**\n     * @private\n     *\n     * Offsets the character offset of the given {line, ch} pos by the given amount and returns a new\n     * pos. Not for general purpose use as it does not account for line boundaries.\n     */\n    function _offsetPos(pos, offset) {\n        return {line: pos.line, ch: pos.ch + offset};\n    }\n\n    /**\n     * A Builder creates a SimpleDOM tree of SimpleNode objects representing the\n     * \"important\" contents of an HTML document. It does not include things like comments.\n     * The nodes include information about their position in the text provided.\n     *\n     * @constructor\n     *\n     * @param {string} text The text to parse\n     * @param {?int} startOffset starting offset in the text\n     * @param {?{line: int, ch: int}} startOffsetPos line/ch position in the text\n     */\n    function Builder(text, startOffset, startOffsetPos) {\n        this.stack = [];\n        this.text = text;\n        this.t = new Tokenizer(text);\n        this.currentTag = null;\n        this.startOffset = startOffset || 0;\n        this.startOffsetPos = startOffsetPos || {line: 0, ch: 0};\n    }\n\n    Builder.prototype._logError = function (token) {\n        var error       = { token: token },\n            startPos    = token ? (token.startPos || token.endPos) : this.startOffsetPos,\n            endPos      = token ? token.endPos : this.startOffsetPos;\n\n        error.startPos = _addPos(this.startOffsetPos, startPos);\n        error.endPos = _addPos(this.startOffsetPos, endPos);\n\n        if (!this.errors) {\n            this.errors = [];\n        }\n\n        this.errors.push(error);\n    };\n\n    /**\n     * Builds the SimpleDOM.\n     *\n     * @param {?bool} strict if errors are detected, halt and return null\n     * @param {?Object} markCache a cache that can be used in ID generation (is passed to `getID`)\n     * @return {SimpleNode} root of tree or null if parsing failed\n     */\n    Builder.prototype.build = function (strict, markCache) {\n        var self = this;\n        var token, lastClosedTag, lastTextNode;\n        var stack = this.stack;\n        var attributeName = null;\n        var nodeMap = {};\n\n        markCache = markCache || {};\n\n        // Start timers for building full and partial DOMs.\n        // Appropriate timer is used, and the other is discarded.\n        var timerBuildFull = \"HTMLInstr. Build DOM Full\";\n        var timerBuildPart = \"HTMLInstr. Build DOM Partial\";\n        var timers; // timer handles\n        timers = PerfUtils.markStart([timerBuildFull, timerBuildPart]);\n        timerBuildFull = timers[0];\n        timerBuildPart = timers[1];\n\n        function closeTag(endIndex, endPos) {\n            lastClosedTag = stack[stack.length - 1];\n            stack.pop();\n            lastClosedTag.update();\n\n            lastClosedTag.end = self.startOffset + endIndex;\n            lastClosedTag.endPos = _addPos(self.startOffsetPos, endPos);\n        }\n\n        while ((token = this.t.nextToken()) !== null) {\n            // lastTextNode is used to glue text nodes together\n            // If the last node we saw was text but this one is not, then we're done gluing.\n            // If this node is a comment, we might still encounter more text.\n            if (token.type !== \"text\" && token.type !== \"comment\" && lastTextNode) {\n                lastTextNode = null;\n            }\n\n            if (token.type === \"error\") {\n                PerfUtils.finalizeMeasurement(timerBuildFull);  // discard\n                PerfUtils.addMeasurement(timerBuildPart);       // use\n                this._logError(token);\n                return null;\n            } else if (token.type === \"opentagname\") {\n                var newTagName = token.contents.toLowerCase(),\n                    newTag;\n\n                if (openImpliesClose.hasOwnProperty(newTagName)) {\n                    var closable = openImpliesClose[newTagName];\n                    while (stack.length > 0 && closable.hasOwnProperty(stack[stack.length - 1].tag)) {\n                        // Close the previous tag at the start of this tag.\n                        // Adjust backwards for the < before the tag name.\n                        closeTag(token.start - 1, _offsetPos(token.startPos, -1));\n                    }\n                }\n\n                newTag = new SimpleNode({\n                    tag: token.contents.toLowerCase(),\n                    children: [],\n                    attributes: {},\n                    parent: (stack.length ? stack[stack.length - 1] : null),\n                    start: this.startOffset + token.start - 1,\n                    startPos: _addPos(this.startOffsetPos, _offsetPos(token.startPos, -1)) // ok because we know the previous char was a \"<\"\n                });\n                newTag.tagID = this.getID(newTag, markCache);\n\n                // During undo in particular, it's possible that tag IDs may be reused and\n                // the marks in the document may be misleading. If a tag ID has been reused,\n                // we apply a new tag ID to ensure that our edits come out correctly.\n                if (nodeMap[newTag.tagID]) {\n                    newTag.tagID = this.getNewID();\n                }\n\n                nodeMap[newTag.tagID] = newTag;\n                if (newTag.parent) {\n                    newTag.parent.children.push(newTag);\n                }\n                this.currentTag = newTag;\n\n                if (voidElements.hasOwnProperty(newTag.tag)) {\n                    // This is a self-closing element.\n                    newTag.update();\n                } else {\n                    stack.push(newTag);\n                }\n            } else if (token.type === \"opentagend\" || token.type === \"selfclosingtag\") {\n                // TODO: disallow <p/>?\n                if (this.currentTag) {\n                    if (token.type === \"selfclosingtag\" && stack.length && stack[stack.length - 1] === this.currentTag) {\n                        // This must have been a self-closing tag that we didn't identify as a void element\n                        // (e.g. an SVG tag). Pop it off the stack as if we had encountered its close tag.\n                        closeTag(token.end, token.endPos);\n                    } else {\n                        // We're ending an open tag. Record the end of the open tag as the end of the\n                        // range. (If we later find a close tag for this tag, the end will get overwritten\n                        // with the end of the close tag. In the case of a self-closing tag, we should never\n                        // encounter that.)\n                        // Note that we don't need to update the signature here because the signature only\n                        // relies on the tag name and ID, and isn't affected by the tag's attributes, so\n                        // the signature we calculated when creating the tag is still the same. If we later\n                        // find a close tag for this tag, we'll update the signature to account for its\n                        // children at that point (in the next \"else\" case).\n                        this.currentTag.end = this.startOffset + token.end;\n                        this.currentTag.endPos = _addPos(this.startOffsetPos, token.endPos);\n                        lastClosedTag = this.currentTag;\n                        this.currentTag.updateAttributeSignature();\n                        this.currentTag = null;\n                    }\n                }\n            } else if (token.type === \"closetag\") {\n                // If this is a self-closing element, ignore the close tag.\n                var closeTagName = token.contents.toLowerCase();\n                if (!voidElements.hasOwnProperty(closeTagName)) {\n                    // Find the topmost item on the stack that matches. If we can't find one, assume\n                    // this is just a dangling closing tag and ignore it.\n                    var i;\n                    for (i = stack.length - 1; i >= 0; i--) {\n                        if (stack[i].tag === closeTagName) {\n                            break;\n                        }\n                    }\n                    if (i >= 0) {\n                        do {\n                            // For all tags we're implicitly closing (before we hit the matching tag), we want the\n                            // implied end to be the beginning of the close tag (which is two characters, \"</\", before\n                            // the start of the tagname). For the actual tag we're explicitly closing, we want the\n                            // implied end to be the end of the close tag (which is one character, \">\", after the end of\n                            // the tagname).\n                            if (stack.length === i + 1) {\n                                closeTag(token.end + 1, _offsetPos(token.endPos, 1));\n                            } else {\n                                if (strict && !optionalClose.hasOwnProperty(stack[stack.length - 1].tag)) {\n                                    // If we're in strict mode, treat unbalanced tags as invalid.\n                                    PerfUtils.finalizeMeasurement(timerBuildFull);\n                                    PerfUtils.addMeasurement(timerBuildPart);\n                                    this._logError(token);\n                                    return null;\n                                }\n                                closeTag(token.start - 2, _offsetPos(token.startPos, -2));\n                            }\n                        } while (stack.length > i);\n                    } else {\n                        // If we're in strict mode, treat unmatched close tags as invalid. Otherwise\n                        // we just silently ignore them.\n                        if (strict) {\n                            PerfUtils.finalizeMeasurement(timerBuildFull);\n                            PerfUtils.addMeasurement(timerBuildPart);\n                            this._logError(token);\n                            return null;\n                        }\n                    }\n                }\n            } else if (token.type === \"attribname\") {\n                attributeName = token.contents.toLowerCase();\n                // Set the value to the empty string in case this is an empty attribute. If it's not,\n                // it will get overwritten by the attribvalue later.\n                this.currentTag.attributes[attributeName] = \"\";\n            } else if (token.type === \"attribvalue\" && attributeName !== null) {\n                this.currentTag.attributes[attributeName] = token.contents;\n                attributeName = null;\n            } else if (token.type === \"text\") {\n                if (stack.length) {\n                    var parent = stack[stack.length - 1];\n                    var newNode;\n\n                    // Check to see if we're continuing a previous text.\n                    if (lastTextNode) {\n                        newNode = lastTextNode;\n                        newNode.content += token.contents;\n                    } else {\n                        newNode = new SimpleNode({\n                            parent: stack[stack.length - 1],\n                            content: token.contents\n                        });\n                        parent.children.push(newNode);\n                        newNode.tagID = getTextNodeID(newNode);\n                        nodeMap[newNode.tagID] = newNode;\n                        lastTextNode = newNode;\n                    }\n\n                    newNode.update();\n                }\n            }\n        }\n\n        // If we have any tags hanging open, fail the parse if we're in strict mode,\n        // otherwise close them at the end of the document.\n        while (stack.length) {\n            if (strict && !optionalClose.hasOwnProperty(stack[stack.length - 1].tag)) {\n                PerfUtils.finalizeMeasurement(timerBuildFull);\n                PerfUtils.addMeasurement(timerBuildPart);\n                this._logError(token);\n                return null;\n            }\n            closeTag(this.text.length, this.t._indexPos);\n        }\n\n        var dom = lastClosedTag;\n        if (!dom) {\n            // This can happen if the document has no nontrivial content, or if the user tries to\n            // have something at the root other than the HTML tag. In all such cases, we treat the\n            // document as invalid.\n            this._logError(token);\n            return null;\n        }\n\n        dom.nodeMap = nodeMap;\n        PerfUtils.addMeasurement(timerBuildFull);       // use\n        PerfUtils.finalizeMeasurement(timerBuildPart);  // discard\n\n        return dom;\n    };\n\n    /**\n     * Returns a new tag ID.\n     *\n     * @return {int} unique tag ID\n     */\n    Builder.prototype.getNewID = function () {\n        return tagID++;\n    };\n\n    /**\n     * Returns the best tag ID for the new tag object given.\n     * The default implementation just calls `getNewID`\n     * and returns a unique ID.\n     *\n     * @param {Object} newTag tag object to potentially inspect to choose an ID\n     * @return {int} unique tag ID\n     */\n    Builder.prototype.getID = Builder.prototype.getNewID;\n\n    /**\n     * Builds a SimpleDOM from the text provided. If `strict` mode is true, parsing\n     * will halt as soon as any error is seen and null will be returned.\n     *\n     * @param {string} text Text of document to parse\n     * @param {bool} strict True for strict parsing\n     * @return {SimpleNode} root of tree or null if strict failed\n     */\n    function build(text, strict) {\n        var builder = new Builder(text);\n        return builder.build(strict);\n    }\n\n    /**\n     * @private\n     *\n     * Generates a string version of a SimpleDOM for debugging purposes.\n     *\n     * @param {SimpleNode} root root of the tree\n     * @return {string} Text version of the tree.\n     */\n    function _dumpDOM(root) {\n        var result = \"\",\n            indent = \"\";\n\n        function walk(node) {\n            if (node.tag) {\n                result += indent + \"TAG \" + node.tagID + \" \" + node.tag + \" \" + JSON.stringify(node.attributes) + \"\\n\";\n            } else {\n                result += indent + \"TEXT \" + (node.tagID || \"- \") + node.content + \"\\n\";\n            }\n            if (node.isElement()) {\n                indent += \"  \";\n                node.children.forEach(walk);\n                indent = indent.slice(2);\n            }\n        }\n        walk(root);\n\n        return result;\n    }\n\n    // Public API\n    exports.build                       = build;\n    exports.Builder                     = Builder;\n    exports.SimpleNode                  = SimpleNode;\n\n    // Private API\n    exports._dumpDOM                    = _dumpDOM;\n    exports._offsetPos                  = _offsetPos;\n    exports._getTextNodeID              = getTextNodeID;\n    exports._seed                       = seed;\n});\n"],"file":"HTMLSimpleDOM.js"}
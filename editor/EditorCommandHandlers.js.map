{"version":3,"sources":["editor/EditorCommandHandlers.js"],"names":["define","require","exports","module","Commands","Strings","Editor","CommandManager","EditorManager","StringUtils","TokenUtils","CodeMirror","_","DIRECTION_UP","DIRECTION_DOWN","_createSpecialLineExp","lineSyntax","blockSyntax","i","character","escapedCharacter","subExps","prevChars","length","charAt","regexEscape","push","RegExp","join","_createLineExpressions","prefixes","blockPrefix","blockSuffix","lineExp","escapedPrefix","nothingPushed","forEach","prefix","indexOf","_matchExpressions","string","expressions","some","exp","match","_getLinePrefix","result","index","_containsNotLineComment","editor","startLine","endLine","line","containsNotLineComment","document","getLine","_getLineCommentPrefixEdit","lineSel","doc","sel","selectionForEdit","trackedSels","selectionsToTrack","start","end","editGroup","commentI","ch","originalCursorPosition","search","firstCharPosition","cursorPosition","getIndentLineComment","text","each","trackedSel","cmpPos","isBeforeEdit","edit","selection","_isPrevTokenABlockComment","ctx","suffix","prefixExp","suffixExp","moveSkippingWhitespace","movePrevToken","token","type","_firstNotWs","lineNum","_getBlockCommentPrefixSuffixEdit","linePrefixes","command","getInitialContext","_codeMirror","selEndIndex","indexFromPos","prefixPos","suffixPos","commentAtStart","isBlockComment","canComment","invalidComment","lineUncomment","searchCtx","atSuffix","suffixEnd","initialPos","indentLineComment","isIndentLineCommand","cloneDeep","test","moveNextToken","pos","hasSelection","completeLineSel","startCh","endCh","useTabChar","indentChar","getUseTabChar","file","fullPath","repeat","updatePosForEdit","trim","prefixAtStart","prefixIndented","suffixAtStart","suffixIndented","_getLineCommentPrefixSuffixEdit","_getLineCommentEdits","selections","lineSelections","convertToLineSelections","mergeAdjacent","edits","mode","getModeForRange","language","getLanguage","getLanguageForMode","name","hasLineCommentSyntax","getLineCommentPrefixes","getBlockCommentPrefix","getBlockCommentSuffix","hasBlockCommentSyntax","lineComment","getFocusedEditor","setSelections","doMultipleEdits","getSelections","blockComment","lineCommentSels","apply","duplicateText","delimiter","rangeSels","cursorSels","cursorLineSels","lineCount","getRange","deleteCurrentLines","from","to","getLastVisibleLine","getFirstVisibleLine","moveLine","direction","isInlineWidget","getFocusedInlineWidget","firstLine","lastLine","totalLines","lineLength","newSels","prevText","substring","originalSel","nextText","deletionStart","getSelection","console","error","scrollIntoView","moveLineUp","moveLineDown","openLine","newSelections","batchOperation","insertPos","primary","_masterEditor","indentLine","openLineAbove","openLineBelow","indentText","execCommand","unindentText","selectLine","pluck","expandEndAtStartOfLine","splitSelIntoLines","addCursorToSelection","dir","origSels","colOffset","clone","getColOffset","getCharIndexForColumn","concat","addCursorToPrevLine","addCursorToNextLine","handleUndoRedo","operation","$","Deferred","resolve","reject","promise","handleUndo","handleRedo","_handleSelectAll","selectAllNoScroll","_execCommand","cmd","window","_execCommandCut","_execCommandCopy","_execCommandPaste","navigator","clipboard","readText","then","getDoc","cursor","getCursor","replaceSelection","replaceRange","register","CMD_INDENT","EDIT_INDENT","CMD_UNINDENT","EDIT_UNINDENT","CMD_COMMENT","EDIT_LINE_COMMENT","CMD_BLOCK_COMMENT","EDIT_BLOCK_COMMENT","CMD_DUPLICATE","EDIT_DUPLICATE","CMD_DELETE_LINES","EDIT_DELETE_LINES","CMD_LINE_UP","EDIT_LINE_UP","CMD_LINE_DOWN","EDIT_LINE_DOWN","CMD_OPEN_LINE_ABOVE","EDIT_OPEN_LINE_ABOVE","CMD_OPEN_LINE_BELOW","EDIT_OPEN_LINE_BELOW","CMD_SELECT_LINE","EDIT_SELECT_LINE","CMD_SPLIT_SEL_INTO_LINES","EDIT_SPLIT_SEL_INTO_LINES","CMD_ADD_CUR_TO_NEXT_LINE","EDIT_ADD_CUR_TO_NEXT_LINE","CMD_ADD_CUR_TO_PREV_LINE","EDIT_ADD_CUR_TO_PREV_LINE","CMD_UNDO","EDIT_UNDO","CMD_REDO","EDIT_REDO","CMD_CUT","EDIT_CUT","CMD_COPY","EDIT_COPY","CMD_PASTE","EDIT_PASTE","CMD_SELECT_ALL","EDIT_SELECT_ALL"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Text-editing commands that apply to whichever Editor is currently focused\n */\ndefine(function (require, exports, module) {\n\n\n    // Load dependent modules\n    var Commands           = require(\"command/Commands\"),\n        Strings            = require(\"strings\"),\n        Editor              = require(\"editor/Editor\").Editor,\n        CommandManager     = require(\"command/CommandManager\"),\n        EditorManager      = require(\"editor/EditorManager\"),\n        StringUtils        = require(\"utils/StringUtils\"),\n        TokenUtils         = require(\"utils/TokenUtils\"),\n        CodeMirror         = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        _                  = require(\"thirdparty/lodash\");\n\n    /**\n     * List of constants\n     */\n    var DIRECTION_UP    = -1;\n    var DIRECTION_DOWN  = +1;\n\n    /**\n     * @private\n     * Creates special regular expressions that matches the line prefix but not the block prefix or suffix\n     * @param {!string} lineSyntax  a line comment prefix\n     * @param {!string} blockSyntax  a block comment prefix or suffix\n     * @return {RegExp}\n     */\n    function _createSpecialLineExp(lineSyntax, blockSyntax) {\n        var i, character, escapedCharacter,\n            subExps   = [],\n            prevChars = \"\";\n\n        for (i = lineSyntax.length; i < blockSyntax.length; i++) {\n            character = blockSyntax.charAt(i);\n            escapedCharacter = StringUtils.regexEscape(character);\n            subExps.push(prevChars + \"[^\" + escapedCharacter + \"]\");\n            if (prevChars) {\n                subExps.push(prevChars + \"$\");\n            }\n            prevChars += escapedCharacter;\n        }\n        return new RegExp(\"^\\\\s*\" + StringUtils.regexEscape(lineSyntax) + \"($|\" + subExps.join(\"|\") + \")\");\n    }\n\n    /**\n     * @private\n     * Creates regular expressions for multiple line comment prefixes\n     * @param {!Array.<string>} prefixes  the line comment prefixes\n     * @param {string=} blockPrefix  the block comment prefix\n     * @param {string=} blockSuffix  the block comment suffix\n     * @return {Array.<RegExp>}\n     */\n    function _createLineExpressions(prefixes, blockPrefix, blockSuffix) {\n        var lineExp = [], escapedPrefix, nothingPushed;\n\n        prefixes.forEach(function (prefix) {\n            escapedPrefix = StringUtils.regexEscape(prefix);\n            nothingPushed = true;\n\n            if (blockPrefix && blockPrefix.indexOf(prefix) === 0) {\n                lineExp.push(_createSpecialLineExp(prefix, blockPrefix));\n                nothingPushed = false;\n            }\n            if (blockSuffix && blockPrefix !== blockSuffix && blockSuffix.indexOf(prefix) === 0) {\n                lineExp.push(_createSpecialLineExp(prefix, blockSuffix));\n                nothingPushed = false;\n            }\n            if (nothingPushed) {\n                lineExp.push(new RegExp(\"^\\\\s*\" + escapedPrefix));\n            }\n        });\n        return lineExp;\n    }\n\n    /**\n     * @private\n     * Returns true if any regular expression matches the given string\n     * @param {!string} string  where to look\n     * @param {!Array.<RegExp>} expressions  what to look\n     * @return {boolean}\n     */\n    function _matchExpressions(string, expressions) {\n        return expressions.some(function (exp) {\n            return string.match(exp);\n        });\n    }\n\n    /**\n     * @private\n     * Returns the line comment prefix that best matches the string. Since there might be line comment prefixes\n     * that are prefixes of other line comment prefixes, it searches through all and returns the longest line\n     * comment prefix that matches the string.\n     * @param {!string} string  where to look\n     * @param {!Array.<RegExp>} expressions  the line comment regular expressions\n     * @param {!Array.<string>} prefixes  the line comment prefixes\n     * @return {string}\n     */\n    function _getLinePrefix(string, expressions, prefixes) {\n        var result = null;\n        expressions.forEach(function (exp, index) {\n            if (string.match(exp) && ((result && result.length < prefixes[index].length) || !result)) {\n                result = prefixes[index];\n            }\n        });\n        return result;\n    }\n\n    /**\n     * @private\n     * Searches between startLine and endLine to check if there is at least one line commented with a line comment, and\n     * skips all the block comments.\n     * @param {!Editor} editor\n     * @param {!number} startLine  valid line inside the document\n     * @param {!number} endLine  valid line inside the document\n     * @param {!Array.<RegExp>} lineExp  an array of line comment prefixes regular expressions\n     * @return {boolean} true if there is at least one uncommented line\n     */\n    function _containsNotLineComment(editor, startLine, endLine, lineExp) {\n        var i, line,\n            containsNotLineComment = false;\n\n        for (i = startLine; i <= endLine; i++) {\n            line = editor.document.getLine(i);\n            // A line is commented out if it starts with 0-N whitespace chars, then a line comment prefix\n            if (line.match(/\\S/) && !_matchExpressions(line, lineExp)) {\n                containsNotLineComment = true;\n                break;\n            }\n        }\n        return containsNotLineComment;\n    }\n\n    /**\n     * @private\n     * Generates an edit that adds or removes line-comment tokens to all the lines in the selected range,\n     * preserving selection and cursor position. Applies to currently focused Editor. The given selection\n     * must already be a line selection in the form returned by `Editor.convertToLineSelections()`.\n     *\n     * If all non-whitespace lines are already commented out, then we uncomment; otherwise we comment\n     * out. Commenting out adds the prefix at column 0 of every line. Uncommenting removes the first prefix\n     * on each line (if any - empty lines might not have one).\n     *\n     * @param {!Editor} editor\n     * @param {!Array.<string>} prefixes, e.g. [\"//\"]\n     * @param {string=} blockPrefix, e.g. \"<!--\"\n     * @param {string=} blockSuffix, e.g. \"-->\"\n     * @param {!Editor} editor The editor to edit within.\n     * @param {!{selectionForEdit: {start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean},\n     *           selectionsToTrack: Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>}}\n     *      lineSel A line selection as returned from `Editor.convertToLineSelections()`. `selectionForEdit` is the selection to perform\n     *      the line comment operation on, and `selectionsToTrack` are a set of selections associated with this line that need to be\n     *      tracked through the edit.\n     * @return {{edit: {text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}|Array.<{text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}>,\n     *                  selection: {start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}|\n     *                  Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}}\n     *      An edit description suitable for including in the edits array passed to `Document.doMultipleEdits()`.\n     */\n    function _getLineCommentPrefixEdit(editor, prefixes, blockPrefix, blockSuffix, lineSel) {\n        var doc         = editor.document,\n            sel         = lineSel.selectionForEdit,\n            trackedSels = lineSel.selectionsToTrack,\n            lineExp     = _createLineExpressions(prefixes, blockPrefix, blockSuffix),\n            startLine   = sel.start.line,\n            endLine     = sel.end.line,\n            editGroup   = [];\n\n        // In full-line selection, cursor pos is start of next line - but don't want to modify that line\n        if (sel.end.ch === 0) {\n            endLine--;\n        }\n\n        // Decide if we're commenting vs. un-commenting\n        // Are there any non-blank lines that aren't commented out? (We ignore blank lines because\n        // some editors like Sublime don't comment them out)\n        var i, line, prefix, commentI,\n            containsNotLineComment = _containsNotLineComment(editor, startLine, endLine, lineExp);\n\n        if (containsNotLineComment) {\n            // Comment out - prepend the first prefix to each line\n            line = doc.getLine(startLine);\n            var originalCursorPosition = line.search(/\\S|$/);\n\n            var firstCharPosition, cursorPosition = originalCursorPosition;\n\n            for (i = startLine; i <= endLine; i++) {\n                //check if preference for indent line comment is available otherwise go back to default indentation\n                if (Editor.getIndentLineComment()) {\n                    //ignore the first line and recalculate cursor position for first non white space char of every line\n                    if (i !== startLine) {\n                        line = doc.getLine(i);\n                        firstCharPosition = line.search(/\\S|$/);\n                    }\n                    //if the non space first character position is before original start position , put comment at the new position otherwise older pos\n                    if (firstCharPosition < originalCursorPosition) {\n                        cursorPosition = firstCharPosition;\n                    } else {\n                        cursorPosition = originalCursorPosition;\n                    }\n\n                    editGroup.push({text: prefixes[0], start: {line: i, ch: cursorPosition}});\n                } else {\n                    editGroup.push({text: prefixes[0], start: {line: i, ch: 0}});\n                }\n            }\n\n            // Make sure tracked selections include the prefix that was added at start of range\n            _.each(trackedSels, function (trackedSel) {\n                if (trackedSel.start.ch === 0 && CodeMirror.cmpPos(trackedSel.start, trackedSel.end) !== 0) {\n                    trackedSel.start = {line: trackedSel.start.line, ch: 0};\n                    trackedSel.end = {line: trackedSel.end.line, ch: (trackedSel.end.line === endLine ? trackedSel.end.ch + prefixes[0].length : 0)};\n                } else {\n                    trackedSel.isBeforeEdit = true;\n                }\n            });\n        } else {\n            // Uncomment - remove the prefix on each line (if any)\n            for (i = startLine; i <= endLine; i++) {\n                line   = doc.getLine(i);\n                prefix = _getLinePrefix(line, lineExp, prefixes);\n\n                if (prefix) {\n                    commentI = line.indexOf(prefix);\n                    editGroup.push({text: \"\", start: {line: i, ch: commentI}, end: {line: i, ch: commentI + prefix.length}});\n                }\n            }\n            _.each(trackedSels, function (trackedSel) {\n                trackedSel.isBeforeEdit = true;\n            });\n        }\n        return {edit: editGroup, selection: trackedSels};\n    }\n\n    /**\n     * @private\n     * Given a token context it will search backwards to determine if the given token is part of a block comment\n     * that doesn't start at the initial token. This is used to know if a line comment is part of a block comment\n     * or if a block delimiter is the prefix or suffix, by passing a token context at that position. Since the\n     * token context will be moved backwards a lot, it is better to pass a new context.\n     *\n     * @param {!{editor:{CodeMirror}, pos:{ch:{number}, line:{number}}, token:{object}}} ctx  token context\n     * @param {!string} prefix  the block comment prefix\n     * @param {!string} suffix  the block comment suffix\n     * @param {!RegExp} prefixExp  a block comment prefix regular expression\n     * @param {!RegExp} suffixExp  a block comment suffix regular expression\n     * @param {!Array.<RegExp>} lineExp  an array of line comment prefixes regular expressions\n     * @return {boolean}\n     */\n    function _isPrevTokenABlockComment(ctx, prefix, suffix, prefixExp, suffixExp, lineExp) {\n        // Start searching from the previous token\n        var result = TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx);\n\n        // Look backwards until we find a none line comment token\n        while (result && _matchExpressions(ctx.token.string, lineExp)) {\n            result = TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx);\n        }\n\n        // If we are now in a block comment token\n        if (result && ctx.token.type === \"comment\") {\n            // If it doesnt matches either prefix or suffix, we know is a block comment\n            if (!ctx.token.string.match(prefixExp) && !ctx.token.string.match(suffixExp)) {\n                return true;\n            // We found a line with just a block comment delimiter, but we can't tell which one it is, so we will\n            // keep searching recursively and return the opposite value\n            } else if (prefix === suffix && ctx.token.string.length === prefix.length) {\n                return !_isPrevTokenABlockComment(ctx, prefix, suffix, prefixExp, suffixExp, lineExp);\n            // We can just now the result by checking if the string matches the prefix\n            }\n            return ctx.token.string.match(prefixExp);\n\n        }\n        return false;\n    }\n\n    /**\n     * Return the column of the first non whitespace char in the given line.\n     *\n     * @private\n     * @param {!Document} doc\n     * @param {number} lineNum\n     * @returns {number} the column index or null\n     */\n    function _firstNotWs(doc, lineNum) {\n        var text = doc.getLine(lineNum);\n        if (text === null || text === undefined) {\n            return 0;\n        }\n\n        return text.search(/\\S|$/);\n    }\n\n    /**\n     * Generates an edit that adds or removes block-comment tokens to the selection, preserving selection\n     * and cursor position. Applies to the currently focused Editor.\n     *\n     * If the selection is inside a block-comment or one block-comment is inside or partially inside the selection\n     * it will uncomment, otherwise it will comment out, unless if there are multiple block comments inside the selection,\n     * where it does nothing.\n     * Commenting out adds the prefix before the selection and the suffix after.\n     * Uncommenting removes them.\n     *\n     * If all the lines inside the selection are line-comment and if the selection is not inside a block-comment, it will\n     * line uncomment all the lines, otherwise it will block comment/uncomment. In the first case, we return null to\n     * indicate to the caller that it needs to handle this selection as a line comment.\n     *\n     * @param {!Editor} editor\n     * @param {!string} prefix, e.g. \"<!--\"\n     * @param {!string} suffix, e.g. \"-->\"\n     * @param {!Array.<string>} linePrefixes, e.g. [\"//\"]\n     * @param {!{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}} sel\n     *      The selection to block comment/uncomment.\n     * @param {?Array.<{!{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}}>} selectionsToTrack\n     *      An array of selections that should be tracked through this edit.\n     * @param {String} command The command callee. It cans be \"line\" or \"block\".\n     * @return {{edit: {text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}|Array.<{text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}>,\n     *                  selection: {start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}|\n     *                  Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}}\n     *      An edit description suitable for including in the edits array passed to `Document.doMultipleEdits()`.\n     */\n    function _getBlockCommentPrefixSuffixEdit(editor, prefix, suffix, linePrefixes, sel, selectionsToTrack, command) {\n        var doc            = editor.document,\n            ctx            = TokenUtils.getInitialContext(editor._codeMirror, {line: sel.start.line, ch: sel.start.ch}),\n            selEndIndex    = editor.indexFromPos(sel.end),\n            lineExp        = _createLineExpressions(linePrefixes, prefix, suffix),\n            prefixExp      = new RegExp(\"^\" + StringUtils.regexEscape(prefix), \"g\"),\n            suffixExp      = new RegExp(StringUtils.regexEscape(suffix) + \"$\", \"g\"),\n            prefixPos      = null,\n            suffixPos      = null,\n            commentAtStart = true,\n            isBlockComment = false,\n            canComment     = false,\n            invalidComment = false,\n            lineUncomment  = false,\n            result         = true,\n            editGroup      = [],\n            edit;\n\n        var searchCtx, atSuffix, suffixEnd, initialPos, endLine;\n\n        var indentLineComment = Editor.getIndentLineComment();\n\n        function isIndentLineCommand() {\n            return indentLineComment && command === \"line\";\n        }\n\n        if (!selectionsToTrack) {\n            // Track the original selection.\n            selectionsToTrack = [_.cloneDeep(sel)];\n        }\n\n        // First move the context to the first none white-space token\n        if (!ctx.token.type && !/\\S/.test(ctx.token.string)) {\n            result = TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx);\n        }\n\n        // Next, move forwards until we find a comment inside the selection\n        while (result && ctx.token.type !== \"comment\") {\n            result = TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx) && editor.indexFromPos(ctx.pos) <= selEndIndex;\n            commentAtStart = false;\n        }\n\n        // We are now in a comment, lets check if it is a block or a line comment\n        if (result && ctx.token.type === \"comment\") {\n            // This token might be at a line comment, but we can't be sure yet\n            if (_matchExpressions(ctx.token.string, lineExp)) {\n                // If the token starts at ch 0 with no starting white spaces, then this might be a block comment or a line\n                // comment over the whole line, and if we found this comment at the start of the selection, we need to search\n                // backwards until we get can tell if we are in a block or a line comment\n                if (ctx.token.start === 0 && !ctx.token.string.match(/^\\\\s*/) && commentAtStart) {\n                    searchCtx      = TokenUtils.getInitialContext(editor._codeMirror, {line: ctx.pos.line, ch: ctx.token.start});\n                    isBlockComment = _isPrevTokenABlockComment(searchCtx, prefix, suffix, prefixExp, suffixExp, lineExp);\n\n                // If not, we already know that is a line comment\n                } else {\n                    isBlockComment = false;\n                }\n\n            // If it was not a line comment, it has to be a block comment\n            } else {\n                isBlockComment = true;\n\n                // If we are in a line that only has a prefix or a suffix and the prefix and suffix are the same string,\n                // lets find first if this is a prefix or suffix and move the context position to the inside of the block comment.\n                // This means that the token will be anywere inside the block comment, including the lines with the delimiters.\n                // This is required so that later we can find the prefix by moving backwards and the suffix by moving forwards.\n                if (ctx.token.string === prefix && prefix === suffix) {\n                    searchCtx = TokenUtils.getInitialContext(editor._codeMirror, {line: ctx.pos.line, ch: ctx.token.start});\n                    atSuffix  = _isPrevTokenABlockComment(searchCtx, prefix, suffix, prefixExp, suffixExp, lineExp);\n                    if (atSuffix) {\n                        TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx);\n                    } else {\n                        TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx);\n                    }\n                }\n            }\n\n            if (isBlockComment) {\n                // Save the initial position to start searching for the suffix from here\n                initialPos = _.cloneDeep(ctx.pos);\n\n                // Find the position of the start of the prefix\n                result = true;\n                while (result && !ctx.token.string.match(prefixExp)) {\n                    result = TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx);\n                }\n                prefixPos = result && {line: ctx.pos.line, ch: ctx.token.start};\n\n                // Restore the context at the initial position to find the position of the start of the suffix,\n                // but only when we found the prefix alone in one line\n                if (ctx.token.string === prefix && prefix === suffix) {\n                    ctx = TokenUtils.getInitialContext(editor._codeMirror, _.cloneDeep(initialPos));\n                }\n\n                while (result && !ctx.token.string.match(suffixExp)) {\n                    result = TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx);\n                }\n                suffixPos = result && {line: ctx.pos.line, ch: ctx.token.end - suffix.length};\n\n                // Lets check if there are more comments in the selection. We do nothing if there is one\n                do {\n                    result = TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx) &&\n                        editor.indexFromPos(ctx.pos) <= selEndIndex;\n                } while (result && !ctx.token.string.match(prefixExp));\n                invalidComment = result && !!ctx.token.string.match(prefixExp);\n\n                // Make sure we didn't search so far backward or forward that we actually found a block comment\n                // that's entirely before or after the selection.\n                suffixEnd = suffixPos && { line: suffixPos.line, ch: suffixPos.ch + suffix.length };\n                if ((suffixEnd && CodeMirror.cmpPos(sel.start, suffixEnd) > 0) || (prefixPos && CodeMirror.cmpPos(sel.end, prefixPos) < 0)) {\n                    canComment = true;\n                }\n\n            } else {\n                // In full-line selection, cursor pos is at the start of next line - but don't want to modify that line\n                endLine = sel.end.line;\n                if (sel.end.ch === 0 && editor.hasSelection()) {\n                    endLine--;\n                }\n                // Find if all the lines are line-commented.\n                if (!_containsNotLineComment(editor, sel.start.line, endLine, lineExp)) {\n                    lineUncomment = true;\n                } else {\n                    canComment = true;\n                }\n            }\n        // If not, we can comment\n        } else {\n            canComment = true;\n        }\n\n\n        // Make the edit\n        if (invalidComment) {\n            // We don't want to do an edit, but we still want to track selections associated with it.\n            edit = {edit: [], selection: selectionsToTrack};\n\n        } else if (lineUncomment) {\n            // Return a null edit. This is a signal to the caller that we should delegate to the\n            // line commenting code. We don't want to just generate the edit here, because the edit\n            // might need to be coalesced with other line-uncomment edits generated by cursors on the\n            // same line.\n            edit = null;\n\n        } else {\n            // Comment out - add the suffix to the start and the prefix to the end.\n            if (canComment) {\n                var completeLineSel = sel.start.ch === 0 && sel.end.ch === 0 && sel.start.line < sel.end.line;\n                var startCh = _firstNotWs(doc, sel.start.line);\n                if (completeLineSel) {\n                    if (isIndentLineCommand()) {\n                        var endCh = _firstNotWs(doc, sel.end.line - 1);\n                        var useTabChar = Editor.getUseTabChar(editor.document.file.fullPath);\n                        var indentChar = useTabChar ? \"\\t\" : \" \";\n                        editGroup.push({\n                            text: _.repeat(indentChar, endCh) + suffix + \"\\n\",\n                            start: {line: sel.end.line, ch: 0}\n                        });\n                        editGroup.push({\n                            text: prefix + \"\\n\" + _.repeat(indentChar, startCh),\n                            start: {line: sel.start.line, ch: startCh}\n                        });\n                    } else {\n                        editGroup.push({text: suffix + \"\\n\", start: sel.end});\n                        editGroup.push({text: prefix + \"\\n\", start: sel.start});\n                    }\n                } else {\n                    editGroup.push({text: suffix, start: sel.end});\n                    if (isIndentLineCommand()) {\n                        editGroup.push({text: prefix, start: { line: sel.start.line, ch: startCh }});\n                    } else {\n                        editGroup.push({text: prefix, start: sel.start});\n                    }\n                }\n\n                // Correct the tracked selections. We can't just use the default selection fixup,\n                // because it will push the end of the selection past the inserted content. Also,\n                // it's possible that we have to deal with tracked selections that might be outside\n                // the bounds of the edit.\n                _.each(selectionsToTrack, function (trackedSel) {\n                    function updatePosForEdit(pos) {\n                        // First adjust for the suffix insertion. Don't adjust\n                        // positions that are exactly at the suffix insertion point.\n                        if (CodeMirror.cmpPos(pos, sel.end) > 0) {\n                            if (completeLineSel) {\n                                pos.line++;\n                            } else if (pos.line === sel.end.line) {\n                                pos.ch += suffix.length;\n                            }\n                        }\n                        // Now adjust for the prefix insertion. In this case, we do\n                        // want to adjust positions that are exactly at the insertion\n                        // point.\n                        if (CodeMirror.cmpPos(pos, sel.start) >= 0) {\n                            if (completeLineSel) {\n                                // Just move the line down.\n                                pos.line++;\n                            } else if (pos.line === sel.start.line && !(isIndentLineCommand() && pos.ch < startCh)) {\n                                pos.ch += prefix.length;\n                            }\n                        }\n                    }\n\n                    updatePosForEdit(trackedSel.start);\n                    updatePosForEdit(trackedSel.end);\n                });\n\n            // Uncomment - remove prefix and suffix.\n            } else {\n                // Find if the prefix and suffix are at the ch 0 and if they are the only thing in the line.\n                // If both are found we assume that a complete line selection comment added new lines, so we remove them.\n                var line          = doc.getLine(prefixPos.line).trim(),\n                    prefixAtStart = prefixPos.ch === 0 && prefix.length === line.length,\n                    prefixIndented = indentLineComment && prefix.length === line.length,\n                    suffixAtStart = false,\n                    suffixIndented = false;\n\n                if (suffixPos) {\n                    line = doc.getLine(suffixPos.line).trim();\n                    suffixAtStart = suffixPos.ch === 0 && suffix.length === line.length;\n                    suffixIndented = indentLineComment && suffix.length === line.length;\n                }\n\n                // Remove the suffix if there is one\n                if (suffixPos) {\n                    if (suffixIndented) {\n                        editGroup.push({text: \"\", start: {line: suffixPos.line, ch: 0}, end: {line: suffixPos.line + 1, ch: 0}});\n                    } else if (prefixAtStart && suffixAtStart) {\n                        editGroup.push({text: \"\", start: suffixPos, end: {line: suffixPos.line + 1, ch: 0}});\n                    } else {\n                        editGroup.push({text: \"\", start: suffixPos, end: {line: suffixPos.line, ch: suffixPos.ch + suffix.length}});\n                    }\n                }\n\n                // Remove the prefix\n                if (prefixIndented) {\n                    editGroup.push({text: \"\", start: {line: prefixPos.line, ch: 0}, end: {line: prefixPos.line + 1, ch: 0}});\n                } else if (prefixAtStart && suffixAtStart) {\n                    editGroup.push({text: \"\", start: prefixPos, end: {line: prefixPos.line + 1, ch: 0}});\n                } else {\n                    editGroup.push({text: \"\", start: prefixPos, end: {line: prefixPos.line, ch: prefixPos.ch + prefix.length}});\n                }\n\n                // Don't fix up the tracked selections here - let the edit fix them up.\n                _.each(selectionsToTrack, function (trackedSel) {\n                    trackedSel.isBeforeEdit = true;\n                });\n            }\n\n            edit = {edit: editGroup, selection: selectionsToTrack};\n        }\n\n        return edit;\n    }\n\n\n    /**\n     * Generates an edit that adds or removes block-comment tokens to the selection, preserving selection\n     * and cursor position. Applies to the currently focused Editor. The selection must already be a\n     * line selection in the form returned by `Editor.convertToLineSelections()`.\n     *\n     * The implementation uses blockCommentPrefixSuffix, with the exception of the case where\n     * there is no selection on a uncommented and not empty line. In this case the whole lines gets\n     * commented in a block-comment.\n     *\n     * @param {!Editor} editor\n     * @param {!String} prefix\n     * @param {!String} suffix\n     * @param {!{selectionForEdit: {start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean},\n     *           selectionsToTrack: Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>}}\n     *      lineSel A line selection as returned from `Editor.convertToLineSelections()`. `selectionForEdit` is the selection to perform\n     *      the line comment operation on, and `selectionsToTrack` are a set of selections associated with this line that need to be\n     *      tracked through the edit.\n     * @param {String} command The command callee. It cans be \"line\" or \"block\".\n     * @return {{edit: {text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}|Array.<{text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}>,\n     *                  selection: {start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}|\n     *                  Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}}\n     *      An edit description suitable for including in the edits array passed to `Document.doMultipleEdits()`.\n     */\n    function _getLineCommentPrefixSuffixEdit(editor, prefix, suffix, lineSel, command) {\n        var sel = lineSel.selectionForEdit;\n\n        // For one-line selections, we shrink the selection to exclude the trailing newline.\n        if (sel.end.line === sel.start.line + 1 && sel.end.ch === 0) {\n            sel.end = {line: sel.start.line, ch: editor.document.getLine(sel.start.line).length};\n        }\n\n        // Now just run the standard block comment code, but make sure to track any associated selections\n        // that were subsumed into this line selection.\n        return _getBlockCommentPrefixSuffixEdit(editor, prefix, suffix, [], sel, lineSel.selectionsToTrack, command);\n    }\n\n    /**\n     * @private\n     * Generates an array of edits for toggling line comments on the given selections.\n     *\n     * @param {!Editor} editor The editor to edit within.\n     * @param {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}\n     *      selections The selections we want to line-comment.\n     * @param {String} command The command callee. It cans be \"line\" or \"block\".\n     * @return {Array.<{edit: {text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}|Array.<{text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}>,\n     *                  selection: {start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}|\n     *                  Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}>}\n     *      An array of edit descriptions suitable for including in the edits array passed to `Document.doMultipleEdits()`.\n     */\n    function _getLineCommentEdits(editor, selections, command) {\n        // We need to expand line selections in order to coalesce cursors on the same line, but we\n        // don't want to merge adjacent line selections.\n        var lineSelections = editor.convertToLineSelections(selections, { mergeAdjacent: false }),\n            edits = [];\n        _.each(lineSelections, function (lineSel) {\n            var sel = lineSel.selectionForEdit,\n                mode = editor.getModeForRange(sel.start, sel.end),\n                edit;\n            if (mode) {\n                var language = editor.document.getLanguage().getLanguageForMode(mode.name || mode);\n\n                if (language.hasLineCommentSyntax()) {\n                    edit = _getLineCommentPrefixEdit(editor, language.getLineCommentPrefixes(), language.getBlockCommentPrefix(), language.getBlockCommentSuffix(), lineSel);\n                } else if (language.hasBlockCommentSyntax()) {\n                    edit = _getLineCommentPrefixSuffixEdit(editor, language.getBlockCommentPrefix(), language.getBlockCommentSuffix(), lineSel, command);\n                }\n            }\n            if (!edit) {\n                // Even if we didn't want to do an edit, we still need to track the selection.\n                edit = {selection: lineSel.selectionsToTrack};\n            }\n            edits.push(edit);\n        });\n        return edits;\n    }\n\n    /**\n     * Invokes a language-specific line-comment/uncomment handler\n     * @param {?Editor} editor If unspecified, applies to the currently focused editor\n     */\n    function lineComment(editor) {\n        editor = editor || EditorManager.getFocusedEditor();\n        if (!editor) {\n            return;\n        }\n\n        editor.setSelections(editor.document.doMultipleEdits(_getLineCommentEdits(editor, editor.getSelections(), \"line\")));\n    }\n\n    /**\n     * Invokes a language-specific block-comment/uncomment handler\n     * @param {?Editor} editor If unspecified, applies to the currently focused editor\n     */\n    function blockComment(editor) {\n        editor = editor || EditorManager.getFocusedEditor();\n        if (!editor) {\n            return;\n        }\n\n        var edits = [],\n            lineCommentSels = [];\n        _.each(editor.getSelections(), function (sel) {\n            var mode = editor.getModeForRange(sel.start, sel.end),\n                edit = {edit: [], selection: [sel]}; // default edit in case we don't have a mode for this selection\n            if (mode) {\n                var language = editor.document.getLanguage().getLanguageForMode(mode.name || mode);\n\n                if (language.hasBlockCommentSyntax()) {\n                    // getLineCommentPrefixes always return an array, and will be empty if no line comment syntax is defined\n                    edit = _getBlockCommentPrefixSuffixEdit(editor, language.getBlockCommentPrefix(), language.getBlockCommentSuffix(),\n                                                            language.getLineCommentPrefixes(), sel);\n                    if (!edit) {\n                        // This is only null if the block comment code found that the selection is within a line-commented line.\n                        // Add this to the list of line-comment selections we need to handle. Since edit is null, we'll skip\n                        // pushing anything onto the edit list for this selection.\n                        lineCommentSels.push(sel);\n                    }\n                }\n            }\n            if (edit) {\n                edits.push(edit);\n            }\n        });\n\n        // Handle any line-comment edits. It's okay if these are out-of-order with the other edits, since\n        // they shouldn't overlap, and `doMultipleEdits()` will take care of sorting the edits so the\n        // selections can be tracked appropriately.\n        edits.push.apply(edits, _getLineCommentEdits(editor, lineCommentSels, \"block\"));\n\n        editor.setSelections(editor.document.doMultipleEdits(edits));\n    }\n\n    /**\n     * Duplicates the selected text, or current line if no selection. The cursor/selection is left\n     * on the second copy.\n     */\n    function duplicateText(editor) {\n        editor = editor || EditorManager.getFocusedEditor();\n        if (!editor) {\n            return;\n        }\n\n        var selections = editor.getSelections(),\n            delimiter = \"\",\n            edits = [],\n            rangeSels = [],\n            cursorSels = [],\n            doc = editor.document;\n\n        // When there are multiple selections, we want to handle all the cursors first (duplicating\n        // their lines), then all the ranges (duplicating the ranges).\n        _.each(selections, function (sel) {\n            if (CodeMirror.cmpPos(sel.start, sel.end) === 0) {\n                cursorSels.push(sel);\n            } else {\n                rangeSels.push(sel);\n            }\n        });\n\n        var cursorLineSels = editor.convertToLineSelections(cursorSels);\n        _.each(cursorLineSels, function (lineSel, index) {\n            var sel = lineSel.selectionForEdit;\n            if (sel.end.line === editor.lineCount()) {\n                delimiter = \"\\n\";\n            }\n            // Don't need to explicitly track selections since we are doing the edits in such a way that\n            // the existing selections will get appropriately updated.\n            edits.push({edit: {text: doc.getRange(sel.start, sel.end) + delimiter, start: sel.start }});\n        });\n        _.each(rangeSels, function (sel) {\n            edits.push({edit: {text: doc.getRange(sel.start, sel.end), start: sel.start }});\n        });\n\n        doc.doMultipleEdits(edits);\n    }\n\n    /**\n     * Deletes the current line if there is no selection or the lines for the selection\n     * (removing the end of line too)\n     */\n    function deleteCurrentLines(editor) {\n        editor = editor || EditorManager.getFocusedEditor();\n        if (!editor) {\n            return;\n        }\n\n        // Walk the selections, calculating the deletion edits we need to do as we go;\n        // document.doMultipleEdits() will take care of adjusting the edit locations when\n        // it actually performs the edits.\n        var doc = editor.document,\n            from,\n            to,\n            lineSelections = editor.convertToLineSelections(editor.getSelections()),\n            edits = [];\n\n        _.each(lineSelections, function (lineSel, index) {\n            var sel = lineSel.selectionForEdit;\n\n            from = sel.start;\n            to = sel.end; // this is already at the beginning of the line after the last selected line\n            if (to.line === editor.getLastVisibleLine() + 1) {\n                // Instead of deleting the newline after the last line, delete the newline\n                // before the beginning of the line--unless this is the entire visible content\n                // of the editor, in which case just delete the line content.\n                if (from.line > editor.getFirstVisibleLine()) {\n                    from.line -= 1;\n                    from.ch = doc.getLine(from.line).length;\n                }\n                to.line -= 1;\n                to.ch = doc.getLine(to.line).length;\n            }\n\n            // We don't need to track the original selections, since they'll get collapsed as\n            // part of the various deletions that occur.\n            edits.push({edit: {text: \"\", start: from, end: to}});\n        });\n        doc.doMultipleEdits(edits);\n    }\n\n    /**\n     * Moves the selected text, or current line if no selection. The cursor/selection\n     * moves with the line/lines.\n     * @param {Editor} editor - target editor\n     * @param {Number} direction - direction of the move (-1,+1) => (Up,Down)\n     */\n    function moveLine(editor, direction) {\n        editor = editor || EditorManager.getFocusedEditor();\n        if (!editor) {\n            return;\n        }\n\n        var doc             = editor.document,\n            lineSelections  = editor.convertToLineSelections(editor.getSelections()),\n            isInlineWidget  = !!EditorManager.getFocusedInlineWidget(),\n            firstLine       = editor.getFirstVisibleLine(),\n            lastLine        = editor.getLastVisibleLine(),\n            totalLines      = editor.lineCount(),\n            lineLength      = 0,\n            edits           = [],\n            newSels         = [],\n            pos             = {};\n\n        _.each(lineSelections, function (lineSel) {\n            var sel = lineSel.selectionForEdit,\n                editGroup = [];\n\n            // Make the move\n            switch (direction) {\n            case DIRECTION_UP:\n                if (sel.start.line !== firstLine) {\n                    var prevText = doc.getRange({ line: sel.start.line - 1, ch: 0 }, sel.start);\n\n                    if (sel.end.line === lastLine + 1) {\n                        if (isInlineWidget) {\n                            prevText   = prevText.substring(0, prevText.length - 1);\n                            lineLength = doc.getLine(sel.end.line - 1).length;\n                            editGroup.push({text: \"\\n\", start: { line: sel.end.line - 1, ch: lineLength }});\n                        } else {\n                            prevText = \"\\n\" + prevText.substring(0, prevText.length - 1);\n                        }\n                    }\n\n                    editGroup.push({text: \"\", start: { line: sel.start.line - 1, ch: 0 }, end: sel.start});\n                    editGroup.push({text: prevText, start: { line: sel.end.line - 1, ch: 0 }});\n\n                    // Make sure CodeMirror hasn't expanded the selection to include\n                    // the line we inserted below.\n                    _.each(lineSel.selectionsToTrack, function (originalSel) {\n                        originalSel.start.line--;\n                        originalSel.end.line--;\n                    });\n\n                    edits.push({edit: editGroup, selection: lineSel.selectionsToTrack});\n                }\n                break;\n            case DIRECTION_DOWN:\n                if (sel.end.line <= lastLine) {\n                    var nextText      = doc.getRange(sel.end, { line: sel.end.line + 1, ch: 0 }),\n                        deletionStart = sel.end;\n\n                    if (sel.end.line === lastLine) {\n                        if (isInlineWidget) {\n                            if (sel.end.line === totalLines - 1) {\n                                nextText += \"\\n\";\n                            }\n                            lineLength = doc.getLine(sel.end.line - 1).length;\n                            editGroup.push({text: \"\\n\", start: { line: sel.end.line, ch: doc.getLine(sel.end.line).length }});\n                        } else {\n                            nextText     += \"\\n\";\n                            deletionStart = { line: sel.end.line - 1, ch: doc.getLine(sel.end.line - 1).length };\n                        }\n                    }\n\n                    editGroup.push({text: \"\", start: deletionStart, end: { line: sel.end.line + 1, ch: 0 }});\n                    if (lineLength) {\n                        editGroup.push({text: \"\", start: { line: sel.end.line - 1, ch: lineLength }, end: { line: sel.end.line, ch: 0 }});\n                    }\n                    editGroup.push({text: nextText, start: { line: sel.start.line, ch: 0 }});\n\n                    // In this case, we don't need to track selections, because the edits are done in such a way that\n                    // the existing selections will automatically be updated properly by CodeMirror as it does the edits.\n                    edits.push({edit: editGroup});\n                }\n                break;\n            }\n        });\n\n        // Make sure selections are correct and primary selection is scrolled into view\n        if (edits.length) {\n            newSels = doc.doMultipleEdits(edits);\n\n            pos.ch = 0;\n\n            if (direction === DIRECTION_UP) {\n                editor.setSelections(newSels);\n                pos.line = editor.getSelection().start.line;\n            } else if (direction === DIRECTION_DOWN) {\n                pos.line = editor.getSelection().end.line;\n            } else {\n                console.error(\"EditorCommandHandler.moveLine() called with invalid argument 'direction' = %d\", direction);\n                pos = null;\n            }\n\n            editor._codeMirror.scrollIntoView(pos);\n        }\n    }\n\n    /**\n     * Moves the selected text, or current line if no selection, one line up. The cursor/selection\n     * moves with the line/lines.\n     */\n    function moveLineUp(editor) {\n        moveLine(editor, DIRECTION_UP);\n    }\n\n    /**\n     * Moves the selected text, or current line if no selection, one line down. The cursor/selection\n     * moves with the line/lines.\n     */\n    function moveLineDown(editor) {\n        moveLine(editor, DIRECTION_DOWN);\n    }\n\n    /**\n     * Inserts a new and smart indented line above/below the selected text, or current line if no selection.\n     * The cursor is moved in the new line.\n     * @param {Editor} editor - target editor\n     * @param {Number} direction - direction where to place the new line (-1,+1) => (Up,Down)\n     */\n    function openLine(editor, direction) {\n        editor = editor || EditorManager.getFocusedEditor();\n        if (!editor) {\n            return;\n        }\n\n        var selections     = editor.getSelections(),\n            isInlineWidget = !!EditorManager.getFocusedInlineWidget(),\n            lastLine       = editor.getLastVisibleLine(),\n            doc            = editor.document,\n            edits          = [],\n            newSelections,\n            line;\n\n        // First, insert all the newlines (skipping multiple selections on the same line),\n        // then indent them all. (We can't easily do them all at once, because doMultipleEdits()\n        // won't do the indentation for us, but we want its help tracking any selection changes\n        // as the result of the edits.)\n\n        // Note that we don't just use `editor.getLineSelections()` here because we don't actually want\n        // to coalesce adjacent selections - we just want to ignore dupes.\n\n        doc.batchOperation(function () {\n            _.each(selections, function (sel, index) {\n                if (index === 0 ||\n                        (direction === DIRECTION_UP && sel.start.line > selections[index - 1].start.line) ||\n                        (direction === DIRECTION_DOWN && sel.end.line > selections[index - 1].end.line)) {\n                    // Insert the new line\n                    switch (direction) {\n                    case DIRECTION_UP:\n                        line = sel.start.line;\n                        break;\n                    case DIRECTION_DOWN:\n                        line = sel.end.line;\n                        if (!(CodeMirror.cmpPos(sel.start, sel.end) !== 0 && sel.end.ch === 0)) {\n                            // If not linewise selection\n                            line++;\n                        }\n                        break;\n                    }\n\n                    var insertPos;\n                    if (line > lastLine && isInlineWidget) {\n                        insertPos = {line: line - 1, ch: doc.getLine(line - 1).length};\n                    } else {\n                        insertPos = {line: line, ch: 0};\n                    }\n                    // We want the selection after this edit to be right before the \\n we just inserted.\n                    edits.push({edit: {text: \"\\n\", start: insertPos}, selection: {start: insertPos, end: insertPos, primary: sel.primary}});\n                } else {\n                    // We just want to discard this selection, since we've already operated on the\n                    // same line and it would just collapse to the same location. But if this was\n                    // primary, make sure the last selection we did operate on ends up as primary.\n                    if (sel.primary) {\n                        edits[edits.length - 1].selections[0].primary = true;\n                    }\n                }\n            });\n            newSelections = doc.doMultipleEdits(edits, \"+input\");\n\n            // Now indent each added line (which doesn't mess up any line numbers, and\n            // we're going to set the character offset to the last position on each line anyway).\n            _.each(newSelections, function (sel) {\n                // This is a bit of a hack. The document is the one that batches operations, but we want\n                // to use CodeMirror's \"smart indent\" operation. So we need to use the document's own backing editor's\n                // CodeMirror to do the indentation. A better way to fix this would be to expose this\n                // operation on Document, but I'm not sure we want to sign up for that as a public API.\n                doc._masterEditor._codeMirror.indentLine(sel.start.line, \"smart\", true);\n                sel.start.ch = null; // last character on line\n                sel.end = sel.start;\n            });\n        });\n        editor.setSelections(newSelections);\n    }\n\n    /**\n     * Inserts a new and smart indented line above the selected text, or current line if no selection.\n     * The cursor is moved in the new line.\n     * @param {Editor} editor - target editor\n     */\n    function openLineAbove(editor) {\n        openLine(editor, DIRECTION_UP);\n    }\n\n    /**\n     * Inserts a new and smart indented line below the selected text, or current line if no selection.\n     * The cursor is moved in the new line.\n     * @param {Editor} editor - target editor\n     */\n    function openLineBelow(editor) {\n        openLine(editor, DIRECTION_DOWN);\n    }\n\n    /**\n     * Indent a line of text if no selection. Otherwise, indent all lines in selection.\n     */\n    function indentText() {\n        var editor = EditorManager.getFocusedEditor();\n        if (!editor) {\n            return;\n        }\n\n        editor._codeMirror.execCommand(\"indentMore\");\n    }\n\n    /**\n     * Unindent a line of text if no selection. Otherwise, unindent all lines in selection.\n     */\n    function unindentText() {\n        var editor = EditorManager.getFocusedEditor();\n        if (!editor) {\n            return;\n        }\n\n        editor._codeMirror.execCommand(\"indentLess\");\n    }\n\n    function selectLine(editor) {\n        editor = editor || EditorManager.getFocusedEditor();\n        if (editor) {\n            // We can just use `convertToLineSelections`, but throw away the original tracked selections and just use the\n            // coalesced selections.\n            editor.setSelections(_.pluck(editor.convertToLineSelections(editor.getSelections(), { expandEndAtStartOfLine: true }), \"selectionForEdit\"));\n        }\n    }\n\n    /**\n     * @private\n     * Takes the current selection and splits each range into separate selections, one per line.\n     * @param {!Editor} editor The editor to operate on.\n     */\n    function splitSelIntoLines(editor) {\n        editor = editor || EditorManager.getFocusedEditor();\n        if (editor) {\n            editor._codeMirror.execCommand(\"splitSelectionByLine\");\n        }\n    }\n\n    /**\n     * @private\n     * Adds a cursor on the next/previous line after/before each selected range to the selection.\n     * @param {!Editor} editor The editor to operate on.\n     * @param {number} dir The direction to add - 1 is down, -1 is up.\n     */\n    function addCursorToSelection(editor, dir) {\n        editor = editor || EditorManager.getFocusedEditor();\n        if (editor) {\n            var origSels = editor.getSelections(),\n                newSels = [];\n            _.each(origSels, function (sel) {\n                var pos, colOffset;\n                if ((dir === -1 && sel.start.line > editor.getFirstVisibleLine()) || (dir === 1 && sel.end.line < editor.getLastVisibleLine())) {\n                    // Add a new cursor on the next line up/down. It's okay if it overlaps another selection, because CM\n                    // will take care of throwing it away in that case. It will also take care of clipping the char position\n                    // to the end of the new line if the line is shorter.\n                    pos = _.clone(dir === -1 ? sel.start : sel.end);\n\n                    // get sel column of current selection\n                    colOffset = editor.getColOffset(pos);\n\n                    pos.line += dir;\n\n                    // translate column to ch in line of new selection\n                    pos.ch = editor.getCharIndexForColumn(pos.line, colOffset);\n\n\n                    // If this is the primary selection, we want the new cursor we're adding to become the\n                    // primary selection.\n                    newSels.push({start: pos, end: pos, primary: sel.primary});\n                    sel.primary = false;\n                }\n            });\n            // CM will take care of sorting the selections.\n            editor.setSelections(origSels.concat(newSels));\n        }\n    }\n\n    /**\n     * @private\n     * Adds a cursor on the previous line before each selected range to the selection.\n     * @param {!Editor} editor The editor to operate on.\n     */\n    function addCursorToPrevLine(editor) {\n        addCursorToSelection(editor, -1);\n    }\n\n    /**\n     * @private\n     * Adds a cursor on the next line after each selected range to the selection.\n     * @param {!Editor} editor The editor to operate on.\n     */\n    function addCursorToNextLine(editor) {\n        addCursorToSelection(editor, 1);\n    }\n\n    function handleUndoRedo(operation) {\n        var editor = EditorManager.getFocusedEditor();\n        var result = new $.Deferred();\n\n        if (editor) {\n            editor[operation]();\n            result.resolve();\n        } else {\n            result.reject();\n        }\n\n        return result.promise();\n    }\n\n    function handleUndo() {\n        return handleUndoRedo(\"undo\");\n    }\n\n    function handleRedo() {\n        return handleUndoRedo(\"redo\");\n    }\n\n    function _handleSelectAll() {\n        var result = new $.Deferred(),\n            editor = EditorManager.getFocusedEditor();\n\n        if (editor) {\n            editor.selectAllNoScroll();\n            result.resolve();\n        } else {\n            result.reject();    // command not handled\n        }\n\n        return result.promise();\n    }\n\n    function _execCommand(cmd) {\n        window.document.execCommand(cmd);\n    }\n    function _execCommandCut() {\n        _execCommand(\"cut\");\n    }\n    function _execCommandCopy() {\n        _execCommand(\"copy\");\n    }\n    function _execCommandPaste() {\n        if(window.navigator && window.navigator.clipboard){\n            window.navigator.clipboard.readText().then(function (text) {\n                var editor = EditorManager.getFocusedEditor();\n                if(editor){\n                    var doc = editor._codeMirror.getDoc();\n                    var selection = doc.getSelection();\n                    var cursor = doc.getCursor();\n                    if(selection){\n                        doc.replaceSelection(text);\n                    } else {\n                        doc.replaceRange(text, cursor);\n                    }\n                }\n            });\n        } else {\n            _execCommand(\"paste\");\n        }\n    }\n\n    // Register commands\n    CommandManager.register(Strings.CMD_INDENT,                 Commands.EDIT_INDENT,                 indentText);\n    CommandManager.register(Strings.CMD_UNINDENT,               Commands.EDIT_UNINDENT,               unindentText);\n    CommandManager.register(Strings.CMD_COMMENT,                Commands.EDIT_LINE_COMMENT,           lineComment);\n    CommandManager.register(Strings.CMD_BLOCK_COMMENT,          Commands.EDIT_BLOCK_COMMENT,          blockComment);\n    CommandManager.register(Strings.CMD_DUPLICATE,              Commands.EDIT_DUPLICATE,              duplicateText);\n    CommandManager.register(Strings.CMD_DELETE_LINES,           Commands.EDIT_DELETE_LINES,           deleteCurrentLines);\n    CommandManager.register(Strings.CMD_LINE_UP,                Commands.EDIT_LINE_UP,                moveLineUp);\n    CommandManager.register(Strings.CMD_LINE_DOWN,              Commands.EDIT_LINE_DOWN,              moveLineDown);\n    CommandManager.register(Strings.CMD_OPEN_LINE_ABOVE,        Commands.EDIT_OPEN_LINE_ABOVE,        openLineAbove);\n    CommandManager.register(Strings.CMD_OPEN_LINE_BELOW,        Commands.EDIT_OPEN_LINE_BELOW,        openLineBelow);\n    CommandManager.register(Strings.CMD_SELECT_LINE,            Commands.EDIT_SELECT_LINE,            selectLine);\n    CommandManager.register(Strings.CMD_SPLIT_SEL_INTO_LINES,   Commands.EDIT_SPLIT_SEL_INTO_LINES,   splitSelIntoLines);\n    CommandManager.register(Strings.CMD_ADD_CUR_TO_NEXT_LINE,   Commands.EDIT_ADD_CUR_TO_NEXT_LINE,   addCursorToNextLine);\n    CommandManager.register(Strings.CMD_ADD_CUR_TO_PREV_LINE,   Commands.EDIT_ADD_CUR_TO_PREV_LINE,   addCursorToPrevLine);\n\n    CommandManager.register(Strings.CMD_UNDO,                   Commands.EDIT_UNDO,                   handleUndo);\n    CommandManager.register(Strings.CMD_REDO,                   Commands.EDIT_REDO,                   handleRedo);\n    CommandManager.register(Strings.CMD_CUT,                    Commands.EDIT_CUT,                    _execCommandCut);\n    CommandManager.register(Strings.CMD_COPY,                   Commands.EDIT_COPY,                   _execCommandCopy);\n    CommandManager.register(Strings.CMD_PASTE,                  Commands.EDIT_PASTE,                  _execCommandPaste);\n    CommandManager.register(Strings.CMD_SELECT_ALL,             Commands.EDIT_SELECT_ALL,             _handleSelectAll);\n});\n"],"file":"EditorCommandHandlers.js"}
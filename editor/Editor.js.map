{"version":3,"sources":["editor/Editor.js"],"names":["define","require","exports","module","AnimationUtils","Async","CodeMirror","LanguageManager","EventDispatcher","PerfUtils","PreferencesManager","TextRange","TokenUtils","HTMLUtils","MainViewManager","_","IndentHelper","EditorPreferences","ChangeHelper","ErrorPopupHelper","InlineWidgetHelper","registeredGutters","cmOptions","init","CLOSE_BRACKETS","CLOSE_TAGS","DRAG_DROP","HIGHLIGHT_MATCHES","LINEWISE_COPY_CUT","SCROLL_PAST_END","SHOW_CURSOR_SELECT","SHOW_LINE_NUMBERS","SMART_INDENT","SPACE_UNITS","STYLE_ACTIVE_LINE","TAB_SIZE","USE_TAB_CHAR","WORD_WRAP","INDENT_LINE_COMMENT","INPUT_STYLE","LINE_NUMBER_GUTTER","LINE_NUMBER_GUTTER_PRIORITY","CODE_FOLDING_GUTTER_PRIORITY","editorOptions","Object","keys","_duringFocus","BOUNDARY_CHECK_NORMAL","BOUNDARY_IGNORE_TOP","BOUNDARY_BULLSEYE","_copyPos","pos","Pos","line","ch","_checkTopBoundary","options","_checkBottomBoundary","_buildPreferencesContext","fullPath","_buildContext","getLanguageForPath","getId","undefined","_instances","Editor","document","makeMasterEditor","container","range","self","this","isReadOnly","editable","push","addRef","jquery","get","$container","$","addClass","_visibleRange","startLine","endLine","_handleDocumentChange","bind","_handleDocumentDeleted","_handleDocumentLanguageChanged","_doWorkingSetSync","on","mode","_getModeFromDocument","_inlineWidgets","_inlineWidgetQueues","_hideMarks","_lastEditorWidth","_$messagePopover","_paneId","_hostEditor","codeMirrorKeyMap","Tab","_handleTabKey","Shift-Tab","Left","instance","_handleSoftTabNavigation","Right","Backspace","Delete","Esc","_instance","canConsumeEscapeKeyEvent","getSelections","length","clearSelection","hasSelection","removeAllInlineWidgets","Home","Cmd-Left","End","Cmd-Right","currentOptions","_currentOptions","zipObject","map","prefName","_getOption","_mouseHandlerOverride","_cm","_repeat","event","addNew","altKey","toggleClass","Boolean","_codeMirror","autoCloseBrackets","autoCloseTags","coverGutterNextToScrollbar","continueComments","cursorScrollMargin","dragDrop","electricChars","configureMouse","extraKeys","highlightSelectionMatches","indentUnit","indentWithTabs","inputStyle","lineNumbers","lineWiseCopyCut","lineWrapping","matchBrackets","maxScanLineLength","maxScanLines","matchTags","bothTags","scrollPastEnd","showCursorWhenSelecting","smartIndent","styleActiveLine","tabSize","readOnly","_focused","_installEditorListeners","_renderGutters","editor","_handleCursorActivity","domEvent","_handleKeypressEvents","changeList","_handleEditorChange","_toggleMasterEditor","setOption","_duringSync","_resetText","getText","_updateHiddenLines","setCursorPos","_makeEditable","defineProperty","getScrollInfo","top","getRootElement","makeEventDispatcher","prototype","markDeprecated","addHelpers","markPaneId","paneId","_associateEditor","getFocusedInlineWidget","doc","isDirty","addToWorkingSet","file","destroy","trigger","remove","splice","indexOf","releaseRef","off","dispose","_masterEditor","_makeNonEditable","_disassociateEditor","forEach","inlineWidget","_removeInlineWidgetInternal","_updateStyleActiveLine","_handleWhitespaceForElectricChars","selections","lineStr","sel","getLine","end","test","setSelections","keyStr","String","fromCharCode","which","keyCode","getLanguage","getMode","selectAllNoScroll","cm","info","operation","scrollTo","left","execCommand","isTextSubset","mark","clear","_hideLines","lineCount","text","currentText","getValue","textLF","currentTextLF","replace","perfTimerName","markStart","cursorPos","getCursorPos","scrollPos","getScrollPos","setValue","refresh","clearHistory","markClean","setScrollPos","x","y","addMeasurement","getFile","expandTabs","cursor","getCursor","getColOffset","getRange","column","i","getTabSize","getCharIndexForColumn","lineNum","iCol","center","setCursor","centerOnCursor","setSize","width","height","CENTERING_MARGIN","_normalizeRange","anchorPos","headPos","start","reversed","centerOptions","$scrollerElement","editorHeight","getScrollerElement","statusBarHeight","documentCursorPosition","cursorCoords","bottom","screenCursorPosition","Math","min","max","clientHeight","indexFromPos","coords","posFromIndex","index","posWithinRange","endInclusive","somethingSelected","getSelection","primarySel","listSelections","result","anchor","head","primary","convertToLineSelections","defaults","expandEndAtStartOfLine","mergeAdjacent","combinedSelections","prevSel","each","newSel","cloneDeep","selectionForEdit","selectionsToTrack","getSelectedText","allSelections","setSelection","origin","primIndex","toggleOverwrite","state","selectWordAt","word","findWordAt","isLineVisible","charCoords","scrollInfo","getFirstVisibleLine","getLastVisibleLine","from","to","value","markText","collapsed","inclusiveLeft","inclusiveRight","clearWhenEmpty","totalHeight","scrollHeight","getWrapperElement","_getLineSpaceElement","children","adjustScrollPos","heightDelta","getTextHeight","defaultTextHeight","addInlineWidget","removeInlineWidget","removeAllInlineWidgetsForLine","getInlineWidgets","setInlineWidgetHeight","displayErrorMessageAtCursor","getVirtualScrollAreaTop","topPadding","offsetTop","scroller","offset","scrollTop","focus","hasFocus","getViewState","restoreViewState","viewState","selection","handleResize","focusedItem","window","activeElement","restoreFocus","contains","refreshAll","undo","redo","notifyVisibilityChange","show","onParentShown","setVisible","$el","css","isFullyVisible","is","getModeForRange","knownMixed","outerMode","startMode","getModeAt","endMode","name","getOption","getModeForSelection","sels","isMixed","tagInfo","getTagInfo","tokenType","position","ATTR_VALUE","attr","toLowerCase","hasMixedSel","some","rangeMode","getLanguageForSelection","getLanguageForMode","getModeForDocument","_updateOption","oldValue","newValue","_toggleLinePadding","registerGutter","unregisterGutter","updateLayout","forceRefresh","curRoot","curWidth","$editorHolder","editorAreaHt","parent","style","clearGutter","languageId","_filterByLanguages","gutter","languages","_sortByPriority","a","b","priority","_getName","gutters","rootElement","sort","filter","removeClass","setGutterMarker","lineNumber","gutterName","marker","gutterNameRegistered","console","warn","getRegisteredGutters","languageIds","isNaN","gutterExists","forEveryEditor","error","setUseTabChar","context","set","getUseTabChar","setTabSize","setSpaceUnits","getSpaceUnits","setCloseBrackets","getCloseBrackets","setShowLineNumbers","getShowLineNumbers","setShowActiveLine","getShowActiveLine","setWordWrap","getWordWrap","setIndentLineComment","getIndentLineComment","callback","showLinePadding","$holders","$holder"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Editor is a 1-to-1 wrapper for a CodeMirror editor instance. It layers on Brackets-specific\n * functionality and provides APIs that cleanly pass through the bits of CodeMirror that the rest\n * of our codebase may want to interact with. An Editor is always backed by a Document, and stays\n * in sync with its content; because Editor keeps the Document alive, it's important to always\n * destroy() an Editor that's going away so it can release its Document ref.\n *\n * For now, there's a distinction between the \"master\" Editor for a Document - which secretly acts\n * as the Document's internal model of the text state - and the multitude of \"slave\" secondary Editors\n * which, via Document, sync their changes to and from that master.\n *\n * For now, direct access to the underlying CodeMirror object is still possible via `_codeMirror` --\n * but this is considered deprecated and may go away.\n *\n * The Editor object dispatches the following events:\n *    - keydown, keypress, keyup -- When any key event happens in the editor (whether it changes the\n *      text or not). Handlers are passed `(BracketsEvent, Editor, KeyboardEvent)`. The 3nd arg is the\n *      raw DOM event. Note: most listeners will only want to listen for \"keypress\".\n *    - cursorActivity -- When the user moves the cursor or changes the selection, or an edit occurs.\n *      Note: do not listen to this in order to be generally informed of edits--listen to the\n *      \"change\" event on Document instead.\n *    - scroll -- When the editor is scrolled, either by user action or programmatically.\n *    - lostContent -- When the backing Document changes in such a way that this Editor is no longer\n *      able to display accurate text. This occurs if the Document's file is deleted, or in certain\n *      Document->editor syncing edge cases that we do not yet support (the latter cause will\n *      eventually go away).\n *    - optionChange -- Triggered when an option for the editor is changed. The 2nd arg to the listener\n *      is a string containing the editor option that is changing. The 3rd arg, which can be any\n *      data type, is the new value for the editor option.\n *    - beforeDestroy - Triggered before the object is about to dispose of all its internal state data\n *      so that listeners can cache things like scroll pos, etc...\n *\n * The Editor also dispatches \"change\" events internally, but you should listen for those on\n * Documents, not Editors.\n *\n * To listen for events, do something like this: (see EventDispatcher for details on this pattern)\n *     `editorInstance.on(\"eventname\", handler);`\n */\ndefine(function (require, exports, module) {\n\n\n    let AnimationUtils     = require(\"utils/AnimationUtils\"),\n        Async              = require(\"utils/Async\"),\n        CodeMirror         = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        LanguageManager    = require(\"language/LanguageManager\"),\n        EventDispatcher    = require(\"utils/EventDispatcher\"),\n        PerfUtils          = require(\"utils/PerfUtils\"),\n        PreferencesManager = require(\"preferences/PreferencesManager\"),\n        TextRange          = require(\"document/TextRange\").TextRange,\n        TokenUtils         = require(\"utils/TokenUtils\"),\n        HTMLUtils          = require(\"language/HTMLUtils\"),\n        MainViewManager    = require(\"view/MainViewManager\"),\n        _                  = require(\"thirdparty/lodash\");\n\n    /** Editor helpers */\n\n    let IndentHelper = require(\"./EditorHelper/IndentHelper\"),\n        EditorPreferences = require(\"./EditorHelper/EditorPreferences\"),\n        ChangeHelper = require(\"./EditorHelper/ChangeHelper\"),\n        ErrorPopupHelper = require(\"./EditorHelper/ErrorPopupHelper\"),\n        InlineWidgetHelper = require(\"./EditorHelper/InlineWidgetHelper\");\n\n    /** Editor preferences */\n\n    /**\n     * A list of gutter name and priorities currently registered for editors.\n     * The line number gutter is defined as { name: LINE_NUMBER_GUTTER, priority: 100 }\n     * @type {Array.<{name: string, priority: number, languageIds: Array}}\n     */\n    let registeredGutters = [];\n\n    let cmOptions         = {};\n\n    EditorPreferences.init(cmOptions);\n\n    const CLOSE_BRACKETS    = EditorPreferences.CLOSE_BRACKETS,\n        CLOSE_TAGS          = EditorPreferences.CLOSE_TAGS,\n        DRAG_DROP           = EditorPreferences.DRAG_DROP,\n        HIGHLIGHT_MATCHES   = EditorPreferences.HIGHLIGHT_MATCHES,\n        LINEWISE_COPY_CUT   = EditorPreferences.LINEWISE_COPY_CUT,\n        SCROLL_PAST_END     = EditorPreferences.SCROLL_PAST_END,\n        SHOW_CURSOR_SELECT  = EditorPreferences.SHOW_CURSOR_SELECT,\n        SHOW_LINE_NUMBERS   = EditorPreferences.SHOW_LINE_NUMBERS,\n        SMART_INDENT        = EditorPreferences.SMART_INDENT,\n        SPACE_UNITS         = EditorPreferences.SPACE_UNITS,\n        STYLE_ACTIVE_LINE   = EditorPreferences.STYLE_ACTIVE_LINE,\n        TAB_SIZE            = EditorPreferences.TAB_SIZE,\n        USE_TAB_CHAR        = EditorPreferences.USE_TAB_CHAR,\n        WORD_WRAP           = EditorPreferences.WORD_WRAP,\n        INDENT_LINE_COMMENT   = EditorPreferences.INDENT_LINE_COMMENT,\n        INPUT_STYLE         = EditorPreferences.INPUT_STYLE;\n\n    const LINE_NUMBER_GUTTER = EditorPreferences.LINE_NUMBER_GUTTER,\n        LINE_NUMBER_GUTTER_PRIORITY     = EditorPreferences.LINE_NUMBER_GUTTER_PRIORITY,\n        CODE_FOLDING_GUTTER_PRIORITY    = EditorPreferences.CODE_FOLDING_GUTTER_PRIORITY;\n\n    let editorOptions = Object.keys(cmOptions);\n\n    /** Editor preferences */\n\n    /**\n     * Guard flag to prevent focus() reentrancy (via blur handlers), even across Editors\n     * @type {boolean}\n     */\n    var _duringFocus = false;\n\n    /**\n     * Constant: ignore upper boundary when centering text\n     * Constant: bulls-eye = strictly centre always\n     * @type {number}\n     */\n    var BOUNDARY_CHECK_NORMAL   = 0,\n        BOUNDARY_IGNORE_TOP     = 1,\n        BOUNDARY_BULLSEYE      = 2;\n\n    /**\n     * @private\n     * Create a copy of the given CodeMirror position\n     * @param {!CodeMirror.Pos} pos\n     * @return {CodeMirror.Pos}\n     */\n    function _copyPos(pos) {\n        return new CodeMirror.Pos(pos.line, pos.ch);\n    }\n\n    /**\n     * Helper functions to check options.\n     * @param {number} options BOUNDARY_CHECK_NORMAL or BOUNDARY_IGNORE_TOP\n     */\n    function _checkTopBoundary(options) {\n        return (options !== BOUNDARY_IGNORE_TOP);\n    }\n\n    function _checkBottomBoundary(options) {\n        return true;\n    }\n\n    /**\n     * Helper function to build preferences context based on the full path of\n     * the file.\n     *\n     * @param {string} fullPath Full path of the file\n     *\n     * @return {*} A context for the specified file name\n     */\n    function _buildPreferencesContext(fullPath) {\n        return PreferencesManager._buildContext(fullPath,\n            fullPath ? LanguageManager.getLanguageForPath(fullPath).getId() : undefined);\n    }\n\n    /**\n     * List of all current (non-destroy()ed) Editor instances. Needed when changing global preferences\n     * that affect all editors, e.g. tabbing or color scheme settings.\n     * @type {Array.<Editor>}\n     */\n    var _instances = [];\n\n    /**\n     * Creates a new CodeMirror editor instance bound to the given Document. The Document need not have\n     * a \"master\" Editor realized yet, even if makeMasterEditor is false; in that case, the first time\n     * an edit occurs we will automatically ask EditorManager to create a \"master\" editor to render the\n     * Document modifiable.\n     *\n     * ALWAYS call destroy() when you are done with an Editor - otherwise it will leak a Document ref.\n     *\n     * @constructor\n     *\n     * @param {!Document} document\n     * @param {!boolean} makeMasterEditor  If true, this Editor will set itself as the (secret) \"master\"\n     *          Editor for the Document. If false, this Editor will attach to the Document as a \"slave\"/\n     *          secondary editor.\n     * @param {!jQueryObject|DomNode} container  Container to add the editor to.\n     * @param {{startLine: number, endLine: number}=} range If specified, range of lines within the document\n     *          to display in this editor. Inclusive.\n     * @param {!Object} options If specified, contains editor options that can be passed to CodeMirror\n     */\n    function Editor(document, makeMasterEditor, container, range, options) {\n        var self = this;\n\n        var isReadOnly = (options && options.isReadOnly) || !document.editable;\n\n        _instances.push(this);\n\n        // Attach to document: add ref & handlers\n        this.document = document;\n        document.addRef();\n\n        if (container.jquery) {\n            // CodeMirror wants a DOM element, not a jQuery wrapper\n            container = container.get(0);\n        }\n\n        let $container = $(container);\n        $container.addClass(\"editor-holder\");\n\n        if (range) {    // attach this first: want range updated before we process a change\n            this._visibleRange = new TextRange(document, range.startLine, range.endLine);\n        }\n\n        // store this-bound version of listeners so we can remove them later\n        this._handleDocumentChange = this._handleDocumentChange.bind(this);\n        this._handleDocumentDeleted = this._handleDocumentDeleted.bind(this);\n        this._handleDocumentLanguageChanged = this._handleDocumentLanguageChanged.bind(this);\n        this._doWorkingSetSync = this._doWorkingSetSync.bind(this);\n        document.on(\"change\", this._handleDocumentChange);\n        document.on(\"deleted\", this._handleDocumentDeleted);\n        document.on(\"languageChanged\", this._handleDocumentLanguageChanged);\n        // To sync working sets if the view is for same doc across panes\n        document.on(\"_dirtyFlagChange\", this._doWorkingSetSync);\n\n        var mode = this._getModeFromDocument();\n\n        // (if makeMasterEditor, we attach the Doc back to ourselves below once we're fully initialized)\n\n        this._inlineWidgets = [];\n        this._inlineWidgetQueues = {};\n        this._hideMarks = [];\n        this._lastEditorWidth = null;\n\n        this._$messagePopover = null;\n\n        // To track which pane the editor is being attached to if it's a full editor\n        this._paneId = null;\n\n        // To track the parent editor ( host editor at that time of creation) of an inline editor\n        this._hostEditor = null;\n\n        // Editor supplies some standard keyboard behavior extensions of its own\n        var codeMirrorKeyMap = {\n            \"Tab\": function () { self._handleTabKey(); },\n            \"Shift-Tab\": \"indentLess\",\n\n            \"Left\": function (instance) {\n                self._handleSoftTabNavigation(-1, \"moveH\");\n            },\n            \"Right\": function (instance) {\n                self._handleSoftTabNavigation(1, \"moveH\");\n            },\n            \"Backspace\": function (instance) {\n                self._handleSoftTabNavigation(-1, \"deleteH\");\n            },\n            \"Delete\": function (instance) {\n                self._handleSoftTabNavigation(1, \"deleteH\");\n            },\n            \"Esc\": function (_instance) {\n                if(!self.canConsumeEscapeKeyEvent()){\n                    return;\n                }\n                if (self.getSelections().length > 1) { // multi cursor\n                    self.clearSelection();\n                } else if(self.hasSelection()){\n                    self.clearSelection();\n                }else {\n                    self.removeAllInlineWidgets();\n                }\n            },\n            \"Home\": \"goLineLeftSmart\",\n            \"Cmd-Left\": \"goLineLeftSmart\",\n            \"End\": \"goLineRight\",\n            \"Cmd-Right\": \"goLineRight\"\n        };\n\n        var currentOptions = this._currentOptions = _.zipObject(\n            editorOptions,\n            _.map(editorOptions, function (prefName) {\n                return self._getOption(prefName);\n            })\n        );\n\n        //cm: CodeMirror, repeat: \"single\" | \"double\" | \"triple\", event: Event\n        // The function is called when the left mouse button is pressed in codemirror\n        function _mouseHandlerOverride(_cm, _repeat, event) {\n            return {\n                addNew: event.altKey // alt key will init multi cursor instead of ctrl-key\n            };\n        }\n\n        // When panes are created *after* the showLineNumbers option has been turned off\n        //  we need to apply the show-line-padding class or the text will be juxtaposed\n        //  to the edge of the editor which makes it not easy to read.  The code below to handle\n        //  that the option change only applies the class to panes that have already been created\n        // This line ensures that the class is applied to any editor created after the fact\n        $container.toggleClass(\"show-line-padding\", Boolean(!this._getOption(\"showLineNumbers\")));\n\n        // Create the CodeMirror instance\n        // (note: CodeMirror doesn't actually require using 'new', but jslint complains without it)\n        this._codeMirror = new CodeMirror(container, {\n            autoCloseBrackets: currentOptions[CLOSE_BRACKETS],\n            autoCloseTags: currentOptions[CLOSE_TAGS],\n            coverGutterNextToScrollbar: true,\n            continueComments: true,\n            cursorScrollMargin: 3,\n            dragDrop: currentOptions[DRAG_DROP],\n            electricChars: true,\n            configureMouse: _mouseHandlerOverride,\n            extraKeys: codeMirrorKeyMap,\n            highlightSelectionMatches: currentOptions[HIGHLIGHT_MATCHES],\n            indentUnit: currentOptions[USE_TAB_CHAR] ? currentOptions[TAB_SIZE] : currentOptions[SPACE_UNITS],\n            indentWithTabs: currentOptions[USE_TAB_CHAR],\n            inputStyle: currentOptions[INPUT_STYLE],\n            lineNumbers: currentOptions[SHOW_LINE_NUMBERS],\n            lineWiseCopyCut: currentOptions[LINEWISE_COPY_CUT],\n            lineWrapping: currentOptions[WORD_WRAP],\n            matchBrackets: { maxScanLineLength: 50000, maxScanLines: 1000 },\n            matchTags: { bothTags: true },\n            scrollPastEnd: !range && currentOptions[SCROLL_PAST_END],\n            showCursorWhenSelecting: currentOptions[SHOW_CURSOR_SELECT],\n            smartIndent: currentOptions[SMART_INDENT],\n            styleActiveLine: currentOptions[STYLE_ACTIVE_LINE],\n            tabSize: currentOptions[TAB_SIZE],\n            readOnly: isReadOnly\n        });\n\n        // Can't get CodeMirror's focused state without searching for\n        // CodeMirror-focused. Instead, track focus via onFocus and onBlur\n        // options and track state with this._focused\n        this._focused = false;\n\n        this._installEditorListeners();\n\n        this._renderGutters();\n\n        this.on(\"cursorActivity\", function (event, editor) {\n            self._handleCursorActivity(event);\n        });\n        this.on(\"keypress\", function (event, editor, domEvent) {\n            self._handleKeypressEvents(domEvent);\n        });\n        this.on(\"change\", function (event, editor, changeList) {\n            self._handleEditorChange(changeList);\n        });\n        this.on(\"focus\", function (event, editor) {\n            if (self._hostEditor) {\n                // Mark the host editor as the master editor for the hosting document\n                self._hostEditor.document._toggleMasterEditor(self._hostEditor);\n            } else {\n                // Set this full editor as master editor for the document\n                self.document._toggleMasterEditor(self);\n            }\n        });\n\n        // Set code-coloring mode BEFORE populating with text, to avoid a flash of uncolored text\n        this._codeMirror.setOption(\"mode\", mode);\n\n        // Initially populate with text. This will send a spurious change event, so need to make\n        // sure this is understood as a 'sync from document' case, not a genuine edit\n        this._duringSync = true;\n        this._resetText(document.getText());\n        this._duringSync = false;\n\n        if (range) {\n            this._updateHiddenLines();\n            this.setCursorPos(range.startLine, 0);\n        }\n\n        // Now that we're fully initialized, we can point the document back at us if needed\n        if (makeMasterEditor) {\n            document._makeEditable(this);\n        }\n\n        // Add scrollTop property to this object for the scroll shadow code to use\n        Object.defineProperty(this, \"scrollTop\", {\n            get: function () {\n                return this._codeMirror.getScrollInfo().top;\n            }\n        });\n\n        // Add an $el getter for Pane Views\n        Object.defineProperty(this,  \"$el\", {\n            get: function () {\n                return $(this.getRootElement());\n            }\n        });\n    }\n\n    EventDispatcher.makeEventDispatcher(Editor.prototype);\n    EventDispatcher.markDeprecated(Editor.prototype, \"keyEvent\", \"'keydown/press/up'\");\n\n    IndentHelper.addHelpers(Editor);\n    ChangeHelper.addHelpers(Editor);\n    InlineWidgetHelper.addHelpers(Editor);\n\n    Editor.prototype.markPaneId = function (paneId) {\n        this._paneId = paneId;\n\n        // Also add this to the pool of full editors\n        this.document._associateEditor(this);\n\n        // In case this Editor is initialized not as the first full editor for the document\n        // and the document is already dirty and present in another working set, make sure\n        // to add this documents to the new panes working set.\n        this._doWorkingSetSync(null, this.document);\n    };\n\n    /**\n     * returns true if the editor can do something an escape key event. Eg. Disable multi cursor escape\n     */\n    Editor.prototype.canConsumeEscapeKeyEvent = function () {\n        let self = this;\n        return (self.getSelections().length > 1) // multi cursor should go away on escape\n            || (self.hasSelection()) // selection should go away on escape\n            || self.getFocusedInlineWidget(); // inline widget\n    };\n\n    Editor.prototype._doWorkingSetSync = function (event, doc) {\n        if (doc === this.document && this._paneId && this.document.isDirty) {\n            MainViewManager.addToWorkingSet(this._paneId, this.document.file, -1, false);\n        }\n    };\n\n    /**\n     * Removes this editor from the DOM and detaches from the Document. If this is the \"master\"\n     * Editor that is secretly providing the Document's backing state, then the Document reverts to\n     * a read-only string-backed mode.\n     */\n    Editor.prototype.destroy = function () {\n        this.trigger(\"beforeDestroy\", this);\n\n        // CodeMirror docs for getWrapperElement() say all you have to do is \"Remove this from your\n        // tree to delete an editor instance.\"\n        $(this.getRootElement()).remove();\n\n        _instances.splice(_instances.indexOf(this), 1);\n\n        // Disconnect from Document\n        this.document.releaseRef();\n        this.document.off(\"change\", this._handleDocumentChange);\n        this.document.off(\"deleted\", this._handleDocumentDeleted);\n        this.document.off(\"languageChanged\", this._handleDocumentLanguageChanged);\n        this.document.off(\"_dirtyFlagChange\", this._doWorkingSetSync);\n\n        if (this._visibleRange) {   // TextRange also refs the Document\n            this._visibleRange.dispose();\n        }\n\n        // If we're the Document's master editor, disconnecting from it has special meaning\n        if (this.document._masterEditor === this) {\n            this.document._makeNonEditable();\n        } else {\n            this.document._disassociateEditor(this);\n        }\n\n        // Destroying us destroys any inline widgets we're hosting. Make sure their closeCallbacks\n        // run, at least, since they may also need to release Document refs\n        var self = this;\n        this._inlineWidgets.forEach(function (inlineWidget) {\n            self._removeInlineWidgetInternal(inlineWidget);\n        });\n    };\n\n    /**\n     * @private\n     * Handle any cursor movement in editor, including selecting and unselecting text.\n     * @param {!Event} event\n     */\n    Editor.prototype._handleCursorActivity = function (event) {\n        this._updateStyleActiveLine();\n    };\n\n    /**\n     * @private\n     * Removes any whitespace after one of ]{}) to prevent trailing whitespace when auto-indenting\n     */\n    Editor.prototype._handleWhitespaceForElectricChars = function () {\n        var self        = this,\n            instance    = this._codeMirror,\n            selections,\n            lineStr;\n\n        selections = this.getSelections().map(function (sel) {\n            lineStr = instance.getLine(sel.end.line);\n\n            if (lineStr && !/\\S/.test(lineStr)) {\n                // if the line is all whitespace, move the cursor to the end of the line\n                // before indenting so that embedded whitespace such as indents are not\n                // orphaned to the right of the electric char being inserted\n                sel.end.ch = self.document.getLine(sel.end.line).length;\n            }\n            return sel;\n        });\n        this.setSelections(selections);\n    };\n\n    /**\n     * @private\n     * Handle CodeMirror key events.\n     * @param {!Event} event\n     */\n    Editor.prototype._handleKeypressEvents = function (event) {\n        var keyStr = String.fromCharCode(event.which || event.keyCode);\n\n        if (/[\\]\\{\\}\\)]/.test(keyStr)) {\n            this._handleWhitespaceForElectricChars();\n        }\n    };\n\n    /**\n     * Determine the mode to use from the document's language\n     * Uses \"text/plain\" if the language does not define a mode\n     * @return {string} The mode to use\n     */\n    Editor.prototype._getModeFromDocument = function () {\n        // We'd like undefined/null/\"\" to mean plain text mode. CodeMirror defaults to plaintext for any\n        // unrecognized mode, but it complains on the console in that fallback case: so, convert\n        // here so we're always explicit, avoiding console noise.\n        return this.document.getLanguage().getMode() || \"text/plain\";\n    };\n\n\n    /**\n     * Selects all text and maintains the current scroll position.\n     */\n    Editor.prototype.selectAllNoScroll = function () {\n        var cm = this._codeMirror,\n            info = this._codeMirror.getScrollInfo();\n\n        // Note that we do not have to check for the visible range here. This\n        // concern is handled internally by code mirror.\n        cm.operation(function () {\n            cm.scrollTo(info.left, info.top);\n            cm.execCommand(\"selectAll\");\n        });\n    };\n\n    /**\n     * @return {boolean} True if editor is not showing the entire text of the document (i.e. an inline editor)\n     */\n    Editor.prototype.isTextSubset = function () {\n        return Boolean(this._visibleRange);\n    };\n\n    /**\n     * Ensures that the lines that are actually hidden in the inline editor correspond to\n     * the desired visible range.\n     */\n    Editor.prototype._updateHiddenLines = function () {\n        if (this._visibleRange) {\n            var cm = this._codeMirror,\n                self = this;\n            cm.operation(function () {\n                self._hideMarks.forEach(function (mark) {\n                    if (mark) {\n                        mark.clear();\n                    }\n                });\n                self._hideMarks = [];\n                self._hideMarks.push(self._hideLines(0, self._visibleRange.startLine));\n                self._hideMarks.push(self._hideLines(self._visibleRange.endLine + 1, self.lineCount()));\n            });\n        }\n    };\n\n    /**\n     * Sets the contents of the editor, clears the undo/redo history and marks the document clean. Dispatches a change event.\n     * Semi-private: only Document should call this.\n     * @param {!string} text\n     */\n    Editor.prototype._resetText = function (text) {\n        var currentText = this._codeMirror.getValue();\n\n        // compare with ignoring line-endings, issue #11826\n        var textLF = text ? text.replace(/(\\r\\n|\\r|\\n)/g, \"\\n\") : null;\n        var currentTextLF = currentText ? currentText.replace(/(\\r\\n|\\r|\\n)/g, \"\\n\") : null;\n        if (textLF === currentTextLF) {\n            // there's nothing to reset\n            return;\n        }\n\n        var perfTimerName = PerfUtils.markStart(\"Editor._resetText()\\t\" + (!this.document || this.document.file.fullPath));\n\n        var cursorPos = this.getCursorPos(),\n            scrollPos = this.getScrollPos();\n\n        // This *will* fire a change event, but we clear the undo immediately afterward\n        this._codeMirror.setValue(text);\n        this._codeMirror.refresh();\n\n        // Make sure we can't undo back to the empty state before setValue(), and mark\n        // the document clean.\n        this._codeMirror.clearHistory();\n        this._codeMirror.markClean();\n\n        // restore cursor and scroll positions\n        this.setCursorPos(cursorPos);\n        this.setScrollPos(scrollPos.x, scrollPos.y);\n\n        PerfUtils.addMeasurement(perfTimerName);\n    };\n\n   /**\n    * Gets the file associated with this editor\n    * This is a required Pane-View interface method\n    * @return {!File} the file associated with this editor\n    */\n    Editor.prototype.getFile = function () {\n        return this.document.file;\n    };\n\n    /**\n     * Gets the current cursor position within the editor.\n     * @param {?boolean} [expandTabs]  If true, return the actual visual column number instead of the character offset in\n     *      the \"ch\" property.\n     * @param {?string} [which] Optional string indicating which end of the\n     *  selection to return. It may be \"start\", \"end\", \"head\" (the side of the\n     *  selection that moves when you press shift+arrow), or \"anchor\" (the\n     *  fixed side of the selection). Omitting the argument is the same as\n     *  passing \"head\". A {line, ch} object will be returned.)\n     * @return {!{line:number, ch:number}}\n     */\n    Editor.prototype.getCursorPos = function (expandTabs, which) {\n        // Translate \"start\" and \"end\" to the official CM names (it actually\n        // supports them as-is, but that isn't documented and we don't want to\n        // rely on it).\n        if (which === \"start\") {\n            which = \"from\";\n        } else if (which === \"end\") {\n            which = \"to\";\n        }\n        var cursor = _copyPos(this._codeMirror.getCursor(which));\n\n        if (expandTabs) {\n            cursor.ch = this.getColOffset(cursor);\n        }\n        return cursor;\n    };\n\n    /**\n     * Returns the display column (zero-based) for a given string-based pos. Differs from pos.ch only\n     * when the line contains preceding \\t chars. Result depends on the current tab size setting.\n     * @param {!{line:number, ch:number}} pos\n     * @return {number}\n     */\n    Editor.prototype.getColOffset = function (pos) {\n        var line    = this._codeMirror.getRange({line: pos.line, ch: 0}, pos),\n            tabSize = null,\n            column  = 0,\n            i;\n\n        for (i = 0; i < line.length; i++) {\n            if (line[i] === '\\t') {\n                if (tabSize === null) {\n                    tabSize = Editor.getTabSize();\n                }\n                if (tabSize > 0) {\n                    column += (tabSize - (column % tabSize));\n                }\n            } else {\n                column++;\n            }\n        }\n        return column;\n    };\n\n    /**\n     * Returns the string-based pos for a given display column (zero-based) in given line. Differs from column\n     * only when the line contains preceding \\t chars. Result depends on the current tab size setting.\n     * @param {number} lineNum Line number\n     * @param {number} column Display column number\n     * @return {number}\n     */\n    Editor.prototype.getCharIndexForColumn = function (lineNum, column) {\n        var line    = this._codeMirror.getLine(lineNum),\n            tabSize = null,\n            iCol    = 0,\n            i;\n\n        for (i = 0; iCol < column; i++) {\n            if (line[i] === '\\t') {\n                if (tabSize === null) {\n                    tabSize = Editor.getTabSize();\n                }\n                if (tabSize > 0) {\n                    iCol += (tabSize - (iCol % tabSize));\n                }\n            } else {\n                iCol++;\n            }\n        }\n        return i;\n    };\n\n    /**\n     * Sets the cursor position within the editor. Removes any selection.\n     * @param {number} line  The 0 based line number.\n     * @param {number} ch  The 0 based character position; treated as 0 if unspecified.\n     * @param {boolean=} center  True if the view should be centered on the new cursor position.\n     * @param {boolean=} expandTabs  If true, use the actual visual column number instead of the character offset as\n     *      the \"ch\" parameter.\n     */\n    Editor.prototype.setCursorPos = function (line, ch, center, expandTabs) {\n        if (expandTabs) {\n            ch = this.getColOffset({line: line, ch: ch});\n        }\n        this._codeMirror.setCursor(line, ch);\n        if (center) {\n            this.centerOnCursor();\n        }\n    };\n\n    /**\n     * Set the editor size in pixels or percentage\n     * @param {(number|string)} width\n     * @param {(number|string)} height\n     */\n    Editor.prototype.setSize = function (width, height) {\n        this._codeMirror.setSize(width, height);\n    };\n\n    /** @const */\n    var CENTERING_MARGIN = 0.15;\n\n    /**\n     * Scrolls the editor viewport to vertically center the line with the cursor,\n     * but only if the cursor is currently near the edges of the viewport or\n     * entirely outside the viewport.\n     *\n     * This does not alter the horizontal scroll position.\n     *\n     * @param {number} centerOptions Option value, or 0 for no options; one of the BOUNDARY_* constants above.\n     */\n    Editor.prototype.centerOnCursor = function (centerOptions) {\n        let $scrollerElement = $(this.getScrollerElement());\n        let editorHeight = $scrollerElement.height();\n\n        // we need to make adjustments for the statusbar's padding on the bottom and the menu bar on top.\n        let statusBarHeight = $(\"#status-bar\").height();\n\n        let documentCursorPosition = this._codeMirror.cursorCoords(null, \"local\").bottom;\n        let screenCursorPosition = this._codeMirror.cursorCoords(null, \"page\").bottom;\n\n        if(centerOptions === BOUNDARY_BULLSEYE){\n            let pos = documentCursorPosition - editorHeight / 2 + statusBarHeight;\n            this.setScrollPos(null, pos);\n            return;\n        }\n        // If the cursor is already reasonably centered, we won't\n        // make any change. \"Reasonably centered\" is defined as\n        // not being within CENTERING_MARGIN of the top or bottom\n        // of the editor (where CENTERING_MARGIN is a percentage\n        // of the editor height).\n        // For finding the first item (i.e. find while typing), do\n        // not center if hit is in first half of screen because this\n        // appears to be an unnecesary scroll.\n        if ((_checkTopBoundary(centerOptions) && (screenCursorPosition < editorHeight * CENTERING_MARGIN)) ||\n                (_checkBottomBoundary(centerOptions) && (screenCursorPosition > editorHeight * (1 - CENTERING_MARGIN)))) {\n\n            var pos = documentCursorPosition - editorHeight / 2 + statusBarHeight;\n            var info = this._codeMirror.getScrollInfo();\n            pos = Math.min(Math.max(pos, 0), (info.height - info.clientHeight));\n            this.setScrollPos(null, pos);\n        }\n    };\n\n    /**\n     * Given a position, returns its index within the text (assuming \\n newlines)\n     * @param {!{line:number, ch:number}}\n     * @return {number}\n     */\n    Editor.prototype.indexFromPos = function (coords) {\n        return this._codeMirror.indexFromPos(coords);\n    };\n\n    Editor.prototype.posFromIndex = function (index) {\n        return this._codeMirror.posFromIndex(index);\n    };\n\n    /**\n     * Returns true if pos is between start and end (INclusive at start; EXclusive at end by default,\n     * but overridable via the endInclusive flag).\n     * @param {{line:number, ch:number}} pos\n     * @param {{line:number, ch:number}} start\n     * @param {{line:number, ch:number}} end\n     * @param {boolean} endInclusive\n     *\n     */\n    Editor.prototype.posWithinRange = function (pos, start, end, endInclusive) {\n        if (start.line <= pos.line && end.line >= pos.line) {\n            if (endInclusive) {\n                return (start.line < pos.line || start.ch <= pos.ch) &&  // inclusive\n                    (end.line > pos.line   || end.ch >= pos.ch);      // inclusive\n            }\n            return (start.line < pos.line || start.ch <= pos.ch) &&  // inclusive\n                    (end.line > pos.line   || end.ch > pos.ch);       // exclusive\n\n\n        }\n        return false;\n    };\n\n    /**\n     * @return {boolean} True if there's a text selection; false if there's just an insertion point\n     */\n    Editor.prototype.hasSelection = function () {\n        return this._codeMirror.somethingSelected();\n    };\n\n    /**\n     * @private\n     * Takes an anchor/head pair and returns a start/end pair where the start is guaranteed to be <= end, and a \"reversed\" flag indicating\n     * if the head is before the anchor.\n     * @param {!{line: number, ch: number}} anchorPos\n     * @param {!{line: number, ch: number}} headPos\n     * @return {!{start:{line:number, ch:number}, end:{line:number, ch:number}}, reversed:boolean} the normalized range with start <= end\n     */\n    function _normalizeRange(anchorPos, headPos) {\n        if (headPos.line < anchorPos.line || (headPos.line === anchorPos.line && headPos.ch < anchorPos.ch)) {\n            return {start: _copyPos(headPos), end: _copyPos(anchorPos), reversed: true};\n        }\n        return {start: _copyPos(anchorPos), end: _copyPos(headPos), reversed: false};\n\n    }\n\n    /**\n     * Gets the current selection; if there is more than one selection, returns the primary selection\n     * (generally the last one made). Start is inclusive, end is exclusive. If there is no selection,\n     * returns the current cursor position as both the start and end of the range (i.e. a selection\n     * of length zero). If `reversed` is set, then the head of the selection (the end of the selection\n     * that would be changed if the user extended the selection) is before the anchor.\n     * @return {!{start:{line:number, ch:number}, end:{line:number, ch:number}}, reversed:boolean}\n     */\n    Editor.prototype.getSelection = function () {\n        return _normalizeRange(this.getCursorPos(false, \"anchor\"), this.getCursorPos(false, \"head\"));\n    };\n\n    /**\n     * Returns an array of current selections, nonoverlapping and sorted in document order.\n     * Each selection is a start/end pair, with the start guaranteed to come before the end.\n     * Cursors are represented as a range whose start is equal to the end.\n     * If `reversed` is set, then the head of the selection\n     * (the end of the selection that would be changed if the user extended the selection)\n     * is before the anchor.\n     * If `primary` is set, then that selection is the primary selection.\n     * @return {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>}\n     */\n    Editor.prototype.getSelections = function () {\n        var primarySel = this.getSelection();\n        return _.map(this._codeMirror.listSelections(), function (sel) {\n            var result = _normalizeRange(sel.anchor, sel.head);\n            if (result.start.line === primarySel.start.line && result.start.ch === primarySel.start.ch &&\n                    result.end.line === primarySel.end.line && result.end.ch === primarySel.end.ch) {\n                result.primary = true;\n            } else {\n                result.primary = false;\n            }\n            return result;\n        });\n    };\n\n    /**\n     * Takes the given selections, and expands each selection so it encompasses whole lines. Merges\n     * adjacent line selections together. Keeps track of each original selection associated with a given\n     * line selection (there might be multiple if individual selections were merged into a single line selection).\n     * Useful for doing multiple-selection-aware line edits.\n     *\n     * @param {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>} selections\n     *      The selections to expand.\n     * @param {{expandEndAtStartOfLine: boolean, mergeAdjacent: boolean}} options\n     *      expandEndAtStartOfLine: true if a range selection that ends at the beginning of a line should be expanded\n     *          to encompass the line. Default false.\n     *      mergeAdjacent: true if adjacent line ranges should be merged. Default true.\n     * @return {Array.<{selectionForEdit: {start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean},\n     *                  selectionsToTrack: Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>}>}\n     *      The combined line selections. For each selection, `selectionForEdit` is the line selection, and `selectionsToTrack` is\n     *      the set of original selections that combined to make up the given line selection. Note that the selectionsToTrack will\n     *      include the original objects passed in `selections`, so if it is later mutated the original passed-in selections will be\n     *      mutated as well.\n     */\n    Editor.prototype.convertToLineSelections = function (selections, options) {\n        var self = this;\n        options = options || {};\n        _.defaults(options, { expandEndAtStartOfLine: false, mergeAdjacent: true });\n\n        // Combine adjacent lines with selections so they don't collide with each other, as they would\n        // if we did them individually.\n        var combinedSelections = [], prevSel;\n        _.each(selections, function (sel) {\n            var newSel = _.cloneDeep(sel);\n\n            // Adjust selection to encompass whole lines.\n            newSel.start.ch = 0;\n            // The end of the selection becomes the start of the next line, if it isn't already\n            // or if expandEndAtStartOfLine is set.\n            var hasSelection = (newSel.start.line !== newSel.end.line) || (newSel.start.ch !== newSel.end.ch);\n            if (options.expandEndAtStartOfLine || !hasSelection || newSel.end.ch !== 0) {\n                newSel.end = {line: newSel.end.line + 1, ch: 0};\n            }\n\n            // If the start of the new selection is within the range of the previous (expanded) selection, merge\n            // the two selections together, but keep track of all the original selections that were related to this\n            // selection, so they can be properly adjusted. (We only have to check for the start being inside the previous\n            // range - it can't be before it because the selections started out sorted.)\n            if (prevSel && self.posWithinRange(newSel.start, prevSel.selectionForEdit.start, prevSel.selectionForEdit.end, options.mergeAdjacent)) {\n                prevSel.selectionForEdit.end.line = newSel.end.line;\n                prevSel.selectionsToTrack.push(sel);\n            } else {\n                prevSel = {selectionForEdit: newSel, selectionsToTrack: [sel]};\n                combinedSelections.push(prevSel);\n            }\n        });\n        return combinedSelections;\n    };\n\n    /**\n     * Returns the currently selected text, or \"\" if no selection. Includes \\n if the\n     * selection spans multiple lines (does NOT reflect the Document's line-endings style). By\n     * default, returns only the contents of the primary selection, unless `allSelections` is true.\n     * @param {boolean=} allSelections Whether to return the contents of all selections (separated\n     *     by newlines) instead of just the primary selection. Default false.\n     * @return {!string} The selected text.\n     */\n    Editor.prototype.getSelectedText = function (allSelections) {\n        if (allSelections) {\n            return this._codeMirror.getSelection();\n        }\n        var sel = this.getSelection();\n        return this.document.getRange(sel.start, sel.end);\n\n    };\n\n    /**\n     * Sets the current selection. Start is inclusive, end is exclusive. Places the cursor at the\n     * end of the selection range. Optionally centers around the cursor after\n     * making the selection\n     *\n     * @param {!{line:number, ch:number}} start\n     * @param {{line:number, ch:number}=} end If not specified, defaults to start.\n     * @param {boolean} center true to center the viewport\n     * @param {number} centerOptions Option value, or 0 for no options; one of the BOUNDARY_* constants above.\n     * @param {?string} origin An optional string that describes what other selection or edit operations this\n     *      should be merged with for the purposes of undo. See {@link Document#replaceRange} for more details.\n     */\n    Editor.prototype.setSelection = function (start, end, center, centerOptions, origin) {\n        this.setSelections([{start: start, end: end || start}], center, centerOptions, origin);\n    };\n\n    /**\n     * Clears any active selection if present.\n     */\n    Editor.prototype.clearSelection = function () {\n        let pos = this.getCursorPos();\n        this.setCursorPos(pos.line, pos.ch);\n    };\n\n    /**\n     * Sets a multiple selection, with the \"primary\" selection (the one returned by\n     * getSelection() and getCursorPos()) defaulting to the last if not specified.\n     * Overlapping ranges will be automatically merged, and the selection will be sorted.\n     * Optionally centers around the primary selection after making the selection.\n     * @param {!Array<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean}>} selections\n     *      The selection ranges to set. If the start and end of a range are the same, treated as a cursor.\n     *      If reversed is true, set the anchor of the range to the end instead of the start.\n     *      If primary is true, this is the primary selection. Behavior is undefined if more than\n     *      one selection has primary set to true. If none has primary set to true, the last one is primary.\n     * @param {boolean} center true to center the viewport around the primary selection.\n     * @param {number} centerOptions Option value, or 0 for no options; one of the BOUNDARY_* constants above.\n     * @param {?string} origin An optional string that describes what other selection or edit operations this\n     *      should be merged with for the purposes of undo. See {@link Document#replaceRange} for more details.\n     */\n    Editor.prototype.setSelections = function (selections, center, centerOptions, origin) {\n        var primIndex = selections.length - 1, options;\n        if (origin) {\n            options = { origin: origin };\n        }\n        this._codeMirror.setSelections(_.map(selections, function (sel, index) {\n            if (sel.primary) {\n                primIndex = index;\n            }\n            return { anchor: sel.reversed ? sel.end : sel.start, head: sel.reversed ? sel.start : sel.end };\n        }), primIndex, options);\n        if (center) {\n            this.centerOnCursor(centerOptions);\n        }\n    };\n\n    /**\n     * Sets the editors overwrite mode state. If null is passed, the state is toggled.\n     *\n     * @param {?boolean} start\n     */\n    Editor.prototype.toggleOverwrite = function (state) {\n        this._codeMirror.toggleOverwrite(state);\n    };\n\n    /**\n     * Selects word that the given pos lies within or adjacent to. If pos isn't touching a word\n     * (e.g. within a token like \"//\"), moves the cursor to pos without selecting a range.\n     * @param {!{line:number, ch:number}}\n     */\n    Editor.prototype.selectWordAt = function (pos) {\n        var word = this._codeMirror.findWordAt(pos);\n        this.setSelection(word.anchor, word.head);\n    };\n\n    /**\n     * Gets the total number of lines in the document (includes lines not visible in the viewport)\n     * @return {!number}\n     */\n    Editor.prototype.lineCount = function () {\n        return this._codeMirror.lineCount();\n    };\n\n    /**\n     * Deterines if line is fully visible.\n     * @param {number} zero-based index of the line to test\n     * @return {boolean} true if the line is fully visible, false otherwise\n     */\n    Editor.prototype.isLineVisible = function (line) {\n        var coords = this._codeMirror.charCoords({line: line, ch: 0}, \"local\"),\n            scrollInfo = this._codeMirror.getScrollInfo(),\n            top = scrollInfo.top,\n            bottom = scrollInfo.top + scrollInfo.clientHeight;\n\n        // Check top and bottom and return false for partially visible lines.\n        return (coords.top >= top && coords.bottom <= bottom);\n    };\n\n    /**\n     * Gets the number of the first visible line in the editor.\n     * @return {number} The 0-based index of the first visible line.\n     */\n    Editor.prototype.getFirstVisibleLine = function () {\n        return (this._visibleRange ? this._visibleRange.startLine : 0);\n    };\n\n    /**\n     * Gets the number of the last visible line in the editor.\n     * @return {number} The 0-based index of the last visible line.\n     */\n    Editor.prototype.getLastVisibleLine = function () {\n        return (this._visibleRange ? this._visibleRange.endLine : this.lineCount() - 1);\n    };\n\n    /* Hides the specified line number in the editor\n     * @param {!from} line to start hiding from (inclusive)\n     * @param {!to} line to end hiding at (exclusive)\n     * @return {TextMarker} The CodeMirror mark object that's hiding the lines\n     */\n    Editor.prototype._hideLines = function (from, to) {\n        if (to <= from) {\n            return;\n        }\n\n        // We set clearWhenEmpty: false so that if there's a blank line at the beginning or end of\n        // the document, and that's the only hidden line, we can still actually hide it. Doing so\n        // requires us to create a 0-length marked span, which would ordinarily be cleaned up by CM\n        // if clearWithEmpty is true. See https://groups.google.com/forum/#!topic/codemirror/RB8VNF8ow2w\n        var value = this._codeMirror.markText(\n            {line: from, ch: 0},\n            {line: to - 1, ch: this._codeMirror.getLine(to - 1).length},\n            {collapsed: true, inclusiveLeft: true, inclusiveRight: true, clearWhenEmpty: false}\n        );\n\n        return value;\n    };\n\n    /**\n     * Gets the total height of the document in pixels (not the viewport)\n     * @return {!number} height in pixels\n     */\n    Editor.prototype.totalHeight = function () {\n        return this.getScrollerElement().scrollHeight;\n    };\n\n    /**\n     * Gets the scroller element from the editor.\n     * @return {!HTMLDivElement} scroller\n     */\n    Editor.prototype.getScrollerElement = function () {\n        return this._codeMirror.getScrollerElement();\n    };\n\n    /**\n     * Gets the root DOM node of the editor.\n     * @return {!HTMLDivElement} The editor's root DOM node.\n     */\n    Editor.prototype.getRootElement = function () {\n        return this._codeMirror.getWrapperElement();\n    };\n\n\n    /**\n     * Gets the lineSpace element within the editor (the container around the individual lines of code).\n     * FUTURE: This is fairly CodeMirror-specific. Logic that depends on this may break if we switch\n     * editors.\n     * @return {!HTMLDivElement} The editor's lineSpace element.\n     */\n    Editor.prototype._getLineSpaceElement = function () {\n        return $(\".CodeMirror-lines\", this.getScrollerElement()).children().get(0);\n    };\n\n    /**\n     * Returns the current scroll position of the editor.\n     * @return {{x:number, y:number}} The x,y scroll position in pixels\n     */\n    Editor.prototype.getScrollPos = function () {\n        var scrollInfo = this._codeMirror.getScrollInfo();\n        return { x: scrollInfo.left, y: scrollInfo.top };\n    };\n\n    /**\n     * Restores and adjusts the current scroll position of the editor.\n     * @param {{x:number, y:number}} scrollPos - The x,y scroll position in pixels\n     * @param {!number} heightDelta - The amount of delta H to apply to the scroll position\n     */\n    Editor.prototype.adjustScrollPos = function (scrollPos, heightDelta) {\n        this._codeMirror.scrollTo(scrollPos.x, scrollPos.y + heightDelta);\n    };\n\n    /**\n     * Sets the current scroll position of the editor.\n     * @param {number} x scrollLeft position in pixels\n     * @param {number} y scrollTop position in pixels\n     */\n    Editor.prototype.setScrollPos = function (x, y) {\n        this._codeMirror.scrollTo(x, y);\n    };\n\n    /*\n     * Returns the current text height of the editor.\n     * @return {number} Height of the text in pixels\n     */\n    Editor.prototype.getTextHeight = function () {\n        return this._codeMirror.defaultTextHeight();\n    };\n\n    /**\n     * Adds an inline widget below the given line. If any inline widget was already open for that\n     * line, it is closed without warning.\n     * @param {!{line:number, ch:number}} pos  Position in text to anchor the inline.\n     * @param {!InlineWidget} inlineWidget The widget to add.\n     * @param {boolean=} scrollLineIntoView Scrolls the associated line into view. Default true.\n     * @return {$.Promise} A promise object that is resolved when the widget has been added (but might\n     *     still be animating open). Never rejected.\n     */\n    Editor.prototype.addInlineWidget = InlineWidgetHelper.addInlineWidget;\n\n    /**\n     * Removes all inline widgets\n     */\n    Editor.prototype.removeAllInlineWidgets = InlineWidgetHelper.removeAllInlineWidgets;\n\n    /**\n     * Removes the given inline widget.\n     * @param {number} inlineWidget The widget to remove.\n     * @return {$.Promise} A promise that is resolved when the inline widget is fully closed and removed from the DOM.\n     */\n    Editor.prototype.removeInlineWidget = InlineWidgetHelper.removeInlineWidget;\n\n    /**\n     * Removes all inline widgets for a given line\n     * @param {number} lineNum The line number to modify\n     */\n    Editor.prototype.removeAllInlineWidgetsForLine = InlineWidgetHelper.removeAllInlineWidgetsForLine;\n\n    /**\n     * Returns a list of all inline widgets currently open in this editor. Each entry contains the\n     * inline's id, and the data parameter that was passed to addInlineWidget().\n     * @return {!Array.<{id:number, data:Object}>}\n     */\n    Editor.prototype.getInlineWidgets = InlineWidgetHelper.getInlineWidgets;\n\n    /**\n     * Returns the currently focused inline widget, if any.\n     * @return {?InlineWidget}\n     */\n    Editor.prototype.getFocusedInlineWidget = InlineWidgetHelper.getFocusedInlineWidget;\n\n    /**\n     * Sets the height of an inline widget in this editor.\n     * @param {!InlineWidget} inlineWidget The widget whose height should be set.\n     * @param {!number} height The height of the widget.\n     * @param {boolean=} ensureVisible Whether to scroll the entire widget into view. Default false.\n     */\n    Editor.prototype.setInlineWidgetHeight = InlineWidgetHelper.setInlineWidgetHeight;\n\n    /**\n     * Display temporary popover message at current cursor position. Display message above\n     * cursor if space allows, otherwise below.\n     *\n     * @param {string} errorMsg Error message to display\n     * @function\n     */\n    Editor.prototype.displayErrorMessageAtCursor = ErrorPopupHelper.displayErrorMessageAtCursor;\n\n    /**\n     * Returns the offset of the top of the virtual scroll area relative to the browser window (not the editor\n     * itself). Mainly useful for calculations related to scrollIntoView(), where you're starting with the\n     * offset() of a child widget (relative to the browser window) and need to figure out how far down it is from\n     * the top of the virtual scroll area (excluding the top padding).\n     * @return {number}\n     */\n    Editor.prototype.getVirtualScrollAreaTop = function () {\n        var topPadding = this._getLineSpaceElement().offsetTop, // padding within mover\n            scroller = this.getScrollerElement();\n        return $(scroller).offset().top - scroller.scrollTop + topPadding;\n    };\n\n    /** Gives focus to the editor control */\n    Editor.prototype.focus = function () {\n        // Focusing an editor synchronously triggers focus/blur handlers. If a blur handler attemps to focus\n        // another editor, we'll put CM in a bad state (because CM assumes programmatically focusing itself\n        // will always succeed, and if you're in the middle of another focus change that appears to be untrue).\n        // So instead, we simply ignore reentrant focus attempts.\n        // See bug #2951 for an example of this happening and badly hosing things.\n        if (_duringFocus) {\n            return;\n        }\n\n        _duringFocus = true;\n        try {\n            this._codeMirror.focus();\n        } finally {\n            _duringFocus = false;\n        }\n    };\n\n    /** Returns true if the editor has focus */\n    Editor.prototype.hasFocus = function () {\n        return this._focused;\n    };\n\n    /*\n     * @typedef {scrollPos:{x:number, y:number},Array.<{start:{line:number, ch:number},end:{line:number, ch:number}}>} EditorViewState\n     */\n\n    /*\n     * returns the view state for the editor\n     * @return {!EditorViewState}\n     */\n    Editor.prototype.getViewState = function () {\n        return {\n            selections: this.getSelections(),\n            scrollPos: this.getScrollPos()\n        };\n\n    };\n\n    /**\n     * Restores the view state\n     * @param {!EditorViewState} viewState - the view state object to restore\n     */\n    Editor.prototype.restoreViewState = function (viewState) {\n        if (viewState.selection) {\n            // We no longer write out single-selection, but there might be some view state\n            // from an older version.\n            this.setSelection(viewState.selection.start, viewState.selection.end);\n        }\n        if (viewState.selections) {\n            this.setSelections(viewState.selections);\n        }\n        if (viewState.scrollPos) {\n            this.setScrollPos(viewState.scrollPos.x, viewState.scrollPos.y);\n        }\n    };\n\n    /**\n     * Re-renders the editor UI\n     * @param {boolean=} handleResize true if this is in response to resizing the editor. Default false.\n     */\n    Editor.prototype.refresh = function (handleResize) {\n        // If focus is currently in a child of the CodeMirror editor (e.g. in an inline widget), but not in\n        // the CodeMirror input field itself, remember the focused item so we can restore focus after the\n        // refresh (which might cause the widget to be removed from the display list temporarily).\n        var focusedItem = window.document.activeElement,\n            restoreFocus = $.contains(this._codeMirror.getScrollerElement(), focusedItem);\n        this._codeMirror.refresh();\n        if (restoreFocus) {\n            focusedItem.focus();\n        }\n    };\n\n    /**\n     * Re-renders the editor, and all children inline editors.\n     * @param {boolean=} handleResize true if this is in response to resizing the editor. Default false.\n     */\n    Editor.prototype.refreshAll = function (handleResize) {\n        this.refresh(handleResize);\n        this.getInlineWidgets().forEach(function (inlineWidget) {\n            inlineWidget.refresh();\n        });\n    };\n\n    /** Undo the last edit. */\n    Editor.prototype.undo = function () {\n        this._codeMirror.undo();\n    };\n\n    /** Redo the last un-done edit. */\n    Editor.prototype.redo = function () {\n        this._codeMirror.redo();\n    };\n\n    /**\n     * View API Visibility Change Notification handler.  This is also\n     * called by the native \"setVisible\" API which refresh can be optimized\n     * @param {boolean} show true to show the editor, false to hide it\n     * @param {boolean} refresh true (default) to refresh the editor, false to skip refreshing it\n     */\n    Editor.prototype.notifyVisibilityChange = function (show, refresh) {\n        if (show && (refresh || refresh === undefined)) {\n            this.refresh();\n        }\n        if (show) {\n            this._inlineWidgets.forEach(function (inlineWidget) {\n                inlineWidget.onParentShown();\n            });\n        }\n    };\n\n    /**\n     * Shows or hides the editor within its parent. Does not force its ancestors to\n     * become visible.\n     * @param {boolean} show true to show the editor, false to hide it\n     * @param {boolean} refresh true (default) to refresh the editor, false to skip refreshing it\n     */\n    Editor.prototype.setVisible = function (show, refresh) {\n        this.$el.css(\"display\", (show ? \"\" : \"none\"));\n        this.notifyVisibilityChange(show, refresh);\n    };\n\n    /**\n     * Returns true if the editor is fully visible--i.e., is in the DOM, all ancestors are\n     * visible, and has a non-zero width/height.\n     */\n    Editor.prototype.isFullyVisible = function () {\n        return $(this.getRootElement()).is(\":visible\");\n    };\n\n    /**\n     * Gets the syntax-highlighting mode for the given range.\n     * Returns null if the mode at the start of the selection differs from the mode at the end -\n     * an *approximation* of whether the mode is consistent across the whole range (a pattern like\n     * A-B-A would return A as the mode, not null).\n     *\n     * @param {!{line: number, ch: number}} start The start of the range to check.\n     * @param {!{line: number, ch: number}} end The end of the range to check.\n     * @param {boolean=} knownMixed Whether we already know we're in a mixed mode and need to check both\n     *     the start and end.\n     * @return {?(Object|string)} Name of syntax-highlighting mode, or object containing a \"name\" property\n     *     naming the mode along with configuration options required by the mode.\n     * @see {@link LanguageManager::#getLanguageForPath} and {@link LanguageManager::Language#getMode}.\n     */\n    Editor.prototype.getModeForRange = function (start, end, knownMixed) {\n        var outerMode = this._codeMirror.getMode(),\n            startMode = TokenUtils.getModeAt(this._codeMirror, start),\n            endMode = TokenUtils.getModeAt(this._codeMirror, end);\n        if (!knownMixed && outerMode.name === startMode.name) {\n            // Mode does not vary: just use the editor-wide mode name\n            return this._codeMirror.getOption(\"mode\");\n        } else if (!startMode || !endMode || startMode.name !== endMode.name) {\n            return null;\n        }\n        return startMode;\n\n    };\n\n    /**\n     * Gets the syntax-highlighting mode for the current selection or cursor position. (The mode may\n     * vary within one file due to embedded languages, e.g. JS embedded in an HTML script block). See\n     * `getModeForRange()` for how this is determined for a single selection.\n     *\n     * If there are multiple selections, this will return a mode only if all the selections are individually\n     * consistent and resolve to the same mode.\n     *\n     * @return {?(Object|string)} Name of syntax-highlighting mode, or object containing a \"name\" property\n     *     naming the mode along with configuration options required by the mode.\n     * @see {@link LanguageManager::#getLanguageForPath} and {@link LanguageManager::Language#getMode}.\n     */\n    Editor.prototype.getModeForSelection = function () {\n        // Check for mixed mode info\n        var self        = this,\n            sels        = this.getSelections(),\n            primarySel  = this.getSelection(),\n            outerMode   = this._codeMirror.getMode(),\n            startMode   = TokenUtils.getModeAt(this._codeMirror, primarySel.start),\n            isMixed     = (outerMode.name !== startMode.name);\n\n        if (isMixed) {\n            // This is the magic code to let the code view know that we are in 'css' context\n            // if the CodeMirror outermode is 'htmlmixed' and we are in 'style' attributes\n            // value context. This has to be done as CodeMirror doesn't yet think this as 'css'\n            // This magic is executed only when user is having a cursor and not selection\n            // We will enable selection handling one we figure a way out to handle mixed scope selection\n            if (outerMode.name === 'htmlmixed' && primarySel.start.line === primarySel.end.line && primarySel.start.ch === primarySel.end.ch) {\n                var tagInfo = HTMLUtils.getTagInfo(this, primarySel.start, true),\n                    tokenType = tagInfo.position.tokenType;\n\n                if (tokenType === HTMLUtils.ATTR_VALUE && tagInfo.attr.name.toLowerCase() === 'style') {\n                    return 'css';\n                }\n            }\n            // Shortcut the first check to avoid getModeAt(), which can be expensive\n            if (primarySel.start.line !== primarySel.end.line || primarySel.start.ch !== primarySel.end.ch) {\n                var endMode = TokenUtils.getModeAt(this._codeMirror, primarySel.end);\n\n                if (startMode.name !== endMode.name) {\n                    return null;\n                }\n            }\n\n            // If mixed mode, check that mode is the same at start & end of each selection\n            var hasMixedSel = _.some(sels, function (sel) {\n                if (sels === primarySel) {\n                    // We already checked this before, so we know it's not mixed.\n                    return false;\n                }\n\n                var rangeMode = self.getModeForRange(sel.start, sel.end, true);\n                return (!rangeMode || rangeMode.name !== startMode.name);\n            });\n            if (hasMixedSel) {\n                return null;\n            }\n\n            return startMode.name;\n        }\n            // Mode does not vary: just use the editor-wide mode\n        return this._codeMirror.getOption(\"mode\");\n\n    };\n\n    /**\n     * gets the language for the selection. (Javascript selected from an HTML document or CSS selected from an HTML\n     * document, etc...)\n     * @return {!Language}\n     */\n    Editor.prototype.getLanguageForSelection = function () {\n        return this.document.getLanguage().getLanguageForMode(this.getModeForSelection());\n    };\n\n    /**\n     * Gets the syntax-highlighting mode for the document.\n     *\n     * @return {Object|String} Object or Name of syntax-highlighting mode\n     * @see {@link LanguageManager::#getLanguageForPath|LanguageManager.getLanguageForPath} and {@link LanguageManager::Language#getMode|Language.getMode}.\n     */\n    Editor.prototype.getModeForDocument = function () {\n        return this._codeMirror.getOption(\"mode\");\n    };\n\n    /**\n     * The Document we're bound to\n     * @type {!Document}\n     */\n    Editor.prototype.document = null;\n\n\n    /**\n     * The Editor's last known width.\n     * Used in conjunction with updateLayout to recompute the layout\n     * if the parent container changes its size since our last layout update.\n     * @type {?number}\n     */\n    Editor.prototype._lastEditorWidth = null;\n\n\n    /**\n     * If true, we're in the middle of syncing to/from the Document. Used to ignore spurious change\n     * events caused by us (vs. change events caused by others, which we need to pay attention to).\n     * @type {!boolean}\n     */\n    Editor.prototype._duringSync = false;\n\n    /**\n     * @private\n     * NOTE: this is actually \"semi-private\": EditorManager also accesses this field... as well as\n     * a few other modules. However, we should try to gradually move most code away from talking to\n     * CodeMirror directly.\n     * @type {!CodeMirror}\n     */\n    Editor.prototype._codeMirror = null;\n\n    /**\n     * @private\n     * @type {!Array.<{id:number, data:Object}>}\n     */\n    Editor.prototype._inlineWidgets = null;\n\n    /**\n     * @private\n     * @type {?TextRange}\n     */\n    Editor.prototype._visibleRange = null;\n\n    /**\n     * @private\n     * @type {Object}\n     * Promise queues for inline widgets being added to a given line.\n     */\n    Editor.prototype._inlineWidgetQueues = null;\n\n    /**\n     * @private\n     * @type {Array}\n     * A list of objects corresponding to the markers that are hiding lines in the current editor.\n     */\n    Editor.prototype._hideMarks = null;\n\n    /**\n     * @private\n     *\n     * Retrieve the value of the named preference for this document.\n     *\n     * @param {string} prefName Name of preference to retrieve.\n     * @return {*} current value of that pref\n     */\n    Editor.prototype._getOption = function (prefName) {\n        return PreferencesManager.get(prefName, PreferencesManager._buildContext(this.document.file.fullPath, this.document.getLanguage().getId()));\n    };\n\n    /**\n     * @private\n     *\n     * Updates the editor to the current value of prefName for the file being edited.\n     *\n     * @param {string} prefName Name of the preference to visibly update\n     */\n    Editor.prototype._updateOption = function (prefName) {\n        var oldValue = this._currentOptions[prefName],\n            newValue = this._getOption(prefName);\n\n        if (oldValue !== newValue) {\n            this._currentOptions[prefName] = newValue;\n\n            if (prefName === USE_TAB_CHAR) {\n                this._codeMirror.setOption(cmOptions[prefName], newValue);\n                this._codeMirror.setOption(\"indentUnit\", newValue === true ?\n                                           this._currentOptions[TAB_SIZE] :\n                                           this._currentOptions[SPACE_UNITS]\n                                          );\n            } else if (prefName === STYLE_ACTIVE_LINE) {\n                this._updateStyleActiveLine();\n            } else if (prefName === SCROLL_PAST_END && this._visibleRange) {\n                // Do not apply this option to inline editors\n                return;\n            } else if (prefName === SHOW_LINE_NUMBERS) {\n                Editor._toggleLinePadding(!newValue);\n                this._codeMirror.setOption(cmOptions[SHOW_LINE_NUMBERS], newValue);\n                if (newValue) {\n                    Editor.registerGutter(LINE_NUMBER_GUTTER, LINE_NUMBER_GUTTER_PRIORITY);\n                } else {\n                    Editor.unregisterGutter(LINE_NUMBER_GUTTER);\n                }\n                this.refreshAll();\n            } else {\n                this._codeMirror.setOption(cmOptions[prefName], newValue);\n            }\n\n            this.trigger(\"optionChange\", prefName, newValue);\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Used to ensure that \"style active line\" is turned off when there is a selection.\n     */\n    Editor.prototype._updateStyleActiveLine = function () {\n        if (this.hasSelection()) {\n            if (this._codeMirror.getOption(\"styleActiveLine\")) {\n                this._codeMirror.setOption(\"styleActiveLine\", false);\n            }\n        } else {\n            this._codeMirror.setOption(\"styleActiveLine\", this._currentOptions[STYLE_ACTIVE_LINE]);\n        }\n    };\n\n    /**\n     * resizes the editor to fill its parent container\n     * should not be used on inline editors\n     * @param {boolean=} forceRefresh - forces the editor to update its layout\n     *                                   even if it already matches the container's height / width\n     */\n    Editor.prototype.updateLayout = function (forceRefresh) {\n        var curRoot = this.getRootElement(),\n            curWidth = $(curRoot).width(),\n            $editorHolder = this.$el.parent(),\n            editorAreaHt = $editorHolder.height();\n\n        if (!curRoot.style.height || $(curRoot).height() !== editorAreaHt) {\n            // Call setSize() instead of $.height() to allow CodeMirror to\n            // check for options like line wrapping\n            this.setSize(null, editorAreaHt);\n            if (forceRefresh === undefined) {\n                forceRefresh = true;\n            }\n        } else if (curWidth !== this._lastEditorWidth) {\n            if (forceRefresh === undefined) {\n                forceRefresh = true;\n            }\n        }\n        this._lastEditorWidth = curWidth;\n\n        if (forceRefresh) {\n            this.refreshAll(forceRefresh);\n        }\n    };\n\n    /**\n     * Clears all marks from the gutter with the specified name.\n     * @param {string} name The name of the gutter to clear.\n     */\n    Editor.prototype.clearGutter = function (name) {\n        this._codeMirror.clearGutter(name);\n    };\n\n    /**\n     * Renders all registered gutters\n     * @private\n     */\n    Editor.prototype._renderGutters = function () {\n        var languageId = this.document.getLanguage().getId();\n\n        function _filterByLanguages(gutter) {\n            return !gutter.languages || gutter.languages.indexOf(languageId) > -1;\n        }\n\n        function _sortByPriority(a, b) {\n            return a.priority - b.priority;\n        }\n\n        function _getName(gutter) {\n            return gutter.name;\n        }\n\n        var gutters = registeredGutters.map(_getName),\n            rootElement = this.getRootElement();\n\n        // If the line numbers gutter has not been explicitly registered and the CodeMirror lineNumbes option is\n        // set to true, we explicitly add the line numbers gutter. This case occurs the first time the editor loads\n        // and showLineNumbers is set to true in preferences\n        if (gutters.indexOf(LINE_NUMBER_GUTTER) < 0 && this._codeMirror.getOption(cmOptions[SHOW_LINE_NUMBERS])) {\n            registeredGutters.push({name: LINE_NUMBER_GUTTER, priority: LINE_NUMBER_GUTTER_PRIORITY});\n        }\n\n        gutters = registeredGutters.sort(_sortByPriority)\n            .filter(_filterByLanguages)\n            .map(_getName);\n\n        this._codeMirror.setOption(\"gutters\", gutters);\n        this._codeMirror.refresh();\n\n        if (gutters.indexOf(LINE_NUMBER_GUTTER) < 0) {\n            $(rootElement).addClass(\"linenumber-disabled\");\n        } else {\n            $(rootElement).removeClass(\"linenumber-disabled\");\n        }\n    };\n\n    /**\n     * Sets the marker for the specified gutter on the specified line number\n     * @param   {string}   lineNumber The line number for the inserted gutter marker\n     * @param   {string}   gutterName The name of the gutter\n     * @param   {object}   marker     The dom element representing the marker to the inserted in the gutter\n     */\n    Editor.prototype.setGutterMarker = function (lineNumber, gutterName, marker) {\n        var gutterNameRegistered = registeredGutters.some(function (gutter) {\n            return gutter.name === gutterName;\n        });\n\n        if (!gutterNameRegistered) {\n            console.warn(\"Gutter name must be registered before calling editor.setGutterMarker\");\n            return;\n        }\n\n        this._codeMirror.setGutterMarker(lineNumber, gutterName, marker);\n    };\n\n    /**\n     * Returns the list of gutters current registered on all editors.\n     * @return {!Array.<{name: string, priority: number}>}\n     */\n    Editor.getRegisteredGutters = function () {\n        return registeredGutters;\n    };\n\n    /**\n     * Registers the gutter with the specified name at the given priority.\n     * @param {string} name    The name of the gutter.\n     * @param {number} priority  A number denoting the priority of the gutter. Priorities higher than LINE_NUMBER_GUTTER_PRIORITY appear after the line numbers. Priority less than LINE_NUMBER_GUTTER_PRIORITY appear before.\n     * @param {?Array<string>} languageIds A list of language ids that this gutter is valid for. If no language ids are passed, then the gutter is valid in all languages.\n     */\n    Editor.registerGutter = function (name, priority, languageIds) {\n        if (isNaN(priority)) {\n            console.warn(\"A non-numeric priority value was passed to registerGutter. The value will default to 0.\");\n            priority = 0;\n        }\n\n        if (!name || typeof name !== \"string\") {\n            console.error(\"The name of the registered gutter must be a string.\");\n            return;\n        }\n\n        var gutter = {name: name, priority: priority, languages: languageIds},\n            gutterExists = registeredGutters.some(function (gutter) {\n                return gutter.name === name;\n            });\n\n        if (!gutterExists) {\n            registeredGutters.push(gutter);\n        }\n\n        Editor.forEveryEditor(function (editor) {\n            editor._renderGutters();\n        });\n    };\n\n    /**\n     * Unregisters the gutter with the specified name and removes it from the UI.\n     * @param {string} name The name of the gutter to be unregistered.\n     */\n    Editor.unregisterGutter = function (name) {\n        var i, gutter;\n        registeredGutters = registeredGutters.filter(function (gutter) {\n            return gutter.name !== name;\n        });\n\n        Editor.forEveryEditor(function (editor) {\n            editor._renderGutters();\n        });\n    };\n\n    // Global settings that affect Editor instances that share the same preference locations\n\n    /**\n     * Sets whether to use tab characters (vs. spaces) when inserting new text.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setUseTabChar = function (value, fullPath) {\n        var options = fullPath && {context: fullPath};\n        return PreferencesManager.set(USE_TAB_CHAR, value, options);\n    };\n\n    /**\n     * Gets whether the specified or current file uses tab characters (vs. spaces) when inserting new text\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getUseTabChar = function (fullPath) {\n        return PreferencesManager.get(USE_TAB_CHAR, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets tab character width.\n     * Affects any editors that share the same preference location.\n     * @param {number} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setTabSize = function (value, fullPath) {\n        var options = fullPath && {context: fullPath};\n        return PreferencesManager.set(TAB_SIZE, value, options);\n    };\n\n    /**\n     * Get indent unit\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {number}\n     */\n    Editor.getTabSize = function (fullPath) {\n        return PreferencesManager.get(TAB_SIZE, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets indentation width.\n     * Affects any editors that share the same preference location.\n     * @param {number} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setSpaceUnits = function (value, fullPath) {\n        var options = fullPath && {context: fullPath};\n        return PreferencesManager.set(SPACE_UNITS, value, options);\n    };\n\n    /**\n     * Get indentation width\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {number}\n     */\n    Editor.getSpaceUnits = function (fullPath) {\n        return PreferencesManager.get(SPACE_UNITS, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets the auto close brackets.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setCloseBrackets = function (value, fullPath) {\n        var options = fullPath && {context: fullPath};\n        return PreferencesManager.set(CLOSE_BRACKETS, value, options);\n    };\n\n    /**\n     * Gets whether the specified or current file uses auto close brackets\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getCloseBrackets = function (fullPath) {\n        return PreferencesManager.get(CLOSE_BRACKETS, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets show line numbers option.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setShowLineNumbers = function (value, fullPath) {\n        var options = fullPath && {context: fullPath};\n        return PreferencesManager.set(SHOW_LINE_NUMBERS, value, options);\n    };\n\n    /**\n     * Returns true if show line numbers is enabled for the specified or current file\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getShowLineNumbers = function (fullPath) {\n        return PreferencesManager.get(SHOW_LINE_NUMBERS, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets show active line option.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setShowActiveLine = function (value, fullPath) {\n        return PreferencesManager.set(STYLE_ACTIVE_LINE, value);\n    };\n\n    /**\n     * Returns true if show active line is enabled for the specified or current file\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getShowActiveLine = function (fullPath) {\n        return PreferencesManager.get(STYLE_ACTIVE_LINE, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets word wrap option.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setWordWrap = function (value, fullPath) {\n        var options = fullPath && {context: fullPath};\n        return PreferencesManager.set(WORD_WRAP, value, options);\n    };\n\n    /**\n     * Returns true if word wrap is enabled for the specified or current file\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getWordWrap = function (fullPath) {\n        return PreferencesManager.get(WORD_WRAP, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Sets indentLineComment option.\n     * Affects any editors that share the same preference location.\n     * @param {boolean} value\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean} true if value was valid\n     */\n    Editor.setIndentLineComment = function (value, fullPath) {\n        var options = fullPath && {context: fullPath};\n        return PreferencesManager.set(INDENT_LINE_COMMENT, value, options);\n    };\n\n    /**\n     * Returns true if indentLineComment is enabled for the specified or current file\n     * @param {string=} fullPath Path to file to get preference for\n     * @return {boolean}\n     */\n    Editor.getIndentLineComment = function (fullPath) {\n        return PreferencesManager.get(INDENT_LINE_COMMENT, _buildPreferencesContext(fullPath));\n    };\n\n    /**\n     * Runs callback for every Editor instance that currently exists\n     * @param {!function(!Editor)} callback\n     */\n    Editor.forEveryEditor = function (callback) {\n        _instances.forEach(callback);\n    };\n\n    /**\n     * @private\n     * Toggles the left padding of all code editors.  Used to provide more\n     * space between the code text and the left edge of the editor when\n     * line numbers are hidden.\n     * @param {boolean} showLinePadding\n     */\n    Editor._toggleLinePadding = function (showLinePadding) {\n        // apply class to all pane DOM nodes\n        var $holders = [];\n        _instances.forEach(function (editor) {\n            var $editorHolder = editor.$el.parent();\n            if ($holders.indexOf($editorHolder) === -1) {\n                $holders.push($editorHolder);\n            }\n        });\n\n        _.each($holders, function ($holder) {\n            $holder.toggleClass(\"show-line-padding\", Boolean(showLinePadding));\n        });\n    };\n\n    Editor.LINE_NUMBER_GUTTER_PRIORITY = LINE_NUMBER_GUTTER_PRIORITY;\n    Editor.CODE_FOLDING_GUTTER_PRIORITY = CODE_FOLDING_GUTTER_PRIORITY;\n\n    // Set up listeners for preference changes\n    editorOptions.forEach(function (prefName) {\n        PreferencesManager.on(\"change\", prefName, function () {\n            _instances.forEach(function (editor) {\n                editor._updateOption(prefName);\n            });\n        });\n    });\n\n    // Define public API\n    exports.Editor                  = Editor;\n    exports.BOUNDARY_CHECK_NORMAL   = BOUNDARY_CHECK_NORMAL;\n    exports.BOUNDARY_IGNORE_TOP     = BOUNDARY_IGNORE_TOP;\n    exports.BOUNDARY_BULLSEYE      = BOUNDARY_BULLSEYE;\n});\n"],"file":"Editor.js"}
{"version":3,"sources":["editor/CodeHintManager.js"],"names":["define","require","exports","module","Commands","CommandManager","EditorManager","Strings","KeyEvent","CodeHintList","PreferencesManager","hintProviders","all","lastChar","sessionProvider","sessionEditor","hintList","deferredHints","keyDownEditor","codeHintsEnabled","codeHintOpened","_beginSession","_providerSort","a","b","priority","registerHintProvider","providerInfo","languageIds","providerObj","provider","languageId","indexOf","hasOwnProperty","push","sort","forEach","Array","prototype","concat","_removeHintProvider","targetLanguageId","index","providers","targetLanguageIdArr","isArray","Object","keys","length","splice","_getProvidersForLanguageId","filter","prefKey","constructor","name","get","_endSession","close","reject","_inSession","editor","isOpen","state","_updateHintList","callMoveUpEvent","callMoveUp","response","getHints","previousEditor","update","open","done","hints","_handleKeydownEvent","jqEvent","event","ctrlKey","altKey","metaKey","keyCode","DOM_VK_ENTER","DOM_VK_RETURN","DOM_VK_TAB","String","fromCharCode","_handleKeypressEvent","charCode","addPendingText","_handleKeyupEvent","DOM_VK_HOME","DOM_VK_END","DOM_VK_LEFT","DOM_VK_RIGHT","DOM_VK_BACK_SPACE","DOM_VK_SPACE","_handleCursorActivity","getSelections","_handleChange","changeList","charToRetest","text","expectedLength","getCursorPos","ch","from","newText","substr","removePendingText","hasValidExclusion","exclusion","textAfterCursor","_startNewSession","getFocusedEditor","_getCodeHintList","activeEditorChangeHandler","current","previous","on","off","definePreference","description","DESCRIPTION_SHOW_CODE_HINTS","DESCRIPTION_INSERT_HINT_ON_TAB","DESCRIPTION_MAX_CODE_HINTS","language","enabledProviders","getLanguageForSelection","getId","some","item","hasHints","insertHintOnTab","maxCodeHints","undefined","onHighlight","$hint","$hintDescContainer","enableDescription","updateHintDescription","onSelect","hint","restart","insertHint","onClose","getActiveEditor","commandId","SHOW_CODE_HINTS","register","CMD_SHOW_CODE_HINTS"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*\n * __CodeHintManager Overview:__\n *\n * The CodeHintManager mediates the interaction between the editor and a\n * collection of hint providers. If hints are requested explicitly by the\n * user, then the providers registered for the current language are queried\n * for their ability to provide hints in order of descending priority by\n * way their hasHints methods. Character insertions may also constitute an\n * implicit request for hints; consequently, providers for the current\n * language are also queried on character insertion for both their ability to\n * provide hints and also for the suitability of providing implicit hints\n * in the given editor context.\n *\n * Once a provider responds affirmatively to a request for hints, the\n * manager begins a hinting session with that provider, begins to query\n * that provider for hints by way of its getHints method, and opens the\n * hint list window. The hint list is kept open for the duration of the\n * current session. The manager maintains the session until either:\n *\n *  1. the provider gives a null response to a request for hints;\n *  2. a deferred response to getHints fails to resolve;\n *  3. the user explicitly dismisses the hint list window;\n *  4. the editor is closed or becomes inactive; or\n *  5. the editor undergoes a \"complex\" change, e.g., a multi-character\n *     insertion, deletion or navigation.\n *\n * Single-character insertions, deletions or navigations may not\n * invalidate the current session; in which case, each such change\n * precipitates a successive call to getHints.\n *\n * If the user selects a hint from the rendered hint list then the\n * provider is responsible for inserting the hint into the editor context\n * for the current session by way of its insertHint method. The provider\n * may use the return value of insertHint to request that an additional\n * explicit hint request be triggered, potentially beginning a new\n * session.\n *\n *\n * __CodeHintProvider Overview:__\n *\n * A code hint provider should implement the following three functions:\n *\n * - `CodeHintProvider.hasHints(editor, implicitChar)`\n * - `CodeHintProvider.getHints(implicitChar)`\n * - `CodeHintProvider.insertHint(hint)`\n *\n * The behavior of these three functions is described in detail below.\n *\n * __CodeHintProvider.hasHints(editor, implicitChar)__\n *\n * The method by which a provider indicates intent to provide hints for a\n * given editor. The manager calls this method both when hints are\n * explicitly requested (via, e.g., Ctrl-Space) and when they may be\n * implicitly requested as a result of character insertion in the editor.\n * If the provider responds negatively then the manager may query other\n * providers for hints. Otherwise, a new hinting session begins with this\n * provider, during which the manager may repeatedly query the provider\n * for hints via the getHints method. Note that no other providers will be\n * queried until the hinting session ends.\n *\n * The implicitChar parameter is used to determine whether the hinting\n * request is explicit or implicit. If the string is null then hints were\n * explicitly requested and the provider should reply based on whether it\n * is possible to return hints for the given editor context. Otherwise,\n * the string contains just the last character inserted into the editor's\n * document and the request for hints is implicit. In this case, the\n * provider should determine whether it is both possible and appropriate\n * to show hints. Because implicit hints can be triggered by every\n * character insertion, hasHints may be called frequently; consequently,\n * the provider should endeavor to return a value as quickly as possible.\n *\n * Because calls to hasHints imply that a hinting session is about to\n * begin, a provider may wish to clean up cached data from previous\n * sessions in this method. Similarly, if the provider returns true, it\n * may wish to prepare to cache data suitable for the current session. In\n * particular, it should keep a reference to the editor object so that it\n * can access the editor in future calls to getHints and insertHints.\n *\n * param {Editor} editor\n * A non-null editor object for the active window.\n *\n * param {string} implicitChar\n * Either null, if the hinting request was explicit, or a single character\n * that represents the last insertion and that indicates an implicit\n * hinting request.\n *\n * return {boolean}\n * Determines whether the current provider is able to provide hints for\n * the given editor context and, in case implicitChar is non- null,\n * whether it is appropriate to do so.\n *\n *\n * __CodeHintProvider.getHints(implicitChar)__\n *\n * The method by which a provider provides hints for the editor context\n * associated with the current session. The getHints method is called only\n * if the provider asserted its willingness to provide hints in an earlier\n * call to hasHints. The provider may return null or false, which indicates\n * that the manager should end the current hinting session and close the hint\n * list window; or true, which indicates that the manager should end the\n * current hinting session but immediately attempt to begin a new hinting\n * session by querying registered providers. Otherwise, the provider should\n * return a response object that contains the following properties:\n *\n *  1. hints, a sorted array hints that the provider could later insert\n *     into the editor;\n *  2. match, a string that the manager may use to emphasize substrings of\n *     hints in the hint list (case-insensitive); and\n *  3. selectInitial, a boolean that indicates whether or not the\n *     first hint in the list should be selected by default.\n *  4. handleWideResults, a boolean (or undefined) that indicates whether\n *     to allow result string to stretch width of display.\n *\n * If the array of\n * hints is empty, then the manager will render an empty list, but the\n * hinting session will remain open and the value of the selectInitial\n * property is irrelevant.\n *\n * Alternatively, the provider may return a jQuery.Deferred object\n * that resolves with an object with the structure described above. In\n * this case, the manager will initially render the hint list window with\n * a throbber and will render the actual list once the deferred object\n * resolves to a response object. If a hint list has already been rendered\n * (from an earlier call to getHints), then the old list will continue\n * to be displayed until the new deferred has resolved.\n *\n * Both the manager and the provider can reject the deferred object. The\n * manager will reject the deferred if the editor changes state (e.g., the\n * user types a character) or if the hinting session ends (e.g., the user\n * explicitly closes the hints by pressing escape). The provider can use\n * this event to, e.g., abort an expensive computation. Consequently, the\n * provider may assume that getHints will not be called again until the\n * deferred object from the current call has resolved or been rejected. If\n * the provider rejects the deferred, the manager will end the hinting\n * session.\n *\n * The getHints method may be called by the manager repeatedly during a\n * hinting session. Providers may wish to cache information for efficiency\n * that may be useful throughout these sessions. The same editor context\n * will be used throughout a session, and will only change during the\n * session as a result of single-character insertions, deletions and\n * cursor navigations. The provider may assume that, throughout the\n * lifetime of the session, the getHints method will be called exactly\n * once for each such editor change. Consequently, the provider may also\n * assume that the document will not be changed outside of the editor\n * during a session.\n *\n * param {string} implicitChar\n * Either null, if the request to update the hint list was a result of\n * navigation, or a single character that represents the last insertion.\n *\n *     return {jQuery.Deferred|{\n *          hints: Array.<string|jQueryObject>,\n *          match: string,\n *          selectInitial: boolean,\n *          handleWideResults: boolean}}\n *\n * Null if the provider wishes to end the hinting session. Otherwise, a\n * response object, possibly deferred, that provides 1. a sorted array\n * hints that consists either of strings or jQuery objects; 2. a string\n * match, possibly null, that is used by the manager to emphasize\n * matching substrings when rendering the hint list; and 3. a boolean that\n * indicates whether the first result, if one exists, should be selected\n * by default in the hint list window. If match is non-null, then the\n * hints should be strings.\n *\n * If the match is null, the manager will not\n * attempt to emphasize any parts of the hints when rendering the hint\n * list; instead the provider may return strings or jQuery objects for\n * which emphasis is self-contained. For example, the strings may contain\n * substrings that wrapped in bold tags. In this way, the provider can\n * choose to let the manager handle emphasis for the simple and common case\n * of prefix matching, or can provide its own emphasis if it wishes to use\n * a more sophisticated matching algorithm.\n *\n *\n * __CodeHintProvider.insertHint(hint)__\n *\n * The method by which a provider inserts a hint into the editor context\n * associated with the current session. The provider may assume that the\n * given hint was returned by the provider in some previous call in the\n * current session to getHints, but not necessarily the most recent call.\n * After the insertion has been performed, the current hinting session is\n * closed. The provider should return a boolean value to indicate whether\n * or not the end of the session should be immediately followed by a new\n * explicit hinting request, which may result in a new hinting session\n * being opened with some provider, but not necessarily the current one.\n *\n * param {string} hint\n * The hint to be inserted into the editor context for the current session.\n *\n * return {boolean}\n * Indicates whether the manager should follow hint insertion with an\n * explicit hint request.\n *\n *\n * __CodeHintProvider.insertHintOnTab__\n *\n * type {?boolean} insertHintOnTab\n * Indicates whether the CodeHintManager should request that the provider of\n * the current session insert the currently selected hint on tab key events,\n * or if instead a tab character should be inserted into the editor. If omitted,\n * the fallback behavior is determined by the CodeHintManager. The default\n * behavior is to insert a tab character, but this can be changed with the\n * insertHintOnTab Preference.\n */\ndefine(function (require, exports, module) {\n\n\n    // Load dependent modules\n    var Commands            = require(\"command/Commands\"),\n        CommandManager      = require(\"command/CommandManager\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        Strings             = require(\"strings\"),\n        KeyEvent            = require(\"utils/KeyEvent\"),\n        CodeHintList        = require(\"editor/CodeHintList\").CodeHintList,\n        PreferencesManager  = require(\"preferences/PreferencesManager\");\n\n    var hintProviders    = { \"all\": [] },\n        lastChar         = null,\n        sessionProvider  = null,\n        sessionEditor    = null,\n        hintList         = null,\n        deferredHints    = null,\n        keyDownEditor    = null,\n        codeHintsEnabled = true,\n        codeHintOpened   = false;\n\n    PreferencesManager.definePreference(\"showCodeHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_SHOW_CODE_HINTS\n    });\n    PreferencesManager.definePreference(\"insertHintOnTab\", \"boolean\", false, {\n        description: Strings.DESCRIPTION_INSERT_HINT_ON_TAB\n    });\n    PreferencesManager.definePreference(\"maxCodeHints\", \"number\", 50, {\n        description: Strings.DESCRIPTION_MAX_CODE_HINTS\n    });\n\n    PreferencesManager.on(\"change\", \"showCodeHints\", function () {\n        codeHintsEnabled = PreferencesManager.get(\"showCodeHints\");\n    });\n\n    /**\n     * Comparator to sort providers from high to low priority\n     */\n    function _providerSort(a, b) {\n        return b.priority - a.priority;\n    }\n\n    /**\n     * The method by which a CodeHintProvider registers its willingness to\n     * providing hints for editors in a given language.\n     *\n     * @param {!CodeHintProvider} provider\n     * The hint provider to be registered, described below.\n     *\n     * @param {!Array.<string>} languageIds\n     * The set of language ids for which the provider is capable of\n     * providing hints. If the special language id name \"all\" is included then\n     * the provider may be called for any language.\n     *\n     * @param {?number} priority\n     * Used to break ties among hint providers for a particular language.\n     * Providers with a higher number will be asked for hints before those\n     * with a lower priority value. Defaults to zero.\n     */\n    function registerHintProvider(providerInfo, languageIds, priority) {\n        var providerObj = { provider: providerInfo,\n            priority: priority || 0 };\n\n        if (languageIds.indexOf(\"all\") !== -1) {\n            // Ignore anything else in languageIds and just register for every language. This includes\n            // the special \"all\" language since its key is in the hintProviders map from the beginning.\n            var languageId;\n            for (languageId in hintProviders) {\n                if (hintProviders.hasOwnProperty(languageId)) {\n                    hintProviders[languageId].push(providerObj);\n                    hintProviders[languageId].sort(_providerSort);\n                }\n            }\n        } else {\n            languageIds.forEach(function (languageId) {\n                if (!hintProviders[languageId]) {\n                    // Initialize provider list with any existing all-language providers\n                    hintProviders[languageId] = Array.prototype.concat(hintProviders.all);\n                }\n                hintProviders[languageId].push(providerObj);\n                hintProviders[languageId].sort(_providerSort);\n            });\n        }\n    }\n\n    /**\n     * @private\n     * Remove a code hint provider\n     * @param {!CodeHintProvider} provider Code hint provider to remove\n     * @param {(string|Array.<string>)=} targetLanguageId Optional set of\n     *     language IDs for languages to remove the provider for. Defaults\n     *     to all languages.\n     */\n    function _removeHintProvider(provider, targetLanguageId) {\n        var index,\n            providers,\n            targetLanguageIdArr;\n\n        if (Array.isArray(targetLanguageId)) {\n            targetLanguageIdArr = targetLanguageId;\n        } else if (targetLanguageId) {\n            targetLanguageIdArr = [targetLanguageId];\n        } else {\n            targetLanguageIdArr = Object.keys(hintProviders);\n        }\n\n        targetLanguageIdArr.forEach(function (languageId) {\n            providers = hintProviders[languageId];\n\n            for (index = 0; index < providers.length; index++) {\n                if (providers[index].provider === provider) {\n                    providers.splice(index, 1);\n                    break;\n                }\n            }\n        });\n    }\n\n    /**\n     *  Return the array of hint providers for the given language id.\n     *  This gets called (potentially) on every keypress. So, it should be fast.\n     *\n     * @param {!string} languageId\n     * @return {?Array.<{provider: Object, priority: number}>}\n     */\n    function _getProvidersForLanguageId(languageId) {\n        var providers = hintProviders[languageId] || hintProviders.all;\n\n        // Exclude providers that are explicitly disabled in the preferences.\n        // All code hint providers that do not have their constructor\n        // names listed in the preferences are enabled by default.\n        return providers.filter(function (provider) {\n            var prefKey = \"codehint.\" + provider.provider.constructor.name;\n            return PreferencesManager.get(prefKey) !== false;\n        });\n    }\n\n    var _beginSession;\n\n    /**\n     * End the current hinting session\n     */\n    function _endSession() {\n        if (!hintList) {\n            return;\n        }\n        hintList.close();\n        hintList = null;\n        codeHintOpened = false;\n        keyDownEditor = null;\n        sessionProvider = null;\n        sessionEditor = null;\n        if (deferredHints) {\n            deferredHints.reject();\n            deferredHints = null;\n        }\n    }\n\n    /**\n     * Is there a hinting session active for a given editor?\n     *\n     * NOTE: the sessionEditor, sessionProvider and hintList objects are\n     * only guaranteed to be initialized during an active session.\n     *\n     * @param {Editor} editor\n     * @return boolean\n     */\n    function _inSession(editor) {\n        if (sessionEditor) {\n            if (sessionEditor === editor &&\n                    (hintList.isOpen() ||\n                     (deferredHints && deferredHints.state() === \"pending\"))) {\n                return true;\n            }\n                // the editor has changed\n            _endSession();\n\n        }\n        return false;\n    }\n    /**\n     * From an active hinting session, get hints from the current provider and\n     * render the hint list window.\n     *\n     * Assumes that it is called when a session is active (i.e. sessionProvider is not null).\n     */\n    function _updateHintList(callMoveUpEvent) {\n\n        callMoveUpEvent = typeof callMoveUpEvent === \"undefined\" ? false : callMoveUpEvent;\n\n        if (deferredHints) {\n            deferredHints.reject();\n            deferredHints = null;\n        }\n\n        if (callMoveUpEvent) {\n            return hintList.callMoveUp(callMoveUpEvent);\n        }\n\n        var response = sessionProvider.getHints(lastChar);\n        lastChar = null;\n\n        if (!response) {\n            // the provider wishes to close the session\n            _endSession();\n        } else {\n            // if the response is true, end the session and begin another\n            if (response === true) {\n                var previousEditor = sessionEditor;\n\n                _endSession();\n                _beginSession(previousEditor);\n            } else if (response.hasOwnProperty(\"hints\")) { // a synchronous response\n                if (hintList.isOpen()) {\n                    // the session is open\n                    hintList.update(response);\n                } else {\n                    hintList.open(response);\n                }\n            } else { // response is a deferred\n                deferredHints = response;\n                response.done(function (hints) {\n                    // Guard against timing issues where the session ends before the\n                    // response gets a chance to execute the callback.  If the session\n                    // ends first while still waiting on the response, then hintList\n                    // will get cleared up.\n                    if (!hintList) {\n                        return;\n                    }\n\n                    if (hintList.isOpen()) {\n                        // the session is open\n                        hintList.update(hints);\n                    } else {\n                        hintList.open(hints);\n                    }\n                });\n            }\n        }\n    }\n\n    /**\n     * Try to begin a new hinting session.\n     * @param {Editor} editor\n     */\n    _beginSession = function (editor) {\n\n        if (!codeHintsEnabled) {\n            return;\n        }\n\n        // Don't start a session if we have a multiple selection.\n        if (editor.getSelections().length > 1) {\n            return;\n        }\n\n        // Find a suitable provider, if any\n        var language = editor.getLanguageForSelection(),\n            enabledProviders = _getProvidersForLanguageId(language.getId());\n\n        enabledProviders.some(function (item, index) {\n            if (item.provider.hasHints(editor, lastChar)) {\n                sessionProvider = item.provider;\n                return true;\n            }\n        });\n\n        // If a provider is found, initialize the hint list and update it\n        if (sessionProvider) {\n            var insertHintOnTab,\n                maxCodeHints = PreferencesManager.get(\"maxCodeHints\");\n            if (sessionProvider.insertHintOnTab !== undefined) {\n                insertHintOnTab = sessionProvider.insertHintOnTab;\n            } else {\n                insertHintOnTab = PreferencesManager.get(\"insertHintOnTab\");\n            }\n\n            sessionEditor = editor;\n            hintList = new CodeHintList(sessionEditor, insertHintOnTab, maxCodeHints);\n            hintList.onHighlight(function ($hint, $hintDescContainer) {\n                if (hintList.enableDescription && $hintDescContainer && $hintDescContainer.length) {\n                    // If the current hint provider listening for hint item highlight change\n                    if (sessionProvider.onHighlight) {\n                        sessionProvider.onHighlight($hint, $hintDescContainer);\n                    }\n\n                    // Update the hint description\n                    if (sessionProvider.updateHintDescription) {\n                        sessionProvider.updateHintDescription($hint, $hintDescContainer);\n                    }\n                } else {\n                    if (sessionProvider.onHighlight) {\n                        sessionProvider.onHighlight($hint);\n                    }\n                }\n            });\n            hintList.onSelect(function (hint) {\n                var restart = sessionProvider.insertHint(hint),\n                    previousEditor = sessionEditor;\n                _endSession();\n                if (restart) {\n                    _beginSession(previousEditor);\n                }\n            });\n            hintList.onClose(_endSession);\n\n            _updateHintList();\n        } else {\n            lastChar = null;\n        }\n    };\n\n    /**\n     * Handles keys related to displaying, searching, and navigating the hint list.\n     * This gets called before handleChange.\n     *\n     * TODO: Ideally, we'd get a more semantic event from the editor that told us\n     * what changed so that we could do all of this logic without looking at\n     * key events. Then, the purposes of handleKeyEvent and handleChange could be\n     * combined. Doing this well requires changing CodeMirror.\n     *\n     * @param {Event} jqEvent\n     * @param {Editor} editor\n     * @param {KeyboardEvent} event\n     */\n    function _handleKeydownEvent(jqEvent, editor, event) {\n        keyDownEditor = editor;\n        if (!(event.ctrlKey || event.altKey || event.metaKey) &&\n                (event.keyCode === KeyEvent.DOM_VK_ENTER ||\n                 event.keyCode === KeyEvent.DOM_VK_RETURN ||\n                 event.keyCode === KeyEvent.DOM_VK_TAB)) {\n            lastChar = String.fromCharCode(event.keyCode);\n        }\n    }\n    function _handleKeypressEvent(jqEvent, editor, event) {\n        keyDownEditor = editor;\n\n        // Last inserted character, used later by handleChange\n        lastChar = String.fromCharCode(event.charCode);\n\n        // Pending Text is used in hintList._keydownHook()\n        if (hintList) {\n            hintList.addPendingText(lastChar);\n        }\n    }\n    function _handleKeyupEvent(jqEvent, editor, event) {\n        keyDownEditor = editor;\n        if (_inSession(editor)) {\n            if (event.keyCode === KeyEvent.DOM_VK_HOME ||\n                  event.keyCode === KeyEvent.DOM_VK_END) {\n                _endSession();\n            } else if (event.keyCode === KeyEvent.DOM_VK_LEFT ||\n                       event.keyCode === KeyEvent.DOM_VK_RIGHT ||\n                       event.keyCode === KeyEvent.DOM_VK_BACK_SPACE) {\n                // Update the list after a simple navigation.\n                // We do this in \"keyup\" because we want the cursor position to be updated before\n                // we redraw the list.\n                _updateHintList();\n            } else if (event.ctrlKey && event.keyCode === KeyEvent.DOM_VK_SPACE) {\n                _updateHintList(event);\n            }\n        }\n    }\n\n    /**\n     * Handle a selection change event in the editor. If the selection becomes a\n     * multiple selection, end our current session.\n     * @param {BracketsEvent} event\n     * @param {Editor} editor\n     */\n    function _handleCursorActivity(event, editor) {\n        if (_inSession(editor)) {\n            if (editor.getSelections().length > 1) {\n                _endSession();\n            }\n        }\n    }\n\n    /**\n     * Start a new implicit hinting session, or update the existing hint list.\n     * Called by the editor after handleKeyEvent, which is responsible for setting\n     * the lastChar.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {{from: Pos, to: Pos, text: Array, origin: string}} changeList\n     */\n    function _handleChange(event, editor, changeList) {\n        if (lastChar && editor === keyDownEditor) {\n            keyDownEditor = null;\n            if (_inSession(editor)) {\n                var charToRetest = lastChar;\n                _updateHintList();\n\n                // _updateHintList() may end a hinting session and clear lastChar, but a\n                // different provider may want to start a new session with the same character.\n                // So check whether current provider terminates the current hinting\n                // session. If so, then restore lastChar and restart a new session.\n                if (!_inSession(editor)) {\n                    lastChar = charToRetest;\n                    _beginSession(editor);\n                }\n            } else {\n                _beginSession(editor);\n            }\n\n            // Pending Text is used in hintList._keydownHook()\n            if (hintList && changeList[0] && changeList[0].text.length && changeList[0].text[0].length) {\n                var expectedLength = editor.getCursorPos().ch - changeList[0].from.ch,\n                    newText = changeList[0].text[0];\n                // We may get extra text in newText since some features like auto\n                // close braces can append some text automatically.\n                // See https://github.com/adobe/brackets/issues/6345#issuecomment-32548064\n                // as an example of this scenario.\n                if (newText.length > expectedLength) {\n                    // Strip off the extra text before calling removePendingText.\n                    newText = newText.substr(0, expectedLength);\n                }\n                hintList.removePendingText(newText);\n            }\n        }\n    }\n\n    /**\n     * Test whether the provider has an exclusion that is still the same as text after the cursor.\n     *\n     * @param {string} exclusion - Text not to be overwritten when the provider inserts the selected hint.\n     * @param {string} textAfterCursor - Text that is immediately after the cursor position.\n     * @return {boolean} true if the exclusion is not null and is exactly the same as textAfterCursor,\n     * false otherwise.\n     */\n    function hasValidExclusion(exclusion, textAfterCursor) {\n        return (exclusion && exclusion === textAfterCursor);\n    }\n\n    /**\n     *  Test if a hint popup is open.\n     *\n     * @return {boolean} - true if the hints are open, false otherwise.\n     */\n    function isOpen() {\n        return (hintList && hintList.isOpen());\n    }\n\n    /**\n     * Explicitly start a new session. If we have an existing session,\n     * then close the current one and restart a new one.\n     * @param {Editor} editor\n     */\n    function _startNewSession(editor) {\n        if (isOpen()) {\n            return;\n        }\n\n        if (!editor) {\n            editor = EditorManager.getFocusedEditor();\n        }\n        if (editor) {\n            lastChar = null;\n            if (_inSession(editor)) {\n                _endSession();\n            }\n\n            // Begin a new explicit session\n            _beginSession(editor);\n        }\n    }\n\n    /**\n     * Expose CodeHintList for unit testing\n     */\n    function _getCodeHintList() {\n        return hintList;\n    }\n\n    function activeEditorChangeHandler(event, current, previous) {\n        if (current) {\n            current.on(\"editorChange\", _handleChange);\n            current.on(\"keydown\",  _handleKeydownEvent);\n            current.on(\"keypress\", _handleKeypressEvent);\n            current.on(\"keyup\",    _handleKeyupEvent);\n            current.on(\"cursorActivity\", _handleCursorActivity);\n        }\n\n        if (previous) {\n            //Removing all old Handlers\n            previous.off(\"editorChange\", _handleChange);\n            previous.off(\"keydown\",  _handleKeydownEvent);\n            previous.off(\"keypress\", _handleKeypressEvent);\n            previous.off(\"keyup\",    _handleKeyupEvent);\n            previous.off(\"cursorActivity\", _handleCursorActivity);\n        }\n    }\n\n    activeEditorChangeHandler(null, EditorManager.getActiveEditor(), null);\n\n    EditorManager.on(\"activeEditorChange\", activeEditorChangeHandler);\n\n    // Dismiss code hints before executing any command other than showing code hints since the command\n    // may make the current hinting session irrevalent after execution.\n    // For example, when the user hits Ctrl+K to open Quick Doc, it is\n    // pointless to keep the hint list since the user wants to view the Quick Doc\n    CommandManager.on(\"beforeExecuteCommand\", function (event, commandId) {\n        if (commandId !== Commands.SHOW_CODE_HINTS) {\n            _endSession();\n        }\n    });\n\n    CommandManager.register(Strings.CMD_SHOW_CODE_HINTS, Commands.SHOW_CODE_HINTS, _startNewSession);\n\n    exports._getCodeHintList        = _getCodeHintList;\n    exports._removeHintProvider     = _removeHintProvider;\n\n    // Define public API\n    exports.isOpen                  = isOpen;\n    exports.registerHintProvider    = registerHintProvider;\n    exports.hasValidExclusion       = hasValidExclusion;\n});\n"],"file":"CodeHintManager.js"}
{"version":3,"sources":["editor/EditorManager.js"],"names":["define","require","exports","module","Commands","EventDispatcher","WorkspaceManager","PreferencesManager","CommandManager","DocumentManager","MainViewManager","ViewStateManager","PerfUtils","Editor","InlineTextEditor","MultiRangeInlineEditor","Strings","LanguageManager","DeprecationWarning","_lastFocusedEditor","_inlineEditProviders","_inlineDocsProviders","_$hiddenEditorsContainer","getCurrentFullEditor","currentPath","getCurrentlyViewedPath","ACTIVE_PANE","doc","getOpenDocumentForPath","_masterEditor","_saveEditorViewState","editor","updateViewState","_restoreEditorViewState","viewState","getViewState","document","file","restoreViewState","_notifyActiveEditorChanged","current","previous","trigger","_handleCurrentFileChange","e","fullPath","_createEditorForDocument","makeMasterEditor","container","range","editorOptions","on","$el","is","_openInlineWidget","providers","defaultErrorMsg","markStart","INLINE_WIDGET_OPEN","pos","getCursorPos","inlinePromise","i","result","$","Deferred","errorMsg","providerRet","length","provider","hasOwnProperty","done","inlineWidget","addInlineWidget","addMeasurement","resolve","fail","finalizeMeasurement","displayErrorMessageAtCursor","reject","promise","_toggleInlineWidget","currentEditor","getFocusedInlineWidget","INLINE_WIDGET_CLOSE","close","_insertProviderSorted","array","priority","index","prioritizedProvider","splice","_createUnattachedMasterEditor","setVisible","closeInlineWidget","hostEditor","hasFocus","widgetLine","_codeMirror","getLineNumber","info","line","cursorLine","setCursorPos","focus","removeInlineWidget","registerInlineEditProvider","undefined","registerInlineDocsProvider","getInlineEditors","inlineEditors","getInlineWidgets","forEach","widget","push","_createFullEditorForDocument","pane","$content","addView","id","createInlineEditorForDocument","inlineContent","hide","inlineEditor","_hostEditor","show","content","focusEditor","deprecationWarning","focusActivePane","resizeEditor","recomputeLayout","_showEditor","createdNewEditor","_paneId","_checkAssociatedEditorForPane","parent","window","getSelection","empty","showView","getActivePaneId","setEditorHolder","Error","registerCustomViewer","canOpenPath","getLanguageForPath","isBinary","openDocument","perfTimerName","getFocusedInlineEditor","focusedWidget","getFocusedEditor","focusedInline","getActiveEditor","_handleRemoveFromPaneView","removedFiles","handleFileRemoved","_destroyEditorIfNotNeeded","isArray","removedFile","makeEventDispatcher","_setCurrentFile","register","CMD_TOGGLE_QUICK_EDIT","TOGGLE_QUICK_EDIT","ERROR_QUICK_EDIT_PROVIDER_NOT_FOUND","CMD_TOGGLE_QUICK_DOCS","TOGGLE_QUICK_DOCS","ERROR_QUICK_DOCS_PROVIDER_NOT_FOUND"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * EditorManager owns the UI for the editor area. This essentially mirrors the 'current document'\n * property maintained by DocumentManager's model.\n *\n * Note that there is a little bit of unusual overlap between EditorManager and DocumentManager:\n * because the Document state is actually stored in the CodeMirror editor UI, DocumentManager is\n * not a pure headless model. Each Document encapsulates an editor instance, and thus EditorManager\n * must have some knowledge about Document's internal state (we access its _editor property).\n *\n * This module dispatches the following events:\n *    - activeEditorChange --  Fires after the active editor (full or inline).\n *\n *      Doesn't fire when editor temporarily loses focus to a non-editor\n *      control (e.g. search toolbar or modal dialog, or window deactivation).\n *\n *      Does fire when focus moves between inline editor and its full-size container.\n *\n *      This event tracks `MainViewManagers's `currentFileChange` event and all editor\n *      objects \"focus\" event.\n *\n *          (e, editorGainingFocus:editor, editorLosingFocus:editor)\n *\n *      The 2nd arg to the listener is which Editor became active; the 3rd arg is\n *      which Editor is deactivated as a result. Either one may be null.\n *      NOTE (#1257): `getFocusedEditor()` sometimes lags behind this event. Listeners\n *      should use the arguments or call `getActiveEditor()` to reliably see which Editor\n *      just gained focus.\n */\ndefine(function (require, exports, module) {\n\n\n    // Load dependent modules\n    var Commands            = require(\"command/Commands\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        WorkspaceManager    = require(\"view/WorkspaceManager\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        CommandManager      = require(\"command/CommandManager\"),\n        DocumentManager     = require(\"document/DocumentManager\"),\n        MainViewManager     = require(\"view/MainViewManager\"),\n        ViewStateManager    = require(\"view/ViewStateManager\"),\n        PerfUtils           = require(\"utils/PerfUtils\"),\n        Editor              = require(\"editor/Editor\").Editor,\n        InlineTextEditor    = require(\"editor/InlineTextEditor\").InlineTextEditor,\n        MultiRangeInlineEditor    = require(\"editor/MultiRangeInlineEditor\").MultiRangeInlineEditor,\n        Strings             = require(\"strings\"),\n        LanguageManager     = require(\"language/LanguageManager\"),\n        DeprecationWarning  = require(\"utils/DeprecationWarning\");\n\n\n    /**\n     * Currently focused Editor (full-size, inline, or otherwise)\n     * @type {?Editor}\n     * @private\n     */\n    var _lastFocusedEditor = null;\n\n    /**\n     * Registered inline-editor widget providers sorted descending by priority.\n     * @see {@link #registerInlineEditProvider}.\n     * @type {Array.<{priority:number, provider:function(...)}>}\n     * @private\n     */\n    var _inlineEditProviders = [];\n\n    /**\n     * Registered inline documentation widget providers sorted descending by priority.\n     * @see {@link #registerInlineDocsProvider}.\n     * @type {Array.<{priority:number, provider:function(...)}>}\n     * @private\n     */\n    var _inlineDocsProviders = [];\n\n    /**\n     * DOM element to house any hidden editors created soley for inline widgets\n     * @private\n     * @type {jQuery}\n     */\n    var _$hiddenEditorsContainer;\n\n\n    /**\n     * Retrieves the visible full-size Editor for the currently opened file in the ACTIVE_PANE\n     * @return {?Editor} editor of the current view or null\n     */\n    function getCurrentFullEditor() {\n        var currentPath = MainViewManager.getCurrentlyViewedPath(MainViewManager.ACTIVE_PANE),\n            doc = currentPath && DocumentManager.getOpenDocumentForPath(currentPath);\n        return doc && doc._masterEditor;\n    }\n\n\n\n    /**\n     * Updates _viewStateCache from the given editor's actual current state\n     * @private\n     * @param {!Editor} editor - editor to cache data for\n     */\n    function _saveEditorViewState(editor) {\n        ViewStateManager.updateViewState(editor);\n    }\n\n    /**\n     * Updates _viewStateCache from the given editor's actual current state\n     * @param {!Editor} editor - editor restore cached data\n     * @private\n     */\n    function _restoreEditorViewState(editor) {\n        // We want to ignore the current state of the editor, so don't call __getViewState()\n        var viewState = ViewStateManager.getViewState(editor.document.file);\n        if (viewState) {\n            editor.restoreViewState(viewState);\n        }\n    }\n\n\n\t/**\n     * Editor focus handler to change the currently active editor\n     * @private\n     * @param {?Editor} current - the editor that will be the active editor\n     */\n    function _notifyActiveEditorChanged(current) {\n        // Skip if the Editor that gained focus was already the most recently focused editor.\n        // This may happen e.g. if the window loses then regains focus.\n        if (_lastFocusedEditor === current) {\n            return;\n        }\n        var previous = _lastFocusedEditor;\n        _lastFocusedEditor = current;\n\n        exports.trigger(\"activeEditorChange\", current, previous);\n    }\n\n    /**\n     * Current File Changed handler\n     * MainViewManager dispatches a \"currentFileChange\" event whenever the currently viewed\n     * file changes.  Which could mean that the previously viewed file has been closed or a\n     * non-editor view (image) has been given focus.  _notifyAcitveEditorChanged is also hooked\n     * up to editor.focus to handle focus events for editors which handles changing focus between\n     * two editors but, because editormanager maintains  a \"_lastFocusedEditor\" state, we have to\n     * \"nullify\" that state whenever the focus goes to a non-editor or when the current editor is closed\n     * @private\n     * @param {!jQuery.Event} e - event\n     * @param {?File} file - current file (can be null)\n     */\n    function _handleCurrentFileChange(e, file) {\n        var doc = file && DocumentManager.getOpenDocumentForPath(file.fullPath);\n        _notifyActiveEditorChanged(doc && doc._masterEditor);\n    }\n\n    /**\n     * Creates a new Editor bound to the given Document.\n     * The editor is appended to the given container as a visible child.\n     * @private\n     * @param {!Document} doc  Document for the Editor's content\n     * @param {!boolean} makeMasterEditor  If true, the Editor will set itself as the private \"master\"\n     *          Editor for the Document. If false, the Editor will attach to the Document as a \"slave.\"\n     * @param {!jQueryObject} container  Container to add the editor to.\n     * @param {{startLine: number, endLine: number}=} range If specified, range of lines within the document\n     *          to display in this editor. Inclusive.\n     * @param {!Object} editorOptions If specified, contains editor options that can be passed to CodeMirror\n     * @return {Editor} the newly created editor.\n     */\n    function _createEditorForDocument(doc, makeMasterEditor, container, range, editorOptions) {\n        var editor = new Editor(doc, makeMasterEditor, container, range, editorOptions);\n\n        editor.on(\"focus\", function () {\n            _notifyActiveEditorChanged(editor);\n        });\n\n        editor.on(\"beforeDestroy\", function () {\n            if (editor.$el.is(\":visible\")) {\n                _saveEditorViewState(editor);\n            }\n        });\n\n        return editor;\n    }\n\n    /**\n     * @private\n     * Finds an inline widget provider from the given list that can offer a widget for the current cursor\n     * position, and once the widget has been created inserts it into the editor.\n     *\n     * @param {!Editor} editor The host editor\n     * @param {Array.<{priority:number, provider:function(...)}>} providers\n     *      prioritized list of providers\n     * @param {string=} defaultErrorMsg Default message to display if no providers return non-null\n     * @return {$.Promise} a promise that will be resolved when an InlineWidget\n     *      is created or rejected if no inline providers have offered one.\n     */\n    function _openInlineWidget(editor, providers, defaultErrorMsg) {\n        PerfUtils.markStart(PerfUtils.INLINE_WIDGET_OPEN);\n\n        // Run through inline-editor providers until one responds\n        var pos = editor.getCursorPos(),\n            inlinePromise,\n            i,\n            result = new $.Deferred(),\n            errorMsg,\n            providerRet;\n\n        // Query each provider in priority order. Provider may return:\n        // 1. `null` to indicate it does not apply to current cursor position\n        // 2. promise that should resolve to an InlineWidget\n        // 3. string which indicates provider does apply to current cursor position,\n        //    but reason it could not create InlineWidget\n        //\n        // Keep looping until a provider is found. If a provider is not found,\n        // display the highest priority error message that was found, otherwise display\n        // default error message\n        for (i = 0; i < providers.length && !inlinePromise; i++) {\n            var provider = providers[i].provider;\n            providerRet = provider(editor, pos);\n            if (providerRet) {\n                if (providerRet.hasOwnProperty(\"done\")) {\n                    inlinePromise = providerRet;\n                } else if (!errorMsg && typeof (providerRet) === \"string\") {\n                    errorMsg = providerRet;\n                }\n            }\n        }\n\n        // Use default error message if none other provided\n        errorMsg = errorMsg || defaultErrorMsg;\n\n        // If one of them will provide a widget, show it inline once ready\n        if (inlinePromise) {\n            inlinePromise.done(function (inlineWidget) {\n                editor.addInlineWidget(pos, inlineWidget).done(function () {\n                    PerfUtils.addMeasurement(PerfUtils.INLINE_WIDGET_OPEN);\n                    result.resolve();\n                });\n            }).fail(function () {\n                // terminate timer that was started above\n                PerfUtils.finalizeMeasurement(PerfUtils.INLINE_WIDGET_OPEN);\n                editor.displayErrorMessageAtCursor(errorMsg);\n                result.reject();\n            });\n        } else {\n            // terminate timer that was started above\n            PerfUtils.finalizeMeasurement(PerfUtils.INLINE_WIDGET_OPEN);\n            editor.displayErrorMessageAtCursor(errorMsg);\n            result.reject();\n        }\n\n        return result.promise();\n    }\n\n\n    /**\n     * Closes any focused inline widget. Else, asynchronously asks providers to create one.\n     *\n     * @param {Array.<{priority:number, provider:function(...)}>} providers\n     *   prioritized list of providers\n     * @param {string=} errorMsg Default message to display if no providers return non-null\n     * @return {!Promise} A promise resolved with true if an inline widget is opened or false\n     *   when closed. Rejected if there is neither an existing widget to close nor a provider\n     *   willing to create a widget (or if no editor is open).\n     */\n    function _toggleInlineWidget(providers, errorMsg) {\n        var result = new $.Deferred();\n\n        var currentEditor = getCurrentFullEditor();\n\n        if (currentEditor) {\n            var inlineWidget = currentEditor.getFocusedInlineWidget();\n\n            if (inlineWidget) {\n                // an inline widget's editor has focus, so close it\n                PerfUtils.markStart(PerfUtils.INLINE_WIDGET_CLOSE);\n                inlineWidget.close().done(function () {\n                    PerfUtils.addMeasurement(PerfUtils.INLINE_WIDGET_CLOSE);\n                    // return a resolved promise to CommandManager\n                    result.resolve(false);\n                });\n            } else {\n                // main editor has focus, so create an inline editor\n                _openInlineWidget(currentEditor, providers, errorMsg).done(function () {\n                    result.resolve(true);\n                }).fail(function () {\n                    result.reject();\n                });\n            }\n        } else {\n            // Can not open an inline editor without a host editor\n            result.reject();\n        }\n\n        return result.promise();\n    }\n\n    /**\n     * Inserts a prioritized provider object into the array in sorted (descending) order.\n     * @private\n     * @param {Array.<{priority:number, provider:function(...)}>} array\n     * @param {number} priority\n     * @param {function(...)} provider\n     */\n    function _insertProviderSorted(array, provider, priority) {\n        var index,\n            prioritizedProvider = {\n                priority: priority,\n                provider: provider\n            };\n\n        for (index = 0; index < array.length; index++) {\n            if (array[index].priority < priority) {\n                break;\n            }\n        }\n\n        array.splice(index, 0, prioritizedProvider);\n    }\n\n\n    /**\n     * Creates a hidden, unattached master editor that is needed when a document is created for the\n     * sole purpose of creating an inline editor so operations that require a master editor can be performed\n     * Only called from Document._ensureMasterEditor()\n     * The editor view is placed in a hidden part of the DOM but can later be moved to a visible pane\n     * when the document is opened using pane.addView()\n     * @param {!Document} doc - document to create a hidden editor for\n     */\n    function _createUnattachedMasterEditor(doc) {\n        // attach to the hidden containers DOM node if necessary\n        if (!_$hiddenEditorsContainer) {\n            _$hiddenEditorsContainer = $(\"#hidden-editors\");\n        }\n        // Create an editor\n        var editor = _createEditorForDocument(doc, true, _$hiddenEditorsContainer);\n        // and hide it\n        editor.setVisible(false);\n    }\n\n    /**\n     * Removes the given widget UI from the given hostEditor (agnostic of what the widget's content\n     * is). The widget's onClosed() callback will be run as a result.\n     * @param {!Editor} hostEditor The editor containing the widget.\n     * @param {!InlineWidget} inlineWidget The inline widget to close.\n     * @return {$.Promise} A promise that's resolved when the widget is fully closed.\n     */\n    function closeInlineWidget(hostEditor, inlineWidget) {\n        // If widget has focus, return it to the hostEditor & move the cursor to where the inline used to be\n        if (inlineWidget.hasFocus()) {\n            // Place cursor back on the line just above the inline (the line from which it was opened)\n            // If cursor's already on that line, leave it be to preserve column position\n            var widgetLine = hostEditor._codeMirror.getLineNumber(inlineWidget.info.line);\n            var cursorLine = hostEditor.getCursorPos().line;\n            if (cursorLine !== widgetLine) {\n                hostEditor.setCursorPos({ line: widgetLine, pos: 0 });\n            }\n\n            hostEditor.focus();\n        }\n\n        return hostEditor.removeInlineWidget(inlineWidget);\n    }\n\n    /**\n     * Registers a new inline editor provider. When Quick Edit is invoked each registered provider is\n     * asked if it wants to provide an inline editor given the current editor and cursor location.\n     * An optional priority parameter is used to give providers with higher priority an opportunity\n     * to provide an inline editor before providers with lower priority.\n     *\n     * @param {function(!Editor, !{line:number, ch:number}):?($.Promise|string)} provider\n     * @param {number=} priority\n     * The provider returns a promise that will be resolved with an InlineWidget, or returns a string\n     * indicating why the provider cannot respond to this case (or returns null to indicate no reason).\n     */\n    function registerInlineEditProvider(provider, priority) {\n        if (priority === undefined) {\n            priority = 0;\n        }\n        _insertProviderSorted(_inlineEditProviders, provider, priority);\n    }\n\n    /**\n     * Registers a new inline docs provider. When Quick Docs is invoked each registered provider is\n     * asked if it wants to provide inline docs given the current editor and cursor location.\n     * An optional priority parameter is used to give providers with higher priority an opportunity\n     * to provide an inline editor before providers with lower priority.\n     *\n     * @param {function(!Editor, !{line:number, ch:number}):?($.Promise|string)} provider\n     * @param {number=} priority\n     * The provider returns a promise that will be resolved with an InlineWidget, or returns a string\n     * indicating why the provider cannot respond to this case (or returns null to indicate no reason).\n     */\n    function registerInlineDocsProvider(provider, priority) {\n        if (priority === undefined) {\n            priority = 0;\n        }\n        _insertProviderSorted(_inlineDocsProviders, provider, priority);\n    }\n\n\n    /**\n     * @private\n     * Given a host editor, return a list of all Editors in all its open inline widgets. (Ignoring\n     * any other inline widgets that might be open but don't contain Editors).\n     * @param {!Editor} hostEditor\n     * @return {Array.<Editor>}\n     *\n     */\n    function getInlineEditors(hostEditor) {\n        var inlineEditors = [];\n\n        if (hostEditor) {\n            hostEditor.getInlineWidgets().forEach(function (widget) {\n                if ((widget instanceof InlineTextEditor && widget.editor)\n                    ||(widget instanceof MultiRangeInlineEditor && widget.editor)) {\n                    inlineEditors.push(widget.editor);\n                }\n            });\n        }\n\n        return inlineEditors;\n    }\n\n\n\n    /**\n     * @private\n     * Creates a new \"full-size\" (not inline) Editor for the given Document, and sets it as the\n     * Document's master backing editor. The editor is not yet visible;\n     * Semi-private: should only be called within this module or by Document.\n     * @param {!Document} document  Document whose main/full Editor to create\n     * @param {!Pane} pane  Pane in which the editor will be hosted\n     * @param {!Object} editorOptions If specified, contains editor options that\n     * can be passed to CodeMirror\n     * @return {!Editor}\n     */\n    function _createFullEditorForDocument(document, pane, editorOptions) {\n        // Create editor; make it initially invisible\n        var editor = _createEditorForDocument(document, true, pane.$content, undefined, editorOptions);\n        editor.setVisible(false);\n        pane.addView(editor);\n        exports.trigger(\"_fullEditorCreatedForDocument\", document, editor, pane.id);\n        return editor;\n    }\n\n\n    /**\n     * Creates a new inline Editor instance for the given Document.\n     * The editor is not yet visible or attached to a host editor.\n     * @param {!Document} doc  Document for the Editor's content\n     * @param {?{startLine:Number, endLine:Number}} range  If specified, all lines outside the given\n     *      range are hidden from the editor. Range is inclusive. Line numbers start at 0.\n     * @param {HTMLDivContainer} inlineContent\n     * @param  {function(inlineWidget)} closeThisInline\n     *\n     * @return {{content:DOMElement, editor:Editor}}\n     */\n    function createInlineEditorForDocument(doc, range, inlineContent) {\n        // Hide the container for the editor before creating it so that CodeMirror doesn't do extra work\n        // when initializing the document. When we construct the editor, we have to set its text and then\n        // set the (small) visible range that we show in the editor. If the editor is visible, CM has to\n        // render a large portion of the document before setting the visible range. By hiding the editor\n        // first and showing it after the visible range is set, we avoid that initial render.\n        $(inlineContent).hide();\n        var inlineEditor = _createEditorForDocument(doc, false, inlineContent, range);\n        inlineEditor._hostEditor = getCurrentFullEditor();\n        $(inlineContent).show();\n\n        return { content: inlineContent, editor: inlineEditor };\n    }\n\n    /**\n     * Returns focus to the last visible editor that had focus. If no editor visible, does nothing.\n     * This function should be called to restore editor focus after it has been temporarily\n     * removed. For example, after a dialog with editable text is closed.\n     */\n    function focusEditor() {\n        DeprecationWarning.deprecationWarning(\"Use MainViewManager.focusActivePane() instead of EditorManager.focusEditor().\", true);\n        MainViewManager.focusActivePane();\n    }\n\n    /**\n     * @deprecated\n     * resizes the editor\n     */\n    function resizeEditor() {\n        DeprecationWarning.deprecationWarning(\"Use WorkspaceManager.recomputeLayout() instead of EditorManager.resizeEditor().\", true);\n        WorkspaceManager.recomputeLayout();\n    }\n\n    /**\n     * Create and/or show the editor for the specified document\n     * @param {!Document} document - document to edit\n     * @param {!Pane} pane - pane to show it in\n     * @param {!Object} editorOptions - If specified, contains\n     * editor options that can be passed to CodeMirror\n     * @private\n     */\n    function _showEditor(document, pane, editorOptions) {\n        // Ensure a main editor exists for this document to show in the UI\n        var createdNewEditor = false,\n            editor = document._masterEditor;\n\n        // Check if a master editor is not set already or the current master editor doesn't belong\n        // to the pane container requested - to support creation of multiple full editors\n        // This check is required as _masterEditor is the active full editor for the document\n        // and there can be existing full editor created for other panes\n        if (editor && editor._paneId && editor._paneId !== pane.id) {\n            editor = document._checkAssociatedEditorForPane(pane.id);\n        }\n\n        if (!editor) {\n            // Performance (see #4757) Chrome wastes time messing with selection\n            // that will just be changed at end, so clear it for now\n            if (window.getSelection && window.getSelection().empty) {  // Chrome\n                window.getSelection().empty();\n            }\n\n            // Editor doesn't exist: populate a new Editor with the text\n            editor = _createFullEditorForDocument(document, pane, editorOptions);\n            createdNewEditor = true;\n        } else if (editor.$el.parent()[0] !== pane.$content[0]) {\n            // editor does exist but is not a child of the pane so add it to the\n            //  pane (which will switch the view's container as well)\n            pane.addView(editor);\n        }\n\n        // show the view\n        pane.showView(editor);\n\n        if (MainViewManager.getActivePaneId() === pane.id) {\n            // give it focus\n            editor.focus();\n        }\n\n        if (createdNewEditor) {\n            _restoreEditorViewState(editor);\n        }\n    }\n\n    /**\n     * @deprecated use MainViewManager.getCurrentlyViewedFile() instead\n     * @return {string=} path of the file currently viewed in the active, full sized editor or null when there is no active editor\n     */\n    function getCurrentlyViewedPath() {\n        DeprecationWarning.deprecationWarning(\"Use MainViewManager.getCurrentlyViewedFile() instead of EditorManager.getCurrentlyViewedPath().\", true);\n\n        // We only want to return a path of a document object\n        // not other things like images, etc...\n        var currentPath = MainViewManager.getCurrentlyViewedPath(MainViewManager.ACTIVE_PANE),\n            doc;\n\n        if (currentPath) {\n            doc = DocumentManager.getOpenDocumentForPath(currentPath);\n        }\n\n        if (doc) {\n            return currentPath;\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated There is no equivalent API moving forward.\n     * Use MainViewManager._initialize() from a unit test to create a Main View attached to a specific DOM element\n     */\n    function setEditorHolder() {\n        throw new Error(\"EditorManager.setEditorHolder() has been removed.\");\n    }\n\n    /**\n     * @deprecated Register a View Factory instead\n     * @see MainViewFactory::#registerViewFactory\n     */\n    function registerCustomViewer() {\n        throw new Error(\"EditorManager.registerCustomViewer() has been removed.\");\n    }\n\n    /**\n     * Determines if the file can be opened in an editor\n     * @param {!string} fullPath - file to be opened\n     * @return {boolean} true if the file can be opened in an editor, false if not\n     */\n    function canOpenPath(fullPath) {\n        return !LanguageManager.getLanguageForPath(fullPath).isBinary();\n    }\n\n    /**\n     * Opens the specified document in the given pane\n     * @param {!Document} doc - the document to open\n     * @param {!Pane} pane - the pane to open the document in\n     * @param {!Object} editorOptions - If specified, contains\n     * editor options that can be passed to CodeMirror\n     * @return {boolean} true if the file can be opened, false if not\n     */\n    function openDocument(doc, pane, editorOptions) {\n        var perfTimerName = PerfUtils.markStart(\"EditorManager.openDocument():\\t\" + (!doc || doc.file.fullPath));\n\n        if (doc && pane) {\n            _showEditor(doc, pane, editorOptions);\n        }\n\n        PerfUtils.addMeasurement(perfTimerName);\n    }\n\n    /**\n     * Returns the currently focused inline widget, if any.\n     * @return {?InlineWidget}\n     */\n    function getFocusedInlineWidget() {\n        var currentEditor = getCurrentFullEditor();\n        if (currentEditor) {\n            return currentEditor.getFocusedInlineWidget();\n        }\n        return null;\n    }\n\n    /**\n     * Returns the focused Editor within an inline text editor, or null if something else has focus\n     * @return {?Editor}\n     */\n    function getFocusedInlineEditor() {\n        var focusedWidget = getFocusedInlineWidget();\n        if (focusedWidget instanceof InlineTextEditor) {\n            return focusedWidget.getFocusedEditor();\n        }\n        return null;\n    }\n\n    /**\n     * Returns the currently focused editor instance (full-sized OR inline editor).\n     * This function is similar to getActiveEditor(), with one main difference: this\n     * function will only return editors that currently have focus, whereas\n     * getActiveEditor() will return the last visible editor that was given focus (but\n     * may not currently have focus because, for example, a dialog with editable text\n     * is open).\n     * @return {?Editor}\n     */\n    function getFocusedEditor() {\n        var currentEditor = getCurrentFullEditor();\n        if (currentEditor) {\n\n            // See if any inlines have focus\n            var focusedInline = getFocusedInlineEditor();\n            if (focusedInline) {\n                return focusedInline;\n            }\n\n            // otherwise, see if full-sized editor has focus\n            if (currentEditor.hasFocus()) {\n                return currentEditor;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the current active editor (full-sized OR inline editor). This editor may not\n     * have focus at the moment, but it is visible and was the last editor that was given\n     * focus. Returns null if no editors are active.\n     * @see #getFocusedEditor\n     * @return {?Editor}\n     */\n    function getActiveEditor() {\n        return _lastFocusedEditor;\n    }\n\n    /**\n     * file removed from pane handler.\n     * @param {jQuery.Event} e\n     * @param {File|Array.<File>} removedFiles - file, path or array of files or paths that are being removed\n     */\n    function _handleRemoveFromPaneView(e, removedFiles) {\n        var handleFileRemoved = function (file) {\n            var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\n\n            if (doc) {\n                MainViewManager._destroyEditorIfNotNeeded(doc);\n            }\n        };\n\n        // when files are removed from a pane then\n        //    we should destroy any unnecssary views\n        if ($.isArray(removedFiles)) {\n            removedFiles.forEach(function (removedFile) {\n                handleFileRemoved(removedFile);\n            });\n        } else {\n            handleFileRemoved(removedFiles);\n        }\n    }\n\n\n    // Set up event dispatching\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // File-based preferences handling\n    exports.on(\"activeEditorChange\", function (e, current) {\n        if (current && current.document && current.document.file) {\n            PreferencesManager._setCurrentFile(current.document.file.fullPath);\n        }\n    });\n\n    // Initialize: command handlers\n    CommandManager.register(Strings.CMD_TOGGLE_QUICK_EDIT, Commands.TOGGLE_QUICK_EDIT, function () {\n        return _toggleInlineWidget(_inlineEditProviders, Strings.ERROR_QUICK_EDIT_PROVIDER_NOT_FOUND);\n    });\n    CommandManager.register(Strings.CMD_TOGGLE_QUICK_DOCS, Commands.TOGGLE_QUICK_DOCS, function () {\n        return _toggleInlineWidget(_inlineDocsProviders, Strings.ERROR_QUICK_DOCS_PROVIDER_NOT_FOUND);\n    });\n\n    MainViewManager.on(\"currentFileChange\", _handleCurrentFileChange);\n    MainViewManager.on(\"workingSetRemove workingSetRemoveList\", _handleRemoveFromPaneView);\n\n\n    // For unit tests and internal use only\n    exports._createFullEditorForDocument  = _createFullEditorForDocument;\n    exports._notifyActiveEditorChanged    = _notifyActiveEditorChanged;\n\n    // Internal Use only\n    exports._saveEditorViewState          = _saveEditorViewState;\n    exports._createUnattachedMasterEditor = _createUnattachedMasterEditor;\n\n    // Define public API\n    exports.createInlineEditorForDocument = createInlineEditorForDocument;\n    exports.getFocusedInlineWidget        = getFocusedInlineWidget;\n    exports.getInlineEditors              = getInlineEditors;\n    exports.closeInlineWidget             = closeInlineWidget;\n    exports.openDocument                  = openDocument;\n    exports.canOpenPath                   = canOpenPath;\n\n    // Convenience Methods\n    exports.getActiveEditor               = getActiveEditor;\n    exports.getCurrentFullEditor          = getCurrentFullEditor;\n    exports.getFocusedEditor              = getFocusedEditor;\n    exports.getFocusedInlineEditor        = getFocusedInlineEditor;\n\n\n    exports.registerInlineEditProvider    = registerInlineEditProvider;\n    exports.registerInlineDocsProvider    = registerInlineDocsProvider;\n\n    // Deprecated\n    exports.registerCustomViewer          = registerCustomViewer;\n    exports.resizeEditor                  = resizeEditor;\n    exports.focusEditor                   = focusEditor;\n    exports.getCurrentlyViewedPath        = getCurrentlyViewedPath;\n    exports.setEditorHolder               = setEditorHolder;\n});\n"],"file":"EditorManager.js"}
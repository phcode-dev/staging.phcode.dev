{"version":3,"sources":["storage.js"],"names":["set","entries","createStore","setupGlobalStorage","window","PhStore","console","error","EVENT_CHANGED","FIRST_BOOT_TIME","storageNodeConnector","_testKey","nodeStoragePhoenixApis","isBrowser","Phoenix","browser","isTauri","isDesktop","PHSTORE_DB","PHSTORE_STORE_NAME","idbStore","_getIDBStorage","PHOENIX_STORAGE_BROADCAST_CHANNEL_NAME","EXTERNAL_CHANGE_BROADCAST_INTERVAL","CHANGE_TYPE_EXTERNAL","CHANGE_TYPE_INTERNAL","MGS_CHANGE","cache","pendingBroadcastKV","watchExternalKeys","commitExternalChanges","changedKV","key","Object","keys","externalChange","t","trigger","STORAGE_NODE_CONNECTOR_ID","PhNodeEngine","createNodeConnector","execPeer","_tauriBootVars","appLocalDir","isTestWindow","on","_evt","storageChannel","BroadcastChannel","setInterval","postMessage","type","onmessage","event","message","data","getItem","cachedResult","JSON","parse","v","setItem","value","valueToStore","Date","now","stringify","debugMode","removeItem","watchExternalChanges","unwatchExternalChanges","setupFirstBoot","firstBootTime","firstBoot","e","storageReadyPromise","Promise","resolve","_tauriStorageRestorePromise","then","jsonData","catch","finally","kvArrayAll","kvArray","_PHSTORE_BOOT_DESKTOP_ZOOM_SCALE_KEY","async","flushDB","zoomFactor","__TAURI__","tauri","invoke","scaleFactor","_storageBootstrapTime","startTime","_setTestKey","testKey","EventDispatcher","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/** The main persistent storage apis used to store preferences, setting etc. This is synced across all running phoenix\n * tabs in the browser and processes in the desktop app.\n * Data is eventually consistent with sync delays up to a few seconds.\n *\n * Storage API that seamlessly works in both web browsers and Tauri. In web browsers, the API utilizes local storage,\n * providing a consistent and reliable key-value store for small configuration data with persistence guarantees and\n * efficient read-write performance. It's important to note that this storage API is not suitable for storing\n * large data, such as file content or debug-related information.\n *\n * Features:\n * - Synchronous reads with in-memory caching for optimized performance.\n * - Read-after-write consistency within a single instance.\n * - Eventual consistency (within approximately 3 seconds) when used across multiple processes or tabs.\n *\n * The motivation behind implementing this unified storage API is to address the limitations and potential data loss\n * issues associated with using local storage and IndexedDB in our desktop builds. Specifically, certain scenarios,\n * like WebKit's data clearing in Linux and macOS Tauri builds as part of Intelligent Tracking Prevention (ITP),\n * could lead to data loss.\n *\n * The main aim is to have data durability guarantees in desktop builds.\n * In bowser, we can only overcome this if we have cloud login. Eventually we can have a cloud backend that will sync\n * with this storage implementation.\n */\n\n/*global EventDispatcher*/\n\nimport {set, entries, createStore} from './thirdparty/idb-keyval.js';\n\n(function setupGlobalStorage() {\n    if(window.PhStore){\n        console.error(`window.PhStore already setup. Ignoring.`);\n        return;\n    }\n    const EVENT_CHANGED = \"change\";\n    const FIRST_BOOT_TIME = \"firstBootTime\";\n    let storageNodeConnector;\n    let _testKey;\n    let nodeStoragePhoenixApis = {};\n    const isBrowser = !Phoenix.browser.isTauri;\n    const isDesktop = Phoenix.browser.isTauri;\n    const PHSTORE_DB = \"PhStore\";\n    const PHSTORE_STORE_NAME = \"KVStore\";\n    let idbStore;\n\n    function _getIDBStorage() {\n        if(!idbStore){\n            idbStore = createStore(PHSTORE_DB, PHSTORE_STORE_NAME);\n        }\n        return idbStore;\n    }\n\n    const PHOENIX_STORAGE_BROADCAST_CHANNEL_NAME = \"ph-storage\";\n    const EXTERNAL_CHANGE_BROADCAST_INTERVAL = 500;\n    // Since this is a sync API, performance is critical. So we use a memory map in cache. This limits the size\n    // of what can be stored in this storage as if fully in memory.\n    const CHANGE_TYPE_EXTERNAL = \"External\",\n        CHANGE_TYPE_INTERNAL = \"Internal\";\n    const MGS_CHANGE = 'change';\n    let cache = {};\n    // map from watched keys that was set in this instance to\n    // modified time and value - key->{t,v}\n    let pendingBroadcastKV = {},\n        watchExternalKeys = {}; // boolean map\n\n    function commitExternalChanges(changedKV) {\n        for(let key of Object.keys(changedKV)){\n            // we only update the key and trigger if the key is being watched here.\n            // If unwatched keys are updated from another window, for eg, theme change pulled in from a new\n            // theme installed in another window cannot be applied in this window. So the code has to\n            // explicitly support external changes by calling watchExternalChanges API.\n            if(watchExternalKeys[key]) {\n                const externalChange = changedKV[key]; // {t,v} in new value, t = changed time\n                // if the change time of the external event we got is more recent than what we have,\n                // only then accept the change. else we have more recent data.\n                if(!cache[key] || (externalChange.t > cache[key].t)) {\n                    cache[key] = externalChange;\n                    PhStore.trigger(key, CHANGE_TYPE_EXTERNAL);\n                }\n            }\n        }\n    }\n\n    if(isDesktop){\n        const STORAGE_NODE_CONNECTOR_ID = \"ph_storage\";\n        storageNodeConnector = window.PhNodeEngine.createNodeConnector(\n            STORAGE_NODE_CONNECTOR_ID, nodeStoragePhoenixApis);\n        storageNodeConnector.execPeer(\"openDB\", window._tauriBootVars.appLocalDir);\n        if(Phoenix.isTestWindow) {\n            window.storageNodeConnector = storageNodeConnector;\n        }\n        storageNodeConnector.on(EVENT_CHANGED, (_evt, changedKV)=>{\n            commitExternalChanges(changedKV);\n        });\n    }\n\n    if(isBrowser) {\n        const storageChannel = new BroadcastChannel(PHOENIX_STORAGE_BROADCAST_CHANNEL_NAME);\n        setInterval(()=>{\n            // broadcast all changes made to watched keys in this instance to others\n            storageChannel.postMessage({type: MGS_CHANGE, keys: pendingBroadcastKV});\n            pendingBroadcastKV = {};\n\n        }, EXTERNAL_CHANGE_BROADCAST_INTERVAL);\n        // Listen for messages on the channel\n        storageChannel.onmessage = (event) => {\n            const message = event.data;\n            if(message.type === MGS_CHANGE){\n                commitExternalChanges(message.keys);\n            }\n        };\n    }\n\n    /**\n     * Retrieves the value associated with the specified key from the browser's local storage.\n     *\n     * @param {string} key - The key to retrieve the value for.\n     * @returns {string|number|boolean|object|null} - The value associated with the specified key. Returns null if the key does not exist.\n     */\n    function getItem(key) {\n        let cachedResult = cache[key];\n        if(cachedResult){\n            return JSON.parse(cachedResult.v);\n        }\n        // once we load the db dump from file, we dont ever touch the storage apis again for\n        // get operations. This is because in, the get operation is async (via node or indexedDB). in future,\n        // we can write a async refresh key api to update values that has been cached if the need arises.\n        // but rn, there is no need for the same as every phoenix instance will use its own cached storage\n        // that guarantees read after write constancy within an instance, and for external changes, use watch.\n        return null;\n    }\n\n    /**\n     * Sets the value of a specified key in the localStorage.\n     *\n     * @param {string} key - The key to set the value for.\n     * @param {string|number|boolean|object} value - The value to be stored. Can be any valid JSON serializable data type.\n     *\n     */\n    function setItem(key, value) {\n        const valueToStore = {\n            t: Date.now(), // modified time\n            // we store value as string here as during get operation, we can use json.parse to clone instead of\n            // using slower structured object clone.\n            v: JSON.stringify(value)\n        };\n        if(!Phoenix.isTestWindow || key === _testKey) {\n            if(isDesktop) {\n                storageNodeConnector.execPeer(\"putItem\", {key, value: valueToStore});\n            }\n            if(window.debugMode || isBrowser) {\n                // in debug mode, we write to browser storage in tauri and browser builds for eazy debug of storage.\n                set(key, valueToStore, _getIDBStorage());\n            }\n        }\n        cache[key] = valueToStore;\n        if(watchExternalKeys[key] && isBrowser){\n            // Broadcast channel is only used in browser, in tauri with multiple tauri process windows,\n            // BroadcastChnnel wont work. So we poll LMDB for changes in tauri.\n            pendingBroadcastKV[key] = valueToStore;\n        }\n        PhStore.trigger(key, CHANGE_TYPE_INTERNAL);\n    }\n\n    /**\n     * Removes an item from storage. This will trigger a change notification on removal if watchers are attached.\n     * Watchers are unaffected on removal, you will still get notifications if the key gets created in the future.\n     *\n     * @param {string} key - The key to remove\n     */\n    function removeItem(key) {\n        setItem(key, null);\n    }\n\n    /**\n     * Enables best effort monitoring of external changes to the specified key when there are multiple Phoenix\n     * windows/instances. By default, PhStore.on(<key name>, fn) only triggers for key value changes within\n     * the current instance. Calling this function will activate change events when changes occur in other\n     * instances as well. Note that this is a best effort service, there may be eventual consistent delays of\n     * up to 1 second or the event may not be received at all.\n     *\n     * @param {string} key - The key to observe changes for.\n     */\n\n    function watchExternalChanges(key) {\n        watchExternalKeys[key] = true;\n        if(isDesktop) {\n            const t = (cache[key] && cache[key].t ) || 0;\n            storageNodeConnector.execPeer(\"watchExternalChanges\", {key, t});\n        }\n    }\n\n    /**\n     * If there are multiple phoenix windows/instances, This function will stop watching changes\n     * made by other phoenix instances for this key.\n     *\n     * @param {string} key - The key for which changes are being observed.\n     */\n    function unwatchExternalChanges(key) {\n        delete watchExternalKeys[key];\n        if(isDesktop) {\n            storageNodeConnector.execPeer(\"unwatchExternalChanges\", key);\n        }\n    }\n\n    function setupFirstBoot() {\n        try{\n            const firstBootTime = getItem(FIRST_BOOT_TIME);\n            if(!firstBootTime){\n                window.Phoenix.firstBoot = true;\n                setItem(FIRST_BOOT_TIME, Date.now());\n            }\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    const storageReadyPromise = new Promise((resolve) => {\n        if(Phoenix.isTestWindow){\n            // in test window, we will always use blank storage to init.\n            resolve();\n            return;\n        }\n        if(isDesktop){\n            // In tauri, we have to read it from app local data dump(which is usually written at app close time. This\n            // will help the storage to quick start from a json dump instead of waiting for node to boot up and init lmdb)\n            window._tauriStorageRestorePromise\n                .then((jsonData)=>{\n                    if(jsonData){\n                        cache = JSON.parse(jsonData);\n                    }\n                })\n                .catch(console.error)\n                .finally(()=>{\n                    setupFirstBoot();\n                    resolve();\n                }); // we never fail, boot with blank storage\n            return;\n        }\n        // Use browser default storage- IndexedDB\n        entries(_getIDBStorage())\n            .then(kvArrayAll=>{\n                for(let kvArray of kvArrayAll) {\n                    // Get all entries in the store. Each entry is an array of [key, value].\n                    // Eg: [[123, 456], ['hello', 'world']]\n                    cache[kvArray[0]] = kvArray[1];\n                }\n            })\n            .catch(console.error)\n            .finally(()=>{\n                setupFirstBoot();\n                resolve();\n            }); // we never fail, boot with blank storage\n    });\n    const _PHSTORE_BOOT_DESKTOP_ZOOM_SCALE_KEY = \"desktopZoomScale\";\n\n    storageReadyPromise\n        .then(()=>{\n            // do things to do that are critical to user experience here\n            // We try to set window zoom as early as possible to prevent zoom flicker\n            const zoomFactor = PhStore.getItem(_PHSTORE_BOOT_DESKTOP_ZOOM_SCALE_KEY) || 1;\n            if(Phoenix.browser.isTauri){\n                window.__TAURI__.tauri.invoke(\"zoom_window\", {scaleFactor: zoomFactor});\n            }\n        });\n    /**\n     * Waits till all pending changes are written to disk. This will not trigger a flush operation, but just waits\n     * on db to flush all operations to disk that has happened till this call.\n     * @returns {Promise<void>|Promise|*}\n     */\n    async function flushDB() {\n        if(isDesktop) {\n            // since node connector web socket messages are queued, sending this message will only execute after all\n            // outstanding messages are sent to node with web socket.\n            await storageNodeConnector.execPeer(\"flushDB\");\n        }\n    }\n\n    const PhStore = {\n        getItem,\n        setItem,\n        removeItem,\n        flushDB,\n        watchExternalChanges,\n        unwatchExternalChanges,\n        storageReadyPromise,\n        // private APIs\n        _storageBootstrapTime: Date.now() - Phoenix.startTime,\n        _PHSTORE_BOOT_DESKTOP_ZOOM_SCALE_KEY,\n        CHANGE_TYPE_INTERNAL,\n        CHANGE_TYPE_EXTERNAL\n    };\n    if(Phoenix.isTestWindow) {\n        PhStore._setTestKey = function (testKey) {\n            _testKey = testKey;\n        };\n    }\n    EventDispatcher.makeEventDispatcher(PhStore);\n    window.PhStore = PhStore;\n}());\n"],"file":"storage.js"}
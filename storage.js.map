{"version":3,"sources":["storage.js"],"names":["setupGlobalStorage","window","PhStore","console","error","EVENT_CHANGED","FIRST_BOOT_TIME","storageNodeConnector","_testKey","nodeStoragePhoenixApis","isBrowser","Phoenix","browser","isTauri","isDesktop","PH_LOCAL_STORE_PREFIX","PHOENIX_STORAGE_BROADCAST_CHANNEL_NAME","EXTERNAL_CHANGE_BROADCAST_INTERVAL","CHANGE_TYPE_EXTERNAL","CHANGE_TYPE_INTERNAL","MGS_CHANGE","cache","pendingBroadcastKV","watchExternalKeys","commitExternalChanges","changedKV","key","Object","keys","externalChange","t","trigger","nodeSetupDonePromise","then","nodeConfig","STORAGE_NODE_CONNECTOR_ID","PhNodeEngine","createNodeConnector","execPeer","_tauriBootVars","appLocalDir","isTestWindow","on","_evt","alert","storageChannel","BroadcastChannel","setInterval","postMessage","type","onmessage","event","message","data","getItem","cachedResult","JSON","parse","v","jsonStr","localStorage","e","setItem","value","valueToStore","Date","now","stringify","debugMode","removeItem","watchExternalChanges","unwatchExternalChanges","setupFirstBoot","firstBootTime","firstBoot","storageReadyPromise","Promise","resolve","_tauriStorageRestorePromise","jsonData","finally","async","flushDB","_storageBootstrapTime","startTime","_setTestKey","testKey","EventDispatcher","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/** The main persistent storage apis used to store preferences, setting etc. This is synced across all running phoenix\n * tabs in the browser and processes in the desktop app.\n * Data is eventually consistent with sync delays up to a few seconds.\n *\n * Storage API that seamlessly works in both web browsers and Tauri. In web browsers, the API utilizes local storage,\n * providing a consistent and reliable key-value store for small configuration data with persistence guarantees and\n * efficient read-write performance. It's important to note that this storage API is not suitable for storing\n * large data, such as file content or debug-related information.\n *\n * Features:\n * - Synchronous reads with in-memory caching for optimized performance.\n * - Read-after-write consistency within a single instance.\n * - Eventual consistency (within approximately 3 seconds) when used across multiple processes or tabs.\n *\n * The motivation behind implementing this unified storage API is to address the limitations and potential data loss\n * issues associated with using local storage and IndexedDB in our desktop builds. Specifically, certain scenarios,\n * like WebKit's data clearing in Linux and macOS Tauri builds as part of Intelligent Tracking Prevention (ITP),\n * could lead to data loss.\n *\n * The main aim is to have data durability guarantees in desktop builds.\n * In bowser, we can only overcome this if we have cloud login. Eventually we can have a cloud backend that will sync\n * with this storage implementation.\n */\n\n/*global EventDispatcher*/\n\n(function setupGlobalStorage() {\n    if(window.PhStore){\n        console.error(`window.PhStore already setup. Ignoring.`);\n        return;\n    }\n    const EVENT_CHANGED = \"change\";\n    const FIRST_BOOT_TIME = \"firstBootTime\";\n    let storageNodeConnector;\n    let _testKey;\n    let nodeStoragePhoenixApis = {};\n    const isBrowser = !Phoenix.browser.isTauri;\n    const isDesktop = Phoenix.browser.isTauri;\n\n    const PH_LOCAL_STORE_PREFIX = \"Ph_\";\n    const PHOENIX_STORAGE_BROADCAST_CHANNEL_NAME = \"ph-storage\";\n    const EXTERNAL_CHANGE_BROADCAST_INTERVAL = 500;\n    // Since this is a sync API, performance is critical. So we use a memory map in cache. This limits the size\n    // of what can be stored in this storage as if fully in memory.\n    const CHANGE_TYPE_EXTERNAL = \"External\",\n        CHANGE_TYPE_INTERNAL = \"Internal\";\n    const MGS_CHANGE = 'change';\n    let cache = {};\n    // map from watched keys that was set in this instance to\n    // modified time and value - key->{t,v}\n    let pendingBroadcastKV = {},\n        watchExternalKeys = {}; // boolean map\n\n    function commitExternalChanges(changedKV) {\n        for(let key of Object.keys(changedKV)){\n            // we only update the key and trigger if the key is being watched here.\n            // If unwatched keys are updated from another window, for eg, theme change pulled in from a new\n            // theme installed in another window cannot be applied in this window. So the code has to\n            // explicitly support external changes by calling watchExternalChanges API.\n            if(watchExternalKeys[key]) {\n                const externalChange = changedKV[key]; // {t,v} in new value, t = changed time\n                // if the change time of the external event we got is more recent than what we have,\n                // only then accept the change. else we have more recent data.\n                if(!cache[key] || (externalChange.t > cache[key].t)) {\n                    cache[key] = externalChange;\n                    PhStore.trigger(key, CHANGE_TYPE_EXTERNAL);\n                }\n            }\n        }\n    }\n\n    if(isDesktop){\n        if(window.nodeSetupDonePromise){\n            window.nodeSetupDonePromise.then(nodeConfig =>{\n                const STORAGE_NODE_CONNECTOR_ID = \"ph_storage\";\n                storageNodeConnector = window.PhNodeEngine.createNodeConnector(\n                    STORAGE_NODE_CONNECTOR_ID, nodeStoragePhoenixApis);\n                storageNodeConnector.execPeer(\"openDB\", window._tauriBootVars.appLocalDir);\n                if(Phoenix.isTestWindow) {\n                    window.storageNodeConnector = storageNodeConnector;\n                }\n                storageNodeConnector.on(EVENT_CHANGED, (_evt, changedKV)=>{\n                    commitExternalChanges(changedKV);\n                });\n            });\n        } else {\n            alert(\"Critical Error! Node Storage could not be started.\");\n        }\n    }\n\n    if(isBrowser) {\n        const storageChannel = new BroadcastChannel(PHOENIX_STORAGE_BROADCAST_CHANNEL_NAME);\n        setInterval(()=>{\n            // broadcast all changes made to watched keys in this instance to others\n            storageChannel.postMessage({type: MGS_CHANGE, keys: pendingBroadcastKV});\n            pendingBroadcastKV = {};\n\n        }, EXTERNAL_CHANGE_BROADCAST_INTERVAL);\n        // Listen for messages on the channel\n        storageChannel.onmessage = (event) => {\n            const message = event.data;\n            if(message.type === MGS_CHANGE){\n                commitExternalChanges(message.keys);\n            }\n        };\n    }\n\n    /**\n     * Retrieves the value associated with the specified key from the browser's local storage.\n     *\n     * @param {string} key - The key to retrieve the value for.\n     * @returns {string|number|boolean|object|null} - The value associated with the specified key. Returns null if the key does not exist.\n     */\n    function getItem(key) {\n        let cachedResult = cache[key];\n        if(cachedResult){\n            return JSON.parse(cachedResult.v);\n        }\n        if(Phoenix.isTestWindow || isDesktop){\n            // in tauri, once we load the db dump from file, we dont ever touch the storage apis again for\n            // get operations. This is because in tauri, the get operation is async via node. in future,\n            // we can write a async refresh key api to update values that has been cached if the need arises.\n            // but rn, there is no need for the same as every phoenix instance will use its own cached storage\n            // that guarantees read after write constancy within an instance, and for external changes, use watch.\n            return null;\n        }\n        const jsonStr = localStorage.getItem(PH_LOCAL_STORE_PREFIX + key);\n        if(jsonStr === null){\n            return null;\n        }\n        try {\n            cachedResult = JSON.parse(jsonStr);\n            cache[key] = cachedResult;\n            return JSON.parse(cachedResult.v); // clone. JSON.Parse is faster than structured object clone.\n        } catch (e) {\n            return null;\n        }\n    }\n\n    /**\n     * Sets the value of a specified key in the localStorage.\n     *\n     * @param {string} key - The key to set the value for.\n     * @param {string|number|boolean|object} value - The value to be stored. Can be any valid JSON serializable data type.\n     *\n     */\n    function setItem(key, value) {\n        const valueToStore = {\n            t: Date.now(), // modified time\n            // we store value as string here as during get operation, we can use json.parse to clone instead of\n            // using slower structured object clone.\n            v: JSON.stringify(value)\n        };\n        if(!Phoenix.isTestWindow || key === _testKey) {\n            if(isDesktop) {\n                storageNodeConnector.execPeer(\"putItem\", {key, value: valueToStore});\n            }\n            if(window.debugMode || isBrowser) {\n                // in debug mode, we write to local storage in tauri and browser builds for eazy debug of storage.\n                localStorage.setItem(PH_LOCAL_STORE_PREFIX + key, JSON.stringify(valueToStore));\n            }\n        }\n        cache[key] = valueToStore;\n        if(watchExternalKeys[key] && isBrowser){\n            // Broadcast channel is only used in browser, in tauri with multiple tauri process windows,\n            // BroadcastChnnel wont work. So we poll LMDB for changes in tauri.\n            pendingBroadcastKV[key] = valueToStore;\n        }\n        PhStore.trigger(key, CHANGE_TYPE_INTERNAL);\n    }\n\n    /**\n     * Removes an item from storage. This will trigger a change notification on removal if watchers are attached.\n     * Watchers are unaffected on removal, you will still get notifications if the key gets created in the future.\n     *\n     * @param {string} key - The key to remove\n     */\n    function removeItem(key) {\n        setItem(key, null);\n    }\n\n    /**\n     * Enables best effort monitoring of external changes to the specified key when there are multiple Phoenix\n     * windows/instances. By default, PhStore.on(<key name>, fn) only triggers for key value changes within\n     * the current instance. Calling this function will activate change events when changes occur in other\n     * instances as well. Note that this is a best effort service, there may be eventual consistent delays of\n     * up to 1 second or the event may not be received at all.\n     *\n     * @param {string} key - The key to observe changes for.\n     */\n\n    function watchExternalChanges(key) {\n        watchExternalKeys[key] = true;\n        if(isDesktop) {\n            const t = (cache[key] && cache[key].t ) || 0;\n            storageNodeConnector.execPeer(\"watchExternalChanges\", {key, t});\n        }\n    }\n\n    /**\n     * If there are multiple phoenix windows/instances, This function will stop watching changes\n     * made by other phoenix instances for this key.\n     *\n     * @param {string} key - The key for which changes are being observed.\n     */\n    function unwatchExternalChanges(key) {\n        delete watchExternalKeys[key];\n        if(isDesktop) {\n            storageNodeConnector.execPeer(\"unwatchExternalChanges\", key);\n        }\n    }\n\n    function setupFirstBoot() {\n        const firstBootTime = getItem(FIRST_BOOT_TIME);\n        if(!firstBootTime){\n            window.Phoenix.firstBoot = true;\n            setItem(FIRST_BOOT_TIME, Date.now());\n        }\n    }\n\n    const storageReadyPromise = new Promise((resolve) => {\n        if(isBrowser || Phoenix.isTestWindow){\n            // in browsers its immediately ready as we use localstorage\n            // in tests, immediately resolve with empty storage.\n            resolve();\n            setupFirstBoot();\n            return;\n        }\n        // In tauri, we have to read it from app local data dump(which is usually written at app close time. This\n        // will help the storage to quick start from a json dump instead of waiting for node to boot up and init lmdb)\n        window._tauriStorageRestorePromise\n            .then((jsonData)=>{\n                cache = JSON.parse(jsonData);\n                setupFirstBoot();\n            })\n            .finally(resolve);\n    });\n\n    /**\n     * Waits till all pending changes are written to disk. This will not trigger a flush operation, but just waits\n     * on db to flush all operations to disk that has happened till this call.\n     * @returns {Promise<void>|Promise|*}\n     */\n    async function flushDB() {\n        if(isDesktop) {\n            // since node connector web socket messages are queued, sending this message will only execute after all\n            // outstanding messages are sent to node with web socket.\n            await storageNodeConnector.execPeer(\"flushDB\");\n        }\n    }\n\n    const PhStore = {\n        getItem,\n        setItem,\n        removeItem,\n        flushDB,\n        watchExternalChanges,\n        unwatchExternalChanges,\n        storageReadyPromise,\n        _storageBootstrapTime: Date.now() - Phoenix.startTime\n    };\n    if(Phoenix.isTestWindow) {\n        PhStore._setTestKey = function (testKey) {\n            _testKey = testKey;\n        };\n    }\n    EventDispatcher.makeEventDispatcher(PhStore);\n    window.PhStore = PhStore;\n}());\n"],"file":"storage.js"}
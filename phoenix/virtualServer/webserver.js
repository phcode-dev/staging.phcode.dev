if(importScripts("phoenix/virtualServer/config.js"),!self.Serve){let fs=self.fs,Path=self.path;function formatContentDisposition(path,stats){const filename=Path.basename(path),modified=stats.mtime.toUTCString();return`attachment; filename="${filename}"; modification-date="${modified}"; size=${stats.size};`}async function _wait(timeMs){return new Promise(resolve=>{setTimeout(resolve,timeMs)})}async function _resolvingRead(path,encoding){return new Promise(resolve=>{fs.readFile(path,encoding,function(error,contents){resolve({error:error,contents:contents})})})}async function _resolvingStat(path){return new Promise(resolve=>{fs.stat(path,function(error,stats){resolve({error:error,stats:stats})})})}const FILE_READ_RETRY_COUNT=5,BACKOFF_TIME_MS=10,serve=async function(path,formatter,download){return new Promise(async(resolve,reject)=>{function buildResponse(responseData){return new Response(responseData.body,responseData.config)}function serveError(path,err){if("ENOENT"===err.code)return resolve(buildResponse(formatter.format404(path)));resolve(buildResponse(formatter.format500(path,err)))}async function serveFile(path,stats){let err=null;for(let i=1;i<=FILE_READ_RETRY_COUNT;i++){let fileResponse=await _resolvingRead(path,fs.BYTE_ARRAY_ENCODING);if(fileResponse.error){err=fileResponse.error,await _wait(i*BACKOFF_TIME_MS);continue}const responseData=formatter.formatFile(path,fileResponse.contents,stats);return 200===responseData.config.status&&download&&(responseData.config.headers["Content-Disposition"]=formatContentDisposition(path,stats)),void resolve(new Response(responseData.body,responseData.config))}serveError(path,err)}function serveDir(path){function maybeServeIndexFile(){if(path.endsWith("//"))return void serveDirListing();const indexPath=Path.join(path,"index.html");fs.stat(indexPath,function(err,stats){err?"ENOENT"!==err.code||Config.disableIndexes?serveError(path,err):serveDirListing():serveFile(indexPath,stats)})}function serveDirListing(){fs.readdir(path,function(err,entries){if(err)return serveError(path,err);const responseData=formatter.formatDir(Config.route,path,entries);resolve(new Response(responseData.body,responseData.config))})}maybeServeIndexFile()}let err=null;try{for(let i=1;i<=FILE_READ_RETRY_COUNT;i++){let fileStat=await _resolvingStat(path);if(!fileStat.error)return fileStat.stats.isDirectory()?serveDir(path):serveFile(path,fileStat.stats);err=fileStat.error,await _wait(i*BACKOFF_TIME_MS)}return serveError(path,err)}catch(e){reject(e)}})};self.Serve={serve:serve}}
//# sourceMappingURL=webserver.js.map

{"version":3,"sources":["phoenix/virtualServer/webserver.js"],"names":["importScripts","self","Serve","fs","Path","path","formatContentDisposition","stats","filename","basename","modified","mtime","toUTCString","size","async","_wait","timeMs","Promise","resolve","setTimeout","_resolvingRead","encoding","readFile","error","contents","_resolvingStat","stat","FILE_READ_RETRY_COUNT","BACKOFF_TIME_MS","serve","formatter","download","reject","buildResponse","responseData","Response","body","config","serveError","err","code","format404","format500","serveFile","i","fileResponse","BYTE_ARRAY_ENCODING","formatFile","status","headers","serveDir","maybeServeIndexFile","endsWith","serveDirListing","indexPath","join","Config","disableIndexes","readdir","entries","formatDir","route","fileStat","isDirectory","e"],"mappings":"AAuBA,GAFAA,cAAc,oCAEVC,KAAKC,MAAM,CACX,IAAIC,GAAKF,KAAKE,GACVC,KAAOH,KAAKI,KAEhB,SAASC,yBAAyBD,KAAME,OACpC,MAAMC,SAAWJ,KAAKK,SAASJ,MACzBK,SAAWH,MAAMI,MAAMC,cAC7B,+BAAgCJ,iCAAiCE,mBAAmBH,MAAMM,QAG9FC,eAAeC,MAAMC,QACjB,OAAO,IAAIC,QAASC,UAChBC,WAAWD,QAASF,UAK5BF,eAAeM,eAAef,KAAMgB,UAChC,OAAO,IAAIJ,QAASC,UAChBf,GAAGmB,SAASjB,KAAMgB,SAAU,SAAUE,MAAOC,UACzCN,QAAQ,CAACK,MAAAA,MAAOC,SAAAA,eAK5BV,eAAeW,eAAepB,MAC1B,OAAO,IAAIY,QAASC,UAChBf,GAAGuB,KAAKrB,KAAM,SAAUkB,MAAOhB,OAC3BW,QAAQ,CAACK,MAAAA,MAAOhB,MAAAA,YAI5B,MAAMoB,sBAAwB,EACxBC,gBAAkB,GAElBC,MAAQf,eAAgBT,KAAMyB,UAAWC,UAC3C,OAAO,IAAId,QAAQH,MAAOI,QAASc,UAC/B,SAASC,cAAcC,cACnB,OAAO,IAAIC,SAASD,aAAaE,KAAMF,aAAaG,QAGxD,SAASC,WAAWjC,KAAMkC,KACtB,GAAiB,WAAbA,IAAIC,KACJ,OAAOtB,QAAQe,cAAcH,UAAUW,UAAUpC,QAErDa,QAAQe,cAAcH,UAAUY,UAAUrC,KAAMkC,OAGpDzB,eAAe6B,UAAUtC,KAAME,OAC3B,IAAIgC,IAAM,KACV,IAAI,IAAIK,EAAI,EAAGA,GAAKjB,sBAAuBiB,IAAI,CAG3C,IAAIC,mBAAqBzB,eAAef,KAAMF,GAAG2C,qBACjD,GAAGD,aAAatB,MAAM,CAClBgB,IAAMM,aAAatB,YACbR,MAAM6B,EAAIhB,iBAChB,SAEJ,MAAMM,aAAeJ,UAAUiB,WAAW1C,KAAMwC,aAAarB,SAAUjB,OASvE,OANmC,MAA/B2B,aAAaG,OAAOW,QAAkBjB,WACtCG,aAAaG,OAAOY,QAAQ,uBACxB3C,yBAAyBD,KAAME,aAGvCW,QAAQ,IAAIiB,SAASD,aAAaE,KAAMF,aAAaG,SAGzDC,WAAWjC,KAAMkC,KAIrB,SAASW,SAAS7C,MAEd,SAAS8C,sBACL,GAAG9C,KAAK+C,SAAS,MAGb,YADAC,kBAIJ,MAAMC,UAAYlD,KAAKmD,KAAKlD,KAAM,cAClCF,GAAGuB,KAAK4B,UAAW,SAAUf,IAAKhC,OAC1BgC,IACiB,WAAbA,IAAIC,MAAsBgB,OAAOC,eAKjCnB,WAAWjC,KAAMkC,KAHjBc,kBAOJV,UAAUW,UAAW/C,SAKjC,SAAS8C,kBACLlD,GAAGuD,QAAQrD,KAAM,SAAUkC,IAAKoB,SAC5B,GAAIpB,IACA,OAAOD,WAAWjC,KAAMkC,KAG5B,MAAML,aAAeJ,UAAU8B,UAAUJ,OAAOK,MAAOxD,KAAMsD,SAC7DzC,QAAQ,IAAIiB,SAASD,aAAaE,KAAMF,aAAaG,WAI7Dc,sBAGJ,IAAIZ,IAAM,KACV,IACI,IAAI,IAAIK,EAAI,EAAGA,GAAKjB,sBAAuBiB,IAAI,CAC3C,IAAIkB,eAAiBrC,eAAepB,MACpC,IAAGyD,SAASvC,MAKZ,OAAIuC,SAASvD,MAAMwD,cACRb,SAAS7C,MAETsC,UAAUtC,KAAMyD,SAASvD,OAPhCgC,IAAMuB,SAASvC,YACTR,MAAM6B,EAAIhB,iBASxB,OAAOU,WAAWjC,KAAMkC,KAC1B,MAAOyB,GACLhC,OAAOgC,OAKnB/D,KAAKC,MAAQ,CACT2B,MAAAA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * modified by core.ai, based on work by David Humphrey <david.humphrey@senecacolleage.ca> (@humphd)\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* global Config, importScripts*/\n\nimportScripts('phoenix/virtualServer/config.js');\n\nif(!self.Serve){\n    let fs = self.fs;\n    let Path = self.path;\n// https://tools.ietf.org/html/rfc2183\n    function formatContentDisposition(path, stats) {\n        const filename = Path.basename(path);\n        const modified = stats.mtime.toUTCString();\n        return `attachment; filename=\"${filename}\"; modification-date=\"${modified}\"; size=${stats.size};`;\n    }\n\n    async function _wait(timeMs) {\n        return new Promise((resolve)=>{\n            setTimeout(resolve, timeMs);\n        });\n    }\n\n    // fs read that always resolves even if there is error\n    async function _resolvingRead(path, encoding) {\n        return new Promise((resolve)=>{\n            fs.readFile(path, encoding, function (error, contents) {\n                resolve({error, contents});\n            });\n        });\n    }\n    // fs stat that always resolves even if there is error\n    async function _resolvingStat(path) {\n        return new Promise((resolve)=>{\n            fs.stat(path, function (error, stats) {\n                resolve({error, stats});\n            });\n        });\n    }\n    const FILE_READ_RETRY_COUNT = 5,\n          BACKOFF_TIME_MS = 10;\n\n    const serve = async function (path, formatter, download) {\n        return new Promise(async (resolve, reject) => { // eslint-disable-line\n            function buildResponse(responseData) {\n                return new Response(responseData.body, responseData.config);\n            }\n\n            function serveError(path, err) {\n                if (err.code === 'ENOENT') {\n                    return resolve(buildResponse(formatter.format404(path)));\n                }\n                resolve(buildResponse(formatter.format500(path, err)));\n            }\n\n            async function serveFile(path, stats) {\n                let err = null;\n                for(let i = 1; i <= FILE_READ_RETRY_COUNT; i++){\n                    // sometimes there is read after write contention in native fs between main thread and worker.\n                    // so we retry\n                    let fileResponse = await _resolvingRead(path, fs.BYTE_ARRAY_ENCODING);\n                    if(fileResponse.error){\n                        err = fileResponse.error;\n                        await _wait(i * BACKOFF_TIME_MS);\n                        continue;\n                    }\n                    const responseData = formatter.formatFile(path, fileResponse.contents, stats);\n\n                    // If we are supposed to serve this file or download, add headers\n                    if (responseData.config.status === 200 && download) {\n                        responseData.config.headers['Content-Disposition'] =\n                            formatContentDisposition(path, stats);\n                    }\n\n                    resolve(new Response(responseData.body, responseData.config));\n                    return;\n                }\n                serveError(path, err);\n            }\n\n            // Either serve /index.html (default index) or / (directory listing)\n            function serveDir(path) {\n\n                function maybeServeIndexFile() {\n                    if(path.endsWith(\"//\")){\n                        // this is for us to override and show the directory listing if the path ends with //\n                        serveDirListing();\n                        return;\n                    }\n\n                    const indexPath = Path.join(path, 'index.html');\n                    fs.stat(indexPath, function (err, stats) {\n                        if (err) {\n                            if (err.code === 'ENOENT' && !Config.disableIndexes) {\n                                // Fallback to a directory listing instead\n                                serveDirListing();\n                            } else {\n                                // Let the error (likely 404) pass through instead\n                                serveError(path, err);\n                            }\n                        } else {\n                            // Index file found, serve that instead\n                            serveFile(indexPath, stats);\n                        }\n                    });\n                }\n\n                function serveDirListing() {\n                    fs.readdir(path, function (err, entries) {\n                        if (err) {\n                            return serveError(path, err);\n                        }\n\n                        const responseData = formatter.formatDir(Config.route, path, entries);\n                        resolve(new Response(responseData.body, responseData.config));\n                    });\n                }\n\n                maybeServeIndexFile();\n            }\n\n            let err = null;\n            try{\n                for(let i = 1; i <= FILE_READ_RETRY_COUNT; i++){\n                    let fileStat = await _resolvingStat(path);\n                    if(fileStat.error){\n                        err = fileStat.error;\n                        await _wait(i * BACKOFF_TIME_MS);\n                        continue;\n                    }\n                    if (fileStat.stats.isDirectory()) {\n                        return serveDir(path);\n                    } else {\n                        return serveFile(path, fileStat.stats);\n                    }\n                }\n                return serveError(path, err);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    self.Serve = {\n        serve\n    };\n\n}\n"],"file":"webserver.js"}
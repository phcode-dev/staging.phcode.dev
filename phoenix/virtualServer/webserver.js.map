{"version":3,"sources":["phoenix/virtualServer/webserver.js"],"names":["importScripts","self","Serve","_serverBroadcastChannel","BroadcastChannel","fs","Path","path","instrumentedURLs","responseListeners","_getNewRequestID","Math","round","random","formatContentDisposition","stats","filename","basename","modified","mtime","toUTCString","size","async","_wait","timeMs","Promise","resolve","setTimeout","_resolvingRead","encoding","readFile","error","contents","_resolvingStat","stat","FILE_READ_RETRY_COUNT","BACKOFF_TIME_MS","serve","formatter","download","normalize","reject","buildResponse","responseData","Response","body","config","serveError","err","code","format404","format500","serveInstrumentedFile","allURLs","rootPaths","Object","keys","subPath","push","includes","_debugLivePreviewLog","requestID","postMessage","type","response","serveFileContent","formatFile","i","fileResponse","BYTE_ARRAY_ENCODING","status","headers","serveFile","fileServed","serveDir","maybeServeIndexFile","endsWith","serveDirListing","indexPath","join","Config","disableIndexes","readdir","entries","formatDir","virtualServerBaseURL","fileStat","isDirectory","e","setInstrumentedURLs","event","data","root","paths","ports","processVirtualServerMessage","eventType","console","log","onmessage"],"mappings":"AAuBA,GAFAA,cAAc,oCAEVC,KAAKC,MAAM,CACX,MAAMC,wBAA0B,IAAIC,iBAAiB,4BAC/CC,GAAKJ,KAAKI,GACVC,KAAOL,KAAKM,KAClB,IAAIC,iBAAmB,GACnBC,kBAAoB,GAExB,SAASC,mBACL,OAAOC,KAAKC,MAAqB,KAAdD,KAAKE,UAI5B,SAASC,yBAAyBP,KAAMQ,OACpC,MAAMC,SAAWV,KAAKW,SAASV,MACzBW,SAAWH,MAAMI,MAAMC,cAC7B,+BAAgCJ,iCAAiCE,mBAAmBH,MAAMM,QAG9FC,eAAeC,MAAMC,QACjB,OAAO,IAAIC,QAASC,UAChBC,WAAWD,QAASF,UAK5BF,eAAeM,eAAerB,KAAMsB,UAChC,OAAO,IAAIJ,QAASC,UAChBrB,GAAGyB,SAASvB,KAAMsB,SAAU,SAAUE,MAAOC,UACzCN,QAAQ,CAACK,MAAAA,MAAOC,SAAAA,eAK5BV,eAAeW,eAAe1B,MAC1B,OAAO,IAAIkB,QAASC,UAChBrB,GAAG6B,KAAK3B,KAAM,SAAUwB,MAAOhB,OAC3BW,QAAQ,CAACK,MAAAA,MAAOhB,MAAAA,YAI5B,MAAMoB,sBAAwB,EAC1BC,gBAAkB,GAEhBC,MAAQf,eAAgBf,KAAM+B,UAAWC,UAE3C,OADAhC,KAAOD,KAAKkC,UAAUjC,MACf,IAAIkB,QAAQH,MAAOI,QAASe,UAC/B,SAASC,cAAcC,cACnB,OAAO,IAAIC,SAASD,aAAaE,KAAMF,aAAaG,QAGxD,SAASC,WAAWxC,KAAMyC,KACtB,GAAiB,WAAbA,IAAIC,KACJ,OAAOvB,QAAQgB,cAAcJ,UAAUY,UAAU3C,QAErDmB,QAAQgB,cAAcJ,UAAUa,UAAU5C,KAAMyC,OAGpD1B,eAAe8B,sBAAsB7C,KAAMQ,OACvC,IAAIsC,QAAU,GACd,IAAI,IAAIC,aAAaC,OAAOC,KAAKhD,kBAC7B,IAAI,IAAIiD,WAAWjD,iBAAiB8C,WAChCD,QAAQK,KAAKpD,KAAKkC,UAAUc,UAAYG,UAGhD,GAAGJ,QAAQM,SAASpD,MAAM,CACtBN,KAAK2D,qBAAqB,4CAA6CrD,MACvE,MAAMsD,UAAYnD,mBAgBlB,OAfAP,wBAAwB2D,YAAY,CAChCC,KAAM,yBACNxD,KAAAA,KACAsD,UAAAA,YAEJpD,kBAAkBoD,WAAa,SAAUG,UACrC,IAAIA,SAAShC,SAIT,OAHA/B,KAAK2D,qBACD,8DAA+DrD,WACnE0D,iBAAiB1D,KAAMQ,OAG3B,MAAM4B,aAAeL,UAAU4B,WAAW3D,KAAMyD,SAAShC,SAAUjB,OACnEW,QAAQ,IAAIkB,SAASD,aAAaE,KAAMF,aAAaG,WAElD,EAEX,OAAO,EAGXxB,eAAe2C,iBAAiB1D,KAAMQ,OAClC,IAAIiC,IAAM,KACV,IAAI,IAAImB,EAAI,EAAGA,GAAKhC,sBAAuBgC,IAAI,CAG3C,IAAIC,mBAAqBxC,eAAerB,KAAMF,GAAGgE,qBACjD,GAAGD,aAAarC,MAAM,CAClBiB,IAAMoB,aAAarC,YACbR,MAAM4C,EAAI/B,iBAChB,SAEJ,MAAMO,aAAeL,UAAU4B,WAAW3D,KAAM6D,aAAapC,SAAUjB,OASvE,OANmC,MAA/B4B,aAAaG,OAAOwB,QAAkB/B,WACtCI,aAAaG,OAAOyB,QAAQ,uBACxBzD,yBAAyBP,KAAMQ,aAGvCW,QAAQ,IAAIkB,SAASD,aAAaE,KAAMF,aAAaG,SAGzDC,WAAWxC,KAAMyC,KAGrB1B,eAAekD,UAAUjE,KAAMQ,OAC3B,IAAI0D,iBAAmBrB,sBAAsB7C,KAAMQ,QAInDkD,iBAAiB1D,KAAMQ,OAI3B,SAAS2D,SAASnE,MAEd,SAASoE,sBACL,GAAGpE,KAAKqE,SAAS,MAGb,YADAC,kBAIJ,MAAMC,UAAYxE,KAAKyE,KAAKxE,KAAM,cAClCF,GAAG6B,KAAK4C,UAAW,SAAU9B,IAAKjC,OAC1BiC,IACiB,WAAbA,IAAIC,MAAsB+B,OAAOC,eAKjClC,WAAWxC,KAAMyC,KAHjB6B,kBAOJL,UAAUM,UAAW/D,SAKjC,SAAS8D,kBACLxE,GAAG6E,QAAQ3E,KAAM,SAAUyC,IAAKmC,SAC5B,GAAInC,IACA,OAAOD,WAAWxC,KAAMyC,KAG5B,MAAML,aAAeL,UAAU8C,UAAUC,qBAAsB9E,KAAM4E,SACrEzD,QAAQ,IAAIkB,SAASD,aAAaE,KAAMF,aAAaG,WAI7D6B,sBAGJ,IAAI3B,IAAM,KACV,IACI,IAAI,IAAImB,EAAI,EAAGA,GAAKhC,sBAAuBgC,IAAI,CAC3C,IAAImB,eAAiBrD,eAAe1B,MACpC,IAAG+E,SAASvD,MAKZ,OAAIuD,SAASvE,MAAMwE,cACRb,SAASnE,MAEbiE,UAAUjE,KAAM+E,SAASvE,OAP5BiC,IAAMsC,SAASvD,YACTR,MAAM4C,EAAI/B,iBASxB,OAAOW,WAAWxC,KAAMyC,KAC1B,MAAOwC,GACL/C,OAAO+C,OAKnBlE,eAAemE,oBAAoBC,OAC/B,MAAMC,KAAOD,MAAMC,KACbC,KAAOD,KAAKC,KACdC,MAAQF,KAAKE,MACjB5F,KAAK2D,qBAAqB,sCAAuC+B,MACjEnF,iBAAiBoF,MAAQC,MACzBH,MAAMI,MAAM,GAAGhC,aAAY,GAK/B,SAASiC,4BAA4BL,OACjC,IAAIM,UACJ,OADgBN,MAAMC,MAAQD,MAAMC,KAAK5B,MAEzC,IAAK,mBACD,MAAMF,UAAY6B,MAAMC,KAAK9B,UAC7B,GAAG6B,MAAMC,KAAK9B,WAAapD,kBAAkBoD,WAGzC,OAFApD,kBAAkBoD,WAAW6B,MAAMC,aAC5BlF,kBAAkBoD,YAClB,GAVnBoC,QAAQC,IAAI,uBAeZ/F,wBAAwBgG,UAAYJ,4BAEpC9F,KAAKC,MAAQ,CACTmC,MAAAA,MACAoD,oBAAAA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * modified by core.ai, based on work by David Humphrey <david.humphrey@senecacolleage.ca> (@humphd)\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* global Config, virtualServerBaseURL*/\n\nimportScripts('phoenix/virtualServer/config.js');\n\nif(!self.Serve){\n    const _serverBroadcastChannel = new BroadcastChannel(\"virtual_server_broadcast\");\n    const fs = self.fs;\n    const Path = self.path;\n    let instrumentedURLs = {},\n        responseListeners = {};\n\n    function _getNewRequestID() {\n        return Math.round( Math.random()*1000000000000);\n    }\n\n    // https://tools.ietf.org/html/rfc2183\n    function formatContentDisposition(path, stats) {\n        const filename = Path.basename(path);\n        const modified = stats.mtime.toUTCString();\n        return `attachment; filename=\"${filename}\"; modification-date=\"${modified}\"; size=${stats.size};`;\n    }\n\n    async function _wait(timeMs) {\n        return new Promise((resolve)=>{\n            setTimeout(resolve, timeMs);\n        });\n    }\n\n    // fs read that always resolves even if there is error\n    async function _resolvingRead(path, encoding) {\n        return new Promise((resolve)=>{\n            fs.readFile(path, encoding, function (error, contents) {\n                resolve({error, contents});\n            });\n        });\n    }\n    // fs stat that always resolves even if there is error\n    async function _resolvingStat(path) {\n        return new Promise((resolve)=>{\n            fs.stat(path, function (error, stats) {\n                resolve({error, stats});\n            });\n        });\n    }\n    const FILE_READ_RETRY_COUNT = 5,\n        BACKOFF_TIME_MS = 10;\n\n    const serve = async function (path, formatter, download) {\n        path = Path.normalize(path);\n        return new Promise(async (resolve, reject) => { // eslint-disable-line\n            function buildResponse(responseData) {\n                return new Response(responseData.body, responseData.config);\n            }\n\n            function serveError(path, err) {\n                if (err.code === 'ENOENT') {\n                    return resolve(buildResponse(formatter.format404(path)));\n                }\n                resolve(buildResponse(formatter.format500(path, err)));\n            }\n\n            async function serveInstrumentedFile(path, stats) {\n                let allURLs = [];\n                for(let rootPaths of Object.keys(instrumentedURLs)){\n                    for(let subPath of instrumentedURLs[rootPaths]){\n                        allURLs.push(Path.normalize(rootPaths + subPath));\n                    }\n                }\n                if(allURLs.includes(path)){\n                    self._debugLivePreviewLog(\"Service worker: serving instrumented file\", path);\n                    const requestID = _getNewRequestID();\n                    _serverBroadcastChannel.postMessage({\n                        type: \"getInstrumentedContent\",\n                        path,\n                        requestID\n                    });\n                    responseListeners[requestID] = function (response) {\n                        if(!response.contents){\n                            self._debugLivePreviewLog(\n                                \"Service worker: no instrumented file received from phoenix!\", path);\n                            serveFileContent(path, stats);\n                            return;\n                        }\n                        const responseData = formatter.formatFile(path, response.contents, stats);\n                        resolve(new Response(responseData.body, responseData.config));\n                    };\n                    return true;\n                }\n                return false;\n            }\n\n            async function serveFileContent(path, stats) {\n                let err = null;\n                for(let i = 1; i <= FILE_READ_RETRY_COUNT; i++){\n                    // sometimes there is read after write contention in native fs between main thread and worker.\n                    // so we retry\n                    let fileResponse = await _resolvingRead(path, fs.BYTE_ARRAY_ENCODING);\n                    if(fileResponse.error){\n                        err = fileResponse.error;\n                        await _wait(i * BACKOFF_TIME_MS);\n                        continue;\n                    }\n                    const responseData = formatter.formatFile(path, fileResponse.contents, stats);\n\n                    // If we are supposed to serve this file or download, add headers\n                    if (responseData.config.status === 200 && download) {\n                        responseData.config.headers['Content-Disposition'] =\n                            formatContentDisposition(path, stats);\n                    }\n\n                    resolve(new Response(responseData.body, responseData.config));\n                    return;\n                }\n                serveError(path, err);\n            }\n\n            async function serveFile(path, stats) {\n                let fileServed = await serveInstrumentedFile(path, stats);\n                if(fileServed){\n                    return;\n                }\n                serveFileContent(path, stats);\n            }\n\n            // Either serve /index.html (default index) or / (directory listing)\n            function serveDir(path) {\n\n                function maybeServeIndexFile() {\n                    if(path.endsWith(\"//\")){\n                        // this is for us to override and show the directory listing if the path ends with //\n                        serveDirListing();\n                        return;\n                    }\n\n                    const indexPath = Path.join(path, 'index.html');\n                    fs.stat(indexPath, function (err, stats) {\n                        if (err) {\n                            if (err.code === 'ENOENT' && !Config.disableIndexes) {\n                                // Fallback to a directory listing instead\n                                serveDirListing();\n                            } else {\n                                // Let the error (likely 404) pass through instead\n                                serveError(path, err);\n                            }\n                        } else {\n                            // Index file found, serve that instead\n                            serveFile(indexPath, stats);\n                        }\n                    });\n                }\n\n                function serveDirListing() {\n                    fs.readdir(path, function (err, entries) {\n                        if (err) {\n                            return serveError(path, err);\n                        }\n\n                        const responseData = formatter.formatDir(virtualServerBaseURL, path, entries);\n                        resolve(new Response(responseData.body, responseData.config));\n                    });\n                }\n\n                maybeServeIndexFile();\n            }\n\n            let err = null;\n            try{\n                for(let i = 1; i <= FILE_READ_RETRY_COUNT; i++){\n                    let fileStat = await _resolvingStat(path);\n                    if(fileStat.error){\n                        err = fileStat.error;\n                        await _wait(i * BACKOFF_TIME_MS);\n                        continue;\n                    }\n                    if (fileStat.stats.isDirectory()) {\n                        return serveDir(path);\n                    }\n                    return serveFile(path, fileStat.stats);\n\n                }\n                return serveError(path, err);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    async function setInstrumentedURLs(event) {\n        const data = event.data;\n        const root = data.root,\n            paths = data.paths;\n        self._debugLivePreviewLog(\"Service worker: setInstrumentedURLs\", data);\n        instrumentedURLs[root] = paths;\n        event.ports[0].postMessage(true);// acknowledge for the other side to resolve promise\n    }\n\n    console.log(\"service worker init\");\n\n    function processVirtualServerMessage(event) {\n        let eventType = event.data && event.data.type;\n        switch (eventType) {\n        case 'REQUEST_RESPONSE':\n            const requestID = event.data.requestID;\n            if(event.data.requestID && responseListeners[requestID]){\n                responseListeners[requestID](event.data);\n                delete responseListeners[requestID];\n                return true;\n            }\n        }\n    }\n\n    _serverBroadcastChannel.onmessage = processVirtualServerMessage;\n\n    self.Serve = {\n        serve,\n        setInstrumentedURLs\n    };\n\n}\n"],"file":"webserver.js"}
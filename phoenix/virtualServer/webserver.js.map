{"version":3,"sources":["phoenix/virtualServer/webserver.js"],"names":["importScripts","self","Serve","_serverBroadcastChannel","BroadcastChannel","fs","Path","path","instrumentedURLs","responseListeners","_getNewRequestID","Math","round","random","formatContentDisposition","stats","filename","basename","modified","mtime","toUTCString","size","async","_wait","timeMs","Promise","resolve","setTimeout","_resolvingRead","encoding","readFile","error","contents","_resolvingStat","stat","FILE_READ_RETRY_COUNT","BACKOFF_TIME_MS","serve","formatter","download","phoenixInstanceID","normalize","reject","buildResponse","responseData","Response","body","config","serveError","err","code","format404","format500","serveInstrumentedFile","allURLs","rootPaths","Object","keys","subPath","push","includes","_debugLivePreviewLog","requestID","postMessage","type","response","serveFileContent","formatFile","i","fileResponse","BYTE_ARRAY_ENCODING","status","headers","serveFile","fileServed","serveDir","maybeServeIndexFile","endsWith","serveDirListing","indexPath","join","Config","disableIndexes","readdir","entries","formatDir","virtualServerBaseURL","fileStat","isDirectory","e","setInstrumentedURLs","event","data","root","paths","ports","processVirtualServerMessage","eventType","console","log","onmessage"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * modified by core.ai, based on work by David Humphrey <david.humphrey@senecacolleage.ca> (@humphd)\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* global Config, virtualServerBaseURL*/\n\nimportScripts('phoenix/virtualServer/config.js');\n\nif(!self.Serve){\n    const _serverBroadcastChannel = new BroadcastChannel(\"virtual_server_broadcast\");\n    const fs = self.fs;\n    const Path = self.path;\n    let instrumentedURLs = {},\n        responseListeners = {};\n\n    function _getNewRequestID() {\n        return Math.round( Math.random()*1000000000000);\n    }\n\n    // https://tools.ietf.org/html/rfc2183\n    function formatContentDisposition(path, stats) {\n        const filename = Path.basename(path);\n        const modified = stats.mtime.toUTCString();\n        return `attachment; filename=\"${filename}\"; modification-date=\"${modified}\"; size=${stats.size};`;\n    }\n\n    async function _wait(timeMs) {\n        return new Promise((resolve)=>{\n            setTimeout(resolve, timeMs);\n        });\n    }\n\n    // fs read that always resolves even if there is error\n    async function _resolvingRead(path, encoding) {\n        return new Promise((resolve)=>{\n            fs.readFile(path, encoding, function (error, contents) {\n                resolve({error, contents});\n            });\n        });\n    }\n    // fs stat that always resolves even if there is error\n    async function _resolvingStat(path) {\n        return new Promise((resolve)=>{\n            fs.stat(path, function (error, stats) {\n                resolve({error, stats});\n            });\n        });\n    }\n    const FILE_READ_RETRY_COUNT = 5,\n        BACKOFF_TIME_MS = 10;\n\n    const serve = async function (path, formatter, download, phoenixInstanceID) {\n        path = Path.normalize(path);\n        return new Promise(async (resolve, reject) => { // eslint-disable-line\n            function buildResponse(responseData) {\n                return new Response(responseData.body, responseData.config);\n            }\n\n            function serveError(path, err) {\n                if (err.code === 'ENOENT') {\n                    return resolve(buildResponse(formatter.format404(path)));\n                }\n                resolve(buildResponse(formatter.format500(path, err)));\n            }\n\n            async function serveInstrumentedFile(path, stats) {\n                let allURLs = [];\n                for(let rootPaths of Object.keys(instrumentedURLs)){\n                    for(let subPath of instrumentedURLs[rootPaths]){\n                        allURLs.push(Path.normalize(rootPaths + subPath));\n                    }\n                }\n                if(allURLs.includes(path)){\n                    self._debugLivePreviewLog(\"Service worker: serving instrumented file\", path);\n                    const requestID = _getNewRequestID();\n                    _serverBroadcastChannel.postMessage({\n                        type: \"getInstrumentedContent\",\n                        path,\n                        requestID,\n                        phoenixInstanceID\n                    });\n                    responseListeners[requestID] = function (response) {\n                        if(!response.contents){\n                            self._debugLivePreviewLog(\n                                \"Service worker: no instrumented file received from phoenix!\", path);\n                            serveFileContent(path, stats);\n                            return;\n                        }\n                        const responseData = formatter.formatFile(path, response.contents, stats);\n                        resolve(new Response(responseData.body, responseData.config));\n                    };\n                    return true;\n                }\n                return false;\n            }\n\n            async function serveFileContent(path, stats) {\n                let err = null;\n                for(let i = 1; i <= FILE_READ_RETRY_COUNT; i++){\n                    // sometimes there is read after write contention in native fs between main thread and worker.\n                    // so we retry\n                    let fileResponse = await _resolvingRead(path, fs.BYTE_ARRAY_ENCODING);\n                    if(fileResponse.error){\n                        err = fileResponse.error;\n                        await _wait(i * BACKOFF_TIME_MS);\n                        continue;\n                    }\n                    const responseData = formatter.formatFile(path, fileResponse.contents, stats);\n\n                    // If we are supposed to serve this file or download, add headers\n                    if (responseData.config.status === 200 && download) {\n                        responseData.config.headers['Content-Disposition'] =\n                            formatContentDisposition(path, stats);\n                    }\n\n                    resolve(new Response(responseData.body, responseData.config));\n                    return;\n                }\n                serveError(path, err);\n            }\n\n            async function serveFile(path, stats) {\n                let fileServed = await serveInstrumentedFile(path, stats);\n                if(fileServed){\n                    return;\n                }\n                serveFileContent(path, stats);\n            }\n\n            // Either serve /index.html (default index) or / (directory listing)\n            function serveDir(path) {\n\n                function maybeServeIndexFile() {\n                    if(path.endsWith(\"//\")){\n                        // this is for us to override and show the directory listing if the path ends with //\n                        serveDirListing();\n                        return;\n                    }\n\n                    const indexPath = Path.join(path, 'index.html');\n                    fs.stat(indexPath, function (err, stats) {\n                        if (err) {\n                            if (err.code === 'ENOENT' && !Config.disableIndexes) {\n                                // Fallback to a directory listing instead\n                                serveDirListing();\n                            } else {\n                                // Let the error (likely 404) pass through instead\n                                serveError(path, err);\n                            }\n                        } else {\n                            // Index file found, serve that instead\n                            serveFile(indexPath, stats);\n                        }\n                    });\n                }\n\n                function serveDirListing() {\n                    fs.readdir(path, function (err, entries) {\n                        if (err) {\n                            return serveError(path, err);\n                        }\n\n                        const responseData = formatter.formatDir(virtualServerBaseURL, path, entries);\n                        resolve(new Response(responseData.body, responseData.config));\n                    });\n                }\n\n                maybeServeIndexFile();\n            }\n\n            let err = null;\n            try{\n                for(let i = 1; i <= FILE_READ_RETRY_COUNT; i++){\n                    let fileStat = await _resolvingStat(path);\n                    if(fileStat.error){\n                        err = fileStat.error;\n                        await _wait(i * BACKOFF_TIME_MS);\n                        continue;\n                    }\n                    if (fileStat.stats.isDirectory()) {\n                        return serveDir(path);\n                    }\n                    return serveFile(path, fileStat.stats);\n\n                }\n                return serveError(path, err);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    async function setInstrumentedURLs(event) {\n        const data = event.data;\n        const root = data.root,\n            paths = data.paths;\n        self._debugLivePreviewLog(\"Service worker: setInstrumentedURLs\", data);\n        instrumentedURLs[root] = paths;\n        event.ports[0].postMessage(true);// acknowledge for the other side to resolve promise\n    }\n\n    console.log(\"service worker init\");\n\n    function processVirtualServerMessage(event) {\n        let eventType = event.data && event.data.type;\n        switch (eventType) {\n        case 'REQUEST_RESPONSE':\n            const requestID = event.data.requestID;\n            if(event.data.requestID && responseListeners[requestID]){\n                responseListeners[requestID](event.data);\n                delete responseListeners[requestID];\n                return true;\n            }\n        }\n    }\n\n    _serverBroadcastChannel.onmessage = processVirtualServerMessage;\n\n    self.Serve = {\n        serve,\n        setInstrumentedURLs\n    };\n\n}\n"],"file":"webserver.js"}
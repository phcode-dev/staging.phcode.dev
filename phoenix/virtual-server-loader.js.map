{"version":3,"sources":["phoenix/virtual-server-loader.js"],"names":["Workbox","_getBaseURL","baseURL","window","location","href","indexOf","substring","lastIndexOf","endsWith","getRoute","_isServiceWorkerLoaderPage","indexUrl","origin","baseUrl","devURL","currentURL","console","log","async","shouldUpdate","logger","error","leaveTrail","loggingOptions","fsServerUrl","navigator","wb","updateViaCache","isServerReady","_forceClearCacheIfNeeded","cacheKey","newCacheVersion","Phoenix","firstBoot","localStorage","setItem","lastClearedVersion","getItem","messageSW","type","then","updatedFilesCount","cache","updatePendingReloadReason","showUpdateDialogue","catch","err","serverReady","debugMode","logToConsolePref","logLivePreview","config","serverInstall","refreshServiceWorkerCache","doneCB","setTimeout","params","showSkipWaitingPrompt","event","updateAccepted","messageSkipWaiting","addEventListener","controlling","isUpdate","register"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// jshint ignore: start\n/*eslint no-console: 0*/\n/*global logger*/\n/*eslint strict: [\"error\", \"global\"]*/\n\n\n/** Sets up a web server for the local phoenix virtual file system root.\n * Based on https://github.com/humphd/nohost\n *\n * This module should be functionally as light weight as possible with minimal deps as it is a shell component.\n *\n * This file is always loaded fresh from network if available bypassing cache to help better resilience\n * against stale caches in service worker. So you can assume that this file will get loaded in its most recent\n * form despite the cache state in the browser.\n * **/\n\n\nimport {Workbox} from 'https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-window.prod.mjs';\n\nif(!window.logger){\n    // this will idealy never happen but since this file is always network first instead of cached, as we introduced\n    // logger, the variable was not found causing exceptions below and cache not being refreshed.\n    console.error(\"Could not find logger.\");\n    window.logger = {\n        leaveTrail: console.log,\n        loggingOptions: {}\n    };\n}\n\nfunction _getBaseURL() {\n    let baseURL = window.location.href;\n    if(location.href.indexOf( \"?\")>-1){\n        baseURL = location.href.substring( 0, location.href.indexOf( \"?\")); // remove query string params\n    }\n    if(location.href.indexOf( \"#\")>-1){\n        baseURL = baseURL.substring( 0, baseURL.indexOf( \"#\")); // remove hrefs in page\n    }\n    if(location.href.indexOf( \"/\")>-1){\n        baseURL = baseURL.substring( 0, baseURL.lastIndexOf( \"/\"));\n    }\n    if(!baseURL.endsWith('/')){\n        baseURL = baseURL + '/';\n    }\n    return baseURL;\n}\n\nfunction getRoute(){\n    return `phoenix/vfs`;\n}\n\nwindow.fsServerUrl = _getBaseURL() + getRoute() + \"/\";\n\nfunction _isServiceWorkerLoaderPage() {\n    // only http(s)://x.y.z/ or http(s)://x.y.z/index.html can load service worker, or localhost/src for dev builds\n    const indexUrl = `${location.origin}/index.html`,\n        baseUrl = `${location.origin}/`,\n        devURL = 'http://localhost:8000/src/',\n        currentURL = _getBaseURL();\n    console.log(\"currentURL\", currentURL, indexUrl, baseUrl, devURL);\n    return (currentURL === baseUrl || currentURL === indexUrl || currentURL === devURL);\n}\n\nasync function shouldUpdate() {\n    // service workers are always updated in phoenix instantly.\n    return true;\n}\n\n/**\n * Register Phoenix PWA and nohost web server service worker, passing `route` or other options.\n */\nif (_isServiceWorkerLoaderPage() && 'serviceWorker' in navigator) {\n    logger.leaveTrail(\"Service worker loader: Loading  from page...\" + window.location.href);\n    // We cannot realistically change the url of the service worker without causing major problems in service worker\n    // load. We will have to unregister and load a new service worker and there is no way to stop the already running\n    // service worker. As such, the below debug=false is unused, but kept there for legacy purposes to not change\n    // sw url without bombing the installation base.\n    // debug=false below is unused and kept for the above reason!!!!!\n    const wb = new Workbox(`virtual-server-main.js?debug=false&route=${getRoute()}`, {\n        // https://developer.chrome.com/blog/fresher-sw/#updateviacache\n        updateViaCache: 'none'\n    });\n\n    let isServerReady = false;\n\n    window.Phoenix.cache = {};\n\n    /**\n     * This will cause a full cache reset in the browser for the phoenix scripts.\n     * This will help the user to load the latest version of phoenix on the next load.\n     * @return {boolean}\n     * @private\n     */\n    function _forceClearCacheIfNeeded() {\n        const cacheKey = \"browserCacheVersionKey\";\n        const newCacheVersion = \"V2\"; // just increment this number to V2, v3 etc. to force clear the cached content.\n        if(window.Phoenix.firstBoot){\n            localStorage.setItem(cacheKey, newCacheVersion);\n            return false;\n        }\n        const lastClearedVersion = window.localStorage.getItem(cacheKey);\n        if(lastClearedVersion !== newCacheVersion) {\n            logger.leaveTrail(`Service worker loader: triggering CLEAR_CACHE for live preview service worker upgrade`);\n            wb.messageSW({\n                type: 'CLEAR_CACHE'\n            }).then(({updatedFilesCount})=>{\n                logger.leaveTrail(`Service worker loader: clear cache updatedFilesCount: `+ updatedFilesCount);\n                window.Phoenix.cache.updatePendingReloadReason = \"clearCache\";\n                window.Phoenix.cache.showUpdateDialogue = true;\n                window.Phoenix.cache.updatedFilesCount = updatedFilesCount || 0;\n                localStorage.setItem(cacheKey, newCacheVersion);\n            }).catch(err=>{\n                console.error(\"Service worker loader: Error while triggering clear cache\", err);\n            });\n            return true;\n        }\n        return false;\n    }\n\n    // refreshServiceWorkerCache should be done after app load to prevent mixed js script content load. Ie,\n    // if we do the cache reset now, some scripts loaded may be from cache and some from the new version.\n    window.refreshServiceWorkerCache = function (doneCB) {\n        if(!isServerReady){\n            setTimeout(()=>{\n                window.refreshServiceWorkerCache(doneCB);\n            }, 100);\n            return;\n        }\n        logger.leaveTrail(`Service worker loader: triggering REFRESH_CACHE`);\n        wb.messageSW({\n            type: 'REFRESH_CACHE'\n        }).then(({updatedFilesCount})=>{\n            logger.leaveTrail(`Service worker loader: refresh cache updatedFilesCount: `+ updatedFilesCount);\n            window.Phoenix.cache.updatePendingReloadReason = \"refreshCache\";\n            window.Phoenix.cache.updatedFilesCount = updatedFilesCount || 0;\n            if(doneCB) {\n                doneCB();\n            }\n        }).catch(err=>{\n            console.error(\"Service worker loader: Error while triggering refresh cache\", err);\n            if(doneCB) {\n                doneCB(\"REFRESH_CACHE Error\");\n            }\n        });\n    };\n\n    // Hoist service worker comm to window for everyone be able to communicate with the sw.\n    window.messageSW = function (params) {\n        return wb.messageSW(params);\n    };\n\n    function serverReady() {\n        console.log('Service worker loader: Server ready.');\n        isServerReady = true;\n        _forceClearCacheIfNeeded();\n        wb.messageSW({\n            type: 'INIT_PHOENIX_CONFIG',\n            debugMode: window.logger.logToConsolePref === 'true',\n            logLivePreview: window.logger.loggingOptions.logLivePreview\n        }).then((config)=>{\n            logger.leaveTrail(\n                `Service worker loader: Server ready! Service worker inited at base url: ${config.baseURL}`);\n        }).catch(err=>{\n            console.error(\"Service worker loader: Error while init of service worker\", err);\n        });\n    }\n\n    function serverInstall() {\n        logger.leaveTrail('Service worker loader: Web server Worker installed.');\n    }\n\n    const showSkipWaitingPrompt = async (event) => {\n        // Assuming the user accepted the update, set up a listener\n        // that will reload the page as soon as the previously waiting\n        // service worker has taken control.\n\n        // When `event.wasWaitingBeforeRegister` is true, a previously\n        // updated service worker is still waiting.\n        // You may want to customize the UI prompt accordingly.\n\n        // This code assumes your app has a promptForUpdate() method,\n        // which returns true if the user wants to update.\n        // Implementing this is app-specific; some examples are:\n        // https://open-ui.org/components/alert.research or\n        // https://open-ui.org/components/toast.research\n        const updateAccepted = await shouldUpdate();\n\n        if (updateAccepted) {\n            wb.messageSkipWaiting();\n        }\n    };\n\n    // Add an event listener to detect when the registered\n    // service worker has installed but is waiting to activate.\n    wb.addEventListener('waiting', (event) => {\n        logger.leaveTrail(\"Service worker loader: A new service worker is pending load. Trying to update worker now.\");\n        window.Phoenix.cache.updatePendingReloadReason = \"skipWait\";\n        showSkipWaitingPrompt(event);\n    });\n\n    wb.controlling.then(serverReady);\n\n    // Deal with first-run install, if necessary\n    wb.addEventListener('installed', (event) => {\n        if(!event.isUpdate) {\n            serverInstall();\n        }\n    });\n\n    wb.register();\n}\n"],"file":"virtual-server-loader.js"}
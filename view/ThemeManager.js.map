{"version":3,"sources":["view/ThemeManager.js"],"names":["define","require","exports","module","_","EventDispatcher","FileSystem","FileUtils","EditorManager","DocumentManager","ExtensionUtils","ThemeSettings","ThemeView","PreferencesManager","UrlParams","prefs","getExtensionPrefs","loadedThemes","currentTheme","styleNode","$","addEmbeddedStyleSheet","commentRegex","scrollbarsRegex","stylesPath","getNativeBracketsDirectoryPath","EVENT_THEME_CHANGE","toDisplayName","name","extIndex","lastIndexOf","substring","undefined","replace","split","map","part","toUpperCase","join","Theme","file","options","fileName","title","getFilenameWithoutExtension","toLocaleLowerCase","this","displayName","dark","theme","addModeClass","extractScrollbars","content","scrollbar","match","push","fixPath","path","lessifyTheme","deferred","Deferred","less","render","rootpath","filename","_path","err","tree","reject","resolve","css","promise","getThemeByFile","find","item","currentTrackingDoc","_trackLivePreviewDevThemeFile","themeFilePath","devTheme","getDocumentForPath","done","doc","off","on","_applyThemeCSS","getText","fail","console","error","_getCurrentlyLoadedDevTheme","params","parse","devThemePaths","get","themeID","Object","keys","fullPath","devThemePath","startsWith","getCurrentTheme","defaultTheme","isOSInDarkTheme","DEFAULTS","darkTheme","lightTheme","EVENT_ACTIVE_EDITOR_CHANGED","getAllThemes","async","lessContent","window","jsPromise","result","cssContent","toggleClass","text","loadCurrentTheme","pending","readAsText","then","catch","when","refresh","force","editor","getActiveEditor","_codeMirror","cm","updateThemes","setOption","_loadThemeFromFile","_setThemes","_copyPackageJson","packageURL","destPackageFilePath","Promise","getFileForPath","exists","packageContent","writeText","JSON","stringify","_loadFileFromURL","url","themeName","themeFolder","brackets","app","getApplicationSupportDirectory","packagePath","normalize","themePath","folder","getDirectoryForPath","themeContent","create","finally","loadFile","Phoenix","VFS","getPathForVirtualServingURL","loadPackage","themePackage","metadata","matchMedia","matches","setCurrentTheme","themeIDs","includes","set","addListener","e","log","trigger","updateScrollbars","evt","isDirectory","makeEventDispatcher","_toDisplayName","_extractScrollbars"],"mappings":"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","sourcesContent":["/**\n * Brackets Themes Copyright (c) 2014 Miguel Castillo.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*jslint regexp: true */\n/*global less, path, Phoenix */\n\ndefine(function (require, exports, module) {\n\n\n    const _                  = require(\"thirdparty/lodash\"),\n        EventDispatcher    = require(\"utils/EventDispatcher\"),\n        FileSystem         = require(\"filesystem/FileSystem\"),\n        FileUtils          = require(\"file/FileUtils\"),\n        EditorManager      = require(\"editor/EditorManager\"),\n        DocumentManager    = require(\"document/DocumentManager\"),\n        ExtensionUtils     = require(\"utils/ExtensionUtils\"),\n        ThemeSettings      = require(\"view/ThemeSettings\"),\n        ThemeView          = require(\"view/ThemeView\"),\n        PreferencesManager = require(\"preferences/PreferencesManager\"),\n        UrlParams          = require(\"utils/UrlParams\").UrlParams,\n        prefs              = PreferencesManager.getExtensionPrefs(\"themes\");\n\n    let loadedThemes    = {},\n        currentTheme    = null,\n        styleNode       = $(ExtensionUtils.addEmbeddedStyleSheet(\"\")),\n        commentRegex    = /\\/\\*([\\s\\S]*?)\\*\\//mg,\n        scrollbarsRegex = /((?:[^}|,]*)::-webkit-scrollbar(?:[^{]*)[{](?:[^}]*?)[}])/mgi,\n        stylesPath      = FileUtils.getNativeBracketsDirectoryPath() + \"/styles/\";\n\n    const EVENT_THEME_CHANGE = \"themeChange\";\n\n    /**\n     * @private\n     * Takes all dashes and converts them to white spaces. Then takes all first letters\n     * and capitalizes them.\n     *\n     * @param {string} name is what needs to be procseed to generate a display name\n     * @return {string} theme name properly formatted for display\n     */\n    function toDisplayName(name) {\n        var extIndex = name.lastIndexOf('.');\n        name = name.substring(0, extIndex !== -1 ? extIndex : undefined).replace(/-/g, ' ');\n\n        return name.split(\" \").map(function (part) {\n            return part[0].toUpperCase() + part.substring(1);\n        }).join(\" \");\n    }\n\n\n    /**\n     * @constructor\n     * Theme contains all the essential bit to load a theme from disk, display a theme in the settings\n     * dialog, and to properly add a theme into CodeMirror along with the rest of brackets.\n     *\n     * @param {File} file for the theme\n     * @param {{name: string, title: string}} options to configure different\n     *   properties in the theme\n     */\n    function Theme(file, options) {\n        options = options || {};\n        var fileName = file.name;\n\n        // If no options.name is provided, then we derive the name of the theme from whichever we find\n        // first, the options.title or the filename.\n        if (!options.name) {\n            if (options.title) {\n                options.name = options.title;\n            } else {\n                // Remove the file extension when the filename is used as the theme name. This is to\n                // follow CodeMirror conventions where themes are just a CSS file and the filename\n                // (without the extension) is used to build CSS rules.  Also handle removing .min\n                // in case the \".min\" is part of the file name.\n                options.name = FileUtils.getFilenameWithoutExtension(fileName).replace(/\\.min$/, \"\");\n            }\n\n            // We do a bit of string treatment here to make sure we generate theme names that can be\n            // used as a CSS class name by CodeMirror.\n            options.name = options.name.toLocaleLowerCase().replace(/[\\W]/g, '-');\n        }\n\n        this.file           = file;\n        this.name           = options.name;\n        this.displayName    = options.title || toDisplayName(fileName);\n        this.dark           = options.theme !== undefined && options.theme.dark === true;\n        this.addModeClass   = options.theme !== undefined && options.theme.addModeClass === true;\n    }\n\n\n    /**\n     * @private\n     * Extracts the scrollbar text from the css/less content so that it can be treated\n     * as a separate styling component that can be anabled/disabled independently from\n     * the theme.\n     *\n     * @param {string} content is the css/less input string to be processed\n     * @return {{content: string, scrollbar: Array.<string>}} content is the new css/less content\n     *   with the scrollbar rules extracted out and put in scrollbar\n     */\n    function extractScrollbars(content) {\n        var scrollbar = [];\n\n        // Go through and extract out scrollbar customizations so that we can\n        // enable/disable via settings.\n        content = content\n            .replace(scrollbarsRegex, function (match) {\n                scrollbar.push(match);\n                return \"\";\n            });\n\n        return {\n            content: content,\n            scrollbar: scrollbar\n        };\n    }\n\n\n    /**\n     * @private\n     * Function will process a string and figure out if it looks like window path with a\n     * a drive.  If that's the case, then we lower case everything.\n     * --- NOTE: There is a bug in less that only checks for lowercase in order to handle\n     * the rootPath configuration...  Hopefully a PR will be coming their way soon.\n     *\n     * @param {string} path is a string to search for drive letters that need to be converted\n     *   to lower case.\n     *\n     * @return {string} Windows Drive letter in lowercase.\n     */\n    function fixPath(path) {\n        return path.replace(/^([A-Z]+:)?\\//, function (match) {\n            return match.toLocaleLowerCase();\n        });\n    }\n\n\n    /**\n     * @private\n     * Takes the content of a file and feeds it through the less processor in order\n     * to provide support for less files.\n     *\n     * @param {string} content is the css/less string to be processed\n     * @param {Theme} theme is the object the css/less corresponds to\n     * @return {$.Promise} promise with the processed css/less as the resolved value\n     */\n    function lessifyTheme(content, theme) {\n        var deferred = new $.Deferred();\n\n        less.render(\"#Phoenix-Main {\" + content + \"\\n}\", {\n            rootpath: fixPath(stylesPath),\n            filename: fixPath(theme.file._path)\n        }, function (err, tree) {\n            if (err) {\n                deferred.reject(err);\n            } else {\n                deferred.resolve(tree.css);\n            }\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * @private\n     * Will search all loaded themes for one the matches the file passed in\n     *\n     * @param {File} file is the search criteria\n     * @return {Theme} theme that matches the file\n     */\n    function getThemeByFile(file) {\n        var path = file._path;\n        return _.find(loadedThemes, function (item) {\n            return item.file._path === path;\n        });\n    }\n\n\n    let currentTrackingDoc;\n    function _trackLivePreviewDevThemeFile(themeFilePath, devTheme) {\n        DocumentManager.getDocumentForPath(themeFilePath).done(doc =>{\n            if(currentTrackingDoc){\n                currentTrackingDoc.off(\"change.ThemeManager\");\n            }\n            currentTrackingDoc = doc;\n            doc.on(\"change.ThemeManager\", ()=>{\n                _applyThemeCSS(doc.getText(), devTheme);\n            });\n        }).fail(console.error);\n    }\n\n    /**\n     * Extension developers can load their custom themes using debug menu> load project as extension. in this case\n     * a query strin param will ge specified with the dev extension path. we will always load that theme as default\n     * as th user intent would be to develop the theme in that case.\n     * @return {null|*}\n     * @private\n     */\n    function _getCurrentlyLoadedDevTheme() {\n        const params  = new UrlParams();\n        params.parse();\n        let devThemePaths = params.get(\"loadDevExtensionPath\");\n        if(!devThemePaths){\n            return null;\n        }\n        devThemePaths = devThemePaths.split(\",\"); // paths are a comma seperated list\n        for(let themeID of Object.keys(loadedThemes)){\n            let themeFilePath = loadedThemes[themeID].file.fullPath;\n            for(let devThemePath of devThemePaths){\n                if(themeFilePath.startsWith(devThemePath)){\n                    return loadedThemes[themeID];\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get current theme object that is loaded in the editor.\n     *\n     * @return {Theme} the current theme instance\n     */\n    function getCurrentTheme() {\n        let defaultTheme = isOSInDarkTheme() ?\n            ThemeSettings.DEFAULTS.darkTheme:\n            ThemeSettings.DEFAULTS.lightTheme;\n        // check if a dev theme is loaded via query string parameter. If so that will be the current theme.\n        let devTheme = _getCurrentlyLoadedDevTheme();\n        if(devTheme){\n            currentTheme = devTheme;\n        } else if (!currentTheme) {\n            currentTheme = loadedThemes[prefs.get(\"theme\")] || loadedThemes[defaultTheme];\n        }\n\n        if(currentTheme){\n            _trackLivePreviewDevThemeFile(currentTheme.file.fullPath, currentTheme);\n            EditorManager.off(EditorManager.EVENT_ACTIVE_EDITOR_CHANGED + \".ThemeManager\");\n            EditorManager.on(EditorManager.EVENT_ACTIVE_EDITOR_CHANGED + \".ThemeManager\", ()=>{\n                _trackLivePreviewDevThemeFile(currentTheme.file.fullPath, currentTheme);\n            });\n        }\n        return currentTheme;\n    }\n\n\n    /**\n     * Gets all available themes\n     * @return {Array.<Theme>} collection of all available themes\n     */\n    function getAllThemes() {\n        return _.map(loadedThemes, function (theme) {\n            return theme;\n        });\n    }\n\n\n    async function _applyThemeCSS(lessContent, theme) {\n        const content =  await window.jsPromise(lessifyTheme(lessContent.replace(commentRegex, \"\"), theme));\n        const result = extractScrollbars(content);\n        theme.scrollbar = result.scrollbar;\n        const cssContent = result.content;\n        $(\"body\").toggleClass(\"dark\", theme.dark);\n        styleNode.text(cssContent);\n    }\n\n    /**\n     * @private\n     * Process and load the current theme into the editor\n     *\n     * @return {$.Promise} promise object resolved with the theme object and all\n     *    corresponding new css/less and scrollbar information\n     */\n    function loadCurrentTheme() {\n        var theme = getCurrentTheme();\n\n        var pending = theme && FileUtils.readAsText(theme.file)\n            .then(function (lessContent) {\n                const deferred = new $.Deferred();\n                _applyThemeCSS(lessContent, theme)\n                    .then(deferred.resolve)\n                    .catch(deferred.reject);\n            });\n\n        return $.when(pending);\n    }\n\n\n    /**\n     * Refresh current theme in the editor\n     *\n     * @param {boolean} force Forces a reload of the current theme.  It reloads the theme file.\n     */\n    function refresh(force) {\n        if (force) {\n            currentTheme = null;\n        }\n\n        $.when(force && loadCurrentTheme()).done(function () {\n            var editor = EditorManager.getActiveEditor();\n            if (!editor || !editor._codeMirror) {\n                return;\n            }\n\n            var cm = editor._codeMirror;\n            ThemeView.updateThemes(cm);\n\n            // currentTheme can be undefined, so watch out\n            cm.setOption(\"addModeClass\", !!(currentTheme && currentTheme.addModeClass));\n        });\n    }\n\n    /**\n     *\n     * @param file FileSystem.getFileForPath object\n     * @param options\n     * @private\n     */\n    function _loadThemeFromFile(file, options) {\n        let theme = new Theme(file, options);\n        loadedThemes[theme.name] = theme;\n        ThemeSettings._setThemes(loadedThemes);\n\n        if (getCurrentTheme() && getCurrentTheme().name === theme.name) {\n            refresh(true);\n        }\n        return theme;\n    }\n\n    function _copyPackageJson(packageURL, destPackageFilePath) {\n        return new Promise((resolve, reject)=>{\n            const file = FileSystem.getFileForPath(destPackageFilePath);\n            file.exists(function (err, exists) {\n                if(err){\n                    reject();\n                    return;\n                }\n                if (!exists) {\n                    $.get(packageURL).done(function (packageContent) {\n                        FileUtils.writeText(file, JSON.stringify(packageContent), true).done(function () {\n                            resolve();\n                        }).fail(function (err) {\n                            reject(err);\n                        });\n                    }).fail(function (err) {\n                        reject(err);\n                    });\n                    return;\n                }\n                resolve();\n            });\n        });\n    }\n\n    /**\n     * Loads a theme from a url.\n     *\n     * @param {string} url is the full http/https url of the theme file\n     * @param {Object} options is an optional parameter to specify metadata\n     *    for the theme.\n     * @return {$.Promise} promise object resolved with the theme to be loaded from fileName\n     */\n    function _loadFileFromURL(url, options) {\n        let deferred         = new $.Deferred();\n\n        const themeName = options.name || options.theme.title,\n            fileName = options.theme.file || (typeof(options.theme) === 'string'? options.theme: `theme.css`),\n            themeFolder = brackets.app.getApplicationSupportDirectory() + `/extensions/user/${themeName}/`,\n            packageURL = url.substring(0, url.lastIndexOf(\"/\")) + '/package.json',\n            packagePath = path.normalize(themeFolder + 'package.json'),\n            themePath = path.normalize(themeFolder + fileName),\n            file = FileSystem.getFileForPath(themePath),\n            folder = FileSystem.getDirectoryForPath(themeFolder);\n\n        $.get(url).done(function (themeContent) {\n            // Write theme to file\n            folder.create((err)=>{\n                if(err){\n                    console.error(err);\n                    deferred.reject();\n                    return;\n                }\n                FileUtils.writeText(file, themeContent, true).done(function () {\n                    _copyPackageJson(packageURL, packagePath)\n                        .catch(error=>{\n                            console.error(\"Error copying package.json for theme \" + themePath, error);\n                        })\n                        .finally(()=>{\n                            let theme = _loadThemeFromFile(file, options);\n                            deferred.resolve(theme);\n                        });\n                }).fail(function (error) {\n                    console.error(\"Error writing \" + themePath, error);\n                    deferred.reject();\n                });\n            });\n        }).fail(function () {\n            // if offline, try to see if we have the previously saved theme available\n            file.exists(function (err, exists) {\n                if(err){\n                    deferred.reject(err);\n                    return;\n                }\n                if (exists) {\n                    let theme = _loadThemeFromFile(file, options);\n                    deferred.resolve(theme);\n                    return;\n                }\n            });\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * Loads a theme from a file.\n     *\n     * @param {string} fileName is the full path to the file to be opened\n     * @param {Object} options is an optional parameter to specify metadata\n     *    for the theme.\n     * @return {$.Promise} promise object resolved with the theme to be loaded from fileName\n     */\n    function loadFile(fileName, options) {\n        if(fileName.startsWith(\"http://\") || fileName.startsWith(\"https://\")) {\n            if(Phoenix.VFS.getPathForVirtualServingURL(fileName)){\n                fileName = Phoenix.VFS.getPathForVirtualServingURL(fileName);\n            } else {\n                return _loadFileFromURL(fileName, options);\n            }\n        }\n\n        var deferred         = new $.Deferred(),\n            file             = FileSystem.getFileForPath(fileName);\n\n        file.exists(function (err, exists) {\n            var theme;\n\n            if (exists) {\n                theme = new Theme(file, options);\n                loadedThemes[theme.name] = theme;\n                ThemeSettings._setThemes(loadedThemes);\n\n                // For themes that are loaded after ThemeManager has been loaded,\n                // we should check if it's the current theme.  If it is, then we just\n                // load it.\n                if (currentTheme && currentTheme.name === theme.name) {\n                    refresh(true);\n                }\n\n                deferred.resolve(theme);\n            } else if (err || !exists) {\n                deferred.reject(err);\n            }\n        });\n\n        return deferred.promise();\n    }\n\n\n    /**\n     * Loads a theme from an extension package.\n     *\n     * @param {Object} themePackage is a package from the extension manager for the theme to be loaded.\n     * @return {$.Promise} promise object resolved with the theme to be loaded from the pacakge\n     */\n    function loadPackage(themePackage) {\n        var fileName = themePackage.path + \"/\" + themePackage.metadata.theme.file;\n        return loadFile(fileName, themePackage.metadata);\n    }\n\n    /**\n     * Detects if the os settings is set to dark theme or not\n     */\n    function isOSInDarkTheme() {\n        if(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches){\n            return true;\n        }\n    }\n\n    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {\n        // listen to system dark/light theme changes\n        console.log(`System theme changed to ${e.matches ? \"dark\" : \"light\"} mode`);\n        refresh(true);\n\n        // Report os preference change also as a theme change\n        exports.trigger(EVENT_THEME_CHANGE, getCurrentTheme());\n    });\n\n    prefs.on(\"change\", \"theme\", function () {\n        // Make sure we don't reprocess a theme that's already loaded\n        if (currentTheme && currentTheme.name === prefs.get(\"theme\")) {\n            return;\n        }\n\n        // Refresh editor with the new theme\n        refresh(true);\n\n        // Process the scrollbars for the editor\n        ThemeView.updateScrollbars(getCurrentTheme());\n\n        // Expose event for theme changes\n        exports.trigger(EVENT_THEME_CHANGE, getCurrentTheme());\n    });\n\n    prefs.on(\"change\", \"themeScrollbars\", function () {\n        refresh();\n        ThemeView.updateScrollbars(getCurrentTheme());\n    });\n\n    // Monitor file changes.  If the file that has changed is actually the currently loaded\n    // theme, then we just reload the theme.  This allows to live edit the theme\n    FileSystem.on(\"change\", function (evt, file) {\n        if (!file || file.isDirectory) {\n            return;\n        }\n\n        if (getThemeByFile(file)) {\n            refresh(true);\n        }\n    });\n\n    EditorManager.on(\"activeEditorChange\", function () {\n        refresh();\n    });\n\n    /**\n     * Sets the current theme for the given theme id if present.\n     * @param {string} themeID\n     * @return {boolean} true if the theme was applied, else false\n     */\n    function setCurrentTheme(themeID) {\n        let themeIDs = [];\n        for(let theme of getAllThemes()){\n            themeIDs.push(theme.name);\n        }\n        if(themeIDs.includes(themeID)){\n            prefs.set(\"theme\", themeID);\n            return true;\n        }\n        console.error(\"Cannot set theme that doesnt exist: \", themeID);\n        return false;\n    }\n\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    exports.refresh         = refresh;\n    exports.loadFile        = loadFile;\n    exports.loadPackage     = loadPackage;\n    exports.getCurrentTheme = getCurrentTheme;\n    exports.getAllThemes    = getAllThemes;\n    exports.isOSInDarkTheme = isOSInDarkTheme;\n    exports.setCurrentTheme = setCurrentTheme;\n    exports.EVENT_THEME_CHANGE = EVENT_THEME_CHANGE;\n\n    // Exposed for testing purposes\n    exports._toDisplayName     = toDisplayName;\n    exports._extractScrollbars = extractScrollbars;\n});\n"],"file":"ThemeManager.js"}
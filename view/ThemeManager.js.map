{"version":3,"sources":["view/ThemeManager.js"],"names":["define","require","exports","module","_","EventDispatcher","FileSystem","FileUtils","EditorManager","DocumentManager","ExtensionUtils","ExtensionLoader","ThemeSettings","ThemeView","PreferencesManager","UrlParams","prefs","getExtensionPrefs","loadedThemes","currentTheme","styleNode","$","addEmbeddedStyleSheet","commentRegex","scrollbarsRegex","stylesPath","getNativeBracketsDirectoryPath","EVENT_THEME_CHANGE","EVENT_THEME_LOADED","toDisplayName","name","extIndex","lastIndexOf","substring","undefined","replace","split","map","part","toUpperCase","join","Theme","file","options","fileName","title","getFilenameWithoutExtension","toLocaleLowerCase","this","displayName","dark","theme","addModeClass","extractScrollbars","content","scrollbar","match","push","fixPath","path","lessifyTheme","deferred","Deferred","less","render","rootpath","filename","_path","err","tree","reject","resolve","css","promise","getThemeByFile","find","item","currentTrackingDoc","_trackLivePreviewDevThemeFile","themeFilePath","devTheme","getDocumentForPath","getSourcePathForExtension","done","doc","off","on","_applyThemeCSS","getText","fail","console","error","_getCurrentlyLoadedDevTheme","params","parse","devThemePaths","get","themeID","Object","keys","fullPath","devThemePath","startsWith","getCurrentTheme","defaultTheme","isOSInDarkTheme","DEFAULTS","darkTheme","lightTheme","EVENT_ACTIVE_EDITOR_CHANGED","getAllThemes","async","lessContent","window","jsPromise","result","cssContent","toggleClass","text","loadCurrentTheme","pending","readAsText","then","catch","when","refresh","force","editor","getActiveEditor","_codeMirror","cm","updateThemes","setOption","_loadThemeFromFile","_setThemes","trigger","_copyPackageJson","packageURL","destPackageFilePath","Promise","getFileForPath","exists","packageContent","writeText","JSON","stringify","_loadFileFromURL","url","themeName","themeFolder","__TAURI__","brackets","app","getApplicationSupportDirectory","packagePath","normalize","themePath","folder","getDirectoryForPath","themeContent","create","finally","loadFile","Phoenix","VFS","getPathForVirtualServingURL","loadPackage","themePackage","metadata","matchMedia","matches","setCurrentTheme","themeIDs","includes","set","addListener","e","log","updateScrollbars","evt","isDirectory","makeEventDispatcher","_toDisplayName","_extractScrollbars"],"mappings":"AA0BAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,MAAMC,EAAqBH,QAAQ,qBAC/BI,gBAAqBJ,QAAQ,yBAC7BK,WAAqBL,QAAQ,yBAC7BM,UAAqBN,QAAQ,kBAC7BO,cAAqBP,QAAQ,wBAC7BQ,gBAAqBR,QAAQ,4BAC7BS,eAAqBT,QAAQ,wBAC7BU,gBAAqBV,QAAQ,yBAC7BW,cAAqBX,QAAQ,sBAC7BY,UAAqBZ,QAAQ,kBAC7Ba,mBAAqBb,QAAQ,kCAC7Bc,UAAqBd,QAAQ,mBAAmBc,UAChDC,MAAqBF,mBAAmBG,kBAAkB,UAE9D,IAAIC,aAAkB,GAClBC,aAAkB,KAClBC,UAAkBC,EAAEX,eAAeY,sBAAsB,KACzDC,aAAkB,uBAClBC,gBAAkB,+DAClBC,WAAkBlB,UAAUmB,iCAAmC,WAEnE,MAAMC,mBAAqB,cACvBC,mBAAqB,cAUzB,SAASC,cAAcC,MACnB,IAAIC,SAAWD,KAAKE,YAAY,KAGhC,OAFAF,KAAOA,KAAKG,UAAU,GAAiB,IAAdF,SAAkBA,cAAWG,GAAWC,QAAQ,KAAM,MAEnEC,MAAM,KAAKC,IAAI,SAAUC,MACjC,OAAOA,KAAK,GAAGC,cAAgBD,KAAKL,UAAU,KAC/CO,KAAK,KAaZ,SAASC,MAAMC,KAAMC,SACjBA,QAAUA,SAAW,GACrB,IAAIC,SAAWF,KAAKZ,KAIfa,QAAQb,OACLa,QAAQE,MACRF,QAAQb,KAAOa,QAAQE,MAMvBF,QAAQb,KAAOvB,UAAUuC,4BAA4BF,UAAUT,QAAQ,SAAU,IAKrFQ,QAAQb,KAAOa,QAAQb,KAAKiB,oBAAoBZ,QAAQ,QAAS,MAGrEa,KAAKN,KAAiBA,KACtBM,KAAKlB,KAAiBa,QAAQb,KAC9BkB,KAAKC,YAAiBN,QAAQE,OAAShB,cAAce,UACrDI,KAAKE,UAAmChB,IAAlBS,QAAQQ,QAA8C,IAAvBR,QAAQQ,MAAMD,KACnEF,KAAKI,kBAAmClB,IAAlBS,QAAQQ,QAAsD,IAA/BR,QAAQQ,MAAMC,aAcvE,SAASC,kBAAkBC,SACvB,IAAIC,UAAY,GAUhB,MAAO,CACHD,QAPJA,QAAUA,QACLnB,QAAQX,gBAAiB,SAAUgC,OAEhC,OADAD,UAAUE,KAAKD,OACR,KAKXD,UAAWA,WAiBnB,SAASG,QAAQC,MACb,OAAOA,KAAKxB,QAAQ,gBAAiB,SAAUqB,OAC3C,OAAOA,MAAMT,sBAcrB,SAASa,aAAaN,QAASH,OAC3B,IAAIU,SAAW,IAAIxC,EAAEyC,SAarB,OAXAC,KAAKC,OAAO,kBAAoBV,QAAU,MAAO,CAC7CW,SAAUP,QAAQjC,YAClByC,SAAUR,QAAQP,MAAMT,KAAKyB,QAC9B,SAAUC,IAAKC,MACVD,IACAP,SAASS,OAAOF,KAEhBP,SAASU,QAAQF,KAAKG,OAIvBX,SAASY,UAUpB,SAASC,eAAehC,MACpB,IAAIiB,KAAOjB,KAAKyB,MAChB,OAAO/D,EAAEuE,KAAKzD,aAAc,SAAU0D,MAClC,OAAOA,KAAKlC,KAAKyB,QAAUR,OAKnC,IAAIkB,mBACJ,SAASC,8BAA8BC,cAAeC,UAClDvE,gBAAgBwE,mBAAmBtE,gBAAgBuE,0BAA0BH,gBAAgBI,KAAKC,MAC3FP,oBACCA,mBAAmBQ,IAAI,uBAE3BR,mBAAqBO,IACrBA,IAAIE,GAAG,sBAAuB,KAC1BC,eAAeH,IAAII,UAAWR,cAEnCS,KAAKC,QAAQC,OAUpB,SAASC,8BACL,MAAMC,OAAU,IAAI9E,UACpB8E,OAAOC,QACP,IAAIC,cAAgBF,OAAOG,IAAI,wBAC/B,IAAID,cACA,OAAO,KAEXA,cAAgBA,cAAc3D,MAAM,KACpC,IAAI,IAAI6D,WAAWC,OAAOC,KAAKjF,cAAc,CACzC,IAAI6D,cAAgBpE,gBAAgBuE,0BAA0BhE,aAAa+E,SAASvD,KAAK0D,UACzF,IAAI,IAAIC,gBAAgBN,cACpB,GAAGhB,cAAcuB,WAAWD,cACxB,OAAOnF,aAAa+E,SAIhC,OAAO,KAQX,SAASM,kBACL,IAAIC,aAAeC,kBACf7F,cAAc8F,SAASC,UACvB/F,cAAc8F,SAASE,WAEvB5B,SAAWY,8BAcf,OAbGZ,SACC7D,aAAe6D,SACP7D,eACRA,aAAeD,aAAaF,MAAMgF,IAAI,WAAa9E,aAAasF,eAGjErF,eACC2D,8BAA8B3D,aAAauB,KAAK0D,SAAUjF,cAC1DX,cAAc6E,IAAI7E,cAAcqG,4BAA8B,iBAC9DrG,cAAc8E,GAAG9E,cAAcqG,4BAA8B,gBAAiB,KAC1E/B,8BAA8B3D,aAAauB,KAAK0D,SAAUjF,iBAG3DA,aAQX,SAAS2F,eACL,OAAO1G,EAAEiC,IAAInB,aAAc,SAAUiC,OACjC,OAAOA,QAKf4D,eAAexB,eAAeyB,YAAa7D,OACvC,MAAMG,cAAiB2D,OAAOC,UAAUtD,aAAaoD,YAAY7E,QAAQZ,aAAc,IAAK4B,QACtFgE,OAAS9D,kBAAkBC,SACjCH,MAAMI,UAAY4D,OAAO5D,UACzB,MAAM6D,WAAaD,OAAO7D,QAC1BjC,EAAE,QAAQgG,YAAY,OAAQlE,MAAMD,MACpC9B,UAAUkG,KAAKF,YAUnB,SAASG,mBACL,IAAIpE,MAAQoD,kBAERiB,QAAUrE,OAAS5C,UAAUkH,WAAWtE,MAAMT,MAC7CgF,KAAK,SAAUV,aACZ,MAAMnD,SAAW,IAAIxC,EAAEyC,SACvByB,eAAeyB,YAAa7D,OACvBuE,KAAK7D,SAASU,SACdoD,MAAM9D,SAASS,UAG5B,OAAOjD,EAAEuG,KAAKJ,SASlB,SAASK,QAAQC,OACTA,QACA3G,aAAe,MAGnBE,EAAEuG,KAAKE,OAASP,oBAAoBpC,KAAK,WACrC,IAAI4C,OAASvH,cAAcwH,kBAC3B,GAAKD,QAAWA,OAAOE,YAAvB,CAIA,IAAIC,GAAKH,OAAOE,YAChBpH,UAAUsH,aAAaD,IAGvBA,GAAGE,UAAU,kBAAmBjH,eAAgBA,aAAaiC,kBAUrE,SAASiF,mBAAmB3F,KAAMC,SAC9B,IAAIQ,MAAQ,IAAIV,MAAMC,KAAMC,SAQ5B,OAPAzB,aAAaiC,MAAMrB,MAAQqB,MAC3BvC,cAAc0H,WAAWpH,cACzBhB,QAAQqI,QAAQ3G,mBAAoBuB,MAAMrB,MAEtCyE,mBAAqBA,kBAAkBzE,OAASqB,MAAMrB,MACtD+F,SAAQ,GAEL1E,MAGX,SAASqF,iBAAiBC,WAAYC,qBAClC,OAAO,IAAIC,QAAQ,CAACpE,QAASD,UACzB,MAAM5B,KAAOpC,WAAWsI,eAAeF,qBACvChG,KAAKmG,OAAO,SAAUzE,IAAKyE,QACpBzE,IACCE,SAGCuE,OAYLtE,UAXIlD,EAAE2E,IAAIyC,YAAYtD,KAAK,SAAU2D,gBAC7BvI,UAAUwI,UAAUrG,KAAMsG,KAAKC,UAAUH,iBAAiB,GAAM3D,KAAK,WACjEZ,YACDkB,KAAK,SAAUrB,KACdE,OAAOF,SAEZqB,KAAK,SAAUrB,KACdE,OAAOF,WAiB3B,SAAS8E,iBAAiBC,IAAKxG,SAC3B,IAAIkB,SAAmB,IAAIxC,EAAEyC,SAE7B,MAAOsF,UAAYzG,QAAQb,MAAQa,QAAQQ,MAAMN,MAC7CwG,YAAcpC,OAAOqC,UACjBC,SAASC,IAAIC,4DAA8DL,aAC3EG,SAASC,IAAIC,qDAAuDL,aAEtExG,SAAWD,QAAQQ,MAAMT,OAAmC,iBAAnBC,QAAa,MAAgBA,QAAQQ,MAAO,aACvFsF,WAAaU,IAAIlH,UAAU,EAAGkH,IAAInH,YAAY,MAAQ,gBACtD0H,YAAc/F,KAAKgG,UAAUN,YAAc,gBAC3CO,UAAYjG,KAAKgG,UAAUN,YAAczG,UACzCF,KAAOpC,WAAWsI,eAAegB,WACjCC,OAASvJ,WAAWwJ,oBAAoBT,aAuC5C,OArCAhI,EAAE2E,IAAImD,KAAKhE,KAAK,SAAU4E,cAEtBF,OAAOG,OAAQ5F,MACX,GAAGA,IAGC,OAFAsB,QAAQC,MAAMvB,UACdP,SAASS,SAGb/D,UAAUwI,UAAUrG,KAAMqH,cAAc,GAAM5E,KAAK,WAC/CqD,iBAAiBC,WAAYiB,aACxB/B,MAAMhC,QACHD,QAAQC,MAAM,wCAA0CiE,UAAWjE,SAEtEsE,QAAQ,KACL,IAAI9G,MAAQkF,mBAAmB3F,KAAMC,SACrCkB,SAASU,QAAQpB,WAE1BsC,KAAK,SAAUE,OACdD,QAAQC,MAAM,iBAAmBiE,UAAWjE,OAC5C9B,SAASS,eAGlBmB,KAAK,WAEJ/C,KAAKmG,OAAO,SAAUzE,IAAKyE,QACvB,GAAGzE,IACCP,SAASS,OAAOF,UAGpB,GAAIyE,OAAJ,CACI,IAAI1F,MAAQkF,mBAAmB3F,KAAMC,SACrCkB,SAASU,QAAQpB,iBAMtBU,SAASY,UAWpB,SAASyF,SAAStH,SAAUD,SACxB,GAAGC,SAAS0D,WAAW,YAAc1D,SAAS0D,WAAW,aAClD1D,SAAS0D,WAAW,eAAiB1D,SAAS0D,WAAW,YAAa,CACzE,IAAG6D,QAAQC,IAAIC,4BAA4BzH,UAGvC,OAAOsG,iBAAiBtG,SAAUD,SAFlCC,SAAWuH,QAAQC,IAAIC,4BAA4BzH,UAM3D,IAAIiB,SAAmB,IAAIxC,EAAEyC,SACzBpB,KAAmBpC,WAAWsI,eAAehG,UAwBjD,OAtBAF,KAAKmG,OAAO,SAAUzE,IAAKyE,QACvB,IAAI1F,MAEA0F,QACA1F,MAAQ,IAAIV,MAAMC,KAAMC,SACxBzB,aAAaiC,MAAMrB,MAAQqB,MAC3BvC,cAAc0H,WAAWpH,cACzBhB,QAAQqI,QAAQ3G,mBAAoBuB,MAAMrB,MAKtCX,cAAgBA,aAAaW,OAASqB,MAAMrB,MAC5C+F,SAAQ,GAGZhE,SAASU,QAAQpB,SACViB,KAAQyE,QACfhF,SAASS,OAAOF,OAIjBP,SAASY,UAUpB,SAAS6F,YAAYC,cACjB,IAAI3H,SACJ,OAAOsH,SADQK,aAAa5G,KAAO,IAAM4G,aAAaC,SAASrH,MAAMT,KAC3C6H,aAAaC,UAM3C,SAAS/D,kBACL,GAAGQ,OAAOwD,YAAcxD,OAAOwD,WAAW,gCAAgCC,QACtE,OAAO,EAuDf,SAASC,gBAAgB1E,SACrB,IAAI2E,SAAW,GACf,IAAI,IAAIzH,SAAS2D,eACb8D,SAASnH,KAAKN,MAAMrB,MAExB,OAAG8I,SAASC,SAAS5E,UACjBjF,MAAM8J,IAAI,QAAS7E,UACZ,IAEXP,QAAQC,MAAM,uCAAwCM,UAC/C,GA7DXgB,OAAOwD,WAAW,gCAAgCM,YAAY,SAAUC,GAEpEtF,QAAQuF,+BAA+BD,EAAEN,QAAU,OAAS,gBAC5D7C,SAAQ,GAGR3H,QAAQqI,QA5ce,cA4cahC,qBAGxCvF,MAAMsE,GAAG,SAAU,QAAS,WAEpBnE,cAAgBA,aAAaW,OAASd,MAAMgF,IAAI,WAKpD6B,SAAQ,GAGRhH,UAAUqK,iBAAiB3E,mBAG3BrG,QAAQqI,QA5de,cA4dahC,sBAGxCvF,MAAMsE,GAAG,SAAU,kBAAmB,WAClCuC,UACAhH,UAAUqK,iBAAiB3E,qBAK/BjG,WAAWgF,GAAG,SAAU,SAAU6F,IAAKzI,MAC9BA,OAAQA,KAAK0I,aAId1G,eAAehC,OACfmF,SAAQ,KAIhBrH,cAAc8E,GAAG,qBAAsB,WACnCuC,YAsBJxH,gBAAgBgL,oBAAoBnL,SAEpCA,QAAQ2H,QAAkBA,QAC1B3H,QAAQgK,SAAkBA,SAC1BhK,QAAQoK,YAAkBA,YAC1BpK,QAAQqG,gBAAkBA,gBAC1BrG,QAAQ4G,aAAkBA,aAC1B5G,QAAQuG,gBAAkBA,gBAC1BvG,QAAQyK,gBAAkBA,gBAC1BzK,QAAQyB,mBAhhBmB,cAihB3BzB,QAAQ0B,mBAAqBA,mBAG7B1B,QAAQoL,eAAqBzJ,cAC7B3B,QAAQqL,mBAAqBlI","sourcesContent":["/**\n * Brackets Themes Copyright (c) 2014 Miguel Castillo.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*jslint regexp: true */\n/*global less, path, Phoenix */\n\ndefine(function (require, exports, module) {\n\n\n    const _                  = require(\"thirdparty/lodash\"),\n        EventDispatcher    = require(\"utils/EventDispatcher\"),\n        FileSystem         = require(\"filesystem/FileSystem\"),\n        FileUtils          = require(\"file/FileUtils\"),\n        EditorManager      = require(\"editor/EditorManager\"),\n        DocumentManager    = require(\"document/DocumentManager\"),\n        ExtensionUtils     = require(\"utils/ExtensionUtils\"),\n        ExtensionLoader    = require(\"utils/ExtensionLoader\"),\n        ThemeSettings      = require(\"view/ThemeSettings\"),\n        ThemeView          = require(\"view/ThemeView\"),\n        PreferencesManager = require(\"preferences/PreferencesManager\"),\n        UrlParams          = require(\"utils/UrlParams\").UrlParams,\n        prefs              = PreferencesManager.getExtensionPrefs(\"themes\");\n\n    let loadedThemes    = {},\n        currentTheme    = null,\n        styleNode       = $(ExtensionUtils.addEmbeddedStyleSheet(\"\")),\n        commentRegex    = /\\/\\*([\\s\\S]*?)\\*\\//mg,\n        scrollbarsRegex = /((?:[^}|,]*)::-webkit-scrollbar(?:[^{]*)[{](?:[^}]*?)[}])/mgi,\n        stylesPath      = FileUtils.getNativeBracketsDirectoryPath() + \"/styles/\";\n\n    const EVENT_THEME_CHANGE = \"themeChange\",\n        EVENT_THEME_LOADED = \"themeLoaded\";\n\n    /**\n     * @private\n     * Takes all dashes and converts them to white spaces. Then takes all first letters\n     * and capitalizes them.\n     *\n     * @param {string} name is what needs to be procseed to generate a display name\n     * @return {string} theme name properly formatted for display\n     */\n    function toDisplayName(name) {\n        var extIndex = name.lastIndexOf('.');\n        name = name.substring(0, extIndex !== -1 ? extIndex : undefined).replace(/-/g, ' ');\n\n        return name.split(\" \").map(function (part) {\n            return part[0].toUpperCase() + part.substring(1);\n        }).join(\" \");\n    }\n\n\n    /**\n     * @constructor\n     * Theme contains all the essential bit to load a theme from disk, display a theme in the settings\n     * dialog, and to properly add a theme into CodeMirror along with the rest of brackets.\n     *\n     * @param {File} file for the theme\n     * @param {{name: string, title: string}} options to configure different\n     *   properties in the theme\n     */\n    function Theme(file, options) {\n        options = options || {};\n        var fileName = file.name;\n\n        // If no options.name is provided, then we derive the name of the theme from whichever we find\n        // first, the options.title or the filename.\n        if (!options.name) {\n            if (options.title) {\n                options.name = options.title;\n            } else {\n                // Remove the file extension when the filename is used as the theme name. This is to\n                // follow CodeMirror conventions where themes are just a CSS file and the filename\n                // (without the extension) is used to build CSS rules.  Also handle removing .min\n                // in case the \".min\" is part of the file name.\n                options.name = FileUtils.getFilenameWithoutExtension(fileName).replace(/\\.min$/, \"\");\n            }\n\n            // We do a bit of string treatment here to make sure we generate theme names that can be\n            // used as a CSS class name by CodeMirror.\n            options.name = options.name.toLocaleLowerCase().replace(/[\\W]/g, '-');\n        }\n\n        this.file           = file;\n        this.name           = options.name;\n        this.displayName    = options.title || toDisplayName(fileName);\n        this.dark           = options.theme !== undefined && options.theme.dark === true;\n        this.addModeClass   = options.theme !== undefined && options.theme.addModeClass === true;\n    }\n\n\n    /**\n     * @private\n     * Extracts the scrollbar text from the css/less content so that it can be treated\n     * as a separate styling component that can be anabled/disabled independently from\n     * the theme.\n     *\n     * @param {string} content is the css/less input string to be processed\n     * @return {{content: string, scrollbar: Array.<string>}} content is the new css/less content\n     *   with the scrollbar rules extracted out and put in scrollbar\n     */\n    function extractScrollbars(content) {\n        var scrollbar = [];\n\n        // Go through and extract out scrollbar customizations so that we can\n        // enable/disable via settings.\n        content = content\n            .replace(scrollbarsRegex, function (match) {\n                scrollbar.push(match);\n                return \"\";\n            });\n\n        return {\n            content: content,\n            scrollbar: scrollbar\n        };\n    }\n\n\n    /**\n     * @private\n     * Function will process a string and figure out if it looks like window path with a\n     * a drive.  If that's the case, then we lower case everything.\n     * --- NOTE: There is a bug in less that only checks for lowercase in order to handle\n     * the rootPath configuration...  Hopefully a PR will be coming their way soon.\n     *\n     * @param {string} path is a string to search for drive letters that need to be converted\n     *   to lower case.\n     *\n     * @return {string} Windows Drive letter in lowercase.\n     */\n    function fixPath(path) {\n        return path.replace(/^([A-Z]+:)?\\//, function (match) {\n            return match.toLocaleLowerCase();\n        });\n    }\n\n\n    /**\n     * @private\n     * Takes the content of a file and feeds it through the less processor in order\n     * to provide support for less files.\n     *\n     * @param {string} content is the css/less string to be processed\n     * @param {Theme} theme is the object the css/less corresponds to\n     * @return {$.Promise} promise with the processed css/less as the resolved value\n     */\n    function lessifyTheme(content, theme) {\n        var deferred = new $.Deferred();\n\n        less.render(\"#Phoenix-Main {\" + content + \"\\n}\", {\n            rootpath: fixPath(stylesPath),\n            filename: fixPath(theme.file._path)\n        }, function (err, tree) {\n            if (err) {\n                deferred.reject(err);\n            } else {\n                deferred.resolve(tree.css);\n            }\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * @private\n     * Will search all loaded themes for one the matches the file passed in\n     *\n     * @param {File} file is the search criteria\n     * @return {Theme} theme that matches the file\n     */\n    function getThemeByFile(file) {\n        var path = file._path;\n        return _.find(loadedThemes, function (item) {\n            return item.file._path === path;\n        });\n    }\n\n\n    let currentTrackingDoc;\n    function _trackLivePreviewDevThemeFile(themeFilePath, devTheme) {\n        DocumentManager.getDocumentForPath(ExtensionLoader.getSourcePathForExtension(themeFilePath)).done(doc =>{\n            if(currentTrackingDoc){\n                currentTrackingDoc.off(\"change.ThemeManager\");\n            }\n            currentTrackingDoc = doc;\n            doc.on(\"change.ThemeManager\", ()=>{\n                _applyThemeCSS(doc.getText(), devTheme);\n            });\n        }).fail(console.error);\n    }\n\n    /**\n     * Extension developers can load their custom themes using debug menu> load project as extension. in this case\n     * a query strin param will ge specified with the dev extension path. we will always load that theme as default\n     * as th user intent would be to develop the theme in that case.\n     * @return {null|*}\n     * @private\n     */\n    function _getCurrentlyLoadedDevTheme() {\n        const params  = new UrlParams();\n        params.parse();\n        let devThemePaths = params.get(\"loadDevExtensionPath\");\n        if(!devThemePaths){\n            return null;\n        }\n        devThemePaths = devThemePaths.split(\",\"); // paths are a comma seperated list\n        for(let themeID of Object.keys(loadedThemes)){\n            let themeFilePath = ExtensionLoader.getSourcePathForExtension(loadedThemes[themeID].file.fullPath);\n            for(let devThemePath of devThemePaths){\n                if(themeFilePath.startsWith(devThemePath)){\n                    return loadedThemes[themeID];\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get current theme object that is loaded in the editor.\n     *\n     * @return {Theme} the current theme instance\n     */\n    function getCurrentTheme() {\n        let defaultTheme = isOSInDarkTheme() ?\n            ThemeSettings.DEFAULTS.darkTheme:\n            ThemeSettings.DEFAULTS.lightTheme;\n        // check if a dev theme is loaded via query string parameter. If so that will be the current theme.\n        let devTheme = _getCurrentlyLoadedDevTheme();\n        if(devTheme){\n            currentTheme = devTheme;\n        } else if (!currentTheme) {\n            currentTheme = loadedThemes[prefs.get(\"theme\")] || loadedThemes[defaultTheme];\n        }\n\n        if(currentTheme){\n            _trackLivePreviewDevThemeFile(currentTheme.file.fullPath, currentTheme);\n            EditorManager.off(EditorManager.EVENT_ACTIVE_EDITOR_CHANGED + \".ThemeManager\");\n            EditorManager.on(EditorManager.EVENT_ACTIVE_EDITOR_CHANGED + \".ThemeManager\", ()=>{\n                _trackLivePreviewDevThemeFile(currentTheme.file.fullPath, currentTheme);\n            });\n        }\n        return currentTheme;\n    }\n\n\n    /**\n     * Gets all available themes\n     * @return {Array.<Theme>} collection of all available themes\n     */\n    function getAllThemes() {\n        return _.map(loadedThemes, function (theme) {\n            return theme;\n        });\n    }\n\n\n    async function _applyThemeCSS(lessContent, theme) {\n        const content =  await window.jsPromise(lessifyTheme(lessContent.replace(commentRegex, \"\"), theme));\n        const result = extractScrollbars(content);\n        theme.scrollbar = result.scrollbar;\n        const cssContent = result.content;\n        $(\"body\").toggleClass(\"dark\", theme.dark);\n        styleNode.text(cssContent);\n    }\n\n    /**\n     * @private\n     * Process and load the current theme into the editor\n     *\n     * @return {$.Promise} promise object resolved with the theme object and all\n     *    corresponding new css/less and scrollbar information\n     */\n    function loadCurrentTheme() {\n        var theme = getCurrentTheme();\n\n        var pending = theme && FileUtils.readAsText(theme.file)\n            .then(function (lessContent) {\n                const deferred = new $.Deferred();\n                _applyThemeCSS(lessContent, theme)\n                    .then(deferred.resolve)\n                    .catch(deferred.reject);\n            });\n\n        return $.when(pending);\n    }\n\n\n    /**\n     * Refresh current theme in the editor\n     *\n     * @param {boolean} force Forces a reload of the current theme.  It reloads the theme file.\n     */\n    function refresh(force) {\n        if (force) {\n            currentTheme = null;\n        }\n\n        $.when(force && loadCurrentTheme()).done(function () {\n            var editor = EditorManager.getActiveEditor();\n            if (!editor || !editor._codeMirror) {\n                return;\n            }\n\n            var cm = editor._codeMirror;\n            ThemeView.updateThemes(cm);\n\n            // currentTheme can be undefined, so watch out\n            cm.setOption(\"addModeClass\", !!(currentTheme && currentTheme.addModeClass));\n        });\n    }\n\n    /**\n     *\n     * @param file FileSystem.getFileForPath object\n     * @param options\n     * @private\n     */\n    function _loadThemeFromFile(file, options) {\n        let theme = new Theme(file, options);\n        loadedThemes[theme.name] = theme;\n        ThemeSettings._setThemes(loadedThemes);\n        exports.trigger(EVENT_THEME_LOADED, theme.name);\n\n        if (getCurrentTheme() && getCurrentTheme().name === theme.name) {\n            refresh(true);\n        }\n        return theme;\n    }\n\n    function _copyPackageJson(packageURL, destPackageFilePath) {\n        return new Promise((resolve, reject)=>{\n            const file = FileSystem.getFileForPath(destPackageFilePath);\n            file.exists(function (err, exists) {\n                if(err){\n                    reject();\n                    return;\n                }\n                if (!exists) {\n                    $.get(packageURL).done(function (packageContent) {\n                        FileUtils.writeText(file, JSON.stringify(packageContent), true).done(function () {\n                            resolve();\n                        }).fail(function (err) {\n                            reject(err);\n                        });\n                    }).fail(function (err) {\n                        reject(err);\n                    });\n                    return;\n                }\n                resolve();\n            });\n        });\n    }\n\n    /**\n     * Loads a theme from a url.\n     *\n     * @param {string} url is the full http/https url of the theme file\n     * @param {Object} options is an optional parameter to specify metadata\n     *    for the theme.\n     * @return {$.Promise} promise object resolved with the theme to be loaded from fileName\n     */\n    function _loadFileFromURL(url, options) {\n        let deferred         = new $.Deferred();\n\n        const  themeName = options.name || options.theme.title,\n            themeFolder = window.__TAURI__ ?\n                brackets.app.getApplicationSupportDirectory() + `/assets/extensions/user/${themeName}/` :\n                brackets.app.getApplicationSupportDirectory() + `/extensions/user/${themeName}/`;\n\n        const fileName = options.theme.file || (typeof(options.theme) === 'string'? options.theme: `theme.css`),\n            packageURL = url.substring(0, url.lastIndexOf(\"/\")) + '/package.json',\n            packagePath = path.normalize(themeFolder + 'package.json'),\n            themePath = path.normalize(themeFolder + fileName),\n            file = FileSystem.getFileForPath(themePath),\n            folder = FileSystem.getDirectoryForPath(themeFolder);\n\n        $.get(url).done(function (themeContent) {\n            // Write theme to file\n            folder.create((err)=>{\n                if(err){\n                    console.error(err);\n                    deferred.reject();\n                    return;\n                }\n                FileUtils.writeText(file, themeContent, true).done(function () {\n                    _copyPackageJson(packageURL, packagePath)\n                        .catch(error=>{\n                            console.error(\"Error copying package.json for theme \" + themePath, error);\n                        })\n                        .finally(()=>{\n                            let theme = _loadThemeFromFile(file, options);\n                            deferred.resolve(theme);\n                        });\n                }).fail(function (error) {\n                    console.error(\"Error writing \" + themePath, error);\n                    deferred.reject();\n                });\n            });\n        }).fail(function () {\n            // if offline, try to see if we have the previously saved theme available\n            file.exists(function (err, exists) {\n                if(err){\n                    deferred.reject(err);\n                    return;\n                }\n                if (exists) {\n                    let theme = _loadThemeFromFile(file, options);\n                    deferred.resolve(theme);\n                    return;\n                }\n            });\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * Loads a theme from a file.\n     *\n     * @param {string} fileName is the full path to the file to be opened\n     * @param {Object} options is an optional parameter to specify metadata\n     *    for the theme.\n     * @return {$.Promise} promise object resolved with the theme to be loaded from fileName\n     */\n    function loadFile(fileName, options) {\n        if(fileName.startsWith(\"http://\") || fileName.startsWith(\"https://\")\n            || fileName.startsWith(\"phtauri://\") || fileName.startsWith(\"asset://\")) {\n            if(Phoenix.VFS.getPathForVirtualServingURL(fileName)){\n                fileName = Phoenix.VFS.getPathForVirtualServingURL(fileName);\n            } else {\n                return _loadFileFromURL(fileName, options);\n            }\n        }\n\n        var deferred         = new $.Deferred(),\n            file             = FileSystem.getFileForPath(fileName);\n\n        file.exists(function (err, exists) {\n            var theme;\n\n            if (exists) {\n                theme = new Theme(file, options);\n                loadedThemes[theme.name] = theme;\n                ThemeSettings._setThemes(loadedThemes);\n                exports.trigger(EVENT_THEME_LOADED, theme.name);\n\n                // For themes that are loaded after ThemeManager has been loaded,\n                // we should check if it's the current theme.  If it is, then we just\n                // load it.\n                if (currentTheme && currentTheme.name === theme.name) {\n                    refresh(true);\n                }\n\n                deferred.resolve(theme);\n            } else if (err || !exists) {\n                deferred.reject(err);\n            }\n        });\n\n        return deferred.promise();\n    }\n\n\n    /**\n     * Loads a theme from an extension package.\n     *\n     * @param {Object} themePackage is a package from the extension manager for the theme to be loaded.\n     * @return {$.Promise} promise object resolved with the theme to be loaded from the pacakge\n     */\n    function loadPackage(themePackage) {\n        var fileName = themePackage.path + \"/\" + themePackage.metadata.theme.file;\n        return loadFile(fileName, themePackage.metadata);\n    }\n\n    /**\n     * Detects if the os settings is set to dark theme or not\n     */\n    function isOSInDarkTheme() {\n        if(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches){\n            return true;\n        }\n    }\n\n    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {\n        // listen to system dark/light theme changes\n        console.log(`System theme changed to ${e.matches ? \"dark\" : \"light\"} mode`);\n        refresh(true);\n\n        // Report os preference change also as a theme change\n        exports.trigger(EVENT_THEME_CHANGE, getCurrentTheme());\n    });\n\n    prefs.on(\"change\", \"theme\", function () {\n        // Make sure we don't reprocess a theme that's already loaded\n        if (currentTheme && currentTheme.name === prefs.get(\"theme\")) {\n            return;\n        }\n\n        // Refresh editor with the new theme\n        refresh(true);\n\n        // Process the scrollbars for the editor\n        ThemeView.updateScrollbars(getCurrentTheme());\n\n        // Expose event for theme changes\n        exports.trigger(EVENT_THEME_CHANGE, getCurrentTheme());\n    });\n\n    prefs.on(\"change\", \"themeScrollbars\", function () {\n        refresh();\n        ThemeView.updateScrollbars(getCurrentTheme());\n    });\n\n    // Monitor file changes.  If the file that has changed is actually the currently loaded\n    // theme, then we just reload the theme.  This allows to live edit the theme\n    FileSystem.on(\"change\", function (evt, file) {\n        if (!file || file.isDirectory) {\n            return;\n        }\n\n        if (getThemeByFile(file)) {\n            refresh(true);\n        }\n    });\n\n    EditorManager.on(\"activeEditorChange\", function () {\n        refresh();\n    });\n\n    /**\n     * Sets the current theme for the given theme id if present.\n     * @param {string} themeID\n     * @return {boolean} true if the theme was applied, else false\n     */\n    function setCurrentTheme(themeID) {\n        let themeIDs = [];\n        for(let theme of getAllThemes()){\n            themeIDs.push(theme.name);\n        }\n        if(themeIDs.includes(themeID)){\n            prefs.set(\"theme\", themeID);\n            return true;\n        }\n        console.error(\"Cannot set theme that doesnt exist: \", themeID);\n        return false;\n    }\n\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    exports.refresh         = refresh;\n    exports.loadFile        = loadFile;\n    exports.loadPackage     = loadPackage;\n    exports.getCurrentTheme = getCurrentTheme;\n    exports.getAllThemes    = getAllThemes;\n    exports.isOSInDarkTheme = isOSInDarkTheme;\n    exports.setCurrentTheme = setCurrentTheme;\n    exports.EVENT_THEME_CHANGE = EVENT_THEME_CHANGE;\n    exports.EVENT_THEME_LOADED = EVENT_THEME_LOADED;\n\n    // Exposed for testing purposes\n    exports._toDisplayName     = toDisplayName;\n    exports._extractScrollbars = extractScrollbars;\n});\n"],"file":"ThemeManager.js"}
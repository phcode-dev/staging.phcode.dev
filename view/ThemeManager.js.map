{"version":3,"sources":["view/ThemeManager.js"],"names":["define","require","exports","module","_","EventDispatcher","FileSystem","FileUtils","EditorManager","ExtensionUtils","ThemeSettings","ThemeView","PreferencesManager","prefs","getExtensionPrefs","loadedThemes","currentTheme","styleNode","$","addEmbeddedStyleSheet","commentRegex","scrollbarsRegex","stylesPath","getNativeBracketsDirectoryPath","EVENT_THEME_CHANGE","toDisplayName","name","extIndex","lastIndexOf","substring","undefined","replace","split","map","part","toUpperCase","join","Theme","file","options","fileName","title","getFilenameWithoutExtension","toLocaleLowerCase","this","displayName","dark","theme","addModeClass","extractScrollbars","content","scrollbar","match","push","fixPath","path","lessifyTheme","deferred","Deferred","less","render","rootpath","filename","_path","err","tree","reject","resolve","css","promise","getThemeByFile","find","item","getCurrentTheme","defaultTheme","isOSInDarkTheme","DEFAULTS","darkTheme","lightTheme","get","getAllThemes","loadCurrentTheme","pending","readAsText","then","lessContent","result","cssContent","toggleClass","text","when","refresh","force","done","editor","getActiveEditor","_codeMirror","cm","updateThemes","setOption","_loadThemeFromFile","_setThemes","_copyPackageJson","packageURL","destPackageFilePath","Promise","getFileForPath","exists","packageContent","writeText","JSON","stringify","fail","_loadFileFromURL","url","themeName","themeFolder","brackets","app","getApplicationSupportDirectory","packagePath","normalize","themePath","folder","getDirectoryForPath","themeContent","create","console","error","catch","finally","loadFile","startsWith","loadPackage","themePackage","metadata","window","matchMedia","matches","setCurrentTheme","themeID","themeIDs","includes","set","addListener","e","log","trigger","on","updateScrollbars","evt","isDirectory","makeEventDispatcher","_toDisplayName","_extractScrollbars"],"mappings":"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","sourcesContent":["/**\n * Brackets Themes Copyright (c) 2014 Miguel Castillo.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*jslint regexp: true */\n/*global less, path */\n\ndefine(function (require, exports, module) {\n\n\n    const _                  = require(\"thirdparty/lodash\"),\n        EventDispatcher    = require(\"utils/EventDispatcher\"),\n        FileSystem         = require(\"filesystem/FileSystem\"),\n        FileUtils          = require(\"file/FileUtils\"),\n        EditorManager      = require(\"editor/EditorManager\"),\n        ExtensionUtils     = require(\"utils/ExtensionUtils\"),\n        ThemeSettings      = require(\"view/ThemeSettings\"),\n        ThemeView          = require(\"view/ThemeView\"),\n        PreferencesManager = require(\"preferences/PreferencesManager\"),\n        prefs              = PreferencesManager.getExtensionPrefs(\"themes\");\n\n    let loadedThemes    = {},\n        currentTheme    = null,\n        styleNode       = $(ExtensionUtils.addEmbeddedStyleSheet(\"\")),\n        commentRegex    = /\\/\\*([\\s\\S]*?)\\*\\//mg,\n        scrollbarsRegex = /((?:[^}|,]*)::-webkit-scrollbar(?:[^{]*)[{](?:[^}]*?)[}])/mgi,\n        stylesPath      = FileUtils.getNativeBracketsDirectoryPath() + \"/styles/\";\n\n    const EVENT_THEME_CHANGE = \"themeChange\";\n\n    /**\n     * @private\n     * Takes all dashes and converts them to white spaces. Then takes all first letters\n     * and capitalizes them.\n     *\n     * @param {string} name is what needs to be procseed to generate a display name\n     * @return {string} theme name properly formatted for display\n     */\n    function toDisplayName(name) {\n        var extIndex = name.lastIndexOf('.');\n        name = name.substring(0, extIndex !== -1 ? extIndex : undefined).replace(/-/g, ' ');\n\n        return name.split(\" \").map(function (part) {\n            return part[0].toUpperCase() + part.substring(1);\n        }).join(\" \");\n    }\n\n\n    /**\n     * @constructor\n     * Theme contains all the essential bit to load a theme from disk, display a theme in the settings\n     * dialog, and to properly add a theme into CodeMirror along with the rest of brackets.\n     *\n     * @param {File} file for the theme\n     * @param {{name: string, title: string}} options to configure different\n     *   properties in the theme\n     */\n    function Theme(file, options) {\n        options = options || {};\n        var fileName = file.name;\n\n        // If no options.name is provided, then we derive the name of the theme from whichever we find\n        // first, the options.title or the filename.\n        if (!options.name) {\n            if (options.title) {\n                options.name = options.title;\n            } else {\n                // Remove the file extension when the filename is used as the theme name. This is to\n                // follow CodeMirror conventions where themes are just a CSS file and the filename\n                // (without the extension) is used to build CSS rules.  Also handle removing .min\n                // in case the \".min\" is part of the file name.\n                options.name = FileUtils.getFilenameWithoutExtension(fileName).replace(/\\.min$/, \"\");\n            }\n\n            // We do a bit of string treatment here to make sure we generate theme names that can be\n            // used as a CSS class name by CodeMirror.\n            options.name = options.name.toLocaleLowerCase().replace(/[\\W]/g, '-');\n        }\n\n        this.file           = file;\n        this.name           = options.name;\n        this.displayName    = options.title || toDisplayName(fileName);\n        this.dark           = options.theme !== undefined && options.theme.dark === true;\n        this.addModeClass   = options.theme !== undefined && options.theme.addModeClass === true;\n    }\n\n\n    /**\n     * @private\n     * Extracts the scrollbar text from the css/less content so that it can be treated\n     * as a separate styling component that can be anabled/disabled independently from\n     * the theme.\n     *\n     * @param {string} content is the css/less input string to be processed\n     * @return {{content: string, scrollbar: Array.<string>}} content is the new css/less content\n     *   with the scrollbar rules extracted out and put in scrollbar\n     */\n    function extractScrollbars(content) {\n        var scrollbar = [];\n\n        // Go through and extract out scrollbar customizations so that we can\n        // enable/disable via settings.\n        content = content\n            .replace(scrollbarsRegex, function (match) {\n                scrollbar.push(match);\n                return \"\";\n            });\n\n        return {\n            content: content,\n            scrollbar: scrollbar\n        };\n    }\n\n\n    /**\n     * @private\n     * Function will process a string and figure out if it looks like window path with a\n     * a drive.  If that's the case, then we lower case everything.\n     * --- NOTE: There is a bug in less that only checks for lowercase in order to handle\n     * the rootPath configuration...  Hopefully a PR will be coming their way soon.\n     *\n     * @param {string} path is a string to search for drive letters that need to be converted\n     *   to lower case.\n     *\n     * @return {string} Windows Drive letter in lowercase.\n     */\n    function fixPath(path) {\n        return path.replace(/^([A-Z]+:)?\\//, function (match) {\n            return match.toLocaleLowerCase();\n        });\n    }\n\n\n    /**\n     * @private\n     * Takes the content of a file and feeds it through the less processor in order\n     * to provide support for less files.\n     *\n     * @param {string} content is the css/less string to be processed\n     * @param {Theme} theme is the object the css/less corresponds to\n     * @return {$.Promise} promise with the processed css/less as the resolved value\n     */\n    function lessifyTheme(content, theme) {\n        var deferred = new $.Deferred();\n\n        less.render(\"#Phoenix-Main {\" + content + \"\\n}\", {\n            rootpath: fixPath(stylesPath),\n            filename: fixPath(theme.file._path)\n        }, function (err, tree) {\n            if (err) {\n                deferred.reject(err);\n            } else {\n                deferred.resolve(tree.css);\n            }\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * @private\n     * Will search all loaded themes for one the matches the file passed in\n     *\n     * @param {File} file is the search criteria\n     * @return {Theme} theme that matches the file\n     */\n    function getThemeByFile(file) {\n        var path = file._path;\n        return _.find(loadedThemes, function (item) {\n            return item.file._path === path;\n        });\n    }\n\n\n    /**\n     * Get current theme object that is loaded in the editor.\n     *\n     * @return {Theme} the current theme instance\n     */\n    function getCurrentTheme() {\n        let defaultTheme = isOSInDarkTheme() ?\n            ThemeSettings.DEFAULTS.darkTheme:\n            ThemeSettings.DEFAULTS.lightTheme;\n        if (!currentTheme) {\n            currentTheme = loadedThemes[prefs.get(\"theme\")] || loadedThemes[defaultTheme];\n        }\n\n        return currentTheme;\n    }\n\n\n    /**\n     * Gets all available themes\n     * @return {Array.<Theme>} collection of all available themes\n     */\n    function getAllThemes() {\n        return _.map(loadedThemes, function (theme) {\n            return theme;\n        });\n    }\n\n\n    /**\n     * @private\n     * Process and load the current theme into the editor\n     *\n     * @return {$.Promise} promise object resolved with the theme object and all\n     *    corresponding new css/less and scrollbar information\n     */\n    function loadCurrentTheme() {\n        var theme = getCurrentTheme();\n\n        var pending = theme && FileUtils.readAsText(theme.file)\n            .then(function (lessContent) {\n                return lessifyTheme(lessContent.replace(commentRegex, \"\"), theme);\n            })\n            .then(function (content) {\n                var result = extractScrollbars(content);\n                theme.scrollbar = result.scrollbar;\n                return result.content;\n            })\n            .then(function (cssContent) {\n                $(\"body\").toggleClass(\"dark\", theme.dark);\n                styleNode.text(cssContent);\n                return theme;\n            });\n\n        return $.when(pending);\n    }\n\n\n    /**\n     * Refresh current theme in the editor\n     *\n     * @param {boolean} force Forces a reload of the current theme.  It reloads the theme file.\n     */\n    function refresh(force) {\n        if (force) {\n            currentTheme = null;\n        }\n\n        $.when(force && loadCurrentTheme()).done(function () {\n            var editor = EditorManager.getActiveEditor();\n            if (!editor || !editor._codeMirror) {\n                return;\n            }\n\n            var cm = editor._codeMirror;\n            ThemeView.updateThemes(cm);\n\n            // currentTheme can be undefined, so watch out\n            cm.setOption(\"addModeClass\", !!(currentTheme && currentTheme.addModeClass));\n        });\n    }\n\n    /**\n     *\n     * @param file FileSystem.getFileForPath object\n     * @param options\n     * @private\n     */\n    function _loadThemeFromFile(file, options) {\n        let theme = new Theme(file, options);\n        loadedThemes[theme.name] = theme;\n        ThemeSettings._setThemes(loadedThemes);\n\n        if (getCurrentTheme() && getCurrentTheme().name === theme.name) {\n            refresh(true);\n        }\n        return theme;\n    }\n\n    function _copyPackageJson(packageURL, destPackageFilePath) {\n        return new Promise((resolve, reject)=>{\n            const file = FileSystem.getFileForPath(destPackageFilePath);\n            file.exists(function (err, exists) {\n                if(err){\n                    reject();\n                    return;\n                }\n                if (!exists) {\n                    $.get(packageURL).done(function (packageContent) {\n                        FileUtils.writeText(file, JSON.stringify(packageContent), true).done(function () {\n                            resolve();\n                        }).fail(function (err) {\n                            reject(err);\n                        });\n                    }).fail(function (err) {\n                        reject(err);\n                    });\n                    return;\n                }\n                resolve();\n            });\n        });\n    }\n\n    /**\n     * Loads a theme from a url.\n     *\n     * @param {string} url is the full http/https url of the theme file\n     * @param {Object} options is an optional parameter to specify metadata\n     *    for the theme.\n     * @return {$.Promise} promise object resolved with the theme to be loaded from fileName\n     */\n    function _loadFileFromURL(url, options) {\n        let deferred         = new $.Deferred();\n\n        const themeName = options.name || options.theme.title,\n            fileName = options.theme.file || (typeof(options.theme) === 'string'? options.theme: `theme.css`),\n            themeFolder = brackets.app.getApplicationSupportDirectory() + `/extensions/user/${themeName}/`,\n            packageURL = url.substring(0, url.lastIndexOf(\"/\")) + '/package.json',\n            packagePath = path.normalize(themeFolder + 'package.json'),\n            themePath = path.normalize(themeFolder + fileName),\n            file = FileSystem.getFileForPath(themePath),\n            folder = FileSystem.getDirectoryForPath(themeFolder);\n\n        $.get(url).done(function (themeContent) {\n            // Write theme to file\n            folder.create((err)=>{\n                if(err){\n                    console.error(err);\n                    deferred.reject();\n                    return;\n                }\n                FileUtils.writeText(file, themeContent, true).done(function () {\n                    _copyPackageJson(packageURL, packagePath)\n                        .catch(error=>{\n                            console.error(\"Error copying package.json for theme \" + themePath, error);\n                        })\n                        .finally(()=>{\n                            let theme = _loadThemeFromFile(file, options);\n                            deferred.resolve(theme);\n                        });\n                }).fail(function (error) {\n                    console.error(\"Error writing \" + themePath, error);\n                    deferred.reject();\n                });\n            });\n        }).fail(function () {\n            // if offline, try to see if we have the previously saved theme available\n            file.exists(function (err, exists) {\n                if(err){\n                    deferred.reject(err);\n                    return;\n                }\n                if (exists) {\n                    let theme = _loadThemeFromFile(file, options);\n                    deferred.resolve(theme);\n                    return;\n                }\n            });\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * Loads a theme from a file.\n     *\n     * @param {string} fileName is the full path to the file to be opened\n     * @param {Object} options is an optional parameter to specify metadata\n     *    for the theme.\n     * @return {$.Promise} promise object resolved with the theme to be loaded from fileName\n     */\n    function loadFile(fileName, options) {\n        if(fileName.startsWith(\"http://\") || fileName.startsWith(\"https://\")) {\n            return _loadFileFromURL(fileName, options);\n        }\n\n        var deferred         = new $.Deferred(),\n            file             = FileSystem.getFileForPath(fileName);\n\n        file.exists(function (err, exists) {\n            var theme;\n\n            if (exists) {\n                theme = new Theme(file, options);\n                loadedThemes[theme.name] = theme;\n                ThemeSettings._setThemes(loadedThemes);\n\n                // For themes that are loaded after ThemeManager has been loaded,\n                // we should check if it's the current theme.  If it is, then we just\n                // load it.\n                if (currentTheme && currentTheme.name === theme.name) {\n                    refresh(true);\n                }\n\n                deferred.resolve(theme);\n            } else if (err || !exists) {\n                deferred.reject(err);\n            }\n        });\n\n        return deferred.promise();\n    }\n\n\n    /**\n     * Loads a theme from an extension package.\n     *\n     * @param {Object} themePackage is a package from the extension manager for the theme to be loaded.\n     * @return {$.Promise} promise object resolved with the theme to be loaded from the pacakge\n     */\n    function loadPackage(themePackage) {\n        var fileName = themePackage.path + \"/\" + themePackage.metadata.theme.file;\n        return loadFile(fileName, themePackage.metadata);\n    }\n\n    /**\n     * Detects if the os settings is set to dark theme or not\n     */\n    function isOSInDarkTheme() {\n        if(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches){\n            return true;\n        }\n    }\n\n    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {\n        // listen to system dark/light theme changes\n        console.log(`System theme changed to ${e.matches ? \"dark\" : \"light\"} mode`);\n        refresh(true);\n        \n        // Report os preference change also as a theme change\n        exports.trigger(EVENT_THEME_CHANGE, getCurrentTheme());\n    });\n\n    prefs.on(\"change\", \"theme\", function () {\n        // Make sure we don't reprocess a theme that's already loaded\n        if (currentTheme && currentTheme.name === prefs.get(\"theme\")) {\n            return;\n        }\n\n        // Refresh editor with the new theme\n        refresh(true);\n\n        // Process the scrollbars for the editor\n        ThemeView.updateScrollbars(getCurrentTheme());\n\n        // Expose event for theme changes\n        exports.trigger(EVENT_THEME_CHANGE, getCurrentTheme());\n    });\n\n    prefs.on(\"change\", \"themeScrollbars\", function () {\n        refresh();\n        ThemeView.updateScrollbars(getCurrentTheme());\n    });\n\n    // Monitor file changes.  If the file that has changed is actually the currently loaded\n    // theme, then we just reload the theme.  This allows to live edit the theme\n    FileSystem.on(\"change\", function (evt, file) {\n        if (!file || file.isDirectory) {\n            return;\n        }\n\n        if (getThemeByFile(file)) {\n            refresh(true);\n        }\n    });\n\n    EditorManager.on(\"activeEditorChange\", function () {\n        refresh();\n    });\n\n    /**\n     * Sets the current theme for the given theme id if present.\n     * @param {string} themeID\n     * @return {boolean} true if the theme was applied, else false\n     */\n    function setCurrentTheme(themeID) {\n        let themeIDs = [];\n        for(let theme of getAllThemes()){\n            themeIDs.push(theme.name);\n        }\n        if(themeIDs.includes(themeID)){\n            prefs.set(\"theme\", themeID);\n            return true;\n        }\n        console.error(\"Cannot set theme that doesnt exist: \", themeID);\n        return false;\n    }\n\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    exports.refresh         = refresh;\n    exports.loadFile        = loadFile;\n    exports.loadPackage     = loadPackage;\n    exports.getCurrentTheme = getCurrentTheme;\n    exports.getAllThemes    = getAllThemes;\n    exports.isOSInDarkTheme = isOSInDarkTheme;\n    exports.setCurrentTheme = setCurrentTheme;\n    exports.EVENT_THEME_CHANGE = EVENT_THEME_CHANGE;\n\n    // Exposed for testing purposes\n    exports._toDisplayName     = toDisplayName;\n    exports._extractScrollbars = extractScrollbars;\n});\n"],"file":"ThemeManager.js"}
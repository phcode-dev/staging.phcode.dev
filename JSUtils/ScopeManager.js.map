{"version":3,"sources":["JSUtils/ScopeManager.js"],"names":["define","require","exports","module","_","CodeMirror","DefaultDialogs","Dialogs","DocumentManager","EditorManager","FileSystem","FileUtils","LanguageManager","PreferencesManager","ProjectManager","Strings","StringUtils","InMemoryFile","IndexingWorker","loadScriptInWorker","Phoenix","baseURL","HintUtils","MessageIds","JSON","parse","Preferences","ternEnvironment","ternConfigInitDone","pendingTernRequests","builtinLibraryNames","isDocumentDirty","_hintCount","currentModule","documentChanges","preferences","deferredPreferences","MAX_HINTS","LARGE_LINE_CHANGE","LARGE_LINE_COUNT","OFFSET_ZERO","line","ch","config","getBuiltins","initTernEnv","builtinDefinitionFiles","fileName","filePath","console","log","fetch","then","async","ternDefsLibrary","contents","json","push","catch","e","error","initPreferences","projectRootPath","state","reject","$","Deferred","pr","getProjectRoot","fullPath","path","FILE_NAME","resolve","err","file","readAsText","done","text","configObj","SyntaxError","message","fail","ensurePreferences","postMessage","msg","isDirectoryExcluded","excludes","getExcludedDirectories","testPath","makeProjectRelativeIfPossible","stripTrailingSlash","test","isFileBeingEdited","currentEditor","getActiveEditor","currentDoc","document","isFileExcludedInternal","detectedExclusions","get","indexOf","isFileExcluded","name","languageID","getLanguageForPath","getId","LANGUAGE_ID","getExcludedFiles","addPendingRequest","offset","type","requests","key","$deferredRequest","promise","has","getPendingRequest","requestType","Object","keys","length","getResolvedPath","getJumptoDef","fileInfo","TERN_JUMPTODEF_MSG","filterText","newText","getMaxFileSize","getTextFromDocument","getText","handleRename","response","displayErrorMessageAtCursor","$deferredFindRefs","TERN_REFS","resolveWith","requestJumptoDef","session","ternPromise","TERN_FILE_INFO_TYPE_FULL","offsetLines","getJavascriptText","handleJumptoDef","$deferredJump","resultFile","handleScopeData","TERN_SCOPEDATA_MSG","getTernHints","isProperty","TERN_COMPLETIONS_MSG","getTernFunctionType","TERN_CALLED_FUNC_TYPE_MSG","getFragmentAround","start","minIndent","minLine","endLine","cm","editor","_codeMirror","tabSize","getOption","p","min","indent","Math","max","fn","getLine","search","countColumn","getToken","lastLine","endCh","from","to","TERN_FILE_INFO_TYPE_PART","getRange","getFileInfo","preventPartialUpdates","getCursor","end","isHtmlFile","result","lineCount","TERN_FILE_INFO_TYPE_EMPTY","getOffset","newOffset","requestGuesses","$deferred","TERN_GET_GUESSES_MSG","guesses","setGuesses","handleTernCompletions","completions","properties","fnType","$deferredHints","handleGetGuesses","handleUpdateFile","handleTimedOut","set","location","scope","showModalDialog","DIALOG_ID_INFO","DETECTED_EXCLUSION_TITLE","format","DETECTED_EXCLUSION_INFO","breakableUrl","className","DIALOG_BTN_CLASS_PRIMARY","id","DIALOG_BTN_OK","OK","TernModule","addFilesPromise","rootTernDir","projectRoot","stopAddingFiles","resolvedFiles","numInitialFiles","numResolvedFiles","numAddedFiles","usingModules","debug","execPeer","_postMessageByPass","updateTernFile","TERN_UPDATE_FILE_MSG","handleTernGetFile","request","replyWith","txt","TERN_GET_FILE_MSG","getDocText","isAbsolutePath","slice","getFileForPath","getDocumentText","docText","findNameInProject","substring","lastIndexOf","_fileFilter","entry","getAllFiles","files","filter","pos","primePump","isUntitledDoc","TERN_PRIME_PUMP_MSG","handlePrimePumpCompletion","addFilesToTern","maxFileCount","getMaxFileCount","available","TERN_ADD_FILES_MSG","addAllFilesAndSubdirectories","dir","doneCallback","directory","visitor","isFile","getDirectoryForPath","visit","initTernModule","moduleDeferred","_ternWorkerEventHandler","evt","data","TERN_INFERENCE_TIMEDOUT","TERN_WORKER_READY","off","on","SET_CONFIG","initTernServer","TERN_INIT_MSG","env","timeout","canSkipTernInitialization","newFile","undefined","doEditorChange","previousDocument","parentPath","addFilesDeferred","updateFilePromise","isUntitled","isDirty","hintsPromise","getContents","map","currentDir","handleEditorChange","resetModule","resetTernServer","whenReady","func","this","event","changedDoc","TERN_UPDATE_DIRTY_FILE","action","TERN_CLEAR_DIRTY_FILES_LIST","resettingDeferred","_maybeReset","force","newTernModule","resetForced","noReset","d","requestParameterHint","functionOffset","fnTypePromise","when","setFnType","setFunctionCallPos","requestHints","hintPromise","sessionType","getType","property","setTernHints","trackChange","changeList","changed","i","thisChange","handleFileChange","handleProjectClose","handleProjectOpen","_readyPromise","_setConfig","configUpdate","brackets","_configureJSCodeHints"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global Phoenix*/\n\n/*\n * Throughout this file, the term \"outer scope\" is used to refer to the outer-\n * most/global/root Scope objects for particular file. The term \"inner scope\"\n * is used to refer to a Scope object that is reachable via the child relation\n * from an outer scope.\n */\n\ndefine(function (require, exports, module) {\n\n\n    var _ = require(\"thirdparty/lodash\");\n\n    const CodeMirror          = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        DefaultDialogs      = require(\"widgets/DefaultDialogs\"),\n        Dialogs             = require(\"widgets/Dialogs\"),\n        DocumentManager     = require(\"document/DocumentManager\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        LanguageManager     = require(\"language/LanguageManager\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        ProjectManager      = require(\"project/ProjectManager\"),\n        Strings             = require(\"strings\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        InMemoryFile        = require(\"document/InMemoryFile\"),\n        IndexingWorker      = require(\"worker/IndexingWorker\");\n\n    IndexingWorker.loadScriptInWorker(`${Phoenix.baseURL}JSUtils/worker/tern-main.js`);\n\n    var HintUtils           = require(\"./HintUtils\"),\n        MessageIds          = JSON.parse(require(\"text!./MessageIds.json\")),\n        Preferences         = require(\"./Preferences\");\n\n    let ternEnvironment     = [],\n        ternConfigInitDone        = false,\n        pendingTernRequests = {},\n        builtinLibraryNames = [],\n        isDocumentDirty     = false,\n        _hintCount          = 0,\n        currentModule       = null,\n        documentChanges     = null,     // bounds of document changes\n        preferences         = null,\n        deferredPreferences = null;\n\n\n    const MAX_HINTS           = 30,  // how often to reset the tern server\n        LARGE_LINE_CHANGE   = 100,\n        LARGE_LINE_COUNT    = 10000,\n        OFFSET_ZERO         = {line: 0, ch: 0};\n\n    var config = {};\n\n    /**\n     *  An array of library names that contain JavaScript builtins definitions.\n     *\n     * @return {Array.<string>} - array of library  names.\n     */\n    function getBuiltins() {\n        return builtinLibraryNames;\n    }\n\n    /**\n     * Read in the json files that have type information for the builtins, dom,etc\n     */\n    function initTernEnv() {\n        const builtinDefinitionFiles = JSON.parse(require(\"text!thirdparty/tern/defs/defs.json\"));\n\n        for(let fileName of builtinDefinitionFiles){\n            let filePath = `thirdparty/tern/defs/${fileName}`;\n            console.log(\"loading tern definition file: \", filePath);\n            fetch(filePath)\n                .then(async contents =>{\n                    const ternDefsLibrary = await contents.json();\n                    builtinLibraryNames.push(ternDefsLibrary[\"!name\"]);\n                    ternEnvironment.push(ternDefsLibrary);\n                })\n                .catch(e =>{\n                    console.error(\"failed to init from tern definition file \" + fileName, e);\n                });\n        }\n    }\n\n    initTernEnv();\n\n    /**\n     *  Init preferences from a file in the project root or builtin\n     *  defaults if no file is found;\n     *\n     *  @param {string=} projectRootPath - new project root path. Only needed\n     *  for unit tests.\n     */\n    function initPreferences(projectRootPath) {\n\n        // Reject the old preferences if they have not completed.\n        if (deferredPreferences && deferredPreferences.state() === \"pending\") {\n            deferredPreferences.reject();\n        }\n\n        deferredPreferences = $.Deferred();\n        var pr = ProjectManager.getProjectRoot();\n\n        // Open preferences relative to the project root\n        // Normally there is a project root, but for unit tests we need to\n        // pass in a project root.\n        if (pr) {\n            projectRootPath = pr.fullPath;\n        } else if (!projectRootPath) {\n            console.log(\"initPreferences: projectRootPath has no value\");\n        }\n\n        var path = projectRootPath + Preferences.FILE_NAME;\n\n        FileSystem.resolve(path, function (err, file) {\n            if (!err) {\n                FileUtils.readAsText(file).done(function (text) {\n                    var configObj = null;\n                    try {\n                        configObj = JSON.parse(text);\n                    } catch (e) {\n                        // continue with null configObj which will result in\n                        // default settings.\n                        console.log(\"Error parsing preference file: \" + path);\n                        if (e instanceof SyntaxError) {\n                            console.log(e.message);\n                        }\n                    }\n                    preferences = new Preferences(configObj);\n                    deferredPreferences.resolve();\n                }).fail(function (error) {\n                    preferences = new Preferences();\n                    deferredPreferences.resolve();\n                });\n            } else {\n                preferences = new Preferences();\n                deferredPreferences.resolve();\n            }\n        });\n    }\n\n    /**\n     * Will initialize preferences only if they do not exist.\n     *\n     */\n    function ensurePreferences() {\n        if (!deferredPreferences) {\n            initPreferences();\n        }\n    }\n\n    /**\n     * Send a message to the tern module - if the module is being initialized,\n     * the message will not be posted until initialization is complete\n     */\n    function postMessage(msg) {\n        if (currentModule) {\n            currentModule.postMessage(msg);\n        }\n    }\n\n    /**\n     * Test if the directory should be excluded from analysis.\n     *\n     * @param {!string} path - full directory path.\n     * @return {boolean} true if excluded, false otherwise.\n     */\n    function isDirectoryExcluded(path) {\n        var excludes = preferences.getExcludedDirectories();\n\n        if (!excludes) {\n            return false;\n        }\n\n        var testPath = ProjectManager.makeProjectRelativeIfPossible(path);\n        testPath = FileUtils.stripTrailingSlash(testPath);\n\n        return excludes.test(testPath);\n    }\n\n    /**\n     * Test if the file path is in current editor\n     *\n     * @param {string} filePath file path to test for exclusion.\n     * @return {boolean} true if in editor, false otherwise.\n     */\n    function isFileBeingEdited(filePath) {\n        var currentEditor   = EditorManager.getActiveEditor(),\n            currentDoc      = currentEditor && currentEditor.document;\n\n        return (currentDoc && currentDoc.file.fullPath === filePath);\n    }\n\n    /**\n     * Test if the file path is an internal exclusion.\n     *\n     * @param {string} path file path to test for exclusion.\n     * @return {boolean} true if excluded, false otherwise.\n     */\n    function isFileExcludedInternal(path) {\n        // The detectedExclusions are files detected to be troublesome with current versions of Tern.\n        // detectedExclusions is an array of full paths.\n        var detectedExclusions = PreferencesManager.get(\"jscodehints.detectedExclusions\") || [];\n        if (detectedExclusions && detectedExclusions.indexOf(path) !== -1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Test if the file should be excluded from analysis.\n     *\n     * @param {!File} file - file to test for exclusion.\n     * @return {boolean} true if excluded, false otherwise.\n     */\n    function isFileExcluded(file) {\n        if (file.name[0] === \".\") {\n            return true;\n        }\n\n        var languageID = LanguageManager.getLanguageForPath(file.fullPath).getId();\n        if (languageID !== HintUtils.LANGUAGE_ID) {\n            return true;\n        }\n\n        var excludes = preferences.getExcludedFiles();\n        if (excludes && excludes.test(file.name)) {\n            return true;\n        }\n\n        if (isFileExcludedInternal(file.fullPath)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Add a pending request waiting for the tern-module to complete.\n     * If file is a detected exclusion, then reject request.\n     *\n     * @param {string} file - the name of the file\n     * @param {{line: number, ch: number}} offset - the offset into the file the request is for\n     * @param {string} type - the type of request\n     * @return {jQuery.Promise} - the promise for the request\n     */\n    function addPendingRequest(file, offset, type) {\n        var requests,\n            key = file + \"@\" + offset.line + \"@\" + offset.ch,\n            $deferredRequest;\n\n        // Reject detected exclusions\n        if (isFileExcludedInternal(file)) {\n            return (new $.Deferred()).reject().promise();\n        }\n\n        if (_.has(pendingTernRequests, key)) {\n            requests = pendingTernRequests[key];\n        } else {\n            requests = {};\n            pendingTernRequests[key] = requests;\n        }\n\n        if (_.has(requests, type)) {\n            $deferredRequest = requests[type];\n        } else {\n            requests[type] = $deferredRequest = new $.Deferred();\n        }\n        return $deferredRequest.promise();\n    }\n\n    /**\n     * Get any pending $.Deferred object waiting on the specified file and request type\n     * @param {string} file - the file\n     * @param {{line: number, ch: number}} offset - the offset into the file the request is for\n     * @param {string} type - the type of request\n     * @return {jQuery.Deferred} - the $.Deferred for the request\n     */\n    function getPendingRequest(file, offset, type) {\n        var key = file + \"@\" + offset.line + \"@\" + offset.ch;\n        if (_.has(pendingTernRequests, key)) {\n            var requests = pendingTernRequests[key],\n                requestType = requests[type];\n\n            delete pendingTernRequests[key][type];\n\n            if (!Object.keys(requests).length) {\n                delete pendingTernRequests[key];\n            }\n\n            return requestType;\n        }\n    }\n\n    /**\n     * @param {string} file a relative path\n     * @return {string} returns the path we resolved when we tried to parse the file, or undefined\n     */\n    function getResolvedPath(file) {\n        return currentModule.getResolvedPath(file);\n    }\n\n    /**\n     * Get a Promise for the definition from TernJS, for the file & offset passed in.\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset - the offset in the file the hints should be calculate at\n     * @return {jQuery.Promise} - a promise that will resolve to definition when\n     *      it is done\n     */\n    function getJumptoDef(fileInfo, offset) {\n        postMessage({\n            type: MessageIds.TERN_JUMPTODEF_MSG,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return addPendingRequest(fileInfo.name, offset, MessageIds.TERN_JUMPTODEF_MSG);\n    }\n\n    /**\n     * check to see if the text we are sending to Tern is too long.\n     * @param {string} the text to check\n     * @return {string} the text, or the empty text if the original was too long\n     */\n    function filterText(text) {\n        var newText = text;\n        if (text.length > preferences.getMaxFileSize()) {\n            newText = \"\";\n        }\n        return newText;\n    }\n\n    /**\n     * Get the text of a document, applying any size restrictions\n     * if necessary\n     * @param {Document} document - the document to get the text from\n     * @return {string} the text, or the empty text if the original was too long\n     */\n    function getTextFromDocument(document) {\n        var text = document.getText();\n        text = filterText(text);\n        return text;\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the references\n     *\n     * @param response - the response from the node domain\n     */\n    function handleRename(response) {\n\n        if (response.error) {\n            EditorManager.getActiveEditor().displayErrorMessageAtCursor(response.error);\n            return;\n        }\n\n        var file = response.file,\n            offset = response.offset;\n\n        var $deferredFindRefs = getPendingRequest(file, offset, MessageIds.TERN_REFS);\n\n        if ($deferredFindRefs) {\n            $deferredFindRefs.resolveWith(null, [response]);\n        }\n    }\n\n    /**\n     * Request Jump-To-Definition from Tern.\n     *\n     * @param {session} session - the session\n     * @param {Document} document - the document\n     * @param {{line: number, ch: number}} offset - the offset into the document\n     * @return {jQuery.Promise} - The promise will not complete until tern\n     *      has completed.\n     */\n    function requestJumptoDef(session, document, offset) {\n        var path    = document.file.fullPath,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: filterText(session.getJavascriptText())\n            };\n\n        var ternPromise = getJumptoDef(fileInfo, offset);\n\n        return {promise: ternPromise};\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the definition\n     *\n     * @param response - the response from the node domain\n     */\n    function handleJumptoDef(response) {\n\n        var file = response.file,\n            offset = response.offset;\n\n        var $deferredJump = getPendingRequest(file, offset, MessageIds.TERN_JUMPTODEF_MSG);\n\n        if ($deferredJump) {\n            response.fullPath = getResolvedPath(response.resultFile);\n            $deferredJump.resolveWith(null, [response]);\n        }\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the scope data\n     *\n     * @param response - the response from the node domain\n     */\n    function handleScopeData(response) {\n        var file = response.file,\n            offset = response.offset;\n\n        var $deferredJump = getPendingRequest(file, offset, MessageIds.TERN_SCOPEDATA_MSG);\n\n        if ($deferredJump) {\n            $deferredJump.resolveWith(null, [response]);\n        }\n    }\n\n    /**\n     * Get a Promise for the completions from TernJS, for the file & offset passed in.\n     *\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset - the offset in the file the hints should be calculate at\n     * @param {boolean} isProperty - true if getting a property hint,\n     * otherwise getting an identifier hint.\n     * @return {jQuery.Promise} - a promise that will resolve to an array of completions when\n     *      it is done\n     */\n    function getTernHints(fileInfo, offset, isProperty) {\n\n        /**\n         *  If the document is large and we have modified a small portions of it that\n         *  we are asking hints for, then send a partial document.\n         */\n        postMessage({\n            type: MessageIds.TERN_COMPLETIONS_MSG,\n            fileInfo: fileInfo,\n            offset: offset,\n            isProperty: isProperty\n        });\n\n        return addPendingRequest(fileInfo.name, offset, MessageIds.TERN_COMPLETIONS_MSG);\n    }\n\n    /**\n     * Get a Promise for the function type from TernJS.\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line:number, ch:number}} offset - the line, column info for what we want the function type of.\n     * @return {jQuery.Promise} - a promise that will resolve to the function type of the function being called.\n     */\n    function getTernFunctionType(fileInfo, offset) {\n        postMessage({\n            type: MessageIds.TERN_CALLED_FUNC_TYPE_MSG,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return addPendingRequest(fileInfo.name, offset, MessageIds.TERN_CALLED_FUNC_TYPE_MSG);\n    }\n\n\n    /**\n     *  Given a starting and ending position, get a code fragment that is self contained\n     *  enough to be compiled.\n     *\n     * @param {!Session} session - the current session\n     * @param {{line: number, ch: number}} start - the starting position of the changes\n     * @return {{type: string, name: string, offsetLines: number, text: string}}\n     */\n    function getFragmentAround(session, start) {\n        var minIndent = null,\n            minLine   = null,\n            endLine,\n            cm        = session.editor._codeMirror,\n            tabSize   = cm.getOption(\"tabSize\"),\n            document  = session.editor.document,\n            p,\n            min,\n            indent,\n            line;\n\n        // expand range backwards\n        for (p = start.line - 1, min = Math.max(0, p - 100); p >= min; --p) {\n            line = session.getLine(p);\n            var fn = line.search(/\\bfunction\\b/);\n\n            if (fn >= 0) {\n                indent = CodeMirror.countColumn(line, null, tabSize);\n                if (minIndent === null || minIndent > indent) {\n                    if (session.getToken({line: p, ch: fn + 1}).type === \"keyword\") {\n                        minIndent = indent;\n                        minLine = p;\n                    }\n                }\n            }\n        }\n\n        if (minIndent === null) {\n            minIndent = 0;\n        }\n\n        if (minLine === null) {\n            minLine = min;\n        }\n\n        var max = Math.min(cm.lastLine(), start.line + 100),\n            endCh = 0;\n\n        for (endLine = start.line + 1; endLine < max; ++endLine) {\n            line = cm.getLine(endLine);\n\n            if (line.length > 0) {\n                indent = CodeMirror.countColumn(line, null, tabSize);\n                if (indent <= minIndent) {\n                    endCh = line.length;\n                    break;\n                }\n            }\n        }\n\n        var from = {line: minLine, ch: 0},\n            to   = {line: endLine, ch: endCh};\n\n        return {type: MessageIds.TERN_FILE_INFO_TYPE_PART,\n            name: document.file.fullPath,\n            offsetLines: from.line,\n            text: document.getRange(from, to)};\n    }\n\n\n    /**\n     * Get an object that describes what tern needs to know about the updated\n     * file to produce a hint. As a side-effect of this calls the document\n     * changes are reset.\n     *\n     * @param {!Session} session - the current session\n     * @param {boolean=} preventPartialUpdates - if true, disallow partial updates.\n     * Optional, defaults to false.\n     * @return {{type: string, name: string, offsetLines: number, text: string}}\n     */\n    function getFileInfo(session, preventPartialUpdates) {\n        var start = session.getCursor(),\n            end = start,\n            document = session.editor.document,\n            path = document.file.fullPath,\n            isHtmlFile = LanguageManager.getLanguageForPath(path).getId() === \"html\",\n            result;\n\n        if (isHtmlFile) {\n            result = {type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                text: session.getJavascriptText()};\n        } else if (!documentChanges) {\n            result = {type: MessageIds.TERN_FILE_INFO_TYPE_EMPTY,\n                name: path,\n                text: \"\"};\n        } else if (!preventPartialUpdates && session.editor.lineCount() > LARGE_LINE_COUNT &&\n                (documentChanges.to - documentChanges.from < LARGE_LINE_CHANGE) &&\n                documentChanges.from <= start.line &&\n                documentChanges.to > end.line) {\n            result = getFragmentAround(session, start);\n        } else {\n            result = {type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                text: getTextFromDocument(document)};\n        }\n\n        documentChanges = null;\n        return result;\n    }\n\n    /**\n     *  Get the current offset. The offset is adjusted for \"part\" updates.\n     *\n     * @param {!Session} session - the current session\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}=} offset - the default offset (optional). Will\n     * use the cursor if not provided.\n     * @return {{line: number, ch: number}}\n     */\n    function getOffset(session, fileInfo, offset) {\n        var newOffset;\n\n        if (offset) {\n            newOffset = {line: offset.line, ch: offset.ch};\n        } else {\n            newOffset = session.getCursor();\n        }\n\n        if (fileInfo.type === MessageIds.TERN_FILE_INFO_TYPE_PART) {\n            newOffset.line = Math.max(0, newOffset.line - fileInfo.offsetLines);\n        }\n\n        return newOffset;\n    }\n\n    /**\n     * Get a Promise for all of the known properties from TernJS, for the directory and file.\n     * The properties will be used as guesses in tern.\n     * @param {Session} session - the active hinting session\n     * @param {Document} document - the document for which scope info is\n     *      desired\n     * @return {jQuery.Promise} - The promise will not complete until the tern\n     *      request has completed.\n     */\n    function requestGuesses(session, document) {\n        var $deferred = $.Deferred(),\n            fileInfo = getFileInfo(session),\n            offset = getOffset(session, fileInfo);\n\n        postMessage({\n            type: MessageIds.TERN_GET_GUESSES_MSG,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        var promise = addPendingRequest(fileInfo.name, offset, MessageIds.TERN_GET_GUESSES_MSG);\n        promise.done(function (guesses) {\n            session.setGuesses(guesses);\n            $deferred.resolve();\n        }).fail(function () {\n            $deferred.reject();\n        });\n\n        return $deferred.promise();\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the list of completions\n     *\n     * @param {{file: string, offset: {line: number, ch: number}, completions:Array.<string>,\n     *          properties:Array.<string>}} response - the response from node domain\n     */\n    function handleTernCompletions(response) {\n\n        var file = response.file,\n            offset = response.offset,\n            completions = response.completions,\n            properties = response.properties,\n            fnType  = response.fnType,\n            type = response.type,\n            error = response.error,\n            $deferredHints = getPendingRequest(file, offset, type);\n\n        if ($deferredHints) {\n            if (error) {\n                $deferredHints.reject();\n            } else if (completions) {\n                $deferredHints.resolveWith(null, [{completions: completions}]);\n            } else if (properties) {\n                $deferredHints.resolveWith(null, [{properties: properties}]);\n            } else if (fnType) {\n                $deferredHints.resolveWith(null, [fnType]);\n            }\n        }\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds to the get guesses message.\n     *\n     * @param {{file: string, type: string, offset: {line: number, ch: number},\n     *      properties: Array.<string>}} response -\n     *      the response from node domain contains the guesses for a\n     *      property lookup.\n     */\n    function handleGetGuesses(response) {\n        var path = response.file,\n            type = response.type,\n            offset = response.offset,\n            $deferredHints = getPendingRequest(path, offset, type);\n\n        if ($deferredHints) {\n            $deferredHints.resolveWith(null, [response.properties]);\n        }\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds to the update file message.\n     *\n     * @param {{path: string, type: string}} response - the response from node domain\n     */\n    function handleUpdateFile(response) {\n\n        var path = response.path,\n            type = response.type,\n            $deferredHints = getPendingRequest(path, OFFSET_ZERO, type);\n\n        if ($deferredHints) {\n            $deferredHints.resolve();\n        }\n    }\n\n    /**\n     * Handle timed out inference\n     *\n     * @param {{path: string, type: string}} response - the response from node domain\n     */\n    function handleTimedOut(response) {\n\n        var detectedExclusions  = PreferencesManager.get(\"jscodehints.detectedExclusions\") || [],\n            filePath            = response.file;\n\n        // Don't exclude the file currently being edited\n        if (isFileBeingEdited(filePath)) {\n            return;\n        }\n\n        // Handle file that is already excluded\n        if (detectedExclusions.indexOf(filePath) !== -1) {\n            console.log(\"JavaScriptCodeHints.handleTimedOut: file already in detectedExclusions array timed out: \" + filePath);\n            return;\n        }\n\n        // Save detected exclusion in project prefs so no further time is wasted on it\n        detectedExclusions.push(filePath);\n        PreferencesManager.set(\"jscodehints.detectedExclusions\", detectedExclusions, { location: { scope: \"project\" } });\n\n        // Show informational dialog\n        Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_INFO,\n            Strings.DETECTED_EXCLUSION_TITLE,\n            StringUtils.format(\n                Strings.DETECTED_EXCLUSION_INFO,\n                StringUtils.breakableUrl(filePath)\n            ),\n            [\n                {\n                    className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\n                    id: Dialogs.DIALOG_BTN_OK,\n                    text: Strings.OK\n                }\n            ]\n        );\n    }\n\n    DocumentManager.on(\"dirtyFlagChange\", function (event, changedDoc) {\n        if (changedDoc.file.fullPath) {\n            postMessage({\n                type: MessageIds.TERN_UPDATE_DIRTY_FILE,\n                name: changedDoc.file.fullPath,\n                action: changedDoc.isDirty\n            });\n        }\n    });\n\n    // Clear dirty document list in tern node domain\n    ProjectManager.on(\"beforeProjectClose\", function () {\n        postMessage({\n            type: MessageIds.TERN_CLEAR_DIRTY_FILES_LIST\n        });\n    });\n\n    /**\n     * Encapsulate all the logic to talk to the tern module.  This will create\n     * a new instance of a TernModule, which the rest of the hinting code can use to talk\n     * to the tern node domain, without worrying about initialization, priming the pump, etc.\n     *\n     */\n    function TernModule() {\n        var ternPromise         = null,\n            addFilesPromise     = null,\n            rootTernDir         = null,\n            projectRoot         = null,\n            stopAddingFiles     = false,\n            resolvedFiles       = {},       // file -> resolved file\n            numInitialFiles     = 0,\n            numResolvedFiles    = 0,\n            numAddedFiles       = 0;\n\n        /**\n         * @param {string} file a relative path\n         * @return {string} returns the path we resolved when we tried to parse the file, or undefined\n         */\n        function getResolvedPath(file) {\n            return resolvedFiles[file];\n        }\n\n        /**\n         *  Determine whether the current set of files are using modules to pull in\n         *  additional files.\n         *\n         * @return {boolean} - true if more files than the current directory have\n         * been read in.\n         */\n        function usingModules() {\n            return numInitialFiles !== numResolvedFiles;\n        }\n\n        /**\n         * Send a message to the tern node domain - if the module is being initialized,\n         * the message will not be posted until initialization is complete\n         */\n        function postMessage(msg) {\n            addFilesPromise.done(function () {\n                if (config.debug) {\n                    console.debug(\"Sending message\", msg);\n                }\n                IndexingWorker.execPeer(\"invokeTernCommand\", msg);\n            });\n        }\n\n        /**\n         * Send a message to the tern node domain - this is only for messages that\n         * need to be sent before and while the addFilesPromise is being resolved.\n         */\n        function _postMessageByPass(msg) {\n            ternPromise.done(function () {\n                if (config.debug) {\n                    console.debug(\"Sending message\", msg);\n                }\n                IndexingWorker.execPeer(\"invokeTernCommand\", msg);\n            });\n        }\n\n        /**\n         *  Update tern with the new contents of a given file.\n         *\n         * @param {Document} document - the document to update\n         * @return {jQuery.Promise} - the promise for the request\n         */\n        function updateTernFile(document) {\n            var path  = document.file.fullPath;\n\n            _postMessageByPass({\n                type: MessageIds.TERN_UPDATE_FILE_MSG,\n                path: path,\n                text: getTextFromDocument(document)\n            });\n\n            return addPendingRequest(path, OFFSET_ZERO, MessageIds.TERN_UPDATE_FILE_MSG);\n        }\n\n        /**\n         * Handle a request from the tern node domain for text of a file\n         *\n         * @param {{file:string}} request - the request from the tern node domain.  Should be an Object containing the name\n         *      of the file tern wants the contents of\n         */\n        function handleTernGetFile(request) {\n\n            function replyWith(name, txt) {\n                _postMessageByPass({\n                    type: MessageIds.TERN_GET_FILE_MSG,\n                    file: name,\n                    text: txt\n                });\n            }\n\n            var name = request.file;\n\n            /**\n             * Helper function to get the text of a given document and send it to tern.\n             * If DocumentManager successfully gets the file's text then we'll send it to the tern node domain.\n             * The Promise for getDocumentText() is returned so that custom fail functions can be used.\n             *\n             * @param {string} filePath - the path of the file to get the text of\n             * @return {jQuery.Promise} - the Promise returned from DocumentMangaer.getDocumentText()\n             */\n            function getDocText(filePath) {\n                if (!FileSystem.isAbsolutePath(filePath) || // don't handle URLs\n                        filePath.slice(0, 2) === \"//\") { // don't handle protocol-relative URLs like //example.com/main.js (see #10566)\n                    return (new $.Deferred()).reject().promise();\n                }\n\n                var file = FileSystem.getFileForPath(filePath),\n                    promise = DocumentManager.getDocumentText(file);\n\n                promise.done(function (docText) {\n                    resolvedFiles[name] = filePath;\n                    numResolvedFiles++;\n                    replyWith(name, filterText(docText));\n                });\n                return promise;\n            }\n\n            /**\n             * Helper function to find any files in the project that end with the\n             * name we are looking for.  This is so we can find requirejs modules\n             * when the baseUrl is unknown, or when the project root is not the same\n             * as the script root (e.g. if you open the 'brackets' dir instead of 'brackets/src' dir).\n             */\n            function findNameInProject() {\n                // check for any files in project that end with the right path.\n                var fileName = name.substring(name.lastIndexOf(\"/\") + 1);\n\n                function _fileFilter(entry) {\n                    return entry.name === fileName;\n                }\n\n                ProjectManager.getAllFiles(_fileFilter).done(function (files) {\n                    var file;\n                    files = files.filter(function (file) {\n                        var pos = file.fullPath.length - name.length;\n                        return pos === file.fullPath.lastIndexOf(name);\n                    });\n\n                    if (files.length === 1) {\n                        file = files[0];\n                    }\n                    if (file) {\n                        getDocText(file.fullPath).fail(function () {\n                            replyWith(name, \"\");\n                        });\n                    } else {\n                        replyWith(name, \"\");\n                    }\n                });\n            }\n\n            if (!isFileExcludedInternal(name)) {\n                getDocText(name).fail(function () {\n                    getDocText(rootTernDir + name).fail(function () {\n                        // check relative to project root\n                        getDocText(projectRoot + name)\n                            // last look for any files that end with the right path\n                            // in the project\n                            .fail(findNameInProject);\n                    });\n                });\n            }\n        }\n\n        /**\n         *  Prime the pump for a fast first lookup.\n         *\n         * @param {string} path - full path of file\n         * @return {jQuery.Promise} - the promise for the request\n         */\n        function primePump(path, isUntitledDoc) {\n            _postMessageByPass({\n                type: MessageIds.TERN_PRIME_PUMP_MSG,\n                path: path,\n                isUntitledDoc: isUntitledDoc\n            });\n\n            return addPendingRequest(path, OFFSET_ZERO, MessageIds.TERN_PRIME_PUMP_MSG);\n        }\n\n        /**\n         * Handle the response from the tern node domain when\n         * it responds to the prime pump message.\n         *\n         * @param {{path: string, type: string}} response - the response from node domain\n         */\n        function handlePrimePumpCompletion(response) {\n\n            var path = response.path,\n                type = response.type,\n                $deferredHints = getPendingRequest(path, OFFSET_ZERO, type);\n\n            if ($deferredHints) {\n                $deferredHints.resolve();\n            }\n        }\n\n        /**\n         *  Add new files to tern, keeping any previous files.\n         *  The tern server must be initialized before making\n         *  this call.\n         *\n         * @param {Array.<string>} files - array of file to add to tern.\n         * @return {boolean} - true if more files may be added, false if maximum has been reached.\n         */\n        function addFilesToTern(files) {\n            // limit the number of files added to tern.\n            var maxFileCount = preferences.getMaxFileCount();\n            if (numResolvedFiles + numAddedFiles < maxFileCount) {\n                var available = maxFileCount - numResolvedFiles - numAddedFiles;\n\n                if (available < files.length) {\n                    files = files.slice(0, available);\n                }\n\n                numAddedFiles += files.length;\n                ternPromise.done(function () {\n                    var msg = {\n                        type: MessageIds.TERN_ADD_FILES_MSG,\n                        files: files\n                    };\n\n                    if (config.debug) {\n                        console.debug(\"Sending message\", msg);\n                    }\n                    IndexingWorker.execPeer(\"invokeTernCommand\", msg);\n                });\n\n            } else {\n                stopAddingFiles = true;\n            }\n\n            return stopAddingFiles;\n        }\n\n        /**\n         *  Add the files in the directory and subdirectories of a given directory\n         *  to tern.\n         *\n         * @param {string} dir - the root directory to add.\n         * @param {function ()} doneCallback - called when all files have been\n         * added to tern.\n         */\n        function addAllFilesAndSubdirectories(dir, doneCallback) {\n            FileSystem.resolve(dir, function (err, directory) {\n                function visitor(entry) {\n                    if (entry.isFile) {\n                        if (!isFileExcluded(entry)) { // ignore .dotfiles and non-.js files\n                            addFilesToTern([entry.fullPath]);\n                        }\n                    } else {\n                        return !isDirectoryExcluded(entry.fullPath) &&\n                            entry.name.indexOf(\".\") !== 0 &&\n                            !stopAddingFiles;\n                    }\n                }\n\n                if (err) {\n                    return;\n                }\n\n                if (dir === FileSystem.getDirectoryForPath(rootTernDir)) {\n                    doneCallback();\n                    return;\n                }\n\n                directory.visit(visitor, doneCallback);\n            });\n        }\n\n        /**\n         * Init the Tern module that does all the code hinting work.\n         */\n        function initTernModule() {\n            let moduleDeferred = $.Deferred();\n            ternPromise = moduleDeferred.promise();\n\n            function _ternWorkerEventHandler(evt, data) {\n                if (config.debug) {\n                    console.log(\"Message received\", data.type);\n                }\n\n                var response = data,\n                    type = response.type;\n\n                if (type === MessageIds.TERN_COMPLETIONS_MSG ||\n                    type === MessageIds.TERN_CALLED_FUNC_TYPE_MSG) {\n                    // handle any completions the tern server calculated\n                    handleTernCompletions(response);\n                } else if (type === MessageIds.TERN_GET_FILE_MSG) {\n                    // handle a request for the contents of a file\n                    handleTernGetFile(response);\n                } else if (type === MessageIds.TERN_JUMPTODEF_MSG) {\n                    handleJumptoDef(response);\n                } else if (type === MessageIds.TERN_SCOPEDATA_MSG) {\n                    handleScopeData(response);\n                } else if (type === MessageIds.TERN_REFS) {\n                    handleRename(response);\n                } else if (type === MessageIds.TERN_PRIME_PUMP_MSG) {\n                    handlePrimePumpCompletion(response);\n                } else if (type === MessageIds.TERN_GET_GUESSES_MSG) {\n                    handleGetGuesses(response);\n                } else if (type === MessageIds.TERN_UPDATE_FILE_MSG) {\n                    handleUpdateFile(response);\n                } else if (type === MessageIds.TERN_INFERENCE_TIMEDOUT) {\n                    handleTimedOut(response);\n                } else if (type === MessageIds.TERN_WORKER_READY) {\n                    moduleDeferred.resolveWith(null);\n                } else {\n                    console.error(\"Tern Module received unknown event: \" + (response.log || response));\n                }\n            }\n\n            if(!ternConfigInitDone){\n                ternConfigInitDone = true;\n                IndexingWorker.off(\"tern-data\");\n                IndexingWorker.on(\"tern-data\", _ternWorkerEventHandler);\n                IndexingWorker.execPeer(\"invokeTernCommand\", {\n                    type: MessageIds.SET_CONFIG,\n                    config: config\n                }).then(()=>{\n                    moduleDeferred.resolveWith(null);\n                });\n            } else {\n                IndexingWorker.off(\"tern-data\");\n                IndexingWorker.on(\"tern-data\", _ternWorkerEventHandler);\n                IndexingWorker.execPeer(\"resetTernServer\");\n            }\n        }\n\n        /**\n         * Create a new tern server.\n         */\n        function initTernServer(dir, files) {\n            initTernModule();\n            numResolvedFiles = 0;\n            numAddedFiles = 0;\n            stopAddingFiles = false;\n            numInitialFiles = files.length;\n\n            ternPromise.done(function () {\n                var msg = {\n                    type: MessageIds.TERN_INIT_MSG,\n                    dir: dir,\n                    files: files,\n                    env: ternEnvironment,\n                    timeout: PreferencesManager.get(\"jscodehints.inferenceTimeout\")\n                };\n                IndexingWorker.execPeer(\"invokeTernCommand\", msg);\n            });\n            rootTernDir = dir + \"/\";\n        }\n\n        /**\n         *  We can skip tern initialization if we are opening a file that has\n         *  already been added to tern.\n         *\n         * @param {string} newFile - full path of new file being opened in the editor.\n         * @return {boolean} - true if tern initialization should be skipped,\n         * false otherwise.\n         */\n        function canSkipTernInitialization(newFile) {\n            return resolvedFiles[newFile] !== undefined;\n        }\n\n\n        /**\n         *  Do the work to initialize a code hinting session.\n         *\n         * @param {Session} session - the active hinting session (TODO: currently unused)\n         * @param {!Document} document - the document the editor has changed to\n         * @param {?Document} previousDocument - the document the editor has changed from\n         */\n        function doEditorChange(session, document, previousDocument) {\n            var file        = document.file,\n                path        = file.fullPath,\n                dir         = file.parentPath,\n                pr;\n\n            var addFilesDeferred = $.Deferred();\n\n            documentChanges = null;\n            addFilesPromise = addFilesDeferred.promise();\n            pr = ProjectManager.getProjectRoot() ? ProjectManager.getProjectRoot().fullPath : null;\n\n            // avoid re-initializing tern if possible.\n            if (canSkipTernInitialization(path)) {\n\n                // update the previous document in tern to prevent stale files.\n                if (isDocumentDirty && previousDocument) {\n                    var updateFilePromise = updateTernFile(previousDocument);\n                    updateFilePromise.done(function () {\n                        primePump(path, document.isUntitled());\n                        addFilesDeferred.resolveWith(null);\n                    });\n                } else {\n                    addFilesDeferred.resolveWith(null);\n                }\n\n                isDocumentDirty = false;\n                return;\n            }\n\n            if (previousDocument && previousDocument.isDirty) {\n                updateTernFile(previousDocument);\n            }\n\n            isDocumentDirty = false;\n            resolvedFiles = {};\n            projectRoot = pr;\n\n            ensurePreferences();\n            deferredPreferences.done(function () {\n                if (file instanceof InMemoryFile) {\n                    initTernServer(pr, []);\n                    var hintsPromise = primePump(path, true);\n                    hintsPromise.done(function () {\n                        addFilesDeferred.resolveWith(null);\n                    });\n                    return;\n                }\n\n                FileSystem.resolve(dir, function (err, directory) {\n                    if (err) {\n                        console.error(\"Error resolving\", dir);\n                        addFilesDeferred.resolveWith(null);\n                        return;\n                    }\n\n                    directory.getContents(function (err, contents) {\n                        if (err) {\n                            console.error(\"Error getting contents for\", directory);\n                            addFilesDeferred.resolveWith(null);\n                            return;\n                        }\n\n                        var files = contents\n                            .filter(function (entry) {\n                                return entry.isFile && !isFileExcluded(entry);\n                            })\n                            .map(function (entry) {\n                                return entry.fullPath;\n                            });\n\n                        initTernServer(dir, files);\n\n                        var hintsPromise = primePump(path, false);\n                        hintsPromise.done(function () {\n                            if (!usingModules()) {\n                                // Read the subdirectories of the new file's directory.\n                                // Read them first in case there are too many files to\n                                // read in the project.\n                                addAllFilesAndSubdirectories(dir, function () {\n                                    // If the file is in the project root, then read\n                                    // all the files under the project root.\n                                    var currentDir = (dir + \"/\");\n                                    if (projectRoot && currentDir !== projectRoot &&\n                                            currentDir.indexOf(projectRoot) === 0) {\n                                        addAllFilesAndSubdirectories(projectRoot, function () {\n                                            // prime the pump again but this time don't wait\n                                            // for completion.\n                                            primePump(path, false);\n                                            addFilesDeferred.resolveWith(null);\n                                        });\n                                    } else {\n                                        addFilesDeferred.resolveWith(null);\n                                    }\n                                });\n                            } else {\n                                addFilesDeferred.resolveWith(null);\n                            }\n                        });\n                    });\n                });\n            });\n        }\n\n        /**\n         * Called each time a new editor becomes active.\n         *\n         * @param {Session} session - the active hinting session (TODO: currently unused by doEditorChange())\n         * @param {!Document} document - the document of the editor that has changed\n         * @param {?Document} previousDocument - the document of the editor is changing from\n         */\n        function handleEditorChange(session, document, previousDocument) {\n            if (addFilesPromise === null) {\n                doEditorChange(session, document, previousDocument);\n            } else {\n                addFilesPromise.done(function () {\n                    doEditorChange(session, document, previousDocument);\n                });\n            }\n        }\n\n        /**\n         * Do some cleanup when a project is closed.\n         *\n         * We can clean up the node tern server we use to calculate hints now, since\n         * we know we will need to re-init it in any new project that is opened.\n         */\n        function resetModule() {\n            function resetTernServer() {\n                IndexingWorker.execPeer('resetTernServer');\n            }\n\n            if (addFilesPromise) {\n                // If we're in the middle of added files, don't reset\n                // until we're done\n                addFilesPromise.done(resetTernServer).fail(resetTernServer);\n            } else {\n                resetTernServer();\n            }\n        }\n\n        function whenReady(func) {\n            addFilesPromise.done(func);\n        }\n\n        this.resetModule = resetModule;\n        this.handleEditorChange = handleEditorChange;\n        this.postMessage = postMessage;\n        this.getResolvedPath = getResolvedPath;\n        this.whenReady = whenReady;\n\n        return this;\n    }\n\n    var resettingDeferred = null;\n\n    /**\n     * reset the tern module, if necessary.\n     *\n     * During debugging, you can turn this automatic resetting behavior off\n     * by running this in the console:\n     * brackets._configureJSCodeHints({ noReset: true })\n     *\n     * This function is also used in unit testing with the \"force\" flag to\n     * reset the module for each test to start with a clean environment.\n     *\n     * @param {Session} session\n     * @param {Document} document\n     * @param {boolean} force true to force a reset regardless of how long since the last one\n     * @return {Promise} Promise resolved when the module is ready.\n     *                   The new (or current, if there was no reset) module is passed to the callback.\n     */\n    function _maybeReset(session, document, force) {\n        var newTernModule;\n        // if we're in the middle of a reset, don't have to check\n        // the new module will be online soon\n        if (!resettingDeferred) {\n\n            // We don't reset if the debugging flag is set\n            // because it's easier to debug if the module isn't\n            // getting reset all the time.\n            if (currentModule.resetForced || force || (!config.noReset && ++_hintCount > MAX_HINTS)) {\n                if (config.debug) {\n                    console.debug(\"Resetting tern module\");\n                }\n\n                resettingDeferred = new $.Deferred();\n                newTernModule = new TernModule();\n                newTernModule.handleEditorChange(session, document, null);\n                newTernModule.whenReady(function () {\n                    // reset the old module\n                    currentModule.resetModule();\n                    currentModule = newTernModule;\n                    resettingDeferred.resolve(currentModule);\n                    // all done reseting\n                    resettingDeferred = null;\n                });\n                _hintCount = 0;\n            } else {\n                var d = new $.Deferred();\n                d.resolve(currentModule);\n                return d.promise();\n            }\n        }\n\n        return resettingDeferred.promise();\n    }\n\n    /**\n     * Request a parameter hint from Tern.\n     *\n     * @param {Session} session - the active hinting session\n     * @param {{line: number, ch: number}} functionOffset - the offset of the function call.\n     * @return {jQuery.Promise} - The promise will not complete until the\n     *      hint has completed.\n     */\n    function requestParameterHint(session, functionOffset) {\n        var $deferredHints = $.Deferred(),\n            fileInfo = getFileInfo(session, true),\n            offset = getOffset(session, fileInfo, functionOffset),\n            fnTypePromise = getTernFunctionType(fileInfo, offset);\n\n        $.when(fnTypePromise).done(\n            function (fnType) {\n                session.setFnType(fnType);\n                session.setFunctionCallPos(functionOffset);\n                $deferredHints.resolveWith(null, [fnType]);\n            }\n        ).fail(function () {\n            $deferredHints.reject();\n        });\n\n        return $deferredHints.promise();\n    }\n\n    /**\n     * Request hints from Tern.\n     *\n     * Note that successive calls to getScope may return the same objects, so\n     * clients that wish to modify those objects (e.g., by annotating them based\n     * on some temporary context) should copy them first. See, e.g.,\n     * Session.getHints().\n     *\n     * @param {Session} session - the active hinting session\n     * @param {Document} document - the document for which scope info is\n     *      desired\n     * @return {jQuery.Promise} - The promise will not complete until the tern\n     *      hints have completed.\n     */\n    function requestHints(session, document) {\n        var $deferredHints = $.Deferred(),\n            hintPromise,\n            sessionType = session.getType(),\n            fileInfo = getFileInfo(session),\n            offset = getOffset(session, fileInfo, null);\n\n        _maybeReset(session, document);\n\n        hintPromise = getTernHints(fileInfo, offset, sessionType.property);\n\n        $.when(hintPromise).done(\n            function (completions, fnType) {\n                if (completions.completions) {\n                    session.setTernHints(completions.completions);\n                    session.setGuesses(null);\n                } else {\n                    session.setTernHints([]);\n                    session.setGuesses(completions.properties);\n                }\n\n                $deferredHints.resolveWith(null);\n            }\n        ).fail(function () {\n            $deferredHints.reject();\n        });\n\n        return $deferredHints.promise();\n    }\n\n    /**\n     *  Track the update area of the current document so we can tell if we can send\n     *  partial updates to tern or not.\n     *\n     * @param {Array.<{from: {line:number, ch: number}, to: {line:number, ch: number},\n     *     text: Array<string>}>} changeList - the document changes from the current change event\n     */\n    function trackChange(changeList) {\n        var changed = documentChanges, i;\n        if (changed === null) {\n            documentChanges = changed = {from: changeList[0].from.line, to: changeList[0].from.line};\n            if (config.debug) {\n                console.debug(\"ScopeManager: document has changed\");\n            }\n        }\n\n        for (i = 0; i < changeList.length; i++) {\n            var thisChange = changeList[i],\n                end = thisChange.from.line + (thisChange.text.length - 1);\n            if (thisChange.from.line < changed.to) {\n                changed.to = changed.to - (thisChange.to.line - end);\n            }\n\n            if (end >= changed.to) {\n                changed.to = end + 1;\n            }\n\n            if (changed.from > thisChange.from.line) {\n                changed.from = thisChange.from.line;\n            }\n        }\n    }\n\n    /*\n     * Called each time the file associated with the active editor changes.\n     * Marks the file as being dirty.\n     *\n     * @param {from: {line:number, ch: number}, to: {line:number, ch: number}}\n     */\n    function handleFileChange(changeList) {\n        isDocumentDirty = true;\n        trackChange(changeList);\n    }\n\n    /**\n     * Called each time a new editor becomes active.\n     *\n     * @param {Session} session - the active hinting session\n     * @param {Document} document - the document of the editor that has changed\n     * @param {?Document} previousDocument - the document of the editor is changing from\n     */\n    function handleEditorChange(session, document, previousDocument) {\n\n        if (!currentModule) {\n            currentModule = new TernModule();\n        }\n\n        return currentModule.handleEditorChange(session, document, previousDocument);\n    }\n\n    /**\n     * Do some cleanup when a project is closed.\n     * Clean up previous analysis data from the module\n     */\n    function handleProjectClose() {\n        if (currentModule) {\n            currentModule.resetModule();\n        }\n    }\n\n    /**\n     *  Read in project preferences when a new project is opened.\n     *  Look in the project root directory for a preference file.\n     *\n     *  @param {string=} projectRootPath - new project root path(optional).\n     *  Only needed for unit tests.\n     */\n    function handleProjectOpen(projectRootPath) {\n        initPreferences(projectRootPath);\n    }\n\n    /** Used to avoid timing bugs in unit tests */\n    function _readyPromise() {\n        return deferredPreferences;\n    }\n\n    /**\n     * @private\n     *\n     * Update the configuration in the tern node domain.\n     */\n    function _setConfig(configUpdate) {\n        config = brackets._configureJSCodeHints.config;\n        postMessage({\n            type: MessageIds.SET_CONFIG,\n            config: configUpdate\n        });\n    }\n\n    exports._setConfig = _setConfig;\n    exports._maybeReset = _maybeReset;\n    exports.getBuiltins = getBuiltins;\n    exports.getResolvedPath = getResolvedPath;\n    exports.getTernHints = getTernHints;\n    exports.handleEditorChange = handleEditorChange;\n    exports.requestGuesses = requestGuesses;\n    exports.handleFileChange = handleFileChange;\n    exports.requestHints = requestHints;\n    exports.requestJumptoDef = requestJumptoDef;\n    exports.requestParameterHint = requestParameterHint;\n    exports.handleProjectClose = handleProjectClose;\n    exports.handleProjectOpen = handleProjectOpen;\n    exports._readyPromise = _readyPromise;\n    exports.filterText = filterText;\n    exports.postMessage = postMessage;\n    exports.addPendingRequest = addPendingRequest;\n});\n"],"file":"ScopeManager.js"}
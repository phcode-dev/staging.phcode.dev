{"version":3,"sources":["JSUtils/ScopeManager.js"],"names":["define","require","exports","module","_","CodeMirror","DefaultDialogs","Dialogs","DocumentManager","EditorManager","FileSystem","FileUtils","LanguageManager","PreferencesManager","ProjectManager","Strings","StringUtils","InMemoryFile","IndexingWorker","loadScriptInWorker","Phoenix","baseURL","HintUtils","MessageIds","JSON","parse","Preferences","ternEnvironment","ternConfigInitDone","pendingTernRequests","builtinLibraryNames","isDocumentDirty","_hintCount","currentModule","documentChanges","preferences","deferredPreferences","MAX_HINTS","LARGE_LINE_CHANGE","LARGE_LINE_COUNT","OFFSET_ZERO","line","ch","config","getBuiltins","initTernEnv","builtinDefinitionFiles","fileName","fileUrl","console","log","fetch","then","async","ternDefsLibrary","contents","json","push","catch","e","error","initPreferences","projectRootPath","state","reject","$","Deferred","pr","getProjectRoot","fullPath","path","FILE_NAME","resolve","err","file","readAsText","done","text","configObj","SyntaxError","message","fail","ensurePreferences","postMessage","msg","isDirectoryExcluded","excludes","getExcludedDirectories","testPath","makeProjectRelativeIfPossible","stripTrailingSlash","test","isFileBeingEdited","filePath","currentEditor","getActiveEditor","currentDoc","document","isFileExcludedInternal","detectedExclusions","get","indexOf","isFileExcluded","name","languageID","getLanguageForPath","getId","LANGUAGE_ID","getExcludedFiles","addPendingRequest","offset","type","requests","key","$deferredRequest","promise","has","getPendingRequest","requestType","Object","keys","length","getResolvedPath","getJumptoDef","fileInfo","TERN_JUMPTODEF_MSG","filterText","newText","getMaxFileSize","getTextFromDocument","getText","handleRename","response","displayErrorMessageAtCursor","$deferredFindRefs","TERN_REFS","resolveWith","requestJumptoDef","session","ternPromise","TERN_FILE_INFO_TYPE_FULL","offsetLines","getJavascriptText","handleJumptoDef","$deferredJump","resultFile","handleScopeData","TERN_SCOPEDATA_MSG","getTernHints","isProperty","TERN_COMPLETIONS_MSG","getTernFunctionType","TERN_CALLED_FUNC_TYPE_MSG","getFragmentAround","start","minIndent","minLine","endLine","cm","editor","_codeMirror","tabSize","getOption","p","min","indent","Math","max","fn","getLine","search","countColumn","getToken","lastLine","endCh","from","to","TERN_FILE_INFO_TYPE_PART","getRange","getFileInfo","preventPartialUpdates","getCursor","end","isHtmlFile","result","lineCount","TERN_FILE_INFO_TYPE_EMPTY","getOffset","newOffset","requestGuesses","$deferred","TERN_GET_GUESSES_MSG","guesses","setGuesses","handleTernCompletions","completions","properties","fnType","$deferredHints","handleGetGuesses","handleUpdateFile","handleTimedOut","set","location","scope","showModalDialog","DIALOG_ID_INFO","DETECTED_EXCLUSION_TITLE","format","DETECTED_EXCLUSION_INFO","breakableUrl","className","DIALOG_BTN_CLASS_PRIMARY","id","DIALOG_BTN_OK","OK","TernModule","addFilesPromise","rootTernDir","projectRoot","stopAddingFiles","resolvedFiles","numInitialFiles","numResolvedFiles","numAddedFiles","usingModules","debug","execPeer","_postMessageByPass","updateTernFile","TERN_UPDATE_FILE_MSG","handleTernGetFile","request","replyWith","txt","TERN_GET_FILE_MSG","getDocText","startsWith","isAbsolutePath","slice","getFileForPath","getDocumentText","docText","findNameInProject","substring","lastIndexOf","_fileFilter","entry","getAllFiles","files","filter","pos","primePump","isUntitledDoc","TERN_PRIME_PUMP_MSG","handlePrimePumpCompletion","addFilesToTern","maxFileCount","getMaxFileCount","available","TERN_ADD_FILES_MSG","addAllFilesAndSubdirectories","dir","doneCallback","directory","visitor","isFile","getDirectoryForPath","visit","initTernModule","moduleDeferred","_ternWorkerEventHandler","evt","data","TERN_INFERENCE_TIMEDOUT","TERN_WORKER_READY","off","on","SET_CONFIG","initTernServer","TERN_INIT_MSG","env","timeout","endsWith","canSkipTernInitialization","newFile","undefined","doEditorChange","previousDocument","parentPath","addFilesDeferred","updateFilePromise","isUntitled","isDirty","hintsPromise","getContents","map","currentDir","handleEditorChange","resetModule","resetTernServer","whenReady","func","this","event","changedDoc","TERN_UPDATE_DIRTY_FILE","action","TERN_CLEAR_DIRTY_FILES_LIST","resettingDeferred","_maybeReset","force","newTernModule","resetForced","noReset","d","requestParameterHint","functionOffset","fnTypePromise","when","setFnType","setFunctionCallPos","requestHints","hintPromise","sessionType","getType","property","setTernHints","trackChange","changeList","changed","i","thisChange","handleFileChange","handleProjectClose","handleProjectOpen","_readyPromise","_setConfig","configUpdate","brackets","_configureJSCodeHints"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global Phoenix*/\n\n/*\n * Throughout this file, the term \"outer scope\" is used to refer to the outer-\n * most/global/root Scope objects for particular file. The term \"inner scope\"\n * is used to refer to a Scope object that is reachable via the child relation\n * from an outer scope.\n */\n\ndefine(function (require, exports, module) {\n\n\n    var _ = require(\"thirdparty/lodash\");\n\n    const CodeMirror          = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        DefaultDialogs      = require(\"widgets/DefaultDialogs\"),\n        Dialogs             = require(\"widgets/Dialogs\"),\n        DocumentManager     = require(\"document/DocumentManager\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        LanguageManager     = require(\"language/LanguageManager\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        ProjectManager      = require(\"project/ProjectManager\"),\n        Strings             = require(\"strings\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        InMemoryFile        = require(\"document/InMemoryFile\"),\n        IndexingWorker      = require(\"worker/IndexingWorker\");\n\n    IndexingWorker.loadScriptInWorker(`${Phoenix.baseURL}JSUtils/worker/tern-main.js`);\n\n    var HintUtils           = require(\"./HintUtils\"),\n        MessageIds          = JSON.parse(require(\"text!./MessageIds.json\")),\n        Preferences         = require(\"./Preferences\");\n\n    let ternEnvironment     = [],\n        ternConfigInitDone        = false,\n        pendingTernRequests = {},\n        builtinLibraryNames = [],\n        isDocumentDirty     = false,\n        _hintCount          = 0,\n        currentModule       = null,\n        documentChanges     = null,     // bounds of document changes\n        preferences         = null,\n        deferredPreferences = null;\n\n\n    const MAX_HINTS           = 30,  // how often to reset the tern server\n        LARGE_LINE_CHANGE   = 100,\n        LARGE_LINE_COUNT    = 10000,\n        OFFSET_ZERO         = {line: 0, ch: 0};\n\n    var config = {};\n\n    /**\n     *  An array of library names that contain JavaScript builtins definitions.\n     *\n     * @return {Array.<string>} - array of library  names.\n     */\n    function getBuiltins() {\n        return builtinLibraryNames;\n    }\n\n    /**\n     * Read in the json files that have type information for the builtins, dom,etc\n     */\n    function initTernEnv() {\n        const builtinDefinitionFiles = JSON.parse(require(\"text!thirdparty/tern/defs/defs.json\"));\n\n        for(let fileName of builtinDefinitionFiles){\n            let fileUrl = `${Phoenix.baseURL}thirdparty/tern/defs/${fileName}`;\n            console.log(\"loading tern definition file: \", fileUrl);\n            fetch(fileUrl)\n                .then(async contents =>{\n                    const ternDefsLibrary = await contents.json();\n                    builtinLibraryNames.push(ternDefsLibrary[\"!name\"]);\n                    ternEnvironment.push(ternDefsLibrary);\n                })\n                .catch(e =>{\n                    console.error(\"failed to init from tern definition file \" + fileName, e);\n                });\n        }\n    }\n\n    initTernEnv();\n\n    /**\n     *  Init preferences from a file in the project root or builtin\n     *  defaults if no file is found;\n     *\n     *  @param {string=} projectRootPath - new project root path. Only needed\n     *  for unit tests.\n     */\n    function initPreferences(projectRootPath) {\n\n        // Reject the old preferences if they have not completed.\n        if (deferredPreferences && deferredPreferences.state() === \"pending\") {\n            deferredPreferences.reject();\n        }\n\n        deferredPreferences = $.Deferred();\n        var pr = ProjectManager.getProjectRoot();\n\n        // Open preferences relative to the project root\n        // Normally there is a project root, but for unit tests we need to\n        // pass in a project root.\n        if (pr) {\n            projectRootPath = pr.fullPath;\n        } else if (!projectRootPath) {\n            console.log(\"initPreferences: projectRootPath has no value. Using Defaults.\");\n            preferences = new Preferences();\n            return;\n        }\n\n        var path = projectRootPath + Preferences.FILE_NAME;\n\n        FileSystem.resolve(path, function (err, file) {\n            if (!err) {\n                FileUtils.readAsText(file).done(function (text) {\n                    var configObj = null;\n                    try {\n                        configObj = JSON.parse(text);\n                    } catch (e) {\n                        // continue with null configObj which will result in\n                        // default settings.\n                        console.log(\"Error parsing preference file: \" + path);\n                        if (e instanceof SyntaxError) {\n                            console.log(e.message);\n                        }\n                    }\n                    preferences = new Preferences(configObj);\n                    deferredPreferences.resolve();\n                }).fail(function (error) {\n                    preferences = new Preferences();\n                    deferredPreferences.resolve();\n                });\n            } else {\n                preferences = new Preferences();\n                deferredPreferences.resolve();\n            }\n        });\n    }\n\n    /**\n     * Will initialize preferences only if they do not exist.\n     *\n     */\n    function ensurePreferences() {\n        if (!deferredPreferences) {\n            initPreferences();\n        }\n    }\n\n    /**\n     * Send a message to the tern module - if the module is being initialized,\n     * the message will not be posted until initialization is complete\n     */\n    function postMessage(msg) {\n        if (currentModule) {\n            currentModule.postMessage(msg);\n        }\n    }\n\n    /**\n     * Test if the directory should be excluded from analysis.\n     *\n     * @param {!string} path - full directory path.\n     * @return {boolean} true if excluded, false otherwise.\n     */\n    function isDirectoryExcluded(path) {\n        var excludes = preferences.getExcludedDirectories();\n\n        if (!excludes) {\n            return false;\n        }\n\n        var testPath = ProjectManager.makeProjectRelativeIfPossible(path);\n        testPath = FileUtils.stripTrailingSlash(testPath);\n\n        return excludes.test(testPath);\n    }\n\n    /**\n     * Test if the file path is in current editor\n     *\n     * @param {string} filePath file path to test for exclusion.\n     * @return {boolean} true if in editor, false otherwise.\n     */\n    function isFileBeingEdited(filePath) {\n        var currentEditor   = EditorManager.getActiveEditor(),\n            currentDoc      = currentEditor && currentEditor.document;\n\n        return (currentDoc && currentDoc.file.fullPath === filePath);\n    }\n\n    /**\n     * Test if the file path is an internal exclusion.\n     *\n     * @param {string} path file path to test for exclusion.\n     * @return {boolean} true if excluded, false otherwise.\n     */\n    function isFileExcludedInternal(path) {\n        // The detectedExclusions are files detected to be troublesome with current versions of Tern.\n        // detectedExclusions is an array of full paths.\n        var detectedExclusions = PreferencesManager.get(\"jscodehints.detectedExclusions\") || [];\n        if (detectedExclusions && detectedExclusions.indexOf(path) !== -1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Test if the file should be excluded from analysis.\n     *\n     * @param {!File} file - file to test for exclusion.\n     * @return {boolean} true if excluded, false otherwise.\n     */\n    function isFileExcluded(file) {\n        if (file.name[0] === \".\") {\n            return true;\n        }\n\n        var languageID = LanguageManager.getLanguageForPath(file.fullPath).getId();\n        if (languageID !== HintUtils.LANGUAGE_ID) {\n            return true;\n        }\n\n        var excludes = preferences.getExcludedFiles();\n        if (excludes && excludes.test(file.name)) {\n            return true;\n        }\n\n        if (isFileExcludedInternal(file.fullPath)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Add a pending request waiting for the tern-module to complete.\n     * If file is a detected exclusion, then reject request.\n     *\n     * @param {string} file - the name of the file\n     * @param {{line: number, ch: number}} offset - the offset into the file the request is for\n     * @param {string} type - the type of request\n     * @return {jQuery.Promise} - the promise for the request\n     */\n    function addPendingRequest(file, offset, type) {\n        var requests,\n            key = file + \"@\" + offset.line + \"@\" + offset.ch,\n            $deferredRequest;\n\n        // Reject detected exclusions\n        if (isFileExcludedInternal(file)) {\n            return (new $.Deferred()).reject().promise();\n        }\n\n        if (_.has(pendingTernRequests, key)) {\n            requests = pendingTernRequests[key];\n        } else {\n            requests = {};\n            pendingTernRequests[key] = requests;\n        }\n\n        if (_.has(requests, type)) {\n            $deferredRequest = requests[type];\n        } else {\n            requests[type] = $deferredRequest = new $.Deferred();\n        }\n        return $deferredRequest.promise();\n    }\n\n    /**\n     * Get any pending $.Deferred object waiting on the specified file and request type\n     * @param {string} file - the file\n     * @param {{line: number, ch: number}} offset - the offset into the file the request is for\n     * @param {string} type - the type of request\n     * @return {jQuery.Deferred} - the $.Deferred for the request\n     */\n    function getPendingRequest(file, offset, type) {\n        var key = file + \"@\" + offset.line + \"@\" + offset.ch;\n        if (_.has(pendingTernRequests, key)) {\n            var requests = pendingTernRequests[key],\n                requestType = requests[type];\n\n            delete pendingTernRequests[key][type];\n\n            if (!Object.keys(requests).length) {\n                delete pendingTernRequests[key];\n            }\n\n            return requestType;\n        }\n    }\n\n    /**\n     * @param {string} file a relative path\n     * @return {string} returns the path we resolved when we tried to parse the file, or undefined\n     */\n    function getResolvedPath(file) {\n        return currentModule.getResolvedPath(file);\n    }\n\n    /**\n     * Get a Promise for the definition from TernJS, for the file & offset passed in.\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset - the offset in the file the hints should be calculate at\n     * @return {jQuery.Promise} - a promise that will resolve to definition when\n     *      it is done\n     */\n    function getJumptoDef(fileInfo, offset) {\n        postMessage({\n            type: MessageIds.TERN_JUMPTODEF_MSG,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return addPendingRequest(fileInfo.name, offset, MessageIds.TERN_JUMPTODEF_MSG);\n    }\n\n    /**\n     * check to see if the text we are sending to Tern is too long.\n     * @param {string} the text to check\n     * @return {string} the text, or the empty text if the original was too long\n     */\n    function filterText(text) {\n        var newText = text;\n        if (text.length > preferences.getMaxFileSize()) {\n            newText = \"\";\n        }\n        return newText;\n    }\n\n    /**\n     * Get the text of a document, applying any size restrictions\n     * if necessary\n     * @param {Document} document - the document to get the text from\n     * @return {string} the text, or the empty text if the original was too long\n     */\n    function getTextFromDocument(document) {\n        var text = document.getText();\n        text = filterText(text);\n        return text;\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the references\n     *\n     * @param response - the response from the node domain\n     */\n    function handleRename(response) {\n\n        if (response.error) {\n            EditorManager.getActiveEditor().displayErrorMessageAtCursor(response.error);\n            return;\n        }\n\n        var file = response.file,\n            offset = response.offset;\n\n        var $deferredFindRefs = getPendingRequest(file, offset, MessageIds.TERN_REFS);\n\n        if ($deferredFindRefs) {\n            $deferredFindRefs.resolveWith(null, [response]);\n        }\n    }\n\n    /**\n     * Request Jump-To-Definition from Tern.\n     *\n     * @param {session} session - the session\n     * @param {Document} document - the document\n     * @param {{line: number, ch: number}} offset - the offset into the document\n     * @return {jQuery.Promise} - The promise will not complete until tern\n     *      has completed.\n     */\n    function requestJumptoDef(session, document, offset) {\n        var path    = document.file.fullPath,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: filterText(session.getJavascriptText())\n            };\n\n        var ternPromise = getJumptoDef(fileInfo, offset);\n\n        return {promise: ternPromise};\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the definition\n     *\n     * @param response - the response from the node domain\n     */\n    function handleJumptoDef(response) {\n\n        var file = response.file,\n            offset = response.offset;\n\n        var $deferredJump = getPendingRequest(file, offset, MessageIds.TERN_JUMPTODEF_MSG);\n\n        if ($deferredJump) {\n            response.fullPath = getResolvedPath(response.resultFile);\n            $deferredJump.resolveWith(null, [response]);\n        }\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the scope data\n     *\n     * @param response - the response from the node domain\n     */\n    function handleScopeData(response) {\n        var file = response.file,\n            offset = response.offset;\n\n        var $deferredJump = getPendingRequest(file, offset, MessageIds.TERN_SCOPEDATA_MSG);\n\n        if ($deferredJump) {\n            $deferredJump.resolveWith(null, [response]);\n        }\n    }\n\n    /**\n     * Get a Promise for the completions from TernJS, for the file & offset passed in.\n     *\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset - the offset in the file the hints should be calculate at\n     * @param {boolean} isProperty - true if getting a property hint,\n     * otherwise getting an identifier hint.\n     * @return {jQuery.Promise} - a promise that will resolve to an array of completions when\n     *      it is done\n     */\n    function getTernHints(fileInfo, offset, isProperty) {\n\n        /**\n         *  If the document is large and we have modified a small portions of it that\n         *  we are asking hints for, then send a partial document.\n         */\n        postMessage({\n            type: MessageIds.TERN_COMPLETIONS_MSG,\n            fileInfo: fileInfo,\n            offset: offset,\n            isProperty: isProperty\n        });\n\n        return addPendingRequest(fileInfo.name, offset, MessageIds.TERN_COMPLETIONS_MSG);\n    }\n\n    /**\n     * Get a Promise for the function type from TernJS.\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line:number, ch:number}} offset - the line, column info for what we want the function type of.\n     * @return {jQuery.Promise} - a promise that will resolve to the function type of the function being called.\n     */\n    function getTernFunctionType(fileInfo, offset) {\n        postMessage({\n            type: MessageIds.TERN_CALLED_FUNC_TYPE_MSG,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return addPendingRequest(fileInfo.name, offset, MessageIds.TERN_CALLED_FUNC_TYPE_MSG);\n    }\n\n\n    /**\n     *  Given a starting and ending position, get a code fragment that is self contained\n     *  enough to be compiled.\n     *\n     * @param {!Session} session - the current session\n     * @param {{line: number, ch: number}} start - the starting position of the changes\n     * @return {{type: string, name: string, offsetLines: number, text: string}}\n     */\n    function getFragmentAround(session, start) {\n        var minIndent = null,\n            minLine   = null,\n            endLine,\n            cm        = session.editor._codeMirror,\n            tabSize   = cm.getOption(\"tabSize\"),\n            document  = session.editor.document,\n            p,\n            min,\n            indent,\n            line;\n\n        // expand range backwards\n        for (p = start.line - 1, min = Math.max(0, p - 100); p >= min; --p) {\n            line = session.getLine(p);\n            var fn = line.search(/\\bfunction\\b/);\n\n            if (fn >= 0) {\n                indent = CodeMirror.countColumn(line, null, tabSize);\n                if (minIndent === null || minIndent > indent) {\n                    if (session.getToken({line: p, ch: fn + 1}).type === \"keyword\") {\n                        minIndent = indent;\n                        minLine = p;\n                    }\n                }\n            }\n        }\n\n        if (minIndent === null) {\n            minIndent = 0;\n        }\n\n        if (minLine === null) {\n            minLine = min;\n        }\n\n        var max = Math.min(cm.lastLine(), start.line + 100),\n            endCh = 0;\n\n        for (endLine = start.line + 1; endLine < max; ++endLine) {\n            line = cm.getLine(endLine);\n\n            if (line.length > 0) {\n                indent = CodeMirror.countColumn(line, null, tabSize);\n                if (indent <= minIndent) {\n                    endCh = line.length;\n                    break;\n                }\n            }\n        }\n\n        var from = {line: minLine, ch: 0},\n            to   = {line: endLine, ch: endCh};\n\n        return {type: MessageIds.TERN_FILE_INFO_TYPE_PART,\n            name: document.file.fullPath,\n            offsetLines: from.line,\n            text: document.getRange(from, to)};\n    }\n\n\n    /**\n     * Get an object that describes what tern needs to know about the updated\n     * file to produce a hint. As a side-effect of this calls the document\n     * changes are reset.\n     *\n     * @param {!Session} session - the current session\n     * @param {boolean=} preventPartialUpdates - if true, disallow partial updates.\n     * Optional, defaults to false.\n     * @return {{type: string, name: string, offsetLines: number, text: string}}\n     */\n    function getFileInfo(session, preventPartialUpdates) {\n        var start = session.getCursor(),\n            end = start,\n            document = session.editor.document,\n            path = document.file.fullPath,\n            isHtmlFile = LanguageManager.getLanguageForPath(path).getId() === \"html\",\n            result;\n\n        if (isHtmlFile) {\n            result = {type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                text: session.getJavascriptText()};\n        } else if (!documentChanges) {\n            result = {type: MessageIds.TERN_FILE_INFO_TYPE_EMPTY,\n                name: path,\n                text: \"\"};\n        } else if (!preventPartialUpdates && session.editor.lineCount() > LARGE_LINE_COUNT &&\n                (documentChanges.to - documentChanges.from < LARGE_LINE_CHANGE) &&\n                documentChanges.from <= start.line &&\n                documentChanges.to > end.line) {\n            result = getFragmentAround(session, start);\n        } else {\n            result = {type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                text: getTextFromDocument(document)};\n        }\n\n        documentChanges = null;\n        return result;\n    }\n\n    /**\n     *  Get the current offset. The offset is adjusted for \"part\" updates.\n     *\n     * @param {!Session} session - the current session\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}=} offset - the default offset (optional). Will\n     * use the cursor if not provided.\n     * @return {{line: number, ch: number}}\n     */\n    function getOffset(session, fileInfo, offset) {\n        var newOffset;\n\n        if (offset) {\n            newOffset = {line: offset.line, ch: offset.ch};\n        } else {\n            newOffset = session.getCursor();\n        }\n\n        if (fileInfo.type === MessageIds.TERN_FILE_INFO_TYPE_PART) {\n            newOffset.line = Math.max(0, newOffset.line - fileInfo.offsetLines);\n        }\n\n        return newOffset;\n    }\n\n    /**\n     * Get a Promise for all of the known properties from TernJS, for the directory and file.\n     * The properties will be used as guesses in tern.\n     * @param {Session} session - the active hinting session\n     * @param {Document} document - the document for which scope info is\n     *      desired\n     * @return {jQuery.Promise} - The promise will not complete until the tern\n     *      request has completed.\n     */\n    function requestGuesses(session, document) {\n        var $deferred = $.Deferred(),\n            fileInfo = getFileInfo(session),\n            offset = getOffset(session, fileInfo);\n\n        postMessage({\n            type: MessageIds.TERN_GET_GUESSES_MSG,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        var promise = addPendingRequest(fileInfo.name, offset, MessageIds.TERN_GET_GUESSES_MSG);\n        promise.done(function (guesses) {\n            session.setGuesses(guesses);\n            $deferred.resolve();\n        }).fail(function () {\n            $deferred.reject();\n        });\n\n        return $deferred.promise();\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the list of completions\n     *\n     * @param {{file: string, offset: {line: number, ch: number}, completions:Array.<string>,\n     *          properties:Array.<string>}} response - the response from node domain\n     */\n    function handleTernCompletions(response) {\n\n        var file = response.file,\n            offset = response.offset,\n            completions = response.completions,\n            properties = response.properties,\n            fnType  = response.fnType,\n            type = response.type,\n            error = response.error,\n            $deferredHints = getPendingRequest(file, offset, type);\n\n        if ($deferredHints) {\n            if (error) {\n                $deferredHints.reject();\n            } else if (completions) {\n                $deferredHints.resolveWith(null, [{completions: completions}]);\n            } else if (properties) {\n                $deferredHints.resolveWith(null, [{properties: properties}]);\n            } else if (fnType) {\n                $deferredHints.resolveWith(null, [fnType]);\n            }\n        }\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds to the get guesses message.\n     *\n     * @param {{file: string, type: string, offset: {line: number, ch: number},\n     *      properties: Array.<string>}} response -\n     *      the response from node domain contains the guesses for a\n     *      property lookup.\n     */\n    function handleGetGuesses(response) {\n        var path = response.file,\n            type = response.type,\n            offset = response.offset,\n            $deferredHints = getPendingRequest(path, offset, type);\n\n        if ($deferredHints) {\n            $deferredHints.resolveWith(null, [response.properties]);\n        }\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds to the update file message.\n     *\n     * @param {{path: string, type: string}} response - the response from node domain\n     */\n    function handleUpdateFile(response) {\n\n        var path = response.path,\n            type = response.type,\n            $deferredHints = getPendingRequest(path, OFFSET_ZERO, type);\n\n        if ($deferredHints) {\n            $deferredHints.resolve();\n        }\n    }\n\n    /**\n     * Handle timed out inference\n     *\n     * @param {{path: string, type: string}} response - the response from node domain\n     */\n    function handleTimedOut(response) {\n\n        var detectedExclusions  = PreferencesManager.get(\"jscodehints.detectedExclusions\") || [],\n            filePath            = response.file;\n\n        // Don't exclude the file currently being edited\n        if (isFileBeingEdited(filePath)) {\n            return;\n        }\n\n        // Handle file that is already excluded\n        if (detectedExclusions.indexOf(filePath) !== -1) {\n            console.log(\"JavaScriptCodeHints.handleTimedOut: file already in detectedExclusions array timed out: \" + filePath);\n            return;\n        }\n\n        // Save detected exclusion in project prefs so no further time is wasted on it\n        detectedExclusions.push(filePath);\n        PreferencesManager.set(\"jscodehints.detectedExclusions\", detectedExclusions, { location: { scope: \"project\" } });\n\n        // Show informational dialog\n        Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_INFO,\n            Strings.DETECTED_EXCLUSION_TITLE,\n            StringUtils.format(\n                Strings.DETECTED_EXCLUSION_INFO,\n                StringUtils.breakableUrl(filePath)\n            ),\n            [\n                {\n                    className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\n                    id: Dialogs.DIALOG_BTN_OK,\n                    text: Strings.OK\n                }\n            ]\n        );\n    }\n\n    DocumentManager.on(\"dirtyFlagChange\", function (event, changedDoc) {\n        if (changedDoc.file.fullPath) {\n            postMessage({\n                type: MessageIds.TERN_UPDATE_DIRTY_FILE,\n                name: changedDoc.file.fullPath,\n                action: changedDoc.isDirty\n            });\n        }\n    });\n\n    // Clear dirty document list in tern node domain\n    ProjectManager.on(\"beforeProjectClose\", function () {\n        postMessage({\n            type: MessageIds.TERN_CLEAR_DIRTY_FILES_LIST\n        });\n    });\n\n    /**\n     * Encapsulate all the logic to talk to the tern module.  This will create\n     * a new instance of a TernModule, which the rest of the hinting code can use to talk\n     * to the tern node domain, without worrying about initialization, priming the pump, etc.\n     *\n     */\n    function TernModule() {\n        var ternPromise         = null,\n            addFilesPromise     = null,\n            rootTernDir         = null,\n            projectRoot         = null,\n            stopAddingFiles     = false,\n            resolvedFiles       = {},       // file -> resolved file\n            numInitialFiles     = 0,\n            numResolvedFiles    = 0,\n            numAddedFiles       = 0;\n\n        /**\n         * @param {string} file a relative path\n         * @return {string} returns the path we resolved when we tried to parse the file, or undefined\n         */\n        function getResolvedPath(file) {\n            return resolvedFiles[file];\n        }\n\n        /**\n         *  Determine whether the current set of files are using modules to pull in\n         *  additional files.\n         *\n         * @return {boolean} - true if more files than the current directory have\n         * been read in.\n         */\n        function usingModules() {\n            return numInitialFiles !== numResolvedFiles;\n        }\n\n        /**\n         * Send a message to the tern node domain - if the module is being initialized,\n         * the message will not be posted until initialization is complete\n         */\n        function postMessage(msg) {\n            addFilesPromise.done(function () {\n                if (config.debug) {\n                    console.debug(\"Sending message\", msg);\n                }\n                IndexingWorker.execPeer(\"invokeTernCommand\", msg);\n            });\n        }\n\n        /**\n         * Send a message to the tern node domain - this is only for messages that\n         * need to be sent before and while the addFilesPromise is being resolved.\n         */\n        function _postMessageByPass(msg) {\n            ternPromise.done(function () {\n                if (config.debug) {\n                    console.debug(\"Sending message\", msg);\n                }\n                IndexingWorker.execPeer(\"invokeTernCommand\", msg);\n            });\n        }\n\n        /**\n         *  Update tern with the new contents of a given file.\n         *\n         * @param {Document} document - the document to update\n         * @return {jQuery.Promise} - the promise for the request\n         */\n        function updateTernFile(document) {\n            var path  = document.file.fullPath;\n\n            _postMessageByPass({\n                type: MessageIds.TERN_UPDATE_FILE_MSG,\n                path: path,\n                text: getTextFromDocument(document)\n            });\n\n            return addPendingRequest(path, OFFSET_ZERO, MessageIds.TERN_UPDATE_FILE_MSG);\n        }\n\n        /**\n         * Handle a request from the tern node domain for text of a file\n         *\n         * @param {{file:string}} request - the request from the tern node domain.  Should be an Object containing the name\n         *      of the file tern wants the contents of\n         */\n        function handleTernGetFile(request) {\n\n            function replyWith(name, txt) {\n                _postMessageByPass({\n                    type: MessageIds.TERN_GET_FILE_MSG,\n                    file: name,\n                    text: txt\n                });\n            }\n\n            var name = request.file;\n\n            /**\n             * Helper function to get the text of a given document and send it to tern.\n             * If DocumentManager successfully gets the file's text then we'll send it to the tern node domain.\n             * The Promise for getDocumentText() is returned so that custom fail functions can be used.\n             *\n             * @param {string} filePath - the path of the file to get the text of\n             * @return {jQuery.Promise} - the Promise returned from DocumentMangaer.getDocumentText()\n             */\n            function getDocText(filePath) {\n                if(!filePath.startsWith(\"/\")){\n                    // tern seems to ignore the leading / we send with the file path\n                    filePath = `/${filePath}`;\n                }\n                if (!FileSystem.isAbsolutePath(filePath) || // don't handle URLs\n                        filePath.slice(0, 2) === \"//\") { // don't handle protocol-relative URLs like //example.com/main.js (see #10566)\n                    return (new $.Deferred()).reject().promise();\n                }\n\n                var file = FileSystem.getFileForPath(filePath),\n                    promise = DocumentManager.getDocumentText(file);\n\n                promise.done(function (docText) {\n                    resolvedFiles[name] = filePath;\n                    numResolvedFiles++;\n                    replyWith(name, filterText(docText));\n                });\n                return promise;\n            }\n\n            /**\n             * Helper function to find any files in the project that end with the\n             * name we are looking for.  This is so we can find requirejs modules\n             * when the baseUrl is unknown, or when the project root is not the same\n             * as the script root (e.g. if you open the 'brackets' dir instead of 'brackets/src' dir).\n             */\n            function findNameInProject() {\n                // check for any files in project that end with the right path.\n                var fileName = name.substring(name.lastIndexOf(\"/\") + 1);\n\n                function _fileFilter(entry) {\n                    return entry.name === fileName;\n                }\n\n                ProjectManager.getAllFiles(_fileFilter).done(function (files) {\n                    var file;\n                    files = files.filter(function (file) {\n                        var pos = file.fullPath.length - name.length;\n                        return pos === file.fullPath.lastIndexOf(name);\n                    });\n\n                    if (files.length === 1) {\n                        file = files[0];\n                    }\n                    if (file) {\n                        getDocText(file.fullPath).fail(function () {\n                            replyWith(name, \"\");\n                        });\n                    } else {\n                        replyWith(name, \"\");\n                    }\n                });\n            }\n\n            if (!isFileExcludedInternal(name)) {\n                getDocText(name).fail(function () {\n                    getDocText(rootTernDir + name).fail(function () {\n                        // check relative to project root\n                        getDocText(projectRoot + name)\n                            // last look for any files that end with the right path\n                            // in the project\n                            .fail(findNameInProject);\n                    });\n                });\n            }\n        }\n\n        /**\n         *  Prime the pump for a fast first lookup.\n         *\n         * @param {string} path - full path of file\n         * @return {jQuery.Promise} - the promise for the request\n         */\n        function primePump(path, isUntitledDoc) {\n            _postMessageByPass({\n                type: MessageIds.TERN_PRIME_PUMP_MSG,\n                path: path,\n                isUntitledDoc: isUntitledDoc\n            });\n\n            return addPendingRequest(path, OFFSET_ZERO, MessageIds.TERN_PRIME_PUMP_MSG);\n        }\n\n        /**\n         * Handle the response from the tern node domain when\n         * it responds to the prime pump message.\n         *\n         * @param {{path: string, type: string}} response - the response from node domain\n         */\n        function handlePrimePumpCompletion(response) {\n\n            var path = response.path,\n                type = response.type,\n                $deferredHints = getPendingRequest(path, OFFSET_ZERO, type);\n\n            if ($deferredHints) {\n                $deferredHints.resolve();\n            }\n        }\n\n        /**\n         *  Add new files to tern, keeping any previous files.\n         *  The tern server must be initialized before making\n         *  this call.\n         *\n         * @param {Array.<string>} files - array of file to add to tern.\n         * @return {boolean} - true if more files may be added, false if maximum has been reached.\n         */\n        function addFilesToTern(files) {\n            // limit the number of files added to tern.\n            var maxFileCount = preferences.getMaxFileCount();\n            if (numResolvedFiles + numAddedFiles < maxFileCount) {\n                var available = maxFileCount - numResolvedFiles - numAddedFiles;\n\n                if (available < files.length) {\n                    files = files.slice(0, available);\n                }\n\n                numAddedFiles += files.length;\n                ternPromise.done(function () {\n                    var msg = {\n                        type: MessageIds.TERN_ADD_FILES_MSG,\n                        files: files\n                    };\n\n                    if (config.debug) {\n                        console.debug(\"Sending message\", msg);\n                    }\n                    IndexingWorker.execPeer(\"invokeTernCommand\", msg);\n                });\n\n            } else {\n                stopAddingFiles = true;\n            }\n\n            return stopAddingFiles;\n        }\n\n        /**\n         *  Add the files in the directory and subdirectories of a given directory\n         *  to tern.\n         *\n         * @param {string} dir - the root directory to add.\n         * @param {function ()} doneCallback - called when all files have been\n         * added to tern.\n         */\n        function addAllFilesAndSubdirectories(dir, doneCallback) {\n            FileSystem.resolve(dir, function (err, directory) {\n                function visitor(entry) {\n                    if (entry.isFile) {\n                        if (!isFileExcluded(entry)) { // ignore .dotfiles and non-.js files\n                            addFilesToTern([entry.fullPath]);\n                        }\n                    } else {\n                        return !isDirectoryExcluded(entry.fullPath) &&\n                            entry.name.indexOf(\".\") !== 0 &&\n                            !stopAddingFiles;\n                    }\n                }\n\n                if (err) {\n                    return;\n                }\n\n                if (dir === FileSystem.getDirectoryForPath(rootTernDir)) {\n                    doneCallback();\n                    return;\n                }\n\n                directory.visit(visitor, doneCallback);\n            });\n        }\n\n        /**\n         * Init the Tern module that does all the code hinting work.\n         */\n        function initTernModule() {\n            let moduleDeferred = $.Deferred();\n            ternPromise = moduleDeferred.promise();\n\n            function _ternWorkerEventHandler(evt, data) {\n                if (config.debug) {\n                    console.log(\"Message received\", data.type);\n                }\n\n                var response = data,\n                    type = response.type;\n\n                if (type === MessageIds.TERN_COMPLETIONS_MSG ||\n                    type === MessageIds.TERN_CALLED_FUNC_TYPE_MSG) {\n                    // handle any completions the tern server calculated\n                    handleTernCompletions(response);\n                } else if (type === MessageIds.TERN_GET_FILE_MSG) {\n                    // handle a request for the contents of a file\n                    handleTernGetFile(response);\n                } else if (type === MessageIds.TERN_JUMPTODEF_MSG) {\n                    handleJumptoDef(response);\n                } else if (type === MessageIds.TERN_SCOPEDATA_MSG) {\n                    handleScopeData(response);\n                } else if (type === MessageIds.TERN_REFS) {\n                    handleRename(response);\n                } else if (type === MessageIds.TERN_PRIME_PUMP_MSG) {\n                    handlePrimePumpCompletion(response);\n                } else if (type === MessageIds.TERN_GET_GUESSES_MSG) {\n                    handleGetGuesses(response);\n                } else if (type === MessageIds.TERN_UPDATE_FILE_MSG) {\n                    handleUpdateFile(response);\n                } else if (type === MessageIds.TERN_INFERENCE_TIMEDOUT) {\n                    handleTimedOut(response);\n                } else if (type === MessageIds.TERN_WORKER_READY) {\n                    moduleDeferred.resolveWith(null);\n                } else {\n                    console.error(\"Tern Module received unknown event: \" + (response.log || response));\n                }\n            }\n\n            if(!ternConfigInitDone){\n                ternConfigInitDone = true;\n                IndexingWorker.off(\"tern-data\");\n                IndexingWorker.on(\"tern-data\", _ternWorkerEventHandler);\n                IndexingWorker.execPeer(\"invokeTernCommand\", {\n                    type: MessageIds.SET_CONFIG,\n                    config: config\n                }).then(()=>{\n                    moduleDeferred.resolveWith(null);\n                });\n            } else {\n                IndexingWorker.off(\"tern-data\");\n                IndexingWorker.on(\"tern-data\", _ternWorkerEventHandler);\n                IndexingWorker.execPeer(\"resetTernServer\");\n            }\n        }\n\n        /**\n         * Create a new tern server.\n         */\n        function initTernServer(dir, files) {\n            initTernModule();\n            numResolvedFiles = 0;\n            numAddedFiles = 0;\n            stopAddingFiles = false;\n            numInitialFiles = files.length;\n\n            ternPromise.done(function () {\n                var msg = {\n                    type: MessageIds.TERN_INIT_MSG,\n                    dir: dir,\n                    files: files,\n                    env: ternEnvironment,\n                    timeout: PreferencesManager.get(\"jscodehints.inferenceTimeout\")\n                };\n                IndexingWorker.execPeer(\"invokeTernCommand\", msg);\n            });\n            rootTernDir = dir.endsWith(\"/\") ? dir : dir + \"/\";\n        }\n\n        /**\n         *  We can skip tern initialization if we are opening a file that has\n         *  already been added to tern.\n         *\n         * @param {string} newFile - full path of new file being opened in the editor.\n         * @return {boolean} - true if tern initialization should be skipped,\n         * false otherwise.\n         */\n        function canSkipTernInitialization(newFile) {\n            return resolvedFiles[newFile] !== undefined;\n        }\n\n\n        /**\n         *  Do the work to initialize a code hinting session.\n         *\n         * @param {Session} session - the active hinting session (TODO: currently unused)\n         * @param {!Document} document - the document the editor has changed to\n         * @param {?Document} previousDocument - the document the editor has changed from\n         */\n        function doEditorChange(session, document, previousDocument) {\n            var file        = document.file,\n                path        = file.fullPath,\n                dir         = file.parentPath,\n                pr;\n\n            var addFilesDeferred = $.Deferred();\n\n            documentChanges = null;\n            addFilesPromise = addFilesDeferred.promise();\n            pr = ProjectManager.getProjectRoot() ? ProjectManager.getProjectRoot().fullPath : null;\n\n            // avoid re-initializing tern if possible.\n            if (canSkipTernInitialization(path)) {\n\n                // update the previous document in tern to prevent stale files.\n                if (isDocumentDirty && previousDocument) {\n                    var updateFilePromise = updateTernFile(previousDocument);\n                    updateFilePromise.done(function () {\n                        primePump(path, document.isUntitled());\n                        addFilesDeferred.resolveWith(null);\n                    });\n                } else {\n                    addFilesDeferred.resolveWith(null);\n                }\n\n                isDocumentDirty = false;\n                return;\n            }\n\n            if (previousDocument && previousDocument.isDirty) {\n                updateTernFile(previousDocument);\n            }\n\n            isDocumentDirty = false;\n            resolvedFiles = {};\n            projectRoot = pr;\n\n            ensurePreferences();\n            deferredPreferences.done(function () {\n                if (file instanceof InMemoryFile) {\n                    initTernServer(pr, []);\n                    var hintsPromise = primePump(path, true);\n                    hintsPromise.done(function () {\n                        addFilesDeferred.resolveWith(null);\n                    });\n                    return;\n                }\n\n                FileSystem.resolve(dir, function (err, directory) {\n                    if (err) {\n                        console.error(\"Error resolving\", dir);\n                        addFilesDeferred.resolveWith(null);\n                        return;\n                    }\n\n                    directory.getContents(function (err, contents) {\n                        if (err) {\n                            console.error(\"Error getting contents for\", directory);\n                            addFilesDeferred.resolveWith(null);\n                            return;\n                        }\n\n                        var files = contents\n                            .filter(function (entry) {\n                                return entry.isFile && !isFileExcluded(entry);\n                            })\n                            .map(function (entry) {\n                                return entry.fullPath;\n                            });\n\n                        initTernServer(dir, files);\n\n                        var hintsPromise = primePump(path, false);\n                        hintsPromise.done(function () {\n                            if (!usingModules()) {\n                                // Read the subdirectories of the new file's directory.\n                                // Read them first in case there are too many files to\n                                // read in the project.\n                                addAllFilesAndSubdirectories(dir, function () {\n                                    // If the file is in the project root, then read\n                                    // all the files under the project root.\n                                    var currentDir = (dir + \"/\");\n                                    if (projectRoot && currentDir !== projectRoot &&\n                                            currentDir.indexOf(projectRoot) === 0) {\n                                        addAllFilesAndSubdirectories(projectRoot, function () {\n                                            // prime the pump again but this time don't wait\n                                            // for completion.\n                                            primePump(path, false);\n                                            addFilesDeferred.resolveWith(null);\n                                        });\n                                    } else {\n                                        addFilesDeferred.resolveWith(null);\n                                    }\n                                });\n                            } else {\n                                addFilesDeferred.resolveWith(null);\n                            }\n                        });\n                    });\n                });\n            });\n        }\n\n        /**\n         * Called each time a new editor becomes active.\n         *\n         * @param {Session} session - the active hinting session (TODO: currently unused by doEditorChange())\n         * @param {!Document} document - the document of the editor that has changed\n         * @param {?Document} previousDocument - the document of the editor is changing from\n         */\n        function handleEditorChange(session, document, previousDocument) {\n            if (addFilesPromise === null) {\n                doEditorChange(session, document, previousDocument);\n            } else {\n                addFilesPromise.done(function () {\n                    doEditorChange(session, document, previousDocument);\n                });\n            }\n        }\n\n        /**\n         * Do some cleanup when a project is closed.\n         *\n         * We can clean up the node tern server we use to calculate hints now, since\n         * we know we will need to re-init it in any new project that is opened.\n         */\n        function resetModule() {\n            function resetTernServer() {\n                IndexingWorker.execPeer('resetTernServer');\n            }\n\n            if (addFilesPromise) {\n                // If we're in the middle of added files, don't reset\n                // until we're done\n                addFilesPromise.done(resetTernServer).fail(resetTernServer);\n            } else {\n                resetTernServer();\n            }\n        }\n\n        function whenReady(func) {\n            addFilesPromise.done(func);\n        }\n\n        this.resetModule = resetModule;\n        this.handleEditorChange = handleEditorChange;\n        this.postMessage = postMessage;\n        this.getResolvedPath = getResolvedPath;\n        this.whenReady = whenReady;\n\n        return this;\n    }\n\n    var resettingDeferred = null;\n\n    /**\n     * reset the tern module, if necessary.\n     *\n     * During debugging, you can turn this automatic resetting behavior off\n     * by running this in the console:\n     * brackets._configureJSCodeHints({ noReset: true })\n     *\n     * This function is also used in unit testing with the \"force\" flag to\n     * reset the module for each test to start with a clean environment.\n     *\n     * @param {Session} session\n     * @param {Document} document\n     * @param {boolean} force true to force a reset regardless of how long since the last one\n     * @return {Promise} Promise resolved when the module is ready.\n     *                   The new (or current, if there was no reset) module is passed to the callback.\n     */\n    function _maybeReset(session, document, force) {\n        var newTernModule;\n        // if we're in the middle of a reset, don't have to check\n        // the new module will be online soon\n        if (!resettingDeferred) {\n\n            // We don't reset if the debugging flag is set\n            // because it's easier to debug if the module isn't\n            // getting reset all the time.\n            if (currentModule.resetForced || force || (!config.noReset && ++_hintCount > MAX_HINTS)) {\n                if (config.debug) {\n                    console.debug(\"Resetting tern module\");\n                }\n\n                resettingDeferred = new $.Deferred();\n                newTernModule = new TernModule();\n                newTernModule.handleEditorChange(session, document, null);\n                newTernModule.whenReady(function () {\n                    // reset the old module\n                    currentModule.resetModule();\n                    currentModule = newTernModule;\n                    resettingDeferred.resolve(currentModule);\n                    // all done reseting\n                    resettingDeferred = null;\n                });\n                _hintCount = 0;\n            } else {\n                var d = new $.Deferred();\n                d.resolve(currentModule);\n                return d.promise();\n            }\n        }\n\n        return resettingDeferred.promise();\n    }\n\n    /**\n     * Request a parameter hint from Tern.\n     *\n     * @param {Session} session - the active hinting session\n     * @param {{line: number, ch: number}} functionOffset - the offset of the function call.\n     * @return {jQuery.Promise} - The promise will not complete until the\n     *      hint has completed.\n     */\n    function requestParameterHint(session, functionOffset) {\n        var $deferredHints = $.Deferred(),\n            fileInfo = getFileInfo(session, true),\n            offset = getOffset(session, fileInfo, functionOffset),\n            fnTypePromise = getTernFunctionType(fileInfo, offset);\n\n        $.when(fnTypePromise).done(\n            function (fnType) {\n                session.setFnType(fnType);\n                session.setFunctionCallPos(functionOffset);\n                $deferredHints.resolveWith(null, [fnType]);\n            }\n        ).fail(function () {\n            $deferredHints.reject();\n        });\n\n        return $deferredHints.promise();\n    }\n\n    /**\n     * Request hints from Tern.\n     *\n     * Note that successive calls to getScope may return the same objects, so\n     * clients that wish to modify those objects (e.g., by annotating them based\n     * on some temporary context) should copy them first. See, e.g.,\n     * Session.getHints().\n     *\n     * @param {Session} session - the active hinting session\n     * @param {Document} document - the document for which scope info is\n     *      desired\n     * @return {jQuery.Promise} - The promise will not complete until the tern\n     *      hints have completed.\n     */\n    function requestHints(session, document) {\n        var $deferredHints = $.Deferred(),\n            hintPromise,\n            sessionType = session.getType(),\n            fileInfo = getFileInfo(session),\n            offset = getOffset(session, fileInfo, null);\n\n        _maybeReset(session, document);\n\n        hintPromise = getTernHints(fileInfo, offset, sessionType.property);\n\n        $.when(hintPromise).done(\n            function (completions, fnType) {\n                if (completions.completions) {\n                    session.setTernHints(completions.completions);\n                    session.setGuesses(null);\n                } else {\n                    session.setTernHints([]);\n                    session.setGuesses(completions.properties);\n                }\n\n                $deferredHints.resolveWith(null);\n            }\n        ).fail(function () {\n            $deferredHints.reject();\n        });\n\n        return $deferredHints.promise();\n    }\n\n    /**\n     *  Track the update area of the current document so we can tell if we can send\n     *  partial updates to tern or not.\n     *\n     * @param {Array.<{from: {line:number, ch: number}, to: {line:number, ch: number},\n     *     text: Array<string>}>} changeList - the document changes from the current change event\n     */\n    function trackChange(changeList) {\n        var changed = documentChanges, i;\n        if (changed === null) {\n            documentChanges = changed = {from: changeList[0].from.line, to: changeList[0].from.line};\n            if (config.debug) {\n                console.debug(\"ScopeManager: document has changed\");\n            }\n        }\n\n        for (i = 0; i < changeList.length; i++) {\n            var thisChange = changeList[i],\n                end = thisChange.from.line + (thisChange.text.length - 1);\n            if (thisChange.from.line < changed.to) {\n                changed.to = changed.to - (thisChange.to.line - end);\n            }\n\n            if (end >= changed.to) {\n                changed.to = end + 1;\n            }\n\n            if (changed.from > thisChange.from.line) {\n                changed.from = thisChange.from.line;\n            }\n        }\n    }\n\n    /*\n     * Called each time the file associated with the active editor changes.\n     * Marks the file as being dirty.\n     *\n     * @param {from: {line:number, ch: number}, to: {line:number, ch: number}}\n     */\n    function handleFileChange(changeList) {\n        isDocumentDirty = true;\n        trackChange(changeList);\n    }\n\n    /**\n     * Called each time a new editor becomes active.\n     *\n     * @param {Session} session - the active hinting session\n     * @param {Document} document - the document of the editor that has changed\n     * @param {?Document} previousDocument - the document of the editor is changing from\n     */\n    function handleEditorChange(session, document, previousDocument) {\n\n        if (!currentModule) {\n            currentModule = new TernModule();\n        }\n\n        return currentModule.handleEditorChange(session, document, previousDocument);\n    }\n\n    /**\n     * Do some cleanup when a project is closed.\n     * Clean up previous analysis data from the module\n     */\n    function handleProjectClose() {\n        if (currentModule) {\n            currentModule.resetModule();\n        }\n    }\n\n    /**\n     *  Read in project preferences when a new project is opened.\n     *  Look in the project root directory for a preference file.\n     *\n     *  @param {string=} projectRootPath - new project root path(optional).\n     *  Only needed for unit tests.\n     */\n    function handleProjectOpen(projectRootPath) {\n        initPreferences(projectRootPath);\n    }\n\n    /** Used to avoid timing bugs in unit tests */\n    function _readyPromise() {\n        return deferredPreferences;\n    }\n\n    /**\n     * @private\n     *\n     * Update the configuration in the tern node domain.\n     */\n    function _setConfig(configUpdate) {\n        config = brackets._configureJSCodeHints.config;\n        postMessage({\n            type: MessageIds.SET_CONFIG,\n            config: configUpdate\n        });\n    }\n\n    exports._setConfig = _setConfig;\n    exports._maybeReset = _maybeReset;\n    exports.getBuiltins = getBuiltins;\n    exports.getResolvedPath = getResolvedPath;\n    exports.getTernHints = getTernHints;\n    exports.handleEditorChange = handleEditorChange;\n    exports.requestGuesses = requestGuesses;\n    exports.handleFileChange = handleFileChange;\n    exports.requestHints = requestHints;\n    exports.requestJumptoDef = requestJumptoDef;\n    exports.requestParameterHint = requestParameterHint;\n    exports.handleProjectClose = handleProjectClose;\n    exports.handleProjectOpen = handleProjectOpen;\n    exports._readyPromise = _readyPromise;\n    exports.filterText = filterText;\n    exports.postMessage = postMessage;\n    exports.addPendingRequest = addPendingRequest;\n});\n"],"file":"ScopeManager.js"}
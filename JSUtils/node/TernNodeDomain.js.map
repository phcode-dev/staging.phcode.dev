{"version":3,"sources":["JSUtils/node/TernNodeDomain.js"],"names":["config","_domainManager","MessageIds","ternOptions","self","postMessage","data","emitEvent","Tern","require","Infer","ExtractContent","ternServer","isUntitledDoc","inferenceTimeout","fileCallBacks","_log","msg","console","log","_reportError","e","file","TimedOut","type","TERN_INFERENCE_TIMEDOUT","message","stack","handleGetFile","text","next","_getNormalizedFilename","fileName","projectDir","indexOf","_getDenormalizedFilename","slice","length","_requestFileContent","name","TERN_GET_FILE_MSG","getFile","setImmediate","extractContent","error","initTernServer","env","files","defs","async","plugins","requirejs","doc_comment","angular","ecmaVersion","reset","resetGuessing","Server","forEach","addFile","resetTernServer","TERN_WORKER_READY","createEmptyUpdate","path","TERN_FILE_INFO_TYPE_EMPTY","offsetLines","buildRequest","fileInfo","query","offset","start","end","TERN_FILE_INFO_TYPE_PART","filter","sort","depths","guess","origins","types","expandWordForward","lineCharPositions","docs","urls","request","timeout","fileInfoCopy","JSON","parse","stringify","push","getRefs","response","TERN_REFS","references","getScopeData","ternError","toString","findFile","scope","scopeAt","ast","resolvePos","key","value","includes","propertyName","body","TERN_SCOPEDATA_MSG","getJumptoDef","TERN_JUMPTODEF_MSG","resultFile","isFunction","substring","getTernProperties","i","properties","completions","map","completion","getTernHints","isProperty","depth","origin","doc","url","TERN_COMPLETIONS_MSG","getParameters","inferFnType","recordTypeToString","inferTypeToString","processInferFnTypeParameters","inferFnTypeToString","inferArrTypeToString","inferArrType","result","props","join","formatParameterHint","params","appendSeparators","appendParameter","typesOnly","pendingOptional","param","separators","isOptional","first","prop","Object","keys","inferType","AVal","Prim","Arr","Fn","Obj","undefined","retval","args","argNames","handleFunctionType","preferFunction","fnType","newOffset","line","ch","expr","findQueryExpr","expressionType","getFunctionType","getType","TERN_CALLED_FUNC_TYPE_MSG","handleAddFiles","handleUpdateFile","TERN_UPDATE_FILE_MSG","handlePrimePump","TERN_PRIME_PUMP_MSG","setConfig","configUpdate","_requestTernServer","commandConfig","debug","TERN_INIT_MSG","TERN_ADD_FILES_MSG","TERN_GET_GUESSES_MSG","SET_CONFIG","TERN_UPDATE_DIRTY_FILE","updateFilesCache","action","TERN_CLEAR_DIRTY_FILES_LIST","clearFilesCache","invokeTernCommand","warn","setInterface","msgInterface","messageIds","checkInterfaceAndReInit","init","domainManager","hasDomain","registerDomain","major","minor","registerCommand","description","registerEvent","setTimeout","exports"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2017 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*eslint-env node */\n/*jslint node: true */\n/*global setImmediate */\n\n\n\n\n\nvar config = {};\nvar _domainManager;\nvar MessageIds;\nvar ternOptions;\nvar self = {\n    postMessage: function (data) {\n        _domainManager.emitEvent(\"TernNodeDomain\", \"data\", [data]);\n    }\n};\n\nvar Tern = require(\"tern\"),\n    Infer = require(\"tern/lib/infer\");\n\nrequire(\"tern/plugin/requirejs\");\nrequire(\"tern/plugin/doc_comment\");\nrequire(\"tern/plugin/angular\");\n\n\nvar ExtractContent = require(\"./ExtractFileContent\");\n\nvar ternServer  = null,\n    isUntitledDoc = false,\n    inferenceTimeout;\n\n// Save the tern callbacks for when we get the contents of the file\nvar fileCallBacks = {};\n\n/**\n * Send a log message back from the node to the main thread\n * @private\n * @param {string} msg - the log message\n */\nfunction _log(msg) {\n    console.log(msg);\n}\n\n/**\n * Report exception\n * @private\n * @param {Error} e - the error object\n */\nfunction _reportError(e, file) {\n    if (e instanceof Infer.TimedOut) {\n        // Post a message back to the main thread with timedout info\n        self.postMessage({\n            type: MessageIds.TERN_INFERENCE_TIMEDOUT,\n            file: file\n        });\n    } else {\n        _log(\"Error thrown in tern_node domain:\" + e.message + \"\\n\" + e.stack);\n    }\n}\n\n/**\n * Handle a response from the main thread providing the contents of a file\n * @param {string} file - the name of the file\n * @param {string} text - the contents of the file\n */\nfunction handleGetFile(file, text) {\n    var next = fileCallBacks[file];\n    if (next) {\n        try {\n            next(null, text);\n        } catch (e) {\n            _reportError(e, file);\n        }\n    }\n    delete fileCallBacks[file];\n}\n\nfunction _getNormalizedFilename(fileName) {\n    if (!isUntitledDoc && ternServer.projectDir && fileName.indexOf(ternServer.projectDir) === -1) {\n        fileName = ternServer.projectDir + fileName;\n    }\n    return fileName;\n}\n\nfunction _getDenormalizedFilename(fileName) {\n    if (!isUntitledDoc && ternServer.projectDir && fileName.indexOf(ternServer.projectDir) === 0) {\n        fileName = fileName.slice(ternServer.projectDir.length);\n    }\n    return fileName;\n}\n\n/**\n * Callback handle to request contents of a file from the main thread\n * @param {string} file - the name of the file\n */\nfunction _requestFileContent(name) {\n    self.postMessage({\n        type: MessageIds.TERN_GET_FILE_MSG,\n        file: name\n    });\n}\n\n/**\n * Provide the contents of the requested file to tern\n * @param {string} name - the name of the file\n * @param {Function} next - the function to call with the text of the file\n *  once it has been read in.\n */\nfunction getFile(name, next) {\n    // save the callback\n    fileCallBacks[name] = next;\n\n    setImmediate(function () {\n        try {\n            ExtractContent.extractContent(name, handleGetFile, _requestFileContent);\n        } catch (error) {\n            console.log(error);\n        }\n    });\n}\n\n/**\n * Create a new tern server.\n *\n * @param {Object} env - an Object with the environment, as read in from\n *  the json files in thirdparty/tern/defs\n * @param {Array.<string>} files - a list of filenames tern should be aware of\n */\nfunction initTernServer(env, files) {\n    ternOptions = {\n        defs: env,\n        async: true,\n        getFile: getFile,\n        plugins: {requirejs: {}, doc_comment: true, angular: true},\n        ecmaVersion: 9\n    };\n\n    // If a server is already created just reset the analysis data before marking it for GC\n    if (ternServer) {\n        ternServer.reset();\n        Infer.resetGuessing();\n    }\n\n    ternServer = new Tern.Server(ternOptions);\n\n    files.forEach(function (file) {\n        ternServer.addFile(file);\n    });\n\n}\n\n/**\n * Resets an existing tern server.\n */\nfunction resetTernServer() {\n    // If a server is already created just reset the analysis data\n    if (ternServer) {\n        ternServer.reset();\n        Infer.resetGuessing();\n        // tell the main thread we're ready to start processing again\n        self.postMessage({type: MessageIds.TERN_WORKER_READY});\n    }\n}\n\n/**\n * Create a \"empty\" update object.\n *\n * @param {string} path - full path of the file.\n * @return {{type: string, name: string, offsetLines: number, text: string}} -\n * \"empty\" update.\n\n */\nfunction createEmptyUpdate(path) {\n    return {type: MessageIds.TERN_FILE_INFO_TYPE_EMPTY,\n        name: path,\n        offsetLines: 0,\n        text: \"\"};\n}\n\n/**\n * Build an object that can be used as a request to tern.\n *\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {string} query - the type of request being made\n * @param {{line: number, ch: number}} offset -\n */\nfunction buildRequest(fileInfo, query, offset) {\n    query = {type: query};\n    query.start = offset;\n    query.end = offset;\n    query.file = (fileInfo.type === MessageIds.TERN_FILE_INFO_TYPE_PART) ? \"#0\" : fileInfo.name;\n    query.filter = false;\n    query.sort = false;\n    query.depths = true;\n    query.guess = true;\n    query.origins = true;\n    query.types = true;\n    query.expandWordForward = false;\n    query.lineCharPositions = true;\n    query.docs = true;\n    query.urls = true;\n\n    var request = {query: query, files: [], offset: offset, timeout: inferenceTimeout};\n    if (fileInfo.type !== MessageIds.TERN_FILE_INFO_TYPE_EMPTY) {\n        // Create a copy to mutate ahead\n        var fileInfoCopy = JSON.parse(JSON.stringify(fileInfo));\n        request.files.push(fileInfoCopy);\n    }\n\n    return request;\n}\n\n\n/**\n * Get all References location\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset - the offset into the\n * file for cursor\n */\nfunction getRefs(fileInfo, offset) {\n    var request = buildRequest(fileInfo, \"refs\", offset);\n    try {\n        ternServer.request(request, function (error, data) {\n            if (error) {\n                _log(\"Error returned from Tern 'refs' request: \" + error);\n                var response = {\n                    type: MessageIds.TERN_REFS,\n                    error: error.message\n                };\n                self.postMessage(response);\n                return;\n            }\n            var response = {\n                type: MessageIds.TERN_REFS,\n                file: fileInfo.name,\n                offset: offset,\n                references: data\n            };\n            // Post a message back to the main thread with the results\n            self.postMessage(response);\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    }\n}\n\n/**\n * Get scope at the offset in the file\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset - the offset into the\n * file for cursor\n */\nfunction getScopeData(fileInfo, offset) {\n    // Create a new tern Server\n    // Existing tern server resolves all the required modules which might take time\n    // We only need to analyze single file for getting the scope\n    ternOptions.plugins = {};\n    var ternServer = new Tern.Server(ternOptions);\n    ternServer.addFile(fileInfo.name, fileInfo.text);\n\n    var error;\n    var request = buildRequest(fileInfo, \"completions\", offset); // for primepump\n\n    try {\n        // primepump\n        ternServer.request(request, function (ternError, data) {\n            if (ternError) {\n                _log(\"Error for Tern request: \\n\" + JSON.stringify(request) + \"\\n\" + ternError);\n                error = ternError.toString();\n            } else {\n                var file = ternServer.findFile(fileInfo.name);\n                var scope = Infer.scopeAt(file.ast, Tern.resolvePos(file, offset), file.scope);\n\n                if (scope) {\n                    // Remove unwanted properties to remove cycles in the object\n                    scope = JSON.parse(JSON.stringify(scope, function(key, value) {\n                        if ([\"proto\", \"propertyOf\", \"onNewProp\", \"sourceFile\", \"maybeProps\"].includes(key)) {\n                            return undefined;\n                        }                        else if (key === \"fnType\") {\n                            return value.name || \"FunctionExpression\";\n                        }                        else if (key === \"props\") {\n                            for (var key in value) {\n                                value[key] = value[key].propertyName;\n                            }\n                            return value;\n                        } else if (key === \"originNode\") {\n                            return value && {\n                                start: value.start,\n                                end: value.end,\n                                type: value.type,\n                                body: {\n                                    start: value.body.start,\n                                    end: value.body.end\n                                }\n                            };\n                        }\n\n                        return value;\n                    }));\n                }\n\n                self.postMessage({\n                    type: MessageIds.TERN_SCOPEDATA_MSG,\n                    file: _getNormalizedFilename(fileInfo.name),\n                    offset: offset,\n                    scope: scope\n                });\n            }\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    } finally {\n        ternServer.reset();\n        Infer.resetGuessing();\n    }\n}\n\n\n/**\n * Get definition location\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset - the offset into the\n * file for cursor\n */\nfunction getJumptoDef(fileInfo, offset) {\n    var request = buildRequest(fileInfo, \"definition\", offset);\n    // request.query.typeOnly = true;       // FIXME: tern doesn't work exactly right yet.\n\n    try {\n        ternServer.request(request, function (error, data) {\n            if (error) {\n                _log(\"Error returned from Tern 'definition' request: \" + error);\n                self.postMessage({type: MessageIds.TERN_JUMPTODEF_MSG, file: fileInfo.name, offset: offset});\n                return;\n            }\n            var response = {\n                type: MessageIds.TERN_JUMPTODEF_MSG,\n                file: _getNormalizedFilename(fileInfo.name),\n                resultFile: data.file,\n                offset: offset,\n                start: data.start,\n                end: data.end\n            };\n\n            request = buildRequest(fileInfo, \"type\", offset);\n            // See if we can tell if the reference is to a Function type\n            ternServer.request(request, function (error, data) {\n                if (!error) {\n                    response.isFunction = data.type.length > 2 && data.type.substring(0, 2) === \"fn\";\n                }\n\n                // Post a message back to the main thread with the definition\n                self.postMessage(response);\n            });\n\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    }\n}\n\n/**\n * Get all the known properties for guessing.\n *\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset -\n * the offset into the file where we want completions for\n * @param {string} type     - the type of the message to reply with.\n */\nfunction getTernProperties(fileInfo, offset, type) {\n\n    var request = buildRequest(fileInfo, \"properties\", offset),\n        i;\n    //_log(\"tern properties: request \" + request.type + dir + \" \" + file);\n    try {\n        ternServer.request(request, function (error, data) {\n            var properties = [];\n            if (error) {\n                _log(\"Error returned from Tern 'properties' request: \" + error);\n            } else {\n                //_log(\"tern properties: completions = \" + data.completions.length);\n                properties = data.completions.map(function (completion) {\n                    return {value: completion, type: completion.type, guess: true};\n                });\n            }\n            // Post a message back to the main thread with the completions\n            self.postMessage({type: type,\n                file: _getNormalizedFilename(fileInfo.name),\n                offset: offset,\n                properties: properties\n            });\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    }\n}\n\n/**\n * Get the completions for the given offset\n *\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset -\n * the offset into the file where we want completions for\n * @param {boolean} isProperty - true if getting a property hint,\n * otherwise getting an identifier hint.\n */\nfunction getTernHints(fileInfo, offset, isProperty) {\n    var request = buildRequest(fileInfo, \"completions\", offset),\n        i;\n    //_log(\"request \" + dir + \" \" + file + \" \" + offset /*+ \" \" + text */);\n    try {\n        ternServer.request(request, function (error, data) {\n            var completions = [];\n            if (error) {\n                _log(\"Error returned from Tern 'completions' request: \" + error);\n            } else {\n                //_log(\"found \" + data.completions + \" for \" + file + \"@\" + offset);\n                completions = data.completions.map(function (completion) {\n                    return {value: completion.name, type: completion.type, depth: completion.depth,\n                        guess: completion.guess, origin: completion.origin, doc: completion.doc, url: completion.url};\n                });\n            }\n\n            if (completions.length > 0 || !isProperty) {\n                // Post a message back to the main thread with the completions\n                self.postMessage({type: MessageIds.TERN_COMPLETIONS_MSG,\n                    file: _getNormalizedFilename(fileInfo.name),\n                    offset: offset,\n                    completions: completions\n                });\n            } else {\n                // if there are no completions, then get all the properties\n                getTernProperties(fileInfo, offset, MessageIds.TERN_COMPLETIONS_MSG);\n            }\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    }\n}\n\n/**\n *  Given a Tern type object, convert it to an array of Objects, where each object describes\n *  a parameter.\n *\n * @param {!Infer.Fn} inferFnType - type to convert.\n * @return {Array<{name: string, type: string, isOptional: boolean}>} where each entry in the array is a parameter.\n */\nfunction getParameters(inferFnType) {\n\n    // work around define functions before use warning.\n    var recordTypeToString, inferTypeToString, processInferFnTypeParameters, inferFnTypeToString;\n\n    /**\n     *  Convert an infer array type to a string.\n     *\n     *  Formatted using google closure style. For example:\n     *\n     *  \"Array.<string, number>\"\n     *\n     * @param {Infer.Arr} inferArrType\n     *\n     * @return {string} - array formatted in google closure style.\n     *\n     */\n    function inferArrTypeToString(inferArrType) {\n        var result = \"Array.<\";\n\n        result += inferArrType.props[\"<i>\"].types.map(inferTypeToString).join(\", \");\n\n        // workaround case where types is zero length\n        if (inferArrType.props[\"<i>\"].types.length === 0) {\n            result += \"Object\";\n        }\n        result += \">\";\n\n        return result;\n    }\n\n    /**\n     * Convert properties to a record type annotation.\n     *\n     * @param {Object} props\n     * @return {string} - record type annotation\n     */\n    recordTypeToString = function (props) {\n        var result = \"{\",\n            first = true,\n            prop;\n\n        result += Object.keys(props).map(function (key) {\n            return key + \": \" + inferTypeToString(props[key]);\n        }).join(\", \");\n\n        result += \"}\";\n\n        return result;\n    };\n\n    /**\n     *  Convert an infer type to a string.\n     *\n     * @param {*} inferType - one of the Infer's types; Infer.Prim, Infer.Arr, Infer.ANull. Infer.Fn functions are\n     * not handled here.\n     *\n     * @return {string}\n     *\n     */\n    inferTypeToString = function (inferType) {\n        var result;\n\n        if (inferType instanceof Infer.AVal) {\n            inferType = inferType.types[0];\n        }\n\n        if (inferType instanceof Infer.Prim) {\n            result = inferType.toString();\n            if (result === \"string\") {\n                result = \"String\";\n            } else if (result === \"number\") {\n                result = \"Number\";\n            } else if (result === \"boolean\") {\n                result = \"Boolean\";\n            }\n        } else if (inferType instanceof Infer.Arr) {\n            result = inferArrTypeToString(inferType);\n        } else if (inferType instanceof Infer.Fn) {\n            result = inferFnTypeToString(inferType);\n        } else if (inferType instanceof Infer.Obj) {\n            if (inferType.name === undefined) {\n                result = recordTypeToString(inferType.props);\n            } else {\n                result = inferType.name;\n            }\n        } else {\n            result = \"Object\";\n        }\n\n        return result;\n    };\n\n    /**\n     * Format the given parameter array. Handles separators between\n     * parameters, syntax for optional parameters, and the order of the\n     * parameter type and parameter name.\n     *\n     * @param {!Array.<{name: string, type: string, isOptional: boolean}>} params -\n     * array of parameter descriptors\n     * @param {function(string)=} appendSeparators - callback function to append separators.\n     * The separator is passed to the callback.\n     * @param {function(string, number)=} appendParameter - callback function to append parameter.\n     * The formatted parameter type and name is passed to the callback along with the\n     * current index of the parameter.\n     * @param {boolean=} typesOnly - only show parameter types. The\n     * default behavior is to include both parameter names and types.\n     * @return {string} - formatted parameter hint\n     */\n    function formatParameterHint(params, appendSeparators, appendParameter, typesOnly) {\n        var result = \"\",\n            pendingOptional = false;\n\n        params.forEach(function (value, i) {\n            var param = value.type,\n                separators = \"\";\n\n            if (value.isOptional) {\n                // if an optional param is following by an optional parameter, then\n                // terminate the bracket. Otherwise enclose a required parameter\n                // in the same bracket.\n                if (pendingOptional) {\n                    separators += \"]\";\n                }\n\n                pendingOptional = true;\n            }\n\n            if (i > 0) {\n                separators += \", \";\n            }\n\n            if (value.isOptional) {\n                separators += \"[\";\n            }\n\n            if (appendSeparators) {\n                appendSeparators(separators);\n            }\n\n            result += separators;\n\n            if (!typesOnly) {\n                param += \" \" + value.name;\n            }\n\n            if (appendParameter) {\n                appendParameter(param, i);\n            }\n\n            result += param;\n\n        });\n\n        if (pendingOptional) {\n            if (appendSeparators) {\n                appendSeparators(\"]\");\n            }\n\n            result += \"]\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert an infer function type to a Google closure type string.\n     *\n     * @param {Infer.Fn} inferType - type to convert.\n     * @return {string} - function type as a string.\n     */\n    inferFnTypeToString = function (inferType) {\n        var result = \"function(\",\n            params = processInferFnTypeParameters(inferType);\n\n        result += /*HintUtils2.*/formatParameterHint(params, null, null, true);\n        if (inferType.retval) {\n            result += \"):\";\n            result += inferTypeToString(inferType.retval);\n        }\n\n        return result;\n    };\n\n    /**\n     * Convert an infer function type to string.\n     *\n     * @param {*} inferType - one of the Infer's types; Infer.Fn, Infer.Prim, Infer.Arr, Infer.ANull\n     * @return {Array<{name: string, type: string, isOptional: boolean}>} where each entry in the array is a parameter.\n     */\n    processInferFnTypeParameters = function (inferType) {\n        var params = [],\n            i;\n\n        for (i = 0; i < inferType.args.length; i++) {\n            var param = {},\n                name = inferType.argNames[i],\n                type = inferType.args[i];\n\n            if (!name) {\n                name = \"param\" + (i + 1);\n            }\n\n            if (name[name.length - 1] === \"?\") {\n                name = name.substring(0, name.length - 1);\n                param.isOptional = true;\n            }\n\n            param.name = name;\n            param.type = inferTypeToString(type);\n            params.push(param);\n        }\n\n        return params;\n    };\n\n    return processInferFnTypeParameters(inferFnType);\n}\n\n/**\n * Get the function type for the given offset\n *\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset -\n * the offset into the file where we want completions for\n */\nfunction handleFunctionType(fileInfo, offset) {\n    var request = buildRequest(fileInfo, \"type\", offset),\n        error;\n\n    request.query.preferFunction = true;\n\n    var fnType = \"\";\n    try {\n        ternServer.request(request, function (ternError, data) {\n\n            if (ternError) {\n                _log(\"Error for Tern request: \\n\" + JSON.stringify(request) + \"\\n\" + ternError);\n                error = ternError.toString();\n            } else {\n                var file = ternServer.findFile(fileInfo.name);\n\n                // convert query from partial to full offsets\n                var newOffset = offset;\n                if (fileInfo.type === MessageIds.TERN_FILE_INFO_TYPE_PART) {\n                    newOffset = {line: offset.line + fileInfo.offsetLines, ch: offset.ch};\n                }\n\n                request = buildRequest(createEmptyUpdate(fileInfo.name), \"type\", newOffset);\n\n                var expr = Tern.findQueryExpr(file, request.query);\n                Infer.resetGuessing();\n                var type = Infer.expressionType(expr);\n                type = type.getFunctionType() || type.getType();\n\n                if (type) {\n                    fnType = getParameters(type);\n                } else {\n                    ternError = \"No parameter type found\";\n                    _log(ternError);\n                }\n            }\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    }\n\n    // Post a message back to the main thread with the completions\n    self.postMessage({type: MessageIds.TERN_CALLED_FUNC_TYPE_MSG,\n        file: _getNormalizedFilename(fileInfo.name),\n        offset: offset,\n        fnType: fnType,\n        error: error\n    });\n}\n\n/**\n *  Add an array of files to tern.\n *\n * @param {Array.<string>} files - each string in the array is the full\n * path of a file.\n */\nfunction handleAddFiles(files) {\n    files.forEach(function (file) {\n        ternServer.addFile(file);\n    });\n}\n\n/**\n *  Update the context of a file in tern.\n *\n * @param {string} path - full path of file.\n * @param {string} text - content of the file.\n */\nfunction handleUpdateFile(path, text) {\n\n    ternServer.addFile(path, text);\n\n    self.postMessage({type: MessageIds.TERN_UPDATE_FILE_MSG,\n        path: path\n    });\n\n    // reset to get the best hints with the updated file.\n    ternServer.reset();\n    Infer.resetGuessing();\n}\n\n/**\n *  Make a completions request to tern to force tern to resolve files\n *  and create a fast first lookup for the user.\n * @param {string} path     - the path of the file\n */\nfunction handlePrimePump(path) {\n    var fileName = _getDenormalizedFilename(path);\n    var fileInfo = createEmptyUpdate(fileName),\n        request = buildRequest(fileInfo, \"completions\", {line: 0, ch: 0});\n\n    try {\n        ternServer.request(request, function (error, data) {\n            // Post a message back to the main thread\n            self.postMessage({type: MessageIds.TERN_PRIME_PUMP_MSG,\n                path: _getNormalizedFilename(path)\n            });\n        });\n    } catch (e) {\n        _reportError(e, path);\n    }\n}\n\n/**\n * Updates the configuration, typically for debugging purposes.\n *\n * @param {Object} configUpdate new configuration\n */\nfunction setConfig(configUpdate) {\n    config = configUpdate;\n}\n\nfunction _requestTernServer(commandConfig) {\n    var file, text, offset,\n        request = commandConfig,\n        type = request.type;\n    if (config.debug) {\n        _log(\"Message received \" + type);\n    }\n\n    if (type === MessageIds.TERN_INIT_MSG) {\n        var env     = request.env,\n            files   = request.files;\n        inferenceTimeout = request.timeout;\n        initTernServer(env, files);\n    } else if (type === MessageIds.TERN_COMPLETIONS_MSG) {\n        offset  = request.offset;\n        getTernHints(request.fileInfo, offset, request.isProperty);\n    } else if (type === MessageIds.TERN_GET_FILE_MSG) {\n        file = request.file;\n        text = request.text;\n        handleGetFile(file, text);\n    } else if (type === MessageIds.TERN_CALLED_FUNC_TYPE_MSG) {\n        offset  = request.offset;\n        handleFunctionType(request.fileInfo, offset);\n    } else if (type === MessageIds.TERN_JUMPTODEF_MSG) {\n        offset  = request.offset;\n        getJumptoDef(request.fileInfo, offset);\n    } else if (type === MessageIds.TERN_SCOPEDATA_MSG) {\n        offset  = request.offset;\n        getScopeData(request.fileInfo, offset);\n    } else if (type === MessageIds.TERN_REFS) {\n        offset  = request.offset;\n        getRefs(request.fileInfo, offset);\n    } else if (type === MessageIds.TERN_ADD_FILES_MSG) {\n        handleAddFiles(request.files);\n    } else if (type === MessageIds.TERN_PRIME_PUMP_MSG) {\n        isUntitledDoc = request.isUntitledDoc;\n        handlePrimePump(request.path);\n    } else if (type === MessageIds.TERN_GET_GUESSES_MSG) {\n        offset  = request.offset;\n        getTernProperties(request.fileInfo, offset, MessageIds.TERN_GET_GUESSES_MSG);\n    } else if (type === MessageIds.TERN_UPDATE_FILE_MSG) {\n        handleUpdateFile(request.path, request.text);\n    } else if (type === MessageIds.SET_CONFIG) {\n        setConfig(request.config);\n    } else if (type === MessageIds.TERN_UPDATE_DIRTY_FILE) {\n        ExtractContent.updateFilesCache(request.name, request.action);\n    } else if (type === MessageIds.TERN_CLEAR_DIRTY_FILES_LIST) {\n        ExtractContent.clearFilesCache();\n    } else {\n        _log(\"Unknown message: \" + JSON.stringify(request));\n    }\n}\n\nfunction invokeTernCommand(commandConfig) {\n    try {\n        _requestTernServer(commandConfig);\n    } catch (error) {\n        console.warn(error);\n    }\n}\n\nfunction setInterface(msgInterface) {\n    MessageIds = msgInterface.messageIds;\n}\n\nfunction checkInterfaceAndReInit() {\n    if (!MessageIds) {\n        // WTF - Worse than failure\n        // We are here as node process got restarted\n        // Request for ReInitialization of interface and Tern Server\n        self.postMessage({\n            type: \"RE_INIT_TERN\"\n        });\n    }\n}\n\n /**\n * Initialize the test domain with commands and events related to find in files.\n * @param {DomainManager} domainManager The DomainManager for the TernNodeDomain\n */\nfunction init(domainManager) {\n    if (!domainManager.hasDomain(\"TernNodeDomain\")) {\n        domainManager.registerDomain(\"TernNodeDomain\", {major: 0, minor: 1});\n    }\n\n    _domainManager = domainManager;\n\n    domainManager.registerCommand(\n        \"TernNodeDomain\",       // domain name\n        \"invokeTernCommand\",    // command name\n        invokeTernCommand,   // command handler function\n        false,          // this command is synchronous in Node\n        \"Invokes a tern command on node\",\n        [{name: \"commandConfig\", // parameters\n            type: \"object\",\n            description: \"Object containing tern command configuration\"}]\n    );\n\n    domainManager.registerCommand(\n        \"TernNodeDomain\",       // domain name\n        \"setInterface\",    // command name\n        setInterface,   // command handler function\n        false,          // this command is synchronous in Node\n        \"Sets the shared message interface\",\n        [{name: \"msgInterface\", // parameters\n            type: \"object\",\n            description: \"Object containing messageId enums\"}]\n    );\n\n    domainManager.registerCommand(\n        \"TernNodeDomain\",       // domain name\n        \"resetTernServer\",    // command name\n        resetTernServer,   // command handler function\n        true,          // this command is synchronous in Node\n        \"Resets an existing tern server\"\n    );\n\n    domainManager.registerEvent(\n        \"TernNodeDomain\",     // domain name\n        \"data\",   // event name\n        [\n            {\n                name: \"data\",\n                type: \"Object\",\n                description: \"data to be returned to main thread\"\n            }\n        ]\n    );\n    setTimeout(checkInterfaceAndReInit, 1000);\n}\n\nexports.init = init;\n"],"file":"TernNodeDomain.js"}
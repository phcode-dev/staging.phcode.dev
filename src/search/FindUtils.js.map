{"version":3,"sources":["search/FindUtils.js"],"names":["define","require","exports","module","Async","DocumentManager","MainViewManager","FileSystem","FileUtils","ProjectManager","EventDispatcher","Strings","StringUtils","_","instantSearchDisabled","indexingInProgress","workerSearchCount","collapseResults","parseDollars","replaceWith","match","replace","whole","dollars","index","length","substr","parsedIndex","parseInt","_doReplaceInDocument","doc","matchInfo","replaceText","isRegexp","diskTimestamp","getTime","timestamp","$","Deferred","reject","ERROR_FILE_CHANGED","promise","batchOperation","matches","reverse","forEach","isChecked","replaceRange","result","start","end","resolve","_doReplaceOnDisk","fullPath","file","getFileForPath","getDocumentText","then","contents","lineEndings","lastIndex","push","slice","startOffset","endOffset","newContents","join","LINE_ENDINGS_CRLF","promisify","_doReplaceInOneFile","options","getOpenDocumentForPath","forceFilesOpen","findInWorkingSet","ALL_PANES","getDocumentForPath","newDoc","hasCheckedMatches","some","performReplacements","results","doInParallel_aggregateErrors","Object","keys","done","getCurrentDocument","sortedPaths","sort","comparePaths","firstPath","find","path","_edit","ACTIVE_PANE","labelForScope","scope","format","FIND_IN_FILES_SCOPED","breakableUrl","makeProjectRelativeIfPossible","FIND_IN_FILES_NO_SCOPE","parseQueryInfo","queryInfo","queryExpr","query","empty","flags","isCaseSensitive","RegExp","e","valid","error","message","regexEscape","prioritizeOpenFile","files","firstFile","workingSetFiles","getWorkingSet","workingSetFileFound","fileSetWithoutWorkingSet","startingWorkingFileSet","propertyName","i","filter","key","undefined","hasOwnProperty","concat","getOpenFilePath","currentDoc","setInstantSearchDisabled","disable","isInstantSearchDisabled","isWorkerSearchInProgress","notifyFileFiltersChanged","trigger","SEARCH_FILE_FILTERS_CHANGED","notifySearchScopeChanged","SEARCH_SCOPE_CHANGED","notifyWorkerSearchStarted","notifyWorkerSearchFinished","notifyIndexingStarted","SEARCH_INDEXING_STARTED","notifyIndexingProgress","progress","total","SEARCH_INDEXING_PROGRESS","notifyIndexingFinished","SEARCH_INDEXING_FINISHED","isIndexingInProgress","setCollapseResults","collapse","SEARCH_COLLAPSE_RESULTS","isCollapsedResults","makeEventDispatcher"],"mappings":"AAqBAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,MAAsBH,QAAQ,eAC9BI,gBAAsBJ,QAAQ,4BAC9BK,gBAAsBL,QAAQ,wBAC9BM,WAAsBN,QAAQ,yBAC9BO,UAAsBP,QAAQ,kBAC9BQ,eAAsBR,QAAQ,0BAC9BS,gBAAsBT,QAAQ,yBAC9BU,QAAsBV,QAAQ,WAC9BW,YAAsBX,QAAQ,qBAC9BY,EAAsBZ,QAAQ,qBAE9Ba,uBAAwB,EACxBC,oBAAqB,EACrBC,kBAAoB,EACpBC,iBAAkB,EAatB,SAASC,aAAaC,YAAaC,OAsB/B,OADAD,aApBAA,YAAcA,YAAYE,QAAQ,oBAAqB,SAAUC,MAAOC,QAASC,OAC7E,GAAID,QAAQE,OAAS,GAAM,EAAG,CAC1B,GAAc,MAAVD,MAGA,OAAOD,QAAQG,OAAO,IAAMN,MAAM,IAAM,IAG5C,IAAIO,YAAcC,SAASJ,MAAO,IAClC,GAAoB,IAAhBG,YAGA,OAAOJ,QAAQG,OAAO,IAAMN,MAAMO,cAAgB,IAK1D,OAAOL,SAGeD,QAAQ,QAAS,KAY/C,SAASQ,qBAAqBC,IAAKC,UAAWC,YAAaC,UAQvD,OAAIH,IAAII,cAAcC,YAAcJ,UAAUK,UAAUD,WAC7C,IAAIE,EAAEC,UAAWC,OAAOrC,QAAQsC,oBAAoBC,WAI/DX,IAAIY,eAAe,WACfX,UAAUY,QAAQC,UAAUC,QAAQ,SAAUzB,OACtCA,MAAM0B,WACNhB,IAAIiB,aAAad,SAAWf,aAAac,YAAaZ,MAAM4B,QAAUhB,YAAaZ,MAAM6B,MAAO7B,MAAM8B,UAK3G,IAAIb,EAAEC,UAAWa,UAAUV,WAWtC,SAASW,iBAAiBC,SAAUtB,UAAWC,YAAaC,UACxD,IAAIqB,KAAO/C,WAAWgD,eAAeF,UACrC,OAAOhD,gBAAgBmD,gBAAgBF,MAAM,GAAMG,KAAK,SAAUC,SAAUtB,UAAWuB,aACnF,GAAIvB,UAAUD,YAAcJ,UAAUK,UAAUD,UAG5C,OAAO,IAAIE,EAAEC,UAAWC,OAAOrC,QAAQsC,oBAAoBC,UAK/D,IAAIO,OAAS,GACTY,UAAY,EAChB7B,UAAUY,QAAQE,QAAQ,SAAUzB,OAC5BA,MAAM0B,YACNE,OAAOa,KAAKH,SAASI,MAAMF,UAAWxC,MAAM2C,cAC5Cf,OAAOa,KAAK5B,SAAWf,aAAac,YAAaZ,MAAM4B,QAAUhB,aACjE4B,UAAYxC,MAAM4C,aAG1BhB,OAAOa,KAAKH,SAASI,MAAMF,YAE3B,IAAIK,YAAcjB,OAAOkB,KAAK,IAM9B,OAJIP,cAAgBnD,UAAU2D,oBAC1BF,YAAcA,YAAY5C,QAAQ,MAAO,SAGtCjB,MAAMgE,UAAUd,KAAM,QAASW,eAiB9C,SAASI,oBAAoBhB,SAAUtB,UAAWC,YAAasC,SAC3D,IAAIxC,IAAMzB,gBAAgBkE,uBAAuBlB,UAIjD,OAHAiB,QAAUA,SAAW,GAGhBxC,MAAQwC,QAAQE,iBAA6F,IAA3ElE,gBAAgBmE,iBAAiBnE,gBAAgBoE,UAAWrB,UAIxFvB,IACAD,qBAAqBC,IAAKC,UAAWC,YAAasC,QAAQrC,UAE9DmB,iBAAiBC,SAAUtB,UAAWC,YAAasC,QAAQrC,UANvD5B,gBAAgBsE,mBAAmBtB,UAAUI,KAAK,SAAUmB,QAC/D,OAAO/C,qBAAqB+C,OAAQ7C,UAAWC,YAAasC,QAAQrC,YAahF,SAAS4C,kBAAkB7B,QACvB,OAAOA,OAAOL,QAAQmC,KAAK,SAAU1D,OAAS,OAAOA,MAAM0B,YA4B/D,SAASiC,oBAAoBC,QAAShD,YAAasC,SAC/C,OAAOlE,MAAM6E,6BAA6BC,OAAOC,KAAKH,SAAU,SAAU3B,UACtE,OAAOgB,oBAAoBhB,SAAU2B,QAAQ3B,UAAWrB,YAAasC,WACtEc,KAAK,WACJ,GAAId,SAAWA,QAAQE,eAAgB,CAGnC,IAAI1C,IAAMzB,gBAAgBgF,qBAC1B,IAAKvD,MACIkD,QAAQlD,IAAIwB,KAAKD,YACjBwB,kBAAkBG,QAAQlD,IAAIwB,KAAKD,WAAY,CAKpD,IAAIiC,YAAcJ,OAAOC,KAAKH,SAASO,KAAK/E,UAAUgF,cAClDC,UAAY5E,EAAE6E,KAAKJ,YAAa,SAAUK,MACtC,OAAOd,kBAAkBG,QAAQW,SAGzC,GAAIF,UAAW,CACX,IAAIb,OAASvE,gBAAgBkE,uBAAuBkB,WAEhDb,QAWAtE,gBAAgBsF,MAAMtF,gBAAgBuF,YAAajB,aAa3E,SAASkB,cAAcC,OACnB,OAAIA,MACOnF,YAAYoF,OACfrF,QAAQsF,qBACRrF,YAAYsF,aACRzF,eAAe0F,8BAA8BJ,MAAM1C,YAIxD1C,QAAQyF,uBAanB,SAASC,eAAeC,WACpB,IAAIC,UAEJ,IAAKD,YAAcA,UAAUE,MACzB,MAAO,CAACC,OAAO,GAMnB,IAAIC,MAAQ,KAMZ,GALKJ,UAAUK,kBACXD,OAAS,KAITJ,UAAUrE,SACV,IACIsE,UAAY,IAAIK,OAAON,UAAUE,MAAOE,OAC1C,MAAOG,GACL,MAAO,CAACC,OAAO,EAAOC,MAAOF,EAAEG,cAInCT,UAAY,IAAIK,OAAOhG,YAAYqG,YAAYX,UAAUE,OAAQE,OAErE,MAAO,CAACI,OAAO,EAAMP,UAAWA,WASpC,SAASW,mBAAmBC,MAAOC,WAC/B,IAAIC,gBAAkB/G,gBAAgBgH,cAAchH,gBAAgBoE,WAChE6C,oBAAsB,GACtBC,yBAA2B,GAC3BC,uBAAyB,GACzBC,aAAe,GACfC,EAAI,EAIR,IAHAP,UAAYA,WAAa,GAGpBO,EAAI,EAAGA,EAAIN,gBAAgB5F,OAAQkG,IACpCJ,oBAAoBF,gBAAgBM,GAAGtE,WAAY,EAkBvD,IAAKqE,gBAdLF,yBAA2BL,MAAMS,OAAO,SAAUC,KAC9C,YAAiCC,IAA7BP,oBAAoBM,OACpBN,oBAAoBM,MAAO,GACpB,MAMwB,IAAnCN,oBAAoBH,aACpBK,uBAAuB5D,KAAKuD,WAC5BG,oBAAoBH,YAAa,GAGhBG,oBACbA,oBAAoBQ,eAAeL,eAAiBH,oBAAoBG,eACxED,uBAAuB5D,KAAK6D,cAGpC,OAAOD,uBAAuBO,OAAOR,0BAQzC,SAASS,kBACL,IAAIC,WAAa7H,gBAAgBgF,qBACjC,OAAO6C,WAAaA,WAAW5E,KAAKD,SAAW,KAOnD,SAAS8E,yBAAyBC,SAC9BtH,sBAAwBsH,QAO5B,SAASC,0BACL,OAAOvH,sBAOX,SAASwH,2BACL,OAA0B,IAAtBtH,kBAWR,SAASuH,2BACLrI,QAAQsI,QAAQtI,QAAQuI,6BAM5B,SAASC,2BACLxI,QAAQsI,QAAQtI,QAAQyI,sBAO5B,SAASC,4BACL5H,oBAOJ,SAAS6H,6BACL7H,oBAMJ,SAAS8H,wBACL/H,oBAAqB,EACrBb,QAAQsI,QAAQtI,QAAQ6I,yBAM5B,SAASC,uBAAuBC,SAAUC,OACtChJ,QAAQsI,QAAQtI,QAAQiJ,yBAA0BF,SAAUC,OAMhE,SAASE,yBACLrI,oBAAqB,EACrBb,QAAQsI,QAAQtI,QAAQmJ,0BAO5B,SAASC,uBACL,OAAOvI,mBAOX,SAASwI,mBAAmBC,UACxBvI,gBAAkBuI,SAClBtJ,QAAQsI,QAAQtI,QAAQuJ,yBAO5B,SAASC,qBACL,OAAOzI,gBAzaXP,gBAAgBiJ,oBAAoBzJ,SA4apCA,QAAQgB,aAAkCA,aAC1ChB,QAAQ2E,kBAAkCA,kBAC1C3E,QAAQ6E,oBAAkCA,oBAC1C7E,QAAQ4F,cAAkCA,cAC1C5F,QAAQmG,eAAkCA,eAC1CnG,QAAQgH,mBAAkCA,mBAC1ChH,QAAQ+H,gBAAkCA,gBAC1C/H,QAAQiI,yBAAkCA,yBAC1CjI,QAAQmI,wBAAkCA,wBAC1CnI,QAAQoI,yBAAkCA,yBAC1CpI,QAAQoJ,qBAAkCA,qBAC1CpJ,QAAQqJ,mBAAkCA,mBAC1CrJ,QAAQwJ,mBAAkCA,mBAC1CxJ,QAAQsC,mBAAkC,cAG1CtC,QAAQqI,yBAAkCA,yBAC1CrI,QAAQwI,yBAAkCA,yBAC1CxI,QAAQ0I,0BAAkCA,0BAC1C1I,QAAQ2I,2BAAkCA,2BAC1C3I,QAAQ4I,sBAAkCA,sBAC1C5I,QAAQ8I,uBAAkCA,uBAC1C9I,QAAQkJ,uBAAkCA,uBAG1ClJ,QAAQuI,4BAA2C,qBACnDvI,QAAQyI,qBAA2C,qBACnDzI,QAAQ6I,wBAA2C,wBACnD7I,QAAQiJ,yBAA2C,yBACnDjJ,QAAQmJ,yBAA2C,yBACnDnJ,QAAQuJ,wBAA2C","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var Async               = require(\"utils/Async\"),\n        DocumentManager     = require(\"document/DocumentManager\"),\n        MainViewManager     = require(\"view/MainViewManager\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        ProjectManager      = require(\"project/ProjectManager\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        Strings             = require(\"strings\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        _                   = require(\"thirdparty/lodash\");\n\n    var instantSearchDisabled = false,\n        indexingInProgress = false,\n        workerSearchCount = 0,\n        collapseResults = false;\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    /**\n     * Given a replace string that contains $-expressions, replace them with data from the given\n     * regexp match info.\n     * NOTE: we can't just use the ordinary replace() function here because the string has been\n     * extracted from the original text and so might be missing some context that the regexp matched.\n     * @param {string} replaceWith The string containing the $-expressions.\n     * @param {Object} match The match data from the regexp.\n     * @return {string} The replace text with the $-expressions substituted.\n     */\n    function parseDollars(replaceWith, match) {\n        replaceWith = replaceWith.replace(/(\\$+)(\\d{1,2}|&)/g, function (whole, dollars, index) {\n            if (dollars.length % 2 === 1) { // make sure dollar signs don't escape themselves (like $$1, $$$$&)\n                if (index === \"&\") { // handle $&\n                    // slice the first dollar (but leave any others to get unescaped below) and return the\n                    // whole match\n                    return dollars.substr(1) + (match[0] || \"\");\n                }\n                    // now we're sure index is an integer, so we can parse it\n                var parsedIndex = parseInt(index, 10);\n                if (parsedIndex !== 0) { // handle $n or $nn, but don't handle $0 or $00\n                        // slice the first dollar (but leave any others to get unescaped below) and return the\n                        // the corresponding match\n                    return dollars.substr(1) + (match[parsedIndex] || \"\");\n                }\n\n            }\n            // this code gets called if the dollar signs escape themselves or if $0/$00 (not handled) was present\n            return whole; // return everything to get handled below\n        });\n        // replace escaped dollar signs (i.e. $$, $$$$, ...) with single ones (unescaping)\n        replaceWith = replaceWith.replace(/\\$\\$/g, \"$\");\n        return replaceWith;\n    }\n\n    /**\n     * Does a set of replacements in a single document in memory.\n     * @param {!Document} doc The document to do the replacements in.\n     * @param {Object} matchInfo The match info for this file, as returned by `_addSearchMatches()`. Might be mutated.\n     * @param {string} replaceText The text to replace each result with.\n     * @param {boolean=} isRegexp Whether the original query was a regexp.\n     * @return {$.Promise} A promise that's resolved when the replacement is finished or rejected with an error if there were one or more errors.\n     */\n    function _doReplaceInDocument(doc, matchInfo, replaceText, isRegexp) {\n        // Double-check that the open document's timestamp matches the one we recorded. This\n        // should normally never go out of sync, because if it did we wouldn't start the\n        // replace in the first place (due to the fact that we immediately close the search\n        // results panel whenever we detect a filesystem change that affects the results),\n        // but we want to double-check in case we don't happen to get the change in time.\n        // This will *not* handle cases where the document has been edited in memory since\n        // the matchInfo was generated.\n        if (doc.diskTimestamp.getTime() !== matchInfo.timestamp.getTime()) {\n            return new $.Deferred().reject(exports.ERROR_FILE_CHANGED).promise();\n        }\n\n        // Do the replacements in reverse document order so the offsets continue to be correct.\n        doc.batchOperation(function () {\n            matchInfo.matches.reverse().forEach(function (match) {\n                if (match.isChecked) {\n                    doc.replaceRange(isRegexp ? parseDollars(replaceText, match.result) : replaceText, match.start, match.end);\n                }\n            });\n        });\n\n        return new $.Deferred().resolve().promise();\n    }\n\n    /**\n     * Does a set of replacements in a single file on disk.\n     * @param {string} fullPath The full path to the file.\n     * @param {Object} matchInfo The match info for this file, as returned by `_addSearchMatches()`.\n     * @param {string} replaceText The text to replace each result with.\n     * @param {boolean=} isRegexp Whether the original query was a regexp.\n     * @return {$.Promise} A promise that's resolved when the replacement is finished or rejected with an error if there were one or more errors.\n     */\n    function _doReplaceOnDisk(fullPath, matchInfo, replaceText, isRegexp) {\n        var file = FileSystem.getFileForPath(fullPath);\n        return DocumentManager.getDocumentText(file, true).then(function (contents, timestamp, lineEndings) {\n            if (timestamp.getTime() !== matchInfo.timestamp.getTime()) {\n                // Return a promise that we'll reject immediately. (We can't just return the\n                // error since this is the success handler.)\n                return new $.Deferred().reject(exports.ERROR_FILE_CHANGED).promise();\n            }\n\n            // Note that this assumes that the matches are sorted.\n            // TODO: is there a more efficient way to do this in a large string?\n            var result = [],\n                lastIndex = 0;\n            matchInfo.matches.forEach(function (match) {\n                if (match.isChecked) {\n                    result.push(contents.slice(lastIndex, match.startOffset));\n                    result.push(isRegexp ? parseDollars(replaceText, match.result) : replaceText);\n                    lastIndex = match.endOffset;\n                }\n            });\n            result.push(contents.slice(lastIndex));\n\n            var newContents = result.join(\"\");\n            // TODO: duplicated logic from Document - should refactor this?\n            if (lineEndings === FileUtils.LINE_ENDINGS_CRLF) {\n                newContents = newContents.replace(/\\n/g, \"\\r\\n\");\n            }\n\n            return Async.promisify(file, \"write\", newContents);\n        });\n    }\n\n    /**\n     * Does a set of replacements in a single file. If the file is already open in a Document in memory,\n     * will do the replacement there, otherwise does it directly on disk.\n     * @param {string} fullPath The full path to the file.\n     * @param {Object} matchInfo The match info for this file, as returned by `_addSearchMatches()`.\n     * @param {string} replaceText The text to replace each result with.\n     * @param {Object=} options An options object:\n     *      forceFilesOpen: boolean - Whether to open the file in an editor and do replacements there rather than doing the\n     *          replacements on disk. Note that even if this is false, files that are already open in editors will have replacements\n     *          done in memory.\n     *      isRegexp: boolean - Whether the original query was a regexp. If true, $-substitution is performed on the replaceText.\n     * @return {$.Promise} A promise that's resolved when the replacement is finished or rejected with an error if there were one or more errors.\n     */\n    function _doReplaceInOneFile(fullPath, matchInfo, replaceText, options) {\n        var doc = DocumentManager.getOpenDocumentForPath(fullPath);\n        options = options || {};\n        // If we're forcing files open, or if the document is in the working set but not actually open\n        // yet, we want to open the file and do the replacement in memory.\n        if (!doc && (options.forceFilesOpen || MainViewManager.findInWorkingSet(MainViewManager.ALL_PANES, fullPath) !== -1)) {\n            return DocumentManager.getDocumentForPath(fullPath).then(function (newDoc) {\n                return _doReplaceInDocument(newDoc, matchInfo, replaceText, options.isRegexp);\n            });\n        } else if (doc) {\n            return _doReplaceInDocument(doc, matchInfo, replaceText, options.isRegexp);\n        }\n        return _doReplaceOnDisk(fullPath, matchInfo, replaceText, options.isRegexp);\n\n    }\n\n    /**\n     * @private\n     * Returns true if a search result has any checked matches.\n     */\n    function hasCheckedMatches(result) {\n        return result.matches.some(function (match) { return match.isChecked; });\n    }\n\n    /**\n     * Given a set of search results, replaces them with the given replaceText, either on disk or in memory.\n     * Checks timestamps to ensure replacements are not performed in files that have changed on disk since\n     * the original search results were generated. However, does *not* check whether edits have been performed\n     * in in-memory documents since the search; it's up to the caller to guarantee this hasn't happened.\n     * (When called from the standard Find in Files UI, SearchResultsView guarantees this. If called headlessly,\n     * the caller needs to track changes.)\n     *\n     * Replacements in documents that are already open in memory at the start of the replacement are guaranteed to\n     * happen synchronously; replacements in files on disk will return an error if the on-disk file changes between\n     * the time performReplacements() is called and the time the replacement actually happens.\n     *\n     * @param {Object.<fullPath: string, {matches: Array.<{start: {line:number,ch:number}, end: {line:number,ch:number}, startOffset: number, endOffset: number, line: string}>, collapsed: boolean}>} results\n     *      The list of results to replace, as returned from _doSearch..\n     * @param {string} replaceText The text to replace each result with.\n     * @param {?Object} options An options object:\n     *      forceFilesOpen: boolean - Whether to open all files in editors and do replacements there rather than doing the\n     *          replacements on disk. Note that even if this is false, files that are already open in editors will have replacements\n     *          done in memory.\n     *      isRegexp: boolean - Whether the original query was a regexp. If true, $-substitution is performed on the replaceText.\n     * @return {$.Promise} A promise that's resolved when the replacement is finished or rejected with an array of errors\n     *      if there were one or more errors. Each individual item in the array will be a {item: string, error: string} object,\n     *      where item is the full path to the file that could not be updated, and error is either a FileSystem error or one\n     *      of the `FindUtils.ERROR_*` constants.\n     */\n    function performReplacements(results, replaceText, options) {\n        return Async.doInParallel_aggregateErrors(Object.keys(results), function (fullPath) {\n            return _doReplaceInOneFile(fullPath, results[fullPath], replaceText, options);\n        }).done(function () {\n            if (options && options.forceFilesOpen) {\n                // If the currently selected document wasn't modified by the search, or there is no open document,\n                // then open the first modified document.\n                var doc = DocumentManager.getCurrentDocument();\n                if (!doc ||\n                        !results[doc.file.fullPath] ||\n                        !hasCheckedMatches(results[doc.file.fullPath])) {\n                    // Figure out the first modified document. This logic is slightly different from\n                    // SearchResultsView._getSortedFiles() because it doesn't sort the currently open file to\n                    // the top. But if the currently open file were in the search results, we wouldn't be\n                    // doing this anyway.\n                    var sortedPaths = Object.keys(results).sort(FileUtils.comparePaths),\n                        firstPath = _.find(sortedPaths, function (path) {\n                            return hasCheckedMatches(results[path]);\n                        });\n\n                    if (firstPath) {\n                        var newDoc = DocumentManager.getOpenDocumentForPath(firstPath);\n                        // newDoc might be null if the replacement failed.\n                        if (newDoc) {\n                            // @todo change the `_edit` call to this:\n                            //\n                            ///    CommandManager.execute(Commands.FILE_OPEN, {fullPath: firstPath});\n                            //\n                            // The problem with doing that is that the promise returned by this\n                            // function has already been resolved by `Async.doInParallel()` and\n                            // `CommandManager.execute` is an asynchronous operation.\n                            // An asynchronous open can't be waited on (since the promise has been\n                            //  resolved already) so use the synchronous version so that the next `done`\n                            //  handler is blocked until the open completes\n                            MainViewManager._edit(MainViewManager.ACTIVE_PANE, newDoc);\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Returns label text to indicate the search scope. Already HTML-escaped.\n     * @param {?Entry} scope\n     * @return {string}\n     */\n    function labelForScope(scope) {\n        if (scope) {\n            return StringUtils.format(\n                Strings.FIND_IN_FILES_SCOPED,\n                StringUtils.breakableUrl(\n                    ProjectManager.makeProjectRelativeIfPossible(scope.fullPath)\n                )\n            );\n        }\n        return Strings.FIND_IN_FILES_NO_SCOPE;\n\n    }\n\n    /**\n     * Parses the given query into a regexp, and returns whether it was valid or not.\n     * @param {{query: string, caseSensitive: boolean, isRegexp: boolean}} queryInfo\n     * @return {{queryExpr: RegExp, valid: boolean, empty: boolean, error: string}}\n     *      queryExpr - the regexp representing the query\n     *      valid - set to true if query is a nonempty string or a valid regexp.\n     *      empty - set to true if query was empty.\n     *      error - set to an error string if valid is false and query is nonempty.\n     */\n    function parseQueryInfo(queryInfo) {\n        var queryExpr;\n\n        if (!queryInfo || !queryInfo.query) {\n            return {empty: true};\n        }\n\n        // For now, treat all matches as multiline (i.e. ^/$ match on every line, not the whole\n        // document). This is consistent with how single-file find works. Eventually we should add\n        // an option for this.\n        var flags = \"gm\";\n        if (!queryInfo.isCaseSensitive) {\n            flags += \"i\";\n        }\n\n        // Is it a (non-blank) regex?\n        if (queryInfo.isRegexp) {\n            try {\n                queryExpr = new RegExp(queryInfo.query, flags);\n            } catch (e) {\n                return {valid: false, error: e.message};\n            }\n        } else {\n            // Query is a plain string. Turn it into a regexp\n            queryExpr = new RegExp(StringUtils.regexEscape(queryInfo.query), flags);\n        }\n        return {valid: true, queryExpr: queryExpr};\n    }\n\n     /**\n     * Prioritizes the open file and then the working set files to the starting of the list of files\n     * @param {Array.<*>} files An array of file paths or file objects to sort\n     * @param {?string} firstFile If specified, the path to the file that should be sorted to the top.\n     * @return {Array.<*>}\n     */\n    function prioritizeOpenFile(files, firstFile) {\n        var workingSetFiles = MainViewManager.getWorkingSet(MainViewManager.ALL_PANES),\n            workingSetFileFound = {},\n            fileSetWithoutWorkingSet = [],\n            startingWorkingFileSet = [],\n            propertyName = \"\",\n            i = 0;\n        firstFile = firstFile || \"\";\n\n        // Create a working set path map which indicates if a file in working set is found in file list\n        for (i = 0; i < workingSetFiles.length; i++) {\n            workingSetFileFound[workingSetFiles[i].fullPath] = false;\n        }\n\n        // Remove all the working set files from the filtration list\n        fileSetWithoutWorkingSet = files.filter(function (key) {\n            if (workingSetFileFound[key] !== undefined) {\n                workingSetFileFound[key] = true;\n                return false;\n            }\n            return true;\n        });\n\n        //push in the first file\n        if (workingSetFileFound[firstFile] === true) {\n            startingWorkingFileSet.push(firstFile);\n            workingSetFileFound[firstFile] = false;\n        }\n        //push in the rest of working set files already present in file list\n        for (propertyName in workingSetFileFound) {\n            if (workingSetFileFound.hasOwnProperty(propertyName) && workingSetFileFound[propertyName]) {\n                startingWorkingFileSet.push(propertyName);\n            }\n        }\n        return startingWorkingFileSet.concat(fileSetWithoutWorkingSet);\n    }\n\n\n    /**\n     * Returns the path of the currently open file or null if there isn't one open\n     * @return {?string}\n     */\n    function getOpenFilePath() {\n        var currentDoc = DocumentManager.getCurrentDocument();\n        return currentDoc ? currentDoc.file.fullPath : null;\n    }\n\n    /**\n     * enable/disable instant search\n     * @param {boolean} disable true to disable web worker based search\n     */\n    function setInstantSearchDisabled(disable) {\n        instantSearchDisabled = disable;\n    }\n\n    /**\n     * if instant search is disabled, this will return true we can only do instant search through worker\n     * @return {boolean}\n     */\n    function isInstantSearchDisabled() {\n        return instantSearchDisabled;\n    }\n\n    /**\n     * check if a search is progressing in worker\n     * @return {Boolean} true if search is processing in worker\n     */\n    function isWorkerSearchInProgress() {\n        if (workerSearchCount === 0) {\n            return false;\n        }\n        return true;\n\n    }\n\n\n    /**\n     * Raises an event when the file filters applied to a search changes\n     */\n    function notifyFileFiltersChanged() {\n        exports.trigger(exports.SEARCH_FILE_FILTERS_CHANGED);\n    }\n\n    /**\n     * Raises an event when the search scope changes[say search in a subdirectory in the project]\n     */\n    function notifySearchScopeChanged() {\n        exports.trigger(exports.SEARCH_SCOPE_CHANGED);\n    }\n\n    /**\n     * Notifies that a worker search has started so that we FindUtils can figure out\n     * if any outstanding worker search requests are pending\n     */\n    function notifyWorkerSearchStarted() {\n        workerSearchCount++;\n    }\n\n    /**\n     * Notifies that a worker search has finished so that we FindUtils can figure out\n     * if any outstanding worker search requests are pending\n     */\n    function notifyWorkerSearchFinished() {\n        workerSearchCount--;\n    }\n\n    /**\n     * Notifies that a worker has started indexing the files\n     */\n    function notifyIndexingStarted() {\n        indexingInProgress = true;\n        exports.trigger(exports.SEARCH_INDEXING_STARTED);\n    }\n\n    /**\n     * Notifies that a worker has started indexing the files\n     */\n    function notifyIndexingProgress(progress, total) {\n        exports.trigger(exports.SEARCH_INDEXING_PROGRESS, progress, total);\n    }\n\n    /**\n     * Notifies that a worker has finished indexing the files\n     */\n    function notifyIndexingFinished() {\n        indexingInProgress = false;\n        exports.trigger(exports.SEARCH_INDEXING_FINISHED);\n    }\n\n    /**\n     * Return true if indexing is in progress in worker\n     * @return {boolean} true if files are being indexed in worker\n     */\n    function isIndexingInProgress() {\n        return indexingInProgress;\n    }\n\n    /**\n     * Set if we need to collapse all results in the results pane\n     * @param {boolean} collapse true to collapse\n     */\n    function setCollapseResults(collapse) {\n        collapseResults = collapse;\n        exports.trigger(exports.SEARCH_COLLAPSE_RESULTS);\n    }\n\n    /**\n     * check if results should be collapsed\n     * @return {boolean} true if results should be collapsed\n     */\n    function isCollapsedResults() {\n        return collapseResults;\n    }\n\n    exports.parseDollars                    = parseDollars;\n    exports.hasCheckedMatches               = hasCheckedMatches;\n    exports.performReplacements             = performReplacements;\n    exports.labelForScope                   = labelForScope;\n    exports.parseQueryInfo                  = parseQueryInfo;\n    exports.prioritizeOpenFile              = prioritizeOpenFile;\n    exports.getOpenFilePath                 = getOpenFilePath;\n    exports.setInstantSearchDisabled        = setInstantSearchDisabled;\n    exports.isInstantSearchDisabled         = isInstantSearchDisabled;\n    exports.isWorkerSearchInProgress        = isWorkerSearchInProgress;\n    exports.isIndexingInProgress            = isIndexingInProgress;\n    exports.setCollapseResults              = setCollapseResults;\n    exports.isCollapsedResults              = isCollapsedResults;\n    exports.ERROR_FILE_CHANGED              = \"fileChanged\";\n\n    // event notification functions\n    exports.notifyFileFiltersChanged        = notifyFileFiltersChanged;\n    exports.notifySearchScopeChanged        = notifySearchScopeChanged;\n    exports.notifyWorkerSearchStarted       = notifyWorkerSearchStarted;\n    exports.notifyWorkerSearchFinished      = notifyWorkerSearchFinished;\n    exports.notifyIndexingStarted           = notifyIndexingStarted;\n    exports.notifyIndexingProgress          = notifyIndexingProgress;\n    exports.notifyIndexingFinished          = notifyIndexingFinished;\n\n    // events raised by FindUtils\n    exports.SEARCH_FILE_FILTERS_CHANGED              = \"fileFiltersChanged\";\n    exports.SEARCH_SCOPE_CHANGED                     = \"searchScopeChanged\";\n    exports.SEARCH_INDEXING_STARTED                  = \"searchIndexingStarted\";\n    exports.SEARCH_INDEXING_PROGRESS                 = \"searchIndexingProgress\";\n    exports.SEARCH_INDEXING_FINISHED                 = \"searchIndexingFinished\";\n    exports.SEARCH_COLLAPSE_RESULTS                  = \"searchCollapseResults\";\n});\n"],"file":"FindUtils.js"}
{"version":3,"sources":["JSUtils/worker/tern-main.js"],"names":["importScripts","Phoenix","baseURL","Tern","tern","_postTernData","data","WorkerComm","triggerPeer","MessageIds","ternOptions","config","fetch","then","async","contents","json","catch","e","console","error","ternServer","isUntitledDoc","inferenceTimeout","fileCallBacks","_dirtyFilesCache","clearDirtyFilesCache","updateDirtyFilesCache","name","action","_reportError","file","TimedOut","type","TERN_INFERENCE_TIMEDOUT","message","stack","handleGetFile","text","contentCallback","_getNormalizedFilename","fileName","projectDir","indexOf","_getDenormalizedFilename","slice","length","_requestFileContent","TERN_GET_FILE_MSG","getFile","contentCb","log","initTernServer","env","files","defs","plugins","requirejs","doc_comment","angular","es_modules","node","node_resolve","complete_strings","commonjs","reset","resetGuessing","Server","forEach","addFile","resetTernServer","TERN_WORKER_READY","createEmptyUpdate","path","TERN_FILE_INFO_TYPE_EMPTY","offsetLines","buildRequest","fileInfo","query","offset","start","end","TERN_FILE_INFO_TYPE_PART","filter","sort","depths","guess","origins","types","expandWordForward","lineCharPositions","docs","urls","request","timeout","fileInfoCopy","JSON","parse","stringify","push","getRefs","response","TERN_REFS","references","getScopeData","ternError","toString","findFile","scope","scopeAt","ast","resolvePos","key","value","includes","propertyName","body","TERN_SCOPEDATA_MSG","getJumptoDef","TERN_JUMPTODEF_MSG","resultFile","isFunction","substring","getTernProperties","i","properties","completions","map","completion","getTernHints","isProperty","depth","origin","doc","url","TERN_COMPLETIONS_MSG","getParameters","inferFnType","recordTypeToString","inferTypeToString","processInferFnTypeParameters","inferFnTypeToString","inferArrTypeToString","inferArrType","result","props","join","formatParameterHint","params","appendSeparators","appendParameter","typesOnly","pendingOptional","param","separators","isOptional","first","prop","Object","keys","inferType","AVal","Prim","Arr","Fn","Obj","undefined","retval","args","argNames","handleFunctionType","preferFunction","fnType","newOffset","line","ch","expr","findQueryExpr","expressionType","getFunctionType","getType","TERN_CALLED_FUNC_TYPE_MSG","handleAddFiles","handleUpdateFile","TERN_UPDATE_FILE_MSG","handlePrimePump","TERN_PRIME_PUMP_MSG","setConfig","configUpdate","_requestTernServer","commandConfig","debug","TERN_INIT_MSG","TERN_ADD_FILES_MSG","TERN_GET_GUESSES_MSG","SET_CONFIG","TERN_UPDATE_DIRTY_FILE","TERN_CLEAR_DIRTY_FILES_LIST","invokeTernCommand","warn","setExecHandler"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2017 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*eslint-env worker */\n/*global Phoenix, WorkerComm, tern*/\n\n// import acorn lib\nimportScripts(`${Phoenix.baseURL}thirdparty/acorn/dist/acorn.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/acorn/dist/acorn_loose.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/acorn/dist/walk.js`);\n// import tern lib\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/lib/signal.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/lib/tern.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/lib/comment.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/lib/def.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/lib/infer.js`);\nconst Tern = tern;\n// import tern plugins\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/modules.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/es_modules.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/doc_comment.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/node.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/node_resolve.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/complete_strings.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/commonjs.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/angular.js`);\n\nfunction _postTernData(data) {\n    WorkerComm.triggerPeer(\"tern-data\", data);\n}\n\nlet MessageIds,\n    ternOptions,\n    config = {};\n\nfetch(`${Phoenix.baseURL}JSUtils/MessageIds.json`)\n    .then(async contents =>{\n        MessageIds = await contents.json();\n    })\n    .catch(e =>{\n        console.error(\"failed to init MessageIds \", e);\n    });\n\nlet ternServer  = null,\n    isUntitledDoc = false,\n    inferenceTimeout;\n\n// Save the tern callbacks for when we get the contents of the file\nlet fileCallBacks = {};\n\nlet _dirtyFilesCache = {};\n\n/**\n * Clears the cache for dirty file paths\n */\nfunction clearDirtyFilesCache() {\n    _dirtyFilesCache = {};\n}\n\n/**\n * Updates the files cache with fullpath when dirty flag changes for a document\n * If the doc is being marked as dirty then an entry is created in the cache\n * If the doc is being marked as clean then the corresponsing entry gets cleared from cache\n *\n * @param {String} name - fullpath of the document\n * @param {boolean} action - whether the document is dirty\n */\nfunction updateDirtyFilesCache(name, action) {\n    if (action) {\n        _dirtyFilesCache[name] = true;\n    } else {\n        if (_dirtyFilesCache[name]) {\n            delete _dirtyFilesCache[name];\n        }\n    }\n}\n\n/**\n * Report exception\n * @private\n * @param {Error} e - the error object\n */\nfunction _reportError(e, file) {\n    if (e instanceof Tern.TimedOut) {\n        // Post a message back to the main thread with timedout info\n        _postTernData({\n            type: MessageIds.TERN_INFERENCE_TIMEDOUT,\n            file: file\n        });\n    } else {\n        console.error(\"Error thrown in tern worker:\" + e.message + \" : file: \" + file , e.stack);\n    }\n}\n\n/**\n * Handle a response from the main thread providing the contents of a file\n * @param {string} file - the name of the file\n * @param {string} text - the contents of the file\n */\nfunction handleGetFile(file, text) {\n    let contentCallback = fileCallBacks[file];\n    if (contentCallback) {\n        try {\n            contentCallback(text);\n        } catch (e) {\n            _reportError(e, file);\n        }\n    }\n    delete fileCallBacks[file];\n}\n\nfunction _getNormalizedFilename(fileName) {\n    if (!isUntitledDoc && ternServer.projectDir && fileName.indexOf(ternServer.projectDir) === -1) {\n        fileName = ternServer.projectDir + fileName;\n    }\n    return fileName;\n}\n\nfunction _getDenormalizedFilename(fileName) {\n    if (!isUntitledDoc && ternServer.projectDir && fileName.indexOf(ternServer.projectDir) === 0) {\n        fileName = fileName.slice(ternServer.projectDir.length);\n    }\n    return fileName;\n}\n\n/**\n * Callback handle to request contents of a file from the main thread\n * @param {string} file - the name of the file\n */\nfunction _requestFileContent(name) {\n    _postTernData({\n        type: MessageIds.TERN_GET_FILE_MSG,\n        file: name\n    });\n}\n\n/**\n * Provide the contents of the requested file to tern\n * @param {string} name - the name of the file\n * @param {Function} contentCb - the function to call with the text of the file\n *  once it has been read in.\n */\nfunction getFile(name, contentCb) {\n    // save the callback\n    fileCallBacks[name] = contentCb;\n\n    try {\n        _requestFileContent(name);\n    } catch (error) {\n        console.log(error);\n    }\n}\n\n/**\n * Create a new tern server.\n *\n * @param {Object} env - an Object with the environment, as read in from\n *  the json files in thirdparty/tern/defs\n * @param {Array.<string>} files - a list of filenames tern should be aware of\n */\nfunction initTernServer(env, files) {\n    ternOptions = {\n        defs: env,\n        async: true,\n        getFile: getFile,\n        plugins: {\n            requirejs: {},\n            doc_comment: true,\n            angular: true,\n            es_modules: true,\n            node: true,\n            node_resolve: true,\n            complete_strings: true,\n            commonjs: true\n        }\n    };\n\n    // If a server is already created just reset the analysis data before marking it for GC\n    if (ternServer) {\n        ternServer.reset();\n        Tern.resetGuessing();\n    }\n\n    ternServer = new Tern.Server(ternOptions);\n\n    files.forEach(function (file) {\n        ternServer.addFile(file);\n    });\n\n}\n\n/**\n * Resets an existing tern server.\n */\nfunction resetTernServer() {\n    // If a server is already created just reset the analysis data\n    if (ternServer) {\n        ternServer.reset();\n        Tern.resetGuessing();\n        // tell the main thread we're ready to start processing again\n        _postTernData({type: MessageIds.TERN_WORKER_READY});\n    }\n}\n\n/**\n * Create a \"empty\" update object.\n *\n * @param {string} path - full path of the file.\n * @return {{type: string, name: string, offsetLines: number, text: string}} -\n * \"empty\" update.\n\n */\nfunction createEmptyUpdate(path) {\n    return {type: MessageIds.TERN_FILE_INFO_TYPE_EMPTY,\n        name: path,\n        offsetLines: 0,\n        text: \"\"};\n}\n\n/**\n * Build an object that can be used as a request to tern.\n *\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {string} query - the type of request being made\n * @param {{line: number, ch: number}} offset -\n */\nfunction buildRequest(fileInfo, query, offset) {\n    query = {type: query};\n    query.start = offset;\n    query.end = offset;\n    query.file = (fileInfo.type === MessageIds.TERN_FILE_INFO_TYPE_PART) ? \"#0\" : fileInfo.name;\n    query.filter = false;\n    query.sort = false;\n    query.depths = true;\n    query.guess = true;\n    query.origins = true;\n    query.types = true;\n    query.expandWordForward = false;\n    query.lineCharPositions = true;\n    query.docs = true;\n    query.urls = true;\n\n    let request = {query: query, files: [], offset: offset, timeout: inferenceTimeout};\n    if (fileInfo.type !== MessageIds.TERN_FILE_INFO_TYPE_EMPTY) {\n        // Create a copy to mutate ahead\n        let fileInfoCopy = JSON.parse(JSON.stringify(fileInfo));\n        request.files.push(fileInfoCopy);\n    }\n\n    return request;\n}\n\n\n/**\n * Get all References location\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset - the offset into the\n * file for cursor\n */\nfunction getRefs(fileInfo, offset) {\n    let request = buildRequest(fileInfo, \"refs\", offset);\n    try {\n        ternServer.request(request, function (error, data) {\n            if (error) {\n                console.error(\"Error returned from Tern 'refs' request: \" + error);\n                let response = {\n                    type: MessageIds.TERN_REFS,\n                    error: error.message\n                };\n                _postTernData(response);\n                return;\n            }\n            let response = {\n                type: MessageIds.TERN_REFS,\n                file: fileInfo.name,\n                offset: offset,\n                references: data\n            };\n            // Post a message back to the main thread with the results\n            _postTernData(response);\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    }\n}\n\n/**\n * Get scope at the offset in the file\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset - the offset into the\n * file for cursor\n */\nfunction getScopeData(fileInfo, offset) {\n    // Create a new tern Server\n    // Existing tern server resolves all the required modules which might take time\n    // We only need to analyze single file for getting the scope\n    ternOptions.plugins = {};\n    let ternServer = new Tern.Server(ternOptions);\n    ternServer.addFile(fileInfo.name, fileInfo.text);\n\n    let error;\n    let request = buildRequest(fileInfo, \"completions\", offset); // for primepump\n\n    try {\n        // primepump\n        ternServer.request(request, function (ternError, data) {\n            if (ternError) {\n                console.error(\"Error for Tern request: \\n\" + JSON.stringify(request) + \"\\n\" + ternError);\n                error = ternError.toString();\n            } else {\n                let file = ternServer.findFile(fileInfo.name);\n                let scope = Tern.scopeAt(file.ast, Tern.resolvePos(file, offset), file.scope);\n\n                if (scope) {\n                    // Remove unwanted properties to remove cycles in the object\n                    scope = JSON.parse(JSON.stringify(scope, function(key, value) {\n                        if ([\"proto\", \"propertyOf\", \"onNewProp\", \"sourceFile\", \"maybeProps\"].includes(key)) {\n                            return undefined;\n                        }                        else if (key === \"fnType\") {\n                            return value.name || \"FunctionExpression\";\n                        }                        else if (key === \"props\") {\n                            for (let key in value) {\n                                value[key] = value[key].propertyName;\n                            }\n                            return value;\n                        } else if (key === \"originNode\") {\n                            return value && {\n                                start: value.start,\n                                end: value.end,\n                                type: value.type,\n                                body: {\n                                    start: value.body.start,\n                                    end: value.body.end\n                                }\n                            };\n                        }\n\n                        return value;\n                    }));\n                }\n\n                _postTernData({\n                    type: MessageIds.TERN_SCOPEDATA_MSG,\n                    file: _getNormalizedFilename(fileInfo.name),\n                    offset: offset,\n                    scope: scope\n                });\n            }\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    } finally {\n        ternServer.reset();\n        Tern.resetGuessing();\n    }\n}\n\n\n/**\n * Get definition location\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset - the offset into the\n * file for cursor\n */\nfunction getJumptoDef(fileInfo, offset) {\n    let request = buildRequest(fileInfo, \"definition\", offset);\n    // request.query.typeOnly = true;       // FIXME: tern doesn't work exactly right yet.\n\n    try {\n        ternServer.request(request, function (error, data) {\n            if (error) {\n                console.error(\"Error returned from Tern 'definition' request: \" + error);\n                _postTernData({type: MessageIds.TERN_JUMPTODEF_MSG, file: fileInfo.name, offset: offset});\n                return;\n            }\n            let response = {\n                type: MessageIds.TERN_JUMPTODEF_MSG,\n                file: _getNormalizedFilename(fileInfo.name),\n                resultFile: data.file,\n                offset: offset,\n                start: data.start,\n                end: data.end\n            };\n\n            request = buildRequest(fileInfo, \"type\", offset);\n            // See if we can tell if the reference is to a Function type\n            ternServer.request(request, function (error, data) {\n                if (!error) {\n                    response.isFunction = data.type.length > 2 && data.type.substring(0, 2) === \"fn\";\n                }\n\n                // Post a message back to the main thread with the definition\n                _postTernData(response);\n            });\n\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    }\n}\n\n/**\n * Get all the known properties for guessing.\n *\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset -\n * the offset into the file where we want completions for\n * @param {string} type     - the type of the message to reply with.\n */\nfunction getTernProperties(fileInfo, offset, type) {\n\n    let request = buildRequest(fileInfo, \"properties\", offset),\n        i;\n    //console.error(\"tern properties: request \" + request.type + dir + \" \" + file);\n    try {\n        ternServer.request(request, function (error, data) {\n            let properties = [];\n            if (error) {\n                console.error(\"Error returned from Tern 'properties' request: \" + error);\n            } else {\n                //console.error(\"tern properties: completions = \" + data.completions.length);\n                properties = data.completions.map(function (completion) {\n                    return {value: completion, type: completion.type, guess: true};\n                });\n            }\n            // Post a message back to the main thread with the completions\n            _postTernData({type: type,\n                file: _getNormalizedFilename(fileInfo.name),\n                offset: offset,\n                properties: properties\n            });\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    }\n}\n\n/**\n * Get the completions for the given offset\n *\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset -\n * the offset into the file where we want completions for\n * @param {boolean} isProperty - true if getting a property hint,\n * otherwise getting an identifier hint.\n */\nfunction getTernHints(fileInfo, offset, isProperty) {\n    let request = buildRequest(fileInfo, \"completions\", offset),\n        i;\n    //console.error(\"request \" + dir + \" \" + file + \" \" + offset /*+ \" \" + text */);\n    try {\n        ternServer.request(request, function (error, data) {\n            let completions = [];\n            if (error) {\n                console.error(\"Error returned from Tern 'completions' request: \" + error);\n            } else {\n                //console.error(\"found \" + data.completions + \" for \" + file + \"@\" + offset);\n                completions = data.completions.map(function (completion) {\n                    return {value: completion.name, type: completion.type, depth: completion.depth,\n                        guess: completion.guess, origin: completion.origin, doc: completion.doc, url: completion.url};\n                });\n            }\n\n            if (completions.length > 0 || !isProperty) {\n                // Post a message back to the main thread with the completions\n                _postTernData({type: MessageIds.TERN_COMPLETIONS_MSG,\n                    file: _getNormalizedFilename(fileInfo.name),\n                    offset: offset,\n                    completions: completions\n                });\n            } else {\n                // if there are no completions, then get all the properties\n                getTernProperties(fileInfo, offset, MessageIds.TERN_COMPLETIONS_MSG);\n            }\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    }\n}\n\n/**\n *  Given a Tern type object, convert it to an array of Objects, where each object describes\n *  a parameter.\n *\n * @param {!Tern.Fn} inferFnType - type to convert.\n * @return {Array<{name: string, type: string, isOptional: boolean}>} where each entry in the array is a parameter.\n */\nfunction getParameters(inferFnType) {\n\n    // work around define functions before use warning.\n    let recordTypeToString, inferTypeToString, processInferFnTypeParameters, inferFnTypeToString;\n\n    /**\n     *  Convert an infer array type to a string.\n     *\n     *  Formatted using google closure style. For example:\n     *\n     *  \"Array.<string, number>\"\n     *\n     * @param {Tern.Arr} inferArrType\n     *\n     * @return {string} - array formatted in google closure style.\n     *\n     */\n    function inferArrTypeToString(inferArrType) {\n        let result = \"Array.<\";\n\n        result += inferArrType.props[\"<i>\"].types.map(inferTypeToString).join(\", \");\n\n        // workaround case where types is zero length\n        if (inferArrType.props[\"<i>\"].types.length === 0) {\n            result += \"Object\";\n        }\n        result += \">\";\n\n        return result;\n    }\n\n    /**\n     * Convert properties to a record type annotation.\n     *\n     * @param {Object} props\n     * @return {string} - record type annotation\n     */\n    recordTypeToString = function (props) {\n        let result = \"{\",\n            first = true,\n            prop;\n\n        result += Object.keys(props).map(function (key) {\n            return key + \": \" + inferTypeToString(props[key]);\n        }).join(\", \");\n\n        result += \"}\";\n\n        return result;\n    };\n\n    /**\n     *  Convert an infer type to a string.\n     *\n     * @param {*} inferType - one of the Infer's types; Tern.Prim, Tern.Arr, Tern.ANull. Tern.Fn functions are\n     * not handled here.\n     *\n     * @return {string}\n     *\n     */\n    inferTypeToString = function (inferType) {\n        let result;\n\n        if (inferType instanceof Tern.AVal) {\n            inferType = inferType.types[0];\n        }\n\n        if (inferType instanceof Tern.Prim) {\n            result = inferType.toString();\n            if (result === \"string\") {\n                result = \"String\";\n            } else if (result === \"number\") {\n                result = \"Number\";\n            } else if (result === \"boolean\") {\n                result = \"Boolean\";\n            }\n        } else if (inferType instanceof Tern.Arr) {\n            result = inferArrTypeToString(inferType);\n        } else if (inferType instanceof Tern.Fn) {\n            result = inferFnTypeToString(inferType);\n        } else if (inferType instanceof Tern.Obj) {\n            if (inferType.name === undefined) {\n                result = recordTypeToString(inferType.props);\n            } else {\n                result = inferType.name;\n            }\n        } else {\n            result = \"Object\";\n        }\n\n        return result;\n    };\n\n    /**\n     * Format the given parameter array. Handles separators between\n     * parameters, syntax for optional parameters, and the order of the\n     * parameter type and parameter name.\n     *\n     * @param {!Array.<{name: string, type: string, isOptional: boolean}>} params -\n     * array of parameter descriptors\n     * @param {function(string)=} appendSeparators - callback function to append separators.\n     * The separator is passed to the callback.\n     * @param {function(string, number)=} appendParameter - callback function to append parameter.\n     * The formatted parameter type and name is passed to the callback along with the\n     * current index of the parameter.\n     * @param {boolean=} typesOnly - only show parameter types. The\n     * default behavior is to include both parameter names and types.\n     * @return {string} - formatted parameter hint\n     */\n    function formatParameterHint(params, appendSeparators, appendParameter, typesOnly) {\n        let result = \"\",\n            pendingOptional = false;\n\n        params.forEach(function (value, i) {\n            let param = value.type,\n                separators = \"\";\n\n            if (value.isOptional) {\n                // if an optional param is following by an optional parameter, then\n                // terminate the bracket. Otherwise enclose a required parameter\n                // in the same bracket.\n                if (pendingOptional) {\n                    separators += \"]\";\n                }\n\n                pendingOptional = true;\n            }\n\n            if (i > 0) {\n                separators += \", \";\n            }\n\n            if (value.isOptional) {\n                separators += \"[\";\n            }\n\n            if (appendSeparators) {\n                appendSeparators(separators);\n            }\n\n            result += separators;\n\n            if (!typesOnly) {\n                param += \" \" + value.name;\n            }\n\n            if (appendParameter) {\n                appendParameter(param, i);\n            }\n\n            result += param;\n\n        });\n\n        if (pendingOptional) {\n            if (appendSeparators) {\n                appendSeparators(\"]\");\n            }\n\n            result += \"]\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert an infer function type to a Google closure type string.\n     *\n     * @param {Tern.Fn} inferType - type to convert.\n     * @return {string} - function type as a string.\n     */\n    inferFnTypeToString = function (inferType) {\n        let result = \"function(\",\n            params = processInferFnTypeParameters(inferType);\n\n        result += /*HintUtils2.*/formatParameterHint(params, null, null, true);\n        if (inferType.retval) {\n            result += \"):\";\n            result += inferTypeToString(inferType.retval);\n        }\n\n        return result;\n    };\n\n    /**\n     * Convert an infer function type to string.\n     *\n     * @param {*} inferType - one of the Infer's types; Tern.Fn, Tern.Prim, Tern.Arr, Tern.ANull\n     * @return {Array<{name: string, type: string, isOptional: boolean}>} where each entry in the array is a parameter.\n     */\n    processInferFnTypeParameters = function (inferType) {\n        let params = [],\n            i;\n\n        for (i = 0; i < inferType.args.length; i++) {\n            let param = {},\n                name = inferType.argNames[i],\n                type = inferType.args[i];\n\n            if (!name) {\n                name = \"param\" + (i + 1);\n            }\n\n            if (name[name.length - 1] === \"?\") {\n                name = name.substring(0, name.length - 1);\n                param.isOptional = true;\n            }\n\n            param.name = name;\n            param.type = inferTypeToString(type);\n            params.push(param);\n        }\n\n        return params;\n    };\n\n    return processInferFnTypeParameters(inferFnType);\n}\n\n/**\n * Get the function type for the given offset\n *\n * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n * - type of update, name of file, and the text of the update.\n * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n * the changed portion of the text. For \"empty\" updates, the file has not been modified\n * and the text is empty.\n * @param {{line: number, ch: number}} offset -\n * the offset into the file where we want completions for\n */\nfunction handleFunctionType(fileInfo, offset) {\n    let request = buildRequest(fileInfo, \"type\", offset),\n        error;\n\n    request.query.preferFunction = true;\n\n    let fnType = \"\";\n    try {\n        ternServer.request(request, function (ternError, data) {\n\n            if (ternError) {\n                console.error(\"Error for Tern request: \\n\" + JSON.stringify(request) + \"\\n\" + ternError);\n                error = ternError.toString();\n            } else {\n                let file = ternServer.findFile(fileInfo.name);\n\n                // convert query from partial to full offsets\n                let newOffset = offset;\n                if (fileInfo.type === MessageIds.TERN_FILE_INFO_TYPE_PART) {\n                    newOffset = {line: offset.line + fileInfo.offsetLines, ch: offset.ch};\n                }\n\n                request = buildRequest(createEmptyUpdate(fileInfo.name), \"type\", newOffset);\n\n                let expr = Tern.findQueryExpr(file, request.query);\n                Tern.resetGuessing();\n                let type = Tern.expressionType(expr);\n                type = type.getFunctionType() || type.getType();\n\n                if (type) {\n                    fnType = getParameters(type);\n                } else {\n                    ternError = \"No parameter type found\";\n                    console.error(ternError);\n                }\n            }\n        });\n    } catch (e) {\n        _reportError(e, fileInfo.name);\n    }\n\n    // Post a message back to the main thread with the completions\n    _postTernData({type: MessageIds.TERN_CALLED_FUNC_TYPE_MSG,\n        file: _getNormalizedFilename(fileInfo.name),\n        offset: offset,\n        fnType: fnType,\n        error: error\n    });\n}\n\n/**\n *  Add an array of files to tern.\n *\n * @param {Array.<string>} files - each string in the array is the full\n * path of a file.\n */\nfunction handleAddFiles(files) {\n    files.forEach(function (file) {\n        ternServer.addFile(file);\n    });\n}\n\n/**\n *  Update the context of a file in tern.\n *\n * @param {string} path - full path of file.\n * @param {string} text - content of the file.\n */\nfunction handleUpdateFile(path, text) {\n\n    ternServer.addFile(path, text);\n\n    _postTernData({type: MessageIds.TERN_UPDATE_FILE_MSG,\n        path: path\n    });\n\n    // reset to get the best hints with the updated file.\n    ternServer.reset();\n    Tern.resetGuessing();\n}\n\n/**\n *  Make a completions request to tern to force tern to resolve files\n *  and create a fast first lookup for the user.\n * @param {string} path     - the path of the file\n */\nfunction handlePrimePump(path) {\n    let fileName = _getDenormalizedFilename(path);\n    let fileInfo = createEmptyUpdate(fileName),\n        request = buildRequest(fileInfo, \"completions\", {line: 0, ch: 0});\n\n    try {\n        ternServer.request(request, function (error, data) {\n            // Post a message back to the main thread\n            _postTernData({type: MessageIds.TERN_PRIME_PUMP_MSG,\n                path: _getNormalizedFilename(path)\n            });\n        });\n    } catch (e) {\n        _reportError(e, path);\n    }\n}\n\n/**\n * Updates the configuration, typically for debugging purposes.\n *\n * @param {Object} configUpdate new configuration\n */\nfunction setConfig(configUpdate) {\n    config = configUpdate;\n}\n\nfunction _requestTernServer(commandConfig) {\n    let file, text, offset,\n        request = commandConfig,\n        type = request.type;\n    if (config.debug) {\n        console.error(\"Message received \" + type);\n    }\n\n    if (type === MessageIds.TERN_INIT_MSG) {\n        let env     = request.env,\n            files   = request.files;\n        inferenceTimeout = request.timeout;\n        initTernServer(env, files);\n    } else if (type === MessageIds.TERN_COMPLETIONS_MSG) {\n        offset  = request.offset;\n        getTernHints(request.fileInfo, offset, request.isProperty);\n    } else if (type === MessageIds.TERN_GET_FILE_MSG) {\n        file = request.file;\n        text = request.text;\n        handleGetFile(file, text);\n    } else if (type === MessageIds.TERN_CALLED_FUNC_TYPE_MSG) {\n        offset  = request.offset;\n        handleFunctionType(request.fileInfo, offset);\n    } else if (type === MessageIds.TERN_JUMPTODEF_MSG) {\n        offset  = request.offset;\n        getJumptoDef(request.fileInfo, offset);\n    } else if (type === MessageIds.TERN_SCOPEDATA_MSG) {\n        offset  = request.offset;\n        getScopeData(request.fileInfo, offset);\n    } else if (type === MessageIds.TERN_REFS) {\n        offset  = request.offset;\n        getRefs(request.fileInfo, offset);\n    } else if (type === MessageIds.TERN_ADD_FILES_MSG) {\n        handleAddFiles(request.files);\n    } else if (type === MessageIds.TERN_PRIME_PUMP_MSG) {\n        isUntitledDoc = request.isUntitledDoc;\n        handlePrimePump(request.path);\n    } else if (type === MessageIds.TERN_GET_GUESSES_MSG) {\n        offset  = request.offset;\n        getTernProperties(request.fileInfo, offset, MessageIds.TERN_GET_GUESSES_MSG);\n    } else if (type === MessageIds.TERN_UPDATE_FILE_MSG) {\n        handleUpdateFile(request.path, request.text);\n    } else if (type === MessageIds.SET_CONFIG) {\n        setConfig(request.config);\n    } else if (type === MessageIds.TERN_UPDATE_DIRTY_FILE) {\n        updateDirtyFilesCache(request.name, request.action);\n    } else if (type === MessageIds.TERN_CLEAR_DIRTY_FILES_LIST) {\n        clearDirtyFilesCache();\n    } else {\n        console.error(\"Unknown message: \" + JSON.stringify(request));\n    }\n}\n\nfunction invokeTernCommand(commandConfig) {\n    try {\n        _requestTernServer(commandConfig);\n    } catch (error) {\n        console.warn(error);\n    }\n}\n\nWorkerComm.setExecHandler(\"invokeTernCommand\", invokeTernCommand);\nWorkerComm.setExecHandler(\"resetTernServer\", resetTernServer);\n"],"file":"tern-main.js"}
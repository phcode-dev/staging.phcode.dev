{"version":3,"sources":["JSUtils/worker/tern-main.js"],"names":["importScripts","Phoenix","baseURL","Tern","tern","detailedDebugLogs","debugLog","args","console","log","splice","_postTernData","data","WorkerComm","triggerPeer","MessageIds","ternOptions","config","fetch","then","async","contents","json","catch","e","error","ternServer","isUntitledDoc","inferenceTimeout","fileCallBacks","_dirtyFilesCache","clearDirtyFilesCache","updateDirtyFilesCache","name","action","_reportError","file","TimedOut","type","TERN_INFERENCE_TIMEDOUT","message","stack","handleGetFile","text","contentCallback","_getNormalizedFilename","fileName","projectDir","indexOf","_getDenormalizedFilename","slice","length","_requestFileContent","TERN_GET_FILE_MSG","getFile","contentCb","initTernServer","env","files","defs","plugins","commonjs","requirejs","angular","complete_strings","doc_comment","doc_comments","es_modules","node","node_resolve","reset","resetGuessing","Server","forEach","addFile","resetTernServer","TERN_WORKER_READY","createEmptyUpdate","path","TERN_FILE_INFO_TYPE_EMPTY","offsetLines","buildRequest","fileInfo","query","offset","start","end","TERN_FILE_INFO_TYPE_PART","filter","sort","depths","guess","origins","types","expandWordForward","lineCharPositions","docs","urls","request","timeout","fileInfoCopy","JSON","parse","stringify","push","getRefs","response","TERN_REFS","references","getScopeData","ternError","toString","findFile","scope","scopeAt","ast","resolvePos","key","value","includes","propertyName","body","TERN_SCOPEDATA_MSG","getJumptoDef","TERN_JUMPTODEF_MSG","resultFile","getTernProperties","i","properties","completions","map","completion","getTernHints","isProperty","depth","origin","doc","url","TERN_COMPLETIONS_MSG","getParameters","inferFnType","recordTypeToString","inferTypeToString","processInferFnTypeParameters","inferFnTypeToString","inferArrTypeToString","inferArrType","result","props","join","formatParameterHint","params","appendSeparators","appendParameter","typesOnly","pendingOptional","param","separators","isOptional","first","prop","Object","keys","inferType","AVal","Prim","Arr","Fn","Obj","undefined","retval","argNames","substring","handleFunctionType","preferFunction","fnType","newOffset","line","ch","expr","findQueryExpr","expressionType","getFunctionType","getType","TERN_CALLED_FUNC_TYPE_MSG","handleAddFiles","handleUpdateFile","TERN_UPDATE_FILE_MSG","handlePrimePump","TERN_PRIME_PUMP_MSG","setConfig","configUpdate","_requestTernServer","commandConfig","TERN_INIT_MSG","TERN_ADD_FILES_MSG","TERN_GET_GUESSES_MSG","SET_CONFIG","TERN_UPDATE_DIRTY_FILE","TERN_CLEAR_DIRTY_FILES_LIST","invokeTernCommand","warn","setExecHandler"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2017 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*eslint-env worker */\n/*global Phoenix, WorkerComm, tern*/\n\n// import acorn lib\nimportScripts(`${Phoenix.baseURL}thirdparty/acorn/dist/acorn.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/acorn/dist/acorn_loose.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/acorn/dist/walk.js`);\n// import tern lib\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/lib/signal.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/lib/tern.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/lib/comment.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/lib/def.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/lib/infer.js`);\nconst Tern = tern;\n// import tern plugins\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/modules.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/requirejs.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/es_modules.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/doc_comment.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/node.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/node_resolve.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/complete_strings.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/commonjs.js`);\nimportScripts(`${Phoenix.baseURL}thirdparty/tern/plugin/angular.js`);\n\nimportScripts(`${Phoenix.baseURL}JSUtils/worker/testTern.js`);\n\n(function () {\n    const detailedDebugLogs = false; // set this to false before checkin\n\n    function debugLog(...args) {\n        if(!detailedDebugLogs) {\n            return;\n        }\n        console.log(\"tern: \" + args[0], ...args.splice(1));\n    }\n\n    function _postTernData(data) {\n        WorkerComm.triggerPeer(\"tern-data\", data);\n    }\n\n    let MessageIds,\n        ternOptions,\n        config = {};\n\n    fetch(`${Phoenix.baseURL}JSUtils/MessageIds.json`)\n        .then(async contents =>{\n            MessageIds = await contents.json();\n        })\n        .catch(e =>{\n            console.error(\"failed to init MessageIds \", e);\n        });\n\n    let ternServer  = null,\n        isUntitledDoc = false,\n        inferenceTimeout;\n\n// Save the tern callbacks for when we get the contents of the file\n    let fileCallBacks = {};\n\n    let _dirtyFilesCache = {};\n\n    /**\n     * Clears the cache for dirty file paths\n     */\n    function clearDirtyFilesCache() {\n        _dirtyFilesCache = {};\n    }\n\n    /**\n     * Updates the files cache with fullpath when dirty flag changes for a document\n     * If the doc is being marked as dirty then an entry is created in the cache\n     * If the doc is being marked as clean then the corresponsing entry gets cleared from cache\n     *\n     * @param {String} name - fullpath of the document\n     * @param {boolean} action - whether the document is dirty\n     */\n    function updateDirtyFilesCache(name, action) {\n        if (action) {\n            _dirtyFilesCache[name] = true;\n        } else {\n            if (_dirtyFilesCache[name]) {\n                delete _dirtyFilesCache[name];\n            }\n        }\n    }\n\n    /**\n     * Report exception\n     * @private\n     * @param {Error} e - the error object\n     */\n    function _reportError(e, file) {\n        if (e instanceof Tern.TimedOut) {\n            // Post a message back to the main thread with timedout info\n            _postTernData({\n                type: MessageIds.TERN_INFERENCE_TIMEDOUT,\n                file: file\n            });\n        } else {\n            console.error(\"Error thrown in tern worker:\" + e.message + \" : file: \" + file , e.stack);\n        }\n    }\n\n    /**\n     * Handle a response from the main thread providing the contents of a file\n     * @param {string} file - the name of the file\n     * @param {string} text - the contents of the file\n     */\n    function handleGetFile(file, text) {\n        debugLog(`tern Got file ${file}`, text);\n        let contentCallback = fileCallBacks[file];\n        if (contentCallback) {\n            try {\n                contentCallback(null, text);\n            } catch (e) {\n                _reportError(e, file);\n            }\n        }\n        delete fileCallBacks[file];\n    }\n\n    function _getNormalizedFilename(fileName) {\n        if (!isUntitledDoc && ternServer.projectDir && fileName.indexOf(ternServer.projectDir) === -1) {\n            fileName = ternServer.projectDir + fileName;\n        }\n        return fileName;\n    }\n\n    function _getDenormalizedFilename(fileName) {\n        if (!isUntitledDoc && ternServer.projectDir && fileName.indexOf(ternServer.projectDir) === 0) {\n            fileName = fileName.slice(ternServer.projectDir.length);\n        }\n        return fileName;\n    }\n\n    /**\n     * Callback handle to request contents of a file from the main thread\n     * @param {string} file - the name of the file\n     */\n    function _requestFileContent(name) {\n        debugLog(\"_requestFileContent: \", name);\n        _postTernData({\n            type: MessageIds.TERN_GET_FILE_MSG,\n            file: name\n        });\n    }\n\n    /**\n     * Provide the contents of the requested file to tern\n     * @param {string} name - the name of the file\n     * @param {Function} contentCb - the function to call with the text of the file\n     *  once it has been read in.\n     */\n    function getFile(name, contentCb) {\n        // save the callback\n        fileCallBacks[name] = contentCb;\n\n        try {\n            _requestFileContent(name);\n        } catch (error) {\n            console.log(error);\n        }\n    }\n\n    /**\n     * Create a new tern server.\n     *\n     * @param {Object} env - an Object with the environment, as read in from\n     *  the json files in thirdparty/tern/defs\n     * @param {Array.<string>} files - a list of filenames tern should be aware of\n     */\n    function initTernServer(env, files) {\n        console.log(\"init tern server with files: \", files);\n        ternOptions = {\n            defs: env,\n            async: true,\n            getFile: getFile,\n            plugins: {\n                commonjs: true,\n                requirejs: {},\n                angular: true,\n                complete_strings: true,\n                doc_comment: true,\n                doc_comments: true,\n                es_modules: true,\n                node: true,\n                node_resolve: true\n            }\n        };\n\n        // If a server is already created just reset the analysis data before marking it for GC\n        if (ternServer) {\n            ternServer.reset();\n            Tern.resetGuessing();\n        }\n\n        ternServer = new Tern.Server(ternOptions);\n\n        files.forEach(function (file) {\n            ternServer.addFile(file);\n        });\n\n    }\n\n    /**\n     * Resets an existing tern server.\n     */\n    function resetTernServer() {\n        // If a server is already created just reset the analysis data\n        if (ternServer) {\n            ternServer.reset();\n            Tern.resetGuessing();\n            // tell the main thread we're ready to start processing again\n            _postTernData({type: MessageIds.TERN_WORKER_READY});\n        }\n    }\n\n    /**\n     * Create a \"empty\" update object.\n     *\n     * @param {string} path - full path of the file.\n     * @return {{type: string, name: string, offsetLines: number, text: string}} -\n     * \"empty\" update.\n\n     */\n    function createEmptyUpdate(path) {\n        return {type: MessageIds.TERN_FILE_INFO_TYPE_EMPTY,\n            name: path,\n            offsetLines: 0,\n            text: \"\"};\n    }\n\n    /**\n     * Build an object that can be used as a request to tern.\n     *\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {string} query - the type of request being made\n     * @param {{line: number, ch: number}} offset -\n     */\n    function buildRequest(fileInfo, query, offset) {\n        query = {type: query};\n        query.start = offset;\n        query.end = offset;\n        query.file = (fileInfo.type === MessageIds.TERN_FILE_INFO_TYPE_PART) ? \"#0\" : fileInfo.name;\n        query.filter = false;\n        query.sort = false;\n        query.depths = true;\n        query.guess = true;\n        query.origins = true;\n        query.types = true;\n        query.expandWordForward = false;\n        query.lineCharPositions = true;\n        query.docs = true;\n        query.urls = true;\n\n        let request = {query: query, files: [], offset: offset, timeout: inferenceTimeout};\n        if (fileInfo.type !== MessageIds.TERN_FILE_INFO_TYPE_EMPTY) {\n            // Create a copy to mutate ahead\n            let fileInfoCopy = JSON.parse(JSON.stringify(fileInfo));\n            request.files.push(fileInfoCopy);\n        }\n\n        return request;\n    }\n\n\n    /**\n     * Get all References location\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset - the offset into the\n     * file for cursor\n     */\n    function getRefs(fileInfo, offset) {\n        let request = buildRequest(fileInfo, \"refs\", offset);\n        try {\n            ternServer.request(request, function (error, data) {\n                if (error) {\n                    console.error(\"Error returned from Tern 'refs' request: \" + error);\n                    let response = {\n                        type: MessageIds.TERN_REFS,\n                        error: error.message\n                    };\n                    _postTernData(response);\n                    return;\n                }\n                let response = {\n                    type: MessageIds.TERN_REFS,\n                    file: fileInfo.name,\n                    offset: offset,\n                    references: data\n                };\n                // Post a message back to the main thread with the results\n                _postTernData(response);\n            });\n        } catch (e) {\n            _reportError(e, fileInfo.name);\n        }\n    }\n\n    /**\n     * Get scope at the offset in the file\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset - the offset into the\n     * file for cursor\n     */\n    function getScopeData(fileInfo, offset) {\n        // Create a new tern Server\n        // Existing tern server resolves all the required modules which might take time\n        // We only need to analyze single file for getting the scope\n        ternOptions.plugins = {};\n        let ternServer = new Tern.Server(ternOptions);\n        ternServer.addFile(fileInfo.name, fileInfo.text);\n\n        let error;\n        let request = buildRequest(fileInfo, \"completions\", offset); // for primepump\n\n        try {\n            // primepump\n            ternServer.request(request, function (ternError, data) {\n                if (ternError) {\n                    console.error(\"Error for Tern request: \\n\" + JSON.stringify(request) + \"\\n\" + ternError);\n                    error = ternError.toString();\n                } else {\n                    let file = ternServer.findFile(fileInfo.name);\n                    let scope = Tern.scopeAt(file.ast, Tern.resolvePos(file, offset), file.scope);\n\n                    if (scope) {\n                        // Remove unwanted properties to remove cycles in the object\n                        scope = JSON.parse(JSON.stringify(scope, function(key, value) {\n                            if ([\"proto\", \"propertyOf\", \"onNewProp\", \"sourceFile\", \"maybeProps\"].includes(key)) {\n                                return undefined;\n                            }                        else if (key === \"fnType\") {\n                                return value.name || \"FunctionExpression\";\n                            }                        else if (key === \"props\") {\n                                for (let key in value) {\n                                    value[key] = value[key].propertyName;\n                                }\n                                return value;\n                            } else if (key === \"originNode\") {\n                                return value && {\n                                    start: value.start,\n                                    end: value.end,\n                                    type: value.type,\n                                    body: {\n                                        start: value.body.start,\n                                        end: value.body.end\n                                    }\n                                };\n                            }\n\n                            return value;\n                        }));\n                    }\n\n                    _postTernData({\n                        type: MessageIds.TERN_SCOPEDATA_MSG,\n                        file: _getNormalizedFilename(fileInfo.name),\n                        offset: offset,\n                        scope: scope\n                    });\n                }\n            });\n        } catch (e) {\n            _reportError(e, fileInfo.name);\n        } finally {\n            ternServer.reset();\n            Tern.resetGuessing();\n        }\n    }\n\n\n    /**\n     * Get definition location\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset - the offset into the\n     * file for cursor\n     */\n    function getJumptoDef(fileInfo, offset) {\n        let request = buildRequest(fileInfo, \"definition\", offset);\n        // request.query.typeOnly = true;       // FIXME: tern doesn't work exactly right yet.\n\n        try {\n            ternServer.request(request, function (error, data) {\n                if (error) {\n                    console.error(\"Error returned from Tern 'definition' request: \" + error);\n                    _postTernData({type: MessageIds.TERN_JUMPTODEF_MSG, file: fileInfo.name, offset: offset});\n                    return;\n                }\n                let response = {\n                    type: MessageIds.TERN_JUMPTODEF_MSG,\n                    file: _getNormalizedFilename(fileInfo.name),\n                    resultFile: data.file,\n                    offset: offset,\n                    start: data.start,\n                    end: data.end\n                };\n\n                request = buildRequest(fileInfo, \"definition\", offset);\n\n                ternServer.request(request, function (error, data) {\n                    // Post a message back to the main thread with the definition\n                    _postTernData(response);\n                });\n\n            });\n        } catch (e) {\n            _reportError(e, fileInfo.name);\n        }\n    }\n\n    /**\n     * Get all the known properties for guessing.\n     *\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset -\n     * the offset into the file where we want completions for\n     * @param {string} type     - the type of the message to reply with.\n     */\n    function getTernProperties(fileInfo, offset, type) {\n\n        let request = buildRequest(fileInfo, \"properties\", offset),\n            i;\n        //console.error(\"tern properties: request \" + request.type + dir + \" \" + file);\n        try {\n            ternServer.request(request, function (error, data) {\n                let properties = [];\n                if (error) {\n                    console.error(\"Error returned from Tern 'properties' request: \" + error);\n                } else {\n                    //console.error(\"tern properties: completions = \" + data.completions.length);\n                    properties = data.completions.map(function (completion) {\n                        return {value: completion, type: completion.type, guess: true};\n                    });\n                }\n                // Post a message back to the main thread with the completions\n                _postTernData({type: type,\n                    file: _getNormalizedFilename(fileInfo.name),\n                    offset: offset,\n                    properties: properties\n                });\n            });\n        } catch (e) {\n            _reportError(e, fileInfo.name);\n        }\n    }\n\n    /**\n     * Get the completions for the given offset\n     *\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset -\n     * the offset into the file where we want completions for\n     * @param {boolean} isProperty - true if getting a property hint,\n     * otherwise getting an identifier hint.\n     */\n    function getTernHints(fileInfo, offset, isProperty) {\n        let request = buildRequest(fileInfo, \"completions\", offset),\n            i;\n        //console.error(\"request \" + dir + \" \" + file + \" \" + offset /*+ \" \" + text */);\n        try {\n            ternServer.request(request, function (error, data) {\n                let completions = [];\n                if (error) {\n                    console.error(\"Error returned from Tern 'completions' request: \" + error);\n                } else {\n                    //console.error(\"found \" + data.completions + \" for \" + file + \"@\" + offset);\n                    completions = data.completions.map(function (completion) {\n                        return {value: completion.name, type: completion.type, depth: completion.depth,\n                            guess: completion.guess, origin: completion.origin, doc: completion.doc, url: completion.url};\n                    });\n                }\n\n                if (completions.length > 0 || !isProperty) {\n                    // Post a message back to the main thread with the completions\n                    _postTernData({type: MessageIds.TERN_COMPLETIONS_MSG,\n                        file: _getNormalizedFilename(fileInfo.name),\n                        offset: offset,\n                        completions: completions\n                    });\n                } else {\n                    // if there are no completions, then get all the properties\n                    getTernProperties(fileInfo, offset, MessageIds.TERN_COMPLETIONS_MSG);\n                }\n            });\n        } catch (e) {\n            _reportError(e, fileInfo.name);\n        }\n    }\n\n    /**\n     *  Given a Tern type object, convert it to an array of Objects, where each object describes\n     *  a parameter.\n     *\n     * @param {!Tern.Fn} inferFnType - type to convert.\n     * @return {Array<{name: string, type: string, isOptional: boolean}>} where each entry in the array is a parameter.\n     */\n    function getParameters(inferFnType) {\n\n        // work around define functions before use warning.\n        let recordTypeToString, inferTypeToString, processInferFnTypeParameters, inferFnTypeToString;\n\n        /**\n         *  Convert an infer array type to a string.\n         *\n         *  Formatted using google closure style. For example:\n         *\n         *  \"Array.<string, number>\"\n         *\n         * @param {Tern.Arr} inferArrType\n         *\n         * @return {string} - array formatted in google closure style.\n         *\n         */\n        function inferArrTypeToString(inferArrType) {\n            let result = \"Array.<\";\n\n            result += inferArrType.props[\"<i>\"].types.map(inferTypeToString).join(\", \");\n\n            // workaround case where types is zero length\n            if (inferArrType.props[\"<i>\"].types.length === 0) {\n                result += \"Object\";\n            }\n            result += \">\";\n\n            return result;\n        }\n\n        /**\n         * Convert properties to a record type annotation.\n         *\n         * @param {Object} props\n         * @return {string} - record type annotation\n         */\n        recordTypeToString = function (props) {\n            let result = \"{\",\n                first = true,\n                prop;\n\n            result += Object.keys(props).map(function (key) {\n                return key + \": \" + inferTypeToString(props[key]);\n            }).join(\", \");\n\n            result += \"}\";\n\n            return result;\n        };\n\n        /**\n         *  Convert an infer type to a string.\n         *\n         * @param {*} inferType - one of the Infer's types; Tern.Prim, Tern.Arr, Tern.ANull. Tern.Fn functions are\n         * not handled here.\n         *\n         * @return {string}\n         *\n         */\n        inferTypeToString = function (inferType) {\n            let result;\n\n            if (inferType instanceof Tern.AVal) {\n                inferType = inferType.types[0];\n            }\n\n            if (inferType instanceof Tern.Prim) {\n                result = inferType.toString();\n                if (result === \"string\") {\n                    result = \"String\";\n                } else if (result === \"number\") {\n                    result = \"Number\";\n                } else if (result === \"boolean\") {\n                    result = \"Boolean\";\n                }\n            } else if (inferType instanceof Tern.Arr) {\n                result = inferArrTypeToString(inferType);\n            } else if (inferType instanceof Tern.Fn) {\n                result = inferFnTypeToString(inferType);\n            } else if (inferType instanceof Tern.Obj) {\n                if (inferType.name === undefined) {\n                    result = recordTypeToString(inferType.props);\n                } else {\n                    result = inferType.name;\n                }\n            } else {\n                result = \"Object\";\n            }\n\n            return result;\n        };\n\n        /**\n         * Format the given parameter array. Handles separators between\n         * parameters, syntax for optional parameters, and the order of the\n         * parameter type and parameter name.\n         *\n         * @param {!Array.<{name: string, type: string, isOptional: boolean}>} params -\n         * array of parameter descriptors\n         * @param {function(string)=} appendSeparators - callback function to append separators.\n         * The separator is passed to the callback.\n         * @param {function(string, number)=} appendParameter - callback function to append parameter.\n         * The formatted parameter type and name is passed to the callback along with the\n         * current index of the parameter.\n         * @param {boolean=} typesOnly - only show parameter types. The\n         * default behavior is to include both parameter names and types.\n         * @return {string} - formatted parameter hint\n         */\n        function formatParameterHint(params, appendSeparators, appendParameter, typesOnly) {\n            let result = \"\",\n                pendingOptional = false;\n\n            params.forEach(function (value, i) {\n                let param = value.type,\n                    separators = \"\";\n\n                if (value.isOptional) {\n                    // if an optional param is following by an optional parameter, then\n                    // terminate the bracket. Otherwise enclose a required parameter\n                    // in the same bracket.\n                    if (pendingOptional) {\n                        separators += \"]\";\n                    }\n\n                    pendingOptional = true;\n                }\n\n                if (i > 0) {\n                    separators += \", \";\n                }\n\n                if (value.isOptional) {\n                    separators += \"[\";\n                }\n\n                if (appendSeparators) {\n                    appendSeparators(separators);\n                }\n\n                result += separators;\n\n                if (!typesOnly) {\n                    param += \" \" + value.name;\n                }\n\n                if (appendParameter) {\n                    appendParameter(param, i);\n                }\n\n                result += param;\n\n            });\n\n            if (pendingOptional) {\n                if (appendSeparators) {\n                    appendSeparators(\"]\");\n                }\n\n                result += \"]\";\n            }\n\n            return result;\n        }\n\n        /**\n         * Convert an infer function type to a Google closure type string.\n         *\n         * @param {Tern.Fn} inferType - type to convert.\n         * @return {string} - function type as a string.\n         */\n        inferFnTypeToString = function (inferType) {\n            let result = \"function(\",\n                params = processInferFnTypeParameters(inferType);\n\n            result += /*HintUtils2.*/formatParameterHint(params, null, null, true);\n            if (inferType.retval) {\n                result += \"):\";\n                result += inferTypeToString(inferType.retval);\n            }\n\n            return result;\n        };\n\n        /**\n         * Convert an infer function type to string.\n         *\n         * @param {*} inferType - one of the Infer's types; Tern.Fn, Tern.Prim, Tern.Arr, Tern.ANull\n         * @return {Array<{name: string, type: string, isOptional: boolean}>} where each entry in the array is a parameter.\n         */\n        processInferFnTypeParameters = function (inferType) {\n            let params = [],\n                i;\n\n            for (i = 0; i < inferType.args.length; i++) {\n                let param = {},\n                    name = inferType.argNames[i],\n                    type = inferType.args[i];\n\n                if (!name) {\n                    name = \"param\" + (i + 1);\n                }\n\n                if (name[name.length - 1] === \"?\") {\n                    name = name.substring(0, name.length - 1);\n                    param.isOptional = true;\n                }\n\n                param.name = name;\n                param.type = inferTypeToString(type);\n                params.push(param);\n            }\n\n            return params;\n        };\n\n        return processInferFnTypeParameters(inferFnType);\n    }\n\n    /**\n     * Get the function type for the given offset\n     *\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset -\n     * the offset into the file where we want completions for\n     */\n    function handleFunctionType(fileInfo, offset) {\n        let request = buildRequest(fileInfo, \"type\", offset),\n            error;\n\n        request.query.preferFunction = true;\n\n        let fnType = \"\";\n        try {\n            ternServer.request(request, function (ternError, data) {\n\n                if (ternError) {\n                    console.error(\"Error for Tern request: \\n\" + JSON.stringify(request) + \"\\n\" + ternError);\n                    error = ternError.toString();\n                } else {\n                    let file = ternServer.findFile(fileInfo.name);\n\n                    // convert query from partial to full offsets\n                    let newOffset = offset;\n                    if (fileInfo.type === MessageIds.TERN_FILE_INFO_TYPE_PART) {\n                        newOffset = {line: offset.line + fileInfo.offsetLines, ch: offset.ch};\n                    }\n\n                    request = buildRequest(createEmptyUpdate(fileInfo.name), \"type\", newOffset);\n\n                    let expr = Tern.findQueryExpr(file, request.query);\n                    Tern.resetGuessing();\n                    let type = Tern.expressionType(expr);\n                    type = type.getFunctionType() || type.getType();\n\n                    if (type) {\n                        fnType = getParameters(type);\n                    } else {\n                        ternError = \"No parameter type found\";\n                        console.error(ternError);\n                    }\n                }\n            });\n        } catch (e) {\n            _reportError(e, fileInfo.name);\n        }\n\n        // Post a message back to the main thread with the completions\n        _postTernData({type: MessageIds.TERN_CALLED_FUNC_TYPE_MSG,\n            file: _getNormalizedFilename(fileInfo.name),\n            offset: offset,\n            fnType: fnType,\n            error: error\n        });\n    }\n\n    /**\n     *  Add an array of files to tern.\n     *\n     * @param {Array.<string>} files - each string in the array is the full\n     * path of a file.\n     */\n    function handleAddFiles(files) {\n        debugLog(\"handleAddFiles: \", files);\n        files.forEach(function (file) {\n            ternServer.addFile(file);\n        });\n    }\n\n    /**\n     *  Update the context of a file in tern.\n     *\n     * @param {string} path - full path of file.\n     * @param {string} text - content of the file.\n     */\n    function handleUpdateFile(path, text) {\n        debugLog(`handleUpdateFile: ${path} `, text);\n        ternServer.addFile(path, text);\n\n        _postTernData({type: MessageIds.TERN_UPDATE_FILE_MSG,\n            path: path\n        });\n\n        // reset to get the best hints with the updated file.\n        ternServer.reset();\n        Tern.resetGuessing();\n    }\n\n    /**\n     *  Make a completions request to tern to force tern to resolve files\n     *  and create a fast first lookup for the user.\n     * @param {string} path     - the path of the file\n     */\n    function handlePrimePump(path) {\n        let fileName = _getDenormalizedFilename(path);\n        let fileInfo = createEmptyUpdate(fileName),\n            request = buildRequest(fileInfo, \"completions\", {line: 0, ch: 0});\n\n        try {\n            ternServer.request(request, function (error, data) {\n                // Post a message back to the main thread\n                _postTernData({type: MessageIds.TERN_PRIME_PUMP_MSG,\n                    path: _getNormalizedFilename(path)\n                });\n            });\n        } catch (e) {\n            _reportError(e, path);\n        }\n    }\n\n    /**\n     * Updates the configuration, typically for debugging purposes.\n     *\n     * @param {Object} configUpdate new configuration\n     */\n    function setConfig(configUpdate) {\n        config = configUpdate;\n    }\n\n    function _requestTernServer(commandConfig) {\n        let file, text, offset,\n            request = commandConfig,\n            type = request.type;\n\n        console.log(\"Tern worker received Message of type: \" + type);\n\n        if (type === MessageIds.TERN_INIT_MSG) {\n            let env     = request.env,\n                files   = request.files;\n            inferenceTimeout = request.timeout;\n            initTernServer(env, files);\n        } else if (type === MessageIds.TERN_COMPLETIONS_MSG) {\n            offset  = request.offset;\n            getTernHints(request.fileInfo, offset, request.isProperty);\n        } else if (type === MessageIds.TERN_GET_FILE_MSG) {\n            file = request.file;\n            text = request.text;\n            handleGetFile(file, text);\n        } else if (type === MessageIds.TERN_CALLED_FUNC_TYPE_MSG) {\n            offset  = request.offset;\n            handleFunctionType(request.fileInfo, offset);\n        } else if (type === MessageIds.TERN_JUMPTODEF_MSG) {\n            offset  = request.offset;\n            getJumptoDef(request.fileInfo, offset);\n        } else if (type === MessageIds.TERN_SCOPEDATA_MSG) {\n            offset  = request.offset;\n            getScopeData(request.fileInfo, offset);\n        } else if (type === MessageIds.TERN_REFS) {\n            offset  = request.offset;\n            getRefs(request.fileInfo, offset);\n        } else if (type === MessageIds.TERN_ADD_FILES_MSG) {\n            handleAddFiles(request.files);\n        } else if (type === MessageIds.TERN_PRIME_PUMP_MSG) {\n            isUntitledDoc = request.isUntitledDoc;\n            handlePrimePump(request.path);\n        } else if (type === MessageIds.TERN_GET_GUESSES_MSG) {\n            offset  = request.offset;\n            getTernProperties(request.fileInfo, offset, MessageIds.TERN_GET_GUESSES_MSG);\n        } else if (type === MessageIds.TERN_UPDATE_FILE_MSG) {\n            handleUpdateFile(request.path, request.text);\n        } else if (type === MessageIds.SET_CONFIG) {\n            setConfig(request.config);\n        } else if (type === MessageIds.TERN_UPDATE_DIRTY_FILE) {\n            updateDirtyFilesCache(request.name, request.action);\n        } else if (type === MessageIds.TERN_CLEAR_DIRTY_FILES_LIST) {\n            clearDirtyFilesCache();\n        } else {\n            console.error(\"Unknown message: \" + JSON.stringify(request));\n        }\n    }\n\n    function invokeTernCommand(commandConfig) {\n        try {\n            _requestTernServer(commandConfig);\n        } catch (error) {\n            console.warn(error);\n        }\n    }\n\n    WorkerComm.setExecHandler(\"invokeTernCommand\", invokeTernCommand);\n    WorkerComm.setExecHandler(\"resetTernServer\", resetTernServer);\n}());\n"],"file":"tern-main.js"}
{"version":3,"sources":["JSUtils/ScopeManager.js"],"names":["define","require","exports","module","_","CodeMirror","DefaultDialogs","Dialogs","DocumentManager","EditorManager","ExtensionUtils","FileSystem","FileUtils","LanguageManager","PreferencesManager","ProjectManager","Strings","StringUtils","NodeDomain","InMemoryFile","HintUtils","MessageIds","Preferences","ternEnvironment","pendingTernRequests","builtinFiles","builtinLibraryNames","isDocumentDirty","_hintCount","currentModule","documentChanges","preferences","deferredPreferences","_bracketsPath","getNativeBracketsDirectoryPath","_modulePath","getNativeModuleDirectoryPath","_nodePath","_absoluteModulePath","join","_domainPath","MAX_HINTS","LARGE_LINE_CHANGE","LARGE_LINE_COUNT","OFFSET_ZERO","line","ch","config","getBuiltins","initTernEnv","path","files","library","forEach","i","resolve","err","file","console","log","readAsText","done","text","JSON","parse","push","fail","error","initPreferences","projectRootPath","state","reject","$","Deferred","pr","getProjectRoot","fullPath","FILE_NAME","configObj","e","SyntaxError","message","ensurePreferences","postMessage","msg","isDirectoryExcluded","excludes","getExcludedDirectories","testPath","makeProjectRelativeIfPossible","stripTrailingSlash","test","isFileBeingEdited","filePath","currentEditor","getActiveEditor","currentDoc","document","isFileExcludedInternal","detectedExclusions","get","indexOf","isFileExcluded","name","languageID","getLanguageForPath","getId","LANGUAGE_ID","getExcludedFiles","addPendingRequest","offset","type","requests","key","$deferredRequest","promise","has","getPendingRequest","requestType","Object","keys","length","getResolvedPath","getJumptoDef","fileInfo","TERN_JUMPTODEF_MSG","filterText","newText","getMaxFileSize","getTextFromDocument","getText","handleRename","response","displayErrorMessageAtCursor","$deferredFindRefs","TERN_REFS","resolveWith","requestJumptoDef","session","ternPromise","TERN_FILE_INFO_TYPE_FULL","offsetLines","getJavascriptText","handleJumptoDef","$deferredJump","resultFile","handleScopeData","TERN_SCOPEDATA_MSG","getTernHints","isProperty","TERN_COMPLETIONS_MSG","getTernFunctionType","TERN_CALLED_FUNC_TYPE_MSG","getFragmentAround","start","minIndent","minLine","endLine","cm","editor","_codeMirror","tabSize","getOption","p","min","indent","Math","max","fn","getLine","search","countColumn","getToken","lastLine","endCh","from","to","TERN_FILE_INFO_TYPE_PART","getRange","getFileInfo","preventPartialUpdates","getCursor","end","isHtmlFile","result","lineCount","TERN_FILE_INFO_TYPE_EMPTY","getOffset","newOffset","requestGuesses","$deferred","TERN_GET_GUESSES_MSG","guesses","setGuesses","handleTernCompletions","completions","properties","fnType","$deferredHints","handleGetGuesses","handleUpdateFile","handleTimedOut","set","location","scope","showModalDialog","DIALOG_ID_INFO","DETECTED_EXCLUSION_TITLE","format","DETECTED_EXCLUSION_INFO","breakableUrl","className","DIALOG_BTN_CLASS_PRIMARY","id","DIALOG_BTN_OK","OK","TernModule","addFilesPromise","rootTernDir","projectRoot","stopAddingFiles","resolvedFiles","numInitialFiles","numResolvedFiles","numAddedFiles","_ternNodeDomain","usingModules","ternModule","debug","exec","_postMessageByPass","updateTernFile","TERN_UPDATE_FILE_MSG","handleTernGetFile","request","replyWith","txt","TERN_GET_FILE_MSG","getDocText","isAbsolutePath","slice","getFileForPath","getDocumentText","docText","findNameInProject","fileName","substring","lastIndexOf","_fileFilter","entry","getAllFiles","filter","pos","primePump","isUntitledDoc","TERN_PRIME_PUMP_MSG","handlePrimePumpCompletion","addFilesToTern","maxFileCount","getMaxFileCount","available","TERN_ADD_FILES_MSG","addAllFilesAndSubdirectories","dir","doneCallback","directory","visitor","isFile","getDirectoryForPath","visit","initTernModule","moduleDeferred","prepareTern","messageIds","SET_CONFIG","on","evt","data","TERN_INFERENCE_TIMEDOUT","TERN_WORKER_READY","resetForced","initTernServer","TERN_INIT_MSG","env","timeout","canSkipTernInitialization","newFile","undefined","doEditorChange","previousDocument","parentPath","addFilesDeferred","updateFilePromise","isUntitled","isDirty","hintsPromise","getContents","contents","map","currentDir","handleEditorChange","resetModule","resetTernServer","ready","whenReady","func","this","event","changedDoc","TERN_UPDATE_DIRTY_FILE","action","TERN_CLEAR_DIRTY_FILES_LIST","resettingDeferred","_maybeReset","force","newTernModule","noReset","d","requestParameterHint","functionOffset","fnTypePromise","when","setFnType","setFunctionCallPos","requestHints","hintPromise","sessionType","getType","property","setTernHints","trackChange","changeList","changed","thisChange","handleFileChange","handleProjectClose","handleProjectOpen","_readyPromise","_setConfig","configUpdate","brackets","_configureJSCodeHints"],"mappings":"AA4BAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,EAAIH,QAAQ,qBAEZI,WAAsBJ,QAAQ,wCAC9BK,eAAsBL,QAAQ,0BAC9BM,QAAsBN,QAAQ,mBAC9BO,gBAAsBP,QAAQ,4BAC9BQ,cAAsBR,QAAQ,wBAC9BS,eAAsBT,QAAQ,wBAC9BU,WAAsBV,QAAQ,yBAC9BW,UAAsBX,QAAQ,kBAC9BY,gBAAsBZ,QAAQ,4BAC9Ba,mBAAsBb,QAAQ,kCAC9Bc,eAAsBd,QAAQ,0BAC9Be,QAAsBf,QAAQ,WAC9BgB,YAAsBhB,QAAQ,qBAC9BiB,WAAsBjB,QAAQ,oBAC9BkB,aAAsBlB,QAAQ,yBAE9BmB,UAAsBnB,QAAQ,eAC9BoB,WAAsBpB,QAAQ,gBAC9BqB,YAAsBrB,QAAQ,iBAE9BsB,gBAAsB,GACtBC,oBAAsB,GACtBC,aAAsB,CAAC,kBAAmB,eAAgB,eAC1DC,oBAAsB,GACtBC,iBAAsB,EACtBC,WAAsB,EACtBC,cAAsB,KACtBC,gBAAsB,KACtBC,YAAsB,KACtBC,oBAAsB,KAEtBC,cAAsBrB,UAAUsB,iCAChCC,YAAsBvB,UAAUwB,6BAA6BjC,QAC7DkC,UAAsB,sBACtBC,oBAAsB,CAACL,cAAeE,aAAaI,KAAK,KACxDC,YAAsB,CAACP,cAAeE,YAAaE,WAAWE,KAAK,KAGnEE,UAAsB,GACtBC,kBAAsB,IACtBC,iBAAsB,IACtBC,YAAsB,CAACC,KAAM,EAAGC,GAAI,GAEpCC,OAAS,GAOb,SAASC,cACL,OAAOtB,oBAMX,SAASuB,cACL,IAAIC,KAAO,CAACZ,oBAAqB,gCAAgCC,KAAK,KAClEY,MACAC,QADQ3B,aAGN4B,QAAQ,SAAUC,GACpB3C,WAAW4C,QAAQL,KAAOI,EAAG,SAAUE,IAAKC,MACnCD,IASDE,QAAQC,IAAI,mCAAqCL,GARjD1C,UAAUgD,WAAWH,MAAMI,KAAK,SAAUC,MACtCV,QAAUW,KAAKC,MAAMF,MACrBpC,oBAAoBuC,KAAKb,QAAQ,UACjC7B,gBAAgB0C,KAAKb,WACtBc,KAAK,SAAUC,OACdT,QAAQC,IAAI,mCAAqCL,SAkBrE,SAASc,gBAAgBC,iBAGjBrC,qBAAuD,YAAhCA,oBAAoBsC,SAC3CtC,oBAAoBuC,SAGxBvC,oBAAsBwC,EAAEC,WACxB,IAAIC,GAAK3D,eAAe4D,iBAKpBD,GACAL,gBAAkBK,GAAGE,SACbP,iBACRX,QAAQC,IAAI,iDAGhB,IAAIT,KAAOmB,gBAAkB/C,YAAYuD,UAEzClE,WAAW4C,QAAQL,KAAM,SAAUM,IAAKC,MAC/BD,KAoBDzB,YAAc,IAAIT,YAClBU,oBAAoBuB,WApBpB3C,UAAUgD,WAAWH,MAAMI,KAAK,SAAUC,MACtC,IAAIgB,UAAY,KAChB,IACIA,UAAYf,KAAKC,MAAMF,MACzB,MAAOiB,GAGLrB,QAAQC,IAAI,kCAAoCT,MAC5C6B,aAAaC,aACbtB,QAAQC,IAAIoB,EAAEE,SAGtBlD,YAAc,IAAIT,YAAYwD,WAC9B9C,oBAAoBuB,YACrBW,KAAK,SAAUC,OACdpC,YAAc,IAAIT,YAClBU,oBAAoBuB,cAapC,SAAS2B,oBACAlD,qBACDoC,kBAQR,SAASe,YAAYC,KACbvD,eACAA,cAAcsD,YAAYC,KAUlC,SAASC,oBAAoBnC,MACzB,IAAIoC,SAAWvD,YAAYwD,yBAE3B,IAAKD,SACD,OAAO,EAGX,IAAIE,SAAWzE,eAAe0E,8BAA8BvC,MAG5D,OAFAsC,SAAW5E,UAAU8E,mBAAmBF,UAEjCF,SAASK,KAAKH,UASzB,SAASI,kBAAkBC,UACvB,IAAIC,cAAkBrF,cAAcsF,kBAChCC,WAAkBF,eAAiBA,cAAcG,SAErD,OAAQD,YAAcA,WAAWvC,KAAKmB,WAAaiB,SASvD,SAASK,uBAAuBhD,MAG5B,IAAIiD,mBAAqBrF,mBAAmBsF,IAAI,mCAAqC,GACrF,SAAID,qBAA4D,IAAtCA,mBAAmBE,QAAQnD,OAazD,SAASoD,eAAe7C,MACpB,GAAqB,MAAjBA,KAAK8C,KAAK,GACV,OAAO,EAGX,IAAIC,WACJ,GADiB3F,gBAAgB4F,mBAAmBhD,KAAKmB,UAAU8B,UAChDtF,UAAUuF,YACzB,OAAO,EAGX,IAAIrB,SAAWvD,YAAY6E,mBAC3B,SAAItB,WAAYA,SAASK,KAAKlC,KAAK8C,UAI/BL,uBAAuBzC,KAAKmB,UAgBpC,SAASiC,kBAAkBpD,KAAMqD,OAAQC,MACrC,IAAIC,SACAC,IAAMxD,KAAO,IAAMqD,OAAOjE,KAAO,IAAMiE,OAAOhE,GAC9CoE,iBAGJ,OAAIhB,uBAAuBzC,OAChB,IAAKe,EAAEC,UAAYF,SAAS4C,WAGnC/G,EAAEgH,IAAI5F,oBAAqByF,KAC3BD,SAAWxF,oBAAoByF,MAE/BD,SAAW,GACXxF,oBAAoByF,KAAOD,UAG3B5G,EAAEgH,IAAIJ,SAAUD,MAChBG,iBAAmBF,SAASD,MAE5BC,SAASD,MAAQG,iBAAmB,IAAI1C,EAAEC,SAEvCyC,iBAAiBC,WAU5B,SAASE,kBAAkB5D,KAAMqD,OAAQC,MACrC,IAAIE,IAAMxD,KAAO,IAAMqD,OAAOjE,KAAO,IAAMiE,OAAOhE,GAClD,GAAI1C,EAAEgH,IAAI5F,oBAAqByF,KAAM,CACjC,IAAID,SAAWxF,oBAAoByF,KAC/BK,YAAcN,SAASD,MAQ3B,cANOvF,oBAAoByF,KAAKF,MAE3BQ,OAAOC,KAAKR,UAAUS,eAChBjG,oBAAoByF,KAGxBK,aAQf,SAASI,gBAAgBjE,MACrB,OAAO5B,cAAc6F,gBAAgBjE,MAczC,SAASkE,aAAaC,SAAUd,QAO5B,OANA3B,YAAY,CACR4B,KAAM1F,WAAWwG,mBACjBD,SAAUA,SACVd,OAAQA,SAGLD,kBAAkBe,SAASrB,KAAMO,OAAQzF,WAAWwG,oBAQ/D,SAASC,WAAWhE,MAChB,IAAIiE,QAAUjE,KAId,OAHIA,KAAK2D,OAAS1F,YAAYiG,mBAC1BD,QAAU,IAEPA,QASX,SAASE,oBAAoBhC,UACzB,IAAInC,KAAOmC,SAASiC,UAEpB,OADApE,KAAOgE,WAAWhE,MAUtB,SAASqE,aAAaC,UAElB,GAAIA,SAASjE,MACT1D,cAAcsF,kBAAkBsC,4BAA4BD,SAASjE,WADzE,CAKA,IAAIV,KACAqD,OAEAwB,kBAAoBjB,kBAHbe,SAAS3E,KACP2E,SAAStB,OAEkCzF,WAAWkH,WAE/DD,mBACAA,kBAAkBE,YAAY,KAAM,CAACJ,YAa7C,SAASK,iBAAiBC,QAASzC,SAAUa,QACzC,IAAI5D,KAAU+C,SAASxC,KAAKmB,SACxBgD,SAOAe,YAEJ,MAAO,CAACxB,QAFUQ,aAPH,CACPZ,KAAM1F,WAAWuH,yBACjBrC,KAAMrD,KACN2F,YAAa,EACb/E,KAAMgE,WAAWY,QAAQI,sBAGQhC,SAW7C,SAASiC,gBAAgBX,UAErB,IAAI3E,KACAqD,OAEAkC,cAAgB3B,kBAHTe,SAAS3E,KACP2E,SAAStB,OAE8BzF,WAAWwG,oBAE3DmB,gBACAZ,SAASxD,SAAW8C,gBAAgBU,SAASa,YAC7CD,cAAcR,YAAY,KAAM,CAACJ,YAUzC,SAASc,gBAAgBd,UACrB,IAAI3E,KACAqD,OAEAkC,cAAgB3B,kBAHTe,SAAS3E,KACP2E,SAAStB,OAE8BzF,WAAW8H,oBAE3DH,eACAA,cAAcR,YAAY,KAAM,CAACJ,WAkBzC,SAASgB,aAAaxB,SAAUd,OAAQuC,YAapC,OAPAlE,YAAY,CACR4B,KAAM1F,WAAWiI,qBACjB1B,SAAUA,SACVd,OAAQA,OACRuC,WAAYA,aAGTxC,kBAAkBe,SAASrB,KAAMO,OAAQzF,WAAWiI,sBAa/D,SAASC,oBAAoB3B,SAAUd,QAOnC,OANA3B,YAAY,CACR4B,KAAM1F,WAAWmI,0BACjB5B,SAAUA,SACVd,OAAQA,SAGLD,kBAAkBe,SAASrB,KAAMO,OAAQzF,WAAWmI,2BAY/D,SAASC,kBAAkBf,QAASgB,OAChC,IAAIC,UAAY,KACZC,QAAY,KACZC,QACAC,GAAYpB,QAAQqB,OAAOC,YAC3BC,QAAYH,GAAGI,UAAU,WACzBjE,SAAYyC,QAAQqB,OAAO9D,SAC3BkE,EACAC,IACAC,OACAxH,KAGJ,IAAKsH,EAAIT,MAAM7G,KAAO,EAAGuH,IAAME,KAAKC,IAAI,EAAGJ,EAAI,KAAMA,GAAKC,MAAOD,EAAG,CAEhE,IAAIK,IADJ3H,KAAO6F,QAAQ+B,QAAQN,IACTO,OAAO,gBAEjBF,IAAM,IACNH,OAAShK,WAAWsK,YAAY9H,KAAM,KAAMoH,UAC1B,OAAdN,WAAsBA,UAAYU,SACmB,YAAjD3B,QAAQkC,SAAS,CAAC/H,KAAMsH,EAAGrH,GAAI0H,GAAK,IAAIzD,OACxC4C,UAAYU,OACZT,QAAUO,IAMR,OAAdR,YACAA,UAAY,GAGA,OAAZC,UACAA,QAAUQ,KAGd,IAAIG,IAAMD,KAAKF,IAAIN,GAAGe,WAAYnB,MAAM7G,KAAO,KAC3CiI,MAAQ,EAEZ,IAAKjB,QAAUH,MAAM7G,KAAO,EAAGgH,QAAUU,MAAOV,QAG5C,IAFAhH,KAAOiH,GAAGW,QAAQZ,UAETpC,OAAS,IACd4C,OAAShK,WAAWsK,YAAY9H,KAAM,KAAMoH,WAC9BN,UAAW,CACrBmB,MAAQjI,KAAK4E,OACb,MAKZ,IAAIsD,KAAO,CAAClI,KAAM+G,QAAS9G,GAAI,GAC3BkI,GAAO,CAACnI,KAAMgH,QAAS/G,GAAIgI,OAE/B,MAAO,CAAC/D,KAAM1F,WAAW4J,yBACrB1E,KAAMN,SAASxC,KAAKmB,SACpBiE,YAAakC,KAAKlI,KAClBiB,KAAMmC,SAASiF,SAASH,KAAMC,KActC,SAASG,YAAYzC,QAAS0C,uBAC1B,IAAI1B,MAAQhB,QAAQ2C,YAChBC,IAAM5B,MACNzD,SAAWyC,QAAQqB,OAAO9D,SAC1B/C,KAAO+C,SAASxC,KAAKmB,SACrB2G,WACAC,OAsBJ,OAnBIA,OAJkE,SAArD3K,gBAAgB4F,mBAAmBvD,MAAMwD,QAI7C,CAACK,KAAM1F,WAAWuH,yBACvBrC,KAAMrD,KACNY,KAAM4E,QAAQI,qBACVhH,iBAIAsJ,uBAAyB1C,QAAQqB,OAAO0B,YAAc9I,kBACzDb,gBAAgBkJ,GAAKlJ,gBAAgBiJ,KAAOrI,mBAC7CZ,gBAAgBiJ,MAAQrB,MAAM7G,MAC9Bf,gBAAgBkJ,GAAKM,IAAIzI,KACpB4G,kBAAkBf,QAASgB,OAE3B,CAAC3C,KAAM1F,WAAWuH,yBACvBrC,KAAMrD,KACNY,KAAMmE,oBAAoBhC,WAXrB,CAACc,KAAM1F,WAAWqK,0BACvBnF,KAAMrD,KACNY,KAAM,IAYdhC,gBAAkB,KACX0J,OAgBX,SAASG,UAAUjD,QAASd,SAAUd,QAClC,IAAI8E,UAYJ,OATIA,UADA9E,OACY,CAACjE,KAAMiE,OAAOjE,KAAMC,GAAIgE,OAAOhE,IAE/B4F,QAAQ2C,YAGpBzD,SAASb,OAAS1F,WAAW4J,2BAC7BW,UAAU/I,KAAOyH,KAAKC,IAAI,EAAGqB,UAAU/I,KAAO+E,SAASiB,cAGpD+C,UAYX,SAASC,eAAenD,QAASzC,UAC7B,IAAI6F,UAAYtH,EAAEC,WACdmD,SAAWuD,YAAYzC,SACvB5B,OAAS6E,UAAUjD,QAASd,UAQ5BT,QAQJ,OAdAhC,YAAY,CACR4B,KAAM1F,WAAW0K,qBACjBnE,SAAUA,SACVd,OAAQA,SAGED,kBAAkBe,SAASrB,KAAMO,OAAQzF,WAAW0K,sBAC1DlI,KAAK,SAAUmI,SACnBtD,QAAQuD,WAAWD,SACnBF,UAAUvI,YACXW,KAAK,WACJ4H,UAAUvH,WAGPuH,UAAU3E,UAUrB,SAAS+E,sBAAsB9D,UAE3B,IAAI3E,KAAO2E,SAAS3E,KAChBqD,OAASsB,SAAStB,OAClBqF,YAAc/D,SAAS+D,YACvBC,WAAahE,SAASgE,WACtBC,OAAUjE,SAASiE,OACnBtF,KAAOqB,SAASrB,KAChB5C,MAAQiE,SAASjE,MACjBmI,eAAiBjF,kBAAkB5D,KAAMqD,OAAQC,MAEjDuF,iBACInI,MACAmI,eAAe/H,SACR4H,YACPG,eAAe9D,YAAY,KAAM,CAAC,CAAC2D,YAAaA,eACzCC,WACPE,eAAe9D,YAAY,KAAM,CAAC,CAAC4D,WAAYA,cACxCC,QACPC,eAAe9D,YAAY,KAAM,CAAC6D,UAc9C,SAASE,iBAAiBnE,UACtB,IAAIlF,KAAOkF,SAAS3E,KAChBsD,KAAOqB,SAASrB,KAChBD,OACAwF,eAAiBjF,kBAAkBnE,KAD1BkF,SAAStB,OAC+BC,MAEjDuF,gBACAA,eAAe9D,YAAY,KAAM,CAACJ,SAASgE,aAUnD,SAASI,iBAAiBpE,UAEtB,IAAIlF,KAAOkF,SAASlF,KAChB6D,KAAOqB,SAASrB,KAChBuF,eAAiBjF,kBAAkBnE,KAAMN,YAAamE,MAEtDuF,gBACAA,eAAe/I,UASvB,SAASkJ,eAAerE,UAEpB,IAAIjC,mBAAsBrF,mBAAmBsF,IAAI,mCAAqC,GAClFP,SAAsBuC,SAAS3E,KAG/BmC,kBAAkBC,aAKwB,IAA1CM,mBAAmBE,QAAQR,WAM/BM,mBAAmBlC,KAAK4B,UACxB/E,mBAAmB4L,IAAI,iCAAkCvG,mBAAoB,CAAEwG,SAAU,CAAEC,MAAO,aAGlGrM,QAAQsM,gBACJvM,eAAewM,eACf9L,QAAQ+L,yBACR9L,YAAY+L,OACRhM,QAAQiM,wBACRhM,YAAYiM,aAAarH,WAE7B,CACI,CACIsH,UAAW5M,QAAQ6M,yBACnBC,GAAI9M,QAAQ+M,cACZxJ,KAAM9C,QAAQuM,OApBtB7J,QAAQC,IAAI,2FAA6FkC,WAiDjH,SAAS2H,aACL,IAAI7E,YAAsB,KACtB8E,gBAAsB,KACtBC,YAAsB,KACtBC,YAAsB,KACtBC,iBAAsB,EACtBC,cAAsB,GACtBC,gBAAsB,EACtBC,iBAAsB,EACtBC,cAAsB,EACtBC,gBAAsB,KAM1B,SAASvG,gBAAgBjE,MACrB,OAAOoK,cAAcpK,MAUzB,SAASyK,eACL,OAAOJ,kBAAoBC,iBAO/B,SAAS5I,YAAYC,KACjBqI,gBAAgB5J,KAAK,SAAUsK,YAEtBF,kBAIDlL,OAAOqL,OACP1K,QAAQ0K,MAAM,kBAAmBhJ,KAErC6I,gBAAgBI,KAAK,oBAAqBjJ,QAQlD,SAASkJ,mBAAmBlJ,KACxBuD,YAAY9E,KAAK,SAAUsK,YACnBpL,OAAOqL,OACP1K,QAAQ0K,MAAM,kBAAmBhJ,KAErC6I,gBAAgBI,KAAK,oBAAqBjJ,OAUlD,SAASmJ,eAAetI,UACpB,IAAI/C,KAAQ+C,SAASxC,KAAKmB,SAQ1B,OANA0J,mBAAmB,CACfvH,KAAM1F,WAAWmN,qBACjBtL,KAAMA,KACNY,KAAMmE,oBAAoBhC,YAGvBY,kBAAkB3D,KAAMN,YAAavB,WAAWmN,sBAS3D,SAASC,kBAAkBC,SAEvB,SAASC,UAAUpI,KAAMqI,KACrBN,mBAAmB,CACfvH,KAAM1F,WAAWwN,kBACjBpL,KAAM8C,KACNzC,KAAM8K,MAId,IAAIrI,KAAOmI,QAAQjL,KAUnB,SAASqL,WAAWjJ,UAChB,IAAKlF,WAAWoO,eAAelJ,WACE,OAAzBA,SAASmJ,MAAM,EAAG,GACtB,OAAO,IAAKxK,EAAEC,UAAYF,SAAS4C,UAGvC,IAAI1D,KAAO9C,WAAWsO,eAAepJ,UACjCsB,QAAU3G,gBAAgB0O,gBAAgBzL,MAO9C,OALA0D,QAAQtD,KAAK,SAAUsL,SACnBtB,cAActH,MAAQV,SACtBkI,mBACAY,UAAUpI,KAAMuB,WAAWqH,YAExBhI,QASX,SAASiI,oBAEL,IAAIC,SAAW9I,KAAK+I,UAAU/I,KAAKgJ,YAAY,KAAO,GAEtD,SAASC,YAAYC,OACjB,OAAOA,MAAMlJ,OAAS8I,SAG1BtO,eAAe2O,YAAYF,aAAa3L,KAAK,SAAUV,OACnD,IAAIM,KAMiB,KALrBN,MAAQA,MAAMwM,OAAO,SAAUlM,MAC3B,IAAImM,IACJ,OADUnM,KAAKmB,SAAS6C,OAASlB,KAAKkB,SACvBhE,KAAKmB,SAAS2K,YAAYhJ,SAGnCkB,SACNhE,KAAON,MAAM,IAEbM,KACAqL,WAAWrL,KAAKmB,UAAUV,KAAK,WAC3ByK,UAAUpI,KAAM,MAGpBoI,UAAUpI,KAAM,MAKvBL,uBAAuBK,OACxBuI,WAAWvI,MAAMrC,KAAK,WAClB4K,WAAWpB,YAAcnH,MAAMrC,KAAK,WAEhC4K,WAAWnB,YAAcpH,MAGpBrC,KAAKkL,uBAY1B,SAASS,UAAU3M,KAAM4M,eAOrB,OANAxB,mBAAmB,CACfvH,KAAM1F,WAAW0O,oBACjB7M,KAAMA,KACN4M,cAAeA,gBAGZjJ,kBAAkB3D,KAAMN,YAAavB,WAAW0O,qBAS3D,SAASC,0BAA0B5H,UAE/B,IAAIlF,KAAOkF,SAASlF,KAChB6D,KAAOqB,SAASrB,KAChBuF,eAAiBjF,kBAAkBnE,KAAMN,YAAamE,MAEtDuF,gBACAA,eAAe/I,UAYvB,SAAS0M,eAAe9M,OAEpB,IAAI+M,aAAenO,YAAYoO,kBAC/B,GAAIpC,iBAAmBC,cAAgBkC,aAAc,CACjD,IAAIE,UAAYF,aAAenC,iBAAmBC,cAE9CoC,UAAYjN,MAAMsE,SAClBtE,MAAQA,MAAM6L,MAAM,EAAGoB,YAG3BpC,eAAiB7K,MAAMsE,OACvBkB,YAAY9E,KAAK,SAAUsK,YACvB,IAAI/I,IAAM,CACN2B,KAAM1F,WAAWgP,mBACjBlN,MAAOA,OAGPJ,OAAOqL,OACP1K,QAAQ0K,MAAM,kBAAmBhJ,KAErC6I,gBAAgBI,KAAK,oBAAqBjJ,YAI9CwI,iBAAkB,EAGtB,OAAOA,gBAWX,SAAS0C,6BAA6BC,IAAKC,cACvC7P,WAAW4C,QAAQgN,IAAK,SAAU/M,IAAKiN,WACnC,SAASC,QAAQjB,OACb,IAAIA,MAAMkB,OAKN,OAAQtL,oBAAoBoK,MAAM7K,WACF,IAA5B6K,MAAMlJ,KAAKF,QAAQ,OAClBuH,gBANAtH,eAAemJ,QAChBQ,eAAe,CAACR,MAAM7K,WAS9BpB,MAIA+M,MAAQ5P,WAAWiQ,oBAAoBlD,aAK3C+C,UAAUI,MAAMH,QAASF,cAJrBA,kBAWZ,SAASM,iBACL,IAAIC,eAAiBvM,EAAEC,WAGvB,SAASuM,cACL/C,gBAAgBI,KAAK,eAAgB,CACjC4C,WAAY5P,aAGhB4M,gBAAgBI,KAAK,oBAAqB,CACtCtH,KAAM1F,WAAW6P,WACjBnO,OAAQA,SAEZgO,eAAevI,YAAY,KAAM,CAACyF,kBAXtCtF,YAAcoI,eAAe5J,UAczB8G,iBACAA,gBAAgBI,KAAK,mBACrB0C,eAAevI,YAAY,KAAM,CAACyF,qBAElCA,gBAAsB,IAAI/M,WAAW,iBAAkBsB,cACvC2O,GAAG,OAAQ,SAAUC,IAAKC,MAClCtO,OAAOqL,OACP1K,QAAQC,IAAI,mBAAoB0N,KAAKtK,MAGzC,IAAIqB,SAAWiJ,KACXtK,KAAOqB,SAASrB,KAEhBA,OAAS1F,WAAWiI,sBAChBvC,OAAS1F,WAAWmI,0BAExB0C,sBAAsB9D,UACfrB,OAAS1F,WAAWwN,kBAE3BJ,kBAAkBrG,UACXrB,OAAS1F,WAAWwG,mBAC3BkB,gBAAgBX,UACTrB,OAAS1F,WAAW8H,mBAC3BD,gBAAgBd,UACTrB,OAAS1F,WAAWkH,UAC3BJ,aAAaC,UACNrB,OAAS1F,WAAW0O,oBAC3BC,0BAA0B5H,UACnBrB,OAAS1F,WAAW0K,qBAC3BQ,iBAAiBnE,UACVrB,OAAS1F,WAAWmN,qBAC3BhC,iBAAiBpE,UACVrB,OAAS1F,WAAWiQ,wBAC3B7E,eAAerE,UACRrB,OAAS1F,WAAWkQ,kBAC3BR,eAAevI,YAAY,KAAM,CAACyF,kBAClB,iBAATlH,KAEHlF,gBACAmP,cAGAnP,cAAc2P,aAAc,GAGhC9N,QAAQC,IAAI,iBAAmByE,SAASzE,KAAOyE,aAIvD6F,gBAAgB9G,UAAUtD,KAAKmN,cAOvC,SAASS,eAAelB,IAAKpN,OACzB2N,iBACA/C,iBAAmB,EACnBC,cAAgB,EAChBJ,iBAAkB,EAClBE,gBAAkB3K,MAAMsE,OAExBkB,YAAY9E,KAAK,SAAUsK,YACvB,IAAI/I,IAAM,CACN2B,KAAM1F,WAAWqQ,cACjBnB,IAAKA,IACLpN,MAAOA,MACPwO,IAAKpQ,gBACLqQ,QAAS9Q,mBAAmBsF,IAAI,iCAEpC6H,gBAAgBI,KAAK,oBAAqBjJ,OAE9CsI,YAAc6C,IAAM,IAWxB,SAASsB,0BAA0BC,SAC/B,YAAkCC,IAA3BlE,cAAciE,SAWzB,SAASE,eAAetJ,QAASzC,SAAUgM,kBACvC,IAAIxO,KAAcwC,SAASxC,KACvBP,KAAcO,KAAKmB,SACnB2L,IAAc9M,KAAKyO,WACnBxN,GAEAyN,iBAAmB3N,EAAEC,WAWb2N,mBATZtQ,gBAAkB,KAClB2L,gBAAkB0E,iBAAiBhL,UACnCzC,GAAK3D,eAAe4D,iBAAmB5D,eAAe4D,iBAAiBC,SAAW,KAG9EiN,0BAA0B3O,QAGtBvB,iBAAmBsQ,iBACK1D,eAAe0D,kBACrBpO,KAAK,WACnBgM,UAAU3M,KAAM+C,SAASoM,cACzBF,iBAAiB3J,YAAY,KAAM,CAACyF,oBAGxCkE,iBAAiB3J,YAAY,KAAM,CAACyF,kBAGxCtM,iBAAkB,IAIlBsQ,kBAAoBA,iBAAiBK,SACrC/D,eAAe0D,kBAGnBtQ,iBAAkB,EAClBkM,cAAgB,GAChBF,YAAcjJ,GAEdQ,oBACAlD,oBAAoB6B,KAAK,WAGjB,IAAI0O,aAFR,GAAI9O,gBAAgBtC,aAMhB,OALAsQ,eAAe/M,GAAI,SACAmL,UAAU3M,MAAM,GACtBW,KAAK,WACdsO,iBAAiB3J,YAAY,KAAM,CAACyF,oBAK5CtN,WAAW4C,QAAQgN,IAAK,SAAU/M,IAAKiN,WACnC,GAAIjN,IAGA,OAFAE,QAAQS,MAAM,kBAAmBoM,UACjC4B,iBAAiB3J,YAAY,MAIjCiI,UAAU+B,YAAY,SAAUhP,IAAKiP,UACjC,GAAIjP,IAGA,OAFAE,QAAQS,MAAM,6BAA8BsM,gBAC5C0B,iBAAiB3J,YAAY,MAIjC,IAAIrF,MAAQsP,SACP9C,OAAO,SAAUF,OACd,OAAOA,MAAMkB,SAAWrK,eAAemJ,SAE1CiD,IAAI,SAAUjD,OACX,OAAOA,MAAM7K,WAKjB2N,aAFJd,eAAelB,IAAKpN,OAED0M,UAAU3M,MAAM,GACtBW,KAAK,WACTqK,eAqBDiE,iBAAiB3J,YAAY,KAAM,CAACyF,kBAjBpCqC,6BAA6BC,IAAK,WAG9B,IAAIoC,WAAcpC,IAAM,IACpB5C,aAAegF,aAAehF,aACU,IAApCgF,WAAWtM,QAAQsH,aACvB2C,6BAA6B3C,YAAa,WAGtCkC,UAAU3M,MAAM,GAChBiP,iBAAiB3J,YAAY,KAAM,CAACyF,oBAGxCkE,iBAAiB3J,YAAY,KAAM,CAACyF,6BAmBpE,SAAS2E,mBAAmBlK,QAASzC,SAAUgM,kBACnB,OAApBxE,gBACAuE,eAAetJ,QAASzC,SAAUgM,kBAElCxE,gBAAgB5J,KAAK,WACjBmO,eAAetJ,QAASzC,SAAUgM,oBAW9C,SAASY,cACL,SAASC,kBACD7E,gBAAgB8E,SAChB9E,gBAAgBI,KAAK,mBAIzBJ,kBACIR,gBAGAA,gBAAgB5J,KAAKiP,iBAAiB5O,KAAK4O,iBAE3CA,mBAKZ,SAASE,UAAUC,MACfxF,gBAAgB5J,KAAKoP,MASzB,OANAC,KAAKL,YAAcA,YACnBK,KAAKN,mBAAqBA,mBAC1BM,KAAK/N,YAAcA,YACnB+N,KAAKxL,gBAAkBA,gBACvBwL,KAAKF,UAAYA,UAEVE,KAhuCXjQ,cAuqBAzC,gBAAgB2Q,GAAG,kBAAmB,SAAUgC,MAAOC,YAC/CA,WAAW3P,KAAKmB,UAChBO,YAAY,CACR4B,KAAM1F,WAAWgS,uBACjB9M,KAAM6M,WAAW3P,KAAKmB,SACtB0O,OAAQF,WAAWd,YAM/BvR,eAAeoQ,GAAG,qBAAsB,WACpChM,YAAY,CACR4B,KAAM1F,WAAWkS,gCA+iBzB,IAAIC,kBAAoB,KAkBxB,SAASC,YAAY/K,QAASzC,SAAUyN,OACpC,IAAIC,cAGJ,IAAKH,kBAAmB,CAKpB,KAAI3R,cAAc2P,aAAekC,QAAW3Q,OAAO6Q,WAAahS,WAAaa,WAiBtE,CACH,IAAIoR,EAAI,IAAIrP,EAAEC,SAEd,OADAoP,EAAEtQ,QAAQ1B,eACHgS,EAAE1M,UAnBLpE,OAAOqL,OACP1K,QAAQ0K,MAAM,yBAGlBoF,kBAAoB,IAAIhP,EAAEC,UAC1BkP,cAAgB,IAAInG,YACNoF,mBAAmBlK,QAASzC,SAAU,MACpD0N,cAAcX,UAAU,WAEpBnR,cAAcgR,cACdhR,cAAgB8R,cAChBH,kBAAkBjQ,QAAQ1B,eAE1B2R,kBAAoB,OAExB5R,WAAa,EAQrB,OAAO4R,kBAAkBrM,UAW7B,SAAS2M,qBAAqBpL,QAASqL,gBACnC,IAAIzH,eAAiB9H,EAAEC,WACnBmD,SAAWuD,YAAYzC,SAAS,GAChC5B,OACAkN,cAAgBzK,oBAAoB3B,SAD3B+D,UAAUjD,QAASd,SAAUmM,iBAa1C,OAVAvP,EAAEyP,KAAKD,eAAenQ,KAClB,SAAUwI,QACN3D,QAAQwL,UAAU7H,QAClB3D,QAAQyL,mBAAmBJ,gBAC3BzH,eAAe9D,YAAY,KAAM,CAAC6D,WAExCnI,KAAK,WACHoI,eAAe/H,WAGZ+H,eAAenF,UAiB1B,SAASiN,aAAa1L,QAASzC,UAC3B,IAAIqG,eAAiB9H,EAAEC,WACnB4P,YACAC,YAAc5L,QAAQ6L,UACtB3M,SAAWuD,YAAYzC,SACvB5B,OAAS6E,UAAUjD,QAASd,SAAU,MAsB1C,OApBA6L,YAAY/K,QAASzC,UAErBoO,YAAcjL,aAAaxB,SAAUd,OAAQwN,YAAYE,UAEzDhQ,EAAEyP,KAAKI,aAAaxQ,KAChB,SAAUsI,YAAaE,QACfF,YAAYA,aACZzD,QAAQ+L,aAAatI,YAAYA,aACjCzD,QAAQuD,WAAW,QAEnBvD,QAAQ+L,aAAa,IACrB/L,QAAQuD,WAAWE,YAAYC,aAGnCE,eAAe9D,YAAY,QAEjCtE,KAAK,WACHoI,eAAe/H,WAGZ+H,eAAenF,UAU1B,SAASuN,YAAYC,YACjB,IAAIC,QAAU9S,gBAAiBwB,EAQ/B,IAPgB,OAAZsR,UACA9S,gBAAkB8S,QAAU,CAAC7J,KAAM4J,WAAW,GAAG5J,KAAKlI,KAAMmI,GAAI2J,WAAW,GAAG5J,KAAKlI,MAC/EE,OAAOqL,OACP1K,QAAQ0K,MAAM,uCAIjB9K,EAAI,EAAGA,EAAIqR,WAAWlN,OAAQnE,IAAK,CACpC,IAAIuR,WAAaF,WAAWrR,GACxBgI,IAAMuJ,WAAW9J,KAAKlI,MAAQgS,WAAW/Q,KAAK2D,OAAS,GACvDoN,WAAW9J,KAAKlI,KAAO+R,QAAQ5J,KAC/B4J,QAAQ5J,GAAK4J,QAAQ5J,IAAM6J,WAAW7J,GAAGnI,KAAOyI,MAGhDA,KAAOsJ,QAAQ5J,KACf4J,QAAQ5J,GAAKM,IAAM,GAGnBsJ,QAAQ7J,KAAO8J,WAAW9J,KAAKlI,OAC/B+R,QAAQ7J,KAAO8J,WAAW9J,KAAKlI,OAW3C,SAASiS,iBAAiBH,YACtBhT,iBAAkB,EAClB+S,YAAYC,YAUhB,SAAS/B,mBAAmBlK,QAASzC,SAAUgM,kBAM3C,OAJKpQ,gBACDA,cAAgB,IAAI2L,YAGjB3L,cAAc+Q,mBAAmBlK,QAASzC,SAAUgM,kBAO/D,SAAS8C,qBACDlT,eACAA,cAAcgR,cAWtB,SAASmC,kBAAkB3Q,iBACvBD,gBAAgBC,iBAIpB,SAAS4Q,gBACL,OAAOjT,oBAQX,SAASkT,WAAWC,cAChBpS,OAASqS,SAASC,sBAAsBtS,OACxCoC,YAAY,CACR4B,KAAM1F,WAAW6P,WACjBnO,OAAQoS,eAIhBjV,QAAQgV,WAAaA,WACrBhV,QAAQuT,YAAcA,YACtBvT,QAAQ8C,YAAcA,YACtB9C,QAAQwH,gBAAkBA,gBAC1BxH,QAAQkJ,aAAeA,aACvBlJ,QAAQ0S,mBAAqBA,mBAC7B1S,QAAQ2L,eAAiBA,eACzB3L,QAAQ4U,iBAAmBA,iBAC3B5U,QAAQkU,aAAeA,aACvBlU,QAAQuI,iBAAmBA,iBAC3BvI,QAAQ4T,qBAAuBA,qBAC/B5T,QAAQ6U,mBAAqBA,mBAC7B7U,QAAQ8U,kBAAoBA,kBAC5B9U,QAAQ+U,cAAgBA,cACxB/U,QAAQ4H,WAAaA,WACrB5H,QAAQiF,YAAcA,YACtBjF,QAAQ2G,kBAAoBA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*\n * Throughout this file, the term \"outer scope\" is used to refer to the outer-\n * most/global/root Scope objects for particular file. The term \"inner scope\"\n * is used to refer to a Scope object that is reachable via the child relation\n * from an outer scope.\n */\n\ndefine(function (require, exports, module) {\n\n\n    var _ = require(\"thirdparty/lodash\");\n\n    var CodeMirror          = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        DefaultDialogs      = require(\"widgets/DefaultDialogs\"),\n        Dialogs             = require(\"widgets/Dialogs\"),\n        DocumentManager     = require(\"document/DocumentManager\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        ExtensionUtils      = require(\"utils/ExtensionUtils\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        LanguageManager     = require(\"language/LanguageManager\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        ProjectManager      = require(\"project/ProjectManager\"),\n        Strings             = require(\"strings\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        NodeDomain          = require(\"utils/NodeDomain\"),\n        InMemoryFile        = require(\"document/InMemoryFile\");\n\n    var HintUtils           = require(\"./HintUtils\"),\n        MessageIds          = require(\"./MessageIds\"),\n        Preferences         = require(\"./Preferences\");\n\n    var ternEnvironment     = [],\n        pendingTernRequests = {},\n        builtinFiles        = [\"ecmascript.json\", \"browser.json\", \"jquery.json\"],\n        builtinLibraryNames = [],\n        isDocumentDirty     = false,\n        _hintCount          = 0,\n        currentModule       = null,\n        documentChanges     = null,     // bounds of document changes\n        preferences         = null,\n        deferredPreferences = null;\n\n    var _bracketsPath       = FileUtils.getNativeBracketsDirectoryPath(),\n        _modulePath         = FileUtils.getNativeModuleDirectoryPath(module),\n        _nodePath           = \"node/TernNodeDomain\",\n        _absoluteModulePath = [_bracketsPath, _modulePath].join(\"/\"),\n        _domainPath         = [_bracketsPath, _modulePath, _nodePath].join(\"/\");\n\n\n    var MAX_HINTS           = 30,  // how often to reset the tern server\n        LARGE_LINE_CHANGE   = 100,\n        LARGE_LINE_COUNT    = 10000,\n        OFFSET_ZERO         = {line: 0, ch: 0};\n\n    var config = {};\n\n    /**\n     *  An array of library names that contain JavaScript builtins definitions.\n     *\n     * @return {Array.<string>} - array of library  names.\n     */\n    function getBuiltins() {\n        return builtinLibraryNames;\n    }\n\n    /**\n     * Read in the json files that have type information for the builtins, dom,etc\n     */\n    function initTernEnv() {\n        var path = [_absoluteModulePath, \"node/node_modules/tern/defs/\"].join(\"/\"),\n            files = builtinFiles,\n            library;\n\n        files.forEach(function (i) {\n            FileSystem.resolve(path + i, function (err, file) {\n                if (!err) {\n                    FileUtils.readAsText(file).done(function (text) {\n                        library = JSON.parse(text);\n                        builtinLibraryNames.push(library[\"!name\"]);\n                        ternEnvironment.push(library);\n                    }).fail(function (error) {\n                        console.log(\"failed to read tern config file \" + i);\n                    });\n                } else {\n                    console.log(\"failed to read tern config file \" + i);\n                }\n            });\n        });\n    }\n\n    initTernEnv();\n\n    /**\n     *  Init preferences from a file in the project root or builtin\n     *  defaults if no file is found;\n     *\n     *  @param {string=} projectRootPath - new project root path. Only needed\n     *  for unit tests.\n     */\n    function initPreferences(projectRootPath) {\n\n        // Reject the old preferences if they have not completed.\n        if (deferredPreferences && deferredPreferences.state() === \"pending\") {\n            deferredPreferences.reject();\n        }\n\n        deferredPreferences = $.Deferred();\n        var pr = ProjectManager.getProjectRoot();\n\n        // Open preferences relative to the project root\n        // Normally there is a project root, but for unit tests we need to\n        // pass in a project root.\n        if (pr) {\n            projectRootPath = pr.fullPath;\n        } else if (!projectRootPath) {\n            console.log(\"initPreferences: projectRootPath has no value\");\n        }\n\n        var path = projectRootPath + Preferences.FILE_NAME;\n\n        FileSystem.resolve(path, function (err, file) {\n            if (!err) {\n                FileUtils.readAsText(file).done(function (text) {\n                    var configObj = null;\n                    try {\n                        configObj = JSON.parse(text);\n                    } catch (e) {\n                        // continue with null configObj which will result in\n                        // default settings.\n                        console.log(\"Error parsing preference file: \" + path);\n                        if (e instanceof SyntaxError) {\n                            console.log(e.message);\n                        }\n                    }\n                    preferences = new Preferences(configObj);\n                    deferredPreferences.resolve();\n                }).fail(function (error) {\n                    preferences = new Preferences();\n                    deferredPreferences.resolve();\n                });\n            } else {\n                preferences = new Preferences();\n                deferredPreferences.resolve();\n            }\n        });\n    }\n\n    /**\n     * Will initialize preferences only if they do not exist.\n     *\n     */\n    function ensurePreferences() {\n        if (!deferredPreferences) {\n            initPreferences();\n        }\n    }\n\n    /**\n     * Send a message to the tern module - if the module is being initialized,\n     * the message will not be posted until initialization is complete\n     */\n    function postMessage(msg) {\n        if (currentModule) {\n            currentModule.postMessage(msg);\n        }\n    }\n\n    /**\n     * Test if the directory should be excluded from analysis.\n     *\n     * @param {!string} path - full directory path.\n     * @return {boolean} true if excluded, false otherwise.\n     */\n    function isDirectoryExcluded(path) {\n        var excludes = preferences.getExcludedDirectories();\n\n        if (!excludes) {\n            return false;\n        }\n\n        var testPath = ProjectManager.makeProjectRelativeIfPossible(path);\n        testPath = FileUtils.stripTrailingSlash(testPath);\n\n        return excludes.test(testPath);\n    }\n\n    /**\n     * Test if the file path is in current editor\n     *\n     * @param {string} filePath file path to test for exclusion.\n     * @return {boolean} true if in editor, false otherwise.\n     */\n    function isFileBeingEdited(filePath) {\n        var currentEditor   = EditorManager.getActiveEditor(),\n            currentDoc      = currentEditor && currentEditor.document;\n\n        return (currentDoc && currentDoc.file.fullPath === filePath);\n    }\n\n    /**\n     * Test if the file path is an internal exclusion.\n     *\n     * @param {string} path file path to test for exclusion.\n     * @return {boolean} true if excluded, false otherwise.\n     */\n    function isFileExcludedInternal(path) {\n        // The detectedExclusions are files detected to be troublesome with current versions of Tern.\n        // detectedExclusions is an array of full paths.\n        var detectedExclusions = PreferencesManager.get(\"jscodehints.detectedExclusions\") || [];\n        if (detectedExclusions && detectedExclusions.indexOf(path) !== -1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Test if the file should be excluded from analysis.\n     *\n     * @param {!File} file - file to test for exclusion.\n     * @return {boolean} true if excluded, false otherwise.\n     */\n    function isFileExcluded(file) {\n        if (file.name[0] === \".\") {\n            return true;\n        }\n\n        var languageID = LanguageManager.getLanguageForPath(file.fullPath).getId();\n        if (languageID !== HintUtils.LANGUAGE_ID) {\n            return true;\n        }\n\n        var excludes = preferences.getExcludedFiles();\n        if (excludes && excludes.test(file.name)) {\n            return true;\n        }\n\n        if (isFileExcludedInternal(file.fullPath)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Add a pending request waiting for the tern-module to complete.\n     * If file is a detected exclusion, then reject request.\n     *\n     * @param {string} file - the name of the file\n     * @param {{line: number, ch: number}} offset - the offset into the file the request is for\n     * @param {string} type - the type of request\n     * @return {jQuery.Promise} - the promise for the request\n     */\n    function addPendingRequest(file, offset, type) {\n        var requests,\n            key = file + \"@\" + offset.line + \"@\" + offset.ch,\n            $deferredRequest;\n\n        // Reject detected exclusions\n        if (isFileExcludedInternal(file)) {\n            return (new $.Deferred()).reject().promise();\n        }\n\n        if (_.has(pendingTernRequests, key)) {\n            requests = pendingTernRequests[key];\n        } else {\n            requests = {};\n            pendingTernRequests[key] = requests;\n        }\n\n        if (_.has(requests, type)) {\n            $deferredRequest = requests[type];\n        } else {\n            requests[type] = $deferredRequest = new $.Deferred();\n        }\n        return $deferredRequest.promise();\n    }\n\n    /**\n     * Get any pending $.Deferred object waiting on the specified file and request type\n     * @param {string} file - the file\n     * @param {{line: number, ch: number}} offset - the offset into the file the request is for\n     * @param {string} type - the type of request\n     * @return {jQuery.Deferred} - the $.Deferred for the request\n     */\n    function getPendingRequest(file, offset, type) {\n        var key = file + \"@\" + offset.line + \"@\" + offset.ch;\n        if (_.has(pendingTernRequests, key)) {\n            var requests = pendingTernRequests[key],\n                requestType = requests[type];\n\n            delete pendingTernRequests[key][type];\n\n            if (!Object.keys(requests).length) {\n                delete pendingTernRequests[key];\n            }\n\n            return requestType;\n        }\n    }\n\n    /**\n     * @param {string} file a relative path\n     * @return {string} returns the path we resolved when we tried to parse the file, or undefined\n     */\n    function getResolvedPath(file) {\n        return currentModule.getResolvedPath(file);\n    }\n\n    /**\n     * Get a Promise for the definition from TernJS, for the file & offset passed in.\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset - the offset in the file the hints should be calculate at\n     * @return {jQuery.Promise} - a promise that will resolve to definition when\n     *      it is done\n     */\n    function getJumptoDef(fileInfo, offset) {\n        postMessage({\n            type: MessageIds.TERN_JUMPTODEF_MSG,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return addPendingRequest(fileInfo.name, offset, MessageIds.TERN_JUMPTODEF_MSG);\n    }\n\n    /**\n     * check to see if the text we are sending to Tern is too long.\n     * @param {string} the text to check\n     * @return {string} the text, or the empty text if the original was too long\n     */\n    function filterText(text) {\n        var newText = text;\n        if (text.length > preferences.getMaxFileSize()) {\n            newText = \"\";\n        }\n        return newText;\n    }\n\n    /**\n     * Get the text of a document, applying any size restrictions\n     * if necessary\n     * @param {Document} document - the document to get the text from\n     * @return {string} the text, or the empty text if the original was too long\n     */\n    function getTextFromDocument(document) {\n        var text = document.getText();\n        text = filterText(text);\n        return text;\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the references\n     *\n     * @param response - the response from the node domain\n     */\n    function handleRename(response) {\n\n        if (response.error) {\n            EditorManager.getActiveEditor().displayErrorMessageAtCursor(response.error);\n            return;\n        }\n\n        var file = response.file,\n            offset = response.offset;\n\n        var $deferredFindRefs = getPendingRequest(file, offset, MessageIds.TERN_REFS);\n\n        if ($deferredFindRefs) {\n            $deferredFindRefs.resolveWith(null, [response]);\n        }\n    }\n\n    /**\n     * Request Jump-To-Definition from Tern.\n     *\n     * @param {session} session - the session\n     * @param {Document} document - the document\n     * @param {{line: number, ch: number}} offset - the offset into the document\n     * @return {jQuery.Promise} - The promise will not complete until tern\n     *      has completed.\n     */\n    function requestJumptoDef(session, document, offset) {\n        var path    = document.file.fullPath,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: filterText(session.getJavascriptText())\n            };\n\n        var ternPromise = getJumptoDef(fileInfo, offset);\n\n        return {promise: ternPromise};\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the definition\n     *\n     * @param response - the response from the node domain\n     */\n    function handleJumptoDef(response) {\n\n        var file = response.file,\n            offset = response.offset;\n\n        var $deferredJump = getPendingRequest(file, offset, MessageIds.TERN_JUMPTODEF_MSG);\n\n        if ($deferredJump) {\n            response.fullPath = getResolvedPath(response.resultFile);\n            $deferredJump.resolveWith(null, [response]);\n        }\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the scope data\n     *\n     * @param response - the response from the node domain\n     */\n    function handleScopeData(response) {\n        var file = response.file,\n            offset = response.offset;\n\n        var $deferredJump = getPendingRequest(file, offset, MessageIds.TERN_SCOPEDATA_MSG);\n\n        if ($deferredJump) {\n            $deferredJump.resolveWith(null, [response]);\n        }\n    }\n\n    /**\n     * Get a Promise for the completions from TernJS, for the file & offset passed in.\n     *\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}} offset - the offset in the file the hints should be calculate at\n     * @param {boolean} isProperty - true if getting a property hint,\n     * otherwise getting an identifier hint.\n     * @return {jQuery.Promise} - a promise that will resolve to an array of completions when\n     *      it is done\n     */\n    function getTernHints(fileInfo, offset, isProperty) {\n\n        /**\n         *  If the document is large and we have modified a small portions of it that\n         *  we are asking hints for, then send a partial document.\n         */\n        postMessage({\n            type: MessageIds.TERN_COMPLETIONS_MSG,\n            fileInfo: fileInfo,\n            offset: offset,\n            isProperty: isProperty\n        });\n\n        return addPendingRequest(fileInfo.name, offset, MessageIds.TERN_COMPLETIONS_MSG);\n    }\n\n    /**\n     * Get a Promise for the function type from TernJS.\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line:number, ch:number}} offset - the line, column info for what we want the function type of.\n     * @return {jQuery.Promise} - a promise that will resolve to the function type of the function being called.\n     */\n    function getTernFunctionType(fileInfo, offset) {\n        postMessage({\n            type: MessageIds.TERN_CALLED_FUNC_TYPE_MSG,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return addPendingRequest(fileInfo.name, offset, MessageIds.TERN_CALLED_FUNC_TYPE_MSG);\n    }\n\n\n    /**\n     *  Given a starting and ending position, get a code fragment that is self contained\n     *  enough to be compiled.\n     *\n     * @param {!Session} session - the current session\n     * @param {{line: number, ch: number}} start - the starting position of the changes\n     * @return {{type: string, name: string, offsetLines: number, text: string}}\n     */\n    function getFragmentAround(session, start) {\n        var minIndent = null,\n            minLine   = null,\n            endLine,\n            cm        = session.editor._codeMirror,\n            tabSize   = cm.getOption(\"tabSize\"),\n            document  = session.editor.document,\n            p,\n            min,\n            indent,\n            line;\n\n        // expand range backwards\n        for (p = start.line - 1, min = Math.max(0, p - 100); p >= min; --p) {\n            line = session.getLine(p);\n            var fn = line.search(/\\bfunction\\b/);\n\n            if (fn >= 0) {\n                indent = CodeMirror.countColumn(line, null, tabSize);\n                if (minIndent === null || minIndent > indent) {\n                    if (session.getToken({line: p, ch: fn + 1}).type === \"keyword\") {\n                        minIndent = indent;\n                        minLine = p;\n                    }\n                }\n            }\n        }\n\n        if (minIndent === null) {\n            minIndent = 0;\n        }\n\n        if (minLine === null) {\n            minLine = min;\n        }\n\n        var max = Math.min(cm.lastLine(), start.line + 100),\n            endCh = 0;\n\n        for (endLine = start.line + 1; endLine < max; ++endLine) {\n            line = cm.getLine(endLine);\n\n            if (line.length > 0) {\n                indent = CodeMirror.countColumn(line, null, tabSize);\n                if (indent <= minIndent) {\n                    endCh = line.length;\n                    break;\n                }\n            }\n        }\n\n        var from = {line: minLine, ch: 0},\n            to   = {line: endLine, ch: endCh};\n\n        return {type: MessageIds.TERN_FILE_INFO_TYPE_PART,\n            name: document.file.fullPath,\n            offsetLines: from.line,\n            text: document.getRange(from, to)};\n    }\n\n\n    /**\n     * Get an object that describes what tern needs to know about the updated\n     * file to produce a hint. As a side-effect of this calls the document\n     * changes are reset.\n     *\n     * @param {!Session} session - the current session\n     * @param {boolean=} preventPartialUpdates - if true, disallow partial updates.\n     * Optional, defaults to false.\n     * @return {{type: string, name: string, offsetLines: number, text: string}}\n     */\n    function getFileInfo(session, preventPartialUpdates) {\n        var start = session.getCursor(),\n            end = start,\n            document = session.editor.document,\n            path = document.file.fullPath,\n            isHtmlFile = LanguageManager.getLanguageForPath(path).getId() === \"html\",\n            result;\n\n        if (isHtmlFile) {\n            result = {type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                text: session.getJavascriptText()};\n        } else if (!documentChanges) {\n            result = {type: MessageIds.TERN_FILE_INFO_TYPE_EMPTY,\n                name: path,\n                text: \"\"};\n        } else if (!preventPartialUpdates && session.editor.lineCount() > LARGE_LINE_COUNT &&\n                (documentChanges.to - documentChanges.from < LARGE_LINE_CHANGE) &&\n                documentChanges.from <= start.line &&\n                documentChanges.to > end.line) {\n            result = getFragmentAround(session, start);\n        } else {\n            result = {type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                text: getTextFromDocument(document)};\n        }\n\n        documentChanges = null;\n        return result;\n    }\n\n    /**\n     *  Get the current offset. The offset is adjusted for \"part\" updates.\n     *\n     * @param {!Session} session - the current session\n     * @param {{type: string, name: string, offsetLines: number, text: string}} fileInfo\n     * - type of update, name of file, and the text of the update.\n     * For \"full\" updates, the whole text of the file is present. For \"part\" updates,\n     * the changed portion of the text. For \"empty\" updates, the file has not been modified\n     * and the text is empty.\n     * @param {{line: number, ch: number}=} offset - the default offset (optional). Will\n     * use the cursor if not provided.\n     * @return {{line: number, ch: number}}\n     */\n    function getOffset(session, fileInfo, offset) {\n        var newOffset;\n\n        if (offset) {\n            newOffset = {line: offset.line, ch: offset.ch};\n        } else {\n            newOffset = session.getCursor();\n        }\n\n        if (fileInfo.type === MessageIds.TERN_FILE_INFO_TYPE_PART) {\n            newOffset.line = Math.max(0, newOffset.line - fileInfo.offsetLines);\n        }\n\n        return newOffset;\n    }\n\n    /**\n     * Get a Promise for all of the known properties from TernJS, for the directory and file.\n     * The properties will be used as guesses in tern.\n     * @param {Session} session - the active hinting session\n     * @param {Document} document - the document for which scope info is\n     *      desired\n     * @return {jQuery.Promise} - The promise will not complete until the tern\n     *      request has completed.\n     */\n    function requestGuesses(session, document) {\n        var $deferred = $.Deferred(),\n            fileInfo = getFileInfo(session),\n            offset = getOffset(session, fileInfo);\n\n        postMessage({\n            type: MessageIds.TERN_GET_GUESSES_MSG,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        var promise = addPendingRequest(fileInfo.name, offset, MessageIds.TERN_GET_GUESSES_MSG);\n        promise.done(function (guesses) {\n            session.setGuesses(guesses);\n            $deferred.resolve();\n        }).fail(function () {\n            $deferred.reject();\n        });\n\n        return $deferred.promise();\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds with the list of completions\n     *\n     * @param {{file: string, offset: {line: number, ch: number}, completions:Array.<string>,\n     *          properties:Array.<string>}} response - the response from node domain\n     */\n    function handleTernCompletions(response) {\n\n        var file = response.file,\n            offset = response.offset,\n            completions = response.completions,\n            properties = response.properties,\n            fnType  = response.fnType,\n            type = response.type,\n            error = response.error,\n            $deferredHints = getPendingRequest(file, offset, type);\n\n        if ($deferredHints) {\n            if (error) {\n                $deferredHints.reject();\n            } else if (completions) {\n                $deferredHints.resolveWith(null, [{completions: completions}]);\n            } else if (properties) {\n                $deferredHints.resolveWith(null, [{properties: properties}]);\n            } else if (fnType) {\n                $deferredHints.resolveWith(null, [fnType]);\n            }\n        }\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds to the get guesses message.\n     *\n     * @param {{file: string, type: string, offset: {line: number, ch: number},\n     *      properties: Array.<string>}} response -\n     *      the response from node domain contains the guesses for a\n     *      property lookup.\n     */\n    function handleGetGuesses(response) {\n        var path = response.file,\n            type = response.type,\n            offset = response.offset,\n            $deferredHints = getPendingRequest(path, offset, type);\n\n        if ($deferredHints) {\n            $deferredHints.resolveWith(null, [response.properties]);\n        }\n    }\n\n    /**\n     * Handle the response from the tern node domain when\n     * it responds to the update file message.\n     *\n     * @param {{path: string, type: string}} response - the response from node domain\n     */\n    function handleUpdateFile(response) {\n\n        var path = response.path,\n            type = response.type,\n            $deferredHints = getPendingRequest(path, OFFSET_ZERO, type);\n\n        if ($deferredHints) {\n            $deferredHints.resolve();\n        }\n    }\n\n    /**\n     * Handle timed out inference\n     *\n     * @param {{path: string, type: string}} response - the response from node domain\n     */\n    function handleTimedOut(response) {\n\n        var detectedExclusions  = PreferencesManager.get(\"jscodehints.detectedExclusions\") || [],\n            filePath            = response.file;\n\n        // Don't exclude the file currently being edited\n        if (isFileBeingEdited(filePath)) {\n            return;\n        }\n\n        // Handle file that is already excluded\n        if (detectedExclusions.indexOf(filePath) !== -1) {\n            console.log(\"JavaScriptCodeHints.handleTimedOut: file already in detectedExclusions array timed out: \" + filePath);\n            return;\n        }\n\n        // Save detected exclusion in project prefs so no further time is wasted on it\n        detectedExclusions.push(filePath);\n        PreferencesManager.set(\"jscodehints.detectedExclusions\", detectedExclusions, { location: { scope: \"project\" } });\n\n        // Show informational dialog\n        Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_INFO,\n            Strings.DETECTED_EXCLUSION_TITLE,\n            StringUtils.format(\n                Strings.DETECTED_EXCLUSION_INFO,\n                StringUtils.breakableUrl(filePath)\n            ),\n            [\n                {\n                    className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\n                    id: Dialogs.DIALOG_BTN_OK,\n                    text: Strings.OK\n                }\n            ]\n        );\n    }\n\n    DocumentManager.on(\"dirtyFlagChange\", function (event, changedDoc) {\n        if (changedDoc.file.fullPath) {\n            postMessage({\n                type: MessageIds.TERN_UPDATE_DIRTY_FILE,\n                name: changedDoc.file.fullPath,\n                action: changedDoc.isDirty\n            });\n        }\n    });\n\n    // Clear dirty document list in tern node domain\n    ProjectManager.on(\"beforeProjectClose\", function () {\n        postMessage({\n            type: MessageIds.TERN_CLEAR_DIRTY_FILES_LIST\n        });\n    });\n\n    /**\n     * Encapsulate all the logic to talk to the tern module.  This will create\n     * a new instance of a TernModule, which the rest of the hinting code can use to talk\n     * to the tern node domain, without worrying about initialization, priming the pump, etc.\n     *\n     */\n    function TernModule() {\n        var ternPromise         = null,\n            addFilesPromise     = null,\n            rootTernDir         = null,\n            projectRoot         = null,\n            stopAddingFiles     = false,\n            resolvedFiles       = {},       // file -> resolved file\n            numInitialFiles     = 0,\n            numResolvedFiles    = 0,\n            numAddedFiles       = 0,\n            _ternNodeDomain     = null;\n\n        /**\n         * @param {string} file a relative path\n         * @return {string} returns the path we resolved when we tried to parse the file, or undefined\n         */\n        function getResolvedPath(file) {\n            return resolvedFiles[file];\n        }\n\n        /**\n         *  Determine whether the current set of files are using modules to pull in\n         *  additional files.\n         *\n         * @return {boolean} - true if more files than the current directory have\n         * been read in.\n         */\n        function usingModules() {\n            return numInitialFiles !== numResolvedFiles;\n        }\n\n        /**\n         * Send a message to the tern node domain - if the module is being initialized,\n         * the message will not be posted until initialization is complete\n         */\n        function postMessage(msg) {\n            addFilesPromise.done(function (ternModule) {\n                // If an error came up during file handling, bail out now\n                if (!_ternNodeDomain) {\n                    return;\n                }\n\n                if (config.debug) {\n                    console.debug(\"Sending message\", msg);\n                }\n                _ternNodeDomain.exec(\"invokeTernCommand\", msg);\n            });\n        }\n\n        /**\n         * Send a message to the tern node domain - this is only for messages that\n         * need to be sent before and while the addFilesPromise is being resolved.\n         */\n        function _postMessageByPass(msg) {\n            ternPromise.done(function (ternModule) {\n                if (config.debug) {\n                    console.debug(\"Sending message\", msg);\n                }\n                _ternNodeDomain.exec(\"invokeTernCommand\", msg);\n            });\n        }\n\n        /**\n         *  Update tern with the new contents of a given file.\n         *\n         * @param {Document} document - the document to update\n         * @return {jQuery.Promise} - the promise for the request\n         */\n        function updateTernFile(document) {\n            var path  = document.file.fullPath;\n\n            _postMessageByPass({\n                type: MessageIds.TERN_UPDATE_FILE_MSG,\n                path: path,\n                text: getTextFromDocument(document)\n            });\n\n            return addPendingRequest(path, OFFSET_ZERO, MessageIds.TERN_UPDATE_FILE_MSG);\n        }\n\n        /**\n         * Handle a request from the tern node domain for text of a file\n         *\n         * @param {{file:string}} request - the request from the tern node domain.  Should be an Object containing the name\n         *      of the file tern wants the contents of\n         */\n        function handleTernGetFile(request) {\n\n            function replyWith(name, txt) {\n                _postMessageByPass({\n                    type: MessageIds.TERN_GET_FILE_MSG,\n                    file: name,\n                    text: txt\n                });\n            }\n\n            var name = request.file;\n\n            /**\n             * Helper function to get the text of a given document and send it to tern.\n             * If DocumentManager successfully gets the file's text then we'll send it to the tern node domain.\n             * The Promise for getDocumentText() is returned so that custom fail functions can be used.\n             *\n             * @param {string} filePath - the path of the file to get the text of\n             * @return {jQuery.Promise} - the Promise returned from DocumentMangaer.getDocumentText()\n             */\n            function getDocText(filePath) {\n                if (!FileSystem.isAbsolutePath(filePath) || // don't handle URLs\n                        filePath.slice(0, 2) === \"//\") { // don't handle protocol-relative URLs like //example.com/main.js (see #10566)\n                    return (new $.Deferred()).reject().promise();\n                }\n\n                var file = FileSystem.getFileForPath(filePath),\n                    promise = DocumentManager.getDocumentText(file);\n\n                promise.done(function (docText) {\n                    resolvedFiles[name] = filePath;\n                    numResolvedFiles++;\n                    replyWith(name, filterText(docText));\n                });\n                return promise;\n            }\n\n            /**\n             * Helper function to find any files in the project that end with the\n             * name we are looking for.  This is so we can find requirejs modules\n             * when the baseUrl is unknown, or when the project root is not the same\n             * as the script root (e.g. if you open the 'brackets' dir instead of 'brackets/src' dir).\n             */\n            function findNameInProject() {\n                // check for any files in project that end with the right path.\n                var fileName = name.substring(name.lastIndexOf(\"/\") + 1);\n\n                function _fileFilter(entry) {\n                    return entry.name === fileName;\n                }\n\n                ProjectManager.getAllFiles(_fileFilter).done(function (files) {\n                    var file;\n                    files = files.filter(function (file) {\n                        var pos = file.fullPath.length - name.length;\n                        return pos === file.fullPath.lastIndexOf(name);\n                    });\n\n                    if (files.length === 1) {\n                        file = files[0];\n                    }\n                    if (file) {\n                        getDocText(file.fullPath).fail(function () {\n                            replyWith(name, \"\");\n                        });\n                    } else {\n                        replyWith(name, \"\");\n                    }\n                });\n            }\n\n            if (!isFileExcludedInternal(name)) {\n                getDocText(name).fail(function () {\n                    getDocText(rootTernDir + name).fail(function () {\n                        // check relative to project root\n                        getDocText(projectRoot + name)\n                            // last look for any files that end with the right path\n                            // in the project\n                            .fail(findNameInProject);\n                    });\n                });\n            }\n        }\n\n        /**\n         *  Prime the pump for a fast first lookup.\n         *\n         * @param {string} path - full path of file\n         * @return {jQuery.Promise} - the promise for the request\n         */\n        function primePump(path, isUntitledDoc) {\n            _postMessageByPass({\n                type: MessageIds.TERN_PRIME_PUMP_MSG,\n                path: path,\n                isUntitledDoc: isUntitledDoc\n            });\n\n            return addPendingRequest(path, OFFSET_ZERO, MessageIds.TERN_PRIME_PUMP_MSG);\n        }\n\n        /**\n         * Handle the response from the tern node domain when\n         * it responds to the prime pump message.\n         *\n         * @param {{path: string, type: string}} response - the response from node domain\n         */\n        function handlePrimePumpCompletion(response) {\n\n            var path = response.path,\n                type = response.type,\n                $deferredHints = getPendingRequest(path, OFFSET_ZERO, type);\n\n            if ($deferredHints) {\n                $deferredHints.resolve();\n            }\n        }\n\n        /**\n         *  Add new files to tern, keeping any previous files.\n         *  The tern server must be initialized before making\n         *  this call.\n         *\n         * @param {Array.<string>} files - array of file to add to tern.\n         * @return {boolean} - true if more files may be added, false if maximum has been reached.\n         */\n        function addFilesToTern(files) {\n            // limit the number of files added to tern.\n            var maxFileCount = preferences.getMaxFileCount();\n            if (numResolvedFiles + numAddedFiles < maxFileCount) {\n                var available = maxFileCount - numResolvedFiles - numAddedFiles;\n\n                if (available < files.length) {\n                    files = files.slice(0, available);\n                }\n\n                numAddedFiles += files.length;\n                ternPromise.done(function (ternModule) {\n                    var msg = {\n                        type: MessageIds.TERN_ADD_FILES_MSG,\n                        files: files\n                    };\n\n                    if (config.debug) {\n                        console.debug(\"Sending message\", msg);\n                    }\n                    _ternNodeDomain.exec(\"invokeTernCommand\", msg);\n                });\n\n            } else {\n                stopAddingFiles = true;\n            }\n\n            return stopAddingFiles;\n        }\n\n        /**\n         *  Add the files in the directory and subdirectories of a given directory\n         *  to tern.\n         *\n         * @param {string} dir - the root directory to add.\n         * @param {function ()} doneCallback - called when all files have been\n         * added to tern.\n         */\n        function addAllFilesAndSubdirectories(dir, doneCallback) {\n            FileSystem.resolve(dir, function (err, directory) {\n                function visitor(entry) {\n                    if (entry.isFile) {\n                        if (!isFileExcluded(entry)) { // ignore .dotfiles and non-.js files\n                            addFilesToTern([entry.fullPath]);\n                        }\n                    } else {\n                        return !isDirectoryExcluded(entry.fullPath) &&\n                            entry.name.indexOf(\".\") !== 0 &&\n                            !stopAddingFiles;\n                    }\n                }\n\n                if (err) {\n                    return;\n                }\n\n                if (dir === FileSystem.getDirectoryForPath(rootTernDir)) {\n                    doneCallback();\n                    return;\n                }\n\n                directory.visit(visitor, doneCallback);\n            });\n        }\n\n        /**\n         * Init the Tern module that does all the code hinting work.\n         */\n        function initTernModule() {\n            var moduleDeferred = $.Deferred();\n            ternPromise = moduleDeferred.promise();\n\n            function prepareTern() {\n                _ternNodeDomain.exec(\"setInterface\", {\n                    messageIds: MessageIds\n                });\n\n                _ternNodeDomain.exec(\"invokeTernCommand\", {\n                    type: MessageIds.SET_CONFIG,\n                    config: config\n                });\n                moduleDeferred.resolveWith(null, [_ternNodeDomain]);\n            }\n\n            if (_ternNodeDomain) {\n                _ternNodeDomain.exec(\"resetTernServer\");\n                moduleDeferred.resolveWith(null, [_ternNodeDomain]);\n            } else {\n                _ternNodeDomain     = new NodeDomain(\"TernNodeDomain\", _domainPath);\n                _ternNodeDomain.on(\"data\", function (evt, data) {\n                    if (config.debug) {\n                        console.log(\"Message received\", data.type);\n                    }\n\n                    var response = data,\n                        type = response.type;\n\n                    if (type === MessageIds.TERN_COMPLETIONS_MSG ||\n                            type === MessageIds.TERN_CALLED_FUNC_TYPE_MSG) {\n                        // handle any completions the tern server calculated\n                        handleTernCompletions(response);\n                    } else if (type === MessageIds.TERN_GET_FILE_MSG) {\n                        // handle a request for the contents of a file\n                        handleTernGetFile(response);\n                    } else if (type === MessageIds.TERN_JUMPTODEF_MSG) {\n                        handleJumptoDef(response);\n                    } else if (type === MessageIds.TERN_SCOPEDATA_MSG) {\n                        handleScopeData(response);\n                    } else if (type === MessageIds.TERN_REFS) {\n                        handleRename(response);\n                    } else if (type === MessageIds.TERN_PRIME_PUMP_MSG) {\n                        handlePrimePumpCompletion(response);\n                    } else if (type === MessageIds.TERN_GET_GUESSES_MSG) {\n                        handleGetGuesses(response);\n                    } else if (type === MessageIds.TERN_UPDATE_FILE_MSG) {\n                        handleUpdateFile(response);\n                    } else if (type === MessageIds.TERN_INFERENCE_TIMEDOUT) {\n                        handleTimedOut(response);\n                    } else if (type === MessageIds.TERN_WORKER_READY) {\n                        moduleDeferred.resolveWith(null, [_ternNodeDomain]);\n                    } else if (type === \"RE_INIT_TERN\") {\n                        // Ensure the request is because of a node restart\n                        if (currentModule) {\n                            prepareTern();\n                            // Mark the module with resetForced, then creation of TernModule will\n                            // happen again as part of '_maybeReset' call\n                            currentModule.resetForced = true;\n                        }\n                    } else {\n                        console.log(\"Tern Module: \" + (response.log || response));\n                    }\n                });\n\n                _ternNodeDomain.promise().done(prepareTern);\n            }\n        }\n\n        /**\n         * Create a new tern server.\n         */\n        function initTernServer(dir, files) {\n            initTernModule();\n            numResolvedFiles = 0;\n            numAddedFiles = 0;\n            stopAddingFiles = false;\n            numInitialFiles = files.length;\n\n            ternPromise.done(function (ternModule) {\n                var msg = {\n                    type: MessageIds.TERN_INIT_MSG,\n                    dir: dir,\n                    files: files,\n                    env: ternEnvironment,\n                    timeout: PreferencesManager.get(\"jscodehints.inferenceTimeout\")\n                };\n                _ternNodeDomain.exec(\"invokeTernCommand\", msg);\n            });\n            rootTernDir = dir + \"/\";\n        }\n\n        /**\n         *  We can skip tern initialization if we are opening a file that has\n         *  already been added to tern.\n         *\n         * @param {string} newFile - full path of new file being opened in the editor.\n         * @return {boolean} - true if tern initialization should be skipped,\n         * false otherwise.\n         */\n        function canSkipTernInitialization(newFile) {\n            return resolvedFiles[newFile] !== undefined;\n        }\n\n\n        /**\n         *  Do the work to initialize a code hinting session.\n         *\n         * @param {Session} session - the active hinting session (TODO: currently unused)\n         * @param {!Document} document - the document the editor has changed to\n         * @param {?Document} previousDocument - the document the editor has changed from\n         */\n        function doEditorChange(session, document, previousDocument) {\n            var file        = document.file,\n                path        = file.fullPath,\n                dir         = file.parentPath,\n                pr;\n\n            var addFilesDeferred = $.Deferred();\n\n            documentChanges = null;\n            addFilesPromise = addFilesDeferred.promise();\n            pr = ProjectManager.getProjectRoot() ? ProjectManager.getProjectRoot().fullPath : null;\n\n            // avoid re-initializing tern if possible.\n            if (canSkipTernInitialization(path)) {\n\n                // update the previous document in tern to prevent stale files.\n                if (isDocumentDirty && previousDocument) {\n                    var updateFilePromise = updateTernFile(previousDocument);\n                    updateFilePromise.done(function () {\n                        primePump(path, document.isUntitled());\n                        addFilesDeferred.resolveWith(null, [_ternNodeDomain]);\n                    });\n                } else {\n                    addFilesDeferred.resolveWith(null, [_ternNodeDomain]);\n                }\n\n                isDocumentDirty = false;\n                return;\n            }\n\n            if (previousDocument && previousDocument.isDirty) {\n                updateTernFile(previousDocument);\n            }\n\n            isDocumentDirty = false;\n            resolvedFiles = {};\n            projectRoot = pr;\n\n            ensurePreferences();\n            deferredPreferences.done(function () {\n                if (file instanceof InMemoryFile) {\n                    initTernServer(pr, []);\n                    var hintsPromise = primePump(path, true);\n                    hintsPromise.done(function () {\n                        addFilesDeferred.resolveWith(null, [_ternNodeDomain]);\n                    });\n                    return;\n                }\n\n                FileSystem.resolve(dir, function (err, directory) {\n                    if (err) {\n                        console.error(\"Error resolving\", dir);\n                        addFilesDeferred.resolveWith(null);\n                        return;\n                    }\n\n                    directory.getContents(function (err, contents) {\n                        if (err) {\n                            console.error(\"Error getting contents for\", directory);\n                            addFilesDeferred.resolveWith(null);\n                            return;\n                        }\n\n                        var files = contents\n                            .filter(function (entry) {\n                                return entry.isFile && !isFileExcluded(entry);\n                            })\n                            .map(function (entry) {\n                                return entry.fullPath;\n                            });\n\n                        initTernServer(dir, files);\n\n                        var hintsPromise = primePump(path, false);\n                        hintsPromise.done(function () {\n                            if (!usingModules()) {\n                                // Read the subdirectories of the new file's directory.\n                                // Read them first in case there are too many files to\n                                // read in the project.\n                                addAllFilesAndSubdirectories(dir, function () {\n                                    // If the file is in the project root, then read\n                                    // all the files under the project root.\n                                    var currentDir = (dir + \"/\");\n                                    if (projectRoot && currentDir !== projectRoot &&\n                                            currentDir.indexOf(projectRoot) === 0) {\n                                        addAllFilesAndSubdirectories(projectRoot, function () {\n                                            // prime the pump again but this time don't wait\n                                            // for completion.\n                                            primePump(path, false);\n                                            addFilesDeferred.resolveWith(null, [_ternNodeDomain]);\n                                        });\n                                    } else {\n                                        addFilesDeferred.resolveWith(null, [_ternNodeDomain]);\n                                    }\n                                });\n                            } else {\n                                addFilesDeferred.resolveWith(null, [_ternNodeDomain]);\n                            }\n                        });\n                    });\n                });\n            });\n        }\n\n        /**\n         * Called each time a new editor becomes active.\n         *\n         * @param {Session} session - the active hinting session (TODO: currently unused by doEditorChange())\n         * @param {!Document} document - the document of the editor that has changed\n         * @param {?Document} previousDocument - the document of the editor is changing from\n         */\n        function handleEditorChange(session, document, previousDocument) {\n            if (addFilesPromise === null) {\n                doEditorChange(session, document, previousDocument);\n            } else {\n                addFilesPromise.done(function () {\n                    doEditorChange(session, document, previousDocument);\n                });\n            }\n        }\n\n        /**\n         * Do some cleanup when a project is closed.\n         *\n         * We can clean up the node tern server we use to calculate hints now, since\n         * we know we will need to re-init it in any new project that is opened.\n         */\n        function resetModule() {\n            function resetTernServer() {\n                if (_ternNodeDomain.ready()) {\n                    _ternNodeDomain.exec('resetTernServer');\n                }\n            }\n\n            if (_ternNodeDomain) {\n                if (addFilesPromise) {\n                    // If we're in the middle of added files, don't reset\n                    // until we're done\n                    addFilesPromise.done(resetTernServer).fail(resetTernServer);\n                } else {\n                    resetTernServer();\n                }\n            }\n        }\n\n        function whenReady(func) {\n            addFilesPromise.done(func);\n        }\n\n        this.resetModule = resetModule;\n        this.handleEditorChange = handleEditorChange;\n        this.postMessage = postMessage;\n        this.getResolvedPath = getResolvedPath;\n        this.whenReady = whenReady;\n\n        return this;\n    }\n\n    var resettingDeferred = null;\n\n    /**\n     * reset the tern module, if necessary.\n     *\n     * During debugging, you can turn this automatic resetting behavior off\n     * by running this in the console:\n     * brackets._configureJSCodeHints({ noReset: true })\n     *\n     * This function is also used in unit testing with the \"force\" flag to\n     * reset the module for each test to start with a clean environment.\n     *\n     * @param {Session} session\n     * @param {Document} document\n     * @param {boolean} force true to force a reset regardless of how long since the last one\n     * @return {Promise} Promise resolved when the module is ready.\n     *                   The new (or current, if there was no reset) module is passed to the callback.\n     */\n    function _maybeReset(session, document, force) {\n        var newTernModule;\n        // if we're in the middle of a reset, don't have to check\n        // the new module will be online soon\n        if (!resettingDeferred) {\n\n            // We don't reset if the debugging flag is set\n            // because it's easier to debug if the module isn't\n            // getting reset all the time.\n            if (currentModule.resetForced || force || (!config.noReset && ++_hintCount > MAX_HINTS)) {\n                if (config.debug) {\n                    console.debug(\"Resetting tern module\");\n                }\n\n                resettingDeferred = new $.Deferred();\n                newTernModule = new TernModule();\n                newTernModule.handleEditorChange(session, document, null);\n                newTernModule.whenReady(function () {\n                    // reset the old module\n                    currentModule.resetModule();\n                    currentModule = newTernModule;\n                    resettingDeferred.resolve(currentModule);\n                    // all done reseting\n                    resettingDeferred = null;\n                });\n                _hintCount = 0;\n            } else {\n                var d = new $.Deferred();\n                d.resolve(currentModule);\n                return d.promise();\n            }\n        }\n\n        return resettingDeferred.promise();\n    }\n\n    /**\n     * Request a parameter hint from Tern.\n     *\n     * @param {Session} session - the active hinting session\n     * @param {{line: number, ch: number}} functionOffset - the offset of the function call.\n     * @return {jQuery.Promise} - The promise will not complete until the\n     *      hint has completed.\n     */\n    function requestParameterHint(session, functionOffset) {\n        var $deferredHints = $.Deferred(),\n            fileInfo = getFileInfo(session, true),\n            offset = getOffset(session, fileInfo, functionOffset),\n            fnTypePromise = getTernFunctionType(fileInfo, offset);\n\n        $.when(fnTypePromise).done(\n            function (fnType) {\n                session.setFnType(fnType);\n                session.setFunctionCallPos(functionOffset);\n                $deferredHints.resolveWith(null, [fnType]);\n            }\n        ).fail(function () {\n            $deferredHints.reject();\n        });\n\n        return $deferredHints.promise();\n    }\n\n    /**\n     * Request hints from Tern.\n     *\n     * Note that successive calls to getScope may return the same objects, so\n     * clients that wish to modify those objects (e.g., by annotating them based\n     * on some temporary context) should copy them first. See, e.g.,\n     * Session.getHints().\n     *\n     * @param {Session} session - the active hinting session\n     * @param {Document} document - the document for which scope info is\n     *      desired\n     * @return {jQuery.Promise} - The promise will not complete until the tern\n     *      hints have completed.\n     */\n    function requestHints(session, document) {\n        var $deferredHints = $.Deferred(),\n            hintPromise,\n            sessionType = session.getType(),\n            fileInfo = getFileInfo(session),\n            offset = getOffset(session, fileInfo, null);\n\n        _maybeReset(session, document);\n\n        hintPromise = getTernHints(fileInfo, offset, sessionType.property);\n\n        $.when(hintPromise).done(\n            function (completions, fnType) {\n                if (completions.completions) {\n                    session.setTernHints(completions.completions);\n                    session.setGuesses(null);\n                } else {\n                    session.setTernHints([]);\n                    session.setGuesses(completions.properties);\n                }\n\n                $deferredHints.resolveWith(null);\n            }\n        ).fail(function () {\n            $deferredHints.reject();\n        });\n\n        return $deferredHints.promise();\n    }\n\n    /**\n     *  Track the update area of the current document so we can tell if we can send\n     *  partial updates to tern or not.\n     *\n     * @param {Array.<{from: {line:number, ch: number}, to: {line:number, ch: number},\n     *     text: Array<string>}>} changeList - the document changes from the current change event\n     */\n    function trackChange(changeList) {\n        var changed = documentChanges, i;\n        if (changed === null) {\n            documentChanges = changed = {from: changeList[0].from.line, to: changeList[0].from.line};\n            if (config.debug) {\n                console.debug(\"ScopeManager: document has changed\");\n            }\n        }\n\n        for (i = 0; i < changeList.length; i++) {\n            var thisChange = changeList[i],\n                end = thisChange.from.line + (thisChange.text.length - 1);\n            if (thisChange.from.line < changed.to) {\n                changed.to = changed.to - (thisChange.to.line - end);\n            }\n\n            if (end >= changed.to) {\n                changed.to = end + 1;\n            }\n\n            if (changed.from > thisChange.from.line) {\n                changed.from = thisChange.from.line;\n            }\n        }\n    }\n\n    /*\n     * Called each time the file associated with the active editor changes.\n     * Marks the file as being dirty.\n     *\n     * @param {from: {line:number, ch: number}, to: {line:number, ch: number}}\n     */\n    function handleFileChange(changeList) {\n        isDocumentDirty = true;\n        trackChange(changeList);\n    }\n\n    /**\n     * Called each time a new editor becomes active.\n     *\n     * @param {Session} session - the active hinting session\n     * @param {Document} document - the document of the editor that has changed\n     * @param {?Document} previousDocument - the document of the editor is changing from\n     */\n    function handleEditorChange(session, document, previousDocument) {\n\n        if (!currentModule) {\n            currentModule = new TernModule();\n        }\n\n        return currentModule.handleEditorChange(session, document, previousDocument);\n    }\n\n    /**\n     * Do some cleanup when a project is closed.\n     * Clean up previous analysis data from the module\n     */\n    function handleProjectClose() {\n        if (currentModule) {\n            currentModule.resetModule();\n        }\n    }\n\n    /**\n     *  Read in project preferences when a new project is opened.\n     *  Look in the project root directory for a preference file.\n     *\n     *  @param {string=} projectRootPath - new project root path(optional).\n     *  Only needed for unit tests.\n     */\n    function handleProjectOpen(projectRootPath) {\n        initPreferences(projectRootPath);\n    }\n\n    /** Used to avoid timing bugs in unit tests */\n    function _readyPromise() {\n        return deferredPreferences;\n    }\n\n    /**\n     * @private\n     *\n     * Update the configuration in the tern node domain.\n     */\n    function _setConfig(configUpdate) {\n        config = brackets._configureJSCodeHints.config;\n        postMessage({\n            type: MessageIds.SET_CONFIG,\n            config: configUpdate\n        });\n    }\n\n    exports._setConfig = _setConfig;\n    exports._maybeReset = _maybeReset;\n    exports.getBuiltins = getBuiltins;\n    exports.getResolvedPath = getResolvedPath;\n    exports.getTernHints = getTernHints;\n    exports.handleEditorChange = handleEditorChange;\n    exports.requestGuesses = requestGuesses;\n    exports.handleFileChange = handleFileChange;\n    exports.requestHints = requestHints;\n    exports.requestJumptoDef = requestJumptoDef;\n    exports.requestParameterHint = requestParameterHint;\n    exports.handleProjectClose = handleProjectClose;\n    exports.handleProjectOpen = handleProjectOpen;\n    exports._readyPromise = _readyPromise;\n    exports.filterText = filterText;\n    exports.postMessage = postMessage;\n    exports.addPendingRequest = addPendingRequest;\n});\n"],"file":"ScopeManager.js"}
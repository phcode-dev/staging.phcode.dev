{"version":3,"sources":["features/QuickViewManager.js"],"names":["define","require","exports","module","CommandManager","Commands","EditorManager","Menus","PreferencesManager","Strings","ViewUtils","AppInit","ProviderRegistrationHandler","RegistrationHandler","previewContainerHTML","_providerRegistrationHandler","registerQuickViewProvider","registerProvider","bind","removeQuickViewProvider","removeProvider","_getQuickViewProviders","editor","quickViewProviders","language","getLanguageForSelection","enabledProviders","getProvidersForLanguageId","getId","item","push","provider","enabled","prefs","$previewContainer","$previewContent","_currentMousePos","animationRequest","CMD_ENABLE_QUICK_VIEW","QUICK_VIEW_EDITOR_MARKER","HOVER_DELAY","POINTER_HEIGHT","POPOVER_HORZ_MARGIN","getExtensionPrefs","definePreference","description","DESCRIPTION_QUICK_VIEW_ENABLED","popoverState","hidePreview","visible","marker","clear","empty","hide","removeClass","showPreviewQueued","mouseInPreviewContainer","window","clearTimeout","hoverTimer","positionPreview","xpos","ypos","ybot","find","is","previewWidth","outerWidth","top","outerHeight","left","elementRect","height","width","clip","getElementClipSize","$","getRootElement","right","addClass","css","_isResultBeforePopoverStart","popover","result","start","indexFromPos","_isResultAfterPopoverEnd","end","_createPopoverState","popoverResults","length","content","append","startCoord","charCoords","endCoord","ytop","bottom","async","queryPreviewProviders","pos","token","line","document","getLine","providers","popovers","providerPromises","getQuickView","results","Promise","allSettled","status","value","_renderPreview","markText","className","$popoverContent","show","addEventListener","showPreview","getHoveredEditor","coordsChar","clientX","clientY","ch","getToken","_isMouseFarFromPopup","previewRect","getBoundingClientRect","docRect","thresholdPercent","_isDistanceExceedThreshold","smaller","larger","total","threshold","x","y","processMouseMove","posWithinRange","setTimeout","handleMouseMove","event","buttons","requestAnimationFrame","onActiveEditorChange","current","previous","off","on","updateMenuItemCheckmark","get","setChecked","mouseOut","_evt","contains","toElement","_mouseEnteredPreviewContainer","_mouseExitedPreviewContainer","setEnabled","_enabled","doNotSave","editorHolder","previewContainer","getActiveEditor","removeEventListener","set","save","toggleEnableQuickView","_forceShow","Math","floor","appReady","appendTo","register","getMenu","AppMenuBar","VIEW_MENU","addMenuItem","AFTER","VIEW_TOGGLE_INSPECTION","_queryPreviewProviders"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * QuickViewManager provides support to add interactive preview popups on hover over the main editors.\n * Extensions can register to provide previews with `QuickViewManager.registerQuickViewProvider` API.\n * ![quick-view-image.png](generatedDocs/images/quick-view-image.png)\n * ![quick-view-youtube.png](generatedDocs/images/quick-view-youtube.png)\n *\n *\n * ## Usage\n * Lets build a \"hello world\" extension that displays \"hello world\" on hover over a text in the editor.\n * In your extension file, add the following code:\n * ```js\n * const QuickViewManager = brackets.getModule(\"features/QuickViewManager\");\n * // replace `all` with language ID(Eg. javascript) if you want to restrict the preview to js files only.\n * QuickViewManager.registerQuickViewProvider(exports, [\"all\"]);\n *\n * // now implement the getQuickView function that will be invoked when ever user hovers over a text in the editor.\n * exports.getQuickView = function(editor, pos, token, line) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 start: {line: pos.line, ch:token.start},\n *                 end: {line: pos.line, ch:token.end},\n *                 content: \"<div>hello world</div>\"\n *             });\n *         });\n *     };\n * ```\n *\n * ### How it works\n * When QuickViewManager determines that the user intents to see QuickView on hover, `getQuickView` function on all\n * registered QuickView providers are invoked to get the quick view popup. `getQuickView` should return a promise\n * that resolves to the popup contents if the provider has a quick view. Else just reject the promise. If multiple\n * providers returns QuickView, all of them are displayed one by one. See detailed API docs for implementation\n * details below:\n *\n * ## API\n * ### registerQuickViewProvider\n * Register a QuickView provider with this api.\n *\n * ```js\n * // syntax\n * QuickViewManager.registerQuickViewProvider(provider, supportedLanguages);\n * ```\n * The API requires three parameters:\n * 1. `provider`: must implement a  `getQuickView` function which will be invoked to get the preview. See API doc below.\n * 1. `supportedLanguages`: An array of languages that the QuickView supports. If `[\"all\"]` is supplied, then the\n *    QuickView will be invoked for all languages. Restrict to specific languages: Eg: `[\"javascript\", \"html\", \"php\"]`\n *\n * ```js\n * // to register a provider that will be invoked for all languages. where provider is any object that implements\n * // a getQuickView function\n * QuickViewManager.registerQuickViewProvider(provider, [\"all\"]);\n *\n * // to register a provider that will be invoked for specific languages\n * QuickViewManager.registerQuickViewProvider(provider, [\"javascript\", \"html\", \"php\"]);\n * ```\n *\n * ### removeQuickViewProvider\n * Removes a registered code hint provider. The API takes the same arguments as `registerQuickViewProvider`.\n * ```js\n * // syntax\n * QuickViewManager.removeQuickViewProvider(provider, supportedLanguages);\n * // Example\n * QuickViewManager.removeQuickViewProvider(provider, [\"javascript\", \"html\"]);\n * ```\n *\n * ### getQuickView\n * Each provider must implement the `getQuickView` function that returns a promise. The promise either resolves with\n * the quick view details object(described below) or rejects if there is no preview for the position.\n * ```js\n * // function signature\n * provider.getQuickView = function(editor, pos, token, line) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 start: {line: pos.line, ch:token.start},\n *                 end: {line: pos.line, ch:token.end},\n *                 content: \"<div>hello world</div>\"\n *             });\n *         });\n *     };\n * ```\n *\n * #### parameters\n * The function will be called with the following arguments:\n * 1. `editor` - The editor over which the user hovers the mouse cursor.\n * 1. `pos` - the cursor position over which the user hovers.\n * 1. `token` - hovered token details\n * 1. `line` - the full line text as string.\n *\n * #### return types\n * The promise returned should resolve with the following contents:\n * 1. `start` : Indicates the start cursor position from which the quick view is valid.\n * 1. `end` : Indicates the end cursor position to which the quick view is valid. These are generally used to highlight\n *    the hovered section of the text in the editor.\n * 1. `content`: Either `HTML` as text, a `DOM Node` or a `Jquery Element`.\n *\n * #### Considerations\n * 1. QuickView won't be displayed till all provider promises are settled. To improve performance, if your QuickView\n *    handler takes time to resolve the QuickView, resolve a dummy quick once you are sure that a QuickView needs\n *    to be shown to the user. The div contents can be later updated as and when more details are available.\n * 1. Note that the QuickView could be hidden/removed any time by the QuickViewManager.\n * 1. If multiple providers returns a valid popup, all of them are displayed.\n *\n * @module features/QuickViewManager\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Brackets modules\n    const CommandManager    = require(\"command/CommandManager\"),\n        Commands            = require(\"command/Commands\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        Menus               = require(\"command/Menus\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        Strings             = require(\"strings\"),\n        ViewUtils           = require(\"utils/ViewUtils\"),\n        AppInit             = require(\"utils/AppInit\"),\n        ProviderRegistrationHandler = require(\"features/PriorityBasedRegistration\").RegistrationHandler;\n\n    const previewContainerHTML       = '<div id=\"quick-view-container\">\\n' +\n        '    <div class=\"preview-content\">\\n' +\n        '    </div>\\n' +\n        '</div>';\n\n    const _providerRegistrationHandler = new ProviderRegistrationHandler(),\n        registerQuickViewProvider = _providerRegistrationHandler.registerProvider.bind(_providerRegistrationHandler),\n        removeQuickViewProvider = _providerRegistrationHandler.removeProvider.bind(_providerRegistrationHandler);\n\n    function _getQuickViewProviders(editor) {\n        let quickViewProviders = [];\n        let language = editor.getLanguageForSelection(),\n            enabledProviders = _providerRegistrationHandler.getProvidersForLanguageId(language.getId());\n\n        for(let item of enabledProviders){\n            quickViewProviders.push(item.provider);\n        }\n        return quickViewProviders;\n    }\n\n    let enabled,                             // Only show preview if true\n        prefs                      = null,   // Preferences\n        $previewContainer,                   // Preview container\n        $previewContent,                     // Preview content holder\n        _currentMousePos,\n        animationRequest;\n\n    // Constants\n    const CMD_ENABLE_QUICK_VIEW       = \"view.enableQuickView\",\n        QUICK_VIEW_EDITOR_MARKER = 'quickViewMark',\n        // Time (ms) mouse must remain over a provider's matched text before popover appears\n        HOVER_DELAY                 = 500,\n        // Pointer height, used to shift popover above pointer (plus a little bit of space)\n        POINTER_HEIGHT              = 10,\n        POPOVER_HORZ_MARGIN         =  5;   // Horizontal margin\n\n    prefs = PreferencesManager.getExtensionPrefs(\"quickview\");\n    prefs.definePreference(\"enabled\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_QUICK_VIEW_ENABLED\n    });\n\n    /**\n     * There are three states for this var:getToken\n     * 1. If null, there is no provider result for the given mouse position.\n     * 2. If non-null, and visible==true, there is a popover currently showing.\n     * 3. If non-null, but visible==false, we're waiting for HOVER_DELAY, which\n     *    is tracked by hoverTimer. The state changes to visible==true as soon as\n     *    there is a provider. If the mouse moves before then, timer is restarted.\n     *\n     * @type {{\n     *      visible: boolean,\n     *      editor: !Editor,\n     *      hoverTimer: number,             - setTimeout() token\n     *      start: !{line, ch},             - start of matched text range\n     *      end: !{line, ch},               - end of matched text range\n     *      content: !string,               - HTML content to display in popover\n     *      onShow: ?function():void,       - called once popover content added to the DOM (may never be called)\n     *        - if specified, must call positionPreview()\n     *      xpos: number,                   - x of center of popover\n     *      ytop: number,                   - y of top of matched text (when popover placed above text, normally)\n     *      ybot: number,                   - y of bottom of matched text (when popover moved below text, avoiding window top)\n     *      marker: ?CodeMirror.TextMarker  - only set once visible==true\n     * }}\n     * @private\n     */\n    let popoverState = null;\n\n\n\n    // Popover widget management ----------------------------------------------\n\n    /**\n     * Cancels whatever popoverState was currently pending and sets it back to null. If the popover was visible,\n     * hides it; if the popover was invisible and still pending, cancels hoverTimer so it will never be shown.\n     * @private\n     */\n    function hidePreview() {\n        if (!popoverState) {\n            return;\n        }\n\n        if (popoverState.visible) {\n            popoverState.marker.clear();\n\n            $previewContent.empty();\n            $previewContainer.hide();\n            $previewContainer.removeClass(\"active\");\n        } else {\n            showPreviewQueued = false;\n            mouseInPreviewContainer = false;\n            window.clearTimeout(popoverState.hoverTimer);\n        }\n        popoverState = null;\n    }\n\n    function positionPreview(editor, xpos, ypos, ybot) {\n        if ($previewContent.find(\"#quick-view-popover-root\").is(':empty')){\n            hidePreview();\n            return;\n        }\n        let previewWidth  = $previewContainer.outerWidth(),\n            top           = ypos - $previewContainer.outerHeight() - POINTER_HEIGHT,\n            left          = xpos - previewWidth / 2,\n            elementRect = {\n                top: top,\n                left: left - POPOVER_HORZ_MARGIN,\n                height: $previewContainer.outerHeight() + POINTER_HEIGHT,\n                width: previewWidth + 2 * POPOVER_HORZ_MARGIN\n            },\n            clip = ViewUtils.getElementClipSize($(editor.getRootElement()), elementRect);\n\n        // Prevent horizontal clipping\n        if (clip.left > 0) {\n            left += clip.left;\n        } else if (clip.right > 0) {\n            left -= clip.right;\n        }\n\n        // If clipped on top, flip popover below line\n        if (clip.top > 0) {\n            top = ybot + POINTER_HEIGHT;\n            $previewContainer\n                .removeClass(\"preview-bubble-above\")\n                .addClass(\"preview-bubble-below\");\n        } else {\n            $previewContainer\n                .removeClass(\"preview-bubble-below\")\n                .addClass(\"preview-bubble-above\");\n        }\n\n        $previewContainer\n            .css({\n                left: left,\n                top: top\n            })\n            .addClass(\"active\");\n    }\n\n    // Preview hide/show logic ------------------------------------------------\n\n    function _isResultBeforePopoverStart(editor, popover, result){\n        if(!popover.start){\n            return true;\n        }\n        return editor.indexFromPos(result.start) < editor.indexFromPos(popover.start);\n    }\n\n    function _isResultAfterPopoverEnd(editor, popover, result){\n        if(!popover.end){\n            return true;\n        }\n        return editor.indexFromPos(popover.start) > editor.indexFromPos(result.end);\n    }\n\n    function _createPopoverState(editor, popoverResults) {\n        if (popoverResults && popoverResults.length) {\n            let popover = {\n                content: $(\"<div id='quick-view-popover-root'></div>\")\n            };\n            // Each provider return popover { start, end, content}\n            for(let result of popoverResults){\n                if(_isResultBeforePopoverStart(editor, popover, result)){\n                    popover.start = result.start;\n                }\n                if(_isResultAfterPopoverEnd(editor, popover, result)){\n                    popover.end = result.end;\n                }\n                popover.content.append(result.content);\n            }\n\n            let startCoord = editor.charCoords(popover.start),\n                endCoord = editor.charCoords(popover.end);\n            popover.xpos = (endCoord.left - startCoord.left) / 2 + startCoord.left;\n            if(endCoord.left<startCoord.left){\n                // this probably spans multiple lines, just show at start cursor position\n                popover.xpos = startCoord.left;\n            }\n            popover.ytop = startCoord.top;\n            popover.ybot = startCoord.bottom;\n            popover.visible = false;\n            popover.editor  = editor;\n            return popover;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns a 'ready for use' popover state object:\n     * { visible: false, editor, start, end, content, ?onShow, xpos, ytop, ybot }\n     * Lacks only hoverTimer (supplied by handleMouseMove()) and marker (supplied by showPreview()).\n     * @private\n     */\n    async function queryPreviewProviders(editor, pos, token) {\n        let line = editor.document.getLine(pos.line);\n        let providers = _getQuickViewProviders(editor);\n        let popovers = [], providerPromises = [];\n        for(let provider of providers){\n            providerPromises.push(provider.getQuickView(editor, pos, token, line));\n        }\n        let results = await Promise.allSettled(providerPromises);\n        for(let result of results){\n            if(result.status === \"fulfilled\" && result.value){\n                popovers.push(result.value);\n            }\n        }\n\n        return _createPopoverState(editor, popovers);\n    }\n\n    /**\n     * Changes the current hidden popoverState to visible, showing it in the UI and highlighting\n     * its matching text in the editor.\n     * @private\n     */\n    function _renderPreview(editor) {\n        if (popoverState && popoverState.start && popoverState.end) {\n            popoverState.marker = editor.markText(\n                QUICK_VIEW_EDITOR_MARKER,\n                popoverState.start,\n                popoverState.end,\n                {className: \"quick-view-highlight\"}\n            );\n\n            let $popoverContent = $(popoverState.content);\n            $previewContent.append($popoverContent);\n            $previewContainer.show();\n            popoverState.visible = true;\n            positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n\n            $popoverContent[0].addEventListener('DOMSubtreeModified', ()=>{\n                positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n            }, false);\n        }\n    }\n\n    async function showPreview(editor) {\n        let token;\n\n        // Figure out which editor we are over\n        if (!editor) {\n            editor = EditorManager.getHoveredEditor(_currentMousePos);\n        }\n\n        if (!editor) {\n            hidePreview();\n            return;\n        }\n\n        // Find char mouse is over\n        let pos = editor.coordsChar({left: _currentMousePos.clientX, top: _currentMousePos.clientY});\n\n        // No preview if mouse is past last char on line\n        if (pos.ch >= editor.document.getLine(pos.line).length) {\n            return;\n        }\n\n        // Query providers and append to popoverState\n        token = editor.getToken(pos);\n        popoverState = await queryPreviewProviders(editor, pos, token);\n        _renderPreview(editor);\n    }\n\n    function _isMouseFarFromPopup() {\n        const previewRect = $previewContainer[0].getBoundingClientRect();\n        const docRect = {\n            height: $(document).height(),\n            width: $(document).width()\n        };\n        const thresholdPercent = 5;\n        function _isDistanceExceedThreshold(smaller, larger, total, threshold) {\n            return ((larger - smaller)/total)*100 > threshold;\n        }\n        let x= _currentMousePos.clientX, y=_currentMousePos.clientY;\n        if((x<previewRect.left && _isDistanceExceedThreshold(x, previewRect.left, docRect.width, thresholdPercent))\n            ||(x>previewRect.right && _isDistanceExceedThreshold(previewRect.right, x, docRect.width, thresholdPercent))\n            ||(y<previewRect.top && _isDistanceExceedThreshold(y, previewRect.top, docRect.height, thresholdPercent))\n            ||(y>previewRect.bottom && _isDistanceExceedThreshold(previewRect.bottom, y, docRect.height, thresholdPercent))){\n            return true;\n        }\n        return false;\n    }\n\n    let showPreviewQueued = false;\n\n    function processMouseMove() {\n        animationRequest = null;\n\n        if (mouseInPreviewContainer) {\n            return;\n        }\n\n        let editor = null;\n\n        if (popoverState && popoverState.visible) {\n            // Only figure out which editor we are over when there is already a popover\n            // showing (otherwise wait until after delay to minimize processing)\n            editor = EditorManager.getHoveredEditor(_currentMousePos);\n            if (editor) {\n                // Find char mouse is over\n                let pos = editor.coordsChar({left: _currentMousePos.clientX, top: _currentMousePos.clientY});\n                if (popoverState.start && popoverState.end &&\n                        editor.posWithinRange(pos, popoverState.start, popoverState.end, true) &&\n                        (pos.ch < editor.document.getLine(pos.line).length)) {\n\n                    // That one's still relevant - nothing more to do\n                    // Note: posWithinRange() includes mouse past end of line, so need to check for that case\n                    return;\n                }\n                if(_isMouseFarFromPopup()){\n                    hidePreview();\n                    return;\n                }\n            }\n        }\n\n        if(!showPreviewQueued){\n            // Initialize popoverState\n            showPreviewQueued = true;\n            popoverState = popoverState || {};\n\n            // Set timer to scan and show. This will get cancelled (in hidePreview())\n            // if mouse movement rendered this popover inapplicable before timer fires.\n            // When showing \"immediately\", still use setTimeout() to make this async\n            // so we return from this mousemove event handler ASAP.\n            popoverState.hoverTimer = window.setTimeout(function () {\n                showPreviewQueued = false;\n                if(!mouseInPreviewContainer){\n                    hidePreview();\n                    popoverState = {};\n                    showPreview(editor);\n                }\n            }, HOVER_DELAY);\n        }\n    }\n\n    function handleMouseMove(event) {\n        // Keep track of mouse position\n        _currentMousePos = {\n            clientX: event.clientX,\n            clientY: event.clientY\n        };\n\n        if (!enabled) {\n            return;\n        }\n\n        if (event.buttons !== 0) {\n            // Button is down - don't show popovers while dragging\n            hidePreview();\n            return;\n        }\n\n        // Prevent duplicate animation frame requests\n        if (!animationRequest) {\n            animationRequest = window.requestAnimationFrame(processMouseMove);\n        }\n    }\n\n    function onActiveEditorChange(event, current, previous) {\n        // Hide preview when editor changes\n        hidePreview();\n\n        if (previous && previous.document) {\n            previous.document.off(\"change\", hidePreview);\n        }\n\n        if (current && current.document) {\n            current.document.on(\"change\", hidePreview);\n        }\n    }\n\n    // Menu command handlers\n    function updateMenuItemCheckmark() {\n        CommandManager.get(CMD_ENABLE_QUICK_VIEW).setChecked(enabled);\n    }\n\n    let mouseInPreviewContainer = false;\n    function mouseOut(_evt) {\n        setTimeout(()=>{\n            if(mouseInPreviewContainer || $previewContainer[0].contains(_evt.toElement)){\n                return;\n            }\n            hidePreview();\n        }, HOVER_DELAY);\n    }\n\n    function _mouseEnteredPreviewContainer() {\n        mouseInPreviewContainer = true;\n    }\n\n    function _mouseExitedPreviewContainer() {\n        mouseInPreviewContainer = false;\n    }\n\n    function setEnabled(_enabled, doNotSave) {\n        if (enabled !== _enabled) {\n            enabled = _enabled;\n            let editorHolder = $(\"#editor-holder\")[0];\n            let previewContainer = $previewContainer[0];\n            if (enabled) {\n                // Note: listening to \"scroll\" also catches text edits, which bubble a scroll\n                // event up from the hidden text area. This means\n                // we auto-hide on text edit, which is probably actually a good thing.\n                editorHolder.addEventListener(\"mousemove\", handleMouseMove, true);\n                editorHolder.addEventListener(\"scroll\", hidePreview, true);\n                editorHolder.addEventListener(\"mouseout\", mouseOut, true);\n                previewContainer.addEventListener(\"mouseover\", _mouseEnteredPreviewContainer, true);\n                previewContainer.addEventListener(\"mouseout\", _mouseExitedPreviewContainer, true);\n\n                // Setup doc \"change\" listener\n                onActiveEditorChange(null, EditorManager.getActiveEditor(), null);\n                EditorManager.on(\"activeEditorChange\", onActiveEditorChange);\n\n            } else {\n                editorHolder.removeEventListener(\"mousemove\", handleMouseMove, true);\n                editorHolder.removeEventListener(\"scroll\", hidePreview, true);\n                editorHolder.removeEventListener(\"mouseout\", mouseOut, true);\n                previewContainer.removeEventListener(\"mouseover\", _mouseEnteredPreviewContainer, true);\n                previewContainer.removeEventListener(\"mouseout\", _mouseExitedPreviewContainer, true);\n\n\n                // Cleanup doc \"change\" listener\n                onActiveEditorChange(null, null, EditorManager.getActiveEditor());\n                EditorManager.off(\"activeEditorChange\", onActiveEditorChange);\n\n                hidePreview();\n            }\n            if (!doNotSave) {\n                prefs.set(\"enabled\", enabled);\n                prefs.save();\n            }\n        }\n        // Always update the checkmark, even if the enabled flag hasn't changed.\n        updateMenuItemCheckmark();\n    }\n\n    function toggleEnableQuickView() {\n        setEnabled(!enabled);\n    }\n\n    function _forceShow(popover) {\n        hidePreview();\n        _currentMousePos = {\n            clientX: popover.xpos,\n            clientY: Math.floor((popover.ybot + popover.ytop) / 2)\n        };\n        popoverState = popover;\n        _renderPreview(popover.editor);\n    }\n\n    AppInit.appReady(function () {\n        // Create the preview container\n        $previewContainer = $(previewContainerHTML).appendTo($(\"body\"));\n        $previewContent = $previewContainer.find(\".preview-content\");\n\n        // Register command\n        // Insert menu at specific pos since this may load before OR after code folding extension\n        CommandManager.register(Strings.CMD_ENABLE_QUICK_VIEW, CMD_ENABLE_QUICK_VIEW, toggleEnableQuickView);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(\n            CMD_ENABLE_QUICK_VIEW, null, Menus.AFTER, Commands.VIEW_TOGGLE_INSPECTION);\n\n        // Setup initial UI state\n        setEnabled(prefs.get(\"enabled\"), true);\n\n        prefs.on(\"change\", \"enabled\", function () {\n            setEnabled(prefs.get(\"enabled\"), true);\n        });\n    });\n\n    // For unit testing\n    exports._queryPreviewProviders  = queryPreviewProviders;\n    exports._forceShow              = _forceShow;\n\n    exports.registerQuickViewProvider = registerQuickViewProvider;\n    exports.removeQuickViewProvider   = removeQuickViewProvider;\n});\n"],"file":"QuickViewManager.js"}
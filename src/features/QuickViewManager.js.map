{"version":3,"sources":["features/QuickViewManager.js"],"names":["define","require","exports","module","CommandManager","Commands","EditorManager","Menus","PreferencesManager","Strings","ViewUtils","AppInit","WorkspaceManager","ProviderRegistrationHandler","RegistrationHandler","previewContainerHTML","_providerRegistrationHandler","registerQuickViewProvider","registerProvider","bind","removeQuickViewProvider","removeProvider","_getQuickViewProviders","editor","quickViewProviders","language","getLanguageForSelection","enabledProviders","getProvidersForLanguageId","getId","item","push","provider","enabled","prefs","$previewContainer","$previewContent","_currentMousePos","animationRequest","CMD_ENABLE_QUICK_VIEW","QUICK_VIEW_EDITOR_MARKER","HOVER_DELAY","POINTER_HEIGHT","POPOVER_HORZ_MARGIN","getExtensionPrefs","definePreference","description","DESCRIPTION_QUICK_VIEW_ENABLED","popoverState","hidePreview","visible","marker","clear","empty","hide","removeClass","getActiveEditor","focus","showPreviewQueued","mouseInPreviewContainer","window","clearTimeout","hoverTimer","positionPreview","xpos","ypos","ybot","find","is","previewWidth","outerWidth","top","outerHeight","left","elementRect","height","width","clip","getElementClipSize","$","getRootElement","right","addClass","css","_isResultBeforePopoverStart","popover","result","start","indexFromPos","_isResultAfterPopoverEnd","end","_createPopoverState","popoverResults","length","content","append","startCoord","charCoords","endCoord","ytop","bottom","async","queryPreviewProviders","pos","token","line","document","getLine","providers","popovers","providerPromises","getQuickView","console","error","results","Promise","allSettled","status","value","_renderPreview","markText","className","$popoverContent","show","addEventListener","currentQueryID","showPreview","getHoveredEditor","coordsChar","clientX","clientY","ch","getToken","savedQueryId","_isMouseFarFromPopup","previewRect","getBoundingClientRect","docRect","thresholdPercent","_isDistanceExceedThreshold","smaller","larger","total","threshold","x","y","processMouseMove","posWithinRange","setTimeout","handleMouseMove","event","buttons","requestAnimationFrame","onActiveEditorChange","current","previous","off","on","updateMenuItemCheckmark","get","setChecked","mouseOut","_evt","contains","toElement","_mouseEnteredPreviewContainer","_mouseExitedPreviewContainer","setEnabled","_enabled","doNotSave","editorHolder","previewContainer","removeEventListener","set","save","toggleEnableQuickView","_forceShow","Math","floor","_handleEscapeKeyEvent","isQuickViewShown","preventDefault","stopPropagation","appReady","appendTo","register","getMenu","AppMenuBar","VIEW_MENU","addMenuItem","AFTER","VIEW_TOGGLE_INSPECTION","addEscapeKeyEventHandler","_queryPreviewProviders"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * QuickViewManager provides support to add interactive preview popups on hover over the main editors.\n * Extensions can register to provide previews with `QuickViewManager.registerQuickViewProvider` API.\n * ![quick-view-image.png](generatedDocs/images/quick-view-image.png)\n * ![quick-view-youtube.png](generatedDocs/images/quick-view-youtube.png)\n *\n * ### See Related: SelectionViewManager\n * [features/SelectionViewManager](https://github.com/phcode-dev/phoenix/wiki/SelectionViewManager-API) is similar to\n * QuickViewManager API.\n * * SelectionViews popup only once user selects a text by mouse or hover over a region with text selection.\n * * Quickviews popup on mouse hover.\n * ![image](https://user-images.githubusercontent.com/5336369/186434397-3db55789-6077-4d02-b4e2-78ef3f663399.png)\n *\n *\n * ## Usage\n * Lets build a \"hello world\" extension that displays \"hello world\" on hover over a text in the editor.\n * In your extension file, add the following code:\n * ```js\n * const QuickViewManager = brackets.getModule(\"features/QuickViewManager\");\n * // replace `all` with language ID(Eg. javascript) if you want to restrict the preview to js files only.\n * QuickViewManager.registerQuickViewProvider(exports, [\"all\"]);\n *\n * // now implement the getQuickView function that will be invoked when ever user hovers over a text in the editor.\n * exports.getQuickView = function(editor, pos, token, line) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 start: {line: pos.line, ch:token.start},\n *                 end: {line: pos.line, ch:token.end},\n *                 content: \"<div>hello world</div>\"\n *             });\n *         });\n *     };\n * ```\n *\n * ### How it works\n * When QuickViewManager determines that the user intents to see QuickView on hover, `getQuickView` function on all\n * registered QuickView providers are invoked to get the quick view popup. `getQuickView` should return a promise\n * that resolves to the popup contents if the provider has a quick view. Else just reject the promise. If multiple\n * providers returns QuickView, all of them are displayed one by one. See detailed API docs for implementation\n * details below:\n *\n * ## API\n * ### registerQuickViewProvider\n * Register a QuickView provider with this api.\n *\n * ```js\n * // syntax\n * QuickViewManager.registerQuickViewProvider(provider, supportedLanguages);\n * ```\n * The API requires two parameters:\n * 1. `provider`: must implement a  `getQuickView` function which will be invoked to get the preview. See API doc below.\n * 1. `supportedLanguages`: An array of languages that the QuickView supports. If `[\"all\"]` is supplied, then the\n *    QuickView will be invoked for all languages. Restrict to specific languages: Eg: `[\"javascript\", \"html\", \"php\"]`\n *\n * ```js\n * // to register a provider that will be invoked for all languages. where provider is any object that implements\n * // a getQuickView function\n * QuickViewManager.registerQuickViewProvider(provider, [\"all\"]);\n *\n * // to register a provider that will be invoked for specific languages\n * QuickViewManager.registerQuickViewProvider(provider, [\"javascript\", \"html\", \"php\"]);\n * ```\n *\n * ### removeQuickViewProvider\n * Removes a registered code hint provider. The API takes the same arguments as `registerQuickViewProvider`.\n * ```js\n * // syntax\n * QuickViewManager.removeQuickViewProvider(provider, supportedLanguages);\n * // Example\n * QuickViewManager.removeQuickViewProvider(provider, [\"javascript\", \"html\"]);\n * ```\n *\n * ### getQuickView\n * Each provider must implement the `getQuickView` function that returns a promise. The promise either resolves with\n * the quick view details object(described below) or rejects if there is no preview for the position.\n * ```js\n * // function signature\n * provider.getQuickView = function(editor, pos, token, line) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 start: {line: pos.line, ch:token.start},\n *                 end: {line: pos.line, ch:token.end},\n *                 content: \"<div>hello world</div>\"\n *             });\n *         });\n *     };\n * ```\n *\n * #### parameters\n * The function will be called with the following arguments:\n * 1. `editor` - The editor over which the user hovers the mouse cursor.\n * 1. `pos` - the cursor position over which the user hovers.\n * 1. `token` - hovered token details\n * 1. `line` - the full line text as string.\n *\n * #### return types\n * The promise returned should resolve to an object with the following contents:\n * 1. `start` : Indicates the start cursor position from which the quick view is valid.\n * 1. `end` : Indicates the end cursor position to which the quick view is valid. These are generally used to highlight\n *    the hovered section of the text in the editor.\n * 1. `content`: Either `HTML` as text, a `DOM Node` or a `Jquery Element`.\n *\n * #### Modifying the QuickView content after resolving `getQuickView` promise\n * Some advanced/interactive extensions may need to do dom operations on the quick view content.\n * In such cases, it is advised to return a domNode/Jquery element as content in `getQuickView`. Event Handlers\n * or further dom manipulations can be done on the returned content element.\n * The Quick view may be dismissed at any time, so be sure to check if the DOM Node is visible in the editor before\n * performing any operations.\n *\n * #### Considerations\n * 1. QuickView won't be displayed till all provider promises are settled. To improve performance, if your QuickView\n *    handler takes time to resolve the QuickView, resolve a dummy quick once you are sure that a QuickView needs\n *    to be shown to the user. The div contents can be later updated as and when more details are available.\n * 1. Note that the QuickView could be hidden/removed any time by the QuickViewManager.\n * 1. If multiple providers returns a valid popup, all of them are displayed.\n *\n * @module features/QuickViewManager\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Brackets modules\n    const CommandManager    = require(\"command/CommandManager\"),\n        Commands            = require(\"command/Commands\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        Menus               = require(\"command/Menus\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        Strings             = require(\"strings\"),\n        ViewUtils           = require(\"utils/ViewUtils\"),\n        AppInit             = require(\"utils/AppInit\"),\n        WorkspaceManager    = require(\"view/WorkspaceManager\"),\n        ProviderRegistrationHandler = require(\"features/PriorityBasedRegistration\").RegistrationHandler;\n\n    const previewContainerHTML       = '<div id=\"quick-view-container\">\\n' +\n        '    <div class=\"preview-content\">\\n' +\n        '    </div>\\n' +\n        '</div>';\n\n    const _providerRegistrationHandler = new ProviderRegistrationHandler(),\n        registerQuickViewProvider = _providerRegistrationHandler.registerProvider.bind(_providerRegistrationHandler),\n        removeQuickViewProvider = _providerRegistrationHandler.removeProvider.bind(_providerRegistrationHandler);\n\n    function _getQuickViewProviders(editor) {\n        let quickViewProviders = [];\n        let language = editor.getLanguageForSelection(),\n            enabledProviders = _providerRegistrationHandler.getProvidersForLanguageId(language.getId());\n\n        for(let item of enabledProviders){\n            quickViewProviders.push(item.provider);\n        }\n        return quickViewProviders;\n    }\n\n    let enabled,                             // Only show preview if true\n        prefs                      = null,   // Preferences\n        $previewContainer,                   // Preview container\n        $previewContent,                     // Preview content holder\n        _currentMousePos,\n        animationRequest;\n\n    // Constants\n    const CMD_ENABLE_QUICK_VIEW       = \"view.enableQuickView\",\n        QUICK_VIEW_EDITOR_MARKER = 'quickViewMark',\n        // Time (ms) mouse must remain over a provider's matched text before popover appears\n        HOVER_DELAY                 = 500,\n        // Pointer height, used to shift popover above pointer (plus a little bit of space)\n        POINTER_HEIGHT              = 10,\n        POPOVER_HORZ_MARGIN         =  5;   // Horizontal margin\n\n    prefs = PreferencesManager.getExtensionPrefs(\"quickview\");\n    prefs.definePreference(\"enabled\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_QUICK_VIEW_ENABLED\n    });\n\n    /**\n     * There are three states for this var:getToken\n     * 1. If null, there is no provider result for the given mouse position.\n     * 2. If non-null, and visible==true, there is a popover currently showing.\n     * 3. If non-null, but visible==false, we're waiting for HOVER_DELAY, which\n     *    is tracked by hoverTimer. The state changes to visible==true as soon as\n     *    there is a provider. If the mouse moves before then, timer is restarted.\n     *\n     * @type {{\n     *      visible: boolean,\n     *      editor: !Editor,\n     *      hoverTimer: number,             - setTimeout() token\n     *      start: !{line, ch},             - start of matched text range\n     *      end: !{line, ch},               - end of matched text range\n     *      content: !string,               - HTML content to display in popover\n     *      xpos: number,                   - x of center of popover\n     *      ytop: number,                   - y of top of matched text (when popover placed above text, normally)\n     *      ybot: number,                   - y of bottom of matched text (when popover moved below text, avoiding window top)\n     *      marker: ?CodeMirror.TextMarker  - only set once visible==true\n     * }}\n     * @private\n     */\n    let popoverState = null;\n\n\n\n    // Popover widget management ----------------------------------------------\n\n    /**\n     * Cancels whatever popoverState was currently pending and sets it back to null. If the popover was visible,\n     * hides it; if the popover was invisible and still pending, cancels hoverTimer so it will never be shown.\n     * @private\n     */\n    function hidePreview() {\n        if (!popoverState) {\n            return;\n        }\n\n        if (popoverState.visible) {\n            popoverState.marker.clear();\n            $previewContent.empty();\n            $previewContainer.hide();\n            $previewContainer.removeClass(\"active\");\n            if(EditorManager.getActiveEditor()){\n                EditorManager.getActiveEditor().focus();\n            }\n        }\n        showPreviewQueued = false;\n        mouseInPreviewContainer = false;\n        window.clearTimeout(popoverState.hoverTimer);\n        popoverState = null;\n    }\n\n    function positionPreview(editor, xpos, ypos, ybot) {\n        if ($previewContent.find(\"#quick-view-popover-root\").is(':empty')){\n            hidePreview();\n            return;\n        }\n        let previewWidth  = $previewContainer.outerWidth(),\n            top           = ypos - $previewContainer.outerHeight() - POINTER_HEIGHT,\n            left          = xpos - previewWidth / 2,\n            elementRect = {\n                top: top,\n                left: left - POPOVER_HORZ_MARGIN,\n                height: $previewContainer.outerHeight() + POINTER_HEIGHT,\n                width: previewWidth + 2 * POPOVER_HORZ_MARGIN\n            },\n            clip = ViewUtils.getElementClipSize($(editor.getRootElement()), elementRect);\n\n        // Prevent horizontal clipping\n        if (clip.left > 0) {\n            left += clip.left;\n        } else if (clip.right > 0) {\n            left -= clip.right;\n        }\n\n        // If clipped on top, flip popover below line\n        if (clip.top > 0) {\n            top = ybot + POINTER_HEIGHT;\n            $previewContainer\n                .removeClass(\"preview-bubble-above\")\n                .addClass(\"preview-bubble-below\");\n        } else {\n            $previewContainer\n                .removeClass(\"preview-bubble-below\")\n                .addClass(\"preview-bubble-above\");\n        }\n\n        $previewContainer\n            .css({\n                left: left,\n                top: top\n            })\n            .addClass(\"active\");\n    }\n\n    // Preview hide/show logic ------------------------------------------------\n\n    function _isResultBeforePopoverStart(editor, popover, result){\n        if(!popover.start){\n            return true;\n        }\n        return editor.indexFromPos(result.start) < editor.indexFromPos(popover.start);\n    }\n\n    function _isResultAfterPopoverEnd(editor, popover, result){\n        if(!popover.end){\n            return true;\n        }\n        return editor.indexFromPos(popover.start) > editor.indexFromPos(result.end);\n    }\n\n    function _createPopoverState(editor, popoverResults) {\n        if (popoverResults && popoverResults.length) {\n            let popover = {\n                content: $(\"<div id='quick-view-popover-root'></div>\")\n            };\n            // Each provider return popover { start, end, content}\n            for(let result of popoverResults){\n                if(_isResultBeforePopoverStart(editor, popover, result)){\n                    popover.start = result.start;\n                }\n                if(_isResultAfterPopoverEnd(editor, popover, result)){\n                    popover.end = result.end;\n                }\n                popover.content.append(result.content);\n            }\n\n            let startCoord = editor.charCoords(popover.start),\n                endCoord = editor.charCoords(popover.end);\n            popover.xpos = (endCoord.left - startCoord.left) / 2 + startCoord.left;\n            if(endCoord.left<startCoord.left){\n                // this probably spans multiple lines, just show at start cursor position\n                popover.xpos = startCoord.left;\n            }\n            popover.ytop = startCoord.top;\n            popover.ybot = startCoord.bottom;\n            popover.visible = false;\n            popover.editor  = editor;\n            return popover;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns a 'ready for use' popover state object:\n     * { visible: false, editor, start, end, content, ?onShow, xpos, ytop, ybot }\n     * Lacks only hoverTimer (supplied by handleMouseMove()) and marker (supplied by showPreview()).\n     * @private\n     */\n    async function queryPreviewProviders(editor, pos, token) {\n        let line = editor.document.getLine(pos.line);\n        let providers = _getQuickViewProviders(editor);\n        let popovers = [], providerPromises = [];\n        for(let provider of providers){\n            if(!provider.getQuickView){\n                console.error(\"Quickview provider does not implement the required getQuickView function\", provider);\n                continue;\n            }\n            providerPromises.push(provider.getQuickView(editor, pos, token, line));\n        }\n        let results = await Promise.allSettled(providerPromises);\n        for(let result of results){\n            if(result.status === \"fulfilled\" && result.value){\n                popovers.push(result.value);\n            }\n        }\n\n        return _createPopoverState(editor, popovers);\n    }\n\n    /**\n     * Changes the current hidden popoverState to visible, showing it in the UI and highlighting\n     * its matching text in the editor.\n     * @private\n     */\n    function _renderPreview(editor) {\n        if (popoverState && popoverState.start && popoverState.end) {\n            popoverState.marker = editor.markText(\n                QUICK_VIEW_EDITOR_MARKER,\n                popoverState.start,\n                popoverState.end,\n                {className: \"quick-view-highlight\"}\n            );\n\n            let $popoverContent = $(popoverState.content);\n            $previewContent.append($popoverContent);\n            $previewContainer.show();\n            popoverState.visible = true;\n            positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n\n            $popoverContent[0].addEventListener('DOMSubtreeModified', ()=>{\n                positionPreview(editor, popoverState.xpos, popoverState.ytop, popoverState.ybot);\n            }, false);\n        }\n    }\n\n    let currentQueryID = 0;\n    async function showPreview(editor) {\n        let token;\n\n        // Figure out which editor we are over\n        if (!editor) {\n            editor = EditorManager.getHoveredEditor(_currentMousePos);\n        }\n\n        if (!editor) {\n            hidePreview();\n            return;\n        }\n\n        // Find char mouse is over\n        let pos = editor.coordsChar({left: _currentMousePos.clientX, top: _currentMousePos.clientY});\n\n        // No preview if mouse is past last char on line\n        if (pos.ch >= editor.document.getLine(pos.line).length) {\n            return;\n        }\n\n        // Query providers and append to popoverState\n        token = editor.getToken(pos);\n        currentQueryID++;\n        let savedQueryId = currentQueryID;\n        popoverState = await queryPreviewProviders(editor, pos, token);\n        if(savedQueryId === currentQueryID){\n            // this is to prevent race conditions. For Eg., if the preview provider takes time to generate a preview,\n            // another query might have happened while the last query is still in progress. So we only render the most\n            // recent QueryID\n            _renderPreview(editor);\n        }\n    }\n\n    function _isMouseFarFromPopup() {\n        const previewRect = $previewContainer[0].getBoundingClientRect();\n        const docRect = {\n            height: $(document).height(),\n            width: $(document).width()\n        };\n        const thresholdPercent = 5;\n        function _isDistanceExceedThreshold(smaller, larger, total, threshold) {\n            return ((larger - smaller)/total)*100 > threshold;\n        }\n        let x= _currentMousePos.clientX, y=_currentMousePos.clientY;\n        if((x<previewRect.left && _isDistanceExceedThreshold(x, previewRect.left, docRect.width, thresholdPercent))\n            ||(x>previewRect.right && _isDistanceExceedThreshold(previewRect.right, x, docRect.width, thresholdPercent))\n            ||(y<previewRect.top && _isDistanceExceedThreshold(y, previewRect.top, docRect.height, thresholdPercent))\n            ||(y>previewRect.bottom && _isDistanceExceedThreshold(previewRect.bottom, y, docRect.height, thresholdPercent))){\n            return true;\n        }\n        return false;\n    }\n\n    let showPreviewQueued = false;\n\n    function processMouseMove() {\n        animationRequest = null;\n\n        if (mouseInPreviewContainer) {\n            return;\n        }\n\n        let editor = null;\n\n        if (popoverState && popoverState.visible) {\n            // Only figure out which editor we are over when there is already a popover\n            // showing (otherwise wait until after delay to minimize processing)\n            editor = EditorManager.getHoveredEditor(_currentMousePos);\n            if (editor) {\n                // Find char mouse is over\n                let pos = editor.coordsChar({left: _currentMousePos.clientX, top: _currentMousePos.clientY});\n                if (popoverState.start && popoverState.end &&\n                        editor.posWithinRange(pos, popoverState.start, popoverState.end, true) &&\n                        (pos.ch < editor.document.getLine(pos.line).length)) {\n\n                    // That one's still relevant - nothing more to do\n                    // Note: posWithinRange() includes mouse past end of line, so need to check for that case\n                    return;\n                }\n                if(_isMouseFarFromPopup()){\n                    hidePreview();\n                    return;\n                }\n            }\n        }\n\n        if(!showPreviewQueued){\n            // Initialize popoverState\n            showPreviewQueued = true;\n            popoverState = popoverState || {};\n\n            // Set timer to scan and show. This will get cancelled (in hidePreview())\n            // if mouse movement rendered this popover inapplicable before timer fires.\n            // When showing \"immediately\", still use setTimeout() to make this async\n            // so we return from this mousemove event handler ASAP.\n            popoverState.hoverTimer = window.setTimeout(function () {\n                showPreviewQueued = false;\n                if(!mouseInPreviewContainer){\n                    hidePreview();\n                    popoverState = {};\n                    showPreview(editor);\n                }\n            }, HOVER_DELAY);\n        }\n    }\n\n    function handleMouseMove(event) {\n        // Keep track of mouse position\n        _currentMousePos = {\n            clientX: event.clientX,\n            clientY: event.clientY\n        };\n\n        if (!enabled) {\n            return;\n        }\n\n        if (event.buttons !== 0) {\n            // Button is down - don't show popovers while dragging\n            hidePreview();\n            return;\n        }\n\n        // Prevent duplicate animation frame requests\n        if (!animationRequest) {\n            animationRequest = window.requestAnimationFrame(processMouseMove);\n        }\n    }\n\n    function onActiveEditorChange(event, current, previous) {\n        // Hide preview when editor changes\n        hidePreview();\n\n        if (previous && previous.document) {\n            previous.document.off(\"change\", hidePreview);\n        }\n\n        if (current && current.document) {\n            current.document.on(\"change\", hidePreview);\n        }\n    }\n\n    // Menu command handlers\n    function updateMenuItemCheckmark() {\n        CommandManager.get(CMD_ENABLE_QUICK_VIEW).setChecked(enabled);\n    }\n\n    let mouseInPreviewContainer = false;\n    function mouseOut(_evt) {\n        setTimeout(()=>{\n            if(mouseInPreviewContainer || $previewContainer[0].contains(_evt.toElement)){\n                return;\n            }\n            hidePreview();\n        }, HOVER_DELAY);\n    }\n\n    function _mouseEnteredPreviewContainer() {\n        mouseInPreviewContainer = true;\n    }\n\n    function _mouseExitedPreviewContainer() {\n        mouseInPreviewContainer = false;\n    }\n\n    function setEnabled(_enabled, doNotSave) {\n        if (enabled !== _enabled) {\n            enabled = _enabled;\n            let editorHolder = $(\"#editor-holder\")[0];\n            let previewContainer = $previewContainer[0];\n            if (enabled) {\n                // Note: listening to \"scroll\" also catches text edits, which bubble a scroll\n                // event up from the hidden text area. This means\n                // we auto-hide on text edit, which is probably actually a good thing.\n                editorHolder.addEventListener(\"mousemove\", handleMouseMove, true);\n                editorHolder.addEventListener(\"scroll\", hidePreview, true);\n                editorHolder.addEventListener(\"mouseout\", mouseOut, true);\n                previewContainer.addEventListener(\"mouseover\", _mouseEnteredPreviewContainer, true);\n                previewContainer.addEventListener(\"mouseout\", _mouseExitedPreviewContainer, true);\n\n                // Setup doc \"change\" listener\n                onActiveEditorChange(null, EditorManager.getActiveEditor(), null);\n                EditorManager.on(\"activeEditorChange\", onActiveEditorChange);\n\n            } else {\n                editorHolder.removeEventListener(\"mousemove\", handleMouseMove, true);\n                editorHolder.removeEventListener(\"scroll\", hidePreview, true);\n                editorHolder.removeEventListener(\"mouseout\", mouseOut, true);\n                previewContainer.removeEventListener(\"mouseover\", _mouseEnteredPreviewContainer, true);\n                previewContainer.removeEventListener(\"mouseout\", _mouseExitedPreviewContainer, true);\n\n\n                // Cleanup doc \"change\" listener\n                onActiveEditorChange(null, null, EditorManager.getActiveEditor());\n                EditorManager.off(\"activeEditorChange\", onActiveEditorChange);\n\n                hidePreview();\n            }\n            if (!doNotSave) {\n                prefs.set(\"enabled\", enabled);\n                prefs.save();\n            }\n        }\n        // Always update the checkmark, even if the enabled flag hasn't changed.\n        updateMenuItemCheckmark();\n    }\n\n    function toggleEnableQuickView() {\n        setEnabled(!enabled);\n    }\n\n    function _forceShow(popover) {\n        hidePreview();\n        _currentMousePos = {\n            clientX: popover.xpos,\n            clientY: Math.floor((popover.ybot + popover.ytop) / 2)\n        };\n        popoverState = popover;\n        _renderPreview(popover.editor);\n    }\n\n    function _handleEscapeKeyEvent(event) {\n        if(isQuickViewShown()){\n            hidePreview();\n            event.preventDefault();\n            event.stopPropagation();\n            return true;\n        }\n        return false;\n    }\n\n    AppInit.appReady(function () {\n        // Create the preview container\n        $previewContainer = $(previewContainerHTML).appendTo($(\"body\"));\n        $previewContent = $previewContainer.find(\".preview-content\");\n\n        // Register command\n        // Insert menu at specific pos since this may load before OR after code folding extension\n        CommandManager.register(Strings.CMD_ENABLE_QUICK_VIEW, CMD_ENABLE_QUICK_VIEW, toggleEnableQuickView);\n        Menus.getMenu(Menus.AppMenuBar.VIEW_MENU).addMenuItem(\n            CMD_ENABLE_QUICK_VIEW, null, Menus.AFTER, Commands.VIEW_TOGGLE_INSPECTION);\n\n        // Setup initial UI state\n        setEnabled(prefs.get(\"enabled\"), true);\n\n        prefs.on(\"change\", \"enabled\", function () {\n            setEnabled(prefs.get(\"enabled\"), true);\n        });\n\n        WorkspaceManager.addEscapeKeyEventHandler(\"quickView\", _handleEscapeKeyEvent);\n    });\n\n    /**\n     * If quickview is displayed and visible on screen\n     * @return {boolean}\n     * @type {function}\n     */\n    function isQuickViewShown() {\n        return (popoverState && popoverState.visible) || false;\n    }\n\n    // For unit testing\n    exports._queryPreviewProviders  = queryPreviewProviders;\n    exports._forceShow              = _forceShow;\n\n    exports.registerQuickViewProvider = registerQuickViewProvider;\n    exports.removeQuickViewProvider   = removeQuickViewProvider;\n    exports.isQuickViewShown = isQuickViewShown;\n});\n"],"file":"QuickViewManager.js"}
{"version":3,"sources":["features/BeautificationManager.js"],"names":["define","require","exports","module","Commands","Strings","StringUtils","AppInit","CommandManager","LanguageManager","Menus","EditorManager","DocumentManager","ProjectManager","PreferencesManager","ProviderRegistrationHandler","RegistrationHandler","PREFERENCES_BEAUTIFY_ON_SAVE","FAILED_EDITOR_TEXT_CHANGED","_providerRegistrationHandler","registerBeautificationProvider","registerProvider","bind","removeBeautificationProvider","removeProvider","beautifyCommand","beautifyOnSaveCommand","_getEnabledProviders","filepath","language","getLanguageForPath","getProvidersForLanguageId","getId","async","_getBeautifiedCodeDetails","editor","enabledProviders","document","file","fullPath","item","provider","beautifyEditorProvider","beautifyTextProvider","beautyObject","e","console","error","Error","_onActiveEditorChange","_evt","current","length","setEnabled","_replaceText","getText","originalText","ranges","replaceStart","line","ch","replaceEnd","getEndingCursorPos","getRange","changedText","hasSelection","setSelection","replaceSelection","cursor","getCursorPos","replaceRange","cursorOffset","posFromIndex","setCursorPos","beautifyEditor","Promise","resolve","reject","then","rejected","operation","catch","beautifyText","textToBeautify","filePathOrFileName","_beautifyCommand","result","$","Deferred","getActiveEditor","promise","busyMessage","format","BEAUTIFY_PROJECT_BUSY_MESSAGE","getFile","name","setProjectBusy","log","message","BEAUTIFY_ERROR_SELECTION","BEAUTIFY_ERROR","BEAUTIFY_ERROR_ORIGINAL_CHANGED","displayErrorMessageAtCursor","warn","_beautifyOnSave","doc","_isBeautifyOnSaveEnabled","clearSelection","getViewState","_toggleBeautifyOnSave","beautifyOnSave","setViewState","setChecked","appReady","register","CMD_BEAUTIFY_CODE","EDIT_BEAUTIFY_CODE","CMD_BEAUTIFY_CODE_ON_SAVE","EDIT_BEAUTIFY_CODE_ON_SAVE","editMenu","getMenu","AppMenuBar","EDIT_MENU","editorContextMenu","addMenuItem","getContextMenu","ContextMenuIds","EDITOR_MENU","AFTER","EDIT_SELECT_ALL","on"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n// @INCLUDE_IN_API_DOCS\n\n/**\n * Beautification manager interacts with beautify extensions to determine what to do when user issues `beautify code`\n * command. Beautification providers can use this module to register new providers to beautify new languages.\n *\n * ## API\n * ### registerBeautificationProvider\n * Register a Beautification provider with this api.\n *\n * ```js\n * // syntax\n * BeautificationManager.registerBeautificationProvider(provider, supportedLanguages, priority);\n * ```\n * The API requires three parameters:\n * 1. `provider`: must implement a  `beautifyEditorProvider` and `beautifyTextProvider` function. See doc below:\n * 1. `supportedLanguages`: An array of languages that the provider supports. If `[\"all\"]` is supplied, then the\n *    provider will be invoked for all languages. Restrict to specific languages: Eg: `[\"javascript\", \"html\", \"php\"]`\n * 1. `priority`: Used to break ties among providers for a particular language. Providers with a higher number\n *     will be asked for beatified code before those with a lower priority value. Defaults to zero.\n *\n * ```js\n * // to register a provider that will be invoked for all languages. where provider is any object that implements\n * // a `beautifyEditorProvider` and `beautifyTextProvider` function\n * BeautificationManager.registerBeautificationProvider(provider, [\"all\"]);\n *\n * // to register a provider that will be invoked for specific languages\n * BeautificationManager.registerBeautificationProvider(provider, [\"javascript\", \"html\", \"php\"]);\n * ```\n *\n * ### removeBeautificationProvider\n * Removes a registered Beautification provider. The API takes the same arguments as `registerBeautificationProvider`.\n * ```js\n * // syntax\n * BeautificationManager.removeBeautificationProvider(provider, supportedLanguages);\n * // Example\n * BeautificationManager.removeBeautificationProvider(provider, [\"javascript\", \"html\"]);\n * ```\n *\n * ### provider.beautifyEditorProvider\n * Each provider must implement the `beautifyEditorProvider` function that returns a promise. The promise either resolves with\n * the beautified code details or rejects if there is nothing to beautify for the provider.\n * ```js\n * // function signature\n * provider.beautifyEditorProvider = function(editor) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 originalText: \"the original text sent to beautify\",\n *                 changedText: \"partial or full text that changed.\",\n *                 // Optional cursor offset if given will set the editor cursor to the position after beautification.\n *                 // either `cursorOffset` or `ranges` can be specified, but not both.\n *                 cursorOffset: number,\n *                 // Optional: If range is specified, only the given range will be replaced. else full text is replaced\n *                 ranges:{\n *                     replaceStart: {line,ch},\n *                     replaceEnd: {line,ch}\n *                 }\n *             });\n *         });\n *     };\n * ```\n *\n * #### The resolved promise object\n * The resolved promise should either be `null`(indicating that the extension itself has prettified the code and\n * doesn't want any further processing from BeautificationManager.) or contain the following details:\n * 1. `originalText` - string, the original text sent to beautify\n * 1. `changedText` - string, this should be the fully prettified text of the whole `originalText` or a fragment of\n *     pretty text in `originalText` if a range was selected. If a `fragment` is returned, then the\n *     `ranges` object must be specified.\n * 1. `cursorOffset` - Optional number, if given will set the editor cursor to the position after beautification.\n *      either `cursorOffset` or `ranges` can be specified, but not both.\n * 1. `ranges` - Optional object, set of 2 cursors that gives details on what range to replace with given changed text.\n *    If range is not specified, the full text in the editor will be replaced. range has 2 fields:\n *    1. `replaceStart{line,ch}` - the start of range to replace\n *    1. `replaceEnd{line,ch}` - the end of range to replace\n *\n * ### provider.beautifyTextProvider\n * Each provider must implement the `beautifyTextProvider` function that returns a promise.\n * The promise either resolves with the beautified code details(same as beautifyEditorProvider) or rejects if\n * there is nothing to beautify for the provider.\n * ```js\n * // function signature.\n * provider.beautifyTextProvider = function(textToBeautify, filePathOrFileName) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 originalText: \"the original text sent to beautify\",\n *                 changedText: \"partial or full text that changed.\",\n *                 // Optional: If range is specified, only the given range is assumed changed. else full text changed.\n *                 ranges:{\n *                     replaceStart: {line,ch},\n *                     replaceEnd: {line,ch}\n *                 }\n *             });\n *         });\n *     };\n * ```\n * #### Parameters\n * The `beautifyTextProvider` callback will receive the following arguments.\n * 1. textToBeautify - string\n * 1. filePathOrFileName - string. This will either be a valid file path, or a file name to deduce which language the\n *    beautifier is dealing with.\n * #### The resolved promise object\n *  The resolved object has the same structure as beautifyEditorProvider resolved promise object.\n * @module features/BeautificationManager\n */\ndefine(function (require, exports, module) {\n\n\n    const Commands = require(\"command/Commands\"),\n        Strings = require(\"strings\"),\n        StringUtils = require(\"utils/StringUtils\"),\n        AppInit = require(\"utils/AppInit\"),\n        CommandManager = require(\"command/CommandManager\"),\n        LanguageManager = require(\"language/LanguageManager\"),\n        Menus = require(\"command/Menus\"),\n        EditorManager = require(\"editor/EditorManager\"),\n        DocumentManager = require(\"document/DocumentManager\"),\n        ProjectManager = require(\"project/ProjectManager\"),\n        PreferencesManager = require(\"preferences/PreferencesManager\"),\n        ProviderRegistrationHandler = require(\"features/PriorityBasedRegistration\").RegistrationHandler;\n\n    const PREFERENCES_BEAUTIFY_ON_SAVE = \"BeautifyOnSave\",\n        FAILED_EDITOR_TEXT_CHANGED = \"Beautify failed- editorTextChanged\";\n\n    let _providerRegistrationHandler = new ProviderRegistrationHandler(),\n        registerBeautificationProvider = _providerRegistrationHandler\n            .registerProvider.bind(_providerRegistrationHandler),\n        removeBeautificationProvider = _providerRegistrationHandler\n            .removeProvider.bind(_providerRegistrationHandler),\n        beautifyCommand,\n        beautifyOnSaveCommand;\n\n    function _getEnabledProviders(filepath) {\n        let language = LanguageManager.getLanguageForPath(filepath);\n        return _providerRegistrationHandler.getProvidersForLanguageId(language.getId());\n    }\n\n    async function _getBeautifiedCodeDetails(editor) {\n        let enabledProviders = _getEnabledProviders(editor.document.file.fullPath);\n\n        for(let item of enabledProviders){\n            if(!item.provider.beautifyEditorProvider || !item.provider.beautifyTextProvider){\n                console.error(\n                    \"Beautify providers must implement `beautifyEditorProvider` and `beautifyTextProvider` function\",\n                    item);\n                continue;\n            }\n            try{\n                let beautyObject = await item.provider.beautifyEditorProvider(editor);\n                if(beautyObject){\n                    return beautyObject;\n                }\n            } catch (e) {\n                // providers reject if they didn't beautify the code. We do nothing in the case as expected failure.\n            }\n        }\n        throw new Error(\"No Providers beautified text\");\n    }\n\n    function _onActiveEditorChange(_evt, current) {\n        if(current && _getEnabledProviders(current.document.file.fullPath).length){\n            beautifyCommand.setEnabled(true);\n            return;\n        }\n        beautifyCommand.setEnabled(false);\n    }\n\n    function _replaceText(editor, beautyObject) {\n        if (editor.document.getText() !== beautyObject.originalText){\n            // editor text changed in between beautification. we cant apply changes\n            throw new Error(FAILED_EDITOR_TEXT_CHANGED);\n        }\n        let ranges = beautyObject.ranges || {\n            replaceStart: {line: 0, ch: 0},\n            replaceEnd: editor.getEndingCursorPos()\n        };\n        if(editor.document.getRange(ranges.replaceStart, ranges.replaceEnd) !== beautyObject.changedText) {\n            if(editor.hasSelection()){\n                editor.setSelection(ranges.replaceStart, ranges.replaceEnd);\n                editor.replaceSelection(beautyObject.changedText, 'around');\n            } else {\n                let cursor = editor.getCursorPos();\n                editor.replaceRange(beautyObject.changedText, ranges.replaceStart, ranges.replaceEnd);\n                if(beautyObject.cursorOffset || beautyObject.cursorOffset === 0){\n                    // we have accurate cursor positioning from beautifier\n                    cursor = editor.posFromIndex(beautyObject.cursorOffset);\n                }\n                editor.setCursorPos(cursor.line, cursor.ch);\n            }\n        }\n    }\n\n    /**\n     * Beautifies text in the given editor with available providers.\n     * @param editor\n     * @return {Promise} - A promise that will be resolved to null if the selected text is beautified or rejects\n     * if beautification failed.\n     * @type {function}\n     */\n    function beautifyEditor(editor){\n        return new Promise((resolve, reject)=>{\n            if(!editor){\n                reject();\n                return;\n            }\n            _getBeautifiedCodeDetails(editor).then(beautyObject => {\n                if(!beautyObject || !beautyObject.changedText){\n                    reject();\n                    return;\n                }\n                let rejected = false;\n                editor.operation(function () {\n                    try{\n                        _replaceText(editor, beautyObject);\n                    } catch (e) {\n                        rejected = true;\n                        reject(e);\n                    }\n                });\n                if(!rejected){\n                    resolve();\n                }\n            }).catch(e => {\n                reject(e);\n            });\n        });\n    }\n\n    /**\n     * Beautifies text with available providers.\n     * @param {string} textToBeautify\n     * @param {string} filePathOrFileName Note that the file path may not actually exist on disk. It is just used to\n     * infer what language beautifier is to be applied.\n     * @return {Promise} - A promise that will be resolved to null if the selected text is beautified or rejects\n     * if beautification failed..\n     * #### The resolved promise object\n     * The resolved promise object contain the following details:\n     * 1. `originalText` - string, the original text sent to beautify\n     * 1. `changedText` - string, the prettified text.\n     * 1. `ranges` - Optional. if range object is returned, it means that only a part of the original text changed in\n     *    the original text `textToBeautify`. The part that changed is supplied by two cursor positions below:\n     *    1. `replaceStart{line,ch}` - the start of range to replace\n     *    1. `replaceEnd{line,ch}` - the end of range to replace\n     * @type {function}\n     */\n    async function beautifyText(textToBeautify, filePathOrFileName){\n        let enabledProviders = _getEnabledProviders(filePathOrFileName);\n        for(let item of enabledProviders){\n            if(!item.provider.beautifyEditorProvider || !item.provider.beautifyTextProvider){\n                console.error(\n                    \"Beautify providers must implement `beautifyEditorProvider` and `beautifyTextProvider` function\",\n                    item);\n                continue;\n            }\n            try{\n                let beautyObject = await item.provider.beautifyTextProvider(textToBeautify, filePathOrFileName);\n                if(beautyObject){\n                    return beautyObject;\n                }\n            } catch (e) {\n                // providers reject if they didn't beautify the code. We do nothing in the case as expected failure.\n            }\n        }\n        throw new Error(\"No Providers beautified text\");\n    }\n\n    function _beautifyCommand() {\n        let result = new $.Deferred();\n        let editor = EditorManager.getActiveEditor();\n        if(!editor){\n            result.reject();\n            return result.promise();\n        }\n        let busyMessage = StringUtils.format(Strings.BEAUTIFY_PROJECT_BUSY_MESSAGE, editor.getFile().name);\n        ProjectManager.setProjectBusy(true, busyMessage);\n        beautifyEditor(editor).then( () => {\n            ProjectManager.setProjectBusy(false, busyMessage);\n            console.log(\"Beautified\");\n            result.resolve();\n        }).catch(e=>{\n            let message = editor.hasSelection() ? Strings.BEAUTIFY_ERROR_SELECTION : Strings.BEAUTIFY_ERROR;\n            if(e.message === FAILED_EDITOR_TEXT_CHANGED){\n                message = Strings.BEAUTIFY_ERROR_ORIGINAL_CHANGED;\n            }\n\n            editor.displayErrorMessageAtCursor(message);\n            ProjectManager.setProjectBusy(false, busyMessage);\n            console.warn(\"No beautify providers responded\", e);\n            result.reject();\n        });\n        return result.promise();\n    }\n\n    function _beautifyOnSave(_evt, doc) {\n        let editor = EditorManager.getActiveEditor();\n        if(!_isBeautifyOnSaveEnabled() || !editor || editor.document.file.fullPath !== doc.file.fullPath){\n            return;\n        }\n        editor.clearSelection();\n        _beautifyCommand();\n    }\n\n    function _isBeautifyOnSaveEnabled() {\n        return PreferencesManager.getViewState(PREFERENCES_BEAUTIFY_ON_SAVE) === \"true\";\n    }\n\n    function _toggleBeautifyOnSave() {\n        let beautifyOnSave = _isBeautifyOnSaveEnabled();\n\n        PreferencesManager.setViewState(PREFERENCES_BEAUTIFY_ON_SAVE, `${!beautifyOnSave}`);\n        beautifyOnSaveCommand.setChecked(!beautifyOnSave);\n    }\n\n    AppInit.appReady(function () {\n        beautifyCommand = CommandManager.register(Strings.CMD_BEAUTIFY_CODE,\n            Commands.EDIT_BEAUTIFY_CODE, ()=>{\n                _beautifyCommand();\n            });\n        beautifyOnSaveCommand = CommandManager.register(Strings.CMD_BEAUTIFY_CODE_ON_SAVE,\n            Commands.EDIT_BEAUTIFY_CODE_ON_SAVE, ()=>{\n                _toggleBeautifyOnSave();\n            });\n        let editMenu = Menus.getMenu(Menus.AppMenuBar.EDIT_MENU);\n        editMenu.addMenuItem(Commands.EDIT_BEAUTIFY_CODE, \"\");\n        editMenu.addMenuItem(Commands.EDIT_BEAUTIFY_CODE_ON_SAVE, \"\");\n\n        let editorContextMenu = Menus.getContextMenu(Menus.ContextMenuIds.EDITOR_MENU);\n        editorContextMenu.addMenuItem(Commands.EDIT_BEAUTIFY_CODE, \"\", Menus.AFTER, Commands.EDIT_SELECT_ALL);\n        beautifyOnSaveCommand.setChecked(_isBeautifyOnSaveEnabled());\n        EditorManager.on(\"activeEditorChange\", _onActiveEditorChange);\n        DocumentManager.on('documentSaved.beautificationManager', _beautifyOnSave);\n    });\n\n    exports.registerBeautificationProvider = registerBeautificationProvider;\n    exports.removeBeautificationProvider = removeBeautificationProvider;\n    exports.beautifyEditor = beautifyEditor;\n    exports.beautifyText = beautifyText;\n});\n"],"file":"BeautificationManager.js"}
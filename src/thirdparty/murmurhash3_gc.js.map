{"version":3,"sources":["thirdparty/murmurhash3_gc.js"],"names":["define","require","exports","module","MurmurHash3","mul32","m","n","nlo","nhi","hashBytes","data","len","seed","c1","c2","h1","roundedEnd","i","k1","charCodeAt","this","hashString"],"mappings":"AAEAA,OAAO,SAAUC,QAASC,QAASC,QAoBnC,IAAIC,YAAc,CACjBC,MAAO,SAASC,EAAGC,GAClB,IAAIC,IAAU,MAAJD,EACNE,IACJ,QADUF,EAAIC,KACCF,EAAI,IAAME,IAAMF,EAAI,GAAM,GAG1CI,UAAW,SAASC,KAAMC,IAAKC,MAM9B,IALA,IAAIC,GAAK,WAAYC,GAAK,UAEtBC,GAAKH,KACLI,YAAmB,EAANL,IAERM,EAAI,EAAGA,EAAID,WAAYC,GAAK,EAAG,CACvC,IAAIC,GAA+B,IAAzBR,KAAKS,WAAWF,IACE,IAAzBP,KAAKS,WAAWF,EAAI,KAAc,GACT,IAAzBP,KAAKS,WAAWF,EAAI,KAAc,IACT,IAAzBP,KAAKS,WAAWF,EAAI,KAAc,GAGrCC,IAAY,QADZA,GAAKE,KAAKhB,MAAMc,GAAIL,OACI,GAAOK,KAAO,GAKtCH,GAAW,GADXA,IAAY,QADZA,IAFAG,GAAKE,KAAKhB,MAAMc,GAAIJ,OAGI,GAAOC,KAAO,IACvB,WAAc,EAK9B,OAFAG,GAAK,EAEEP,IAAM,GACZ,KAAK,EACJO,IAAwC,IAAlCR,KAAKS,WAAWH,WAAa,KAAc,GAElD,KAAK,EACJE,KAAyC,IAAlCR,KAAKS,WAAWH,WAAa,KAAc,EAEnD,KAAK,EACJE,IAAqC,IAA9BR,KAAKS,WAAWH,YAEvBE,IAAY,QADZA,GAAKE,KAAKhB,MAAMc,GAAIL,OACI,GAAOK,KAAO,GAEtCH,IADAG,GAAKE,KAAKhB,MAAMc,GAAIJ,IActB,OATAC,IAAMJ,IAGNI,IAAMA,KAAO,GACbA,GAAMK,KAAKhB,MAAMW,GAAI,YACrBA,IAAMA,KAAO,GACbA,GAAMK,KAAKhB,MAAMW,GAAI,YACrBA,IAAMA,KAAO,IAKdM,WAAY,SAASX,KAAMC,IAAKC,MAM/B,IALA,IAAIC,GAAK,WAAYC,GAAK,UAEtBC,GAAKH,KACLI,YAAmB,EAANL,IAERM,EAAI,EAAGA,EAAID,WAAYC,GAAK,EAAG,CACvC,IAAIC,GAAKR,KAAKS,WAAWF,GAAMP,KAAKS,WAAWF,EAAI,IAAM,GAGzDC,IAAY,QADZA,GAAKE,KAAKhB,MAAMc,GAAIL,OACI,GAAOK,KAAO,GAKtCH,GAAW,GADXA,IAAY,QADZA,IAFAG,GAAKE,KAAKhB,MAAMc,GAAIJ,OAGI,GAAOC,KAAO,IACvB,WAAc,EAqB9B,OAlBIJ,IAAM,GAAM,IACfO,GAAKR,KAAKS,WAAWH,YAErBE,IAAY,QADZA,GAAKE,KAAKhB,MAAMc,GAAIL,OACI,GAAOK,KAAO,GAEtCH,IADAG,GAAKE,KAAKhB,MAAMc,GAAIJ,KAKrBC,IAAOJ,KAAO,EAGdI,IAAMA,KAAO,GACbA,GAAMK,KAAKhB,MAAMW,GAAI,YACrBA,IAAMA,KAAO,GACbA,GAAMK,KAAKhB,MAAMW,GAAI,YACrBA,IAAMA,KAAO,UAMM,IAAXb,aAAoD,IAAnBA,OAAOD,UACjDC,OAAOD,QAAUE","sourcesContent":["/* Public Domain MurmurHash3 implementation. Altered to have AMD header and function wrapper. */\n\ndefine(function (require, exports, module) {\n\n/*\n *  The MurmurHash3 algorithm was created by Austin Appleby.  This JavaScript port was authored\n *  by Peter Zotov (based on Java port by Yonik Seeley) and is placed into the public domain.\n *  The author hereby disclaims copyright to this source code.\n *\n *  This produces exactly the same hash values as the final C++ version of MurmurHash3 and\n *  is thus suitable for producing the same hash values across platforms.\n *\n *  There are two versions of this hash implementation. First interprets the string as a\n *  sequence of bytes, ignoring most significant byte of each codepoint. The second one\n *  interprets the string as a UTF-16 codepoint sequence, and appends each 16-bit codepoint\n *  to the hash independently. The latter mode was not written to be compatible with\n *  any other implementation, but it should offer better performance for JavaScript-only\n *  applications.\n *\n *  See http://github.com/whitequark/murmurhash3-js for future updates to this file.\n */\n\nvar MurmurHash3 = {\n\tmul32: function(m, n) {\n\t\tvar nlo = n & 0xffff;\n\t\tvar nhi = n - nlo;\n\t\treturn ((nhi * m | 0) + (nlo * m | 0)) | 0;\n\t},\n\n\thashBytes: function(data, len, seed) {\n\t\tvar c1 = 0xcc9e2d51, c2 = 0x1b873593;\n\n\t\tvar h1 = seed;\n\t\tvar roundedEnd = len & ~0x3;\n\n\t\tfor (var i = 0; i < roundedEnd; i += 4) {\n\t\t\tvar k1 = (data.charCodeAt(i)     & 0xff)        |\n\t\t\t\t((data.charCodeAt(i + 1) & 0xff) << 8)  |\n\t\t\t\t((data.charCodeAt(i + 2) & 0xff) << 16) |\n\t\t\t\t((data.charCodeAt(i + 3) & 0xff) << 24);\n\n\t\t\tk1 = this.mul32(k1, c1);\n\t\t\tk1 = ((k1 & 0x1ffff) << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n\t\t\tk1 = this.mul32(k1, c2);\n\n\t\t\th1 ^= k1;\n\t\t\th1 = ((h1 & 0x7ffff) << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n\t\t\th1 = (h1 * 5 + 0xe6546b64) | 0;\n\t\t}\n\n\t\tk1 = 0;\n\n\t\tswitch(len % 4) {\n\t\t\tcase 3:\n\t\t\t\tk1 = (data.charCodeAt(roundedEnd + 2) & 0xff) << 16;\n\t\t\t\t// fallthrough\n\t\t\tcase 2:\n\t\t\t\tk1 |= (data.charCodeAt(roundedEnd + 1) & 0xff) << 8;\n\t\t\t\t// fallthrough\n\t\t\tcase 1:\n\t\t\t\tk1 |= (data.charCodeAt(roundedEnd) & 0xff);\n\t\t\t\tk1 = this.mul32(k1, c1);\n\t\t\t\tk1 = ((k1 & 0x1ffff) << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n\t\t\t\tk1 = this.mul32(k1, c2);\n\t\t\t\th1 ^= k1;\n\t\t}\n\n\t\t// finalization\n\t\th1 ^= len;\n\n\t\t// fmix(h1);\n\t\th1 ^= h1 >>> 16;\n\t\th1  = this.mul32(h1, 0x85ebca6b);\n\t\th1 ^= h1 >>> 13;\n\t\th1  = this.mul32(h1, 0xc2b2ae35);\n\t\th1 ^= h1 >>> 16;\n\n\t\treturn h1;\n\t},\n\n\thashString: function(data, len, seed) {\n\t\tvar c1 = 0xcc9e2d51, c2 = 0x1b873593;\n\n\t\tvar h1 = seed;\n\t\tvar roundedEnd = len & ~0x1;\n\n\t\tfor (var i = 0; i < roundedEnd; i += 2) {\n\t\t\tvar k1 = data.charCodeAt(i) | (data.charCodeAt(i + 1) << 16);\n\n\t\t\tk1 = this.mul32(k1, c1);\n\t\t\tk1 = ((k1 & 0x1ffff) << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n\t\t\tk1 = this.mul32(k1, c2);\n\n\t\t\th1 ^= k1;\n\t\t\th1 = ((h1 & 0x7ffff) << 13) | (h1 >>> 19);  // ROTL32(h1,13);\n\t\t\th1 = (h1 * 5 + 0xe6546b64) | 0;\n\t\t}\n\n\t\tif((len % 2) == 1) {\n\t\t\tk1 = data.charCodeAt(roundedEnd);\n\t\t\tk1 = this.mul32(k1, c1);\n\t\t\tk1 = ((k1 & 0x1ffff) << 15) | (k1 >>> 17);  // ROTL32(k1,15);\n\t\t\tk1 = this.mul32(k1, c2);\n\t\t\th1 ^= k1;\n\t\t}\n\n\t\t// finalization\n\t\th1 ^= (len << 1);\n\n\t\t// fmix(h1);\n\t\th1 ^= h1 >>> 16;\n\t\th1  = this.mul32(h1, 0x85ebca6b);\n\t\th1 ^= h1 >>> 13;\n\t\th1  = this.mul32(h1, 0xc2b2ae35);\n\t\th1 ^= h1 >>> 16;\n\n\t\treturn h1;\n\t}\n};\n\nif(typeof module !== \"undefined\" && typeof module.exports !== \"undefined\") {\n\tmodule.exports = MurmurHash3;\n}\n});"],"file":"murmurhash3_gc.js"}
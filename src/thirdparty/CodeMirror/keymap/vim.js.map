{"version":3,"sources":["thirdparty/CodeMirror/keymap/vim.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","initVim$1","Pos","transformCursor","cm","range","vim","state","insertMode","head","sel","visualBlock","line","from","anchor","empty","ch","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","replace","fullLine","exitVisualBlock","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","length","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","enterVimMode","setOption","signal","mode","on","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","off","highlightTimeout","clearTimeout","detachVimMap","next","this","keyMap","options","$customCursor","rmClass","getWrapperElement","attach","attachVimMap","prev","curOp","selectionChanged","addClass","cmKey","key","vimKey","cmKeyToVimKey","cmd","vimApi","findKey","defineOption","val","getOption","Init","test","modifiers","Shift","Ctrl","Alt","Cmd","Mod","CapsLock","specialKeys","Enter","Backspace","Delete","Insert","charAt","pieces","split","lastPiece","hasCharacter","i","piece","isUpperCase","toLowerCase","join","onPasteFn","setCursor","offsetCursor","getCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","bigWordCharTest","makeKeyRange","start","size","push","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","upperCaseChars","RegExp","_","isLine","firstLine","lastLine","isLowerCase","k","isMatchableSymbol","indexOf","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","defaultValue","aliases","callback","undefined","Error","value","cfg","option","scope","local","createCircularJumpList","pointer","tail","buffer","Array","add","oldCur","newCur","current","curMark","useNextSlot","cursor","trashMark","clear","setBookmark","markPos","find","cursorEqual","move","offset","mark","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","vimGlobalState","lastInsertModeKeyTimer","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","marks","insertModeRepeat","visualMode","lastSelection","lastPastedText","resetVimGlobalState","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","prototype","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","openDialog","template","dom","class","bottom","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","substr","newMapping","_mapCommand","mappedCtxs","filter","el","mapclear","userKeymap","slice","contexts","j","defineEx","prefix","func","exCommands","commandMap_","handleKey","origin","command","multiSelectHandleKey","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","match","exec","substring","index","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","window","setTimeout","selections","listSelections","here","replaceRange","pop","handleKeyNonInsertMode","keysMatcher","mainKey","operatorShortcut","pushRepeatDigit","operation","isVimOp","processCommand","e","console","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","reason","Register","text","insertModeChanges","searchQueries","registers","unnamedRegister","historyBuffer","iterator","initialPrefix","n","getRepeat","repeat","parseInt","setText","pushText","pushInsertModeChanges","pushSearchQuery","query","toString","isValidRegister","append","shiftNumericRegisters_","nextMatch","up","dir","element","pushInput","splice","reset","matches","commandMatches","bestMatch","full","partial","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","shift","showPrompt","onClose","onPromptClose","desc","onKeyUp","onPromptKeyUp","onKeyDown","onPromptKeyDown","word","expandWordUnderCursor","isKeyword","getLine","end","escapeRegex","ignoreCase","smartCase","updateSearchQuery","showConfirm","scrollTo","left","top","logSearchQuery","close","keyName","parsedQuery","target","selectionEnd","selectionStart","Math","min","scrollIntoView","findNext","clearSearchHighlight","e_stop","focus","exArgs","selectValueOnOpen","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","newHead","newAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","ranges","lineLength","tmp","exclusive","expandSelectionToLine","clipToLine","setSelections","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","floor","moveToBottomLine","expandToLine","_cm","cur","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","to","subMode","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","posV","findPosV","hasMarkedText","moveToStartOfLine","charCoords","res","hitSide","lastCharCoords","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","lineText","symbol","style","getTokenTypeAt","re","matched","findMatchingBracket","bracketRegex","moveToLineOrEdgeOfDocument","lineNum","moveToStartOfDisplayLine","execCommand","moveToEndOfDisplayLine","sticky","textObjectManipulation","mirroredPairs","(",")","{","}","[","]","<",">","selfPaired","'","\"","`","selectCompanionObject","findBeginningAndEnd","expandTagUnderCursor","content","getSentence","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fn","fillArray","times","change","args","finalHead","Number","MAX_VALUE","setSelection","getSelection","replaceSelection","replacement","replaceSelections","getRange","lastState","prevLineEnd","wasLastLine","commands","newlineAndIndent","delete","indent","indentMore","indentLess","startLine","endLine","indentLine","indentAuto","_args","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","height","y","lineLastCharPos","lineLastCharCoords","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","max","getLastEditPos","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","undo","repeatFn","redo","setRegister","setMark","markName","replaceWith","replaceTo","replaceWithStr","incrementNumberToken","lineStr","numberStr","baseStr","digits","base","0b","0","","0x","number","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","call","cur3","cur1before2","cur2before3","trim","s","column","clipPos","isClipped","curHead","primIndex","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","width","headOffset","anchorOffset","fromCh","toCh","getHead","moveHead","selection","lines","firstNonWS","search","_forward","noSymbol","wordStart","findMatchingTag","findEnclosingTag","tags","open","symbolToMode","*","/","m","M","#","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","found","method","preprocess","token","lineCount","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","nextChar","curr","ln","lastSentencePos","reverse","curr_index","last_valid","skip_empty_lines","bracketRegexp","openSym","curChar","scanForBracket","chars","len","firstIndex","SearchState","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","\\n","\\r","\\t","translateRegexReplace","unescapes","\\/","\\\\","\\&","unescapeRegexReplace","stream","StringStream","output","eol","peek","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","regexp","document","createElement","a","createTextNode","nodeType","appendChild","Object","setAttribute","pre","$color","$whiteSpace","openNotification","duration","alert","innerText","makePrompt","createDocumentFragment","$fontFamily","autocorrect","autocapitalize","spellcheck","shortText","textContent","prompt","regexEqual","r1","r2","props","rawQuery","source","matchSol","sol","backUp","skipToEnd","searchState","removeOverlay","addOverlay","showMatchesOnScrollbar","lastEndPos","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","done","doc","history","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","commandName","parseInput_","matchCommand_","parseCommandArgs_","toInput","result","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","pattern","parseArgs","eatSpace","opts","decimal","hex","octal","err","lineStart","radix","numPart","textPart","matchPart","comparePatternFn","compareFn","textOld","b","anum","bnum","vglobal","global","inverted","matchedLines","getLineHandle","nextCommand","getLineNumber","substitute","replacePart","trailing","count","confirm","startPos","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","lastPos","modifiedLineNumber","joined","replaceAll","newText","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","insertModeChangeRegister","lastChange","logInsertModeChange","extra","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","somethingSelected","onKeyFound","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","cloneVimState","constructor","forEach","o","isArray","isHandled","wasInVisualBlock","wasMultiselect","isInMultiSelectMode","status","inVirtualSelectionMode","old","forEachSelection","virtualSelection","cursorActivity","insert","detach","fallthrough","initVim","CodeMirror5","Vim"],"mappings":"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","sourcesContent":["(function(mod) {\n    if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n      mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n    else if (typeof define == \"function\" && define.amd) // AMD\n      define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n    else // Plain browser env\n      mod(CodeMirror);\n  })(function(CodeMirror) {\n    'use strict';\n  // CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\nfunction initVim$1(CodeMirror) {\n\n  var Pos = CodeMirror.Pos;\n\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head)  return range.head;\n\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch)\n        return new Pos(range.head.line, range.head.ch - 1);\n    }\n\n    return range.head;\n  }\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    {keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\"},\n    {keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    {keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n      if (highlightTimeout) clearTimeout(highlightTimeout);\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp) cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = vimApi.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/']);\n    var upperCaseChars;\n    try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n    catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n            this.onRecordingDone = cm.openDialog(template, null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      enterVimMode: enterVimMode,\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      multiSelectHandleKey: multiSelectHandleKey,\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            if (vim.visualMode) {\n              // Get back to normal mode.\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              // Get back to normal mode.\n              exitInsertMode(cm);\n            } else {\n              // We're already in normal mode. Let '<Esc>' be handled normally.\n              return;\n            }\n            clearInputState(cm);\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n          else if (match.type == 'clear') { clearInputState(cm); return true; }\n\n          vim.inputState.keyBuffer = '';\n          keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!vimApi.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character || character.length > 1) return {type: 'clear'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: '(JavaScript regexp)',\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n          clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n\n        // next: [from, to] | null\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n        // No matches.\n        if (!next) {\n          return;\n        }\n\n        // If there's an operator that will be executed, return the selection.\n        if (prevInputState.operator) {\n          return next;\n        }\n\n        // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n        var from = next[0];\n        // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n        var to = new Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n          }\n\n          // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n          var anchor = vim.sel.anchor;\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        }\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last){\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n        return new Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return new Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(new Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return new Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      moveToStartOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n      },\n      moveToEndOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\") head.ch--;\n        return head;\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else if (character === 's') {\n          // account for cursor on end of sentence symbol\n          var content = cm.getLine(head.line);\n          if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n            head.ch -= 1;\n          }\n          var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n          var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n          // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n          if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n              && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n            start = {line: start.line, ch: start.ch + 1};\n          }\n          tmp = {start: start, end: end};\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          for (var j = 0; j < repeat; j++) {\n            if (args.indentRight) cm.indentMore();\n            else cm.indentLess();\n          }\n        } else {\n          var startLine = ranges[0].anchor.line;\n          var endLine = vim.visualBlock ?\n            ranges[ranges.length - 1].anchor.line :\n            ranges[0].head.line;\n          // In visual mode, n> shifts the selection right n times, instead of\n          // shifting n lines right once.\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          if (args.linewise) {\n            // The only way to delete a newline is to delete until the start of\n            // the next line, so in linewise mode evalInput will include the next\n            // line. We don't want this in indent, so we go back a line.\n            endLine--;\n          }\n          for (var i = startLine; i <= endLine; i++) {\n            for (var j = 0; j < repeat; j++) {\n              cm.indentLine(i, args.indentRight);\n            }\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n          case 'center': y = charCoords.bottom - height / 2;\n            break;\n          case 'bottom':\n            var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n            var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n            var lineHeight = lineLastCharCoords.bottom - y;\n            y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = new Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = new Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch, sel.anchor.ch) + 1);\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = new Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces\n            ? text.replace(/\\n\\r?/g, '')\n            : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = new Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n              text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  new Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, new Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = new Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = new Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = new Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = new Pos(cur.line, start);\n          var to = new Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return new Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return new Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(new Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = new Pos(i, selectionStart.ch);\n            var head = new Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = new Pos(selectionStart.line, 0);\n            selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            fromCh = anchor.ch,\n            bottom = Math.max(anchor.line, head.line),\n            toCh = head.ch;\n        if (fromCh < toCh) { toCh += 1; }\n        else { fromCh += 1; }        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: new Pos(top + i, fromCh),\n            head: new Pos(top + i, toCh)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n    }\n\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n      if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n      }\n\n      if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n      }\n      return { start: tags.open.to, end: tags.close.from };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return new Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end=cm.clipPos(retval);\n      end.ch--;\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n      }\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return new Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, new Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the pos member to represent the\n    next valid position or sets the line to null if there are\n    no more valid positions.\n   */\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n          curr.line = null;\n        }\n      else {\n        curr.pos += curr.dir;\n      }\n    }\n    /*\n    Performs one iteration of traversal in forward direction\n    Returns an index object of the new location\n   */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: curr.pos + 1 };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null ) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return { ln: curr.ln, pos: lastSentencePos + 1, };\n          }\n        }\n        nextChar(curr);\n      }\n      return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n\n    /*\n    Performs one iteration of traversal in reverse direction\n    Returns an index object of the new location\n   */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        }\n\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: lastSentencePos };\n          } else {\n              if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                return { ln: curr.ln, pos: curr.pos + 1, };\n              } else {\n                return {ln: curr.ln, pos: lastSentencePos};\n              }\n          }\n        }\n\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return { ln: curr.ln, pos: curr.pos };\n      } else {\n        return { ln: curr.ln, pos: lastSentencePos };\n      }\n\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the line, ln, and pos members to represent the\n    next valid position or sets them to null if there are\n    no more valid positions.\n   */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos };\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n      return regexp;\n    }\n\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);\n        else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n      }\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n      if (cm.openNotification) {\n        cm.openNotification(pre, {bottom: true, duration: 5000});\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom(document.createDocumentFragment(),\n               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre'},\n                 prefix,\n                 dom('input', {type: 'text', autocorrect: 'off',\n                               autocapitalize: 'off', spellcheck: 'false'})),\n               desc && dom('span', {$color: '#888'}, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var template = makePrompt(options.prefix, options.desc);\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n          bottom: true, selectValueOnOpen: false, value: options.value\n        });\n      }\n      else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n        if (options.desc) shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        if (!cm.state.vim) return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                found = cursor.find(prev);\n            }\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        // Go back one result to ensure that if the cursor is currently a match, we keep it.\n        var found = cursor.find(!prev);\n\n        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return [cursor.from(), cursor.to()];\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return true;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n        }\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLineHandle(i);\n          var matched = query.test(line.text);\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? line : line.text);\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var line = matchedLines[index++];\n            var lineNum = cm.getLineNumber(line);\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n            var command = (lineNum + 1) + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n        return match;\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(findNextValidMatch() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            cm.replaceSelection(change);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n            cm.setCursor(end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    // multiselect support\n    function cloneVimState(state) {\n      var n = new state.constructor();\n      Object.keys(state).forEach(function(key) {\n        var o = state[key];\n        if (Array.isArray(o))\n          o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n          o = cloneVimState(o);\n        n[key] = o;\n      });\n      if (state.sel) {\n        n.sel = {\n          head: state.sel.head && copyCursor(state.sel.head),\n          anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n      }\n      return n;\n    }\n    function multiSelectHandleKey(cm, key, origin) {\n      var isHandled = false;\n      var vim = vimApi.maybeInitVimState_(cm);\n      var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n      var wasMultiselect = cm.isInMultiSelectMode();\n      if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n      } else if (wasMultiselect && vim.visualBlock) {\n         vim.wasInVisualBlock = true;\n      }\n\n      if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n        // allow editor to exit multiselect\n        clearInputState(cm);\n      } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n      } else {\n        var old = cloneVimState(vim);\n\n        cm.operation(function() {\n          cm.curOp.isVimOp = true;\n          cm.forEachSelection(function() {\n            var head = cm.getCursor(\"head\");\n            var anchor = cm.getCursor(\"anchor\");\n            var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n            var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n            head = offsetCursor(head, 0, headOffset);\n            anchor = offsetCursor(anchor, 0, anchorOffset);\n            cm.state.vim.sel.head = head;\n            cm.state.vim.sel.anchor = anchor;\n\n            isHandled = vimApi.handleKey(cm, key, origin);\n            if (cm.virtualSelection) {\n              cm.state.vim = cloneVimState(old);\n            }\n          });\n          if (cm.curOp.cursorActivity && !isHandled)\n            cm.curOp.cursorActivity = false;\n          cm.state.vim = vim;\n        }, true);\n      }\n      // some commands may bring visualMode and selection out of sync\n      if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim);\n      }\n      return isHandled;\n    }\n    resetVimGlobalState();\n\n  return vimApi;\n}\n\nfunction initVim(CodeMirror5) {\r\n  CodeMirror5.Vim = initVim$1(CodeMirror5);\r\n  return CodeMirror5.Vim;\r\n}\n\n\n\n    CodeMirror.Vim = initVim(CodeMirror);\n  });\n  "],"file":"vim.js"}
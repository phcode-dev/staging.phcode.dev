{"version":3,"sources":["thirdparty/CodeMirror/mode/commonlisp/commonlisp.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","specialForm","assumeBody","numLiteral","symbol","type","readSym","stream","ch","next","test","backUp","current","base","state","eatSpace","match","tokenize","inString","skipToEnd","skipTo","inComment","name","charAt","lastType","escaped","last","startState","ctx","prev","start","indentTo","token","sol","style","indentUnit","column","indent","_textAfter","i","closeBrackets","pairs","lineComment","fold","blockCommentStart","blockCommentEnd","defineMIME"],"mappings":"CAGA,SAAUA,KACc,iBAAXC,SAAwC,iBAAVC,OACvCF,IAAIG,QAAQ,yBACY,mBAAVC,QAAwBA,OAAOC,IAC7CD,OAAO,CAAC,wBAAyBJ,KAEjCA,IAAIM,YANR,CAOG,SAASA,YACZ,aAEAA,WAAWC,WAAW,aAAc,SAAUC,QAC5C,IAAIC,YAAc,8NACdC,WAAa,wDACbC,WAAa,yHACbC,OAAS,oBACTC,KAEJ,SAASC,QAAQC,QAEf,IADA,IAAIC,GACGA,GAAKD,OAAOE,QACjB,GAAU,MAAND,GAAYD,OAAOE,YAClB,IAAKL,OAAOM,KAAKF,IAAK,CAAED,OAAOI,OAAO,GAAI,MAEjD,OAAOJ,OAAOK,UAGhB,SAASC,KAAKN,OAAQO,OACpB,GAAIP,OAAOQ,WAA0B,OAAbV,KAAO,KAAa,KAC5C,GAAIE,OAAOS,MAAMb,YAAa,MAAO,SACrC,IAAIK,GAYEA,GATN,GAFU,OADNA,GAAKD,OAAOE,UACAD,GAAKD,OAAOE,QAElB,KAAND,GAAW,OAAQM,MAAMG,SAAWC,UAAUX,OAAQO,OACrD,GAAU,KAANN,GAA4B,OAAfH,KAAO,OAAe,UACvC,GAAU,KAANG,IAAmB,KAANA,GAA6B,OAAhBH,KAAO,QAAgB,UACrD,GAAU,KAANG,GAA8C,OAAjCD,OAAOY,YAAad,KAAO,KAAa,UACzD,GAAI,SAASK,KAAKF,IAAK,OAAO,KAC9B,GAAU,KAANA,GACP,OAAID,OAAOa,OAAO,MAAQb,OAAOE,OAAe,WACzCF,OAAOY,YAAoB,SAC7B,GAAU,KAANX,GAET,MAAU,MADNA,GAAKD,OAAOE,SACCJ,KAAO,OAAe,WAC9B,YAAYK,KAAKF,IAAY,KAC7B,KAAKE,KAAKF,KAAOD,OAAOS,MAAM,SAAiB,KACzC,KAANR,IAAmBM,MAAMG,SAAWI,WAAWd,OAAQO,OACjD,KAANN,IAAaF,QAAQC,QAAgB,QAC/B,MAANC,IAAcD,OAAOE,OAAQH,QAAQC,QAAgB,YAClD,QAEZ,IAAIe,KAAOhB,QAAQC,QACnB,MAAY,KAARe,KAAoB,MACxBjB,KAAO,SACK,OAARiB,MAAyB,KAARA,MAAiC,KAAlBA,KAAKC,OAAO,GAAkB,OAC5C,QAAlBT,MAAMU,WAAuBvB,YAAYS,KAAKY,OAASpB,WAAWQ,KAAKY,OAAe,UACpE,KAAlBA,KAAKC,OAAO,GAAkB,aAC3B,YAIX,SAASL,SAASX,OAAQO,OAExB,IADA,IAAIW,SAAU,EAAOhB,KACdA,KAAOF,OAAOE,QAAQ,CAC3B,GAAY,KAARA,OAAgBgB,QAAS,CAAEX,MAAMG,SAAWJ,KAAM,MACtDY,SAAWA,SAAmB,MAARhB,KAExB,MAAO,SAGT,SAASY,UAAUd,OAAQO,OAEzB,IADA,IAAIL,KAAMiB,KACHjB,KAAOF,OAAOE,QAAQ,CAC3B,GAAY,KAARA,MAAuB,KAARiB,KAAa,CAAEZ,MAAMG,SAAWJ,KAAM,MACzDa,KAAOjB,KAGT,OADAJ,KAAO,KACA,UAGT,MAAO,CACLsB,WAAY,WACV,MAAO,CAACC,IAAK,CAACC,KAAM,KAAMC,MAAO,EAAGC,SAAU,GAAIP,SAAU,KAAMP,SAAUJ,OAG9EmB,MAAO,SAAUzB,OAAQO,OACnBP,OAAO0B,OAAsC,iBAAtBnB,MAAMc,IAAIG,WACnCjB,MAAMc,IAAIG,SAAWjB,MAAMc,IAAIE,MAAQ,GAEzCzB,KAAO,KACP,IAAI6B,MAAQpB,MAAMG,SAASV,OAAQO,OAcnC,MAbY,MAART,OACwB,MAAtBS,MAAMc,IAAIG,SACA,UAAR1B,MAAoBH,WAAWQ,KAAKH,OAAOK,WAC7CE,MAAMc,IAAIG,SAAWjB,MAAMc,IAAIE,MAAQ9B,OAAOmC,WAE9CrB,MAAMc,IAAIG,SAAW,OACQ,QAAtBjB,MAAMc,IAAIG,WACnBjB,MAAMc,IAAIG,SAAWxB,OAAO6B,UAE9BtB,MAAMU,SAAWnB,MAEP,QAARA,KAAgBS,MAAMc,IAAM,CAACC,KAAMf,MAAMc,IAAKE,MAAOvB,OAAO6B,SAAUL,SAAU,MACnE,SAAR1B,OAAiBS,MAAMc,IAAMd,MAAMc,IAAIC,MAAQf,MAAMc,KACvDM,OAGTG,OAAQ,SAAUvB,MAAOwB,YACvB,IAAIC,EAAIzB,MAAMc,IAAIG,SAClB,MAAmB,iBAALQ,EAAgBA,EAAIzB,MAAMc,IAAIE,MAAQ,GAGtDU,cAAe,CAACC,MAAO,YACvBC,YAAa,KACbC,KAAM,cACNC,kBAAmB,KACnBC,gBAAiB,QAIrB/C,WAAWgD,WAAW,qBAAsB","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"commonlisp\", function (config) {\n  var specialForm = /^(block|let*|return-from|catch|load-time-value|setq|eval-when|locally|symbol-macrolet|flet|macrolet|tagbody|function|multiple-value-call|the|go|multiple-value-prog1|throw|if|progn|unwind-protect|labels|progv|let|quote)$/;\n  var assumeBody = /^with|^def|^do|^prog|case$|^cond$|bind$|when$|unless$/;\n  var numLiteral = /^(?:[+\\-]?(?:\\d+|\\d*\\.\\d+)(?:[efd][+\\-]?\\d+)?|[+\\-]?\\d+(?:\\/[+\\-]?\\d+)?|#b[+\\-]?[01]+|#o[+\\-]?[0-7]+|#x[+\\-]?[\\da-f]+)/;\n  var symbol = /[^\\s'`,@()\\[\\]\";]/;\n  var type;\n\n  function readSym(stream) {\n    var ch;\n    while (ch = stream.next()) {\n      if (ch == \"\\\\\") stream.next();\n      else if (!symbol.test(ch)) { stream.backUp(1); break; }\n    }\n    return stream.current();\n  }\n\n  function base(stream, state) {\n    if (stream.eatSpace()) {type = \"ws\"; return null;}\n    if (stream.match(numLiteral)) return \"number\";\n    var ch = stream.next();\n    if (ch == \"\\\\\") ch = stream.next();\n\n    if (ch == '\"') return (state.tokenize = inString)(stream, state);\n    else if (ch == \"(\") { type = \"open\"; return \"bracket\"; }\n    else if (ch == \")\" || ch == \"]\") { type = \"close\"; return \"bracket\"; }\n    else if (ch == \";\") { stream.skipToEnd(); type = \"ws\"; return \"comment\"; }\n    else if (/['`,@]/.test(ch)) return null;\n    else if (ch == \"|\") {\n      if (stream.skipTo(\"|\")) { stream.next(); return \"symbol\"; }\n      else { stream.skipToEnd(); return \"error\"; }\n    } else if (ch == \"#\") {\n      var ch = stream.next();\n      if (ch == \"(\") { type = \"open\"; return \"bracket\"; }\n      else if (/[+\\-=\\.']/.test(ch)) return null;\n      else if (/\\d/.test(ch) && stream.match(/^\\d*#/)) return null;\n      else if (ch == \"|\") return (state.tokenize = inComment)(stream, state);\n      else if (ch == \":\") { readSym(stream); return \"meta\"; }\n      else if (ch == \"\\\\\") { stream.next(); readSym(stream); return \"string-2\" }\n      else return \"error\";\n    } else {\n      var name = readSym(stream);\n      if (name == \".\") return null;\n      type = \"symbol\";\n      if (name == \"nil\" || name == \"t\" || name.charAt(0) == \":\") return \"atom\";\n      if (state.lastType == \"open\" && (specialForm.test(name) || assumeBody.test(name))) return \"keyword\";\n      if (name.charAt(0) == \"&\") return \"variable-2\";\n      return \"variable\";\n    }\n  }\n\n  function inString(stream, state) {\n    var escaped = false, next;\n    while (next = stream.next()) {\n      if (next == '\"' && !escaped) { state.tokenize = base; break; }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return \"string\";\n  }\n\n  function inComment(stream, state) {\n    var next, last;\n    while (next = stream.next()) {\n      if (next == \"#\" && last == \"|\") { state.tokenize = base; break; }\n      last = next;\n    }\n    type = \"ws\";\n    return \"comment\";\n  }\n\n  return {\n    startState: function () {\n      return {ctx: {prev: null, start: 0, indentTo: 0}, lastType: null, tokenize: base};\n    },\n\n    token: function (stream, state) {\n      if (stream.sol() && typeof state.ctx.indentTo != \"number\")\n        state.ctx.indentTo = state.ctx.start + 1;\n\n      type = null;\n      var style = state.tokenize(stream, state);\n      if (type != \"ws\") {\n        if (state.ctx.indentTo == null) {\n          if (type == \"symbol\" && assumeBody.test(stream.current()))\n            state.ctx.indentTo = state.ctx.start + config.indentUnit;\n          else\n            state.ctx.indentTo = \"next\";\n        } else if (state.ctx.indentTo == \"next\") {\n          state.ctx.indentTo = stream.column();\n        }\n        state.lastType = type;\n      }\n      if (type == \"open\") state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};\n      else if (type == \"close\") state.ctx = state.ctx.prev || state.ctx;\n      return style;\n    },\n\n    indent: function (state, _textAfter) {\n      var i = state.ctx.indentTo;\n      return typeof i == \"number\" ? i : state.ctx.start + 1;\n    },\n\n    closeBrackets: {pairs: \"()[]{}\\\"\\\"\"},\n    lineComment: \";;\",\n    fold: \"brace-paren\",\n    blockCommentStart: \"#|\",\n    blockCommentEnd: \"|#\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-common-lisp\", \"commonlisp\");\n\n});\n"],"file":"commonlisp.js"}
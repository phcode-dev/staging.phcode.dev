{"version":3,"sources":["filesystem/Directory.js"],"names":["define","require","exports","module","FileSystemEntry","Directory","fullPath","fileSystem","this","_isDirectory","call","_applyAllCallbacks","callbacks","args","length","callback","pop","apply","undefined","prototype","Object","create","constructor","parentClass","_contents","_contentsStats","_contentsStatsErrors","_clearCachedData","preserveImmediateChildren","forEach","child","dirPath","_fileSystem","_index","visitAll","entry","parentPath","getContents","_contentsCallbacks","push","_impl","readdir","err","names","stats","contents","contentsStats","contentsStatsErrors","watched","_isWatched","name","index","entryPath","entryStats","_indexFilter","isFile","getFileForPath","getDirectoryForPath","_stat","currentCallbacks","callbackArgs","bind","_beginChange","mkdir","_path","stat","_endChange","parent","_handleDirectoryChange","added","removed","_fireChangeEvent"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var FileSystemEntry = require(\"filesystem/FileSystemEntry\");\n\n    /*\n     * Model for a file system Directory.\n     *\n     * This class should *not* be instantiated directly. Use FileSystem.getDirectoryForPath,\n     * FileSystem.resolve, or Directory.getContents to create an instance of this class.\n     *\n     * Note: Directory.fullPath always has a trailing slash.\n     *\n     * See the FileSystem class for more details.\n     *\n     * @constructor\n     * @param {!string} fullPath The full path for this Directory.\n     * @param {!FileSystem} fileSystem The file system associated with this Directory.\n     */\n    function Directory(fullPath, fileSystem) {\n        this._isDirectory = true;\n        FileSystemEntry.call(this, fullPath, fileSystem);\n    }\n\n    Directory.prototype = Object.create(FileSystemEntry.prototype);\n    Directory.prototype.constructor = Directory;\n    Directory.prototype.parentClass = FileSystemEntry.prototype;\n\n    /**\n     * The contents of this directory. This \"private\" property is used by FileSystem.\n     * @type {Array<FileSystemEntry>}\n     */\n    Directory.prototype._contents = null;\n\n    /**\n     * The stats for the contents of this directory, such that this._contentsStats[i]\n     * corresponds to this._contents[i].\n     * @type {Array.<FileSystemStats>}\n     */\n    Directory.prototype._contentsStats = null;\n\n    /**\n     * The stats errors for the contents of this directory.\n     * @type {object.<string: string>} fullPaths are mapped to FileSystemError strings\n     */\n    Directory.prototype._contentsStatsErrors = null;\n\n    /**\n     * Clear any cached data for this directory. By default, we clear the contents\n     * of immediate children as well, because in some cases file watchers fail\n     * provide precise change notifications. (Sometimes, like after a \"git\n     * checkout\", they just report that some directory has changed when in fact\n     * many of the file within the directory have changed.\n     *\n     * @private\n     * @param {boolean=} preserveImmediateChildren\n     */\n    Directory.prototype._clearCachedData = function (preserveImmediateChildren) {\n        FileSystemEntry.prototype._clearCachedData.apply(this);\n\n        if (!preserveImmediateChildren) {\n            if (this._contents) {\n                this._contents.forEach(function (child) {\n                    child._clearCachedData(true);\n                });\n            } else {\n                // No cached _contents, but child entries may still exist.\n                // Scan the full index to catch all of them.\n                var dirPath = this.fullPath;\n                this._fileSystem._index.visitAll(function (entry) {\n                    if (entry.parentPath === dirPath) {\n                        entry._clearCachedData(true);\n                    }\n                });\n            }\n        }\n\n        this._contents = undefined;\n        this._contentsStats = undefined;\n        this._contentsStatsErrors = undefined;\n    };\n\n    /**\n     * Apply each callback in a list to the provided arguments. Callbacks\n     * can throw without preventing other callbacks from being applied.\n     *\n     * @private\n     * @param {Array.<function>} callbacks The callbacks to apply\n     * @param {Array} args The arguments to which each callback is applied\n     */\n    function _applyAllCallbacks(callbacks, args) {\n        if (callbacks.length > 0) {\n            var callback = callbacks.pop();\n            try {\n                callback.apply(undefined, args);\n            } finally {\n                _applyAllCallbacks(callbacks, args);\n            }\n        }\n    }\n\n    /**\n     * Read the contents of a Directory. If this Directory is under a watch root,\n     * the listing will exclude any items filtered out by the watch root's filter\n     * function.\n     *\n     * @param {Directory} directory Directory whose contents you want to get\n     * @param {function (?string, Array.<FileSystemEntry>=, Array.<FileSystemStats>=, Object.<string, string>=)} callback\n     *          Callback that is passed an error code or the stat-able contents\n     *          of the directory along with the stats for these entries and a\n     *          fullPath-to-FileSystemError string map of unstat-able entries\n     *          and their stat errors. If there are no stat errors then the last\n     *          parameter shall remain undefined.\n     */\n    Directory.prototype.getContents = function (callback) {\n        if (this._contentsCallbacks) {\n            // There is already a pending call for this directory's contents.\n            // Push the new callback onto the stack and return.\n            this._contentsCallbacks.push(callback);\n            return;\n        }\n\n        // Return cached contents if the directory is watched\n        if (this._contents) {\n            callback(null, this._contents, this._contentsStats, this._contentsStatsErrors);\n            return;\n        }\n\n        this._contentsCallbacks = [callback];\n\n        this._impl.readdir(this.fullPath, function (err, names, stats) {\n            var contents = [],\n                contentsStats = [],\n                contentsStatsErrors;\n\n            if (err) {\n                this._clearCachedData();\n            } else {\n                // Use the \"relaxed\" parameter to _isWatched because it's OK to\n                // cache data even while watchers are still starting up\n                var watched = this._isWatched(true);\n\n                names.forEach(function (name, index) {\n                    var entryPath = this.fullPath + name;\n\n                    var entryStats = stats[index];\n                    if (this._fileSystem._indexFilter(entryPath, name, entryStats)) {\n                        var entry;\n\n                        // Note: not all entries necessarily have associated stats.\n                        if (typeof entryStats === \"string\") {\n                            // entryStats is an error string\n                            if (contentsStatsErrors === undefined) {\n                                contentsStatsErrors = {};\n                            }\n                            contentsStatsErrors[entryPath] = entryStats;\n                        } else {\n                            // entryStats is a FileSystemStats object\n                            if (entryStats.isFile) {\n                                entry = this._fileSystem.getFileForPath(entryPath);\n                            } else {\n                                entry = this._fileSystem.getDirectoryForPath(entryPath);\n                            }\n\n                            if (watched) {\n                                entry._stat = entryStats;\n                            }\n\n                            contents.push(entry);\n                            contentsStats.push(entryStats);\n                        }\n                    }\n                }, this);\n\n                if (watched) {\n                    this._contents = contents;\n                    this._contentsStats = contentsStats;\n                    this._contentsStatsErrors = contentsStatsErrors;\n                }\n            }\n\n            // Reset the callback list before we begin calling back so that\n            // synchronous reentrant calls are handled correctly.\n            var currentCallbacks = this._contentsCallbacks;\n\n            this._contentsCallbacks = null;\n\n            // Invoke all saved callbacks\n            var callbackArgs = [err, contents, contentsStats, contentsStatsErrors];\n            _applyAllCallbacks(currentCallbacks, callbackArgs);\n        }.bind(this));\n    };\n\n    /**\n     * Create a directory\n     *\n     * @param {function (?string, FileSystemStats=)=} callback Callback resolved with a\n     *      FileSystemError string or the stat object for the created directory.\n     */\n    Directory.prototype.create = function (callback) {\n        callback = callback || function () {};\n\n        // Block external change events until after the write has finished\n        this._fileSystem._beginChange();\n\n        this._impl.mkdir(this._path, function (err, stat) {\n            if (err) {\n                this._clearCachedData();\n                try {\n                    callback(err);\n                    return;\n                } finally {\n                    // Unblock external change events\n                    this._fileSystem._endChange();\n                }\n            }\n\n            var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\n\n            // Update internal filesystem state\n            if (this._isWatched()) {\n                this._stat = stat;\n            }\n\n            this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\n                try {\n                    callback(null, stat);\n                } finally {\n                    if (parent._isWatched()) {\n                        this._fileSystem._fireChangeEvent(parent, added, removed);\n                    }\n                    // Unblock external change events\n                    this._fileSystem._endChange();\n                }\n            }.bind(this));\n        }.bind(this));\n    };\n\n    // Export this class\n    module.exports = Directory;\n});\n"],"file":"Directory.js"}
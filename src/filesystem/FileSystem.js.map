{"version":3,"sources":["filesystem/FileSystem.js"],"names":["define","require","exports","module","Directory","File","FileIndex","FileSystemError","RemoteFile","WatchedRoot","EventDispatcher","PathUtils","_","_fileProtocolPlugins","MAX_DEDUPE_NUMBER","registerProtocolAdapter","protocol","adapter","adapters","push","sort","a","b","priority","_getProtocolAdapter","filePath","protocolAdapters","selectedAdapter","forEach","canRead","FileSystem","this","_index","_watchedRoots","_watchRequests","_externalChanges","_ensureTrailingSlash","path","length","makeEventDispatcher","prototype","_impl","_activeChangeCount","_getActiveChangeCount","_triggerExternalChangesNow","info","_handleExternalChange","stat","_enqueueExternalChange","_dequeueWatchRequest","request","fn","call","callbackArgs","arguments","cb","apply","shift","bind","_enqueueWatchRequest","_findWatchedRootForPath","fullPath","watchedRoot","Object","keys","some","watchedPath","indexOf","_watchOrUnwatchEntry","entry","callback","shouldWatch","impl","recursiveWatch","commandName","filterGlobs","requestCb","entriesToWatch","visitor","child","filter","name","parentPath","isDirectory","visit","err","count","watchCallback","watchPath","unwatchPath","_watchEntry","_unwatchEntry","visitAll","_clearCachedData","init","console","assert","changeCallback","offlineCallback","_unwatchAll","initWatchers","close","unwatchAll","clear","alwaysIndex","doNotRemoveFromIndex","_indexFilter","parentRoot","_beginChange","_endChange","error","isAbsolutePath","_DUPLICATED_SLASH_RE","_instance","_getNewPath","suggestedPath","isDir","i","pathLib","normalize","dir","dirname","extName","extname","baseName","basename","join","_wrap","func","_normalizePath","Error","isUNCPath","normalizeUNCPaths","search","replace","segments","split","splice","addEntryForPathIfRequired","fileEntry","getEntry","addEntry","_getEntryForPath","EntryConstructor","getFileForPath","parseUrl","protocolAdapter","fileImpl","copy","src","dst","self","async","target","isFile","parentDir","window","realPath","getDirectoryForPath","_handleDirectoryChange","added","removed","_isWatched","_fireChangeEvent","getFreePath","newPath","exists","existsAsync","TOO_MANY_ENTRIES","NOT_FOUND","resolve","normalizedPath","item","_stat","resolveAsync","Promise","reject","showOpenDialog","allowMultipleSelection","chooseDirectories","title","initialPath","fileTypes","showSaveDialog","proposedNewFilename","_fireRenameEvent","oldPath","trigger","_handleRename","oldFullPath","newFullPath","entryRenamed","directory","oldContents","_contents","getContents","contents","addedEntries","removedEntries","addedCounter","removedCounter","counter","watchOrUnwatchCallback","oldStat","mtime","getTime","clearAllCaches","watch","watchingParentRoot","status","STARTING","ACTIVE","watchingChildRoot","warn","unwatch","INACTIVE","removeEntry","ROOT_NOT_WATCHED","on","event","handler","off","_FileSystem","HTTP_PROTOCOL","HTTPS_PROTOCOL"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * FileSystem is a model object representing a complete file system. This object creates\n * and manages File and Directory instances, dispatches events when the file system changes,\n * and provides methods for showing 'open' and 'save' dialogs.\n *\n * FileSystem automatically initializes when loaded. It depends on a pluggable \"impl\" layer, which\n * it loads itself but must be designated in the require.config() that loads FileSystem. For details\n * see: https://github.com/adobe/brackets/wiki/File-System-Implementations\n *\n * There are three ways to get File or Directory instances:\n *    * Use FileSystem.resolve() to convert a path to a File/Directory object. This will only\n *      succeed if the file/directory already exists.\n *    * Use FileSystem.getFileForPath()/FileSystem.getDirectoryForPath() if you know the\n *      file/directory already exists, or if you want to create a new entry.\n *    * Use Directory.getContents() to return all entries for the specified Directory.\n *\n * All paths passed *to* FileSystem APIs must be in the following format:\n *    * The path separator is \"/\" regardless of platform\n *    * Paths begin with \"/\" on Mac/Linux and \"c:/\" (or some other drive letter) on Windows\n *\n * All paths returned *from* FileSystem APIs additionally meet the following guarantees:\n *    * No \"..\" segments\n *    * No consecutive \"/\"s\n *    * Paths to a directory always end with a trailing \"/\"\n * (Because FileSystem normalizes paths automatically, paths passed *to* FileSystem do not need\n * to meet these requirements)\n *\n * FileSystem dispatches the following events:\n * (NOTE: attach to these events via `FileSystem.on()` - not `$(FileSystem).on()`)\n *\n * __change__ - Sent whenever there is a change in the file system. The handler\n *   is passed up to three arguments: the changed entry and, if that changed entry\n *   is a Directory, a list of entries added to the directory and a list of entries\n *   removed from the Directory. The entry argument can be:\n *   *  a File - the contents of the file have changed, and should be reloaded.\n *   *  a Directory - an immediate child of the directory has been added, removed,\n *      or renamed/moved. Not triggered for \"grandchildren\".\n *      - If the added & removed arguments are null, we don't know what was added/removed:\n *        clients should assume the whole subtree may have changed.\n *      - If the added & removed arguments are 0-length, there's no net change in the set\n *        of files but a file may have been replaced: clients should assume the contents\n *        of any immediate child file may have changed.\n *   *  null - a 'wholesale' change happened, and you should assume everything may\n *      have changed.\n *   For changes made externally, there may be a significant delay before a \"change\" event\n *   is dispatched.\n *\n * __rename__ - Sent whenever a File or Directory is renamed. All affected File and Directory\n *   objects have been updated to reflect the new path by the time this event is dispatched.\n *   This event should be used to trigger any UI updates that may need to occur when a path\n *   has changed. Note that these events will only be sent for rename operations that happen\n *   within the filesystem. If a file is renamed externally, a change event on the parent\n *   directory will be sent instead.\n *\n * FileSystem may perform caching. But it guarantees:\n *    * File contents & metadata - reads are guaranteed to be up to date (cached data is not used\n *      without first veryifying it is up to date).\n *    * Directory structure / file listing - reads may return cached data immediately, which may not\n *      reflect external changes made recently. (However, changes made via FileSystem itself are always\n *      reflected immediately, as soon as the change operation's callback signals success).\n *\n * The FileSystem doesn't directly read or write contents--this work is done by a low-level\n * implementation object. This allows client code to use the FileSystem API without having to\n * worry about the underlying storage, which could be a local filesystem or a remote server.\n */\ndefine(function (require, exports, module) {\n\n\n    const Directory       = require(\"filesystem/Directory\"),\n        File            = require(\"filesystem/File\"),\n        FileIndex       = require(\"filesystem/FileIndex\"),\n        FileSystemError = require(\"filesystem/FileSystemError\"),\n        RemoteFile      = require(\"filesystem/RemoteFile\"),\n        WatchedRoot     = require(\"filesystem/WatchedRoot\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        PathUtils       = require(\"thirdparty/path-utils/path-utils\"),\n        _               = require(\"thirdparty/lodash\");\n\n\n    // Collection of registered protocol adapters\n    let _fileProtocolPlugins = {};\n    const MAX_DEDUPE_NUMBER = 1000; // Eg: folder (copy 1000)\n\n    /**\n     * Typical signature of a file protocol adapter.\n     * @typedef {Object} FileProtocol~Adapter\n     * @property {Number} priority - Indicates the priority.\n     * @property {Object} fileImpl - Handle for the custom file implementation prototype.\n     * @property {function} canRead - To check if this impl can read a file for a given path.\n     */\n\n    /**\n     * FileSystem hook to register file protocol adapter\n     * @param {string} protocol ex: \"https:\"|\"http:\"|\"ftp:\"|\"file:\"\n     * @param {...FileProtocol~Adapter} adapter wrapper over file implementation\n     */\n    function registerProtocolAdapter(protocol, adapter) {\n        var adapters;\n        if (protocol) {\n            adapters = _fileProtocolPlugins[protocol] || [];\n            adapters.push(adapter);\n\n            // We will keep a sorted adapter list on 'priority'\n            // If priority is not provided a default of '0' is assumed\n            adapters.sort(function (a, b) {\n                return (b.priority || 0) - (a.priority || 0);\n            });\n\n            _fileProtocolPlugins[protocol] = adapters;\n        }\n    }\n\n    /**\n     * @param {string} protocol ex: \"https:\"|\"http:\"|\"ftp:\"|\"file:\"\n     * @param {string} filePath fullPath of the file\n     * @return adapter adapter wrapper over file implementation\n     */\n    function _getProtocolAdapter(protocol, filePath) {\n        var protocolAdapters = _fileProtocolPlugins[protocol] || [],\n            selectedAdapter;\n\n        // Find the fisrt compatible adapter having highest priority\n        _.forEach(protocolAdapters, function (adapter) {\n            if (adapter.canRead && adapter.canRead(filePath)) {\n                selectedAdapter = adapter;\n                // Break at first compatible adapter\n                return false;\n            }\n        });\n\n        return selectedAdapter;\n    }\n\n    /**\n     * The FileSystem is not usable until init() signals its callback.\n     * @constructor\n     */\n    function FileSystem() {\n        // Create a file index\n        this._index = new FileIndex();\n\n        // Initialize the set of watched roots\n        this._watchedRoots = {};\n\n        // Initialize the watch/unwatch request queue\n        this._watchRequests = [];\n\n        // Initialize the queue of pending external changes\n        this._externalChanges = [];\n    }\n    EventDispatcher.makeEventDispatcher(FileSystem.prototype);\n\n    /**\n     * The low-level file system implementation used by this object.\n     * This is set in the init() function and cannot be changed.\n     */\n    FileSystem.prototype._impl = null;\n\n    /**\n     * The FileIndex used by this object. This is initialized in the constructor.\n     */\n    FileSystem.prototype._index = null;\n\n    /**\n     * Refcount of any pending filesystem mutation operations (e.g., writes,\n     * unlinks, etc.). Used to ensure that external change events aren't processed\n     * until after index fixups, operation-specific callbacks, and internal change\n     * events are complete. (This is important for distinguishing rename from\n     * an unrelated delete-add pair).\n     * @type {number}\n     */\n    FileSystem.prototype._activeChangeCount = 0;\n\n    // For unit testing only\n    FileSystem.prototype._getActiveChangeCount = function () {\n        return this._activeChangeCount;\n    };\n\n    /**\n     * Queue of arguments with which to invoke _handleExternalChanges(); triggered\n     * once _activeChangeCount drops to zero.\n     * @type {!Array.<{path:?string, stat:FileSystemStats=}>}\n     */\n    FileSystem.prototype._externalChanges = null;\n\n    /** Process all queued watcher results, by calling _handleExternalChange() on each */\n    FileSystem.prototype._triggerExternalChangesNow = function () {\n        this._externalChanges.forEach(function (info) {\n            this._handleExternalChange(info.path, info.stat);\n        }, this);\n        this._externalChanges.length = 0;\n    };\n\n    /**\n     * Receives a result from the impl's watcher callback, and either processes it\n     * immediately (if _activeChangeCount is 0) or otherwise stores it for later\n     * processing.\n     * @param {?string} path The fullPath of the changed entry\n     * @param {FileSystemStats=} stat An optional stat object for the changed entry\n     */\n    FileSystem.prototype._enqueueExternalChange = function (path, stat) {\n        this._externalChanges.push({path: path, stat: stat});\n        if (!this._activeChangeCount) {\n            this._triggerExternalChangesNow();\n        }\n    };\n\n\n    /**\n     * The queue of pending watch/unwatch requests.\n     * @type {Array.<{fn: function(), cb: function()}>}\n     */\n    FileSystem.prototype._watchRequests = null;\n\n    /**\n     * Dequeue and process all pending watch/unwatch requests\n     */\n    FileSystem.prototype._dequeueWatchRequest = function () {\n        if (this._watchRequests.length > 0) {\n            var request = this._watchRequests[0];\n\n            request.fn.call(null, function () {\n                // Apply the given callback\n                var callbackArgs = arguments;\n                try {\n                    request.cb.apply(null, callbackArgs);\n                } finally {\n                    // Process the remaining watch/unwatch requests\n                    this._watchRequests.shift();\n                    this._dequeueWatchRequest();\n                }\n            }.bind(this));\n        }\n    };\n\n    /**\n     * Enqueue a new watch/unwatch request.\n     *\n     * @param {function()} fn - The watch/unwatch request function.\n     * @param {callback()} cb - The callback for the provided watch/unwatch\n     *      request function.\n     */\n    FileSystem.prototype._enqueueWatchRequest = function (fn, cb) {\n        // Enqueue the given watch/unwatch request\n        this._watchRequests.push({fn: fn, cb: cb});\n\n        // Begin processing the queue if it is not already being processed\n        if (this._watchRequests.length === 1) {\n            this._dequeueWatchRequest();\n        }\n    };\n\n    /**\n     * The set of watched roots, encoded as a mapping from full paths to WatchedRoot\n     * objects which contain a file entry, filter function, and an indication of\n     * whether the watched root is inactive, starting up or fully active.\n     *\n     * @type {Object.<string, WatchedRoot>}\n     */\n    FileSystem.prototype._watchedRoots = null;\n\n    /**\n     * Finds a parent watched root for a given path, or returns null if a parent\n     * watched root does not exist.\n     *\n     * @param {string} fullPath The child path for which a parent watched root is to be found\n     * @return {?{entry: FileSystemEntry, filter: function(string) boolean}} The parent\n     *      watched root, if it exists, or null.\n     */\n    FileSystem.prototype._findWatchedRootForPath = function (fullPath) {\n        var watchedRoot = null;\n\n        Object.keys(this._watchedRoots).some(function (watchedPath) {\n            if (fullPath.indexOf(watchedPath) === 0) {\n                watchedRoot = this._watchedRoots[watchedPath];\n                return true;\n            }\n        }, this);\n\n        return watchedRoot;\n    };\n\n    /**\n     * Helper function to watch or unwatch a filesystem entry beneath a given\n     * watchedRoot.\n     *\n     * @private\n     * @param {FileSystemEntry} entry - The FileSystemEntry to watch. Must be a\n     *      non-strict descendent of watchedRoot.entry.\n     * @param {WatchedRoot} watchedRoot - See FileSystem._watchedRoots.\n     * @param {function(?string)} callback - A function that is called once the\n     *      watch is complete, possibly with a FileSystemError string.\n     * @param {boolean} shouldWatch - Whether the entry should be watched (true)\n     *      or unwatched (false).\n     */\n    FileSystem.prototype._watchOrUnwatchEntry = function (entry, watchedRoot, callback, shouldWatch) {\n        var impl = this._impl,\n            recursiveWatch = impl.recursiveWatch,\n            commandName = shouldWatch ? \"watchPath\" : \"unwatchPath\",\n            filterGlobs = watchedRoot.filterGlobs;\n\n        if (recursiveWatch) {\n            // The impl can watch the entire subtree with one call on the root (we also fall into this case for\n            // unwatch, although that never requires us to do the recursion - see similar final case below)\n            if (entry !== watchedRoot.entry) {\n                // Watch and unwatch calls to children of the watched root are\n                // no-ops if the impl supports recursiveWatch\n                callback(null);\n            } else {\n                // The impl will handle finding all subdirectories to watch.\n                this._enqueueWatchRequest(function (requestCb) {\n                    impl[commandName].call(impl, entry.fullPath, filterGlobs, requestCb);\n                }.bind(this), callback);\n            }\n        } else if (shouldWatch) {\n            // The impl can't handle recursive watch requests, so it's up to the\n            // filesystem to recursively watch all subdirectories.\n            this._enqueueWatchRequest(function (requestCb) {\n                // First construct a list of entries to watch or unwatch\n                var entriesToWatch = [];\n\n                var visitor = function (child) {\n                    if (watchedRoot.filter(child.name, child.parentPath)) {\n                        if (child.isDirectory || child === watchedRoot.entry) {\n                            entriesToWatch.push(child);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n                entry.visit(visitor, function (err) {\n                    if (err) {\n                        // Unexpected error\n                        requestCb(err);\n                        return;\n                    }\n\n                    // Then watch or unwatched all these entries\n                    var count = entriesToWatch.length;\n                    if (count === 0) {\n                        requestCb(null);\n                        return;\n                    }\n\n                    var watchCallback = function () {\n                        if (--count === 0) {\n                            requestCb(null);\n                        }\n                    };\n\n                    entriesToWatch.forEach(function (entry) {\n                        impl.watchPath(entry.fullPath, filterGlobs, watchCallback);\n                    });\n                });\n            }, callback);\n        } else {\n            // Unwatching never requires enumerating the subfolders (which is good, since after a\n            // delete/rename we may be unable to do so anyway)\n            this._enqueueWatchRequest(function (requestCb) {\n                impl.unwatchPath(entry.fullPath, requestCb);\n            }, callback);\n        }\n    };\n\n    /**\n     * Watch a filesystem entry beneath a given watchedRoot.\n     *\n     * @private\n     * @param {FileSystemEntry} entry - The FileSystemEntry to watch. Must be a\n     *      non-strict descendent of watchedRoot.entry.\n     * @param {WatchedRoot} watchedRoot - See FileSystem._watchedRoots.\n     * @param {function(?string)} callback - A function that is called once the\n     *      watch is complete, possibly with a FileSystemError string.\n     */\n    FileSystem.prototype._watchEntry = function (entry, watchedRoot, callback) {\n        this._watchOrUnwatchEntry(entry, watchedRoot, callback, true);\n    };\n\n    /**\n     * Unwatch a filesystem entry beneath a given watchedRoot.\n     *\n     * @private\n     * @param {FileSystemEntry} entry - The FileSystemEntry to watch. Must be a\n     *      non-strict descendent of watchedRoot.entry.\n     * @param {WatchedRoot} watchedRoot - See FileSystem._watchedRoots.\n     * @param {function(?string)} callback - A function that is called once the\n     *      watch is complete, possibly with a FileSystemError string.\n     */\n    FileSystem.prototype._unwatchEntry = function (entry, watchedRoot, callback) {\n        this._watchOrUnwatchEntry(entry, watchedRoot, function (err) {\n            // Make sure to clear cached data for all unwatched entries because\n            // entries always return cached data if it exists!\n            this._index.visitAll(function (child) {\n                if (child.fullPath.indexOf(entry.fullPath) === 0) {\n                    // 'true' so entry doesn't try to clear its immediate childrens' caches too. That would be redundant\n                    // with the visitAll() here, and could be slow if we've already cleared its parent (#7150).\n                    child._clearCachedData(true);\n                }\n            }.bind(this));\n\n            callback(err);\n        }.bind(this), false);\n    };\n\n    /**\n     * Initialize this FileSystem instance.\n     *\n     * @param {FileSystemImpl} impl The back-end implementation for this\n     *      FileSystem instance.\n     */\n    FileSystem.prototype.init = function (impl) {\n        console.assert(!this._impl, \"This FileSystem has already been initialized!\");\n\n        var changeCallback = this._enqueueExternalChange.bind(this),\n            offlineCallback = this._unwatchAll.bind(this);\n\n        this._impl = impl;\n        this._impl.initWatchers(changeCallback, offlineCallback);\n    };\n\n    /**\n     * Close a file system. Clear all caches, indexes, and file watchers.\n     */\n    FileSystem.prototype.close = function () {\n        this._impl.unwatchAll();\n        this._index.clear();\n    };\n\n    /**\n     * Will never remove the given file from index. Useful if you want to always hold cache the file.\n     */\n    FileSystem.prototype.alwaysIndex = function (filePath) {\n        this._index.doNotRemoveFromIndex(filePath);\n    };\n\n    /**\n     * Returns true if the given path should be automatically added to the index & watch list when one of its ancestors\n     * is a watch-root. (Files are added automatically when the watch-root is first established, or later when a new\n     * directory is created and its children enumerated).\n     *\n     * Entries explicitly created via FileSystem.getFile/DirectoryForPath() are *always* added to the index regardless\n     * of this filtering - but they will not be watched if the watch-root's filter excludes them.\n     *\n     * @param {string} path Full path\n     * @param {string} name Name portion of the path\n     */\n    FileSystem.prototype._indexFilter = function (path, name) {\n        var parentRoot = this._findWatchedRootForPath(path);\n\n        if (parentRoot) {\n            return parentRoot.filter(name, path);\n        }\n\n        // It might seem more sensible to return false (exclude) for files outside the watch roots, but\n        // that would break usage of appFileSystem for 'system'-level things like enumerating extensions.\n        // (Or in general, Directory.getContents() for any Directory outside the watch roots).\n        return true;\n    };\n\n    /**\n     * Indicates that a filesystem-mutating operation has begun. As long as there\n     * are changes taking place, change events from the external watchers are\n     * blocked and queued, to be handled once changes have finished. This is done\n     * because for mutating operations that originate from within the filesystem,\n     * synthetic change events are fired that do not depend on external file\n     * watchers, and we prefer the former over the latter for the following\n     * reasons: 1) there is no delay; and 2) they may have higher fidelity ---\n     * e.g., a rename operation can be detected as such, instead of as a nearly\n     * simultaneous addition and deletion.\n     *\n     * All operations that mutate the file system MUST begin with a call to\n     * _beginChange and must end with a call to _endChange.\n     */\n    FileSystem.prototype._beginChange = function () {\n        this._activeChangeCount++;\n        //console.log(\"> beginChange  -> \" + this._activeChangeCount);\n    };\n\n    /**\n     * Indicates that a filesystem-mutating operation has completed. See\n     * FileSystem._beginChange above.\n     */\n    FileSystem.prototype._endChange = function () {\n        this._activeChangeCount--;\n        //console.log(\"< endChange    -> \" + this._activeChangeCount);\n\n        if (this._activeChangeCount < 0) {\n            console.error(\"FileSystem _activeChangeCount has fallen below zero!\");\n        }\n\n        if (!this._activeChangeCount) {\n            this._triggerExternalChangesNow();\n        }\n    };\n\n    /**\n     * Determines whether or not the supplied path is absolute, as opposed to relative.\n     *\n     * @param {!string} fullPath\n     * @return {boolean} True if the fullPath is absolute and false otherwise.\n     */\n    FileSystem.isAbsolutePath = function (fullPath) {\n        return (fullPath[0] === \"/\" || (fullPath[1] === \":\" && fullPath[2] === \"/\"));\n    };\n\n    function _ensureTrailingSlash(path) {\n        if (path[path.length - 1] !== \"/\") {\n            path += \"/\";\n        }\n\n        return path;\n    }\n\n    /*\n     * Matches continguous groups of forward slashes\n     * @const\n     */\n    var _DUPLICATED_SLASH_RE = /\\/{2,}/g;\n\n    /**\n     * Returns a canonical version of the path: no duplicated \"/\"es, no \"..\"s,\n     * and directories guaranteed to end in a trailing \"/\"\n     * @param {!string} path  Absolute path, using \"/\" as path separator\n     * @param {boolean=} isDirectory\n     * @return {!string}\n     */\n    FileSystem.prototype._normalizePath = function (path, isDirectory) {\n\n        if (!FileSystem.isAbsolutePath(path)) {\n            throw new Error(\"Paths must be absolute: '\" + path + \"'\");  // expect only absolute paths\n        }\n\n        var isUNCPath = this._impl.normalizeUNCPaths && path.search(_DUPLICATED_SLASH_RE) === 0;\n\n        // Remove duplicated \"/\"es\n        path = path.replace(_DUPLICATED_SLASH_RE, \"/\");\n\n        // Remove \"..\" segments\n        if (path.indexOf(\"..\") !== -1) {\n            var segments = path.split(\"/\"),\n                i;\n            for (i = 1; i < segments.length; i++) {\n                if (segments[i] === \"..\") {\n                    if (i < 2) {\n                        throw new Error(\"Invalid absolute path: '\" + path + \"'\");\n                    }\n                    segments.splice(i - 1, 2);\n                    i -= 2; // compensate so we start on the right index next iteration\n                }\n            }\n            path = segments.join(\"/\");\n        }\n\n        if (isDirectory) {\n            // Make sure path DOES include trailing slash\n            path = _ensureTrailingSlash(path);\n        }\n\n        if (isUNCPath) {\n            // Restore the leading double slash that was removed previously\n            path = \"/\" + path;\n        }\n\n        return path;\n    };\n\n    /**\n     * This method adds an entry for a file in the file Index. Files on disk are added\n     * to the file index either on load or on open. This method is primarily needed to add\n     * in memory files to the index\n     *\n     * @param {File} The fileEntry which needs to be added\n     * @param {String} The full path to the file\n     */\n    FileSystem.prototype.addEntryForPathIfRequired = function (fileEntry, path) {\n        var entry = this._index.getEntry(path);\n\n        if (!entry) {\n            this._index.addEntry(fileEntry);\n        }\n    };\n\n    /**\n     * Return a (strict subclass of a) FileSystemEntry object for the specified\n     * path using the provided constuctor. For now, the provided constructor\n     * should be either File or Directory.\n     *\n     * @private\n     * @param {function(string, FileSystem)} EntryConstructor Constructor with\n     *      which to initialize new FileSystemEntry objects.\n     * @param {string} path Absolute path of file.\n     * @return {File|Directory} The File or Directory object. This file may not\n     *      yet exist on disk.\n     */\n    FileSystem.prototype._getEntryForPath = function (EntryConstructor, path) {\n        var isDirectory = EntryConstructor === Directory;\n        path = this._normalizePath(path, isDirectory);\n        var entry = this._index.getEntry(path);\n\n        if (!entry) {\n            entry = new EntryConstructor(path, this);\n            this._index.addEntry(entry);\n        }\n\n        return entry;\n    };\n\n    /**\n     * Return a File object for the specified path.\n     *\n     * @param {string} path Absolute path of file.\n     *\n     * @return {File} The File object. This file may not yet exist on disk.\n     */\n    FileSystem.prototype.getFileForPath = function (path) {\n        var protocol = PathUtils.parseUrl(path).protocol,\n            protocolAdapter = _getProtocolAdapter(protocol);\n\n        if (protocolAdapter && protocolAdapter.fileImpl) {\n            return new protocolAdapter.fileImpl(protocol, path, this);\n        }\n        return this._getEntryForPath(File, path);\n\n    };\n\n    function _getNewPath(suggestedPath, isDir, i, pathLib) {\n        suggestedPath = pathLib.normalize(suggestedPath);\n        if(isDir){\n            return `${suggestedPath} (copy ${i})`;\n        } else {\n            const dir = pathLib.dirname(suggestedPath),\n                extName = pathLib.extname(suggestedPath),\n                baseName = pathLib.basename(suggestedPath, extName);\n            return pathLib.join(dir, `${baseName}(copy ${i})${extName}`);\n        }\n    }\n\n    /**\n     * copies a file/folder path from src to destination recursively. follows unix copy semantics mostly.\n     * As with unix copy, the destination path may not be exactly the `dst` path provided.\n     * Eg. copy(\"/a/b\", \"/a/x\") -> will copy to `/a/x/b` if folder `/a/x` exists. If dst `/a/x` not exists,\n     * then copy will honor the given destination `/a/x`\n     *\n     * @param {string} src Absolute path of file or directory to copy\n     * @param {string} dst Absolute path of file or directory destination\n     * @param {function(err, string)} callback Callback with err or stat of copied destination.\n     */\n    FileSystem.prototype.copy = function (src, dst, callback) {\n        let self = this;\n        // Block external change events until after the write has finished\n        self._beginChange();\n        self._impl.copy(src, dst, async function (err, stat) {\n            if (err) {\n                callback(err);\n                self._endChange();\n                return;\n            }\n            let target;\n            if(stat.isFile){\n                let parentDir = window.path.dirname(stat.realPath);\n                target = self.getDirectoryForPath(parentDir);\n            } else {\n                target = self.getDirectoryForPath(stat.realPath);\n            }\n            self._handleDirectoryChange(target, function (added, removed) {\n                try {\n                    callback(null, stat);\n                } finally {\n                    if (target._isWatched()) {\n                        self._fireChangeEvent(target, added, removed);\n                    }\n                    // Unblock external change events\n                    self._endChange();\n                }\n            });\n        });\n    };\n\n    /**\n     * Return a path that is free to use for the given suggestedPath.\n     * If suggestedPath is, Eg: `/a/b/dir` , then if `/a/b/dir` does not exist, it will be returned as is.\n     *\n     * if suggestedPath exists and is a dir, then the next available path will be returned like\n     * `/a/b/dir(copy)`, /a/b/dir(copy 1)`...\n     *\n     * if suggestedPath exists and is a file say `/a/b/test.html`, then the next available path will be returned like\n     * `/a/b/test (copy).html`, /a/b/test (copy 1).html`...\n     *\n     * @param {string} suggestedPath Absolute path of file or directory to check if free.\n     * @param {function(err, string)} callback Callback with err or Absolute path that is free to use.\n     */\n    FileSystem.prototype.getFreePath = function (suggestedPath, callback) {\n        let self = this;\n        self._impl.stat(suggestedPath, async function (err, stat) {\n            if (stat) {\n                // find a suggested path\n                let isDir = stat.isDirectory;\n                for(let i = 1; i < MAX_DEDUPE_NUMBER; i++) {\n                    let newPath = _getNewPath(suggestedPath, isDir, i, self._impl.pathLib);\n                    let exists = await self._impl.existsAsync(newPath);\n                    if(!exists){\n                        callback(null, newPath);\n                        return;\n                    }\n                }\n                callback(FileSystemError.TOO_MANY_ENTRIES);\n                return;\n            } else if (err && err === FileSystemError.NOT_FOUND) {\n                callback(null, suggestedPath);\n                return;\n            }\n            callback(err);\n        });\n    };\n\n    /**\n     * Return a Directory object for the specified path.\n     *\n     * @param {string} path Absolute path of directory.\n     *\n     * @return {Directory} The Directory object. This directory may not yet exist on disk.\n     */\n    FileSystem.prototype.getDirectoryForPath = function (path) {\n        return this._getEntryForPath(Directory, path);\n    };\n\n    /**\n     * Resolve a path.\n     *\n     * @param {string} path The path to resolve\n     * @param {function (?string, FileSystemEntry=, FileSystemStats=)} callback Callback resolved\n     *      with a FileSystemError string or with the entry for the provided path.\n     */\n    FileSystem.prototype.resolve = function (path, callback) {\n        var normalizedPath = this._normalizePath(path, false),\n            item = this._index.getEntry(normalizedPath);\n\n        if (!item) {\n            normalizedPath = _ensureTrailingSlash(normalizedPath);\n            item = this._index.getEntry(normalizedPath);\n        }\n\n        if (item) {\n            item.stat(function (err, stat) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n\n                callback(null, item, stat);\n            });\n        } else {\n            this._impl.stat(path, function (err, stat) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n\n                if (stat.isFile) {\n                    item = this.getFileForPath(path);\n                } else {\n                    item = this.getDirectoryForPath(path);\n                }\n\n                if (item._isWatched()) {\n                    item._stat = stat;\n                }\n\n                callback(null, item, stat);\n            }.bind(this));\n        }\n    };\n\n    /**\n     * Determine whether a file or directory exists at the given path\n     * resolved to a boolean, which is true if the file exists and false otherwise.\n     * The error will never be FileSystemError.NOT_FOUND; in that case, there will be no error and the\n     * boolean parameter will be false.\n     *\n     * @param {string} path\n     * @param {function(?string, boolean)} callback\n     */\n    FileSystem.prototype.existsAsync = function (path) {\n        return this._impl.existsAsync(path);\n    };\n\n    /**\n     * promisified version of FileSystem.resolve\n     * @param {String} path to resolve\n     * @returns {Promise<{entry, stat}>}\n     */\n    FileSystem.prototype.resolveAsync = function (path) {\n        let self = this;\n        return new Promise((resolve, reject)=>{\n            self.resolve(path, (err, item, stat)=>{\n                if(err){\n                    reject(err);\n                    return;\n                }\n                resolve({\n                    entry: item,\n                    stat: stat\n                });\n            });\n        });\n    };\n\n    /**\n     * Show an \"Open\" dialog and return the file(s)/directories selected by the user.\n     *\n     * @param {boolean} allowMultipleSelection Allows selecting more than one file at a time\n     * @param {boolean} chooseDirectories Allows directories to be opened\n     * @param {string} title The title of the dialog\n     * @param {string} initialPath The folder opened inside the window initially. If initialPath\n     *                          is not set, or it doesn't exist, the window would show the last\n     *                          browsed folder depending on the OS preferences\n     * @param {?Array.<string>} fileTypes (Currently *ignored* except on Mac - https://trello.com/c/430aXkpq)\n     *                          List of extensions that are allowed to be opened, without leading \".\".\n     *                          Null or empty array allows all files to be selected. Not applicable\n     *                          when chooseDirectories = true.\n     * @param {function (?string, Array.<string>=)} callback Callback resolved with a FileSystemError\n     *                          string or the selected file(s)/directories. If the user cancels the\n     *                          open dialog, the error will be falsy and the file/directory array will\n     *                          be empty.\n     */\n    FileSystem.prototype.showOpenDialog = function (allowMultipleSelection,\n                            chooseDirectories,\n                            title,\n                            initialPath,\n                            fileTypes,\n                            callback) {\n\n        this._impl.showOpenDialog(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback);\n    };\n\n    /**\n     * Show a \"Save\" dialog and return the path of the file to save.\n     *\n     * @param {string} title The title of the dialog.\n     * @param {string} initialPath The folder opened inside the window initially. If initialPath\n     *                          is not set, or it doesn't exist, the window would show the last\n     *                          browsed folder depending on the OS preferences.\n     * @param {string} proposedNewFilename Provide a new file name for the user. This could be based on\n     *                          on the current file name plus an additional suffix\n     * @param {function (?string, string=)} callback Callback that is resolved with a FileSystemError\n     *                          string or the name of the file to save. If the user cancels the save,\n     *                          the error will be falsy and the name will be empty.\n     */\n    FileSystem.prototype.showSaveDialog = function (title, initialPath, proposedNewFilename, callback) {\n        this._impl.showSaveDialog(title, initialPath, proposedNewFilename, callback);\n    };\n\n    /**\n     * Fire a rename event. Clients listen for these events using FileSystem.on.\n     *\n     * @param {string} oldPath The entry's previous fullPath\n     * @param {string} newPath The entry's current fullPath\n     */\n    FileSystem.prototype._fireRenameEvent = function (oldPath, newPath) {\n        this.trigger(\"rename\", oldPath, newPath);\n    };\n\n    /**\n     * Fire a change event. Clients listen for these events using FileSystem.on.\n     *\n     * @param {File|Directory} entry The entry that has changed\n     * @param {Array<File|Directory>=} added If the entry is a directory, this\n     *      is a set of new entries in the directory.\n     * @param {Array<File|Directory>=} removed If the entry is a directory, this\n     *      is a set of removed entries from the directory.\n     */\n    FileSystem.prototype._fireChangeEvent = function (entry, added, removed) {\n        this.trigger(\"change\", entry, added, removed);\n    };\n\n    /**\n     * @private\n     * Notify the system when an entry name has changed.\n     *\n     * @param {string} oldFullPath\n     * @param {string} newFullPath\n     * @param {boolean} isDirectory\n     */\n    FileSystem.prototype._handleRename = function (oldFullPath, newFullPath, isDirectory) {\n        // Update all affected entries in the index\n        this._index.entryRenamed(oldFullPath, newFullPath, isDirectory);\n    };\n\n    /**\n     * Notify the filesystem that the given directory has changed. Updates the filesystem's\n     * internal state as a result of the change, and calls back with the set of added and\n     * removed entries. Mutating FileSystemEntry operations should call this method before\n     * applying the operation's callback, and pass along the resulting change sets in the\n     * internal change event.\n     *\n     * @param {Directory} directory The directory that has changed.\n     * @param {function(Array<File|Directory>=, Array<File|Directory>=)} callback\n     *      The callback that will be applied to a set of added and a set of removed\n     *      FileSystemEntry objects.\n     */\n    FileSystem.prototype._handleDirectoryChange = function (directory, callback) {\n        var oldContents = directory._contents;\n\n        directory._clearCachedData();\n        directory.getContents(function (err, contents) {\n            var addedEntries = oldContents && contents.filter(function (entry) {\n                return oldContents.indexOf(entry) === -1;\n            });\n\n            var removedEntries = oldContents && oldContents.filter(function (entry) {\n                return contents.indexOf(entry) === -1;\n            });\n\n            // If directory is not watched, clear children's caches manually.\n            var watchedRoot = this._findWatchedRootForPath(directory.fullPath);\n            if (!watchedRoot || !watchedRoot.filter(directory.name, directory.parentPath)) {\n                this._index.visitAll(function (entry) {\n                    if (entry.fullPath.indexOf(directory.fullPath) === 0) {\n                        // Passing 'true' for a similar reason as in _unwatchEntry() - see #7150\n                        entry._clearCachedData(true);\n                    }\n                }.bind(this));\n\n                callback(addedEntries, removedEntries);\n                return;\n            }\n\n            var addedCounter = addedEntries ? addedEntries.length : 0,\n                removedCounter = removedEntries ? removedEntries.length : 0,\n                counter = addedCounter + removedCounter;\n\n            if (counter === 0) {\n                callback(addedEntries, removedEntries);\n                return;\n            }\n\n            var watchOrUnwatchCallback = function (err) {\n                if (err) {\n                    console.error(\"FileSystem error in _handleDirectoryChange after watch/unwatch entries: \" + err);\n                }\n\n                if (--counter === 0) {\n                    callback(addedEntries, removedEntries);\n                }\n            };\n\n            if (addedEntries) {\n                addedEntries.forEach(function (entry) {\n                    this._watchEntry(entry, watchedRoot, watchOrUnwatchCallback);\n                }, this);\n            }\n\n            if (removedEntries) {\n                removedEntries.forEach(function (entry) {\n                    this._unwatchEntry(entry, watchedRoot, watchOrUnwatchCallback);\n                }, this);\n            }\n        }.bind(this));\n    };\n\n    /**\n     * @private\n     * Processes a result from the file/directory watchers. Watch results are sent from the low-level implementation\n     * whenever a directory or file is changed.\n     *\n     * @param {string} path The path that changed. This could be a file or a directory.\n     * @param {FileSystemStats=} stat Optional stat for the item that changed. This param is not always\n     *         passed.\n     */\n    FileSystem.prototype._handleExternalChange = function (path, stat) {\n\n        if (!path) {\n            // This is a \"wholesale\" change event; clear all caches\n            this._index.visitAll(function (entry) {\n                // Passing 'true' for a similar reason as in _unwatchEntry() - see #7150\n                entry._clearCachedData(true);\n            });\n\n            this._fireChangeEvent(null);\n            return;\n        }\n\n        path = this._normalizePath(path, false);\n\n        var entry = this._index.getEntry(path);\n        if (entry) {\n            var oldStat = entry._stat;\n            if (entry.isFile) {\n                // Update stat and clear contents, but only if out of date\n                if (!(stat && oldStat && stat.mtime.getTime() <= oldStat.mtime.getTime())) {\n                    entry._clearCachedData();\n                    entry._stat = stat;\n                    this._fireChangeEvent(entry);\n                }\n            } else {\n                this._handleDirectoryChange(entry, function (added, removed) {\n                    entry._stat = stat;\n\n                    if (entry._isWatched()) {\n                        // We send a change even if added & removed are both zero-length. Something may still have changed,\n                        // e.g. a file may have been quickly removed & re-added before we got a chance to reread the directory\n                        // listing.\n                        this._fireChangeEvent(entry, added, removed);\n                    }\n                }.bind(this));\n            }\n        }\n    };\n\n    /**\n     * Clears all cached content. Because of the performance implications of this, this should only be used if\n     * there is a suspicion that the file system has not been updated through the normal file watchers\n     * mechanism.\n     */\n    FileSystem.prototype.clearAllCaches = function () {\n        this._handleExternalChange(null);\n    };\n\n    /**\n     * Start watching a filesystem root entry.\n     *\n     * @param {FileSystemEntry} entry - The root entry to watch. If entry is a directory,\n     *      all subdirectories that aren't explicitly filtered will also be watched.\n     * @param {function(string): boolean} filter - Returns true if a particular item should\n     *      be watched, given its name (not full path). Items that are ignored are also\n     *      filtered from Directory.getContents() results within this subtree.\n     * @param {Array<string>} filterGlobs - glob compatible string definitions for\n     *      filtering out events on the node side.\n     * @param {function(?string)=} callback - A function that is called when the watch has\n     *      completed. If the watch fails, the function will have a non-null FileSystemError\n     *      string parametr.\n     */\n    FileSystem.prototype.watch = function (entry, filter, filterGlobs, callback) {\n        // make filterGlobs an optional argument to stay backwards compatible\n        if (typeof callback === \"undefined\" && typeof filterGlobs === \"function\") {\n            callback = filterGlobs;\n            filterGlobs = null;\n        }\n\n        var fullPath = entry.fullPath;\n\n        callback = callback || function () {};\n\n        var watchingParentRoot = this._findWatchedRootForPath(fullPath);\n        if (watchingParentRoot &&\n                (watchingParentRoot.status === WatchedRoot.STARTING ||\n                 watchingParentRoot.status === WatchedRoot.ACTIVE)) {\n            callback(\"A parent of this root is already watched\");\n            return;\n        }\n\n        var watchingChildRoot = Object.keys(this._watchedRoots).some(function (path) {\n            var watchedRoot = this._watchedRoots[path],\n                watchedPath = watchedRoot.entry.fullPath;\n\n            return watchedPath.indexOf(fullPath) === 0;\n        }, this);\n\n        if (watchingChildRoot &&\n                (watchingChildRoot.status === WatchedRoot.STARTING ||\n                 watchingChildRoot.status === WatchedRoot.ACTIVE)) {\n            callback(\"A child of this root is already watched\");\n            return;\n        }\n\n        var watchedRoot = new WatchedRoot(entry, filter, filterGlobs);\n\n        this._watchedRoots[fullPath] = watchedRoot;\n\n        // Enter the STARTING state early to indiate that watched Directory\n        // objects may cache their contents. See FileSystemEntry._isWatched.\n        watchedRoot.status = WatchedRoot.STARTING;\n\n        this._watchEntry(entry, watchedRoot, function (err) {\n            if (err) {\n                console.warn(\"Failed to watch root: \", entry.fullPath, err);\n                delete this._watchedRoots[fullPath];\n                callback(err);\n                return;\n            }\n\n            watchedRoot.status = WatchedRoot.ACTIVE;\n\n            callback(null);\n        }.bind(this));\n    };\n\n    /**\n     * Stop watching a filesystem root entry.\n     *\n     * @param {FileSystemEntry} entry - The root entry to stop watching. The unwatch will\n     *      if the entry is not currently being watched.\n     * @param {function(?string)=} callback - A function that is called when the unwatch has\n     *      completed. If the unwatch fails, the function will have a non-null FileSystemError\n     *      string parameter.\n     */\n    FileSystem.prototype.unwatch = function (entry, callback) {\n        var fullPath = entry.fullPath,\n            watchedRoot = this._watchedRoots[fullPath];\n\n        callback = callback || function () {};\n\n        if (!watchedRoot) {\n            callback(FileSystemError.ROOT_NOT_WATCHED);\n            return;\n        }\n\n        // Mark this as inactive, but don't delete the entry until the unwatch is complete.\n        // This is useful for making sure we don't try to concurrently watch overlapping roots.\n        watchedRoot.status = WatchedRoot.INACTIVE;\n\n        this._unwatchEntry(entry, watchedRoot, function (err) {\n            delete this._watchedRoots[fullPath];\n\n            this._index.visitAll(function (child) {\n                if (child.fullPath.indexOf(entry.fullPath) === 0) {\n                    this._index.removeEntry(child);\n                }\n            }.bind(this));\n\n            if (err) {\n                console.warn(\"Failed to unwatch root: \", entry.fullPath, err);\n                callback(err);\n                return;\n            }\n\n            callback(null);\n        }.bind(this));\n    };\n\n    /**\n     * Unwatch all watched roots. Calls unwatch on the underlying impl for each\n     * watched root and ignores errors.\n     * @private\n     */\n    FileSystem.prototype._unwatchAll = function () {\n        console.warn(\"File watchers went offline!\");\n\n        Object.keys(this._watchedRoots).forEach(function (path) {\n            var watchedRoot = this._watchedRoots[path];\n\n            watchedRoot.status = WatchedRoot.INACTIVE;\n            delete this._watchedRoots[path];\n            this._unwatchEntry(watchedRoot.entry, watchedRoot, function () {\n                console.warn(\"Watching disabled for\", watchedRoot.entry.fullPath);\n            });\n        }, this);\n\n        // Fire a wholesale change event, clearing all caches and request that\n        // clients manually update their state.\n        this._handleExternalChange(null);\n    };\n\n\n    // The singleton instance\n    var _instance;\n\n    function _wrap(func) {\n        return function () {\n            return func.apply(_instance, arguments);\n        };\n    }\n\n    // Export public methods as proxies to the singleton instance\n    exports.init = _wrap(FileSystem.prototype.init);\n    exports.close = _wrap(FileSystem.prototype.close);\n    exports.getFileForPath = _wrap(FileSystem.prototype.getFileForPath);\n    exports.addEntryForPathIfRequired = _wrap(FileSystem.prototype.addEntryForPathIfRequired);\n    exports.getDirectoryForPath = _wrap(FileSystem.prototype.getDirectoryForPath);\n    exports.resolve = _wrap(FileSystem.prototype.resolve);\n    exports.resolveAsync = _wrap(FileSystem.prototype.resolveAsync);\n    exports.showOpenDialog = _wrap(FileSystem.prototype.showOpenDialog);\n    exports.showSaveDialog = _wrap(FileSystem.prototype.showSaveDialog);\n    exports.watch = _wrap(FileSystem.prototype.watch);\n    exports.unwatch = _wrap(FileSystem.prototype.unwatch);\n    exports.clearAllCaches = _wrap(FileSystem.prototype.clearAllCaches);\n    exports.alwaysIndex = _wrap(FileSystem.prototype.alwaysIndex);\n    exports.getFreePath = _wrap(FileSystem.prototype.getFreePath);\n    exports.copy = _wrap(FileSystem.prototype.copy);\n    exports.existsAsync = _wrap(FileSystem.prototype.existsAsync);\n\n    // Static public utility methods\n    exports.isAbsolutePath = FileSystem.isAbsolutePath;\n    exports.registerProtocolAdapter = registerProtocolAdapter;\n\n    // For testing only\n    exports._getActiveChangeCount = _wrap(FileSystem.prototype._getActiveChangeCount);\n\n    /**\n     * Add an event listener for a FileSystem event.\n     *\n     * @param {string} event The name of the event\n     * @param {function} handler The handler for the event\n     */\n    exports.on = function (event, handler) {\n        _instance.on(event, handler);\n    };\n\n    /**\n     * Remove an event listener for a FileSystem event.\n     *\n     * @param {string} event The name of the event\n     * @param {function} handler The handler for the event\n     */\n    exports.off = function (event, handler) {\n        _instance.off(event, handler);\n    };\n\n    // Export the FileSystem class as \"private\" for unit testing only.\n    exports._FileSystem = FileSystem;\n\n    // Create the singleton instance\n    _instance = new FileSystem();\n\n    // Initialize the singleton instance\n    _instance.init(require(\"fileSystemImpl\"));\n\n    // attach remote file handlers\n    var HTTP_PROTOCOL = \"http:\",\n        HTTPS_PROTOCOL = \"https:\";\n\n    var protocolAdapter = {\n        priority: 0, // Default priority\n        fileImpl: RemoteFile,\n        canRead: function (filePath) {\n            return true; // Always claim true, we are the default adpaters\n        }\n    };\n\n    // Register the custom object as HTTP and HTTPS protocol adapter\n    registerProtocolAdapter(HTTP_PROTOCOL, protocolAdapter);\n    registerProtocolAdapter(HTTPS_PROTOCOL, protocolAdapter);\n});\n"],"file":"FileSystem.js"}
{"version":3,"sources":["filesystem/impls/appshell/AppshellFileSystem.js"],"names":["define","require","exports","module","FileUtils","FileSystemStats","FileSystemError","FILE_WATCHER_BATCH_TIMEOUT","_changeCallback","_offlineCallback","_changeTimeout","_pendingChanges","_enqueueChange","changedPath","stats","window","setTimeout","Object","keys","forEach","path","_registerChangeEventListeners","pathToWatch","eventEmitter","reloadParentDirContents","pathToReload","_normalise_path","appshell","dirname","on","fs","WATCH_EVENTS","ADD_FILE","ADD_DIR","UNLINK_DIR","UNLINK_FILE","CHANGE","stat","err","newStat","initWatchers","changeCallback","offlineCallback","_watchEventListeners","watchPath","ignored","callback","console","log","watchAsync","then","catch","_mapError","unwatchPath","pathBeingWatched","unwatchAsync","unwatchAll","allUnwatchPromises","push","Promise","all","FS_ERROR_CODES","Phoenix","app","ERR_CODES","code","EINVAL","INVALID_PARAMS","ENOENT","NOT_FOUND","EIO","NOT_READABLE","EROFS","NOT_WRITABLE","ECHARSET","UNSUPPORTED_ENCODING","ENOSPC","OUT_OF_SPACE","EEXIST","ALREADY_EXISTS","ENCODE_FILE_FAILED","DECODE_FILE_FAILED","UNSUPPORTED_UTF16_ENCODING","error","UNKNOWN","VFS","normalize","_wrap","cb","args","Array","prototype","slice","call","arguments","apply","showOpenDialog","allowMultipleSelection","chooseDirectories","title","initialPath","fileTypes","wrappedCallback","browser","isTauri","openTauriFilePickerAsync","multiple","directory","defaultPath","getTauriPlatformPath","filters","name","extensions","undefined","mountNativeFolder","showSaveDialog","proposedNewFilename","_createStatObject","realPath","hash","mtime","getTime","options","isFile","size","fsStats","exists","existsAsync","resolve","reject","existStatus","readdir","withFileTypes","count","length","contents","statsObject","entryStat","entryPath","mkdir","mode","mkdirs","copy","src","dst","copiedPath","rename","oldPath","newPath","readFile","encoding","getFsEncoding","doReadFile","EXCEEDS_MAX_FILE_SIZE","_err","_data","preserveBOM","_stat","writeFile","data","_finishWrite","created","hasOwnProperty","expectedHash","_hash","expectedContents","CONTENTS_MODIFIED","unlink","moveToTrash","pathLib","normalizeUNCPaths","brackets","platform"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global appshell, Phoenix*/\n/*eslint-env es6*/\n// jshint ignore: start\n\ndefine(function (require, exports, module) {\n\n\n    var FileUtils           = require(\"file/FileUtils\"),\n        FileSystemStats     = require(\"filesystem/FileSystemStats\"),\n        FileSystemError     = require(\"filesystem/FileSystemError\");\n\n    /**\n     * @const\n     */\n    var FILE_WATCHER_BATCH_TIMEOUT = 200;   // 200ms - granularity of file watcher changes\n\n    /**\n     * Callback to notify FileSystem of watcher changes\n     * @type {?function(string, FileSystemStats=)}\n     */\n    var _changeCallback;\n\n    /**\n     * Callback to notify FileSystem if watchers stop working entirely\n     * @type {?function()}\n     */\n    var _offlineCallback;\n\n    /** Timeout used to batch up file watcher changes (setTimeout() return value) */\n    var _changeTimeout;\n\n    /**\n     * Pending file watcher changes - map from fullPath to flag indicating whether we need to pass stats\n     * to _changeCallback() for this path.\n     * @type {!Object.<string, boolean>}\n     */\n    var _pendingChanges = {};\n\n    /**\n     * Enqueue a file change event for eventual reporting back to the FileSystem.\n     *\n     * @param {string} changedPath The path that was changed\n     * @param {object} stats Stats coming from the underlying watcher, if available\n     * @private\n     */\n    function _enqueueChange(changedPath, stats) {\n        _pendingChanges[changedPath] = stats;\n        if (!_changeTimeout) {\n            _changeTimeout = window.setTimeout(function () {\n                if (_changeCallback) {\n                    Object.keys(_pendingChanges).forEach(function (path) {\n                        _changeCallback(path, _pendingChanges[path]);\n                    });\n                }\n\n                _changeTimeout = null;\n                _pendingChanges = {};\n            }, FILE_WATCHER_BATCH_TIMEOUT);\n        }\n    }\n\n    /**\n     * Register Event handler for file system change event\n     *\n     * @param {string} pathToWatch the path that is being watched\n     * @param {string} eventEmitter\n     * * @param {string=} fullPath The full path that has changed\n     * @private\n     */\n    function _registerChangeEventListeners(pathToWatch, eventEmitter) {\n        function reloadParentDirContents({path}) {\n            const changedPath = path;\n            let pathToReload = _normalise_path(changedPath);\n            if(pathToReload !== pathToWatch) {\n                // if the changed path is the path being watched itself, we don't issue reload on its parent.\n                // else file/directory was created/deleted; fire change on parent to reload contents\n                pathToReload = appshell.path.dirname(changedPath);\n            }\n            _enqueueChange(`${pathToReload}/`, null);\n        }\n        eventEmitter.on(appshell.fs.WATCH_EVENTS.ADD_FILE, reloadParentDirContents);\n        eventEmitter.on(appshell.fs.WATCH_EVENTS.ADD_DIR, reloadParentDirContents);\n        eventEmitter.on(appshell.fs.WATCH_EVENTS.UNLINK_DIR, reloadParentDirContents);\n        eventEmitter.on(appshell.fs.WATCH_EVENTS.UNLINK_FILE, reloadParentDirContents);\n        eventEmitter.on(appshell.fs.WATCH_EVENTS.CHANGE, ({path})=>{\n            const changedPath = path;\n            stat(changedPath, (err, newStat) => {\n                // fire change event irrespective of error. if err, stat will be null.\n                _enqueueChange(changedPath, newStat);\n            });\n        });\n    }\n\n    /**\n     * Initialize file watching for this filesystem, using the supplied\n     * changeCallback to provide change notifications. The first parameter of\n     * changeCallback specifies the changed path (either a file or a directory);\n     * if this parameter is null, it indicates that the implementation cannot\n     * specify a particular changed path, and so the callers should consider all\n     * paths to have changed and to update their state accordingly. The second\n     * parameter to changeCallback is an optional FileSystemStats object that\n     * may be provided in case the changed path already exists and stats are\n     * readily available. The offlineCallback will be called in case watchers\n     * are no longer expected to function properly. All watched paths are\n     * cleared when the offlineCallback is called.\n     *\n     * @param {function(?string, FileSystemStats=)} changeCallback\n     * @param {function()=} offlineCallback\n     */\n    function initWatchers(changeCallback, offlineCallback) {\n        _changeCallback = changeCallback;\n        _offlineCallback = offlineCallback;\n\n        if (_offlineCallback) {\n            _offlineCallback();\n        }\n    }\n\n    const _watchEventListeners = {};\n\n    /**\n     * Start providing change notifications for the file or directory at the\n     * given path, calling back asynchronously with a possibly null FileSystemError\n     * string when the initialization is complete. Notifications are provided\n     * using the changeCallback function provided by the initWatchers method.\n     * Note that change notifications are only provided recursively for directories\n     * when the recursiveWatch property of this module is true.\n     *\n     * @param {string} pathToWatch\n     * @param {Array<string>|string} ignored\n     * @param {function(?string)=} callback\n     */\n    function watchPath(pathToWatch, ignored, callback) {\n        console.log('Watch path: ', pathToWatch, ignored);\n        pathToWatch = _normalise_path(pathToWatch);\n        appshell.fs.watchAsync(pathToWatch, ignored)\n            .then(eventEmitter=>{\n                _watchEventListeners[pathToWatch] = eventEmitter;\n                _registerChangeEventListeners(pathToWatch, eventEmitter);\n                callback(null);\n            })\n            .catch(err=>{\n                callback(_mapError(err));\n            });\n    }\n    /**\n     * Stop providing change notifications for the file or directory at the\n     * given path, calling back asynchronously with a possibly null FileSystemError\n     * string when the operation is complete.\n     * This function needs to mirror the signature of watchPath\n     * because of FileSystem.prototype._watchOrUnwatchEntry implementation.\n     *\n     * @param {string} pathBeingWatched\n     * @param {Array<string>} ignored\n     * @param {function(?string)=} callback\n     */\n    function unwatchPath(pathBeingWatched, ignored, callback) {\n        console.log('unwatch path: ', pathBeingWatched);\n        pathBeingWatched = _normalise_path(pathBeingWatched);\n        const eventEmitter = _watchEventListeners[pathBeingWatched];\n        delete _watchEventListeners[pathBeingWatched];\n        appshell.fs.unwatchAsync(eventEmitter)\n            .then(()=>{\n                callback(null);\n            }).catch(err=>{\n                callback(_mapError(err));\n            });\n    }\n\n    /**\n     * Stop providing change notifications for all previously watched files and\n     * directories, optionally calling back asynchronously with a possibly null\n     * FileSystemError string when the operation is complete.\n     *\n     * @param {function(?string)=} callback\n     */\n    function unwatchAll(callback) {\n        const allUnwatchPromises = [];\n        for(let pathBeingWatched of Object.keys(_watchEventListeners)) {\n            const eventEmitter = _watchEventListeners[pathBeingWatched];\n            delete _watchEventListeners[pathBeingWatched];\n            allUnwatchPromises.push(appshell.fs.unwatchAsync(eventEmitter));\n        }\n        Promise.all(allUnwatchPromises).then(()=>{\n            callback(null);\n        }).catch(err=>{\n            callback(_mapError(err));\n        });\n    }\n\n\n    /**\n     * Convert appshell error codes to FileSystemError values.\n     *\n     * @param {?number} err An appshell error code\n     * @return {?string} A FileSystemError string, or null if there was no error code.\n     * @private\n     */\n    function _mapError(err) {\n        if (!err) {\n            return null;\n        }\n\n        const FS_ERROR_CODES = window.Phoenix.app.ERR_CODES.FS_ERROR_CODES;\n        console.log('appshell fs error: ', err);\n\n        switch (err.code) {\n        case FS_ERROR_CODES.EINVAL:\n            return FileSystemError.INVALID_PARAMS;\n        case FS_ERROR_CODES.ENOENT:\n            return FileSystemError.NOT_FOUND;\n        case FS_ERROR_CODES.EIO:\n            return FileSystemError.NOT_READABLE;\n        case FS_ERROR_CODES.EROFS:\n            return FileSystemError.NOT_WRITABLE;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.UNSUPPORTED_ENCODING;\n        case FS_ERROR_CODES.ENOSPC:\n            return FileSystemError.OUT_OF_SPACE;\n        case FS_ERROR_CODES.EEXIST:\n            return FileSystemError.ALREADY_EXISTS;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.ENCODE_FILE_FAILED;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.DECODE_FILE_FAILED;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.UNSUPPORTED_UTF16_ENCODING;\n        }\n\n        console.error('unknown error: ', err);\n        return FileSystemError.UNKNOWN;\n    }\n\n    /**\n     * Normalises path.\n     *\n     * @param {string} path The path to normalise\n     * @return {string} Normalised path.\n     * @private\n     */\n    function _normalise_path(path) {\n        return window.Phoenix.VFS.path.normalize(path);\n    }\n\n    /**\n     * Convert a callback to one that transforms its first parameter from an\n     * appshell error code to a FileSystemError string.\n     *\n     * @param {function(?number)} cb A callback that expects an appshell error code\n     * @return {function(?string)} A callback that expects a FileSystemError string\n     * @private\n     */\n    function _wrap(cb) {\n        return function (err) {\n            var args = Array.prototype.slice.call(arguments);\n            args[0] = _mapError(args[0]);\n            cb.apply(null, args);\n        };\n    }\n\n    /**\n     * Display an open-files dialog to the user and call back asynchronously with\n     * either a FileSystmError string or an array of path strings, which indicate\n     * the entry or entries selected.\n     *\n     * @param {boolean} allowMultipleSelection\n     * @param {boolean} chooseDirectories\n     * @param {string} title\n     * @param {string} initialPath\n     * @param {Array.<string>=} fileTypes\n     * @param {function(?string, Array.<string>=)} callback\n     */\n    function showOpenDialog(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback) {\n        const wrappedCallback = _wrap(callback);\n        if(Phoenix.browser.isTauri){\n            appshell.fs.openTauriFilePickerAsync({\n                multiple: allowMultipleSelection,\n                directory: chooseDirectories,\n                title,\n                defaultPath: Phoenix.fs.getTauriPlatformPath(initialPath),\n                filters: fileTypes ? [{\n                    name: \"openDialog\",\n                    extensions: fileTypes || []\n                }] : undefined\n            }).then(directory => {\n                if(!directory) {\n                    wrappedCallback(FileSystemError.NOT_READABLE);\n                    return;\n                }\n                if(typeof directory === 'string') {\n                    wrappedCallback(null, [directory]);\n                    return;\n                }\n                wrappedCallback(null, directory); // is an array of paths\n            }).catch(wrappedCallback);\n            return;\n        }\n        appshell.fs.mountNativeFolder(wrappedCallback);\n    }\n\n    /**\n     * Display a save-file dialog and call back asynchronously with either a\n     * FileSystemError string or the path to which the user has chosen to save\n     * the file. If the dialog is cancelled, the path string will be empty.\n     *\n     * @param {string} title\n     * @param {string} initialPath\n     * @param {string} proposedNewFilename\n     * @param {function(?string, string=)} callback\n     */\n    function showSaveDialog(title, initialPath, proposedNewFilename, callback) {\n        appshell.fs.showSaveDialog(title, initialPath, proposedNewFilename, _wrap(callback));\n    }\n\n    function _createStatObject(stats, realPath) {\n        const hash = stats.mtime? stats.mtime.getTime() : null;\n        var options = {\n            isFile: stats.isFile(),\n            mtime: stats.mtime,\n            size: stats.size,\n            realPath: stats.realPath || realPath,\n            hash: hash\n        };\n        return  new FileSystemStats(options);\n    }\n\n    /**\n     * Stat the file or directory at the given path, calling back\n     * asynchronously with either a FileSystemError string or the entry's\n     * associated FileSystemStats object.\n     *\n     * @param {string} path\n     * @param {function(?string, FileSystemStats=)} callback\n     */\n    function stat(path, callback) {\n        console.log('stat: ', path);\n        path = _normalise_path(path);\n        appshell.fs.stat(path, function (err, stats) {\n            if (err) {\n                callback(_mapError(err));\n            } else {\n                var fsStats = _createStatObject(stats, path);\n                callback(null, fsStats);\n            }\n        });\n    }\n\n    /**\n     * Determine whether a file or directory exists at the given path by calling\n     * back asynchronously with either a FileSystemError string or a boolean,\n     * which is true if the file exists and false otherwise. The error will never\n     * be FileSystemError.NOT_FOUND; in that case, there will be no error and the\n     * boolean parameter will be false.\n     *\n     * @param {string} path\n     * @param {function(?string, boolean)} callback\n     */\n    function exists(path, callback) {\n        console.log('exists: ', path);\n        path = _normalise_path(path);\n        stat(path, function (err) {\n            if (err) {\n                if (err === FileSystemError.NOT_FOUND) {\n                    callback(null, false);\n                } else {\n                    callback(err);\n                }\n                return;\n            }\n\n            callback(null, true);\n        });\n    }\n\n    /**\n     * Determine whether a file or directory exists at the given path by calling\n     * back asynchronously with either a FileSystemError string or a boolean,\n     * which is true if the file exists and false otherwise. The error will never\n     * be FileSystemError.NOT_FOUND; in that case, there will be no error and the\n     * boolean parameter will be false.\n     *\n     * @param {string} path\n     * @param {function(?string, boolean)} callback\n     */\n    function existsAsync(path) {\n        console.log('exists: ', path);\n        return new Promise(function (resolve, reject) {\n            exists(path, function (err, existStatus) {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(existStatus);\n            });\n        });\n    }\n\n    /**\n     * Read the contents of the directory at the given path, calling back\n     * asynchronously either with a FileSystemError string or an array of\n     * FileSystemEntry objects along with another consistent array, each index\n     * of which either contains a FileSystemStats object for the corresponding\n     * FileSystemEntry object in the second parameter or a FileSystemError\n     * string describing a stat error.\n     *\n     * @param {string} path\n     * @param {function(?string, Array.<FileSystemEntry>=, Array.<string|FileSystemStats>=)} callback\n     */\n    function readdir(path, callback) {\n        console.log('readdir: ', path);\n        path = _normalise_path(path);\n        appshell.fs.readdir(path, {withFileTypes: true}, function (err, stats) {\n            if (err) {\n                callback(_mapError(err));\n                return;\n            }\n\n            var count = stats.length;\n            if (!count) {\n                callback(null, [], []);\n                return;\n            }\n\n            let contents = [],\n                statsObject =[];\n\n            stats.forEach(function (entryStat) {\n                contents.push(entryStat.name);\n                let entryPath = `${path}/${entryStat.name}`;\n                statsObject.push(_createStatObject(entryStat, entryPath));\n            });\n            callback(null, contents, statsObject);\n        });\n    }\n\n    /**\n     * Create a directory at the given path, and call back asynchronously with\n     * either a FileSystemError string or a stats object for the newly created\n     * directory. The octal mode parameter is optional; if unspecified, the mode\n     * of the created directory is implementation dependent.\n     *\n     * @param {string} path\n     * @param {number=} mode The base-eight mode of the newly created directory.\n     * @param {function(?string, FileSystemStats=)=} callback\n     */\n    function mkdir(path, mode, callback) {\n        console.log('mkdir: ', path);\n        path = _normalise_path(path);\n        if (typeof mode === \"function\") {\n            callback = mode;\n            mode = 0o755;\n        }\n        appshell.fs.mkdirs(path, mode, true, function (err) {\n            if (err) {\n                callback(_mapError(err));\n            } else {\n                stat(path, function (err, stat) {\n                    callback(err, stat);\n                });\n            }\n        });\n    }\n\n    /**\n     * copies a file/folder path from src to destination recursively. follows unix copy semantics mostly.\n     * As with unix copy, the destination path may not be exactly the `dst` path provided.\n     * Eg. copy(\"/a/b\", \"/a/x\") -> will copy to `/a/x/b` if folder `/a/x` exists. If dst `/a/x` not exists,\n     * then copy will honor the given destination `/a/x`\n     *\n     * @param {string} src Absolute path of file or directory to copy\n     * @param {string} dst Absolute path of file or directory destination\n     * @param {function(err, string)} callback Callback with err or stat of copied destination.\n     */\n    function copy(src, dst, callback) {\n        console.log('copy: ', src);\n        src = _normalise_path(src);\n        dst = _normalise_path(dst);\n        appshell.fs.copy(src, dst, function (err, copiedPath) {\n            if (err) {\n                callback(_mapError(err));\n            } else {\n                stat(copiedPath, function (err, stat) {\n                    callback(err, stat);\n                });\n            }\n        });\n    }\n\n    /**\n     * Rename the file or directory at oldPath to newPath, and call back\n     * asynchronously with a possibly null FileSystemError string.\n     *\n     * @param {string} oldPath\n     * @param {string} newPath\n     * @param {function(?string)=} callback\n     */\n    function rename(oldPath, newPath, callback) {\n        console.log('rename: ', oldPath, ' to ', newPath);\n        oldPath = _normalise_path(oldPath);\n        newPath = _normalise_path(newPath);\n        appshell.fs.rename(oldPath, newPath, _wrap(callback));\n    }\n\n    /**\n     * Read the contents of the file at the given path, calling back\n     * asynchronously with either a FileSystemError string, or with the data and\n     * the FileSystemStats object associated with the read file. The options\n     * parameter can be used to specify an encoding (default \"utf8\"), and also\n     * a cached stats object that the implementation is free to use in order\n     * to avoid an additional stat call.\n     *\n     * Note: if either the read or the stat call fails then neither the read data\n     * nor stat will be passed back, and the call should be considered to have failed.\n     * If both calls fail, the error from the read call is passed back.\n     *\n     * @param {string} path\n     * @param {{encoding: string=, stat: FileSystemStats=}} options\n     * @param {function(?string, string=, FileSystemStats=)} callback\n     */\n    function readFile(path, options, callback) {\n        console.log('Reading file: ', path);\n        path = _normalise_path(path);\n        var encoding = window.Phoenix.VFS.getFsEncoding(options.encoding) || \"utf8\";\n\n        // callback to be executed when the call to stat completes\n        //  or immediately if a stat object was passed as an argument\n        function doReadFile(stat) {\n            if (stat.size > (FileUtils.MAX_FILE_SIZE)) {\n                callback(FileSystemError.EXCEEDS_MAX_FILE_SIZE);\n            } else {\n                appshell.fs.readFile(path, encoding, function (_err, _data, encoding, preserveBOM) {\n                    if (_err) {\n                        callback(_mapError(_err));\n                    } else {\n                        callback(null, _data, encoding, preserveBOM, stat);\n                    }\n                });\n            }\n        }\n\n        if (options.stat) {\n            doReadFile(options.stat);\n        } else {\n            exports.stat(path, function (_err, _stat) {\n                if (_err) {\n                    callback(_err);\n                } else {\n                    doReadFile(_stat);\n                }\n            });\n        }\n    }\n    /**\n     * Write data to the file at the given path, calling back asynchronously with\n     * either a FileSystemError string or the FileSystemStats object associated\n     * with the written file and a boolean that indicates whether the file was\n     * created by the write (true) or not (false). If no file exists at the\n     * given path, a new file will be created. The options parameter can be used\n     * to specify an encoding (default \"utf8\"), an octal mode (default\n     * unspecified and implementation dependent), and a consistency hash, which\n     * is used to the current state of the file before overwriting it. If a\n     * consistency hash is provided but does not match the hash of the file on\n     * disk, a FileSystemError.CONTENTS_MODIFIED error is passed to the callback.\n     *\n     * @param {string} path\n     * @param {string} data\n     * @param {{encoding : string=, mode : number=, expectedHash : object=, expectedContents : string=}} options\n     * @param {function(?string, FileSystemStats=, boolean)} callback\n     */\n    function writeFile(path, data, options, callback) {\n        console.log('Write file: ', path);\n        path = _normalise_path(path);\n        var encoding = window.Phoenix.VFS.getFsEncoding(options.encoding) || \"utf8\",\n            preserveBOM = options.preserveBOM;\n\n        function _finishWrite(created) {\n            appshell.fs.writeFile(path, data, encoding, preserveBOM, function (err) {\n                if (err) {\n                    callback(_mapError(err));\n                } else {\n                    stat(path, function (err, stat) {\n                        callback(err, stat, created);\n                    });\n                }\n            });\n        }\n\n        stat(path, function (err, stats) {\n            if (err) {\n                switch (err) {\n                case FileSystemError.NOT_FOUND:\n                    _finishWrite(true);\n                    break;\n                default:\n                    callback(err);\n                }\n                return;\n            }\n\n            if (options.hasOwnProperty(\"expectedHash\") && options.expectedHash !== stats._hash) {\n                console.error(\"Blind write attempted: \", path, stats._hash, options.expectedHash);\n\n                if (options.hasOwnProperty(\"expectedContents\")) {\n                    appshell.fs.readFile(path, encoding, function (_err, _data) {\n                        if (_err || _data !== options.expectedContents) {\n                            callback(FileSystemError.CONTENTS_MODIFIED);\n                            return;\n                        }\n\n                        _finishWrite(false);\n                    });\n                    return;\n                }\n                callback(FileSystemError.CONTENTS_MODIFIED);\n                return;\n\n            }\n\n            _finishWrite(false);\n        });\n    }\n\n    /**\n     * Unlink (i.e., permanently delete) the file or directory at the given path,\n     * calling back asynchronously with a possibly null FileSystemError string.\n     * Directories will be unlinked even when non-empty.\n     *\n     * @param {string} path\n     * @param {function(string)=} callback\n     */\n    function unlink(path, callback) {\n        console.log('delete file: ', path);\n        path = _normalise_path(path);\n        appshell.fs.unlink(path, function (err) {\n            callback(_mapError(err));\n        });\n    }\n\n    /**\n     * Move the file or directory at the given path to a system dependent trash\n     * location, calling back asynchronously with a possibly null FileSystemError\n     * string. Directories will be moved even when non-empty.\n     *\n     * @param {string} path\n     * @param {function(string)=} callback\n     */\n    function moveToTrash(path, callback) {\n        console.log('Trash file: ', path);\n        path = _normalise_path(path);\n        appshell.fs.moveToTrash(path, function (err) {\n            callback(_mapError(err));\n        });\n    }\n\n    // Export public API\n    exports.showOpenDialog  = showOpenDialog;\n    exports.showSaveDialog  = showSaveDialog;\n    exports.exists          = exists;\n    exports.existsAsync     = existsAsync;\n    exports.readdir         = readdir;\n    exports.mkdir           = mkdir;\n    exports.rename          = rename;\n    exports.copy            = copy;\n    exports.stat            = stat;\n    exports.readFile        = readFile;\n    exports.writeFile       = writeFile;\n    exports.unlink          = unlink;\n    exports.moveToTrash     = moveToTrash;\n    exports.initWatchers    = initWatchers;\n    exports.watchPath       = watchPath;\n    exports.unwatchPath     = unwatchPath;\n    exports.unwatchAll      = unwatchAll;\n    exports.pathLib         = window.Phoenix.VFS.path;\n\n    /**\n     * Indicates whether or not the filesystem should expect and normalize UNC\n     * paths. If set, then //server/directory/ is a normalized path; otherwise the\n     * filesystem will normalize it to /server/directory. Currently, UNC path\n     * normalization only occurs on Windows.\n     *\n     * @type {boolean}\n     */\n    exports.normalizeUNCPaths = brackets.platform === \"win\";\n});\n"],"file":"AppshellFileSystem.js"}
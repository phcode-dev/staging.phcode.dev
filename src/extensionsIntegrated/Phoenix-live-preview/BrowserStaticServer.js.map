{"version":3,"sources":["extensionsIntegrated/Phoenix-live-preview/BrowserStaticServer.js"],"names":["define","require","exports","module","BaseServer","LiveDevelopmentUtils","LiveDevelopment","LiveDevProtocol","marked","DocumentManager","Mustache","FileSystem","EventDispatcher","CommandManager","Commands","EventManager","ProjectManager","Strings","utils","BootstrapCSSText","GithubCSSText","HilightJSText","GFMCSSText","markdownHTMLTemplate","redirectionHTMLTemplate","EVENT_GET_PHOENIX_INSTANCE_ID","EVENT_GET_CONTENT","EVENT_TAB_ONLINE","EVENT_REPORT_ERROR","EVENT_UPDATE_TITLE_ICON","EVENT_EMBEDDED_IFRAME_ESCAPE_PRESS","EVENT_SERVER_READY","makeEventDispatcher","livePreviewTabs","Map","PHCODE_LIVE_PREVIEW_QUERY_PARAM","navigatorChannel","NAVIGATOR_CHANNEL_ID","Phoenix","PHOENIX_INSTANCE_ID","livePreviewChannel","LIVE_PREVIEW_MESSENGER_CHANNEL","LIVE_PREVIEW_BROADCAST_CHANNEL_ID","_staticServerInstance","$livepreviewServerIframe","LIVE_PREVIEW_STATIC_SERVER_BASE_URL","PREVIEW_BASE_URL","BASE_URL_PATH_PREFIX","getLivePreviewNotSupportedURL","window","baseURL","encodeURIComponent","DESCRIPTION_LIVEDEV_MAIN_HEADING","DESCRIPTION_LIVEDEV_MAIN_SPAN","getNoPreviewURL","DESCRIPTION_LIVEDEV_NO_PREVIEW","DESCRIPTION_LIVEDEV_NO_PREVIEW_DETAILS","_isLivePreviewSupported","browser","isTauri","desktop","isSafari","mobile","isIos","async","getPreviewDetails","Promise","resolve","reject","URL","isNoPreview","projectRoot","getProjectRoot","fullPath","projectRootUrl","currentDocument","getCurrentDocument","currentFile","file","getSelectedItem","httpFilePath","startsWith","isPreviewableFile","filePath","path","relative","isMarkdownFile","isHTMLFile","currentLivePreviewDetails","getLivePreviewDetails","liveDocument","isRelated","doc","e","_initNavigatorChannel","BroadcastChannel","onmessage","event","logger","livePreview","log","type","data","set","pageLoaderID","lastSeen","Date","navigationTab","_sendToLivePreviewServerTabs","postMessage","_initLivePreviewChannel","eventName","message","getContent","url","then","response","requestID","catch","console","error","clientID","reportError","Error","trigger","StaticServer","config","this","_baseUrl","_getInstrumentedContent","bind","call","_getMarkdown","getDocumentForPath","done","text","getText","replace","markdownHtml","templateVars","markdownContent","parse","BOOTSTRAP_LIB_CSS","HIGHLIGHT_JS_CSS","HIGHLIGHT_JS","GFM_CSS","PARENT_ORIGIN","location","origin","html","render","contents","headers","Content-Type","fail","err","_getRedirectionPage","redirectURL","searchParams","delete","href","getBaseUrl","_startHeartBeatListeners","TAB_HEARTBEAT_TIMEOUT","setInterval","endTime","tab","keys","tabInfo","get","timeDiff","messageToLivePreviewTabs","contentWindow","redirectAllTabs","newURL","_projectOpened","_evt","_isLiveHighlightEnabled","FILE_LIVE_HIGHLIGHT","getChecked","getPageLoaderURL","DESCRIPTION_LIVEDEV_SECURITY_POPOUT_MESSAGE","APP_NAME","TRUST_PROJECT","getTabPopoutURL","openURL","hasActiveLivePreviews","size","getRemoteTransportScript","init","setLivePreviewTransportBridge","$","attr","registerEventHandler","on","EVENT_PROJECT_OPEN","setOptions","renderer","Renderer","pedantic","gfm","breaks","sanitize","smartLists","smartypants","xhtml","prototype","Object","create","constructor","pathToUrl","baseUrl","relativePath","_pathResolver","encodeURI","urlToPath","indexOf","urlObj","decodeURI","pathname","canServe","localPath","match","isStaticHtmlFileExt","readyToServe","Deferred","promise","addVirtualContentAtPath","docText","add","setInstrumentationEnabled","remove","removeVirtualContentAtPath","clear","requestedPath","_documentKey","_liveDocuments","virtualDocument","_virtualServingDocuments","isWithinProject","isLivePreviewPopoutPage","getResponseData","body","getRemoteScript","getFileForPath","getOpenDocumentForPath","fs","readFile","BYTE_ARRAY_ENCODING","binContent","start","isActive","stop","undefined","_ev","phoenixInstanceID","requestPath","title","faviconBase64","focusActiveEditorIfFocusInLivePreview"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2012 - present Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*global Phoenix, logger, fs, path */\n\ndefine(function (require, exports, module) {\n\n    const BaseServer = require(\"LiveDevelopment/Servers/BaseServer\").BaseServer,\n        LiveDevelopmentUtils = require(\"LiveDevelopment/LiveDevelopmentUtils\"),\n        LiveDevelopment    = require(\"LiveDevelopment/main\"),\n        LiveDevProtocol = require(\"LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol\"),\n        marked = require('thirdparty/marked.min'),\n        DocumentManager = require(\"document/DocumentManager\"),\n        Mustache = require(\"thirdparty/mustache/mustache\"),\n        FileSystem = require(\"filesystem/FileSystem\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        CommandManager     = require(\"command/CommandManager\"),\n        Commands           = require(\"command/Commands\"),\n        EventManager = require(\"utils/EventManager\"),\n        ProjectManager = require(\"project/ProjectManager\"),\n        Strings = require(\"strings\"),\n        utils = require('./utils'),\n        BootstrapCSSText = require(\"text!thirdparty/bootstrap/bootstrap.min.css\"),\n        GithubCSSText = require(\"text!thirdparty/highlight.js/styles/github.min.css\"),\n        HilightJSText = require(\"text!thirdparty/highlight.js/highlight.min.js\"),\n        GFMCSSText = require(\"text!thirdparty/gfm.min.css\"),\n        markdownHTMLTemplate = require(\"text!./markdown.html\"),\n        redirectionHTMLTemplate = require(\"text!./redirectPage.html\");\n\n    const EVENT_GET_PHOENIX_INSTANCE_ID = 'GET_PHOENIX_INSTANCE_ID';\n    const EVENT_GET_CONTENT = 'GET_CONTENT';\n    const EVENT_TAB_ONLINE = 'TAB_ONLINE';\n    const EVENT_REPORT_ERROR = 'REPORT_ERROR';\n    const EVENT_UPDATE_TITLE_ICON = 'UPDATE_TITLE_AND_ICON';\n    const EVENT_EMBEDDED_IFRAME_ESCAPE_PRESS = 'embeddedEscapeKeyPressed';\n    // In browser the SERVER_READY event is raised by the phcode.live virtual server page. That is why you wouldnt see\n    // this triggered in the phcode.dev codebase. It comes from the embedded iframe. Do not remove as unused.\n    const EVENT_SERVER_READY = 'SERVER_READY';\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    const livePreviewTabs = new Map();\n    const PHCODE_LIVE_PREVIEW_QUERY_PARAM = \"phcodeLivePreview\";\n\n    // Communication Channels for PHCode.dev Editor and Live Preview\n    // -------------------------------------------------------------\n    //\n    // NAVIGATOR_CHANNEL:\n    // - Purpose: To handle navigation messages between the PHCode.dev editor and multiple tabs open\n    //   at phcode.dev/live-preview-loader.html.\n    // - Function: Mainly used to redirect pages in response to user actions, such as clicking on different\n    //   files in the files panel or through other navigational inputs.\n    // - Channel ID: `live-preview-loader-${Phoenix.PHOENIX_INSTANCE_ID}` uniquely identifies this channel\n    //   for a specific phoenix instance. This allows multiple live previews to exist if the user opens the\n    //   same project in multiple phoenix editor instances.\n    let navigatorChannel;\n    const NAVIGATOR_CHANNEL_ID = `live-preview-loader-${Phoenix.PHOENIX_INSTANCE_ID}`;\n\n    // LIVE_PREVIEW_MESSENGER_CHANNEL:\n    // - Purpose: To facilitate communication of live preview transport messages between the PHCode.dev\n    //   editor and tabs open at phcode.dev/live-preview-loader.html.\n    // - Function: Acts as a relay channel. Messages received here are forwarded to the LIVE_PREVIEW_MAIN_CHANNEL\n    //   in the phcode.live domain.\n    // - Note: This setup ensures that messages are securely relayed within the constraints of the same origin\n    //   communication policy.\n    let livePreviewChannel;\n    const LIVE_PREVIEW_MESSENGER_CHANNEL = `live-preview-messenger-${Phoenix.PHOENIX_INSTANCE_ID}`;\n\n    // LIVE_PREVIEW_MAIN_CHANNEL:\n    // - Purpose: The primary channel for receiving live preview messages in the phcode.live preview iframe.\n    // - Function: Listens to messages forwarded from LIVE_PREVIEW_MESSENGER_CHANNEL and updates the\n    //   live preview accordingly in phcode.live domain.\n    // - Note: This channel is crucial for the real-time update and synchronization of the live preview\n    //   with user actions in the PHCode.dev editor.\n    const LIVE_PREVIEW_BROADCAST_CHANNEL_ID = `${Phoenix.PHOENIX_INSTANCE_ID}_livePreview`;\n\n    let _staticServerInstance, $livepreviewServerIframe;\n\n    const LIVE_PREVIEW_STATIC_SERVER_BASE_URL = \"https://phcode.live/\";\n    // #LIVE_PREVIEW_STATIC_SERVER_BASE_URL_OVERRIDE uncomment below line if you are developing -\n    // live preview server for browser.\n    // const LIVE_PREVIEW_STATIC_SERVER_BASE_URL = \"http://localhost:8001/\";\n    // const LIVE_PREVIEW_STATIC_SERVER_ORIGIN = \"http://localhost:8001\";\n\n    const PREVIEW_BASE_URL = `${LIVE_PREVIEW_STATIC_SERVER_BASE_URL}vfs/PHOENIX_LIVE_PREVIEW_${Phoenix.PHOENIX_INSTANCE_ID}`;\n    const BASE_URL_PATH_PREFIX = `/vfs/PHOENIX_LIVE_PREVIEW_${Phoenix.PHOENIX_INSTANCE_ID}`;\n\n    function getLivePreviewNotSupportedURL() {\n        return `${window.Phoenix.baseURL}assets/phoenix-splash/live-preview-error.html?mainHeading=`+\n            encodeURIComponent(`${Strings.DESCRIPTION_LIVEDEV_MAIN_HEADING}`) + \"&mainSpan=\"+\n            encodeURIComponent(`${Strings.DESCRIPTION_LIVEDEV_MAIN_SPAN}`);\n    }\n\n    function getNoPreviewURL(){\n        return `${window.Phoenix.baseURL}assets/phoenix-splash/no-preview.html?jsonInput=`+\n            encodeURIComponent(`{\"heading\":\"${Strings.DESCRIPTION_LIVEDEV_NO_PREVIEW}\",`\n                +`\"details\":\"${Strings.DESCRIPTION_LIVEDEV_NO_PREVIEW_DETAILS}\"}`);\n    }\n\n    function _isLivePreviewSupported() {\n        // in safari, service workers are disabled in third party iframes. We use phcode.live for secure sandboxing\n        // live previews into its own domain apart from phcode.dev. Since safari doesn't support this, we are left\n        // with using phcode.dev domain directly for live previews. That is a large attack surface for untrusted\n        // code execution. so we will disable live previews in safari instead of shipping a security vulnerability.\n        return Phoenix.browser.isTauri || !(Phoenix.browser.desktop.isSafari || Phoenix.browser.mobile.isIos);\n    }\n\n    /**\n     * Finds out a {URL,filePath} to live preview from the project. Will return and empty object if the current\n     * file is not previewable.\n     * @return {Promise<*>}\n     */\n    async function getPreviewDetails() {\n        return new Promise(async (resolve, reject)=>{ // eslint-disable-line\n            // async is explicitly caught\n            try {\n                if(!_isLivePreviewSupported()){\n                    resolve({\n                        URL: getLivePreviewNotSupportedURL(),\n                        isNoPreview: true\n                    });\n                    return;\n                }\n                const projectRoot = ProjectManager.getProjectRoot().fullPath;\n                const projectRootUrl = `${PREVIEW_BASE_URL}${projectRoot}`;\n                const currentDocument = DocumentManager.getCurrentDocument();\n                const currentFile = currentDocument? currentDocument.file : ProjectManager.getSelectedItem();\n                if(currentFile){\n                    let fullPath = currentFile.fullPath;\n                    let httpFilePath = null;\n                    if(fullPath.startsWith(\"http://\") || fullPath.startsWith(\"https://\")){\n                        httpFilePath = fullPath;\n                    }\n                    if(utils.isPreviewableFile(fullPath)){\n                        const filePath = httpFilePath || path.relative(projectRoot, fullPath);\n                        let URL = httpFilePath || `${projectRootUrl}${filePath}`;\n                        resolve({\n                            URL,\n                            filePath: filePath,\n                            fullPath: fullPath,\n                            isMarkdownFile: utils.isMarkdownFile(fullPath),\n                            isHTMLFile: utils.isHTMLFile(fullPath)\n                        });\n                        return;\n                    } else {\n                        const currentLivePreviewDetails = LiveDevelopment.getLivePreviewDetails();\n                        if(currentLivePreviewDetails && currentLivePreviewDetails.liveDocument\n                            &&currentLivePreviewDetails.liveDocument.isRelated(fullPath)){\n                            fullPath = currentLivePreviewDetails.liveDocument.doc.file.fullPath;\n                            const filePath = path.relative(projectRoot, fullPath);\n                            let URL = `${projectRootUrl}${filePath}`;\n                            resolve({\n                                URL,\n                                filePath: filePath,\n                                fullPath: fullPath,\n                                isMarkdownFile: utils.isMarkdownFile(fullPath),\n                                isHTMLFile: utils.isHTMLFile(fullPath)\n                            });\n                            return;\n                        }\n                    }\n                }\n                resolve({\n                    URL: getNoPreviewURL(),\n                    isNoPreview: true\n                });\n            }catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    function _initNavigatorChannel() {\n        navigatorChannel = new BroadcastChannel(NAVIGATOR_CHANNEL_ID);\n        navigatorChannel.onmessage = (event) => {\n            window.logger.livePreview.log(\"Live Preview navigator channel: Phoenix received event from tab: \", event);\n            const type = event.data.type;\n            switch (type) {\n            case 'TAB_LOADER_ONLINE':\n                livePreviewTabs.set(event.data.pageLoaderID, {\n                    lastSeen: new Date(),\n                    URL: event.data.URL,\n                    navigationTab: true\n                });\n                return;\n            default: return; // ignore messages not intended for us.\n            }\n        };\n    }\n\n    // this is the server tabs located at \"src/live-preview.html\" which embeds the `phcode.live` server and\n    // preview iframes.\n    function _sendToLivePreviewServerTabs(data, pageLoaderID=null) {\n        livePreviewChannel.postMessage({\n            pageLoaderID,\n            data\n        });\n    }\n\n    function _initLivePreviewChannel() {\n        livePreviewChannel = new BroadcastChannel(LIVE_PREVIEW_MESSENGER_CHANNEL);\n        livePreviewChannel.onmessage = (event) => {\n            window.logger.livePreview.log(\"StaticServer: Live Preview message channel Phoenix recvd:\", event);\n            const pageLoaderID = event.data.pageLoaderID;\n            const data = event.data.data;\n            const eventName =  data.eventName;\n            const message =  data.message;\n            switch (eventName) {\n            case EVENT_GET_PHOENIX_INSTANCE_ID:\n                _sendToLivePreviewServerTabs({\n                    type: 'PHOENIX_INSTANCE_ID',\n                    PHOENIX_INSTANCE_ID: Phoenix.PHOENIX_INSTANCE_ID\n                }, pageLoaderID);\n                return;\n            case EVENT_GET_CONTENT:\n                getContent(message.path,  message.url)\n                    .then(response =>{\n                        // response has the following attributes set\n                        // response.contents: <text or arrayBuffer content>,\n                        // response.path\n                        // headers: {'Content-Type': 'text/html'} // optional headers\n                        response.type = 'REQUEST_RESPONSE';\n                        response.requestID = message.requestID;\n                        _sendToLivePreviewServerTabs(response, pageLoaderID);\n                    })\n                    .catch(console.error);\n                return;\n            case EVENT_TAB_ONLINE:\n                livePreviewTabs.set(message.clientID, {\n                    lastSeen: new Date(),\n                    URL: message.URL\n                });\n                return;\n            case EVENT_REPORT_ERROR:\n                logger.reportError(new Error(message));\n                return;\n            default:\n                exports.trigger(eventName, {\n                    data\n                });\n            }\n        };\n    }\n\n    // see markdown advanced rendering options at https://marked.js.org/using_advanced\n    marked.setOptions({\n        renderer: new marked.Renderer(),\n        pedantic: false,\n        gfm: true,\n        breaks: false,\n        sanitize: false,\n        smartLists: true,\n        smartypants: false,\n        xhtml: false\n    });\n\n    /**\n     * @constructor\n     * @extends {BaseServer}\n     * Live preview server that uses a built-in HTTP server to serve static\n     * and instrumented files.\n     *\n     * @param {!{baseUrl: string, root: string, pathResolver: function(string), nodeDomain: NodeDomain}} config\n     *    Configuration parameters for this server:\n     *        baseUrl        - Optional base URL (populated by the current project)\n     *        pathResolver   - Function to covert absolute native paths to project relative paths\n     *        root           - Native path to the project root (and base URL)\n     */\n    function StaticServer(config) {\n        this._baseUrl       = PREVIEW_BASE_URL;\n        this._getInstrumentedContent = this._getInstrumentedContent.bind(this);\n        BaseServer.call(this, config);\n    }\n\n    StaticServer.prototype = Object.create(BaseServer.prototype);\n    StaticServer.prototype.constructor = StaticServer;\n\n    /**\n     * Returns a base url for current project.\n     *\n     * @return {string}\n     * Base url for current project.\n     */\n    StaticServer.prototype.getBaseUrl = function () {\n        return this._baseUrl;\n    };\n\n    /**\n     * Returns a URL for a given path\n     * @param {string} path Absolute path to covert to a URL\n     * @return {?string} Converts a path within the project root to a URL.\n     *  Returns null if the path is not a descendant of the project root.\n     */\n    StaticServer.prototype.pathToUrl = function (path) {\n        const baseUrl         = this.getBaseUrl(),\n            relativePath    = this._pathResolver(path);\n\n        // See if base url has been specified and path is within project\n        if (relativePath !== path) {\n            // Map to server url. Base url is already encoded, so don't encode again.\n\n            return `${baseUrl}${encodeURI(path)}`;\n        }\n\n        return null;\n    };\n\n    /**\n     * Convert a URL to a local full file path\n     * @param {string} url\n     * @return {?string} The absolute path for given URL or null if the path is\n     *  not a descendant of the project.\n     */\n    StaticServer.prototype.urlToPath = function (url) {\n        let baseUrl = this.getBaseUrl();\n\n        if (baseUrl !== \"\" && url.indexOf(baseUrl) === 0) {\n            const urlObj = new URL(url);\n\n            const filePath = decodeURI(urlObj.pathname)\n                .replace(BASE_URL_PATH_PREFIX, \"\");\n            return decodeURI(filePath);\n        }\n\n        return null;\n    };\n\n    /**\n     * Determines whether we can serve local file.\n     * @param {string} localPath A local path to file being served.\n     * @return {boolean} true for yes, otherwise false.\n     */\n    StaticServer.prototype.canServe = function (localPath) {\n        // If we can't transform the local path to a project relative path,\n        // the path cannot be served\n        if (localPath === this._pathResolver(localPath)) {\n            return false;\n        }\n\n        // Url ending in \"/\" implies default file, which is usually index.html.\n        // Return true to indicate that we can serve it.\n        if (localPath.match(/\\/$/)) {\n            return true;\n        }\n\n        // FUTURE: do a MIME Type lookup on file extension\n        return LiveDevelopmentUtils.isStaticHtmlFileExt(localPath);\n    };\n\n    /**\n     * Gets the server details from the StaticServerDomain in node.\n     * The domain itself handles starting a server if necessary (when\n     * the staticServer.getServer command is called).\n     *\n     * @return {jQuery.Promise} A promise that resolves/rejects when\n     *     the server is ready/failed.\n     */\n    StaticServer.prototype.readyToServe = function () {\n        return $.Deferred().resolve().promise(); // virtual server is always assumed present in phoenix\n    };\n\n    /**\n     * This will add the given text to be served when the path is hit in server. use this to either serve a file\n     * that doesn't exist in project, or to override a given path to the contents you give.\n     */\n    StaticServer.prototype.addVirtualContentAtPath = function (path, docText) {\n        BaseServer.prototype.addVirtualContentAtPath.call(this, path, docText);\n    };\n\n    /**\n     * See BaseServer#add. StaticServer ignores documents that do not have\n     * a setInstrumentationEnabled method. Updates request filters.\n     */\n    StaticServer.prototype.add = function (liveDocument) {\n        if (liveDocument.setInstrumentationEnabled) {\n            // enable instrumentation\n            liveDocument.setInstrumentationEnabled(true);\n        }\n\n        BaseServer.prototype.add.call(this, liveDocument);\n    };\n\n    /**\n     * See BaseServer#remove. Updates request filters.\n     */\n    StaticServer.prototype.remove = function (liveDocument) {\n        BaseServer.prototype.remove.call(this, liveDocument);\n    };\n\n    /**\n     * removes path added by addVirtualContentAtPath()\n     */\n    StaticServer.prototype.removeVirtualContentAtPath = function (path) {\n        BaseServer.prototype.removeVirtualContentAtPath.call(this, path);\n    };\n\n    /**\n     * See BaseServer#clear. Updates request filters.\n     */\n    StaticServer.prototype.clear = function () {\n        BaseServer.prototype.clear.call(this);\n    };\n\n    function _getMarkdown(fullPath) {\n        return new Promise((resolve, reject)=>{\n            DocumentManager.getDocumentForPath(fullPath)\n                .done(function (doc) {\n                    let text = doc.getText();\n                    //  Input: special ZERO WIDTH unicode characters (for example \\uFEFF) might interfere with parsing.\n                    //  Some text editors add them at the start of the file. See\n                    // https://github.com/markedjs/marked/issues/2139\n                    text = text.replace(/^[\\u200B\\u200C\\u200D\\u200E\\u200F\\uFEFF]/, \"\");\n                    let markdownHtml = marked.parse(text);\n                    let templateVars = {\n                        markdownContent: markdownHtml,\n                        BOOTSTRAP_LIB_CSS: BootstrapCSSText,\n                        HIGHLIGHT_JS_CSS: GithubCSSText,\n                        HIGHLIGHT_JS: HilightJSText,\n                        GFM_CSS: GFMCSSText,\n                        PARENT_ORIGIN: location.origin\n                    };\n                    let html = Mustache.render(markdownHTMLTemplate, templateVars);\n                    resolve({\n                        contents: html,\n                        headers: {'Content-Type': 'text/html'},\n                        path: fullPath\n                    });\n                })\n                .fail(function (err) {\n                    reject(new Error(`Markdown rendering failed for ${fullPath}: ` + err));\n                });\n        });\n    }\n\n    /**\n     * return a page loader html with redirect script tag that just redirects the page to the given redirectURL.\n     * Strips the PHCODE_LIVE_PREVIEW_QUERY_PARAM in redirectURL also, indicating this is not a live previewed url.\n     *\n     * @param redirectURL\n     * @return {string}\n     * @private\n     */\n    function _getRedirectionPage(redirectURL) {\n        let url = new URL(redirectURL);\n        // strip this query param as the redirection will be done by the page loader and not the content iframe.\n        url.searchParams.delete(PHCODE_LIVE_PREVIEW_QUERY_PARAM);\n        let templateVars = {\n            redirectURL: url.href\n        };\n        return Mustache.render(redirectionHTMLTemplate, templateVars);\n    }\n\n    /**\n     * @private\n     * Events raised by broadcast channel from the service worker will be captured here. The service worker will ask\n     * all phoenix instances if the url to be served should be replaced with instrumented content here or served\n     * as static file from disk.\n     */\n    StaticServer.prototype._getInstrumentedContent = function (requestedPath, url) {\n        return new Promise((resolve, reject)=>{\n            let path = this._documentKey(requestedPath),\n                liveDocument = this._liveDocuments[path],\n                virtualDocument = this._virtualServingDocuments[path];\n            let contents;\n            if(!ProjectManager.isWithinProject(requestedPath)) {\n                console.error(\"Security issue prevented: Live preview tried to access non project resource!!!\", path);\n                resolve({\n                    path,\n                    contents: null // 404. the user doesnt need to know this, might be a mistake too\n                });\n                return;\n            }\n\n            url = new URL(url);\n            let isLivePreviewPopoutPage = false;\n            if(url.searchParams.get(PHCODE_LIVE_PREVIEW_QUERY_PARAM)) {\n                isLivePreviewPopoutPage = true;\n            }\n            if (virtualDocument) {\n                // virtual document overrides takes precedence over live preview docs\n                contents = virtualDocument;\n            } else if (liveDocument && liveDocument.getResponseData) {\n                contents = liveDocument.getResponseData().body;\n                if(isLivePreviewPopoutPage && contents.indexOf(LiveDevProtocol.getRemoteScript()) === -1){\n                    // #LIVE_PREVIEW_TAB_NAVIGATION_RACE_FIX\n                    // check if this is a live preview html. If so, then if you are here, it means that users switched\n                    // live preview to a different page while we are just about to serve an old live preview page that is\n                    // no longer in live preview. If we just serve the raw html here, it will not have any tab navigation\n                    // instrumentation on popped out tabs and live preview navigation will stop on this page. So we will\n                    // use a page loader url to continue navigation.\n                    console.log(\"serving stale live preview with navigable url\", url);\n                    contents = _getRedirectionPage(url);\n                }\n            } else {\n                const file = FileSystem.getFileForPath(requestedPath);\n                let doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\n                if (doc) {\n                    // this file is open in some editor, so we sent the edited contents.\n                    contents = doc.getText();\n                } else {\n                    fs.readFile(requestedPath, fs.BYTE_ARRAY_ENCODING, function (error, binContent) {\n                        if(error){\n                            binContent = null;\n                        }\n                        resolve({\n                            path,\n                            contents: binContent\n                        });\n                    });\n                    return;\n                }\n            }\n\n            resolve({\n                path,\n                contents: contents\n            });\n        });\n    };\n\n    function getContent(path, url) {\n        const currentDocument = DocumentManager.getCurrentDocument();\n        const currentFile = currentDocument? currentDocument.file : ProjectManager.getSelectedItem();\n        if(!_staticServerInstance){\n            return Promise.reject(\"Static serve not started!\");\n        }\n        if(!url.startsWith(_staticServerInstance.getBaseUrl())) {\n            return Promise.reject(\"Not serving content as url belongs to another phcode instance: \" + url);\n        }\n        if(utils.isMarkdownFile(path) && currentFile && currentFile.fullPath === path){\n            return _getMarkdown(path);\n        }\n        if(_staticServerInstance){\n            return _staticServerInstance._getInstrumentedContent(path, url);\n        }\n        return Promise.reject(\"Cannot get content\");\n    };\n\n    /**\n     * See BaseServer#start. Starts listenting to StaticServerDomain events.\n     */\n    StaticServer.prototype.start = async function () {\n        _staticServerInstance = this;\n        // in browsers, the virtual server is always loaded permanently in iframe.\n    };\n\n    StaticServer.prototype.isActive = function () {\n        return _staticServerInstance === this;\n    };\n\n    /**\n     * See BaseServer#stop. Remove event handlers from StaticServerDomain.\n     */\n    StaticServer.prototype.stop = function () {\n        _staticServerInstance = undefined;\n    };\n\n    exports.on(EVENT_REPORT_ERROR, function(_ev, event){\n        logger.reportError(new Error(event.data.message));\n    });\n    exports.on(EVENT_GET_CONTENT, function(_ev, event){\n        window.logger.livePreview.log(\"Static Server GET_CONTENT\", event);\n        if(event.data.message && event.data.message.phoenixInstanceID === Phoenix.PHOENIX_INSTANCE_ID) {\n            const requestPath = event.data.message.path,\n                requestID = event.data.message.requestID,\n                url = event.data.message.url;\n            getContent(requestPath, url)\n                .then(response =>{\n                    // response has the following attributes set\n                    // response.contents: <text or arrayBuffer content>,\n                    // response.path\n                    // headers: {'Content-Type': 'text/html'} // optional headers\n                    response.type = 'REQUEST_RESPONSE';\n                    response.requestID = requestID;\n                    messageToLivePreviewTabs(response);\n                })\n                .catch(console.error);\n        }\n    });\n    exports.on(EVENT_GET_PHOENIX_INSTANCE_ID, function(_ev){\n        messageToLivePreviewTabs({\n            type: 'PHOENIX_INSTANCE_ID',\n            PHOENIX_INSTANCE_ID: Phoenix.PHOENIX_INSTANCE_ID\n        });\n    });\n\n    exports.on(EVENT_TAB_ONLINE, function(_ev, event){\n        livePreviewTabs.set(event.data.message.clientID, {\n            lastSeen: new Date(),\n            URL: event.data.message.URL\n        });\n    });\n\n    function _startHeartBeatListeners() {\n        // If we didn't receive heartbeat message from a tab for 10 seconds, we assume tab closed\n        const TAB_HEARTBEAT_TIMEOUT = 10000; // in millis secs\n        setInterval(()=>{\n            let endTime = new Date();\n            for(let tab of livePreviewTabs.keys()){\n                const tabInfo = livePreviewTabs.get(tab);\n                let timeDiff = endTime - tabInfo.lastSeen; // in ms\n                if(timeDiff > TAB_HEARTBEAT_TIMEOUT){\n                    livePreviewTabs.delete(tab);\n                    // the parent navigationTab `phcode.dev/live-preview-loader.html` which loads the live preview tab\n                    // is in the list too. We should not raise browser close for a live-preview-loader tab.\n                    if(!tabInfo.navigationTab) {\n                        exports.trigger('BROWSER_CLOSE', { data: { message: {clientID: tab}}});\n                    }\n                }\n            }\n        }, 1000);\n    }\n\n    /**\n     * The message should be and object of the form: {type, ...}. a type attribute is mandatory\n     * @param message\n     */\n    function messageToLivePreviewTabs(message) {\n        if(!message.type){\n            throw new Error('Missing type attribute to send live preview message to tabs');\n        }\n        // The embedded iframe is a trusted origin and hence we use '*'. We can alternatively use\n        // getStaticServerBaseURLs().origin, but there seems to be a single error on startup\n        // Most likely as we switch frequently between about:blank and the live preview server host page.\n        // Error message in console:\n        // `Failed to execute 'postMessage' on 'DOMWindow': The target origin provided ('http://localhost:8001')\n        // does not match the recipient window's origin ('http://localhost:8000').`\n        $livepreviewServerIframe && $livepreviewServerIframe[0].contentWindow.postMessage(message, '*');\n        _sendToLivePreviewServerTabs(message);\n    }\n\n    function redirectAllTabs(newURL) {\n        navigatorChannel.postMessage({\n            type: 'REDIRECT_PAGE',\n            URL: newURL\n        });\n    }\n\n    function _projectOpened(_evt, projectRoot) {\n        navigatorChannel.postMessage({\n            type: 'PROJECT_SWITCH',\n            projectRoot: projectRoot.fullPath\n        });\n    }\n\n    exports.on(EVENT_UPDATE_TITLE_ICON, function(_ev, event){\n        const title = event.data.message.title;\n        const faviconBase64 = event.data.message.faviconBase64;\n        navigatorChannel.postMessage({\n            type: 'UPDATE_TITLE_ICON',\n            title,\n            faviconBase64\n        });\n    });\n\n    function _isLiveHighlightEnabled() {\n        return CommandManager.get(Commands.FILE_LIVE_HIGHLIGHT).getChecked();\n    }\n    exports.on(EVENT_EMBEDDED_IFRAME_ESCAPE_PRESS, function () {\n        if(!_isLiveHighlightEnabled()){\n            return;\n        }\n        utils.focusActiveEditorIfFocusInLivePreview();\n    });\n\n    function getPageLoaderURL(url) {\n        return `${Phoenix.baseURL}live-preview-loader.html?`\n            +`virtualServerURL=${encodeURIComponent(LIVE_PREVIEW_STATIC_SERVER_BASE_URL)}`\n            +`&phoenixInstanceID=${Phoenix.PHOENIX_INSTANCE_ID}&initialURL=${encodeURIComponent(url)}`\n            +`&localMessage=${encodeURIComponent(Strings.DESCRIPTION_LIVEDEV_SECURITY_POPOUT_MESSAGE)}`\n            +`&appName=${encodeURIComponent(Strings.APP_NAME)}`\n            +`&initialProjectRoot=${encodeURIComponent(ProjectManager.getProjectRoot().fullPath)}`\n            +`&okMessage=${encodeURIComponent(Strings.TRUST_PROJECT)}`;\n    }\n\n    function getTabPopoutURL(url) {\n        let openURL = new URL(url);\n        // we tag all externally opened urls with query string parameter phcodeLivePreview=\"true\" to address\n        // #LIVE_PREVIEW_TAB_NAVIGATION_RACE_FIX\n        openURL.searchParams.set(PHCODE_LIVE_PREVIEW_QUERY_PARAM, \"true\");\n        return  getPageLoaderURL(openURL.href);\n    }\n\n    function hasActiveLivePreviews() {\n        return livePreviewTabs.size > 0;\n    }\n\n    function getRemoteTransportScript() {\n        return `TRANSPORT_CONFIG.LIVE_PREVIEW_BROADCAST_CHANNEL_ID = \"${LIVE_PREVIEW_BROADCAST_CHANNEL_ID}\";\\n`;\n    }\n\n    function init() {\n        LiveDevelopment.setLivePreviewTransportBridge(exports);\n        // load the hidden iframe that loads the service worker server page once. we will reuse the same server\n        // as this is a cross-origin server phcode.live, the browser will identify it as a security issue\n        // if we continuously reload the service worker loader page frequently and it will stop working.\n        $livepreviewServerIframe = $(\"#live-preview-server-iframe\");\n        let url = LIVE_PREVIEW_STATIC_SERVER_BASE_URL +\n            `?parentOrigin=${location.origin}`;\n        $livepreviewServerIframe.attr(\"src\", url);\n        _initNavigatorChannel();\n        _initLivePreviewChannel();\n        EventManager.registerEventHandler(\"ph-liveServer\", exports);\n        ProjectManager.on(ProjectManager.EVENT_PROJECT_OPEN, _projectOpened);\n        _startHeartBeatListeners();\n    }\n\n    exports.init = init;\n    exports.StaticServer = StaticServer;\n    exports.messageToLivePreviewTabs = messageToLivePreviewTabs;\n    exports.getPreviewDetails = getPreviewDetails;\n    exports.livePreviewTabs = livePreviewTabs;\n    exports.redirectAllTabs = redirectAllTabs;\n    exports.getTabPopoutURL = getTabPopoutURL;\n    exports.hasActiveLivePreviews = hasActiveLivePreviews;\n    exports.getNoPreviewURL = getNoPreviewURL;\n    exports.getRemoteTransportScript = getRemoteTransportScript;\n    exports.PHCODE_LIVE_PREVIEW_QUERY_PARAM = PHCODE_LIVE_PREVIEW_QUERY_PARAM;\n    exports.EVENT_SERVER_READY = EVENT_SERVER_READY;\n});\n"],"file":"BrowserStaticServer.js"}
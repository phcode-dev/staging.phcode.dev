{"version":3,"sources":["extensionsIntegrated/InAppNotifications/banner.js"],"names":["define","require","exports","module","AppInit","PreferencesManager","ExtensionUtils","Metrics","utils","NotificationBarHtml","loadStyleSheet","ONE_DAY","IN_APP_NOTIFICATIONS_BANNER_SHOWN_STATE","NOTIFICATION_ACK_CLASS","async","_renderNotifications","notifications","_InAppBannerShownAndDone","getViewState","notificationID","Object","keys","notification","isValidForThisVersion","FOR_VERSIONS","isValidForThisPlatform","PLATFORM","HTML_CONTENT","includes","DANGER_SHOW_ON_EVERY_BOOT","_markAsShownAndDone","showBannerAndWaitForDismiss","_InAppBannersShownAndDone","setViewState","fetchJSON","url","fetch","then","response","ok","json","stateManager","definePreference","inProgress","_fetchAndRenderNotifications","locale","brackets","getLocale","fetchURL","config","app_notification_url","defaultFetchURL","fetchedJSON","catch","error","console","finally","cleanNotificationBanner","$notificationBar","$","length","remove","html","resolved","Promise","resolve","$htmlContent","$notificationBarElement","find","prependTo","$notificationContent","$closeIcon","append","countEvent","EVENT_TYPE","NOTIFICATIONS","click","appReady","Phoenix","isTestWindow","setInterval"],"mappings":"AA2BAA,OAAO,SAAUC,QAASC,QAASC,QAE/B,MAAMC,QAAuBH,QAAQ,iBACjCI,mBAAuBJ,QAAQ,kCAC/BK,eAAuBL,QAAQ,wBAC/BM,QAAUN,QAAQ,iBAClBO,MAAQP,QAAQ,WAChBQ,oBAAuBR,QAAQ,iDAEnCK,eAAeI,eAAeP,OAAQ,qBAGtC,MAAMQ,QAAU,MACVC,wCAA0C,gCAC1CC,uBAAyB,mBAqC/BC,eAAeC,qBAAqBC,eAChC,IAAIA,cACA,OAGJ,MAAMC,yBAA2BZ,mBAAmBa,aAChDN,yCAEJ,IAAI,MAAMO,kBAAkBC,OAAOC,KAAKL,eACpC,IAAIC,yBAAyBE,gBAAiB,CAC1C,MAAMG,aAAeN,cAAcG,gBACnC,IAAIX,MAAMe,sBAAsBD,aAAaE,cACzC,SAEJ,IAAIhB,MAAMiB,uBAAuBH,aAAaI,UAC1C,SAEAJ,aAAaK,aAAaC,SAASf,yBAC/BS,aAAaO,2BAEjBC,oBAAoBX,sBAElBY,4BAA4BT,aAAaK,aAAcR,gBACzDG,aAAaO,2BACbC,oBAAoBX,iBAMpC,SAASW,oBAAoBX,gBACzB,MAAMa,0BAA4B3B,mBAAmBa,aAAaN,yCAClEoB,0BAA0Bb,iBAAkB,EAC5Cd,mBAAmB4B,aAAarB,wCAC5BoB,2BAGR,SAASE,UAAUC,KACf,OAAOC,MAAMD,KACRE,KAAKC,UACGA,SAASC,GAGPD,SAASE,OAFL,MA3EvBnC,mBAAmBoC,aAAaC,iBAAiB9B,wCAC7C,SAAU,IAgFd,IAAI+B,YAAa,EACjB,SAASC,+BACL,GAAGD,WACC,OAEJA,YAAa,EACb,MAAME,OAASC,SAASC,YAClBC,YAAcF,SAASG,OAAOC,uBAAuBL,qBACrDM,mBAAqBL,SAASG,OAAOC,uCAE3ChB,UAAUc,UACLX,KAAKe,aAEkB,OAAhBA,YAEOlB,UAAUiB,iBAEdC,aAEVf,KAAKtB,sBACLsC,MAAMC,QACHC,QAAQD,MAAM,2CAA4CA,SAE7DE,QAAQ,KACLb,YAAa,IAQzB,SAASc,0BACL,MAAMC,iBAAmBC,EAAE,qBACvBD,iBAAiBE,OAAS,GAC1BF,iBAAiBG,SAQzB/C,eAAeiB,4BAA4B+B,KAAM3C,gBAC7C,IAAI4C,UAAW,EACf,OAAO,IAAIC,QAASC,UAChB,MAAMC,aAAeP,EAAEG,MACnBK,wBAA0BR,EAAElD,qBAGhCyD,aAAaE,KAAK,UAAUP,SAG5BK,aAAaE,KAAK,SAASP,SAE3BJ,0BACAU,wBAAwBE,UAAU,YAElC,IAAIX,iBAAmBC,EAAE,qBACrBW,qBAAuBZ,iBAAiBU,KAAK,sBAC7CG,WAAab,iBAAiBU,KAAK,eAEvCE,qBAAqBE,OAAON,cAC5B3D,QAAQkE,WAAWlE,QAAQmE,WAAWC,cAAe,UAAUxD,eAC3D,SAGAoD,WAAWX,OAAS,GACpBW,WAAWK,MAAM,WACbnB,0BACAlD,QAAQkE,WAAWlE,QAAQmE,WAAWC,cAAe,UAAUxD,eAC3D,eACH4C,UAAYE,QAAQC,cACrBH,UAAW,IAInBL,iBAAiBU,SAASvD,0BAA0B+D,MAAM,WAEtDnB,0BACAlD,QAAQkE,WAAWlE,QAAQmE,WAAWC,cAAe,UAAUxD,eAC3D,aACH4C,UAAYE,QAAQC,cACrBH,UAAW,MAMvB3D,QAAQyE,SAAS,WACVC,QAAQC,eAGXnC,+BACAoC,YAAYpC,6BApLA,UAuLbkC,QAAQC,eACP7E,QAAQuD,wBAA0BA,wBAClCvD,QAAQa,qBAAuBA","sourcesContent":["/*\n * Copyright (c) 2019 - present Adobe. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n/*global Phoenix*/\n/**\n *  module for displaying in-app banner notifications\n *\n */\ndefine(function (require, exports, module) {\n\n    const AppInit              = require(\"utils/AppInit\"),\n        PreferencesManager   = require(\"preferences/PreferencesManager\"),\n        ExtensionUtils       = require(\"utils/ExtensionUtils\"),\n        Metrics = require(\"utils/Metrics\"),\n        utils = require(\"./utils\"),\n        NotificationBarHtml  = require(\"text!./htmlContent/notificationContainer.html\");\n\n    ExtensionUtils.loadStyleSheet(module, \"styles/styles.css\");\n\n    // duration of one day in milliseconds\n    const ONE_DAY = 1000 * 60 * 60 * 24;\n    const IN_APP_NOTIFICATIONS_BANNER_SHOWN_STATE = \"InAppNotificationsBannerShown\";\n    const NOTIFICATION_ACK_CLASS = \"notification_ack\";\n\n    // Init default last notification number\n    PreferencesManager.stateManager.definePreference(IN_APP_NOTIFICATIONS_BANNER_SHOWN_STATE,\n        \"object\", {});\n\n    /**\n     * If there are multiple notifications, thew will be shown one after the other and not all at once.\n     * A sample notifications is as follows:\n     * {\n     *   \"SAMPLE_NOTIFICATION_NAME\": {\n     *     \"DANGER_SHOW_ON_EVERY_BOOT\" : false,\n     *     \"HTML_CONTENT\": \"<div>hello world <a class='notification_ack'>Click to acknowledge.</a></div>\",\n     *     \"FOR_VERSIONS\": \"1.x || >=2.5.0 || 5.0.0 - 7.2.3\",\n     *     \"PLATFORM\" : \"allDesktop\"\n     *   },\n     *   \"ANOTHER_SAMPLE_NOTIFICATION_NAME\": {etc}\n     * }\n     *  By default, a notification is shown only once except if `DANGER_SHOW_ON_EVERY_BOOT` is set\n     *  or there is an html element with class `notification_ack`.\n     *\n     * 1. `SAMPLE_NOTIFICATION_NAME` : This is a unique ID. It is used to check if the notification was shown to user.\n     * 2. `DANGER_SHOW_ON_EVERY_BOOT` : (Default false) Setting this to true will cause the\n     *    notification to be shown on every boot. This is bad ux and only be used if there is a critical security issue\n     *    that we want the version not to be used.\n     * 3. `HTML_CONTENT`: The actual html content to show to the user. It can have an optional `notification_ack` class.\n     *     Setting this class will cause the notification to be shown once a day until the user explicitly clicks\n     *     on any html element with class `notification_ack` or explicitly click the close button.\n     *     If such a class is not present, then the notification is shown only once ever.\n     * 4. `FOR_VERSIONS` : [Semver compatible version filter](https://www.npmjs.com/package/semver).\n     *     The notification will be shown to all versions satisfying this.\n     * 5. `PLATFORM`: A comma seperated list of all platforms in which the message will be shown.\n     *     allowed values are: `mac,win,linux,allDesktop,firefox,chrome,safari,allBrowser,all`\n     * @param notifications\n     * @returns {false|*}\n     * @private\n     */\n    async function _renderNotifications(notifications) {\n        if(!notifications) {\n            return; // nothing to show here\n        }\n\n        const _InAppBannerShownAndDone = PreferencesManager.getViewState(\n            IN_APP_NOTIFICATIONS_BANNER_SHOWN_STATE);\n\n        for(const notificationID of Object.keys(notifications)){\n            if(!_InAppBannerShownAndDone[notificationID]) {\n                const notification = notifications[notificationID];\n                if(!utils.isValidForThisVersion(notification.FOR_VERSIONS)){\n                    continue;\n                }\n                if(!utils.isValidForThisPlatform(notification.PLATFORM)){\n                    continue;\n                }\n                if(!notification.HTML_CONTENT.includes(NOTIFICATION_ACK_CLASS)\n                    && !notification.DANGER_SHOW_ON_EVERY_BOOT){\n                    // One time notification. mark as shown and never show again\n                    _markAsShownAndDone(notificationID);\n                }\n                await showBannerAndWaitForDismiss(notification.HTML_CONTENT, notificationID);\n                if(!notification.DANGER_SHOW_ON_EVERY_BOOT){\n                    _markAsShownAndDone(notificationID);\n                }\n            }\n        }\n    }\n\n    function _markAsShownAndDone(notificationID) {\n        const _InAppBannersShownAndDone = PreferencesManager.getViewState(IN_APP_NOTIFICATIONS_BANNER_SHOWN_STATE);\n        _InAppBannersShownAndDone[notificationID] = true;\n        PreferencesManager.setViewState(IN_APP_NOTIFICATIONS_BANNER_SHOWN_STATE,\n            _InAppBannersShownAndDone);\n    }\n\n    function fetchJSON(url) {\n        return fetch(url)\n            .then(response => {\n                if (!response.ok) {\n                    return null;\n                }\n                return response.json();\n            });\n    }\n\n    let inProgress = false;\n    function _fetchAndRenderNotifications() {\n        if(inProgress){\n            return;\n        }\n        inProgress = true;\n        const locale = brackets.getLocale(); // en-US default\n        const fetchURL = `${brackets.config.app_notification_url}${locale}/banner.json`;\n        const defaultFetchURL = `${brackets.config.app_notification_url}root/banner.json`;\n        // Fetch data from fetchURL first\n        fetchJSON(fetchURL)\n            .then(fetchedJSON => {\n                // Check if fetchedJSON is empty or undefined\n                if (fetchedJSON === null) {\n                    // Fetch data from defaultFetchURL if fetchURL didn't provide data\n                    return fetchJSON(defaultFetchURL);\n                }\n                return fetchedJSON;\n            })\n            .then(_renderNotifications) // Call the render function with the fetched JSON data\n            .catch(error => {\n                console.error(`Error fetching and rendering banner.json`, error);\n            })\n            .finally(()=>{\n                inProgress = false;\n            });\n    }\n\n\n    /**\n     * Removes and cleans up the notification bar from DOM\n     */\n    function cleanNotificationBanner() {\n        const $notificationBar = $('#notification-bar');\n        if ($notificationBar.length > 0) {\n            $notificationBar.remove();\n        }\n    }\n\n    /**\n     * Displays the Notification Bar UI\n     *\n     */\n    async function showBannerAndWaitForDismiss(html, notificationID) {\n        let resolved = false;\n        return new Promise((resolve)=>{\n            const $htmlContent = $(html),\n                $notificationBarElement = $(NotificationBarHtml);\n\n            // Remove any SCRIPT tag to avoid secuirity issues\n            $htmlContent.find('script').remove();\n\n            // Remove any STYLE tag to avoid styling impact on Brackets DOM\n            $htmlContent.find('style').remove();\n\n            cleanNotificationBanner(); //Remove an already existing notification bar, if any\n            $notificationBarElement.prependTo(\".content\");\n\n            var $notificationBar = $('#notification-bar'),\n                $notificationContent = $notificationBar.find('.content-container'),\n                $closeIcon = $notificationBar.find('.close-icon');\n\n            $notificationContent.append($htmlContent);\n            Metrics.countEvent(Metrics.EVENT_TYPE.NOTIFICATIONS, \"banner-\"+notificationID,\n                \"shown\");\n\n            // Click handlers on actionable elements\n            if ($closeIcon.length > 0) {\n                $closeIcon.click(function () {\n                    cleanNotificationBanner();\n                    Metrics.countEvent(Metrics.EVENT_TYPE.NOTIFICATIONS, \"banner-\"+notificationID,\n                        \"closeClick\");\n                    !resolved && resolve($htmlContent);\n                    resolved = true;\n                });\n            }\n\n            $notificationBar.find(`.${NOTIFICATION_ACK_CLASS}`).click(function() {\n                // Your click event handler logic here\n                cleanNotificationBanner();\n                Metrics.countEvent(Metrics.EVENT_TYPE.NOTIFICATIONS, \"banner-\"+notificationID,\n                    \"ackClick\");\n                !resolved && resolve($htmlContent);\n                resolved = true;\n            });\n        });\n    }\n\n\n    AppInit.appReady(function () {\n        if(Phoenix.isTestWindow) {\n            return;\n        }\n        _fetchAndRenderNotifications();\n        setInterval(_fetchAndRenderNotifications, ONE_DAY);\n    });\n\n    if(Phoenix.isTestWindow){\n        exports.cleanNotificationBanner = cleanNotificationBanner;\n        exports._renderNotifications = _renderNotifications;\n    }\n});\n"],"file":"banner.js"}
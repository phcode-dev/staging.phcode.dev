{"version":3,"sources":["widgets/NotificationUI.js"],"names":["define","require","exports","module","WorkspaceManager","Notification","tooltip","this","$tooltip","_result","$","Deferred","_promise","promise","createFromTemplate","template","elementID","options","allowedPlacements","dismissOnClick","_createDomElementWithArrowElement","addClass","notification","autoCloseTimeS","setTimeout","close","CLOSE_TIMEOUT","click","CLOSE_CLICK_DISMISS","prototype","closeType","removeClass","remove","off","EVENT_WORKSPACE_UPDATE_LAYOUT","update","resolve","done","callback","notificationWidgetCount","_computePlacementWithArrowElement","arrowElement","x","y","placement","middlewareData","Object","assign","style","left","top","arrowX","arrowY","arrow","staticSide","right","bottom","split","[object Object]","_updatePositions","onElement","middleWare","FloatingUIDOM","offset","autoPlacement","shift","padding","push","element","computePosition","middleware","then","on","domTemplate","document","getElementById","widgetID","arrowID","textTemplate","String","floatingDom","append"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global FloatingUIDOM*/\n// @INCLUDE_IN_API_DOCS\n\n/**\n * The global NotificationUI can be used to create popup notifications over dom elements or generics app notifications.\n *\n * A global `window.EventManager` object is made available in phoenix that can be called anytime after AppStart.\n * This global can be triggered from anywhere without using require context.\n *\n * ## Usage\n * ### Simple example\n * For Eg. Let's say we have to create a popup notification over the HTML element with ID `showInfileTree`.\n * We can do this with the following\n * ```js\n * const NotificationUI = brackets.getModule(\"widgets/NotificationUI\");\n * // or use window.NotificationUI global object has the same effect.\n * let notification = NotificationUI.createFromTemplate(\"Click me to locate the file in file tree\", \"showInfileTree\",{});\n * notification.done(()=>{\n *     console.log(\"notification is closed in ui.\");\n * })\n * ```\n * ### Advanced example\n * Another advanced example where you can specify html and interactive components in the notification\n * ```js\n * // note that you can even provide an HTML Element node with\n * // custom event handlers directly here instead of HTML text.\n * let notification1 = NotificationUI.createFromTemplate(\n *   \"<div>Click me to </br>locate the file in file tree</div>\", \"showInfileTree\",{\n *       allowedPlacements: ['top', 'bottom'],\n *       dismissOnClick: false,\n *       autoCloseTimeS: 300 // auto close the popup after 5 minutes\n *   });\n * // do stuff\n * notification1.done((closeReason)=>{\n *     console.log(\"notification is closed in ui reason:\", closeReason);\n * })\n * ```\n * The [createFromTemplate]() API can be configured with numerous options. See API options below.\n * @module widgets/NotificationUI\n */\n\ndefine(function (require, exports, module) {\n\n\n    let WorkspaceManager  = require(\"view/WorkspaceManager\");\n\n    /**\n     * This section outlines the properties and methods available in this module\n     * @name API\n     */\n\n    /**\n     * This is an instance of the notification returned by the `createFromTemplate` call. The object can be used to\n     * control the created notification. See Notification docs below.\n     * @type {Object}\n     * @name Notification\n     */\n\n    /**\n     * @constructor\n     * @private\n     */\n    function Notification(tooltip) {\n        this.$tooltip    = tooltip;\n        this._result  = new $.Deferred();\n        this._promise = this._result.promise();\n    }\n\n    /**\n     * Closes the Notification if is visible and destroys then dom nodes\n     * @type {function}\n     * @name Notification.close\n     */\n    Notification.prototype.close = function (closeType) {\n        let $tooltip = this.$tooltip;\n        if(!$tooltip){\n            return this; // if already closed\n        }\n        $tooltip.removeClass('notification-ui-visible')\n            .addClass('notification-ui-hidden');\n        setTimeout(()=>{\n            // wait for the animation to complete before removal\n            $tooltip.remove();\n            this.$tooltip = null;\n            WorkspaceManager.off(WorkspaceManager.EVENT_WORKSPACE_UPDATE_LAYOUT, $tooltip[0].update);\n            this._result.resolve(closeType);\n        }, 1000);\n        return this;\n    };\n\n    /**\n     * Adds a done callback to the Notification promise. The promise will be resolved\n     * when the Notification is dismissed. Never rejected.\n     * @example <caption>Print the close reason on console when the notification closes</caption>\n     * notificationInstance.done((closeReason)=>{\n     *     console.log(closeReason)\n     * })\n     * @type {function}\n     * @name Notification.done\n     */\n    Notification.prototype.done = function (callback) {\n        this._promise.done(callback);\n    };\n\n    /**\n     * Creates a new notification popup from given template.\n     * The template can either be a string or a jQuery object representing a DOM node that is *not* in the current DOM.\n     *\n     * @example <caption>Creating a notification popup</caption>\n     * ```js\n     * // note that you can even provide an HTML Element node with\n     * // custom event handlers directly here instead of HTML text.\n     * let notification1 = NotificationUI.createFromTemplate(\n     *   \"<div>Click me to </br>locate the file in file tree</div>\", \"showInfileTree\",{\n     *       allowedPlacements: ['top', 'bottom'],\n     *       dismissOnClick: false,\n     *       autoCloseTimeS: 300 // auto close the popup after 5 minutes\n     *   });\n     * ```\n     *\n     * @param {string|Element} template A string template or HTML Element to use as the dialog HTML.\n     * @param {String} [elementID] optional id string if provided will show the notification pointing to the element.\n     *   If no element is specified, it will be managed as a generic notification.\n     * @param {Object} [options] optional, supported\n     *   * options are:\n     *   * `allowedPlacements` - Optional String array with values restricting where the notification will be shown.\n     *       Values can be a mix of `['top', 'bottom', 'left', 'right']`\n     *   * `autoCloseTimeS` - Time in seconds after which the notification should be auto closed. Default is never.\n     *   * `dismissOnClick` - when clicked, the notification is closed. Default is true(dismiss).\n     * @return {Notification} Object with a done handler that resolves when the notification closes.\n     * @type {function}\n     */\n    function createFromTemplate(template, elementID, options) {\n        // https://floating-ui.com/docs/tutorial\n        options.allowedPlacements = options.allowedPlacements || ['top', 'bottom', 'left', 'right'];\n        options.dismissOnClick = options.dismissOnClick || true;\n        if(!elementID){\n            elementID = 'notificationUIDefaultAnchor';\n        }\n        const tooltip = _createDomElementWithArrowElement(template, elementID, options);\n        tooltip.addClass('notification-ui-visible');\n        let notification = (new Notification(tooltip));\n\n        if(options.autoCloseTimeS){\n            setTimeout(()=>{\n                notification.close(exports.CLOSE_TIMEOUT);\n            }, options.autoCloseTimeS * 1000);\n        }\n\n        if(options.dismissOnClick){\n            tooltip.click(()=>{\n                notification.close(exports.CLOSE_CLICK_DISMISS);\n            });\n        }\n        return notification;\n    }\n\n    let notificationWidgetCount = 0;\n\n    function _computePlacementWithArrowElement(tooltip, arrowElement, {x, y, placement, middlewareData}) {\n        Object.assign(tooltip.style, {\n            left: `${x}px`,\n            top: `${y}px`\n        });\n        if(arrowElement){\n            const {x: arrowX, y: arrowY} = middlewareData.arrow;\n\n            const staticSide = {\n                top: 'bottom',\n                right: 'left',\n                bottom: 'top',\n                left: 'right'\n            }[placement.split('-')[0]];\n\n            Object.assign(arrowElement.style, {\n                left: arrowX != null ? `${arrowX}px` : '',\n                top: arrowY != null ? `${arrowY}px` : '',\n                right: '',\n                bottom: '',\n                [staticSide]: '-4px'\n            });\n        }\n    }\n\n    function _updatePositions(tooltip, onElement, arrowElement, options) {\n        let middleWare=  [\n            FloatingUIDOM.offset(6),\n            FloatingUIDOM.autoPlacement({\n                // 'right' and 'left' won't be chosen\n                allowedPlacements: options.allowedPlacements\n            }),\n            FloatingUIDOM.shift({padding: 5})\n        ];\n        if(arrowElement){\n            middleWare.push(FloatingUIDOM.arrow({element: arrowElement}));\n        }\n        tooltip.update = function () {\n            FloatingUIDOM.computePosition(onElement, tooltip, {\n                placement: 'top',\n                middleware: middleWare\n            }).then(({x, y, placement, middlewareData}) => {\n                _computePlacementWithArrowElement(tooltip, arrowElement,\n                    {x, y, placement, middlewareData});\n            });\n        };\n        tooltip.update();\n        WorkspaceManager.on(WorkspaceManager.EVENT_WORKSPACE_UPDATE_LAYOUT, tooltip.update);\n    }\n\n    function _createDomElementWithArrowElement(domTemplate, elementID, options) {\n        notificationWidgetCount++;\n        const onElement = document.getElementById(elementID);\n        let arrowElement;\n        let widgetID = `notification-ui-widget-${notificationWidgetCount}`;\n        let arrowID = `notification-ui-arrow-${notificationWidgetCount}`;\n        let textTemplate = null;\n        if (typeof domTemplate === 'string' || domTemplate instanceof String){\n            textTemplate = domTemplate;\n        }\n        let floatingDom = $(`<div id=\"${widgetID}\" class=\"notification-ui-tooltip\" role=\"tooltip\">\n                                ${textTemplate||''}</div>`);\n        if(!textTemplate && domTemplate){\n            floatingDom.append($(domTemplate));\n        }\n        if(onElement){\n            arrowElement = $(`<div id=\"${arrowID}\" class=\"notification-ui-arrow\"></div>`);\n            floatingDom.append(arrowElement);\n        }\n        $(\"body\").append(floatingDom);\n        _updatePositions(floatingDom[0], onElement, arrowElement[0], options);\n        return floatingDom;\n    }\n\n    exports.createFromTemplate = createFromTemplate;\n    exports.CLOSE_TIMEOUT = 'closeTimeout';\n    exports.CLOSE_CLICK_DISMISS = 'clickDismiss';\n});\n"],"file":"NotificationUI.js"}
{"version":3,"sources":["language/JSONUtils.js"],"names":["define","require","exports","module","TokenUtils","TOKEN_KEY","TOKEN_VALUE","valueTokenTypes","regexAllowedChars","_createContextInfo","token","tokenType","offset","keyName","valueName","parentKeyName","isArray","exclusionList","shouldReplace","stripQuotes","string","test","charAt","substr","length","_getParentKeyName","ctx","braceParity","hasColon","moveSkippingWhitespace","movePrevToken","type","_getExclusionList","editor","constPos","ctxPrev","ctxNext","pos","$","extend","getInitialContext","_codeMirror","push","moveNextToken","getContextInfo","requireParent","requireNextToken","hasComma","hasBracket","offsetInToken","end","ch","indexOf"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2015 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var TokenUtils      = require(\"utils/TokenUtils\");\n\n    // Enumerations for token types.\n    var TOKEN_KEY   = 1,\n        TOKEN_VALUE = 2;\n\n    // Whitelist for allowed value types.\n    var valueTokenTypes = [\"atom\", \"string\", \"number\", \"variable\"];\n\n    // Reg-ex to match colon, comma, opening bracket of an array and white-space.\n    var regexAllowedChars = /(?:^[:,\\[]$)|(?:^\\s+$)/;\n\n    /**\n     * @private\n     *\n     * Returns an object that represents all its parameters\n     *\n     * @param {!Object} token CodeMirror token\n     * @param {!number} tokenType Type of current token\n     * @param {!number} offset Offset in current token\n     * @param {!String} keyName Name of corresponding key\n     * @param {String} valueName Name of current value\n     * @param {String} parentKeyName Name of parent key name\n     * @param {Boolean} isArray Whether or not we are inside an array\n     * @param {Array.<String>} exclusionList An array of keys that have already been used in the context of an object\n     * @param {Boolean} shouldReplace Should we just replace the current token or also add colons/braces/brackets to it\n     * @return {!{token: Object, tokenType: number, offset: number, keyName: String, valueName: String, parentKeyName: String, isArray: Boolean, exclusionList: Array.<String>, shouldReplace: Boolean}}\n     */\n    function _createContextInfo(token, tokenType, offset, keyName, valueName, parentKeyName, isArray, exclusionList, shouldReplace) {\n        return {\n            token: token || null,\n            tokenType: tokenType || null,\n            offset: offset || 0,\n            keyName: keyName || null,\n            valueName: valueName || null,\n            parentKeyName: parentKeyName || null,\n            isArray: isArray || false,\n            exclusionList: exclusionList || [],\n            shouldReplace: shouldReplace || false\n        };\n    }\n\n    /**\n     * Removes the quotes around a string\n     *\n     * @param {!String} string\n     * @return {String}\n     */\n    function stripQuotes(string) {\n        if (string) {\n            if (/^['\"]$/.test(string.charAt(0))) {\n                string = string.substr(1);\n            }\n            if (/^['\"]$/.test(string.substr(-1, 1))) {\n                string = string.substr(0, string.length - 1);\n            }\n        }\n        return string;\n    }\n\n    /**\n     * @private\n     *\n     * Returns the name of parent object\n     *\n     * @param {!{editor:!CodeMirror, pos:!{ch:number, line:number}, token:Object}} ctx\n     * @return {String}\n     */\n    function _getParentKeyName(ctx) {\n        var parentKeyName, braceParity = 1, hasColon;\n\n        // Move the context back to find the parent key.\n        while (TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx)) {\n            if (ctx.token.type === null) {\n                if (ctx.token.string === \"}\") {\n                    braceParity++;\n                } else if (ctx.token.string === \"{\") {\n                    braceParity--;\n                }\n            }\n\n            if (braceParity === 0) {\n                while (TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx)) {\n                    if (ctx.token.type === null && ctx.token.string === \":\") {\n                        hasColon = true;\n                    } else if (ctx.token.type === \"string property\") {\n                        parentKeyName = stripQuotes(ctx.token.string);\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n\n        if (parentKeyName && hasColon) {\n            return parentKeyName;\n        }\n        return null;\n    }\n\n    /**\n     * @private\n     *\n     * Returns a list of properties that are already used by an object\n     *\n     * @param {!Editor} editor\n     * @param {!{line: number, ch: number}} constPos\n     * @return {Array.<String>}\n     */\n    function _getExclusionList(editor, constPos) {\n        var ctxPrev, ctxNext, exclusionList = [], pos, braceParity;\n\n        // Move back to find exclusions.\n        pos = $.extend({}, constPos);\n        braceParity = 1;\n        ctxPrev = TokenUtils.getInitialContext(editor._codeMirror, pos);\n        while (TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctxPrev)) {\n            if (ctxPrev.token.type === null) {\n                if (ctxPrev.token.string === \"}\") {\n                    braceParity++;\n                } else if (ctxPrev.token.string === \"{\") {\n                    braceParity--;\n                }\n            }\n\n            if (braceParity === 1 && ctxPrev.token.type === \"string property\") {\n                exclusionList.push(stripQuotes(ctxPrev.token.string));\n            } else if (braceParity === 0) {\n                break;\n            }\n        }\n\n        // Move forward and find exclusions.\n        pos = $.extend({}, constPos);\n        braceParity = 1;\n        ctxNext = TokenUtils.getInitialContext(editor._codeMirror, pos);\n        while (TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctxNext)) {\n            if (ctxNext.token.type === null) {\n                if (ctxNext.token.string === \"{\") {\n                    braceParity++;\n                } else if (ctxNext.token.string === \"}\") {\n                    braceParity--;\n                }\n            }\n\n            if (braceParity === 1 && ctxNext.token.type === \"string property\") {\n                exclusionList.push(stripQuotes(ctxNext.token.string));\n            } else if (braceParity === 0) {\n                break;\n            }\n        }\n\n        return exclusionList;\n    }\n\n    /**\n     * Returns context info at a given position in editor\n     *\n     * @param {!Editor} editor\n     * @param {!{line: number, ch: number}} constPos Position of cursor in the editor\n     * @param {Boolean} requireParent If true will look for parent key name\n     * @param {Boolean} requireNextToken if true we can replace the next token of a value.\n     * @return {!{token: Object, tokenType: number, offset: number, keyName: String, valueName: String, parentKeyName: String, isArray: Boolean, exclusionList: Array.<String>, shouldReplace: Boolean}}\n     */\n    function getContextInfo(editor, constPos, requireParent, requireNextToken) {\n        var pos, ctx, ctxPrev, ctxNext, offset, keyName, valueName, parentKeyName,\n            isArray, exclusionList, hasColon, hasComma, hasBracket, shouldReplace;\n\n        pos = $.extend({}, constPos);\n        ctx = TokenUtils.getInitialContext(editor._codeMirror, pos);\n        offset = TokenUtils.offsetInToken(ctx);\n\n        if (ctx.token && ctx.token.type === \"string property\") {\n            // String literals used as keys.\n\n            // Disallow hints if cursor is out of the string.\n            if (/^['\"]$/.test(ctx.token.string.substr(-1, 1)) &&\n                    ctx.token.string.length !== 1 && ctx.token.end === pos.ch) {\n                return null;\n            }\n            keyName = stripQuotes(ctx.token.string);\n\n            // Get parent key name.\n            if (requireParent) {\n                ctxPrev = $.extend(true, {}, ctx);\n                parentKeyName = stripQuotes(_getParentKeyName(ctxPrev));\n            }\n\n            // Check if the key is followed by a colon, so we should not append colon again.\n            ctxNext = $.extend(true, {}, ctx);\n            TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctxNext);\n            if (ctxNext.token.type === null && ctxNext.token.string === \":\") {\n                shouldReplace = true;\n            }\n\n            // Get an exclusion list of properties.\n            pos = $.extend({}, constPos);\n            exclusionList = _getExclusionList(editor, pos);\n\n            return _createContextInfo(ctx.token, TOKEN_KEY, offset, keyName, valueName, parentKeyName, null, exclusionList, shouldReplace);\n        } else if (ctx.token && (valueTokenTypes.indexOf(ctx.token.type) !== -1 ||\n                                (ctx.token.type === null && regexAllowedChars.test(ctx.token.string)))) {\n            // Boolean, String, Number and variable literal values.\n\n            // Disallow hints if cursor is out of the string.\n            if (ctx.token.type === \"string\" && /^['\"]$/.test(ctx.token.string.substr(-1, 1)) &&\n                    ctx.token.string.length !== 1 && ctx.token.end === pos.ch) {\n                return null;\n            }\n            valueName = ctx.token.string;\n\n            // Check the current token\n            if (ctx.token.type === null) {\n                if (ctx.token.string === \":\") {\n                    hasColon = true;\n                } else if (ctx.token.string === \",\") {\n                    hasComma = true;\n                } else if (ctx.token.string === \"[\") {\n                    hasBracket = true;\n                }\n            }\n\n            // move context back and find corresponding key name.\n            ctxPrev = $.extend(true, {}, ctx);\n            while (TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctxPrev)) {\n                if (ctxPrev.token.type === \"string property\") {\n                    keyName = stripQuotes(ctxPrev.token.string);\n                    break;\n                } else if (ctxPrev.token.type === null) {\n                    if (ctxPrev.token.string === \":\") {\n                        hasColon = true;\n                    } else if (ctxPrev.token.string === \",\") {\n                        hasComma = true;\n                    } else if (ctxPrev.token.string === \"[\") {\n                        hasBracket = true;\n                    } else {\n                        return null;\n                    }\n                } else if (!hasComma) {\n                    return null;\n                }\n            }\n\n            // If no key name or colon found OR\n            // If we have a comma but no opening bracket, return null.\n            if ((!keyName || !hasColon) || (hasComma && !hasBracket)) {\n                return null;\n            }\n            isArray = hasBracket;\n\n\n            // Get parent key name.\n            if (requireParent) {\n                ctxPrev = $.extend(true, {}, ctx);\n                parentKeyName = stripQuotes(_getParentKeyName(ctxPrev));\n            }\n\n            // Check if we can replace the next token of a value.\n            ctxNext = $.extend(true, {}, ctx);\n            TokenUtils.moveNextToken(ctxNext);\n            if (requireNextToken && valueTokenTypes.indexOf(ctxNext.token.type) !== -1) {\n                shouldReplace = true;\n            }\n\n            return _createContextInfo((shouldReplace) ? ctxNext.token : ctx.token, TOKEN_VALUE, offset, keyName, valueName, parentKeyName, isArray, null, shouldReplace);\n        }\n\n        return null;\n    }\n\n    // Expose public API.\n    exports.TOKEN_KEY           = TOKEN_KEY;\n    exports.TOKEN_VALUE         = TOKEN_VALUE;\n    exports.regexAllowedChars   = regexAllowedChars;\n    exports.getContextInfo      = getContextInfo;\n    exports.stripQuotes         = stripQuotes;\n});\n"],"file":"JSONUtils.js"}
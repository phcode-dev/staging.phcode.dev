{"version":3,"sources":["language/LanguageManager.js"],"names":["define","require","exports","module","CodeMirror","EventDispatcher","Async","FileUtils","Strings","_defaultLanguagesJSON","_","PreferencesManager","_fallbackLanguage","_pendingLanguages","_languages","_baseFileExtensionToLanguageMap","_fileExtensionToLanguageMap","Object","create","_fileNameToLanguageMap","_filePathToLanguageMap","_modeToLanguageMap","_ready","_EXTENSION_MAP_PREF","_NAME_MAP_PREF","_prefState","_validateNonEmptyString","value","description","deferred","reportError","reject","console","error","prototype","toString","call","_patchCodeMirror","_original_CodeMirror_defineMode","defineMode","_wrapped_CodeMirror_defineMode","name","modes","apply","arguments","_setLanguageForMode","mode","language","warn","_name","getLanguage","id","getLanguageForExtension","extension","toLowerCase","getLanguageForPath","path","ignoreOverride","fileName","parts","getBaseName","split","shift","length","join","getLanguages","$","extend","_getLanguageForMode","log","_triggerLanguageAdded","getId","trigger","_triggerLanguageModified","setLanguageOverrideForPath","fullPath","oldLang","newLang","_resetPathLanguageOverrides","getCompoundFileExtension","baseName","pop","i","unshift","Language","this","_fileExtensions","_fileNames","_lineCommentSyntax","defineLanguage","definition","result","Deferred","promise","fileExtensions","fileNames","blockComment","lineComment","l","_finishRegisteringLanguage","addFileExtension","addFileName","_setBinary","isBinary","_updateFromPrefs","_setId","_setName","setBlockCommentSyntax","setLineCommentSyntax","resolve","_loadAndSetMode","done","getMode","fail","always","_restoreOverriddenDefault","state","overridden","add","pref","newMapping","get","newNames","keys","last","forEach","remove","difference","_id","_mode","_blockCommentSyntax","_isBinary","match","getName","self","mimeMode","Array","isArray","finish","modeConfig","mimeModes","_wasModified","getFileExtensions","concat","getFileNames","_addFileExtension","bind","charAt","substr","indexOf","push","removeFileExtension","_removeFileExtension","index","splice","_addFileName","removeFileName","_removeFileName","hasLineCommentSyntax","getLineCommentPrefixes","prefix","prefixes","String","hasBlockCommentSyntax","Boolean","getBlockCommentPrefix","getBlockCommentSuffix","suffix","getLanguageForMode","isFallbackLanguage","makeEventDispatcher","defineMIME","scriptTypes","matches","JSON","parse","doInParallel","key","html","php","scss","stylus","pm","definePreference","DESCRIPTION_LANGUAGE_FILE_EXTENSIONS","on","DESCRIPTION_LANGUAGE_FILE_NAMES","ready"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: LanguageManager*/\n\n/**\n * LanguageManager provides access to the languages supported by Brackets\n *\n * To find out which languages we support by default, have a look at languages.json.\n *\n * To get access to an existing language, call getLanguage():\n *\n *     var language = LanguageManager.getLanguage(\"<id>\");\n *\n * To define your own languages, call defineLanguage():\n *\n *     LanguageManager.defineLanguage(\"haskell\", {\n *         name: \"Haskell\",\n *         mode: \"haskell\",\n *         fileExtensions: [\"hs\"],\n *         blockComment: [\"{-\", \"-}\"],\n *         lineComment: [\"--\"]\n *     });\n *\n * To use that language and its related mode, wait for the returned promise to be resolved:\n *\n *     LanguageManager.defineLanguage(\"haskell\", definition).done(function (language) {\n *         console.log(\"Language \" + language.getName() + \" is now available!\");\n *     });\n *\n * The extension can also contain dots:\n *\n *     LanguageManager.defineLanguage(\"literatecoffeescript\", {\n *         name: \"Literate CoffeeScript\",\n *         mode: \"coffeescript\",\n *         fileExtensions: [\"litcoffee\", \"coffee.md\"]\n *     });\n *\n * You can also specify file names:\n *\n *     LanguageManager.defineLanguage(\"makefile\", {\n *         name: \"Make\",\n *         mode: [\"null\", \"text/plain\"],\n *         fileNames: [\"Makefile\"]\n *     });\n *\n * You can combine file names and extensions, or not define them at all.\n *\n * You can also refine an existing language:\n *\n *     var language = LanguageManager.getLanguage(\"haskell\");\n *     language.setLineCommentSyntax([\"--\"]);\n *     language.setBlockCommentSyntax(\"{-\", \"-}\");\n *     language.addFileExtension(\"lhs\");\n *\n * Some CodeMirror modes define variations of themselves. They are called MIME modes.\n * To find existing MIME modes, search for \"CodeMirror.defineMIME\" in thirdparty/CodeMirror/mode\n * For instance, C++, C# and Java all use the clike (C-like) mode with different settings and a different MIME name.\n * You can refine the mode definition by specifying the MIME mode as well:\n *\n *     LanguageManager.defineLanguage(\"csharp\", {\n *         name: \"C#\",\n *         mode: [\"clike\", \"text/x-csharp\"],\n *         ...\n *     });\n *\n * Defining the base mode is still necessary to know which file to load.\n * However, language.getMode() will return just the MIME mode if one was\n * specified.\n *\n * If you need to configure a mode, you can just create a new MIME mode and use that:\n *\n *     CodeMirror.defineMIME(\"text/x-brackets-html\", {\n *         \"name\": \"htmlmixed\",\n *         \"scriptTypes\": [{\"matches\": /\\/x-handlebars-template|\\/x-mustache/i,\n *                        \"mode\": null}]\n *     });\n *\n *     LanguageManager.defineLanguage(\"html\", {\n *         name: \"HTML\",\n *         mode: [\"htmlmixed\", \"text/x-brackets-html\"],\n *         ...\n *     });\n *\n * If a mode is not shipped with our CodeMirror distribution, you need to first load it yourself.\n * If the mode is part of our CodeMirror distribution, it gets loaded automatically.\n *\n * You can also defines binary file types, i.e. Brackets supports image files by default,\n * such as *.jpg, *.png etc.\n * Binary files do not require mode because modes are specific to CodeMirror, which\n * only handles text based file types.\n * To register a binary language the isBinary flag must be set, i.e.\n *\n *     LanguageManager.defineLanguage(\"audio\", {\n *         name: \"Audio\",\n *         fileExtensions: [\"mp3\", \"wav\", \"aif\", \"aiff\", \"ogg\"],\n *         isBinary: true\n *     });\n *\n *\n * LanguageManager dispatches two events:\n *\n *  - languageAdded -- When any new Language is added. 2nd arg is the new Language.\n *  - languageModified -- When the attributes of a Language change, or when the Language gains or loses\n *          file extension / filename mappings. 2nd arg is the modified Language.\n */\ndefine(function (require, exports, module) {\n\n\n\n    // Dependencies\n    var CodeMirror            = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        EventDispatcher       = require(\"utils/EventDispatcher\"),\n        Async                 = require(\"utils/Async\"),\n        FileUtils             = require(\"file/FileUtils\"),\n        Strings               = require(\"strings\"),\n        _defaultLanguagesJSON = require(\"text!language/languages.json\"),\n        _                     = require(\"thirdparty/lodash\"),\n\n        // PreferencesManager is loaded near the end of the file\n        PreferencesManager;\n\n    // State\n    var _fallbackLanguage               = null,\n        _pendingLanguages               = {},\n        _languages                      = {},\n        _baseFileExtensionToLanguageMap = {},\n        _fileExtensionToLanguageMap     = Object.create(_baseFileExtensionToLanguageMap),\n        _fileNameToLanguageMap          = {},\n        _filePathToLanguageMap          = {},\n        _modeToLanguageMap              = {},\n        _ready;\n\n    // Constants\n\n    var _EXTENSION_MAP_PREF = \"language.fileExtensions\",\n        _NAME_MAP_PREF      = \"language.fileNames\";\n\n    // Tracking for changes to mappings made by preferences\n    var _prefState = {};\n\n    _prefState[_EXTENSION_MAP_PREF] = {\n        last: {},\n        overridden: {},\n        add: \"addFileExtension\",\n        remove: \"removeFileExtension\",\n        get: \"getLanguageForExtension\"\n    };\n\n    _prefState[_NAME_MAP_PREF] = {\n        last: {},\n        overridden: {},\n        add: \"addFileName\",\n        remove: \"removeFileName\",\n        get: \"getLanguageForPath\"\n    };\n\n    // Helper functions\n\n    /**\n     * Checks whether value is a non-empty string. Reports an error otherwise.\n     * If no deferred is passed, console.error is called.\n     * Otherwise the deferred is rejected with the error message.\n     * @param {*}                value         The value to validate\n     * @param {!string}          description   A helpful identifier for value\n     * @param {?jQuery.Deferred} deferred      A deferred to reject with the error message in case of an error\n     * @return {boolean} True if the value is a non-empty string, false otherwise\n     */\n    function _validateNonEmptyString(value, description, deferred) {\n        var reportError = deferred ? deferred.reject : console.error;\n\n        // http://stackoverflow.com/questions/1303646/check-whether-variable-is-number-or-string-in-javascript\n        if (Object.prototype.toString.call(value) !== \"[object String]\") {\n            reportError(description + \" must be a string\");\n            return false;\n        }\n        if (value === \"\") {\n            reportError(description + \" must not be empty\");\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Monkey-patch CodeMirror to prevent modes from being overwritten by extensions.\n     * We may rely on the tokens provided by some of these modes.\n     */\n    function _patchCodeMirror() {\n        var _original_CodeMirror_defineMode = CodeMirror.defineMode;\n        function _wrapped_CodeMirror_defineMode(name) {\n            if (CodeMirror.modes[name]) {\n                console.error(\"There already is a CodeMirror mode with the name \\\"\" + name + \"\\\"\");\n                return;\n            }\n            _original_CodeMirror_defineMode.apply(CodeMirror, arguments);\n        }\n        CodeMirror.defineMode = _wrapped_CodeMirror_defineMode;\n    }\n\n    /**\n     * Adds a global mode-to-language association.\n     * @param {!string} mode The mode to associate the language with\n     * @param {!Language} language The language to associate with the mode\n     */\n    function _setLanguageForMode(mode, language) {\n        if (_modeToLanguageMap[mode]) {\n            console.warn(\"CodeMirror mode \\\"\" + mode + \"\\\" is already used by language \" + _modeToLanguageMap[mode]._name + \" - cannot fully register language \" + language._name +\n                         \" using the same mode. Some features will treat all content with this mode as language \" + _modeToLanguageMap[mode]._name);\n            return;\n        }\n\n        _modeToLanguageMap[mode] = language;\n    }\n\n    /**\n     * Resolves a language ID to a Language object.\n     * File names have a higher priority than file extensions.\n     * @param {!string} id Identifier for this language: lowercase letters, digits, and _ separators (e.g. \"cpp\", \"foo_bar\", \"c99\")\n     * @return {Language} The language with the provided identifier or undefined\n     */\n    function getLanguage(id) {\n        return _languages[id];\n    }\n\n    /**\n     * Resolves a file extension to a Language object.\n     * *Warning:* it is almost always better to use getLanguageForPath(), since Language can depend\n     * on file name and even full path. Use this API only if no relevant file/path exists.\n     * @param {!string} extension Extension that language should be resolved for\n     * @return {?Language} The language for the provided extension or null if none exists\n     */\n    function getLanguageForExtension(extension) {\n        return _fileExtensionToLanguageMap[extension.toLowerCase()];\n    }\n\n    /**\n     * Resolves a file path to a Language object.\n     * @param {!string} path Path to the file to find a language for\n     * @param {?boolean} ignoreOverride If set to true will cause the lookup to ignore any\n     *      overrides and return default binding. By default override is not ignored.\n     *\n     * @return {Language} The language for the provided file type or the fallback language\n     */\n    function getLanguageForPath(path, ignoreOverride) {\n        var fileName,\n            language = _filePathToLanguageMap[path],\n            extension,\n            parts;\n\n        // if there's an override, return it\n        if (!ignoreOverride && language) {\n            return language;\n        }\n\n        fileName = FileUtils.getBaseName(path).toLowerCase();\n        language = _fileNameToLanguageMap[fileName];\n\n        // If no language was found for the file name, use the file extension instead\n        if (!language) {\n            // Split the file name into parts:\n            //   \"foo.coffee.md\"   => [\"foo\", \"coffee\", \"md\"]\n            //   \".profile.bak\"    => [\"\", \"profile\", \"bak\"]\n            //   \"1. Vacation.txt\" => [\"1\", \" Vacation\", \"txt\"]\n            parts = fileName.split(\".\");\n\n            // A leading dot does not indicate a file extension, but marks the file as hidden => remove it\n            if (parts[0] === \"\") {\n                // [\"\", \"profile\", \"bak\"] => [\"profile\", \"bak\"]\n                parts.shift();\n            }\n\n            // The first part is assumed to be the title, not the extension => remove it\n            //   [\"foo\", \"coffee\", \"md\"]   => [\"coffee\", \"md\"]\n            //   [\"profile\", \"bak\"]        => [\"bak\"]\n            //   [\"1\", \" Vacation\", \"txt\"] => [\" Vacation\", \"txt\"]\n            parts.shift();\n\n            // Join the remaining parts into a file extension until none are left or a language was found\n            while (!language && parts.length) {\n                // First iteration:\n                //   [\"coffee\", \"md\"]     => \"coffee.md\"\n                //   [\"bak\"]              => \"bak\"\n                //   [\" Vacation\", \"txt\"] => \" Vacation.txt\"\n                // Second iteration (assuming no language was found for \"coffee.md\"):\n                //   [\"md\"]  => \"md\"\n                //   [\"txt\"] => \"txt\"\n                extension = parts.join(\".\");\n                language  = _fileExtensionToLanguageMap[extension];\n                // Remove the first part\n                // First iteration:\n                //   [\"coffee\", \"md\"]     => [\"md\"]\n                //   [\"bak\"]              => []\n                //   [\" Vacation\", \"txt\"] => [\"txt\"]\n                // Second iteration:\n                //   [\"md\"]  => []\n                //   [\"txt\"] => []\n                parts.shift();\n            }\n        }\n\n        return language || _fallbackLanguage;\n    }\n\n    /**\n     * Returns a map of all the languages currently defined in the LanguageManager. The key to\n     * the map is the language id and the value is the language object.\n     *\n     * @return {Object.<string, Language>} A map containing all of the\n     *      languages currently defined.\n     */\n    function getLanguages() {\n        return $.extend({}, _languages); // copy to prevent modification\n    }\n\n    /**\n     * Resolves a CodeMirror mode to a Language object.\n     * @param {!string} mode CodeMirror mode\n     * @return {Language} The language for the provided mode or the fallback language\n     */\n    function _getLanguageForMode(mode) {\n        var language = _modeToLanguageMap[mode];\n        if (language) {\n            return language;\n        }\n\n        // In case of unsupported languages\n        console.log(\"Called LanguageManager._getLanguageForMode with a mode for which no language has been registered:\", mode);\n        return _fallbackLanguage;\n    }\n\n    /**\n     * @private\n     * Notify listeners when a language is added\n     * @param {!Language} language The new language\n     */\n    function _triggerLanguageAdded(language) {\n        // finally, store language to _language map\n        _languages[language.getId()] = language;\n        exports.trigger(\"languageAdded\", language);\n    }\n\n    /**\n     * @private\n     * Notify listeners when a language is modified\n     * @param {!Language} language The modified language\n     */\n    function _triggerLanguageModified(language) {\n        exports.trigger(\"languageModified\", language);\n    }\n\n    /**\n     * Adds a language mapping for the specified fullPath. If language is falsy (null or undefined), the mapping\n     * is removed. The override is NOT persisted across Brackets sessions.\n     *\n     * @param {!fullPath} fullPath absolute path of the file\n     * @param {?object} language language to associate the file with or falsy value to remove any existing override\n     */\n    function setLanguageOverrideForPath(fullPath, language) {\n        var oldLang = getLanguageForPath(fullPath);\n        if (!language) {\n            delete _filePathToLanguageMap[fullPath];\n        } else {\n            _filePathToLanguageMap[fullPath] = language;\n        }\n        var newLang = getLanguageForPath(fullPath);\n\n        // Old language changed since this path is no longer mapped to it\n        _triggerLanguageModified(oldLang);\n        // New language changed since a path is now mapped to it that wasn't before\n        _triggerLanguageModified(newLang);\n    }\n\n    /**\n     * Resets all the language overrides for file paths. Used by unit tests only.\n     */\n    function _resetPathLanguageOverrides() {\n        _filePathToLanguageMap = {};\n    }\n\n    /**\n     * Get the file extension (excluding \".\") given a path OR a bare filename.\n     * Returns \"\" for names with no extension.\n     * If the only `.` in the file is the first character,\n     * returns \"\" as this is not considered an extension.\n     * This method considers known extensions which include `.` in them.\n     *\n     * @param {string} fullPath full path to a file or directory\n     * @return {string} Returns the extension of a filename or empty string if\n     * the argument is a directory or a filename with no extension\n     */\n    function getCompoundFileExtension(fullPath) {\n        var baseName = FileUtils.getBaseName(fullPath),\n            parts = baseName.split(\".\");\n\n        // get rid of file name\n        parts.shift();\n        if (baseName[0] === \".\") {\n            // if starts with a `.`, then still consider it as file name\n            parts.shift();\n        }\n\n        var extension = [parts.pop()], // last part is always an extension\n            i = parts.length;\n        while (i--) {\n            if (getLanguageForExtension(parts[i])) {\n                extension.unshift(parts[i]);\n            } else {\n                break;\n            }\n        }\n        return extension.join(\".\");\n    }\n\n\n\n    /**\n     * Model for a language.\n     * @constructor\n     */\n    function Language() {\n        this._fileExtensions    = [];\n        this._fileNames         = [];\n        this._modeToLanguageMap = {};\n        this._lineCommentSyntax = [];\n    }\n\n\n    /**\n     * Identifier for this language\n     * @type {string}\n     */\n    Language.prototype._id = null;\n\n    /**\n     * Human-readable name of this language\n     * @type {string}\n     */\n    Language.prototype._name = null;\n\n    /**\n     * CodeMirror mode for this language\n     * @type {string}\n     */\n    Language.prototype._mode = null;\n\n    /**\n     * File extensions that use this language\n     * @type {Array.<string>}\n     */\n    Language.prototype._fileExtensions = null;\n\n    /**\n     * File names for extensionless files that use this language\n     * @type {Array.<string>}\n     */\n    Language.prototype._fileNames = null;\n\n    /**\n     * Line comment syntax\n     * @type {Array.<string>}\n     */\n    Language.prototype._lineCommentSyntax = null;\n\n    /**\n     * Which language to use for what CodeMirror mode\n     * @type {Object.<string,Language>}\n     */\n    Language.prototype._modeToLanguageMap = null;\n\n    /**\n     * Block comment syntax\n     * @type {{ prefix: string, suffix: string }}\n     */\n    Language.prototype._blockCommentSyntax = null;\n\n    /**\n     * Whether or not the language is binary\n     * @type {boolean}\n     */\n    Language.prototype._isBinary = false;\n\n    /**\n     * Returns the identifier for this language.\n     * @return {string} The identifier\n     */\n    Language.prototype.getId = function () {\n        return this._id;\n    };\n\n    /**\n     * Sets the identifier for this language or prints an error to the console.\n     * @param {!string} id Identifier for this language: lowercase letters, digits, and _ separators (e.g. \"cpp\", \"foo_bar\", \"c99\")\n     * @return {boolean} Whether the ID was valid and set or not\n     */\n    Language.prototype._setId = function (id) {\n        if (!_validateNonEmptyString(id, \"Language ID\")) {\n            return false;\n        }\n        // Make sure the ID is a string that can safely be used universally by the computer - as a file name, as an object key, as part of a URL, etc.\n        // Hence we use \"_\" instead of \".\" since the latter often has special meaning\n        if (!id.match(/^[a-z0-9]+(_[a-z0-9]+)*$/)) {\n            console.error(\"Invalid language ID \\\"\" + id + \"\\\": Only groups of lower case letters and numbers are allowed, separated by underscores.\");\n            return false;\n        }\n\n        this._id = id;\n        return true;\n    };\n\n    /**\n     * Returns the human-readable name of this language.\n     * @return {string} The name\n     */\n    Language.prototype.getName = function () {\n        return this._name;\n    };\n\n    /**\n     * Sets the human-readable name of this language or prints an error to the console.\n     * @param {!string} name Human-readable name of the language, as it's commonly referred to (e.g. \"C++\")\n     * @return {boolean} Whether the name was valid and set or not\n     */\n    Language.prototype._setName = function (name) {\n        if (!_validateNonEmptyString(name, \"name\")) {\n            return false;\n        }\n\n        this._name = name;\n        return true;\n    };\n\n    /**\n     * Returns the CodeMirror mode for this language.\n     * @return {string} The mode\n     */\n    Language.prototype.getMode = function () {\n        return this._mode;\n    };\n\n    /**\n     * Loads a mode and sets it for this language.\n     *\n     * @param {(string|Array.<string>)} mode  CodeMirror mode (e.g. \"htmlmixed\"), optionally paired with a MIME mode defined by\n     *      that mode (e.g. [\"clike\", \"text/x-c++src\"]). Unless the mode is located in thirdparty/CodeMirror/mode/<name>/<name>.js,\n     *      you need to first load it yourself.\n     * @return {$.Promise} A promise object that will be resolved when the mode is loaded and set\n     */\n    Language.prototype._loadAndSetMode = function (mode) {\n        var result      = new $.Deferred(),\n            self        = this,\n            mimeMode; // Mode can be an array specifying a mode plus a MIME mode defined by that mode [\"clike\", \"text/x-c++src\"]\n\n        if (Array.isArray(mode)) {\n            if (mode.length !== 2) {\n                result.reject(\"Mode must either be a string or an array containing two strings\");\n                return result.promise();\n            }\n            mimeMode = mode[1];\n            mode = mode[0];\n        }\n\n        // mode must not be empty. Use \"null\" (the string \"null\") mode for plain text\n        if (!_validateNonEmptyString(mode, \"mode\", result)) {\n            result.reject();\n            return result.promise();\n        }\n\n        var finish = function () {\n            if (!CodeMirror.modes[mode]) {\n                result.reject(\"CodeMirror mode \\\"\" + mode + \"\\\" is not loaded\");\n                return;\n            }\n\n            if (mimeMode) {\n                var modeConfig = CodeMirror.mimeModes[mimeMode];\n\n                if (!modeConfig) {\n                    result.reject(\"CodeMirror MIME mode \\\"\" + mimeMode + \"\\\" not found\");\n                    return;\n                }\n            }\n\n            // This mode is now only about what to tell CodeMirror\n            // The base mode was only necessary to load the proper mode file\n            self._mode = mimeMode || mode;\n            self._wasModified();\n\n            result.resolve(self);\n        };\n\n        if (CodeMirror.modes[mode]) {\n            finish();\n        } else {\n            require([\"thirdparty/CodeMirror/mode/\" + mode + \"/\" + mode], finish);\n        }\n\n        return result.promise();\n    };\n\n    /**\n     * Returns an array of file extensions for this language.\n     * @return {Array.<string>} File extensions used by this language\n     */\n    Language.prototype.getFileExtensions = function () {\n        // Use concat to create a copy of this array, preventing external modification\n        return this._fileExtensions.concat();\n    };\n\n    /**\n     * Returns an array of file names for extensionless files that use this language.\n     * @return {Array.<string>} Extensionless file names used by this language\n     */\n    Language.prototype.getFileNames = function () {\n        // Use concat to create a copy of this array, preventing external modification\n        return this._fileNames.concat();\n    };\n\n    /**\n     * Adds one or more file extensions to this language.\n     * @param {!string|Array.<string>} extension A file extension (or array thereof) used by this language\n     */\n    Language.prototype.addFileExtension = function (extension) {\n        if (Array.isArray(extension)) {\n            extension.forEach(this._addFileExtension.bind(this));\n        } else {\n            this._addFileExtension(extension);\n        }\n    };\n    Language.prototype._addFileExtension = function (extension) {\n        // Remove a leading dot if present\n        if (extension.charAt(0) === \".\") {\n            extension = extension.substr(1);\n        }\n\n        // Make checks below case-INsensitive\n        extension = extension.toLowerCase();\n\n        if (this._fileExtensions.indexOf(extension) === -1) {\n            this._fileExtensions.push(extension);\n\n            var language = _fileExtensionToLanguageMap[extension];\n            if (language) {\n                console.warn(\"Cannot register file extension \\\"\" + extension + \"\\\" for \" + this._name + \", it already belongs to \" + language._name);\n            } else {\n                _fileExtensionToLanguageMap[extension] = this;\n            }\n\n            this._wasModified();\n        } else if(!_fileExtensionToLanguageMap[extension]) {\n\n            // Language should be in the extension map but isn't\n            _fileExtensionToLanguageMap[extension] = this;\n            this._wasModified();\n        }\n    };\n\n    /**\n     * Unregisters one or more file extensions from this language.\n     * @param {!string|Array.<string>} extension File extension (or array thereof) to stop using for this language\n     */\n    Language.prototype.removeFileExtension = function (extension) {\n        if (Array.isArray(extension)) {\n            extension.forEach(this._removeFileExtension.bind(this));\n        } else {\n            this._removeFileExtension(extension);\n        }\n    };\n    Language.prototype._removeFileExtension = function (extension) {\n        // Remove a leading dot if present\n        if (extension.charAt(0) === \".\") {\n            extension = extension.substr(1);\n        }\n\n        // Make checks below case-INsensitive\n        extension = extension.toLowerCase();\n\n        var index = this._fileExtensions.indexOf(extension);\n        if (index !== -1) {\n            this._fileExtensions.splice(index, 1);\n\n            delete _fileExtensionToLanguageMap[extension];\n\n            this._wasModified();\n        }\n    };\n\n    /**\n     * Adds one or more file names to the language which is used to match files that don't have extensions like \"Makefile\" for example.\n     * @param {!string|Array.<string>} extension An extensionless file name (or array thereof) used by this language\n     */\n    Language.prototype.addFileName = function (name) {\n        if (Array.isArray(name)) {\n            name.forEach(this._addFileName.bind(this));\n        } else {\n            this._addFileName(name);\n        }\n    };\n    Language.prototype._addFileName = function (name) {\n        // Make checks below case-INsensitive\n        name = name.toLowerCase();\n\n        if (this._fileNames.indexOf(name) === -1) {\n            this._fileNames.push(name);\n\n            var language = _fileNameToLanguageMap[name];\n            if (language) {\n                console.warn(\"Cannot register file name \\\"\" + name + \"\\\" for \" + this._name + \", it already belongs to \" + language._name);\n            } else {\n                _fileNameToLanguageMap[name] = this;\n            }\n\n            this._wasModified();\n        }\n    };\n\n    /**\n     * Unregisters one or more file names from this language.\n     * @param {!string|Array.<string>} extension An extensionless file name (or array thereof) used by this language\n     */\n    Language.prototype.removeFileName = function (name) {\n        if (Array.isArray(name)) {\n            name.forEach(this._removeFileName.bind(this));\n        } else {\n            this._removeFileName(name);\n        }\n    };\n    Language.prototype._removeFileName = function (name) {\n        // Make checks below case-INsensitive\n        name = name.toLowerCase();\n\n        var index = this._fileNames.indexOf(name);\n        if (index !== -1) {\n            this._fileNames.splice(index, 1);\n\n            delete _fileNameToLanguageMap[name];\n\n            this._wasModified();\n        }\n    };\n\n    /**\n     * Returns whether the line comment syntax is defined for this language.\n     * @return {boolean} Whether line comments are supported\n     */\n    Language.prototype.hasLineCommentSyntax = function () {\n        return this._lineCommentSyntax.length > 0;\n    };\n\n    /**\n     * Returns an array of prefixes to use for line comments.\n     * @return {Array.<string>} The prefixes\n     */\n    Language.prototype.getLineCommentPrefixes = function () {\n        return this._lineCommentSyntax;\n    };\n\n    /**\n     * Sets the prefixes to use for line comments in this language or prints an error to the console.\n     * @param {!(string|Array.<string>)} prefix Prefix string or an array of prefix strings\n     *   to use for line comments (e.g. \"//\" or [\"//\", \"#\"])\n     * @return {boolean} Whether the syntax was valid and set or not\n     */\n    Language.prototype.setLineCommentSyntax = function (prefix) {\n        var prefixes = Array.isArray(prefix) ? prefix : [prefix];\n        var i;\n\n        if (prefixes.length) {\n            this._lineCommentSyntax = [];\n            for (i = 0; i < prefixes.length; i++) {\n                _validateNonEmptyString(String(prefixes[i]), Array.isArray(prefix) ? \"prefix[\" + i + \"]\" : \"prefix\");\n\n                this._lineCommentSyntax.push(prefixes[i]);\n            }\n            this._wasModified();\n        } else {\n            console.error(\"The prefix array should not be empty\");\n        }\n\n        return true;\n    };\n\n    /**\n     * Returns whether the block comment syntax is defined for this language.\n     * @return {boolean} Whether block comments are supported\n     */\n    Language.prototype.hasBlockCommentSyntax = function () {\n        return Boolean(this._blockCommentSyntax);\n    };\n\n    /**\n     * Returns the prefix to use for block comments.\n     * @return {string} The prefix\n     */\n    Language.prototype.getBlockCommentPrefix = function () {\n        return this._blockCommentSyntax && this._blockCommentSyntax.prefix;\n    };\n\n    /**\n     * Returns the suffix to use for block comments.\n     * @return {string} The suffix\n     */\n    Language.prototype.getBlockCommentSuffix = function () {\n        return this._blockCommentSyntax && this._blockCommentSyntax.suffix;\n    };\n\n    /**\n     * Sets the prefix and suffix to use for blocks comments in this language or prints an error to the console.\n     * @param {!string} prefix Prefix string to use for block comments (e.g. \"<!--\")\n     * @param {!string} suffix Suffix string to use for block comments (e.g. \"-->\")\n     * @return {boolean} Whether the syntax was valid and set or not\n     */\n    Language.prototype.setBlockCommentSyntax = function (prefix, suffix) {\n        if (!_validateNonEmptyString(prefix, \"prefix\") || !_validateNonEmptyString(suffix, \"suffix\")) {\n            return false;\n        }\n\n        this._blockCommentSyntax = { prefix: prefix, suffix: suffix };\n        this._wasModified();\n\n        return true;\n    };\n\n    /**\n     * Returns either a language associated with the mode or the fallback language.\n     * Used to disambiguate modes used by multiple languages.\n     * @param {!string} mode The mode to associate the language with\n     * @return {Language} This language if it uses the mode, or whatever {@link #_getLanguageForMode} returns\n     */\n    Language.prototype.getLanguageForMode = function (mode) {\n        if (mode === this._mode) {\n            return this;\n        }\n        return this._modeToLanguageMap[mode] || _getLanguageForMode(mode);\n    };\n\n    /**\n     * Overrides a mode-to-language association for this particular language only or prints an error to the console.\n     * Used to disambiguate modes used by multiple languages.\n     * @param {!string} mode The mode to associate the language with\n     * @param {!Language} language The language to associate with the mode\n     * @return {boolean} Whether the mode-to-language association was valid and set or not\n     * @private\n     */\n    Language.prototype._setLanguageForMode = function (mode, language) {\n        if (mode === this._mode && language !== this) {\n            console.error(\"A language must always map its mode to itself\");\n            return false;\n        }\n\n        this._modeToLanguageMap[mode] = language;\n        this._wasModified();\n\n        return true;\n    };\n\n    /**\n     * Determines whether this is the fallback language or not\n     * @return {boolean} True if this is the fallback language, false otherwise\n     */\n    Language.prototype.isFallbackLanguage = function () {\n        return this === _fallbackLanguage;\n    };\n\n    /**\n     * Trigger the \"languageModified\" event if this language is registered already\n     * @see #_triggerLanguageModified\n     * @private\n     */\n    Language.prototype._wasModified = function () {\n        if (_languages[this._id]) {\n            _triggerLanguageModified(this);\n        }\n    };\n\n    /**\n     * Indicates whether or not the language is binary (e.g., image or audio).\n     * @return {boolean}\n     */\n    Language.prototype.isBinary = function () {\n        return this._isBinary;\n    };\n\n    /**\n     * Sets whether or not the language is binary\n     * @param {!boolean} isBinary\n     */\n    Language.prototype._setBinary = function (isBinary) {\n        this._isBinary = isBinary;\n    };\n\n    /**\n     * Defines a language.\n     *\n     * @param {!string}               id                        Unique identifier for this language: lowercase letters, digits, and _ separators (e.g. \"cpp\", \"foo_bar\", \"c99\")\n     * @param {!Object}               definition                An object describing the language\n     * @param {!string}               definition.name           Human-readable name of the language, as it's commonly referred to (e.g. \"C++\")\n     * @param {Array.<string>}        definition.fileExtensions List of file extensions used by this language (e.g. [\"php\", \"php3\"] or [\"coffee.md\"] - may contain dots)\n     * @param {Array.<string>}        definition.fileNames      List of exact file names (e.g. [\"Makefile\"] or [\"package.json]). Higher precedence than file extension.\n     * @param {Array.<string>}        definition.blockComment   Array with two entries defining the block comment prefix and suffix (e.g. [\"<!--\", \"-->\"])\n     * @param {(string|Array.<string>)} definition.lineComment  Line comment prefixes (e.g. \"//\" or [\"//\", \"#\"])\n     * @param {(string|Array.<string>)} definition.mode         CodeMirror mode (e.g. \"htmlmixed\"), optionally with a MIME mode defined by that mode [\"clike\", \"text/x-c++src\"]\n     *                                                          Unless the mode is located in thirdparty/CodeMirror/mode/<name>/<name>.js, you need to first load it yourself.\n     *\n     * @return {$.Promise} A promise object that will be resolved with a Language object\n     **/\n    function defineLanguage(id, definition) {\n        var result = new $.Deferred();\n\n        if (_pendingLanguages[id]) {\n            result.reject(\"Language \\\"\" + id + \"\\\" is waiting to be resolved.\");\n            return result.promise();\n        }\n        if (_languages[id]) {\n            result.reject(\"Language \\\"\" + id + \"\\\" is already defined\");\n            return result.promise();\n        }\n\n        var language       = new Language(),\n            name           = definition.name,\n            fileExtensions = definition.fileExtensions,\n            fileNames      = definition.fileNames,\n            blockComment   = definition.blockComment,\n            lineComment    = definition.lineComment,\n            i,\n            l;\n\n        function _finishRegisteringLanguage() {\n            if (fileExtensions) {\n                for (i = 0, l = fileExtensions.length; i < l; i++) {\n                    language.addFileExtension(fileExtensions[i]);\n                }\n            }\n            // register language file names after mode has loaded\n            if (fileNames) {\n                for (i = 0, l = fileNames.length; i < l; i++) {\n                    language.addFileName(fileNames[i]);\n                }\n            }\n\n            language._setBinary(!!definition.isBinary);\n\n            // store language to language map\n            _languages[language.getId()] = language;\n\n            // restore any preferences for non-default languages\n            if(PreferencesManager) {\n                _updateFromPrefs(_EXTENSION_MAP_PREF);\n                _updateFromPrefs(_NAME_MAP_PREF);\n            }\n        }\n\n        if (!language._setId(id) || !language._setName(name) ||\n                (blockComment && !language.setBlockCommentSyntax(blockComment[0], blockComment[1])) ||\n                (lineComment && !language.setLineCommentSyntax(lineComment))) {\n            result.reject();\n            return result.promise();\n        }\n\n\n        if (definition.isBinary) {\n            // add file extensions and store language to language map\n            _finishRegisteringLanguage();\n\n            result.resolve(language);\n            // Not notifying DocumentManager via event LanguageAdded, because DocumentManager\n            // does not care about binary files.\n        } else {\n            // track languages that are currently loading\n            _pendingLanguages[id] = language;\n\n            language._loadAndSetMode(definition.mode).done(function () {\n\n                // globally associate mode to language\n                _setLanguageForMode(language.getMode(), language);\n\n                // add file extensions and store language to language map\n                _finishRegisteringLanguage();\n\n                // fire an event to notify DocumentManager of the new language\n                _triggerLanguageAdded(language);\n\n                result.resolve(language);\n            }).fail(function (error) {\n                console.error(error);\n                result.reject(error);\n            }).always(function () {\n                // delete from pending languages after success and failure\n                delete _pendingLanguages[id];\n            });\n        }\n\n        return result.promise();\n    }\n\n    /**\n     * @private\n     *\n     * If a default file extension or name was overridden by a pref, restore it.\n     *\n     * @param {string} name Extension or filename that should be restored\n     * @param {{overridden: string, add: string}} prefState object for the pref that is currently being updated\n     */\n    function _restoreOverriddenDefault(name, state) {\n        if (state.overridden[name]) {\n            var language = getLanguage(state.overridden[name]);\n            language[state.add](name);\n            delete state.overridden[name];\n        }\n    }\n\n    /**\n     * @private\n     *\n     * Updates extension and filename mappings from languages based on the current preferences values.\n     *\n     * The preferences look like this in a prefs file:\n     *\n     * Map *.foo to javascript, *.vm to html\n     *\n     *     \"language.fileExtensions\": {\n     *         \"foo\": \"javascript\",\n     *         \"vm\": \"html\"\n     *     }\n     *\n     * Map \"Gemfile\" to ruby:\n     *\n     *     \"language.fileNames\": {\n     *         \"Gemfile\": \"ruby\"\n     *     }\n     */\n    function _updateFromPrefs(pref) {\n        var newMapping = PreferencesManager.get(pref),\n            newNames = Object.keys(newMapping),\n            state = _prefState[pref],\n            last = state.last,\n            overridden = state.overridden;\n\n        // Look for added and changed names (extensions or filenames)\n        newNames.forEach(function (name) {\n            var language;\n            if (newMapping[name] !== last[name]) {\n                if (last[name]) {\n                    language = getLanguage(last[name]);\n                    if (language) {\n                        language[state.remove](name);\n\n                        // If this name that was previously mapped was overriding a default\n                        // restore it now.\n                        _restoreOverriddenDefault(name, state);\n                    }\n                }\n\n                language = exports[state.get](name);\n                if (language) {\n                    language[state.remove](name);\n\n                    // We're removing a name that was defined in Brackets or an extension,\n                    // so keep track of how it used to be mapped.\n                    if (!overridden[name]) {\n                        overridden[name] = language.getId();\n                    }\n                }\n                language = getLanguage(newMapping[name]);\n                if (language) {\n                    language[state.add](name);\n                }\n            }\n            if(!getLanguage(newMapping[name])) {\n\n                // If the language doesn't exist, restore any overrides and remove it\n                // from the state.\n                if(overridden[name]) {\n                    _restoreOverriddenDefault(name, state);\n                }\n                delete newMapping[name];\n            }\n        });\n\n        // Look for removed names (extensions or filenames)\n        _.difference(Object.keys(last), newNames).forEach(function (name) {\n            var language = getLanguage(last[name]);\n            if (language) {\n                language[state.remove](name);\n                _restoreOverriddenDefault(name, state);\n            }\n        });\n        state.last = newMapping;\n    }\n\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // Prevent modes from being overwritten by extensions\n    _patchCodeMirror();\n\n    // Define a custom MIME mode here instead of putting it directly into languages.json\n    // because JSON files can't contain regular expressions. Also, all other modes so\n    // far were strings, so we spare us the trouble of allowing more complex mode values.\n    CodeMirror.defineMIME(\"text/x-brackets-html\", {\n        \"name\": \"htmlmixed\",\n        \"scriptTypes\": [\n            {\n                \"matches\": /\\/x-handlebars|\\/x-mustache|\\/ng-template$|^text\\/html$/i,\n                \"mode\": \"htmlmixed\"\n            },\n            {\n                \"matches\": /^text\\/(babel|jsx)$/i,\n                \"mode\": \"jsx\"\n            }\n        ]\n    });\n\n    // Define SVG MIME type so an SVG language can be defined for SVG-specific code hints.\n    // Currently, SVG uses XML mode so it has generic XML syntax highlighting. This can\n    // be removed when SVG gets its own CodeMirror mode with SVG syntax highlighting.\n    CodeMirror.defineMIME(\"image/svg+xml\", \"xml\");\n\n    // Load the default languages\n    _defaultLanguagesJSON = JSON.parse(_defaultLanguagesJSON);\n    _ready = Async.doInParallel(Object.keys(_defaultLanguagesJSON), function (key) {\n        return defineLanguage(key, _defaultLanguagesJSON[key]);\n    }, false);\n\n    // Get the object for HTML\n    _ready.always(function () {\n        var html = getLanguage(\"html\");\n\n        // The htmlmixed mode uses the xml mode internally for the HTML parts, so we map it to HTML\n        html._setLanguageForMode(\"xml\", html);\n\n        // Currently we override the above mentioned \"xml\" in TokenUtils.getModeAt, instead returning \"html\".\n        // When the CSSInlineEditor and the hint providers are no longer based on modes, this can be changed.\n        // But for now, we need to associate this madeup \"html\" mode with our HTML language object.\n        _setLanguageForMode(\"html\", html);\n\n        // Similarly, the php mode uses clike internally for the PHP parts\n        var php = getLanguage(\"php\");\n        php._setLanguageForMode(\"clike\", php);\n\n        // Similar hack to the above for dealing with SCSS/CSS.\n        var scss = getLanguage(\"scss\");\n        scss._setLanguageForMode(\"css\", scss);\n\n        // Map stylus mode to the stylus Brackets language, fixes #13378\n        var stylus = getLanguage(\"stylus\");\n        _setLanguageForMode(\"stylus\", stylus);\n\n        // The fallback language for unknown modes and file extensions\n        _fallbackLanguage = getLanguage(\"unknown\");\n\n        // There is a circular dependency between FileUtils and LanguageManager which\n        // was introduced in 254b01e2f2eebea4416026d0f40d017b8ca6dbc9\n        // and may be preventing us from importing PreferencesManager (which also\n        // depends on FileUtils) here. Using the async form of require fixes this.\n        require([\"preferences/PreferencesManager\"], function (pm) {\n            PreferencesManager = pm;\n            pm.definePreference(_EXTENSION_MAP_PREF, \"object\", {}, {\n                description: Strings.DESCRIPTION_LANGUAGE_FILE_EXTENSIONS\n            }).on(\"change\", function () {\n                _updateFromPrefs(_EXTENSION_MAP_PREF);\n            });\n            pm.definePreference(_NAME_MAP_PREF, \"object\", {}, {\n                description: Strings.DESCRIPTION_LANGUAGE_FILE_NAMES\n            }).on(\"change\", function () {\n                _updateFromPrefs(_NAME_MAP_PREF);\n            });\n            _updateFromPrefs(_EXTENSION_MAP_PREF);\n            _updateFromPrefs(_NAME_MAP_PREF);\n        });\n    });\n\n    // Private for unit tests\n    exports._EXTENSION_MAP_PREF         = _EXTENSION_MAP_PREF;\n    exports._NAME_MAP_PREF              = _NAME_MAP_PREF;\n    exports._resetPathLanguageOverrides = _resetPathLanguageOverrides;\n\n    // Public methods\n    exports.ready                       = _ready;\n    exports.defineLanguage              = defineLanguage;\n    exports.getLanguage                 = getLanguage;\n    exports.getLanguageForExtension     = getLanguageForExtension;\n    exports.getLanguageForPath          = getLanguageForPath;\n    exports.getLanguages                = getLanguages;\n    exports.setLanguageOverrideForPath  = setLanguageOverrideForPath;\n    exports.getCompoundFileExtension    = getCompoundFileExtension;\n});\n"],"file":"LanguageManager.js"}
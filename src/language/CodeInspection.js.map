{"version":3,"sources":["language/CodeInspection.js"],"names":["define","require","exports","module","_","Commands","WorkspaceManager","CommandManager","DocumentManager","EditorManager","Editor","MainViewManager","LanguageManager","PreferencesManager","PerfUtils","Strings","StringUtils","AppInit","StatusBar","Async","PanelTemplate","ResultsTemplate","Mustache","QuickViewManager","CODE_INSPECTION_GUTTER_PRIORITY","CODE_INSPECTION_GUTTER","INDICATOR_ID","Type","ERROR","WARNING","META","_getIconClassForType","type","CODE_MARK_TYPE_INSPECTOR","PREF_ENABLED","PREF_COLLAPSED","PREF_ASYNC_TIMEOUT","PREF_PREFER_PROVIDERS","PREF_PREFERRED_ONLY","prefs","getExtensionPrefs","_enabled","_collapsed","$problemsPanel","problemsPanel","$problemsPanelTable","_gotoEnabled","_providers","_registeredLanguageIDs","_hasErrors","_currentPromise","setGotoEnabled","gotoEnabled","get","NAVIGATE_GOTO_FIRST_PROBLEM","setEnabled","_unregisterAll","getProvidersForPath","filePath","language","getLanguageForPath","getId","context","_buildContext","installedProviders","getProvidersForLanguageId","preferredProviders","prefPreferredProviderNames","prefPreferredOnly","providers","length","reduce","result","key","provider","find","name","push","union","getProviderIDsForLanguage","languageId","map","inspectFile","file","providerList","response","$","Deferred","results","fullPath","getDocumentText","done","fileText","perfTimerInspector","markStart","masterPromise","doInParallel","perfTimerProvider","runPromise","scanResult","scanFileAsync","window","setTimeout","errTimeout","pos","line","col","message","format","LINTER_TIMED_OUT","resolve","errors","jsPromise","then","addMeasurement","catch","err","finalizeMeasurement","errError","LINTER_FAILED","console","error","stack","scanFile","promise","sort","a","b","indexOf","fail","reject","updatePanelTitleAndStatusBar","numProblems","providersReportingProblems","aborted","tooltip","hide","removeClass","MULTIPLE_ERRORS","SINGLE_ERROR","show","ERRORS_PANEL_TITLE_MULTIPLE","text","STATUSBAR_CODE_INSPECTION_TOOLTIP","updateIndicator","_getMarkOptions","MARK_OPTION_UNDERLINE_ERROR","MARK_OPTION_UNDERLINE_WARN","MARK_OPTION_UNDERLINE_INFO","_getMarkTypePriority","_shouldMarkTokenAtPosition","editor","isNaN","ch","warn","markings","findMarksAt","MarkToApplyPriority","shouldMark","mark","markTypePriority","clear","_createMarkerElement","$marker","attr","addClass","click","setCursorPos","html","_addDummyGutterMarkerIfNotExist","marker","getGutterMarker","setGutterMarker","_populateDummyGutterElements","from","to","_updateGutterMarks","gutterErrorMessages","lineno","Object","keys","highestPriorityMarkTypeSeen","gutterMessage","prev","current","getLastVisibleLine","_editorVieportChangeHandler","_evt","getQuickView","token","Promise","codeInspectionMarks","hoverMessage","start","end","content","_updateEditorMarks","resultProviderEntries","getCurrentFullEditor","operation","clearAllMarks","clearGutter","off","on","resultProvider","markToken","run","LINT_DISABLED","currentDoc","getCurrentDocument","allErrors","empty","this","item","Boolean","NO_ERRORS_MULTIPLE_PROVIDER","NO_ERRORS","perfTimerDOM","forEach","inspectionResult","isExpanded","undefined","codeSnippet","getLine","friendlyLine","substr","iconClass","display","providerName","render","reportList","append","scrollTop","NO_LINT_AVAILABLE","getName","NOTHING_TO_LINT","register","indexOfProvider","findIndex","entry","splice","includes","unregisterGutter","registerGutter","concat","updateListeners","event","document","toggleEnabled","enabled","doNotSave","VIEW_TOGGLE_INSPECTION","setChecked","set","save","toggleCollapsed","collapsed","handleGotoFirstProblem","first","trigger","CMD_VIEW_TOGGLE_INSPECTION","CMD_GOTO_FIRST_PROBLEM","definePreference","brackets","config","description","DESCRIPTION_LINTING_ENABLED","e","data","DESCRIPTION_LINTING_COLLAPSED","DESCRIPTION_ASYNC_TIMEOUT","DESCRIPTION_LINTING_PREFER","valueType","DESCRIPTION_USE_PREFERED_ONLY","htmlReady","panelHtml","$selectedRow","createBottomPanel","currentTarget","hasClass","$triangle","nextUntil","toggleClass","val","lineTd","parseInt","character","focusActivePane","statusIconHtml","addIndicator","registerQuickViewProvider","QUICK_VIEW_NAME","_PREF_ASYNC_TIMEOUT","_PREF_PREFER_PROVIDERS","_PREF_PREFERRED_ONLY","requestRun"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global jsPromise*/\n\n/**\n * Manages linters and other code inspections on a per-language basis. Provides a UI and status indicator for\n * the resulting errors/warnings.\n *\n * Currently, inspection providers are only invoked on the current file and only when it is opened, switched to,\n * or saved. But in the future, inspectors may be invoked as part of a global scan, at intervals while typing, etc.\n * Currently, results are only displayed in a bottom panel list and in a status bar icon. But in the future,\n * results may also be displayed inline in the editor (as gutter markers, etc.).\n * In the future, support may also be added for error/warning providers that cannot process a single file at a time\n * (e.g. a full-project compiler).\n */\ndefine(function (require, exports, module) {\n\n\n    const _ = require(\"thirdparty/lodash\");\n\n    // Load dependent modules\n    const Commands                = require(\"command/Commands\"),\n        WorkspaceManager        = require(\"view/WorkspaceManager\"),\n        CommandManager          = require(\"command/CommandManager\"),\n        DocumentManager         = require(\"document/DocumentManager\"),\n        EditorManager           = require(\"editor/EditorManager\"),\n        Editor                  = require(\"editor/Editor\").Editor,\n        MainViewManager         = require(\"view/MainViewManager\"),\n        LanguageManager         = require(\"language/LanguageManager\"),\n        PreferencesManager      = require(\"preferences/PreferencesManager\"),\n        PerfUtils               = require(\"utils/PerfUtils\"),\n        Strings                 = require(\"strings\"),\n        StringUtils             = require(\"utils/StringUtils\"),\n        AppInit                 = require(\"utils/AppInit\"),\n        StatusBar               = require(\"widgets/StatusBar\"),\n        Async                   = require(\"utils/Async\"),\n        PanelTemplate           = require(\"text!htmlContent/problems-panel.html\"),\n        ResultsTemplate         = require(\"text!htmlContent/problems-panel-table.html\"),\n        Mustache                = require(\"thirdparty/mustache/mustache\"),\n        QuickViewManager        = require(\"features/QuickViewManager\");\n\n    const CODE_INSPECTION_GUTTER_PRIORITY      = 500,\n        CODE_INSPECTION_GUTTER = \"code-inspection-gutter\";\n\n    const INDICATOR_ID = \"status-inspection\";\n\n    /** Values for problem's 'type' property */\n    const Type = {\n        /** Unambiguous error, such as a syntax error */\n        ERROR: \"error\",\n        /** Maintainability issue, probable error / bad smell, etc. */\n        WARNING: \"warning\",\n        /** Inspector unable to continue, code too complex for static analysis, etc. Not counted in err/warn tally. */\n        META: \"meta\"\n    };\n\n    function _getIconClassForType(type) {\n        switch (type) {\n        case Type.ERROR: return \"line-icon-problem_type_error fa-solid fa-times-circle\";\n        case Type.WARNING: return \"line-icon-problem_type_warning fa-solid fa-exclamation-triangle\";\n        case Type.META: return \"line-icon-problem_type_info fa-solid fa-info-circle\";\n        default: return \"line-icon-problem_type_info fa-solid fa-info-circle\";\n        }\n    }\n\n    const CODE_MARK_TYPE_INSPECTOR = \"codeInspector\";\n\n    /**\n     * Constants for the preferences defined in this file.\n     */\n    const PREF_ENABLED            = \"enabled\",\n        PREF_COLLAPSED          = \"collapsed\",\n        PREF_ASYNC_TIMEOUT      = \"asyncTimeout\",\n        PREF_PREFER_PROVIDERS   = \"prefer\",\n        PREF_PREFERRED_ONLY     = \"usePreferredOnly\";\n\n    const prefs = PreferencesManager.getExtensionPrefs(\"linting\");\n\n    /**\n     * When disabled, the errors panel is closed and the status bar icon is grayed out.\n     * Takes precedence over _collapsed.\n     * @private\n     * @type {boolean}\n     */\n    var _enabled = false;\n\n    /**\n     * When collapsed, the errors panel is closed but the status bar icon is kept up to date.\n     * @private\n     * @type {boolean}\n     */\n    var _collapsed = false;\n\n    /**\n     * @private\n     * @type {$.Element}\n     */\n    var $problemsPanel;\n\n    /**\n     * @private the panelView\n     * @type {Panel}\n     */\n    var problemsPanel;\n\n    /**\n     * @private\n     * @type {$.Element}\n     */\n    var $problemsPanelTable;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    var _gotoEnabled = false;\n\n    /**\n     * @private\n     * @type {{languageId:string, Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):Object}>}}\n     */\n    var _providers = {};\n\n    /**\n     * @private\n     * @type\n     */\n    let _registeredLanguageIDs = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    var _hasErrors;\n\n    /**\n     * Promise of the returned by the last call to inspectFile or null if linting is disabled. Used to prevent any stale promises\n     * to cause updates of the UI.\n     *\n     * @private\n     * @type {$.Promise}\n     */\n    var _currentPromise = null;\n\n    /**\n     * Enable or disable the \"Go to First Error\" command\n     * @param {boolean} gotoEnabled Whether it is enabled.\n     */\n    function setGotoEnabled(gotoEnabled) {\n        CommandManager.get(Commands.NAVIGATE_GOTO_FIRST_PROBLEM).setEnabled(gotoEnabled);\n        _gotoEnabled = gotoEnabled;\n    }\n\n    function _unregisterAll() {\n        _providers = {};\n    }\n\n    /**\n     * Returns a list of provider for given file path, if available.\n     * Decision is made depending on the file extension.\n     *\n     * @param {!string} filePath\n     * @return {Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):?{errors:!Array, aborted:boolean}}>}\n     */\n    function getProvidersForPath(filePath) {\n        var language            = LanguageManager.getLanguageForPath(filePath).getId(),\n            context             = PreferencesManager._buildContext(filePath, language),\n            installedProviders  = getProvidersForLanguageId(language),\n            preferredProviders,\n\n            prefPreferredProviderNames  = prefs.get(PREF_PREFER_PROVIDERS, context),\n            prefPreferredOnly           = prefs.get(PREF_PREFERRED_ONLY, context),\n\n            providers;\n\n        if (prefPreferredProviderNames && prefPreferredProviderNames.length) {\n            if (typeof prefPreferredProviderNames === \"string\") {\n                prefPreferredProviderNames = [prefPreferredProviderNames];\n            }\n            preferredProviders = prefPreferredProviderNames.reduce(function (result, key) {\n                var provider = _.find(installedProviders, {name: key});\n                if (provider) {\n                    result.push(provider);\n                }\n                return result;\n            }, []);\n            if (prefPreferredOnly) {\n                providers = preferredProviders;\n            } else {\n                providers = _.union(preferredProviders, installedProviders);\n            }\n        } else {\n            providers = installedProviders;\n        }\n        return providers;\n    }\n\n    /**\n     * Returns an array of the IDs of providers registered for a specific language\n     *\n     * @param {!string} languageId\n     * @return {Array.<string>} Names of registered providers.\n     */\n    function getProviderIDsForLanguage(languageId) {\n        if (!_providers[languageId]) {\n            return [];\n        }\n        return _providers[languageId].map(function (provider) {\n            return provider.name;\n        });\n    }\n\n    /**\n     * Runs a file inspection over passed file. Uses the given list of providers if specified, otherwise uses\n     * the set of providers that are registered for the file's language.\n     * This method doesn't update the Brackets UI, just provides inspection results.\n     * These results will reflect any unsaved changes present in the file if currently open.\n     *\n     * The Promise yields an array of provider-result pair objects (the result is the return value of the\n     * provider's scanFile() - see register() for details). The result object may be null if there were no\n     * errors from that provider.\n     * If there are no providers registered for this file, the Promise yields null instead.\n     *\n     * @param {!File} file File that will be inspected for errors.\n     * @param {?Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):?{errors:!Array, aborted:boolean}}>} providerList\n     * @return {$.Promise} a jQuery promise that will be resolved with ?Array.<{provider:Object, result: ?{errors:!Array, aborted:boolean}}>\n     */\n    function inspectFile(file, providerList) {\n        var response = new $.Deferred(),\n            results = [];\n\n        providerList = providerList || getProvidersForPath(file.fullPath);\n\n        if (!providerList.length) {\n            response.resolve(null);\n            return response.promise();\n        }\n\n        DocumentManager.getDocumentText(file)\n            .done(function (fileText) {\n                var perfTimerInspector = PerfUtils.markStart(\"CodeInspection:\\t\" + file.fullPath),\n                    masterPromise;\n\n                masterPromise = Async.doInParallel(providerList, function (provider) {\n                    var perfTimerProvider = PerfUtils.markStart(\"CodeInspection '\" + provider.name + \"':\\t\" + file.fullPath),\n                        runPromise = new $.Deferred();\n\n                    runPromise.done(function (scanResult) {\n                        results.push({provider: provider, result: scanResult});\n                    });\n\n                    if (provider.scanFileAsync) {\n                        window.setTimeout(function () {\n                            // timeout error\n                            var errTimeout = {\n                                pos: { line: -1, col: 0},\n                                message: StringUtils.format(Strings.LINTER_TIMED_OUT, provider.name, prefs.get(PREF_ASYNC_TIMEOUT)),\n                                type: Type.ERROR\n                            };\n                            runPromise.resolve({errors: [errTimeout]});\n                        }, prefs.get(PREF_ASYNC_TIMEOUT));\n                        jsPromise(provider.scanFileAsync(fileText, file.fullPath))\n                            .then(function (scanResult) {\n                                PerfUtils.addMeasurement(perfTimerProvider);\n                                runPromise.resolve(scanResult);\n                            })\n                            .catch(function (err) {\n                                PerfUtils.finalizeMeasurement(perfTimerProvider);\n                                var errError = {\n                                    pos: {line: -1, col: 0},\n                                    message: StringUtils.format(Strings.LINTER_FAILED, provider.name, err),\n                                    type: Type.ERROR\n                                };\n                                console.error(\"[CodeInspection] Provider \" + provider.name + \" (async) failed: \" + err.stack);\n                                runPromise.resolve({errors: [errError]});\n                            });\n                    } else {\n                        try {\n                            var scanResult = provider.scanFile(fileText, file.fullPath);\n                            PerfUtils.addMeasurement(perfTimerProvider);\n                            runPromise.resolve(scanResult);\n                        } catch (err) {\n                            PerfUtils.finalizeMeasurement(perfTimerProvider);\n                            var errError = {\n                                pos: {line: -1, col: 0},\n                                message: StringUtils.format(Strings.LINTER_FAILED, provider.name, err),\n                                type: Type.ERROR\n                            };\n                            console.error(\"[CodeInspection] Provider \" + provider.name + \" (sync) threw an error: \" + err.stack);\n                            runPromise.resolve({errors: [errError]});\n                        }\n                    }\n                    return runPromise.promise();\n\n                }, false);\n\n                masterPromise.then(function () {\n                    // sync async may have pushed results in different order, restore the original order\n                    results.sort(function (a, b) {\n                        return providerList.indexOf(a.provider) - providerList.indexOf(b.provider);\n                    });\n                    PerfUtils.addMeasurement(perfTimerInspector);\n                    response.resolve(results);\n                });\n\n            })\n            .fail(function (err) {\n                console.error(\"[CodeInspection] Could not read file for inspection: \" + file.fullPath);\n                response.reject(err);\n            });\n\n        return response.promise();\n    }\n\n    /**\n     * Update the title of the problem panel and the tooltip of the status bar icon. The title and the tooltip will\n     * change based on the number of problems reported and how many provider reported problems.\n     *\n     * @param {Number} numProblems - total number of problems across all providers\n     * @param {Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):Object}>} providersReportingProblems - providers that reported problems\n     * @param {boolean} aborted - true if any provider returned a result with the 'aborted' flag set\n     */\n    function updatePanelTitleAndStatusBar(numProblems, providersReportingProblems, aborted) {\n        var message, tooltip;\n\n        if (providersReportingProblems.length === 1) {\n            // don't show a header if there is only one provider available for this file type\n            $problemsPanelTable.find(\".inspector-section\").hide();\n            $problemsPanelTable.find(\"tr\").removeClass(\"forced-hidden\");\n\n            if (numProblems === 1 && !aborted) {\n                message = StringUtils.format(Strings.SINGLE_ERROR, providersReportingProblems[0].name);\n            } else {\n                if (aborted) {\n                    numProblems += \"+\";\n                }\n\n                message = StringUtils.format(Strings.MULTIPLE_ERRORS, providersReportingProblems[0].name, numProblems);\n            }\n        } else if (providersReportingProblems.length > 1) {\n            $problemsPanelTable.find(\".inspector-section\").show();\n\n            if (aborted) {\n                numProblems += \"+\";\n            }\n\n            message = StringUtils.format(Strings.ERRORS_PANEL_TITLE_MULTIPLE, numProblems);\n        } else {\n            return;\n        }\n\n        $problemsPanel.find(\".title\").text(message);\n        tooltip = StringUtils.format(Strings.STATUSBAR_CODE_INSPECTION_TOOLTIP, message);\n        StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-errors\", tooltip);\n    }\n\n    function _getMarkOptions(error){\n        switch (error.type) {\n        case Type.ERROR: return Editor.MARK_OPTION_UNDERLINE_ERROR;\n        case Type.WARNING: return Editor.MARK_OPTION_UNDERLINE_WARN;\n        case Type.META: return Editor.MARK_OPTION_UNDERLINE_INFO;\n        }\n    }\n\n    function _getMarkTypePriority(type){\n        switch (type) {\n        case Type.ERROR: return 3;\n        case Type.WARNING: return 2;\n        case Type.META: return 1;\n        }\n    }\n\n    function _shouldMarkTokenAtPosition(editor, error) {\n        if(isNaN(error.pos.line) || isNaN(error.pos.ch) || error.pos.line < 0 || error.pos.ch < 0){\n            console.warn(\"CodeInspector: Invalid error position: \", error);\n            return false;\n        }\n        // now we only apply a style if there is not already a higher priority style applied to it.\n        // Ie. If an error style is applied, we don't apply an info style over it as error takes precedence.\n        let markings = editor.findMarksAt(error.pos, CODE_MARK_TYPE_INSPECTOR);\n        let MarkToApplyPriority = _getMarkTypePriority(error.type);\n        let shouldMark = true;\n        for(let mark of markings){\n            let markTypePriority = _getMarkTypePriority(mark.type);\n            if(markTypePriority<=MarkToApplyPriority){\n                mark.clear();\n            } else {\n                // there's something with a higher priority marking the token\n                shouldMark = false;\n            }\n        }\n        return shouldMark;\n    }\n\n    /**\n     * It creates a div element with a span element inside it, and then adds a click handler to move cursor to the\n     * error position.\n     * @param editor - the editor instance\n     * @param line - the line number of the error\n     * @param ch - the character position of the error\n     * @param type - The type of the marker. This is a string that can be one of the error types\n     * @param message - The message that will be displayed when you hover over the marker.\n     * @returns A DOM element.\n     */\n    function _createMarkerElement(editor, line, ch, type, message) {\n        let $marker = $('<div><span>')\n            .attr('title', message)\n            .addClass(CODE_INSPECTION_GUTTER);\n        $marker.click(function (){\n            editor.setCursorPos(line, ch);\n        });\n        $marker.find('span')\n            .addClass(_getIconClassForType(type))\n            .addClass(\"brackets-inspection-gutter-marker\")\n            .html('&nbsp;');\n        return $marker[0];\n    }\n\n    /**\n     * We have to draw empty gutter markers if it doesnt exist, else there is a visual gap in the gutter when\n     * codemirror renders gutter with lines having no gutter icons\n     * @param editor\n     * @param line\n     * @private\n     */\n    function _addDummyGutterMarkerIfNotExist(editor, line) {\n        let marker = editor.getGutterMarker(line, CODE_INSPECTION_GUTTER);\n        if(!marker){\n            let $marker = $('<div>')\n                .addClass(CODE_INSPECTION_GUTTER);\n            editor.setGutterMarker(line, CODE_INSPECTION_GUTTER, $marker[0]);\n        }\n    }\n\n    function _populateDummyGutterElements(editor, from, to) {\n        for(let line=from; line <= to; line++) {\n            _addDummyGutterMarkerIfNotExist(editor, line);\n        }\n    }\n\n    function _updateGutterMarks(editor, gutterErrorMessages) {\n        // add gutter icons\n        for(let lineno of Object.keys(gutterErrorMessages)){\n            // We mark the line with the Highest priority icon. (Eg. error icon if same line has warnings and info)\n            let highestPriorityMarkTypeSeen = Type.META;\n            let gutterMessage = gutterErrorMessages[lineno].reduce((prev, current)=>{\n                if(_getMarkTypePriority(current.type) > _getMarkTypePriority(highestPriorityMarkTypeSeen)){\n                    highestPriorityMarkTypeSeen = current.type;\n                }\n                return {message: `${prev.message}\\n${current.message} at column: ${current.ch+1}`};\n            }, {message: ''});\n            let line = gutterErrorMessages[lineno][0].line,\n                ch = gutterErrorMessages[lineno][0].ch,\n                message = gutterMessage.message;\n            let marker = _createMarkerElement(editor, line, ch, highestPriorityMarkTypeSeen, message);\n            editor.setGutterMarker(line, CODE_INSPECTION_GUTTER, marker);\n        }\n        _populateDummyGutterElements(editor, 0, editor.getLastVisibleLine());\n    }\n\n    function _editorVieportChangeHandler(_evt, editor, from, to) {\n        _populateDummyGutterElements(editor, from, to);\n    }\n\n    function getQuickView(editor, pos, token, line) {\n        return new Promise((resolve, reject)=>{\n            let codeInspectionMarks = editor.findMarksAt(pos, CODE_MARK_TYPE_INSPECTOR) || [];\n            let hoverMessage = '';\n            for(let mark of codeInspectionMarks){\n                hoverMessage = `${hoverMessage}${mark.message}\\n`;\n            }\n            if(hoverMessage){\n                resolve({\n                    start: {line: pos.line, ch: token.start},\n                    end: {line: pos.line, ch: token.end},\n                    content: hoverMessage\n                });\n                return;\n            }\n            reject();\n        });\n    }\n\n\n    /**\n     * Adds gutter icons and squiggly lines under err/warn/info to editor after lint.\n     * @param resultProviderEntries\n     * @private\n     */\n    function _updateEditorMarks(resultProviderEntries) {\n        let editor = EditorManager.getCurrentFullEditor();\n        if(!(editor && resultProviderEntries && resultProviderEntries.length)) {\n            return;\n        }\n        editor.operation(function () {\n            editor.clearAllMarks(CODE_MARK_TYPE_INSPECTOR);\n            editor.clearGutter(CODE_INSPECTION_GUTTER);\n            editor.off(\"viewportChange.codeInspection\");\n            editor.on(\"viewportChange.codeInspection\", _editorVieportChangeHandler);\n            let gutterErrorMessages = {};\n            for (let resultProvider of resultProviderEntries) {\n                let errors = (resultProvider.result && resultProvider.result.errors) || [];\n                for (let error of errors) {\n                    // todo: add error.message on hover\n                    // add gutter markers\n                    let line = error.pos.line || 0;\n                    let ch = error.pos.ch || 0;\n                    let gutterMessage = gutterErrorMessages[line] || [];\n                    gutterMessage.push({message: error.message, type: error.type, line, ch});\n                    gutterErrorMessages[line] = gutterMessage;\n                    // add squiggly lines\n                    if (_shouldMarkTokenAtPosition(editor, error)) {\n                        let mark = editor.markToken(CODE_MARK_TYPE_INSPECTOR, error.pos, _getMarkOptions(error));\n                        mark.type = error.type;\n                        mark.message = error.message;\n                    }\n                }\n            }\n            _updateGutterMarks(editor, gutterErrorMessages);\n        });\n    }\n\n    /**\n     * Run inspector applicable to current document. Updates status bar indicator and refreshes error list in\n     * bottom panel. Does not run if inspection is disabled or if a providerName is given and does not\n     * match the current doc's provider name.\n     *\n     * @param {?string} providerName name of the provider that is requesting a run\n     */\n    function run() {\n        if (!_enabled) {\n            _hasErrors = false;\n            _currentPromise = null;\n            problemsPanel.hide();\n            StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-disabled\", Strings.LINT_DISABLED);\n            setGotoEnabled(false);\n            return;\n        }\n\n        var currentDoc = DocumentManager.getCurrentDocument(),\n            providerList = currentDoc && getProvidersForPath(currentDoc.file.fullPath);\n\n        if (providerList && providerList.length) {\n            var numProblems = 0;\n            var aborted = false;\n            var allErrors = [];\n            var html;\n            var providersReportingProblems = [];\n            $problemsPanelTable.empty();\n\n            // run all the providers registered for this file type\n            (_currentPromise = inspectFile(currentDoc.file, providerList)).then(function (results) {\n                _updateEditorMarks(results);\n                // check if promise has not changed while inspectFile was running\n                if (this !== _currentPromise) {\n                    return;\n                }\n\n                // how many errors in total?\n                var errors = results.reduce(function (a, item) { return a + (item.result ? item.result.errors.length : 0); }, 0);\n\n                _hasErrors = Boolean(errors);\n\n                if (!errors) {\n                    problemsPanel.hide();\n\n                    var message = Strings.NO_ERRORS_MULTIPLE_PROVIDER;\n                    if (providerList.length === 1) {\n                        message = StringUtils.format(Strings.NO_ERRORS, providerList[0].name);\n                    }\n\n                    StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-valid\", message);\n\n                    setGotoEnabled(false);\n                    return;\n                }\n\n                var perfTimerDOM = PerfUtils.markStart(\"ProblemsPanel render:\\t\" + currentDoc.file.fullPath);\n\n                // Augment error objects with additional fields needed by Mustache template\n                results.forEach(function (inspectionResult) {\n                    var provider = inspectionResult.provider;\n                    var isExpanded = prefs.get(provider.name + \".collapsed\") !== false;\n\n                    if (inspectionResult.result) {\n                        inspectionResult.result.errors.forEach(function (error) {\n                            // some inspectors don't always provide a line number or report a negative line number\n                            if (!isNaN(error.pos.line) &&\n                                    (error.pos.line + 1) > 0 &&\n                                    (error.codeSnippet = currentDoc.getLine(error.pos.line)) !== undefined) {\n                                error.friendlyLine = error.pos.line + 1;\n                                error.codeSnippet = error.codeSnippet.substr(0, 175);  // limit snippet width\n                            }\n\n                            if (error.type !== Type.META) {\n                                numProblems++;\n                            }\n\n                            error.iconClass = _getIconClassForType(error.type);\n\n                            // Hide the errors when the provider is collapsed.\n                            error.display = isExpanded ? \"\" : \"forced-hidden\";\n                        });\n\n                        // if the code inspector was unable to process the whole file, we keep track to show a different status\n                        if (inspectionResult.result.aborted) {\n                            aborted = true;\n                        }\n\n                        if (inspectionResult.result.errors.length) {\n                            allErrors.push({\n                                isExpanded: isExpanded,\n                                providerName: provider.name,\n                                results: inspectionResult.result.errors\n                            });\n\n                            providersReportingProblems.push(provider);\n                        }\n                    }\n                });\n\n                // Update results table\n                html = Mustache.render(ResultsTemplate, {reportList: allErrors});\n\n                $problemsPanelTable\n                    .empty()\n                    .append(html)\n                    .scrollTop(0);  // otherwise scroll pos from previous contents is remembered\n\n                if (!_collapsed) {\n                    problemsPanel.show();\n                }\n\n                updatePanelTitleAndStatusBar(numProblems, providersReportingProblems, aborted);\n                setGotoEnabled(true);\n\n                PerfUtils.addMeasurement(perfTimerDOM);\n            });\n\n        } else {\n            // No provider for current file\n            _hasErrors = false;\n            _currentPromise = null;\n            if(problemsPanel){\n                problemsPanel.hide();\n            }\n            var language = currentDoc && LanguageManager.getLanguageForPath(currentDoc.file.fullPath);\n            if (language) {\n                StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-disabled\", StringUtils.format(Strings.NO_LINT_AVAILABLE, language.getName()));\n            } else {\n                StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-disabled\", Strings.NOTHING_TO_LINT);\n            }\n            setGotoEnabled(false);\n        }\n    }\n\n    /**\n     * The provider is passed the text of the file and its fullPath. Providers should not assume\n     * that the file is open (i.e. DocumentManager.getOpenDocumentForPath() may return null) or\n     * that the file on disk matches the text given (file may have unsaved changes).\n     *\n     * Registering any provider for the \"javascript\" language automatically unregisters the built-in\n     * Brackets JSLint provider. This is a temporary convenience until UI exists for disabling\n     * registered providers.\n     *\n     * Providers implement scanFile() if results are available synchronously, or scanFileAsync() if results\n     * may require an async wait (if both are implemented, scanFile() is ignored). scanFileAsync() returns\n     * a {$.Promise} object resolved with the same type of value as scanFile() is expected to return.\n     * Rejecting the promise is treated as an internal error in the provider.\n     *\n     * @param {string} languageId\n     * @param {{name:string, scanFileAsync:?function(string, string):!{$.Promise},\n     *         scanFile:?function(string, string):?{errors:!Array, aborted:boolean}}} provider\n     *\n     * Each error is: { pos:{line,ch}, endPos:?{line,ch}, message:string, type:?Type }\n     * If type is unspecified, Type.WARNING is assumed.\n     * If no errors found, return either null or an object with a zero-length `errors` array.\n     */\n    function register(languageId, provider) {\n        if (!_providers[languageId]) {\n            _providers[languageId] = [];\n        } else {\n            // Check if provider with same name exists for the given language\n            // If yes, remove the provider before inserting the most recently loaded one\n            var indexOfProvider = _.findIndex(_providers[languageId], function(entry) { return entry.name === provider.name; });\n            if (indexOfProvider !== -1) {\n                _providers[languageId].splice(indexOfProvider, 1);\n            }\n        }\n\n        _providers[languageId].push(provider);\n\n        if(!_registeredLanguageIDs.includes(languageId)){\n            _registeredLanguageIDs.push(languageId);\n            Editor.unregisterGutter(CODE_INSPECTION_GUTTER);\n            Editor.registerGutter(CODE_INSPECTION_GUTTER, CODE_INSPECTION_GUTTER_PRIORITY, _registeredLanguageIDs);\n        }\n\n        run();  // in case a file of this type is open currently\n    }\n\n    /**\n     * Returns a list of providers registered for given languageId through register function\n     */\n    function getProvidersForLanguageId(languageId) {\n        var result = [];\n        if (_providers[languageId]) {\n            result = result.concat(_providers[languageId]);\n        }\n        if (_providers['*']) {\n            result = result.concat(_providers['*']);\n        }\n        return result;\n    }\n\n    /**\n     * Update DocumentManager listeners.\n     */\n    function updateListeners() {\n        if (_enabled) {\n            // register our event listeners\n            MainViewManager\n                .on(\"currentFileChange.codeInspection\", function () {\n                    run();\n                });\n            DocumentManager\n                .on(\"currentDocumentLanguageChanged.codeInspection\", function () {\n                    run();\n                })\n                .on(\"documentSaved.codeInspection documentRefreshed.codeInspection\", function (event, document) {\n                    if (document === DocumentManager.getCurrentDocument()) {\n                        run();\n                    }\n                });\n        } else {\n            DocumentManager.off(\".codeInspection\");\n            MainViewManager.off(\".codeInspection\");\n        }\n    }\n\n    /**\n     * Enable or disable all inspection.\n     * @param {?boolean} enabled Enabled state. If omitted, the state is toggled.\n     * @param {?boolean} doNotSave true if the preference should not be saved to user settings. This is generally for events triggered by project-level settings.\n     */\n    function toggleEnabled(enabled, doNotSave) {\n        if (enabled === undefined) {\n            enabled = !_enabled;\n        }\n\n        // Take no action when there is no change.\n        if (enabled === _enabled) {\n            return;\n        }\n\n        _enabled = enabled;\n\n        CommandManager.get(Commands.VIEW_TOGGLE_INSPECTION).setChecked(_enabled);\n        updateListeners();\n        if (!doNotSave) {\n            prefs.set(PREF_ENABLED, _enabled);\n            prefs.save();\n        }\n\n        // run immediately\n        run();\n    }\n\n    /**\n     * Toggle the collapsed state for the panel. This explicitly collapses the panel (as opposed to\n     * the auto collapse due to files with no errors & filetypes with no provider). When explicitly\n     * collapsed, the panel will not reopen automatically on switch files or save.\n     *\n     * @param {?boolean} collapsed Collapsed state. If omitted, the state is toggled.\n     * @param {?boolean} doNotSave true if the preference should not be saved to user settings. This is generally for events triggered by project-level settings.\n     */\n    function toggleCollapsed(collapsed, doNotSave) {\n        if (collapsed === undefined) {\n            collapsed = !_collapsed;\n        }\n\n        if (collapsed === _collapsed) {\n            return;\n        }\n\n        _collapsed = collapsed;\n        if (!doNotSave) {\n            prefs.set(PREF_COLLAPSED, _collapsed);\n            prefs.save();\n        }\n\n        if (_collapsed) {\n            problemsPanel.hide();\n        } else {\n            if (_hasErrors) {\n                problemsPanel.show();\n            }\n        }\n    }\n\n    /** Command to go to the first Problem */\n    function handleGotoFirstProblem() {\n        run();\n        if (_gotoEnabled) {\n            $problemsPanel.find(\"tr:not(.inspector-section)\").first().trigger(\"click\");\n        }\n    }\n\n    // Register command handlers\n    CommandManager.register(Strings.CMD_VIEW_TOGGLE_INSPECTION, Commands.VIEW_TOGGLE_INSPECTION,        toggleEnabled);\n    CommandManager.register(Strings.CMD_GOTO_FIRST_PROBLEM,     Commands.NAVIGATE_GOTO_FIRST_PROBLEM,   handleGotoFirstProblem);\n\n    // Register preferences\n    prefs.definePreference(PREF_ENABLED, \"boolean\", brackets.config[\"linting.enabled_by_default\"], {\n        description: Strings.DESCRIPTION_LINTING_ENABLED\n    })\n        .on(\"change\", function (e, data) {\n            toggleEnabled(prefs.get(PREF_ENABLED), true);\n        });\n\n    prefs.definePreference(PREF_COLLAPSED, \"boolean\", false, {\n        description: Strings.DESCRIPTION_LINTING_COLLAPSED\n    })\n        .on(\"change\", function (e, data) {\n            toggleCollapsed(prefs.get(PREF_COLLAPSED), true);\n        });\n\n    prefs.definePreference(PREF_ASYNC_TIMEOUT, \"number\", 10000, {\n        description: Strings.DESCRIPTION_ASYNC_TIMEOUT\n    });\n\n    prefs.definePreference(PREF_PREFER_PROVIDERS, \"array\", [], {\n        description: Strings.DESCRIPTION_LINTING_PREFER,\n        valueType: \"string\"\n    });\n\n    prefs.definePreference(PREF_PREFERRED_ONLY, \"boolean\", false, {\n        description: Strings.DESCRIPTION_USE_PREFERED_ONLY\n    });\n\n    // Initialize items dependent on HTML DOM\n    AppInit.htmlReady(function () {\n        Editor.registerGutter(CODE_INSPECTION_GUTTER, CODE_INSPECTION_GUTTER_PRIORITY);\n        // Create bottom panel to list error details\n        var panelHtml = Mustache.render(PanelTemplate, Strings);\n        problemsPanel = WorkspaceManager.createBottomPanel(\"errors\", $(panelHtml), 100);\n        $problemsPanel = $(\"#problems-panel\");\n\n        var $selectedRow;\n        $problemsPanelTable = $problemsPanel.find(\".table-container\")\n            .on(\"click\", \"tr\", function (e) {\n                if ($selectedRow) {\n                    $selectedRow.removeClass(\"selected\");\n                }\n\n                $selectedRow  = $(e.currentTarget);\n                $selectedRow.addClass(\"selected\");\n\n                // This is a inspector title row, expand/collapse on click\n                if ($selectedRow.hasClass(\"inspector-section\")) {\n                    var $triangle = $(\".disclosure-triangle\", $selectedRow);\n                    var isExpanded = $triangle.hasClass(\"expanded\");\n\n                    // Clicking the inspector title section header collapses/expands result rows\n                    if (isExpanded) {\n                        $selectedRow.nextUntil(\".inspector-section\").addClass(\"forced-hidden\");\n                    } else {\n                        $selectedRow.nextUntil(\".inspector-section\").removeClass(\"forced-hidden\");\n                    }\n                    $triangle.toggleClass(\"expanded\");\n\n                    var providerName = $selectedRow.find(\"input[type='hidden']\").val();\n                    prefs.set(providerName + \".collapsed\", !isExpanded);\n                    prefs.save();\n                } else {\n                    // This is a problem marker row, show the result on click\n                    // Grab the required position data\n                    var lineTd    = $selectedRow.find(\".line-number\");\n                    var line      = parseInt(lineTd.text(), 10) - 1;  // convert friendlyLine back to pos.line\n                    // if there is no line number available, don't do anything\n                    if (!isNaN(line)) {\n                        var character = lineTd.data(\"character\");\n\n                        var editor = EditorManager.getCurrentFullEditor();\n                        editor.setCursorPos(line, character, true);\n                        MainViewManager.focusActivePane();\n                    }\n                }\n            });\n\n        $(\"#problems-panel .close\").click(function () {\n            toggleCollapsed(true);\n            MainViewManager.focusActivePane();\n        });\n\n        // Status bar indicator - icon & tooltip updated by run()\n        var statusIconHtml = Mustache.render(\"<div id=\\\"status-inspection\\\">&nbsp;</div>\", Strings);\n        StatusBar.addIndicator(INDICATOR_ID, $(statusIconHtml), true, \"\", \"\", \"status-indent\");\n\n        $(\"#status-inspection\").click(function () {\n            // Clicking indicator toggles error panel, if any errors in current file\n            if (_hasErrors) {\n                toggleCollapsed();\n            }\n        });\n\n        // Set initial UI state\n        toggleEnabled(prefs.get(PREF_ENABLED), true);\n        toggleCollapsed(prefs.get(PREF_COLLAPSED), true);\n\n        QuickViewManager.registerQuickViewProvider({\n            getQuickView,\n            QUICK_VIEW_NAME: \"CodeInspection\"\n        }, [\"all\"]);\n    });\n\n    // Testing\n    exports._unregisterAll          = _unregisterAll;\n    exports._PREF_ASYNC_TIMEOUT     = PREF_ASYNC_TIMEOUT;\n    exports._PREF_PREFER_PROVIDERS  = PREF_PREFER_PROVIDERS;\n    exports._PREF_PREFERRED_ONLY    = PREF_PREFERRED_ONLY;\n\n    // Public API\n    exports.CODE_INSPECTION_GUTTER      = CODE_INSPECTION_GUTTER;\n    exports.register                    = register;\n    exports.Type                        = Type;\n    exports.toggleEnabled               = toggleEnabled;\n    exports.inspectFile                 = inspectFile;\n    exports.requestRun                  = run;\n    exports.getProvidersForPath         = getProvidersForPath;\n    exports.getProviderIDsForLanguage   = getProviderIDsForLanguage;\n});\n"],"file":"CodeInspection.js"}
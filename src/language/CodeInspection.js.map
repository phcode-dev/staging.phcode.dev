{"version":3,"sources":["language/CodeInspection.js"],"names":["define","require","exports","module","_","Commands","WorkspaceManager","CommandManager","DocumentManager","EditorManager","Editor","MainViewManager","LanguageManager","PreferencesManager","PerfUtils","Strings","StringUtils","AppInit","StatusBar","Async","PanelTemplate","ResultsTemplate","Mustache","CODE_INSPECTION_GUTTER_PRIORITY","CODE_INSPECTION_GUTTER","INDICATOR_ID","Type","ERROR","WARNING","META","_getIconClassForType","type","CODE_MARK_TYPE_INSPECTOR","PREF_ENABLED","PREF_COLLAPSED","PREF_ASYNC_TIMEOUT","PREF_PREFER_PROVIDERS","PREF_PREFERRED_ONLY","prefs","getExtensionPrefs","_enabled","_collapsed","$problemsPanel","problemsPanel","$problemsPanelTable","_gotoEnabled","_providers","_hasErrors","_currentPromise","setGotoEnabled","gotoEnabled","get","NAVIGATE_GOTO_FIRST_PROBLEM","setEnabled","_unregisterAll","getProvidersForPath","filePath","language","getLanguageForPath","getId","context","_buildContext","installedProviders","getProvidersForLanguageId","preferredProviders","prefPreferredProviderNames","prefPreferredOnly","providers","length","reduce","result","key","provider","find","name","push","union","getProviderIDsForLanguage","languageId","map","inspectFile","file","providerList","response","$","Deferred","results","fullPath","getDocumentText","done","fileText","perfTimerInspector","markStart","masterPromise","doInParallel","perfTimerProvider","runPromise","scanResult","scanFileAsync","window","setTimeout","errTimeout","pos","line","col","message","format","LINTER_TIMED_OUT","resolve","errors","jsPromise","then","addMeasurement","catch","err","finalizeMeasurement","errError","LINTER_FAILED","console","error","stack","scanFile","promise","sort","a","b","indexOf","fail","reject","updatePanelTitleAndStatusBar","numProblems","providersReportingProblems","aborted","tooltip","hide","removeClass","MULTIPLE_ERRORS","SINGLE_ERROR","show","ERRORS_PANEL_TITLE_MULTIPLE","text","STATUSBAR_CODE_INSPECTION_TOOLTIP","updateIndicator","_getMarkOptions","MARK_OPTION_UNDERLINE_ERROR","MARK_OPTION_UNDERLINE_WARN","MARK_OPTION_UNDERLINE_INFO","_getMarkTypePriority","_shouldMarkTokenAtPosition","editor","isNaN","ch","warn","markings","findMarksAt","MarkToApplyPriority","shouldMark","mark","markTypePriority","clear","_createMarkerElement","$marker","attr","addClass","click","setCursorPos","html","_addDummyGutterMarkerIfNotExist","marker","getGutterMarker","setGutterMarker","_populateDummyGutterElements","from","to","_updateGutterMarks","gutterErrorMessages","lineno","Object","keys","highestPriorityMarkTypeSeen","gutterMessage","prev","current","getLastVisibleLine","_editorVieportChangeHandler","_evt","_updateEditorMarks","resultProviderEntries","getCurrentFullEditor","operation","clearAllMarks","clearGutter","off","on","resultProvider","markToken","run","LINT_DISABLED","currentDoc","getCurrentDocument","allErrors","empty","this","item","Boolean","NO_ERRORS_MULTIPLE_PROVIDER","NO_ERRORS","perfTimerDOM","forEach","inspectionResult","isExpanded","undefined","codeSnippet","getLine","friendlyLine","substr","iconClass","display","providerName","render","reportList","append","scrollTop","NO_LINT_AVAILABLE","getName","NOTHING_TO_LINT","register","indexOfProvider","findIndex","entry","splice","concat","updateListeners","event","document","toggleEnabled","enabled","doNotSave","VIEW_TOGGLE_INSPECTION","setChecked","set","save","toggleCollapsed","collapsed","handleGotoFirstProblem","first","trigger","CMD_VIEW_TOGGLE_INSPECTION","CMD_GOTO_FIRST_PROBLEM","definePreference","brackets","config","description","DESCRIPTION_LINTING_ENABLED","e","data","DESCRIPTION_LINTING_COLLAPSED","DESCRIPTION_ASYNC_TIMEOUT","DESCRIPTION_LINTING_PREFER","valueType","DESCRIPTION_USE_PREFERED_ONLY","htmlReady","registerGutter","panelHtml","$selectedRow","createBottomPanel","currentTarget","hasClass","$triangle","nextUntil","toggleClass","val","lineTd","parseInt","character","focusActivePane","statusIconHtml","addIndicator","_PREF_ASYNC_TIMEOUT","_PREF_PREFER_PROVIDERS","_PREF_PREFERRED_ONLY","requestRun"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global jsPromise*/\n\n/**\n * Manages linters and other code inspections on a per-language basis. Provides a UI and status indicator for\n * the resulting errors/warnings.\n *\n * Currently, inspection providers are only invoked on the current file and only when it is opened, switched to,\n * or saved. But in the future, inspectors may be invoked as part of a global scan, at intervals while typing, etc.\n * Currently, results are only displayed in a bottom panel list and in a status bar icon. But in the future,\n * results may also be displayed inline in the editor (as gutter markers, etc.).\n * In the future, support may also be added for error/warning providers that cannot process a single file at a time\n * (e.g. a full-project compiler).\n */\ndefine(function (require, exports, module) {\n\n\n    const _ = require(\"thirdparty/lodash\");\n\n    // Load dependent modules\n    const Commands                = require(\"command/Commands\"),\n        WorkspaceManager        = require(\"view/WorkspaceManager\"),\n        CommandManager          = require(\"command/CommandManager\"),\n        DocumentManager         = require(\"document/DocumentManager\"),\n        EditorManager           = require(\"editor/EditorManager\"),\n        Editor                  = require(\"editor/Editor\").Editor,\n        MainViewManager         = require(\"view/MainViewManager\"),\n        LanguageManager         = require(\"language/LanguageManager\"),\n        PreferencesManager      = require(\"preferences/PreferencesManager\"),\n        PerfUtils               = require(\"utils/PerfUtils\"),\n        Strings                 = require(\"strings\"),\n        StringUtils             = require(\"utils/StringUtils\"),\n        AppInit                 = require(\"utils/AppInit\"),\n        StatusBar               = require(\"widgets/StatusBar\"),\n        Async                   = require(\"utils/Async\"),\n        PanelTemplate           = require(\"text!htmlContent/problems-panel.html\"),\n        ResultsTemplate         = require(\"text!htmlContent/problems-panel-table.html\"),\n        Mustache                = require(\"thirdparty/mustache/mustache\");\n\n    const CODE_INSPECTION_GUTTER_PRIORITY      = 500,\n        CODE_INSPECTION_GUTTER = \"code-inspection-gutter\";\n\n    const INDICATOR_ID = \"status-inspection\";\n\n    /** Values for problem's 'type' property */\n    const Type = {\n        /** Unambiguous error, such as a syntax error */\n        ERROR: \"error\",\n        /** Maintainability issue, probable error / bad smell, etc. */\n        WARNING: \"warning\",\n        /** Inspector unable to continue, code too complex for static analysis, etc. Not counted in err/warn tally. */\n        META: \"meta\"\n    };\n\n    function _getIconClassForType(type) {\n        switch (type) {\n        case Type.ERROR: return \"line-icon-problem_type_error fa-solid fa-times-circle\";\n        case Type.WARNING: return \"line-icon-problem_type_warning fa-solid fa-exclamation-triangle\";\n        case Type.META: return \"line-icon-problem_type_info fa-solid fa-info-circle\";\n        default: return \"line-icon-problem_type_info fa-solid fa-info-circle\";\n        }\n    }\n\n    const CODE_MARK_TYPE_INSPECTOR = \"codeInspector\";\n\n    /**\n     * Constants for the preferences defined in this file.\n     */\n    const PREF_ENABLED            = \"enabled\",\n        PREF_COLLAPSED          = \"collapsed\",\n        PREF_ASYNC_TIMEOUT      = \"asyncTimeout\",\n        PREF_PREFER_PROVIDERS   = \"prefer\",\n        PREF_PREFERRED_ONLY     = \"usePreferredOnly\";\n\n    const prefs = PreferencesManager.getExtensionPrefs(\"linting\");\n\n    /**\n     * When disabled, the errors panel is closed and the status bar icon is grayed out.\n     * Takes precedence over _collapsed.\n     * @private\n     * @type {boolean}\n     */\n    var _enabled = false;\n\n    /**\n     * When collapsed, the errors panel is closed but the status bar icon is kept up to date.\n     * @private\n     * @type {boolean}\n     */\n    var _collapsed = false;\n\n    /**\n     * @private\n     * @type {$.Element}\n     */\n    var $problemsPanel;\n\n    /**\n     * @private the panelView\n     * @type {Panel}\n     */\n    var problemsPanel;\n\n    /**\n     * @private\n     * @type {$.Element}\n     */\n    var $problemsPanelTable;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    var _gotoEnabled = false;\n\n    /**\n     * @private\n     * @type {{languageId:string, Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):Object}>}}\n     */\n    var _providers = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    var _hasErrors;\n\n    /**\n     * Promise of the returned by the last call to inspectFile or null if linting is disabled. Used to prevent any stale promises\n     * to cause updates of the UI.\n     *\n     * @private\n     * @type {$.Promise}\n     */\n    var _currentPromise = null;\n\n    /**\n     * Enable or disable the \"Go to First Error\" command\n     * @param {boolean} gotoEnabled Whether it is enabled.\n     */\n    function setGotoEnabled(gotoEnabled) {\n        CommandManager.get(Commands.NAVIGATE_GOTO_FIRST_PROBLEM).setEnabled(gotoEnabled);\n        _gotoEnabled = gotoEnabled;\n    }\n\n    function _unregisterAll() {\n        _providers = {};\n    }\n\n    /**\n     * Returns a list of provider for given file path, if available.\n     * Decision is made depending on the file extension.\n     *\n     * @param {!string} filePath\n     * @return {Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):?{errors:!Array, aborted:boolean}}>}\n     */\n    function getProvidersForPath(filePath) {\n        var language            = LanguageManager.getLanguageForPath(filePath).getId(),\n            context             = PreferencesManager._buildContext(filePath, language),\n            installedProviders  = getProvidersForLanguageId(language),\n            preferredProviders,\n\n            prefPreferredProviderNames  = prefs.get(PREF_PREFER_PROVIDERS, context),\n            prefPreferredOnly           = prefs.get(PREF_PREFERRED_ONLY, context),\n\n            providers;\n\n        if (prefPreferredProviderNames && prefPreferredProviderNames.length) {\n            if (typeof prefPreferredProviderNames === \"string\") {\n                prefPreferredProviderNames = [prefPreferredProviderNames];\n            }\n            preferredProviders = prefPreferredProviderNames.reduce(function (result, key) {\n                var provider = _.find(installedProviders, {name: key});\n                if (provider) {\n                    result.push(provider);\n                }\n                return result;\n            }, []);\n            if (prefPreferredOnly) {\n                providers = preferredProviders;\n            } else {\n                providers = _.union(preferredProviders, installedProviders);\n            }\n        } else {\n            providers = installedProviders;\n        }\n        return providers;\n    }\n\n    /**\n     * Returns an array of the IDs of providers registered for a specific language\n     *\n     * @param {!string} languageId\n     * @return {Array.<string>} Names of registered providers.\n     */\n    function getProviderIDsForLanguage(languageId) {\n        if (!_providers[languageId]) {\n            return [];\n        }\n        return _providers[languageId].map(function (provider) {\n            return provider.name;\n        });\n    }\n\n    /**\n     * Runs a file inspection over passed file. Uses the given list of providers if specified, otherwise uses\n     * the set of providers that are registered for the file's language.\n     * This method doesn't update the Brackets UI, just provides inspection results.\n     * These results will reflect any unsaved changes present in the file if currently open.\n     *\n     * The Promise yields an array of provider-result pair objects (the result is the return value of the\n     * provider's scanFile() - see register() for details). The result object may be null if there were no\n     * errors from that provider.\n     * If there are no providers registered for this file, the Promise yields null instead.\n     *\n     * @param {!File} file File that will be inspected for errors.\n     * @param {?Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):?{errors:!Array, aborted:boolean}}>} providerList\n     * @return {$.Promise} a jQuery promise that will be resolved with ?Array.<{provider:Object, result: ?{errors:!Array, aborted:boolean}}>\n     */\n    function inspectFile(file, providerList) {\n        var response = new $.Deferred(),\n            results = [];\n\n        providerList = providerList || getProvidersForPath(file.fullPath);\n\n        if (!providerList.length) {\n            response.resolve(null);\n            return response.promise();\n        }\n\n        DocumentManager.getDocumentText(file)\n            .done(function (fileText) {\n                var perfTimerInspector = PerfUtils.markStart(\"CodeInspection:\\t\" + file.fullPath),\n                    masterPromise;\n\n                masterPromise = Async.doInParallel(providerList, function (provider) {\n                    var perfTimerProvider = PerfUtils.markStart(\"CodeInspection '\" + provider.name + \"':\\t\" + file.fullPath),\n                        runPromise = new $.Deferred();\n\n                    runPromise.done(function (scanResult) {\n                        results.push({provider: provider, result: scanResult});\n                    });\n\n                    if (provider.scanFileAsync) {\n                        window.setTimeout(function () {\n                            // timeout error\n                            var errTimeout = {\n                                pos: { line: -1, col: 0},\n                                message: StringUtils.format(Strings.LINTER_TIMED_OUT, provider.name, prefs.get(PREF_ASYNC_TIMEOUT)),\n                                type: Type.ERROR\n                            };\n                            runPromise.resolve({errors: [errTimeout]});\n                        }, prefs.get(PREF_ASYNC_TIMEOUT));\n                        jsPromise(provider.scanFileAsync(fileText, file.fullPath))\n                            .then(function (scanResult) {\n                                PerfUtils.addMeasurement(perfTimerProvider);\n                                runPromise.resolve(scanResult);\n                            })\n                            .catch(function (err) {\n                                PerfUtils.finalizeMeasurement(perfTimerProvider);\n                                var errError = {\n                                    pos: {line: -1, col: 0},\n                                    message: StringUtils.format(Strings.LINTER_FAILED, provider.name, err),\n                                    type: Type.ERROR\n                                };\n                                console.error(\"[CodeInspection] Provider \" + provider.name + \" (async) failed: \" + err.stack);\n                                runPromise.resolve({errors: [errError]});\n                            });\n                    } else {\n                        try {\n                            var scanResult = provider.scanFile(fileText, file.fullPath);\n                            PerfUtils.addMeasurement(perfTimerProvider);\n                            runPromise.resolve(scanResult);\n                        } catch (err) {\n                            PerfUtils.finalizeMeasurement(perfTimerProvider);\n                            var errError = {\n                                pos: {line: -1, col: 0},\n                                message: StringUtils.format(Strings.LINTER_FAILED, provider.name, err),\n                                type: Type.ERROR\n                            };\n                            console.error(\"[CodeInspection] Provider \" + provider.name + \" (sync) threw an error: \" + err.stack);\n                            runPromise.resolve({errors: [errError]});\n                        }\n                    }\n                    return runPromise.promise();\n\n                }, false);\n\n                masterPromise.then(function () {\n                    // sync async may have pushed results in different order, restore the original order\n                    results.sort(function (a, b) {\n                        return providerList.indexOf(a.provider) - providerList.indexOf(b.provider);\n                    });\n                    PerfUtils.addMeasurement(perfTimerInspector);\n                    response.resolve(results);\n                });\n\n            })\n            .fail(function (err) {\n                console.error(\"[CodeInspection] Could not read file for inspection: \" + file.fullPath);\n                response.reject(err);\n            });\n\n        return response.promise();\n    }\n\n    /**\n     * Update the title of the problem panel and the tooltip of the status bar icon. The title and the tooltip will\n     * change based on the number of problems reported and how many provider reported problems.\n     *\n     * @param {Number} numProblems - total number of problems across all providers\n     * @param {Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):Object}>} providersReportingProblems - providers that reported problems\n     * @param {boolean} aborted - true if any provider returned a result with the 'aborted' flag set\n     */\n    function updatePanelTitleAndStatusBar(numProblems, providersReportingProblems, aborted) {\n        var message, tooltip;\n\n        if (providersReportingProblems.length === 1) {\n            // don't show a header if there is only one provider available for this file type\n            $problemsPanelTable.find(\".inspector-section\").hide();\n            $problemsPanelTable.find(\"tr\").removeClass(\"forced-hidden\");\n\n            if (numProblems === 1 && !aborted) {\n                message = StringUtils.format(Strings.SINGLE_ERROR, providersReportingProblems[0].name);\n            } else {\n                if (aborted) {\n                    numProblems += \"+\";\n                }\n\n                message = StringUtils.format(Strings.MULTIPLE_ERRORS, providersReportingProblems[0].name, numProblems);\n            }\n        } else if (providersReportingProblems.length > 1) {\n            $problemsPanelTable.find(\".inspector-section\").show();\n\n            if (aborted) {\n                numProblems += \"+\";\n            }\n\n            message = StringUtils.format(Strings.ERRORS_PANEL_TITLE_MULTIPLE, numProblems);\n        } else {\n            return;\n        }\n\n        $problemsPanel.find(\".title\").text(message);\n        tooltip = StringUtils.format(Strings.STATUSBAR_CODE_INSPECTION_TOOLTIP, message);\n        StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-errors\", tooltip);\n    }\n\n    function _getMarkOptions(error){\n        switch (error.type) {\n        case Type.ERROR: return Editor.MARK_OPTION_UNDERLINE_ERROR;\n        case Type.WARNING: return Editor.MARK_OPTION_UNDERLINE_WARN;\n        case Type.META: return Editor.MARK_OPTION_UNDERLINE_INFO;\n        }\n    }\n\n    function _getMarkTypePriority(type){\n        switch (type) {\n        case Type.ERROR: return 3;\n        case Type.WARNING: return 2;\n        case Type.META: return 1;\n        }\n    }\n\n    function _shouldMarkTokenAtPosition(editor, error) {\n        if(isNaN(error.pos.line) || isNaN(error.pos.ch) || error.pos.line < 0 || error.pos.ch < 0){\n            console.warn(\"CodeInspector: Invalid error position: \", error);\n            return false;\n        }\n        // now we only apply a style if there is not already a higher priority style applied to it.\n        // Ie. If an error style is applied, we don't apply an info style over it as error takes precedence.\n        let markings = editor.findMarksAt(error.pos, CODE_MARK_TYPE_INSPECTOR);\n        let MarkToApplyPriority = _getMarkTypePriority(error.type);\n        let shouldMark = true;\n        for(let mark of markings){\n            let markTypePriority = _getMarkTypePriority(mark.type);\n            if(markTypePriority<=MarkToApplyPriority){\n                mark.clear();\n            } else {\n                // there's something with a higher priority marking the token\n                shouldMark = false;\n            }\n        }\n        return shouldMark;\n    }\n\n    /**\n     * It creates a div element with a span element inside it, and then adds a click handler to move cursor to the\n     * error position.\n     * @param editor - the editor instance\n     * @param line - the line number of the error\n     * @param ch - the character position of the error\n     * @param type - The type of the marker. This is a string that can be one of the error types\n     * @param message - The message that will be displayed when you hover over the marker.\n     * @returns A DOM element.\n     */\n    function _createMarkerElement(editor, line, ch, type, message) {\n        let $marker = $('<div><span>')\n            .attr('title', message)\n            .addClass(CODE_INSPECTION_GUTTER);\n        $marker.click(function (){\n            editor.setCursorPos(line, ch);\n        });\n        $marker.find('span')\n            .addClass(_getIconClassForType(type))\n            .addClass(\"brackets-inspection-gutter-marker\")\n            .html('&nbsp;');\n        return $marker[0];\n    }\n\n    /**\n     * We have to draw empty gutter markers if it doesnt exist, else there is a visual gap in the gutter when\n     * codemirror renders gutter with lines having no gutter icons\n     * @param editor\n     * @param line\n     * @private\n     */\n    function _addDummyGutterMarkerIfNotExist(editor, line) {\n        let marker = editor.getGutterMarker(line, CODE_INSPECTION_GUTTER);\n        if(!marker){\n            let $marker = $('<div>')\n                .addClass(CODE_INSPECTION_GUTTER);\n            editor.setGutterMarker(line, CODE_INSPECTION_GUTTER, $marker[0]);\n        }\n    }\n\n    function _populateDummyGutterElements(editor, from, to) {\n        for(let line=from; line <= to; line++) {\n            _addDummyGutterMarkerIfNotExist(editor, line);\n        }\n    }\n\n    function _updateGutterMarks(editor, gutterErrorMessages) {\n        // add gutter icons\n        for(let lineno of Object.keys(gutterErrorMessages)){\n            // We mark the line with the Highest priority icon. (Eg. error icon if same line has warnings and info)\n            let highestPriorityMarkTypeSeen = Type.META;\n            let gutterMessage = gutterErrorMessages[lineno].reduce((prev, current)=>{\n                if(_getMarkTypePriority(current.type) > _getMarkTypePriority(highestPriorityMarkTypeSeen)){\n                    highestPriorityMarkTypeSeen = current.type;\n                }\n                return {message: `${prev.message}\\n${current.message} at column: ${current.ch+1}`};\n            }, {message: ''});\n            let line = gutterErrorMessages[lineno][0].line,\n                ch = gutterErrorMessages[lineno][0].ch,\n                message = gutterMessage.message;\n            let marker = _createMarkerElement(editor, line, ch, highestPriorityMarkTypeSeen, message);\n            editor.setGutterMarker(line, CODE_INSPECTION_GUTTER, marker);\n        }\n        _populateDummyGutterElements(editor, 0, editor.getLastVisibleLine());\n    }\n\n    function _editorVieportChangeHandler(_evt, editor, from, to) {\n        _populateDummyGutterElements(editor, from, to);\n    }\n\n    /**\n     * Adds gutter icons and squiggly lines under err/warn/info to editor after lint.\n     * @param resultProviderEntries\n     * @private\n     */\n    function _updateEditorMarks(resultProviderEntries) {\n        let editor = EditorManager.getCurrentFullEditor();\n        if(!(editor && resultProviderEntries && resultProviderEntries.length)) {\n            return;\n        }\n        editor.operation(function () {\n            editor.clearAllMarks(CODE_MARK_TYPE_INSPECTOR);\n            editor.clearGutter(CODE_INSPECTION_GUTTER);\n            editor.off(\"viewportChange.codeInspection\");\n            editor.on(\"viewportChange.codeInspection\", _editorVieportChangeHandler);\n            let gutterErrorMessages = {};\n            for (let resultProvider of resultProviderEntries) {\n                let errors = (resultProvider.result && resultProvider.result.errors) || [];\n                for (let error of errors) {\n                    // todo: add error.message on hover\n                    // add gutter markers\n                    let line = error.pos.line || 0;\n                    let ch = error.pos.ch || 0;\n                    let gutterMessage = gutterErrorMessages[line] || [];\n                    gutterMessage.push({message: error.message, type: error.type, line, ch});\n                    gutterErrorMessages[line] = gutterMessage;\n                    // add squiggly lines\n                    if (_shouldMarkTokenAtPosition(editor, error)) {\n                        let mark = editor.markToken(CODE_MARK_TYPE_INSPECTOR, error.pos, _getMarkOptions(error));\n                        mark.type = error.type;\n                    }\n                }\n            }\n            _updateGutterMarks(editor, gutterErrorMessages);\n        });\n    }\n\n    /**\n     * Run inspector applicable to current document. Updates status bar indicator and refreshes error list in\n     * bottom panel. Does not run if inspection is disabled or if a providerName is given and does not\n     * match the current doc's provider name.\n     *\n     * @param {?string} providerName name of the provider that is requesting a run\n     */\n    function run() {\n        if (!_enabled) {\n            _hasErrors = false;\n            _currentPromise = null;\n            problemsPanel.hide();\n            StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-disabled\", Strings.LINT_DISABLED);\n            setGotoEnabled(false);\n            return;\n        }\n\n        var currentDoc = DocumentManager.getCurrentDocument(),\n            providerList = currentDoc && getProvidersForPath(currentDoc.file.fullPath);\n\n        if (providerList && providerList.length) {\n            var numProblems = 0;\n            var aborted = false;\n            var allErrors = [];\n            var html;\n            var providersReportingProblems = [];\n            $problemsPanelTable.empty();\n\n            // run all the providers registered for this file type\n            (_currentPromise = inspectFile(currentDoc.file, providerList)).then(function (results) {\n                _updateEditorMarks(results);\n                // check if promise has not changed while inspectFile was running\n                if (this !== _currentPromise) {\n                    return;\n                }\n\n                // how many errors in total?\n                var errors = results.reduce(function (a, item) { return a + (item.result ? item.result.errors.length : 0); }, 0);\n\n                _hasErrors = Boolean(errors);\n\n                if (!errors) {\n                    problemsPanel.hide();\n\n                    var message = Strings.NO_ERRORS_MULTIPLE_PROVIDER;\n                    if (providerList.length === 1) {\n                        message = StringUtils.format(Strings.NO_ERRORS, providerList[0].name);\n                    }\n\n                    StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-valid\", message);\n\n                    setGotoEnabled(false);\n                    return;\n                }\n\n                var perfTimerDOM = PerfUtils.markStart(\"ProblemsPanel render:\\t\" + currentDoc.file.fullPath);\n\n                // Augment error objects with additional fields needed by Mustache template\n                results.forEach(function (inspectionResult) {\n                    var provider = inspectionResult.provider;\n                    var isExpanded = prefs.get(provider.name + \".collapsed\") !== false;\n\n                    if (inspectionResult.result) {\n                        inspectionResult.result.errors.forEach(function (error) {\n                            // some inspectors don't always provide a line number or report a negative line number\n                            if (!isNaN(error.pos.line) &&\n                                    (error.pos.line + 1) > 0 &&\n                                    (error.codeSnippet = currentDoc.getLine(error.pos.line)) !== undefined) {\n                                error.friendlyLine = error.pos.line + 1;\n                                error.codeSnippet = error.codeSnippet.substr(0, 175);  // limit snippet width\n                            }\n\n                            if (error.type !== Type.META) {\n                                numProblems++;\n                            }\n\n                            error.iconClass = _getIconClassForType(error.type);\n\n                            // Hide the errors when the provider is collapsed.\n                            error.display = isExpanded ? \"\" : \"forced-hidden\";\n                        });\n\n                        // if the code inspector was unable to process the whole file, we keep track to show a different status\n                        if (inspectionResult.result.aborted) {\n                            aborted = true;\n                        }\n\n                        if (inspectionResult.result.errors.length) {\n                            allErrors.push({\n                                isExpanded: isExpanded,\n                                providerName: provider.name,\n                                results: inspectionResult.result.errors\n                            });\n\n                            providersReportingProblems.push(provider);\n                        }\n                    }\n                });\n\n                // Update results table\n                html = Mustache.render(ResultsTemplate, {reportList: allErrors});\n\n                $problemsPanelTable\n                    .empty()\n                    .append(html)\n                    .scrollTop(0);  // otherwise scroll pos from previous contents is remembered\n\n                if (!_collapsed) {\n                    problemsPanel.show();\n                }\n\n                updatePanelTitleAndStatusBar(numProblems, providersReportingProblems, aborted);\n                setGotoEnabled(true);\n\n                PerfUtils.addMeasurement(perfTimerDOM);\n            });\n\n        } else {\n            // No provider for current file\n            _hasErrors = false;\n            _currentPromise = null;\n            if(problemsPanel){\n                problemsPanel.hide();\n            }\n            var language = currentDoc && LanguageManager.getLanguageForPath(currentDoc.file.fullPath);\n            if (language) {\n                StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-disabled\", StringUtils.format(Strings.NO_LINT_AVAILABLE, language.getName()));\n            } else {\n                StatusBar.updateIndicator(INDICATOR_ID, true, \"inspection-disabled\", Strings.NOTHING_TO_LINT);\n            }\n            setGotoEnabled(false);\n        }\n    }\n\n    /**\n     * The provider is passed the text of the file and its fullPath. Providers should not assume\n     * that the file is open (i.e. DocumentManager.getOpenDocumentForPath() may return null) or\n     * that the file on disk matches the text given (file may have unsaved changes).\n     *\n     * Registering any provider for the \"javascript\" language automatically unregisters the built-in\n     * Brackets JSLint provider. This is a temporary convenience until UI exists for disabling\n     * registered providers.\n     *\n     * Providers implement scanFile() if results are available synchronously, or scanFileAsync() if results\n     * may require an async wait (if both are implemented, scanFile() is ignored). scanFileAsync() returns\n     * a {$.Promise} object resolved with the same type of value as scanFile() is expected to return.\n     * Rejecting the promise is treated as an internal error in the provider.\n     *\n     * @param {string} languageId\n     * @param {{name:string, scanFileAsync:?function(string, string):!{$.Promise},\n     *         scanFile:?function(string, string):?{errors:!Array, aborted:boolean}}} provider\n     *\n     * Each error is: { pos:{line,ch}, endPos:?{line,ch}, message:string, type:?Type }\n     * If type is unspecified, Type.WARNING is assumed.\n     * If no errors found, return either null or an object with a zero-length `errors` array.\n     */\n    function register(languageId, provider) {\n        if (!_providers[languageId]) {\n            _providers[languageId] = [];\n        } else {\n            // Check if provider with same name exists for the given language\n            // If yes, remove the provider before inserting the most recently loaded one\n            var indexOfProvider = _.findIndex(_providers[languageId], function(entry) { return entry.name === provider.name; });\n            if (indexOfProvider !== -1) {\n                _providers[languageId].splice(indexOfProvider, 1);\n            }\n        }\n\n        _providers[languageId].push(provider);\n\n        run();  // in case a file of this type is open currently\n    }\n\n    /**\n     * Returns a list of providers registered for given languageId through register function\n     */\n    function getProvidersForLanguageId(languageId) {\n        var result = [];\n        if (_providers[languageId]) {\n            result = result.concat(_providers[languageId]);\n        }\n        if (_providers['*']) {\n            result = result.concat(_providers['*']);\n        }\n        return result;\n    }\n\n    /**\n     * Update DocumentManager listeners.\n     */\n    function updateListeners() {\n        if (_enabled) {\n            // register our event listeners\n            MainViewManager\n                .on(\"currentFileChange.codeInspection\", function () {\n                    run();\n                });\n            DocumentManager\n                .on(\"currentDocumentLanguageChanged.codeInspection\", function () {\n                    run();\n                })\n                .on(\"documentSaved.codeInspection documentRefreshed.codeInspection\", function (event, document) {\n                    if (document === DocumentManager.getCurrentDocument()) {\n                        run();\n                    }\n                });\n        } else {\n            DocumentManager.off(\".codeInspection\");\n            MainViewManager.off(\".codeInspection\");\n        }\n    }\n\n    /**\n     * Enable or disable all inspection.\n     * @param {?boolean} enabled Enabled state. If omitted, the state is toggled.\n     * @param {?boolean} doNotSave true if the preference should not be saved to user settings. This is generally for events triggered by project-level settings.\n     */\n    function toggleEnabled(enabled, doNotSave) {\n        if (enabled === undefined) {\n            enabled = !_enabled;\n        }\n\n        // Take no action when there is no change.\n        if (enabled === _enabled) {\n            return;\n        }\n\n        _enabled = enabled;\n\n        CommandManager.get(Commands.VIEW_TOGGLE_INSPECTION).setChecked(_enabled);\n        updateListeners();\n        if (!doNotSave) {\n            prefs.set(PREF_ENABLED, _enabled);\n            prefs.save();\n        }\n\n        // run immediately\n        run();\n    }\n\n    /**\n     * Toggle the collapsed state for the panel. This explicitly collapses the panel (as opposed to\n     * the auto collapse due to files with no errors & filetypes with no provider). When explicitly\n     * collapsed, the panel will not reopen automatically on switch files or save.\n     *\n     * @param {?boolean} collapsed Collapsed state. If omitted, the state is toggled.\n     * @param {?boolean} doNotSave true if the preference should not be saved to user settings. This is generally for events triggered by project-level settings.\n     */\n    function toggleCollapsed(collapsed, doNotSave) {\n        if (collapsed === undefined) {\n            collapsed = !_collapsed;\n        }\n\n        if (collapsed === _collapsed) {\n            return;\n        }\n\n        _collapsed = collapsed;\n        if (!doNotSave) {\n            prefs.set(PREF_COLLAPSED, _collapsed);\n            prefs.save();\n        }\n\n        if (_collapsed) {\n            problemsPanel.hide();\n        } else {\n            if (_hasErrors) {\n                problemsPanel.show();\n            }\n        }\n    }\n\n    /** Command to go to the first Problem */\n    function handleGotoFirstProblem() {\n        run();\n        if (_gotoEnabled) {\n            $problemsPanel.find(\"tr:not(.inspector-section)\").first().trigger(\"click\");\n        }\n    }\n\n    // Register command handlers\n    CommandManager.register(Strings.CMD_VIEW_TOGGLE_INSPECTION, Commands.VIEW_TOGGLE_INSPECTION,        toggleEnabled);\n    CommandManager.register(Strings.CMD_GOTO_FIRST_PROBLEM,     Commands.NAVIGATE_GOTO_FIRST_PROBLEM,   handleGotoFirstProblem);\n\n    // Register preferences\n    prefs.definePreference(PREF_ENABLED, \"boolean\", brackets.config[\"linting.enabled_by_default\"], {\n        description: Strings.DESCRIPTION_LINTING_ENABLED\n    })\n        .on(\"change\", function (e, data) {\n            toggleEnabled(prefs.get(PREF_ENABLED), true);\n        });\n\n    prefs.definePreference(PREF_COLLAPSED, \"boolean\", false, {\n        description: Strings.DESCRIPTION_LINTING_COLLAPSED\n    })\n        .on(\"change\", function (e, data) {\n            toggleCollapsed(prefs.get(PREF_COLLAPSED), true);\n        });\n\n    prefs.definePreference(PREF_ASYNC_TIMEOUT, \"number\", 10000, {\n        description: Strings.DESCRIPTION_ASYNC_TIMEOUT\n    });\n\n    prefs.definePreference(PREF_PREFER_PROVIDERS, \"array\", [], {\n        description: Strings.DESCRIPTION_LINTING_PREFER,\n        valueType: \"string\"\n    });\n\n    prefs.definePreference(PREF_PREFERRED_ONLY, \"boolean\", false, {\n        description: Strings.DESCRIPTION_USE_PREFERED_ONLY\n    });\n\n    // Initialize items dependent on HTML DOM\n    AppInit.htmlReady(function () {\n        Editor.registerGutter(CODE_INSPECTION_GUTTER, CODE_INSPECTION_GUTTER_PRIORITY);\n        // Create bottom panel to list error details\n        var panelHtml = Mustache.render(PanelTemplate, Strings);\n        problemsPanel = WorkspaceManager.createBottomPanel(\"errors\", $(panelHtml), 100);\n        $problemsPanel = $(\"#problems-panel\");\n\n        var $selectedRow;\n        $problemsPanelTable = $problemsPanel.find(\".table-container\")\n            .on(\"click\", \"tr\", function (e) {\n                if ($selectedRow) {\n                    $selectedRow.removeClass(\"selected\");\n                }\n\n                $selectedRow  = $(e.currentTarget);\n                $selectedRow.addClass(\"selected\");\n\n                // This is a inspector title row, expand/collapse on click\n                if ($selectedRow.hasClass(\"inspector-section\")) {\n                    var $triangle = $(\".disclosure-triangle\", $selectedRow);\n                    var isExpanded = $triangle.hasClass(\"expanded\");\n\n                    // Clicking the inspector title section header collapses/expands result rows\n                    if (isExpanded) {\n                        $selectedRow.nextUntil(\".inspector-section\").addClass(\"forced-hidden\");\n                    } else {\n                        $selectedRow.nextUntil(\".inspector-section\").removeClass(\"forced-hidden\");\n                    }\n                    $triangle.toggleClass(\"expanded\");\n\n                    var providerName = $selectedRow.find(\"input[type='hidden']\").val();\n                    prefs.set(providerName + \".collapsed\", !isExpanded);\n                    prefs.save();\n                } else {\n                    // This is a problem marker row, show the result on click\n                    // Grab the required position data\n                    var lineTd    = $selectedRow.find(\".line-number\");\n                    var line      = parseInt(lineTd.text(), 10) - 1;  // convert friendlyLine back to pos.line\n                    // if there is no line number available, don't do anything\n                    if (!isNaN(line)) {\n                        var character = lineTd.data(\"character\");\n\n                        var editor = EditorManager.getCurrentFullEditor();\n                        editor.setCursorPos(line, character, true);\n                        MainViewManager.focusActivePane();\n                    }\n                }\n            });\n\n        $(\"#problems-panel .close\").click(function () {\n            toggleCollapsed(true);\n            MainViewManager.focusActivePane();\n        });\n\n        // Status bar indicator - icon & tooltip updated by run()\n        var statusIconHtml = Mustache.render(\"<div id=\\\"status-inspection\\\">&nbsp;</div>\", Strings);\n        StatusBar.addIndicator(INDICATOR_ID, $(statusIconHtml), true, \"\", \"\", \"status-indent\");\n\n        $(\"#status-inspection\").click(function () {\n            // Clicking indicator toggles error panel, if any errors in current file\n            if (_hasErrors) {\n                toggleCollapsed();\n            }\n        });\n\n        // Set initial UI state\n        toggleEnabled(prefs.get(PREF_ENABLED), true);\n        toggleCollapsed(prefs.get(PREF_COLLAPSED), true);\n    });\n\n    // Testing\n    exports._unregisterAll          = _unregisterAll;\n    exports._PREF_ASYNC_TIMEOUT     = PREF_ASYNC_TIMEOUT;\n    exports._PREF_PREFER_PROVIDERS  = PREF_PREFER_PROVIDERS;\n    exports._PREF_PREFERRED_ONLY    = PREF_PREFERRED_ONLY;\n\n    // Public API\n    exports.CODE_INSPECTION_GUTTER      = CODE_INSPECTION_GUTTER;\n    exports.register                    = register;\n    exports.Type                        = Type;\n    exports.toggleEnabled               = toggleEnabled;\n    exports.inspectFile                 = inspectFile;\n    exports.requestRun                  = run;\n    exports.getProvidersForPath         = getProvidersForPath;\n    exports.getProviderIDsForLanguage   = getProviderIDsForLanguage;\n});\n"],"file":"CodeInspection.js"}
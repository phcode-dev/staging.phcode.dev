{"version":3,"sources":["project/FileTreeView.js"],"names":["define","require","exports","module","Preact","Classnames","Immutable","_","FileUtils","LanguageManager","FileTreeViewModel","ViewUtils","KeyEvent","PreferencesManager","DOM","_extensions","Map","_draggedItemPath","CLICK_RENAME_MINIMUM","RIGHT_MOUSE_BUTTON","LEFT_MOUSE_BUTTON","INDENTATION_WIDTH","_getName","fullname","extension","substring","length","pathComputer","myPath","result","this","props","parentPath","name","isFile","entry","last","_measureText","text","measuringElement","$","css","position","top","left","visibility","white-space","appendTo","width","remove","_createThickness","depth","div","style","display","_createAlignedIns","ins","className","marginLeft","renameBehavior","handleClick","e","stopPropagation","button","preventDefault","handleKeyDown","keyCode","DOM_VK_ESCAPE","actions","cancelRename","DOM_VK_RETURN","performRename","handleInput","setRenameValue","refs","value","trim","DOM_VK_LEFT","DOM_VK_RIGHT","node","newWidth","handleBlur","dragAndDrop","handleDrag","get","dataTransfer","setData","JSON","stringify","path","dragItem","setDragImage","handleDrop","data","parse","getData","moveItem","setDraggedOver","clearDragTimeout","handleDragEnd","handleDragOver","getParentPath","self","dragOverTimeout","window","setTimeout","setDirectoryOpen","handleDragLeave","clearTimeout","draggedOver","state","setState","document","createElement","textContent","classList","add","body","appendChild","removeChild","fileRenameInput","createFactory","createClass","mixins","componentDidMount","getCompoundFileExtension","setSelectionRange","focus","scrollElementIntoView","render","input","type","defaultValue","autoFocus","onKeyDown","onInput","onClick","onBlur","ref","contextSettable","handleMouseDown","platform","ctrlKey","setContext","selectNode","isDefined","undefined","extendable","getIcons","extensions","getDataForExtension","iconProviders","toArray","iconProviderCB","iconResult","isValidElement","span","dangerouslySetInnerHTML","__html","outerHTML","push","console","error","stack","getClasses","classes","classProviders","succeededPriority","classProviderCB","priority","classResult","fileNode","getInitialState","clickTimer","shouldComponentUpdate","nextProps","nextState","forceRender","componentDidUpdate","prevProps","prevState","wasSelected","isSelected","findDOMNode","clearTimer","startRename","timer","language","getLanguageForPath","doNotOpen","isBinary","getId","shouldOpenInExternalApplication","getFileExtension","toLowerCase","setSelected","handleDoubleClick","openWithExternalApplication","selectInWorkingSet","fullPath","nameDisplay","cx","fileClasses","jstree-clicked selected-node","context-node","liArgs","onMouseDown","onDoubleClick","draggable","onDragStart","thickness","aArgs","flatten","href","a","apply","li","directoryNode","directoryContents","_buildDirsFirstComparator","contents","_dirsFirstCompare","b","aIsFile","bIsFile","compareFilenames","_sortDirectoryContents","dirsFirst","keySeq","sort","directoryRenameInput","sortDirectoriesFirst","event","isOpen","setOpen","metaKey","altKey","toggleSubdirectories","closeSubtree","nodeClass","childNodes","children","directoryClasses","jstree-clicked sidebar-selection","nodeClasses","onDrop","onDragEnd","onDragOver","onDragLeave","iconClass","ulProps","isRoot","namesInOrder","ul","map","key","bind","fileSelectionBox","visible","selectedNode","parentNode","find","selectedClassName","selectionViewInfo","offset","scrollWidth","overflow","selectionExtension","closest","baselineHeight","dataset","initialHeight","height","scrollerTop","outerHeight","difference","parseInt","outerWidth","fileTreeView","treeData","selectionBackground","forceUpdate","contextBackground","extensionForSelection","extensionForContext","args","element","viewModel","projectRoot","_addExtension","category","callback","callbackList","List","sortBy","f","set","addIconProvider","addClassesProvider","_sortFormattedDirectory","_fileNode","_directoryNode","_directoryContents","_fileTreeView"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: FileTreeView*/\n\n/**\n * This is the view layer (template) for the file tree in the sidebar. It takes a FileTreeViewModel\n * and renders it to the given element using Preact. User actions are signaled via an ActionCreator\n * (in the Flux sense).\n */\ndefine(function (require, exports, module) {\n\n\n    var Preact            = require(\"thirdparty/preact\"),\n        Classnames        = require(\"thirdparty/classnames\"),\n        Immutable         = require(\"thirdparty/immutable\"),\n        _                 = require(\"thirdparty/lodash\"),\n        FileUtils         = require(\"file/FileUtils\"),\n        LanguageManager   = require(\"language/LanguageManager\"),\n        FileTreeViewModel = require(\"project/FileTreeViewModel\"),\n        ViewUtils         = require(\"utils/ViewUtils\"),\n        KeyEvent          = require(\"utils/KeyEvent\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\");\n\n    var DOM = Preact.DOM;\n\n    /**\n     * @private\n     * @type {Immutable.Map}\n     *\n     * Stores the file tree extensions for adding classes and icons. The keys of the map\n     * are the \"categories\" of the extensions and values are vectors of the callback functions.\n     */\n    var _extensions = Immutable.Map();\n\n     /**\n     * @private\n     * @type {string}\n     *\n     * Stores the path of the currently dragged item in the filetree.\n     */\n    var _draggedItemPath;\n\n\n    // Constants\n\n    // Time range from first click to second click to invoke renaming.\n    var CLICK_RENAME_MINIMUM  = 500,\n        RIGHT_MOUSE_BUTTON    = 2,\n        LEFT_MOUSE_BUTTON     = 0;\n\n    var INDENTATION_WIDTH     = 10;\n\n    /**\n     * @private\n     *\n     * Returns the name of a file without its extension.\n     *\n     * @param {string} fullname The complete name of the file (not including the rest of the path)\n     * @param {string} extension The file extension\n     * @return {string} The fullname without the extension\n     */\n    function _getName(fullname, extension) {\n        return extension !== \"\" ? fullname.substring(0, fullname.length - extension.length - 1) : fullname;\n    }\n\n    /**\n     * Mixin that allows a component to compute the full path to its directory entry.\n     */\n    var pathComputer = {\n        /**\n         * Computes the full path of the file represented by this input.\n         */\n        myPath: function () {\n            var result = this.props.parentPath + this.props.name;\n\n            // Add trailing slash for directories\n            if (!FileTreeViewModel.isFile(this.props.entry) && _.last(result) !== \"/\") {\n                result += \"/\";\n            }\n\n            return result;\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Gets an appropriate width given the text provided.\n     *\n     * @param {string} text Text to measure\n     * @return {int} Width to use\n     */\n    function _measureText(text) {\n        var measuringElement = $(\"<span />\", { css: { \"position\": \"absolute\", \"top\": \"-200px\", \"left\": \"-1000px\", \"visibility\": \"hidden\", \"white-space\": \"pre\" } }).appendTo(\"body\");\n        measuringElement.text(\"pW\" + text);\n        var width = measuringElement.width();\n        measuringElement.remove();\n        return width;\n    }\n\n    /**\n     * @private\n     *\n     * Create an appropriate div based \"thickness\" to indent the tree correctly.\n     *\n     * @param {int} depth The depth of the current node.\n     * @return {PreactComponent} The resulting div.\n     */\n    function _createThickness(depth) {\n        return DOM.div({\n            style: {\n                display: \"inline-block\",\n                width: INDENTATION_WIDTH * depth\n            }\n        });\n    }\n\n    /**\n     * @private\n     *\n     * Create, and indent correctly, the arrow icons used for the folders.\n     *\n     * @param {int} depth The depth of the current node.\n     * @return {PreactComponent} The resulting ins.\n     */\n    function _createAlignedIns(depth) {\n        return DOM.ins({\n            className: \"jstree-icon\",\n            style: {\n                marginLeft: INDENTATION_WIDTH * depth\n            }\n        });\n    }\n\n    /**\n     * This is a mixin that provides rename input behavior. It is responsible for taking keyboard input\n     * and invoking the correct action based on that input.\n     */\n    var renameBehavior = {\n        /**\n         * Stop clicks from propagating so that clicking on the rename input doesn't\n         * cause directories to collapse.\n         */\n        handleClick: function (e) {\n            e.stopPropagation();\n            if (e.button !== LEFT_MOUSE_BUTTON) {\n                e.preventDefault();\n            }\n        },\n\n        /**\n         * If the user presses enter or escape, we either successfully complete or cancel, respectively,\n         * the rename or create operation that is underway.\n         */\n        handleKeyDown: function (e) {\n            if (e.keyCode === KeyEvent.DOM_VK_ESCAPE) {\n                this.props.actions.cancelRename();\n            } else if (e.keyCode === KeyEvent.DOM_VK_RETURN) {\n                this.props.actions.performRename();\n            }\n        },\n\n        /**\n         * The rename or create operation can be completed or canceled by actions outside of\n         * this component, so we keep the model up to date by sending every update via an action.\n         */\n        handleInput: function (e) {\n            this.props.actions.setRenameValue(this.props.parentPath + this.refs.name.value.trim());\n\n            if (e.keyCode !== KeyEvent.DOM_VK_LEFT &&\n                    e.keyCode !== KeyEvent.DOM_VK_RIGHT) {\n                // update the width of the input field\n                var node = this.refs.name,\n                    newWidth = _measureText(node.value);\n                $(node).width(newWidth);\n            }\n        },\n\n        /**\n         * If we leave the field for any reason, complete the rename.\n         */\n        handleBlur: function () {\n            this.props.actions.performRename();\n        }\n    };\n\n    /**\n     * This is a mixin that provides drag and drop move function.\n     */\n    var dragAndDrop = {\n        handleDrag: function(e) {\n            // Disable drag when renaming\n            if (this.props.entry.get(\"rename\")) {\n                e.preventDefault();\n                e.stopPropagation();\n                return false;\n            }\n\n            // In newer CEF versions, the drag and drop data from the event\n            // (i.e. e.dataTransfer.getData) cannot be used to read data in dragOver event,\n            // so store the drag and drop data in a global variable to read it in the dragOver\n            // event.\n            _draggedItemPath = this.myPath();\n\n            // Pass the dragged item path.\n            e.dataTransfer.setData(\"text\", JSON.stringify({\n                path: _draggedItemPath\n            }));\n\n            this.props.actions.dragItem(this.myPath());\n\n            this.setDragImage(e);\n            e.stopPropagation();\n        },\n        handleDrop: function(e) {\n            var data = JSON.parse(e.dataTransfer.getData(\"text\"));\n\n            this.props.actions.moveItem(data.path, this.myPath());\n            this.setDraggedOver(false);\n\n            this.clearDragTimeout();\n            e.stopPropagation();\n        },\n\n        handleDragEnd: function(e) {\n            this.clearDragTimeout();\n        },\n\n        handleDragOver: function(e) {\n            var data = e.dataTransfer.getData(\"text\"),\n                path;\n\n            if (data) {\n                path = JSON.parse(data).path;\n            } else {\n                path = _draggedItemPath;\n            }\n\n            if (path === this.myPath() || FileUtils.getParentPath(path) === this.myPath()) {\n                e.preventDefault();\n                e.stopPropagation();\n                return;\n            }\n            var self = this;\n            this.setDraggedOver(true);\n\n            // Open the directory tree when item is dragged over a directory\n            if (!this.dragOverTimeout) {\n                this.dragOverTimeout = window.setTimeout(function() {\n                    self.props.actions.setDirectoryOpen(self.myPath(), true);\n                    self.dragOverTimeout = null;\n                }, 800);\n            }\n\n            e.preventDefault(); // Allow the drop\n            e.stopPropagation();\n        },\n\n        handleDragLeave: function(e) {\n            this.setDraggedOver(false);\n            this.clearDragTimeout();\n        },\n\n        clearDragTimeout: function() {\n            if (this.dragOverTimeout) {\n                clearTimeout(this.dragOverTimeout);\n                this.dragOverTimeout = null;\n            }\n        },\n        setDraggedOver: function(draggedOver) {\n            if (this.state.draggedOver !== draggedOver) {\n                this.setState({\n                    draggedOver: draggedOver\n                });\n            }\n        },\n\n        setDragImage: function(e) {\n            var div = window.document.createElement('div');\n            div.textContent = this.props.name;\n            div.classList.add('jstree-dragImage');\n            window.document.body.appendChild(div);\n            e.dataTransfer.setDragImage(div, -10, -10);\n            setTimeout(function() {\n                window.document.body.removeChild(div);\n            }, 0);\n        }\n    };\n\n    /**\n     * @private\n     *\n     * This component presents an input field to the user for renaming a file.\n     *\n     * Props:\n     * * parentPath: the full path of the directory containing this file\n     * * name: the name of the file, including the extension\n     * * actions: the action creator responsible for communicating actions the user has taken\n     */\n    var fileRenameInput = Preact.createFactory(Preact.createClass({\n        mixins: [renameBehavior],\n\n        /**\n         * When this component is displayed, we scroll it into view and select the portion\n         * of the filename that excludes the extension.\n         */\n        componentDidMount: function () {\n            var fullname = this.props.name,\n                extension = LanguageManager.getCompoundFileExtension(fullname);\n\n            var node = this.refs.name;\n            node.setSelectionRange(0, _getName(fullname, extension).length);\n            node.focus(); // set focus on the rename input\n            ViewUtils.scrollElementIntoView($(\"#project-files-container\"), $(node), true);\n        },\n\n        render: function () {\n            var width = _measureText(this.props.name);\n\n            return DOM.input({\n                className: \"jstree-rename-input\",\n                type: \"text\",\n                defaultValue: this.props.name,\n                autoFocus: true,\n                onKeyDown: this.handleKeyDown,\n                onInput: this.handleInput,\n                onClick: this.handleClick,\n                onBlur: this.handleBlur,\n                style: {\n                    width: width\n                },\n                ref: \"name\"\n            });\n        }\n    }));\n\n    /**\n     * @private\n     *\n     * This mixin handles right click (or control click on Mac) action to make a file\n     * the \"context\" object for performing operations like rename.\n     */\n    var contextSettable = {\n\n        /**\n         * Send matching mouseDown events to the action creator as a setContext action.\n         */\n        handleMouseDown: function (e) {\n            e.stopPropagation();\n            if (e.button === RIGHT_MOUSE_BUTTON ||\n                    (this.props.platform === \"mac\" && e.button === LEFT_MOUSE_BUTTON && e.ctrlKey)) {\n                this.props.actions.setContext(this.myPath());\n                e.preventDefault();\n                return;\n            }\n            // Return true only for mouse down in rename mode.\n            if (this.props.entry.get(\"rename\")) {\n                return;\n            }\n            this.selectNode(e);\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Returns true if the value is defined (used in `.filter`)\n     *\n     * @param {Object} value value to test\n     * @return {boolean} true if value is defined\n     */\n    function isDefined(value) {\n        return value !== undefined;\n    }\n\n    /**\n     * Mixin for components that support the \"icons\" and \"addClass\" extension points.\n     * `fileNode` and `directoryNode` support this.\n     */\n    var extendable = {\n\n        /**\n         * Calls the icon providers to get the collection of icons (most likely just one) for\n         * the current file or directory.\n         *\n         * @return {Array.<PreactComponent>} icon components to render\n         */\n        getIcons: function () {\n            let result= [],\n                extensions = this.props.extensions;\n            if (extensions && extensions.get(\"icons\")) {\n                let data = this.getDataForExtension();\n                let iconProviders = extensions.get(\"icons\").toArray();\n                // the iconProviders list is sorted by priority at insertion\n                for(let iconProviderCB of iconProviders){\n                    try {\n                        let iconResult = iconProviderCB(data);\n                        if (iconResult && !Preact.isValidElement(iconResult)) {\n                            iconResult = Preact.DOM.span({\n                                dangerouslySetInnerHTML: {\n                                    __html: $(iconResult)[0].outerHTML\n                                }\n                            });\n                        }\n                        // by this point, returns either undefined or a Preact object\n                        if(iconResult){\n                            result.push(iconResult);\n                            break;\n                        }\n                    } catch (e) {\n                        console.error(\"Exception thrown in FileTreeView icon provider: \" + e, e.stack);\n                    }\n                }\n            }\n\n            if (!result || result.length === 0) {\n                result = [DOM.ins({\n                    className: \"jstree-icon\"\n                }, \" \")];\n            }\n            return result;\n        },\n\n        /**\n         * Calls the addClass providers to get the classes (in string form) to add for the current\n         * file or directory.\n         *\n         * @param {string} classes Initial classes for this node\n         * @return {string} classes for the current node\n         */\n        getClasses: function (classes) {\n            let extensions = this.props.extensions;\n\n            if (extensions && extensions.get(\"addClass\")) {\n                let data = this.getDataForExtension();\n                let classProviders = extensions.get(\"addClass\").toArray();\n                let succeededPriority = null;\n                // the classProviders list is sorted by priority at insertion\n                for(let classProviderCB of classProviders){\n                    if(succeededPriority !== null && (succeededPriority !== classProviderCB.priority)){\n                        // we need to append all class of the same priority and break once we shift to lower priority.\n                        break;\n                    }\n                    try{\n                        let classResult = classProviderCB(data);\n                        if(classResult){\n                            classes = classes + \" \" + classResult;\n                            succeededPriority = classProviderCB.priority;\n                        }\n                    } catch (e) {\n                        console.error(\"Exception thrown in FileTreeView addClass provider: \" + e, e.stack);\n                    }\n                }\n            }\n\n            return classes;\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Component to display a file in the tree.\n     *\n     * Props:\n     * * parentPath: the full path of the directory containing this file\n     * * name: the name of the file, including the extension\n     * * entry: the object with the relevant metadata for the file (whether it's selected or is the context file)\n     * * actions: the action creator responsible for communicating actions the user has taken\n     * * extensions: registered extensions for the file tree\n     * * forceRender: causes the component to run render\n     */\n    var fileNode = Preact.createFactory(Preact.createClass({\n        mixins: [contextSettable, pathComputer, extendable, dragAndDrop],\n\n        /**\n         * Ensures that we always have a state object.\n         */\n        getInitialState: function () {\n            return {\n                clickTimer: null\n            };\n        },\n\n        /**\n         * Thanks to immutable objects, we can just do a start object identity check to know\n         * whether or not we need to re-render.\n         */\n        shouldComponentUpdate: function (nextProps, nextState) {\n            return nextProps.forceRender ||\n                this.props.entry !== nextProps.entry ||\n                this.props.extensions !== nextProps.extensions;\n        },\n\n        /**\n         * If this node is newly selected, scroll it into view. Also, move the selection or\n         * context boxes as appropriate.\n         */\n        componentDidUpdate: function (prevProps, prevState) {\n            var wasSelected = prevProps.entry.get(\"selected\"),\n                isSelected  = this.props.entry.get(\"selected\");\n\n            if (isSelected && !wasSelected) {\n                // TODO: This shouldn't really know about project-files-container\n                // directly. It is probably the case that our Preact tree should actually\n                // start with project-files-container instead of just the interior of\n                // project-files-container and then the file tree will be one self-contained\n                // functional unit.\n                ViewUtils.scrollElementIntoView($(\"#project-files-container\"), $(Preact.findDOMNode(this)), true);\n            } else if (!isSelected && wasSelected && this.state.clickTimer !== null) {\n                this.clearTimer();\n            }\n        },\n\n        clearTimer: function () {\n            if (this.state.clickTimer !== null) {\n                window.clearTimeout(this.state.clickTimer);\n                this.setState({\n                    clickTimer: null\n                });\n            }\n        },\n\n        startRename: function () {\n            if (!this.props.entry.get(\"rename\")) {\n                this.props.actions.startRename(this.myPath());\n            }\n            this.clearTimer();\n        },\n\n        /**\n         * When the user clicks on the node, we'll either select it or, if they've clicked twice\n         * with a bit of delay in between, we'll invoke the `startRename` action.\n         */\n        handleClick: function (e) {\n            // If we're renaming, allow the click to go through to the rename input.\n            if (this.props.entry.get(\"rename\")) {\n                e.stopPropagation();\n                return;\n            }\n\n            if (e.button !== LEFT_MOUSE_BUTTON) {\n                return;\n            }\n\n            if (this.props.entry.get(\"selected\") && !e.ctrlKey) {\n                if (this.state.clickTimer === null && !this.props.entry.get(\"rename\")) {\n                    var timer = window.setTimeout(this.startRename, CLICK_RENAME_MINIMUM);\n                    this.setState({\n                        clickTimer: timer\n                    });\n                }\n            } else {\n                var language = LanguageManager.getLanguageForPath(this.myPath()),\n                    doNotOpen = false;\n                if (language && language.isBinary() && \"image\" !== language.getId() &&\n                        FileUtils.shouldOpenInExternalApplication(\n                            FileUtils.getFileExtension(this.myPath()).toLowerCase()\n                        )\n                    ) {\n                    doNotOpen = true;\n                }\n                this.props.actions.setSelected(this.myPath(), doNotOpen);\n            }\n            e.stopPropagation();\n            e.preventDefault();\n        },\n\n        /**\n         * select the current node in the file tree on mouse down event on files.\n         * This is to increase click responsiveness of file tree.\n         */\n        selectNode: function (e) {\n            if (e.button !== LEFT_MOUSE_BUTTON) {\n                return;\n            }\n\n            var language = LanguageManager.getLanguageForPath(this.myPath()),\n                doNotOpen = false;\n            if (language && language.isBinary() && \"image\" !== language.getId() &&\n                FileUtils.shouldOpenInExternalApplication(\n                    FileUtils.getFileExtension(this.myPath()).toLowerCase()\n                )\n            ) {\n                doNotOpen = true;\n            }\n            this.props.actions.setSelected(this.myPath(), doNotOpen);\n            render();\n        },\n\n        /**\n         * When the user double clicks, we will select this file and add it to the working\n         * set (via the `selectInWorkingSet` action.)\n         */\n        handleDoubleClick: function () {\n            if (!this.props.entry.get(\"rename\")) {\n                if (this.state.clickTimer !== null) {\n                    this.clearTimer();\n                }\n                if (FileUtils.shouldOpenInExternalApplication(\n                        FileUtils.getFileExtension(this.myPath()).toLowerCase()\n                      )) {\n                    this.props.actions.openWithExternalApplication(this.myPath());\n                    return;\n                }\n                this.props.actions.selectInWorkingSet(this.myPath());\n            }\n        },\n\n        /**\n         * Create the data object to pass to extensions.\n         *\n         * @return {!{name:string, isFile:boolean, fullPath:string}} Data for extensions\n         */\n        getDataForExtension: function () {\n            return {\n                name: this.props.name,\n                isFile: true,\n                fullPath: this.myPath()\n            };\n        },\n\n        render: function () {\n            var fullname = this.props.name,\n                extension = LanguageManager.getCompoundFileExtension(fullname),\n                name = _getName(fullname, extension);\n\n            // React automatically wraps content in a span element whereas preact doesn't, so do it manually\n            if (name) {\n                name = DOM.span({}, name);\n            }\n\n            if (extension) {\n                extension = DOM.span({\n                    className: \"extension\"\n                }, \".\" + extension);\n            }\n\n            var nameDisplay,\n                cx = Classnames;\n\n            var fileClasses = cx({\n                'jstree-clicked selected-node': this.props.entry.get(\"selected\"),\n                'context-node': this.props.entry.get(\"context\")\n            });\n\n            var liArgs = [\n                {\n                    className: this.getClasses(\"jstree-leaf\"),\n                    onClick: this.handleClick,\n                    onMouseDown: this.handleMouseDown,\n                    onDoubleClick: this.handleDoubleClick,\n                    draggable: true,\n                    onDragStart: this.handleDrag\n                },\n                DOM.ins({\n                    className: \"jstree-icon\"\n                })\n            ];\n\n            var thickness = _createThickness(this.props.depth);\n\n            if (this.props.entry.get(\"rename\")) {\n                liArgs.push(thickness);\n                nameDisplay = fileRenameInput({\n                    actions: this.props.actions,\n                    entry: this.props.entry,\n                    name: this.props.name,\n                    parentPath: this.props.parentPath\n                });\n            } else {\n                // Need to flatten the argument list because getIcons returns an array\n                var aArgs = _.flatten([{\n                    href: \"#\",\n                    className: fileClasses\n                }, thickness, this.getIcons(), name, extension]);\n                nameDisplay = DOM.a.apply(DOM.a, aArgs);\n            }\n\n            liArgs.push(nameDisplay);\n\n            return DOM.li.apply(DOM.li, liArgs);\n        }\n    }));\n\n    /**\n     * @private\n     *\n     * Creates a comparison function for sorting a directory's contents with directories\n     * appearing before files.\n     *\n     * We're sorting the keys of the directory (the names) based partly on the values,\n     * so we use a closure to capture the map itself so that we can look up the\n     * values as needed.\n     *\n     * @param {Immutable.Map} contents The directory's contents\n     * @return {function(string,string)} Comparator that sorts directories first.\n     */\n    function _buildDirsFirstComparator(contents) {\n        function _dirsFirstCompare(a, b) {\n            var aIsFile = FileTreeViewModel.isFile(contents.get(a)),\n                bIsFile = FileTreeViewModel.isFile(contents.get(b));\n\n            if (!aIsFile && bIsFile) {\n                return -1;\n            } else if (aIsFile && !bIsFile) {\n                return 1;\n            }\n            return FileUtils.compareFilenames(a, b);\n\n        }\n        return _dirsFirstCompare;\n    }\n\n    /**\n     * @private\n     *\n     * Sort a directory either alphabetically or with subdirectories listed first.\n     *\n     * @param {Immutable.Map} contents the directory's contents\n     * @param {boolean} dirsFirst true to sort subdirectories first\n     * @return {Immutable.Map} sorted mapping\n     */\n    function _sortDirectoryContents(contents, dirsFirst) {\n        if (dirsFirst) {\n            return contents.keySeq().sort(_buildDirsFirstComparator(contents));\n        }\n        return contents.keySeq().sort(FileUtils.compareFilenames);\n\n    }\n\n    // Forward references to keep JSLint happy.\n    var directoryNode, directoryContents;\n\n    /**\n     * @private\n     *\n     * Component that provides the input for renaming a directory.\n     *\n     * Props:\n     * * parentPath: the full path of the directory containing this file\n     * * name: the name of the file, including the extension\n     * * actions: the action creator responsible for communicating actions the user has taken\n     */\n    var directoryRenameInput = Preact.createFactory(Preact.createClass({\n        mixins: [renameBehavior],\n\n        /**\n         * When this component is displayed, we scroll it into view and select the folder name.\n         */\n        componentDidMount: function () {\n            var fullname = this.props.name;\n\n            var node = this.refs.name;\n            node.setSelectionRange(0, fullname.length);\n            node.focus(); // set focus on the rename input\n            ViewUtils.scrollElementIntoView($(\"#project-files-container\"), $(node), true);\n        },\n\n        render: function () {\n            var width = _measureText(this.props.name);\n\n            return DOM.input({\n                className: \"jstree-rename-input\",\n                type: \"text\",\n                defaultValue: this.props.name,\n                autoFocus: true,\n                onKeyDown: this.handleKeyDown,\n                onInput: this.handleInput,\n                onBlur: this.handleBlur,\n                style: {\n                    width: width\n                },\n                onClick: this.handleClick,\n                ref: \"name\"\n            });\n        }\n    }));\n\n    /**\n     * @private\n     *\n     * Displays a directory (but not its contents) in the tree.\n     *\n     * Props:\n     * * parentPath: the full path of the directory containing this file\n     * * name: the name of the directory\n     * * entry: the object with the relevant metadata for the file (whether it's selected or is the context file)\n     * * actions: the action creator responsible for communicating actions the user has taken\n     * * sortDirectoriesFirst: whether the directories should be displayed first when listing the contents of a directory\n     * * extensions: registered extensions for the file tree\n     * * forceRender: causes the component to run render\n     */\n    directoryNode = Preact.createFactory(Preact.createClass({\n        mixins: [contextSettable, pathComputer, extendable, dragAndDrop],\n\n        getInitialState: function() {\n            return {\n                draggedOver: false\n            };\n        },\n\n        /**\n         * We need to update this component if the sort order changes or our entry object\n         * changes. Thanks to immutability, if any of the directory contents change, our\n         * entry object will change.\n         */\n        shouldComponentUpdate: function (nextProps, nextState) {\n            return nextProps.forceRender ||\n                this.props.entry !== nextProps.entry ||\n                this.props.sortDirectoriesFirst !== nextProps.sortDirectoriesFirst ||\n                this.props.extensions !== nextProps.extensions ||\n                (nextState !== undefined && this.state.draggedOver !== nextState.draggedOver);\n        },\n\n        /**\n         * If you click on a directory, it will toggle between open and closed.\n         */\n        handleClick: function (event) {\n            if (this.props.entry.get(\"rename\")) {\n                event.stopPropagation();\n                return;\n            }\n\n            if (event.button !== LEFT_MOUSE_BUTTON) {\n                return;\n            }\n\n            var isOpen = this.props.entry.get(\"open\"),\n                setOpen = isOpen ? false : true;\n\n            if (event.metaKey || event.ctrlKey) {\n                // ctrl-alt-click toggles this directory and its children\n                if (event.altKey) {\n                    if (setOpen) {\n                        // when opening, we only open the immediate children because\n                        // opening a whole subtree could be really slow (consider\n                        // a `node_modules` directory, for example).\n                        this.props.actions.toggleSubdirectories(this.myPath(), setOpen);\n                        this.props.actions.setDirectoryOpen(this.myPath(), setOpen);\n                    } else {\n                        // When closing, we recursively close the whole subtree.\n                        this.props.actions.closeSubtree(this.myPath());\n                    }\n                } else {\n                    // ctrl-click toggles the sibling directories\n                    this.props.actions.toggleSubdirectories(this.props.parentPath, setOpen);\n                }\n            } else {\n                // directory toggle with no modifier\n                this.props.actions.setDirectoryOpen(this.myPath(), setOpen);\n            }\n            event.stopPropagation();\n            event.preventDefault();\n        },\n\n        /**\n         * select the current node in the file tree\n         */\n        selectNode: function (e) {\n            // Do nothing for folders on keydown event. Only expand the file tree on click event\n            // to prevent jarring directory accordion expansion in ui.\n        },\n\n        /**\n         * Create the data object to pass to extensions.\n         *\n         * @return {{name: {string}, isFile: {boolean}, fullPath: {string}}} Data for extensions\n         */\n        getDataForExtension: function () {\n            return {\n                name: this.props.name,\n                isFile: false,\n                fullPath: this.myPath()\n            };\n        },\n\n        render: function () {\n            var entry = this.props.entry,\n                nodeClass,\n                childNodes,\n                children = entry.get(\"children\"),\n                isOpen = entry.get(\"open\");\n\n            if (isOpen && children) {\n                nodeClass = \"open\";\n                childNodes = directoryContents({\n                    depth: this.props.depth + 1,\n                    parentPath: this.myPath(),\n                    contents: children,\n                    extensions: this.props.extensions,\n                    actions: this.props.actions,\n                    forceRender: this.props.forceRender,\n                    platform: this.props.platform,\n                    sortDirectoriesFirst: this.props.sortDirectoriesFirst\n                });\n            } else {\n                nodeClass = \"closed\";\n            }\n\n            var nameDisplay,\n                cx = Classnames;\n\n            var directoryClasses = cx({\n                'jstree-clicked sidebar-selection': entry.get(\"selected\"),\n                'context-node': entry.get(\"context\")\n            });\n\n            var nodeClasses = \"jstree-\" + nodeClass;\n            if (this.state.draggedOver) {\n                nodeClasses += \" jstree-draggedOver\";\n            }\n\n            var liArgs = [\n                {\n                    className: this.getClasses(nodeClasses),\n                    onClick: this.handleClick,\n                    onMouseDown: this.handleMouseDown,\n                    draggable: true,\n                    onDragStart: this.handleDrag,\n                    onDrop: this.handleDrop,\n                    onDragEnd: this.handleDragEnd,\n                    onDragOver: this.handleDragOver,\n                    onDragLeave: this.handleDragLeave\n                },\n                _createAlignedIns(this.props.depth)\n            ];\n\n            var thickness = _createThickness(this.props.depth);\n\n            if (entry.get(\"rename\")) {\n                liArgs.push(thickness);\n                nameDisplay = directoryRenameInput({\n                    actions: this.props.actions,\n                    entry: entry,\n                    name: this.props.name,\n                    parentPath: this.props.parentPath\n                });\n            } else {\n                // React automatically wraps content in a span element whereas preact doesn't, so do it manually\n                if (this.props.name) {\n                    var name = DOM.span({}, this.props.name);\n                }\n\n                // Need to flatten the arguments because getIcons returns an array\n                var aArgs = _.flatten([{\n                    href: \"#\",\n                    className: directoryClasses\n                }, thickness, this.getIcons(), name]);\n                nameDisplay = DOM.a.apply(DOM.a, aArgs);\n            }\n\n            liArgs.push(nameDisplay);\n            liArgs.push(childNodes);\n\n            return DOM.li.apply(DOM.li, liArgs);\n        }\n    }));\n\n    /**\n     * @private\n     *\n     * Displays the contents of a directory.\n     *\n     * Props:\n     * * isRoot: whether this directory is the root of the tree\n     * * parentPath: the full path of the directory containing this file\n     * * contents: the map of name/child entry pairs for this directory\n     * * actions: the action creator responsible for communicating actions the user has taken\n     * * sortDirectoriesFirst: whether the directories should be displayed first when listing the contents of a directory\n     * * extensions: registered extensions for the file tree\n     * * forceRender: causes the component to run render\n     */\n    directoryContents = Preact.createFactory(Preact.createClass({\n\n        /**\n         * Need to re-render if the sort order or the contents change.\n         */\n        shouldComponentUpdate: function (nextProps, nextState) {\n            return nextProps.forceRender ||\n                this.props.contents !== nextProps.contents ||\n                this.props.sortDirectoriesFirst !== nextProps.sortDirectoriesFirst ||\n                this.props.extensions !== nextProps.extensions;\n        },\n\n        render: function () {\n            var extensions = this.props.extensions,\n                iconClass = extensions && extensions.get(\"icons\") ? \"jstree-icons\" : \"jstree-no-icons\",\n                ulProps = this.props.isRoot ? {\n                    className: \"jstree-brackets jstree-no-dots \" + iconClass\n                } : null;\n\n            var contents = this.props.contents,\n                namesInOrder = _sortDirectoryContents(contents, this.props.sortDirectoriesFirst);\n\n            return DOM.ul(ulProps, namesInOrder.map(function (name) {\n                var entry = contents.get(name);\n\n                if (FileTreeViewModel.isFile(entry)) {\n                    return fileNode({\n                        depth: this.props.depth,\n                        parentPath: this.props.parentPath,\n                        name: name,\n                        entry: entry,\n                        actions: this.props.actions,\n                        extensions: this.props.extensions,\n                        forceRender: this.props.forceRender,\n                        platform: this.props.platform,\n                        key: name\n                    });\n                }\n                return directoryNode({\n                    depth: this.props.depth,\n                    parentPath: this.props.parentPath,\n                    name: name,\n                    entry: entry,\n                    actions: this.props.actions,\n                    extensions: this.props.extensions,\n                    sortDirectoriesFirst: this.props.sortDirectoriesFirst,\n                    forceRender: this.props.forceRender,\n                    platform: this.props.platform,\n                    key: name\n                });\n\n            }.bind(this)).toArray());\n        }\n    }));\n\n    /**\n     * Displays the absolutely positioned box for the selection or context in the\n     * file tree. Its position is determined by passed-in info about the scroller in which\n     * the tree resides and the top of the selected node (as reported by the node itself).\n     *\n     * Props:\n     * * selectionViewInfo: Immutable.Map with width, scrollTop, scrollLeft and offsetTop for the tree container\n     * * visible: should this be visible now\n     * * selectedClassName: class name applied to the element that is selected\n     */\n    var fileSelectionBox = Preact.createFactory(Preact.createClass({\n        /**\n         * When the component has updated in the DOM, reposition it to where the currently\n         * selected node is located now.\n         */\n        componentDidUpdate: function () {\n            if (!this.props.visible) {\n                return;\n            }\n\n            var node = Preact.findDOMNode(this),\n                selectedNode = $(node.parentNode).find(this.props.selectedClassName),\n                selectionViewInfo = this.props.selectionViewInfo;\n\n            if (selectedNode.length === 0) {\n                return;\n            }\n\n            node.style.top = selectedNode.offset().top - selectionViewInfo.get(\"offsetTop\") + selectionViewInfo.get(\"scrollTop\") - selectedNode.position().top + \"px\";\n        },\n\n        render: function () {\n            var selectionViewInfo = this.props.selectionViewInfo,\n                left = selectionViewInfo.get(\"scrollLeft\"),\n                width = selectionViewInfo.get(\"width\"),\n                scrollWidth = selectionViewInfo.get(\"scrollWidth\");\n\n            return DOM.div({\n                style: {\n                    overflow: \"auto\",\n                    left: left,\n                    display: this.props.visible ? \"block\" : \"none\"\n                },\n                className: this.props.className\n            });\n        }\n    }));\n\n    /**\n     * On Windows and Linux, the selection bar in the tree does not extend over the scroll bar.\n     * The selectionExtension sits on top of the scroll bar to make the selection bar appear to span the\n     * whole width of the sidebar.\n     *\n     * Props:\n     * * selectionViewInfo: Immutable.Map with width, scrollTop, scrollLeft and offsetTop for the tree container\n     * * visible: should this be visible now\n     * * selectedClassName: class name applied to the element that is selected\n     * * className: class to be applied to the extension element\n     */\n    var selectionExtension = Preact.createFactory(Preact.createClass({\n        /**\n         * When the component has updated in the DOM, reposition it to where the currently\n         * selected node is located now.\n         */\n        componentDidUpdate: function () {\n            if (!this.props.visible) {\n                return;\n            }\n\n            var node = Preact.findDOMNode(this),\n                selectedNode = $(node.parentNode).find(this.props.selectedClassName).closest(\"li\"),\n                selectionViewInfo = this.props.selectionViewInfo;\n\n            if (selectedNode.length === 0) {\n                return;\n            }\n\n            var top = selectedNode.offset().top,\n                baselineHeight = node.dataset.initialHeight,\n                height = baselineHeight,\n                scrollerTop = selectionViewInfo.get(\"offsetTop\");\n\n            if (!baselineHeight) {\n                baselineHeight = $(node).outerHeight();\n                node.dataset.initialHeight = baselineHeight;\n                height = baselineHeight;\n            }\n\n            // Check to see if the selection is completely scrolled out of view\n            // to prevent the extension from appearing in the working set area.\n            if (top < scrollerTop - baselineHeight) {\n                node.style.display = \"none\";\n                return;\n            }\n\n            node.style.display = \"block\";\n\n            // The selectionExtension sits on top of the other nodes\n            // so we need to shrink it if only part of the selection node is visible\n            if (top < scrollerTop) {\n                var difference = scrollerTop - top;\n                top += difference;\n                height = parseInt(height, 10);\n                height -= difference;\n            }\n\n            node.style.top = top + \"px\";\n            node.style.height = height + \"px\";\n            node.style.left = selectionViewInfo.get(\"width\") - $(node).outerWidth() + \"px\";\n        },\n\n        render: function () {\n            return DOM.div({\n                style: {\n                    display: this.props.visible ? \"block\" : \"none\"\n                },\n                className: this.props.className\n            });\n        }\n    }));\n\n    /**\n     * @private\n     *\n     * This is the root component of the file tree.\n     *\n     * Props:\n     * * treeData: the root of the tree (an Immutable.Map with the contents of the project root)\n     * * sortDirectoriesFirst: whether the directories should be displayed first when listing the contents of a directory\n     * * parentPath: the full path of the directory containing this file\n     * * actions: the action creator responsible for communicating actions the user has taken\n     * * extensions: registered extensions for the file tree\n     * * forceRender: causes the component to run render\n     * * platform: platform that Brackets is running on\n     */\n    var fileTreeView = Preact.createFactory(Preact.createClass({\n\n        /**\n         * Update for any change in the tree data or directory sorting preference.\n         */\n        shouldComponentUpdate: function (nextProps, nextState) {\n            return nextProps.forceRender ||\n                this.props.treeData !== nextProps.treeData ||\n                this.props.sortDirectoriesFirst !== nextProps.sortDirectoriesFirst ||\n                this.props.extensions !== nextProps.extensions ||\n                this.props.selectionViewInfo !== nextProps.selectionViewInfo;\n        },\n\n        handleDrop: function(e) {\n            var data = JSON.parse(e.dataTransfer.getData(\"text\"));\n            this.props.actions.moveItem(data.path, this.props.parentPath);\n            e.stopPropagation();\n        },\n\n        /**\n         * Allow the Drop\n         */\n        handleDragOver: function(e) {\n            e.preventDefault();\n        },\n\n        render: function () {\n            var selectionBackground = fileSelectionBox({\n                    ref: \"selectionBackground\",\n                    selectionViewInfo: this.props.selectionViewInfo,\n                    className: \"filetree-selection\",\n                    visible: this.props.selectionViewInfo.get(\"hasSelection\"),\n                    selectedClassName: \".selected-node\",\n                    forceUpdate: true\n                }),\n                contextBackground = fileSelectionBox({\n                    ref: \"contextBackground\",\n                    selectionViewInfo: this.props.selectionViewInfo,\n                    className: \"filetree-context\",\n                    visible: this.props.selectionViewInfo.get(\"hasContext\"),\n                    selectedClassName: \".context-node\",\n                    forceUpdate: true\n                }),\n                extensionForSelection = selectionExtension({\n                    selectionViewInfo: this.props.selectionViewInfo,\n                    selectedClassName: \".selected-node\",\n                    visible: this.props.selectionViewInfo.get(\"hasSelection\"),\n                    forceUpdate: true,\n                    className: \"filetree-selection-extension\"\n                }),\n                extensionForContext = selectionExtension({\n                    selectionViewInfo: this.props.selectionViewInfo,\n                    selectedClassName: \".context-node\",\n                    visible: this.props.selectionViewInfo.get(\"hasContext\"),\n                    forceUpdate: true,\n                    className: \"filetree-context-extension\"\n                }),\n                contents = directoryContents({\n                    isRoot: true,\n                    depth: 1,\n                    parentPath: this.props.parentPath,\n                    sortDirectoriesFirst: this.props.sortDirectoriesFirst,\n                    contents: this.props.treeData,\n                    extensions: this.props.extensions,\n                    actions: this.props.actions,\n                    forceRender: this.props.forceRender,\n                    platform: this.props.platform\n                }),\n                args = {\n                    onDrop: this.handleDrop,\n                    onDragOver: this.handleDragOver\n                };\n\n\n            return DOM.div(\n                args,\n                contents,\n                selectionBackground,\n                contextBackground,\n                extensionForSelection,\n                extensionForContext\n            );\n        }\n    }));\n\n    /**\n     * Renders the file tree to the given element.\n     *\n     * @param {DOMNode|jQuery} element Element in which to render this file tree\n     * @param {FileTreeViewModel} viewModel the data container\n     * @param {Directory} projectRoot Directory object from which the fullPath of the project root is extracted\n     * @param {ActionCreator} actions object with methods used to communicate events that originate from the user\n     * @param {boolean} forceRender Run render on the entire tree (useful if an extension has new data that it needs rendered)\n     * @param {string} platform mac, win, linux\n     */\n    function render(element, viewModel, projectRoot, actions, forceRender, platform) {\n        if (!projectRoot) {\n            return;\n        }\n\n        Preact.render(fileTreeView({\n            treeData: viewModel.treeData,\n            selectionViewInfo: viewModel.selectionViewInfo,\n            sortDirectoriesFirst: viewModel.sortDirectoriesFirst,\n            parentPath: projectRoot.fullPath,\n            actions: actions,\n            extensions: _extensions,\n            platform: platform,\n            forceRender: forceRender\n        }),\n              element);\n    }\n\n    /**\n     * @private\n     *\n     * Add an extension for the given category (icons, addClass).\n     *\n     * @param {string} category Category to which the extension is being added\n     * @param {function} callback The extension function itself\n     */\n    function _addExtension(category, callback) {\n        if (!callback || typeof callback !== \"function\") {\n            console.error(\"Attempt to add FileTreeView\", category, \"extension without a callback function\");\n            return;\n        }\n        var callbackList = _extensions.get(category);\n        if (!callbackList) {\n            callbackList = Immutable.List();\n        }\n        callbackList = callbackList.push(callback);\n        callbackList = callbackList.sortBy((f) => -f.priority);\n        _extensions = _extensions.set(category, callbackList);\n    }\n\n    /**\n     * Adds an icon provider. The callback is invoked before each working set item is created, and can\n     * return content to prepend to the item if it supports the icon.\n     *\n     * @param {!function(!{name:string, fullPath:string, isFile:boolean}):?string|jQuery|DOMNode} callback\n     * Return a string representing the HTML, a jQuery object or DOM node, or undefined. If undefined,\n     * nothing is prepended to the list item and the default or an available icon will be used.\n     * @param {number} [priority] optional priority. 0 being lowest. The icons with the highest priority wins if there\n     * are multiple callback providers attached. icon providers of the same priority first valid response wins.\n     */\n    function addIconProvider(callback, priority= 0) {\n        callback.priority = priority;\n        _addExtension(\"icons\", callback);\n    }\n\n    /**\n     * Adds a CSS class provider, invoked before each working set item is created or updated. When called\n     * to update an existing item, all previously applied classes have been cleared.\n     *\n     * @param {!function(!{name:string, fullPath:string, isFile:boolean}):?string} callback\n     * Return a string containing space-separated CSS class(es) to add, or undefined to leave CSS unchanged.\n     * @param {number} [priority] optional priority. 0 being lowest. The class with the highest priority wins if there\n     * are multiple callback classes attached. class providers of the same priority will be appended.\n     */\n    function addClassesProvider(callback, priority = 0) {\n        callback.priority = priority;\n        _addExtension(\"addClass\", callback);\n    }\n\n    // Private API for testing\n    exports._sortFormattedDirectory = _sortDirectoryContents;\n    exports._fileNode = fileNode;\n    exports._directoryNode = directoryNode;\n    exports._directoryContents = directoryContents;\n    exports._fileTreeView = fileTreeView;\n\n    // Public API\n    exports.addIconProvider = addIconProvider;\n    exports.addClassesProvider = addClassesProvider;\n    exports.render = render;\n});\n"],"file":"FileTreeView.js"}
{"version":3,"sources":["extensions/default/NavigationAndHistory/FileRecovery.js"],"names":["define","require","exports","module","NativeApp","brackets","getModule","FileSystem","ProjectManager","MainViewManager","FileSystemError","FileUtils","DocumentManager","NotificationUI","Mustache","Strings","FileViewController","recoveryTemplate","EventDispatcher","EventManager","makeEventDispatcher","registerEventHandler","BACKUP_INTERVAL_MS","sessionRestoreDir","getDirectoryForPath","path","normalize","getApplicationSupportDirectory","trackedProjects","simpleHash","str","hash","i","length","char","charCodeAt","Math","abs","createDir","dir","Promise","resolve","reject","create","err","ALREADY_EXISTS","console","error","fullPath","silentlyRemoveFile","getFileForPath","unlink","silentlyRemoveDirectory","getProjectRestoreRoot","projectPath","baseName","basename","restoreRootPath","getRestoreFilePath","projectFilePath","projectRootPath","startsWith","pathWithinProject","replace","restoreRoot","getProjectFilePath","restoreFilePath","project","filePathInProject","async","ensureFolderIsClean","folder","unlinkEmptyDirectoryAsync","loadLastBackedUpFileContents","currentProjectLoadCount","projectLoadCount","restoreFolder","allEntries","getAllDirectoryContents","backupExists","entry","isDirectory","text","jsPromise","readAsText","lastBackedUpFileContents","lastBackedupLoadInProgress","notificationHTML","render","PROJECT_TO_RECOVER","restoreNotification","close","createToastFromTemplate","RECOVER_UNSAVED_FILES_TITLE","dismissOnClick","toastStyle","NOTIFICATION_STYLES_CSS_CLASS","SUCCESS","projectOpened","_event","projectRoot","firstEditHandled","trackedFileUpdateTimestamps","trackedFileContents","changeErrorReported","catch","writeFileIgnoreFailure","filePath","contents","parentDir","dirname","file","writeText","e","backupChangedDocs","trackedFilePaths","Object","keys","trackedFilePath","restorePath","content","cleanupUntrackedFiles","docPathsToTrack","allTrackingPaths","trackedPath","restoreFile","backupInProgress","changeScanner","currentProjectRoot","getProjectRoot","openDocs","getAllOpenDocuments","dirtyDocsExists","doc","isDirty","lastTrackedTimestamp","lastChangeTimestamp","getText","logger","reportError","beforeProjectClosed","ensureOpenEditors","pathList","allOpenFiles","getAllOpenFiles","openFilePaths","openFileAndAddToWorkingSet","restoreBtnClicked","projectToRestore","pathsToRestore","isWithinProject","document","log","getDocumentForPath","setText","initWith","scanIntervalMs","restoreDir","on","EVENT_AFTER_PROJECT_OPEN","EVENT_PROJECT_BEFORE_CLOSE","setInterval","init","window","testEnvironment","_FileRecoveryExtensionForTests"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2016 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global path, logger, jsPromise*/\n\n/**\n * This file outlines the process phcode follows to restore files if the application crashes or if a user closes\n * the application without saving their files.\n *\n * For each project in phcode, there's a unique 'restore' folder located in the appdata directory.\n * This folder is named according to the pattern <projectName>-<projectPathHash>.\n *\n * The restore folder monitors all files being edited in phcode, and this tracking is updated every 5 seconds\n * by a function called changeScanner. The function backs up changes every 5 seconds, and only unsaved files\n * that have been modified since the last backup are synced again. When files are saved, they're removed from\n * the backup during this changeScanner process because there's no need to restore them.\n *\n * When opening a project, we first check for the existence of a 'restore' folder associated with that project\n * and scan for any files within it. If we find any, these files are marked for potential restoration.\n *\n * During this process, we load all recoverable file data into memory and temporarily halt any writing activity\n * to the 'restore' folder. This safeguard is in place to prevent any accidental overwriting of the restore files'\n * data in case the user edits any files currently marked for restoration.\n *\n * Once we've cached the data from the restore files, we present a notification to the user, asking if they would\n * like these files to be restored. If the user agrees, we then open all of these files in the editor and populate\n * them with the previously cached, restored content.\n */\n\ndefine(function (require, exports, module) {\n    const NativeApp = brackets.getModule(\"utils/NativeApp\"),\n        FileSystem = brackets.getModule(\"filesystem/FileSystem\"),\n        ProjectManager = brackets.getModule(\"project/ProjectManager\"),\n        MainViewManager = brackets.getModule(\"view/MainViewManager\"),\n        FileSystemError = brackets.getModule(\"filesystem/FileSystemError\"),\n        FileUtils = brackets.getModule(\"file/FileUtils\"),\n        DocumentManager = brackets.getModule(\"document/DocumentManager\"),\n        NotificationUI = brackets.getModule(\"widgets/NotificationUI\"),\n        Mustache = brackets.getModule(\"thirdparty/mustache/mustache\"),\n        Strings = brackets.getModule(\"strings\"),\n        FileViewController  = brackets.getModule(\"project/FileViewController\"),\n        recoveryTemplate = require(\"text!html/recovery-template.html\"),\n        EventDispatcher = brackets.getModule(\"utils/EventDispatcher\"),\n        EventManager = brackets.getModule(\"utils/EventManager\");\n\n    EventDispatcher.makeEventDispatcher(exports);\n    EventManager.registerEventHandler(\"ph-recovery\", exports);\n\n    const BACKUP_INTERVAL_MS = 5000;\n    let sessionRestoreDir = FileSystem.getDirectoryForPath(\n        path.normalize(NativeApp.getApplicationSupportDirectory() + \"/sessionRestore\"));\n\n    const trackedProjects = {};\n\n    function simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            let char = str.charCodeAt(i);\n            // eslint-disable-next-line no-bitwise\n            hash = ((hash << 5) - hash) + char;\n            // eslint-disable-next-line no-bitwise\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return Math.abs(hash) + \"\";\n    }\n\n    function createDir(dir) {\n        return new Promise((resolve, reject)=>{\n            dir.create(function (err) {\n                if (err && err !== FileSystemError.ALREADY_EXISTS) {\n                    console.error(\"[recovery] Error creating project crash restore folder \" + dir.fullPath, err);\n                    reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function silentlyRemoveFile(path) {\n        return new Promise((resolve)=>{\n            FileSystem.getFileForPath(path).unlink((err)=>{\n                if(err) {\n                    console.error(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function silentlyRemoveDirectory(dir) {\n        return new Promise((resolve)=>{\n            dir.unlink((err)=>{\n                if(err) {\n                    console.error(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function getProjectRestoreRoot(projectPath) {\n        const baseName = path.basename(projectPath),\n            restoreRootPath = path.normalize(`${sessionRestoreDir.fullPath}/${baseName}_${simpleHash(projectPath)}`);\n        return FileSystem.getDirectoryForPath(restoreRootPath);\n    }\n\n    function getRestoreFilePath(projectFilePath, projectRootPath) {\n        if(!projectFilePath.startsWith(projectRootPath) || !trackedProjects[projectRootPath]){\n            console.error(`[recovery] cannot backed up as ${projectRootPath} is not in project ${projectRootPath}`);\n            return null;\n        }\n        let pathWithinProject = projectFilePath.replace(projectRootPath, \"\");\n        let restoreRoot = trackedProjects[projectRootPath].restoreRoot;\n        return path.normalize(`${restoreRoot.fullPath}/${pathWithinProject}`);\n    }\n\n    // try not to use this\n    function getProjectFilePath(restoreFilePath, projectRootPath) {\n        const project = trackedProjects[projectRootPath];\n        if(!project || !restoreFilePath.startsWith(project.restoreRoot.fullPath)){\n            return null;\n        }\n\n        let filePathInProject = restoreFilePath.replace(project.restoreRoot.fullPath, \"\");\n        return path.normalize(`${projectRootPath}/${filePathInProject}`);\n    }\n\n    /**\n     * the restore folder may have empty folders as files get deleted according to backup algorithm. This fn will\n     * ensure that there are no empty folders and restore folder exists\n     * @param folder\n     * @return {Promise<void>}\n     */\n    async function ensureFolderIsClean(folder) {\n        await createDir(folder);\n        await folder.unlinkEmptyDirectoryAsync();\n        await createDir(folder);\n    }\n\n    async function loadLastBackedUpFileContents(projectRootPath) {\n        const project = trackedProjects[projectRootPath];\n        if(!project){\n            console.error(\"[recovery] Cannot load backup, no tracking info of project \" + projectRootPath);\n            return;\n        }\n        const currentProjectLoadCount = project.projectLoadCount;\n        let restoreFolder = project.restoreRoot;\n        await ensureFolderIsClean(restoreFolder);\n        let allEntries = await FileSystem.getAllDirectoryContents(restoreFolder);\n        let backupExists = false;\n        for(let entry of allEntries){\n            if(entry.isDirectory){\n                continue;\n            }\n            let text = await jsPromise(FileUtils.readAsText(entry));\n            let projectFilePath = getProjectFilePath(entry.fullPath, projectRootPath);\n            if(currentProjectLoadCount !== project.projectLoadCount){\n                // this means that while we were tying to load a project backup, the user switched to another project\n                // and then switched back to this project, all before the first backup load was complete. so\n                // we just return without doing anything here. This function will be eventually called on projectOpened\n                // event handler.\n                return;\n            }\n            project.lastBackedUpFileContents[projectFilePath] = text;\n            backupExists = true;\n        }\n        project.lastBackedupLoadInProgress = false;\n        if(backupExists) {\n            let notificationHTML = Mustache.render(recoveryTemplate, {\n                Strings: Strings,\n                PROJECT_TO_RECOVER: projectRootPath\n            });\n            if(project.restoreNotification){\n                project.restoreNotification.close();\n                project.restoreNotification = null;\n            }\n            project.restoreNotification = NotificationUI.createToastFromTemplate( Strings.RECOVER_UNSAVED_FILES_TITLE,\n                notificationHTML, {\n                    dismissOnClick: false,\n                    toastStyle: NotificationUI.NOTIFICATION_STYLES_CSS_CLASS.SUCCESS\n                });\n        }\n    }\n\n    function projectOpened(_event, projectRoot) {\n        if(projectRoot.fullPath === '/') {\n            console.error(\"[recovery] Backups will not be done for root folder `/`\");\n            return;\n        }\n        if(trackedProjects[projectRoot.fullPath]){\n            if(trackedProjects[projectRoot.fullPath].restoreNotification){\n                trackedProjects[projectRoot.fullPath].restoreNotification.close();\n                trackedProjects[projectRoot.fullPath].restoreNotification = null;\n            }\n            trackedProjects[projectRoot.fullPath].projectLoadCount++;// we use this to prevent race conditions\n            // on frequent project switch before all project backup files are loaded.\n            trackedProjects[projectRoot.fullPath].lastBackedUpFileContents = {};\n            trackedProjects[projectRoot.fullPath].firstEditHandled = false;\n            trackedProjects[projectRoot.fullPath].lastBackedupLoadInProgress = true;\n            trackedProjects[projectRoot.fullPath].trackedFileUpdateTimestamps = {};\n            trackedProjects[projectRoot.fullPath].trackedFileContents = {};\n            trackedProjects[projectRoot.fullPath].changeErrorReported = false;\n            loadLastBackedUpFileContents(projectRoot.fullPath).catch(err=>{\n                console.error(\"[recovery] loadLastBackedUpFileContents failed \", err);\n            });\n            return;\n        }\n        trackedProjects[projectRoot.fullPath] = {\n            projectLoadCount: 0, // we use this to prevent race conditions on frequent project switch before all\n            // project backup files are loaded.\n            projectRoot: projectRoot,\n            restoreRoot: getProjectRestoreRoot(projectRoot.fullPath),\n            lastBackedUpFileContents: {},\n            firstEditHandled: false, // after a project is loaded, has the first edit by user on any file been handled?\n            lastBackedupLoadInProgress: true, // while the backup is loading, we need to prevent write over the existing\n            // backup with backup info of the current session\n            trackedFileUpdateTimestamps: {},\n            trackedFileContents: {},\n            restoreNotification: null,\n            changeErrorReported: false // we only report change errors once to prevent too many Bugsnag reports\n        };\n        loadLastBackedUpFileContents(projectRoot.fullPath).catch(err=>{\n            console.error(\"[recovery] loadLastBackedUpFileContents failed \", err);\n        });\n    }\n\n    async function writeFileIgnoreFailure(filePath, contents) {\n        try {\n            let parentDir = FileSystem.getDirectoryForPath(path.dirname(filePath));\n            await createDir(parentDir);\n            let file = FileSystem.getFileForPath(filePath);\n            await jsPromise(FileUtils.writeText(file, contents, true));\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    async function backupChangedDocs(projectRoot) {\n        const project = trackedProjects[projectRoot.fullPath];\n        let trackedFilePaths =  Object.keys(project.trackedFileContents);\n        for(let trackedFilePath of trackedFilePaths){\n            const restorePath = getRestoreFilePath(trackedFilePath, projectRoot.fullPath);\n            const content = project.trackedFileContents[trackedFilePath];\n            await writeFileIgnoreFailure(restorePath, content);\n            delete project.trackedFileContents[trackedFilePath];\n        }\n    }\n\n    async function cleanupUntrackedFiles(docPathsToTrack, projectRoot) {\n        const project = trackedProjects[projectRoot.fullPath];\n        let allTrackingPaths = Object.keys(project.trackedFileUpdateTimestamps);\n        for(let trackedPath of allTrackingPaths){\n            if(!docPathsToTrack[trackedPath]){\n                const restoreFile = getRestoreFilePath(trackedPath, projectRoot.fullPath);\n                await silentlyRemoveFile(restoreFile);\n                delete project.trackedFileUpdateTimestamps[trackedPath];\n            }\n        }\n    }\n\n    let backupInProgress = false;\n\n    /**\n     * This gets executed every 5 seconds and should be as light-weight as possible. If there are no changes to be\n     * backed up, then this function should return as soon as possible without waiting for any async flows.\n     * @return {Promise<void>}\n     */\n    async function changeScanner() {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        if(backupInProgress || currentProjectRoot.fullPath === \"/\" || !project || project.lastBackedupLoadInProgress){\n            // trackingProjectRoot can be \"/\" if debug>open virtual file system menu is clicked. Don't track root fs\n            return;\n        }\n        backupInProgress = true;\n        try{\n            // do backup\n            const openDocs = DocumentManager.getAllOpenDocuments();\n            let docPathsToTrack = {}, dirtyDocsExists = false;\n            for(let doc of openDocs){\n                if(doc && doc.isDirty){\n                    dirtyDocsExists = true;\n                    docPathsToTrack[doc.file.fullPath] = true;\n                    const lastTrackedTimestamp = project.trackedFileUpdateTimestamps[doc.file.fullPath];\n                    if(!lastTrackedTimestamp || lastTrackedTimestamp !== doc.lastChangeTimestamp){\n                        // Already backed up, only need to consider it again if its contents changed\n                        project.trackedFileContents[doc.file.fullPath] = doc.getText();\n                        project.trackedFileUpdateTimestamps[doc.file.fullPath] = doc.lastChangeTimestamp;\n                    }\n                }\n            }\n            if(!project.firstEditHandled && dirtyDocsExists) {\n                // this means that the last backup session has been fully loaded in memory and a new edit has been\n                // done by the user. The user may not have yet clicked on the restore backup button. But as the user\n                // made an edit, we should delete the project restore folder to start a new backup session. The user\n                // can still restore the last backup session from the in memory `project.lastBackedUpFileContents`\n                await silentlyRemoveDirectory(project.restoreRoot);\n                await createDir(project.restoreRoot);\n                await backupChangedDocs(currentProjectRoot);\n                project.firstEditHandled = true;\n            } else {\n                await backupChangedDocs(currentProjectRoot);\n                await cleanupUntrackedFiles(docPathsToTrack, currentProjectRoot);\n            }\n        } catch (e) {\n            console.error(\"[recovery] changeScanner error\", e);\n            if(!project.changeErrorReported){\n                project.changeErrorReported = true;\n                // we only report change errors once to prevent too many Bugsnag reports\n                logger.reportError(e);\n            }\n        }\n        backupInProgress = false;\n    }\n\n    function beforeProjectClosed() {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        if(project.restoreNotification) {\n            project.restoreNotification.close();\n            project.restoreNotification = null;\n        }\n        changeScanner().catch(err=>{\n            console.error(\"[recovery] beforeProjectClosed failed which scanning for changes to backup\", err);\n        });\n    }\n\n    async function ensureOpenEditors(pathList) {\n        let allOpenFiles = MainViewManager.getAllOpenFiles();\n        let openFilePaths = {};\n        for(let file of allOpenFiles){\n            openFilePaths[file.fullPath] = true;\n        }\n        for(let path of pathList) {\n            if(!openFilePaths[path]){\n                let file = FileSystem.getFileForPath(path);\n                await jsPromise(FileViewController.openFileAndAddToWorkingSet(file.fullPath));\n            }\n        }\n    }\n\n    async function restoreBtnClicked(_event, projectToRestore) {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        if(!project || projectToRestore !== currentProjectRoot.fullPath){\n            console.error(`[recovery] current project ${currentProjectRoot.fullPath} != restore ${projectToRestore}`);\n            return;\n        }\n        let pathsToRestore = Object.keys(project.lastBackedUpFileContents);\n        await ensureOpenEditors(pathsToRestore);\n        for(let filePath of pathsToRestore){\n            if(ProjectManager.isWithinProject(filePath)) {\n                console.log(\"restoring\", filePath);\n                let document = await jsPromise(DocumentManager.getDocumentForPath(filePath));\n                document.setText(project.lastBackedUpFileContents[filePath]);\n            } else {\n                console.error(\"[recovery] Skipping restore of non project file: \", filePath);\n            }\n        }\n        if(project.restoreNotification){\n            project.restoreNotification.close();\n            project.restoreNotification = null;\n        }\n    }\n\n    function initWith(scanIntervalMs, restoreDir) {\n        ProjectManager.on(ProjectManager.EVENT_AFTER_PROJECT_OPEN, projectOpened);\n        ProjectManager.on(ProjectManager.EVENT_PROJECT_BEFORE_CLOSE, beforeProjectClosed);\n        exports.on(\"restoreProject\", restoreBtnClicked);\n        sessionRestoreDir = restoreDir;\n        createDir(sessionRestoreDir);\n        setInterval(changeScanner, scanIntervalMs);\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        if(currentProjectRoot) {\n            // At boot, the startup project may be opened and we may never get the projectOpened event triggered\n            // for the startup project. So we call manually.\n            projectOpened(null, currentProjectRoot);\n        }\n    }\n\n    function init() {\n        if(!window.testEnvironment){\n            initWith(BACKUP_INTERVAL_MS, sessionRestoreDir);\n        } else {\n            // this is a test environment, expose functions to test\n            exports.getProjectRestoreRoot = getProjectRestoreRoot;\n            exports.initWith = initWith;\n            window._FileRecoveryExtensionForTests = exports;\n        }\n    }\n\n    exports.init = init;\n});\n"],"file":"FileRecovery.js"}
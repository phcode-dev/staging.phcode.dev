{"version":3,"sources":["extensions/default/NavigationAndHistory/integ-tests.js"],"names":["define","require","exports","module","SpecRunnerUtils","brackets","getModule","describe","testPathOriginal","getTestPath","testPath","getTestRoot","tempRestorePath","FileViewController","ProjectManager","CommandManager","Commands","testWindow","EditorManager","MainViewManager","FileSystem","$","async","deletePath","pathToDel","startsWith","promise","awaitsForDone","loadTestWindow","createTestWindowAndRun","test","copyPath","loadProjectInTestWindow","closeSession","execute","FILE_CLOSE_ALL","_forceClose","openFile","relativePath","openAndSelectDocument","PROJECT_MANAGER","isFileOpen","fullPath","allOpenFiles","getAllOpenFiles","file","initFileRestorer","fileToOpen","scanInterval","waitTillPathNotExists","expect","toBeTrue","_FileRecoveryExtensionForTests","exists","pathExists","toBeFalse","initWith","getDirectoryForPath","waitTillPathExists","beforeAll","afterAll","closeTestWindow","beforeEach","it","projectRestorePath","getProjectRestoreRoot","editor","getActiveEditor","document","setText","FILE_SAVE_ALL","unsavedText","Math","random","awaitsFor","length","click","getText"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global describe, it, expect, beforeAll, afterAll, awaitsForDone, beforeEach, awaits, awaitsFor */\n\ndefine(function (require, exports, module) {\n    // Recommended to avoid reloading the integration test window Phoenix instance for each test.\n\n    const SpecRunnerUtils     = brackets.getModule(\"spec/SpecRunnerUtils\");\n\n    describe(\"integration:FileRecovery integration tests\", function () {\n\n        const testPathOriginal = SpecRunnerUtils.getTestPath(\"/spec/ProjectManager-test-files\");\n        const testPath = SpecRunnerUtils.getTestRoot() + \"/navigationTests/\";\n        const tempRestorePath = SpecRunnerUtils.getTestRoot() + \"/navigationTestsRestore/\";\n\n        let FileViewController,     // loaded from brackets.test\n            ProjectManager,         // loaded from brackets.test;\n            CommandManager,\n            Commands,\n            testWindow,\n            EditorManager,\n            MainViewManager,\n            brackets,\n            FileSystem,\n            $;\n\n\n        async function deletePath(pathToDel) {\n            if(!pathToDel.startsWith(\"/\")) {\n                pathToDel = testPath + pathToDel;\n            }\n            let promise = SpecRunnerUtils.deletePath(pathToDel, true);\n            await awaitsForDone(promise, \"Remove \" + pathToDel, 5000);\n        }\n\n        async function loadTestWindow() {\n            testWindow = await SpecRunnerUtils.createTestWindowAndRun();\n            brackets            = testWindow.brackets;\n            $                   = testWindow.$;\n            FileViewController  = brackets.test.FileViewController;\n            ProjectManager      = brackets.test.ProjectManager;\n            CommandManager      = brackets.test.CommandManager;\n            Commands            = brackets.test.Commands;\n            EditorManager       = brackets.test.EditorManager;\n            MainViewManager     = brackets.test.MainViewManager;\n            FileSystem          = brackets.test.FileSystem;\n            await awaitsForDone(SpecRunnerUtils.copyPath(testPathOriginal, testPath), \"copy temp files\");\n            await SpecRunnerUtils.loadProjectInTestWindow(testPath);\n        }\n\n        beforeAll(async function () {\n            await loadTestWindow();\n        }, 30000);\n\n        afterAll(async function () {\n            FileViewController  = null;\n            ProjectManager      = null;\n            testWindow = null;\n            brackets = null;\n            await deletePath(testPath);\n            await deletePath(tempRestorePath);\n            await SpecRunnerUtils.closeTestWindow();\n        });\n\n        beforeEach(async function () {\n            await deletePath(testPath);\n            await deletePath(tempRestorePath);\n            await awaitsForDone(SpecRunnerUtils.copyPath(testPathOriginal, testPath), \"copy temp files\");\n        });\n\n        async function closeSession() {\n            await awaitsForDone(CommandManager.execute(Commands.FILE_CLOSE_ALL, { _forceClose: true }),\n                \"closing all file\");\n        }\n\n        async function openFile(relativePath) {\n            await awaitsForDone(\n                FileViewController.openAndSelectDocument(\n                    testPath + relativePath,\n                    FileViewController.PROJECT_MANAGER\n                ));\n        }\n\n        function isFileOpen(relativePath) {\n            const fullPath = testPath + relativePath;\n            let allOpenFiles = MainViewManager.getAllOpenFiles();\n            for(let file of allOpenFiles){\n                if(file.fullPath === fullPath){\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        async function initFileRestorer(fileToOpen, scanInterval = 100) {\n            await deletePath(tempRestorePath);\n            await SpecRunnerUtils.waitTillPathNotExists(tempRestorePath);\n            await openFile(fileToOpen);\n            expect(isFileOpen(fileToOpen)).toBeTrue();\n            expect(testWindow._FileRecoveryExtensionForTests).exists;\n            expect(await SpecRunnerUtils.pathExists(tempRestorePath, true)).toBeFalse();\n            testWindow._FileRecoveryExtensionForTests.initWith(scanInterval,\n                FileSystem.getDirectoryForPath(tempRestorePath));\n            await SpecRunnerUtils.waitTillPathExists(tempRestorePath);\n\n        }\n\n        it(\"Should create restore folders and backup files\", async function () {\n            await initFileRestorer(\"file.js\");\n            let projectRestorePath = testWindow._FileRecoveryExtensionForTests.getProjectRestoreRoot(testPath);\n\n            // now edit a file so that its backup is created\n            let editor = EditorManager.getActiveEditor();\n            editor.document.setText(\"hello\");\n            await SpecRunnerUtils.waitTillPathExists(projectRestorePath.fullPath, true);\n            await SpecRunnerUtils.waitTillPathExists(projectRestorePath.fullPath + \"file.js\", false);\n            await closeSession();\n        });\n\n        it(\"Should saving files remove file restore folder\", async function () {\n            await initFileRestorer(\"toDelete1/file.js\");\n            let projectRestorePath = testWindow._FileRecoveryExtensionForTests.getProjectRestoreRoot(testPath);\n\n            // now edit a file so that its backup is created\n            let editor = EditorManager.getActiveEditor();\n            editor.document.setText(\"hello\");\n            await SpecRunnerUtils.waitTillPathExists(projectRestorePath.fullPath + \"toDelete1/file.js\", false);\n            await awaitsForDone(CommandManager.execute(Commands.FILE_SAVE_ALL), \"saving all file\");\n            await SpecRunnerUtils.waitTillPathNotExists(projectRestorePath.fullPath + \"toDelete1/file.js\", false);\n            await closeSession();\n        });\n\n        it(\"Should show restore notification and restore if there is anything to restore\", async function () {\n            await initFileRestorer(\"toDelete1/file.js\");\n            let projectRestorePath = testWindow._FileRecoveryExtensionForTests.getProjectRestoreRoot(testPath);\n\n            // now edit a file so that its backup is created\n            const unsavedText = \"hello\" + Math.random();\n            let editor = EditorManager.getActiveEditor();\n            editor.document.setText(unsavedText);\n            await SpecRunnerUtils.waitTillPathExists(projectRestorePath.fullPath + \"toDelete1/file.js\", false);\n\n            // backup is now present, reload the project\n            await SpecRunnerUtils.closeTestWindow();\n            await loadTestWindow();\n            testWindow._FileRecoveryExtensionForTests.initWith(100,\n                FileSystem.getDirectoryForPath(tempRestorePath));\n            await awaitsFor(()=>{\n                return $(\".file-recovery-button\").length === 1;\n            }, \"waiting for restore notification\", 5000);\n\n            // now press the recover button to start the recovery\n            $(\".file-recovery-button\").click();\n            // check if the file is recovered\n            await awaitsFor(()=>{\n                editor = EditorManager.getActiveEditor();\n                return editor && editor.document.getText() === unsavedText;\n            }, \"waiting for restore notification\", 5000);\n            await closeSession();\n        }, 10000);\n\n        // below project switch test case is flakey. need to fix. disable for now.\n        // it(\"Should show restore on project switch\", async function () {\n        //     const readOnlyProject = SpecRunnerUtils.getTestPath(\"/spec/ProjectManager-test-files\");\n        //     await initFileRestorer(\"toDelete1/file.js\", 1000);\n        //     let projectRestorePath = testWindow._FileRecoveryExtensionForTests.getProjectRestoreRoot(testPath);\n        //\n        //     // now edit a file so that its backup is created\n        //     const unsavedText = \"hello\" + Math.random();\n        //     let editor = EditorManager.getActiveEditor();\n        //     editor.document.setText(unsavedText);\n        //     await SpecRunnerUtils.waitTillPathExists(projectRestorePath.fullPath + \"toDelete1/file.js\", false);\n        //\n        //     // backup is now present, switch to another project\n        //     let loadPromise = SpecRunnerUtils.loadProjectInTestWindow(readOnlyProject);\n        //     await awaitsFor(()=>{\n        //         return $('button[data-button-id=dontsave]').length >= 1;\n        //     }, \"waiting for save changes dialogue\", 5000);\n        //     $('button[data-button-id=dontsave]')[0].click();\n        //     await loadPromise;\n        //     await SpecRunnerUtils.loadProjectInTestWindow(testPath);\n        //     await awaits(3000);\n        //     await awaitsFor(()=>{\n        //         return $(\".file-recovery-button\").length === 1;\n        //     }, \"waiting for restore notification\", 5000);\n        //\n        //     // now press the recover button to start the recovery\n        //     $(\".file-recovery-button\").click();\n        //     // check if the file is recovered\n        //     await awaitsFor(()=>{\n        //         editor = EditorManager.getActiveEditor();\n        //         return editor && editor.document.getText() === unsavedText;\n        //     }, \"waiting for restore notification\", 5000);\n        //     await closeSession();\n        // }, 1000000);\n    });\n});\n"],"file":"integ-tests.js"}
{"version":3,"sources":["extensions/default/JavaScriptCodeHints/main.js"],"names":["define","require","exports","module","_","brackets","getModule","CodeHintManager","EditorManager","Commands","CommandManager","LanguageManager","AppInit","ExtensionUtils","StringMatch","ProjectManager","PreferencesManager","Strings","JSParameterHintsProvider","ParameterHintsManager","HintUtils","ScopeManager","Session","JumpToDefManager","Acorn","session","cachedCursor","cachedHints","cachedType","cachedToken","matcher","jsHintsEnabled","hintDetailsEnabled","noHintsOnDot","ignoreChange","_inlineScriptLanguages","phProvider","_areHintsEnabled","get","setConfig","configUpdate","config","Object","keys","forEach","key","_setConfig","getSession","getHintResponse","hints","query","type","trimmedQuery","formattedHints","formatTypeDataForToken","$hintObj","token","addClass","_appendLink","url","$","appendTo","attr","on","event","stopImmediatePropagation","stopPropagation","trim","length","split","join","toString","keyword","doc","text","formatHints","map","property","builtin","undefined","depth","guess","literal","stringRanges","item","matched","append","escape","value","data","debug","console","pluck","SINGLE_QUOTE","DOUBLE_QUOTE","match","selectInitial","handleWideResults","JSHints","setCachedHintContext","cursor","resetCachedHintContext","isInlineScriptSupported","document","language","getLanguageForPath","file","fullPath","getId","indexOf","isInlineScript","editor","getModeForSelection","getStringMatcher","StringMatcher","preferPrefixMatches","hintsArePending","deferredHints","hasOwnProperty","state","getSessionHints","$deferredHints","hintResults","getHints","needGuesses","guessesResponse","requestGuesses","Deferred","done","hintResponse","resolveWith","fail","reject","definePreference","description","DESCRIPTION_DETECTED_EXCLUSIONS","DESCRIPTION_INFERENCE_TIMEOUT","DESCRIPTION_NO_HINTS_ON_DOT","DESCRIPTION_JS_HINTS","DESCRIPTION_JS_HINTS_TYPE_DETAILS","prototype","needNewHints","getCursor","getType","line","context","showFunctionType","functionCallPos","ch","shouldCloseHints","getToken","lastToken","getNextTokenOnLine","string","hasHints","hintableKey","hintable","isFunctionName","this","getQuery","isOpen","handleFileChange","from","to","scopeResponse","requestHints","scopeSession","insertHint","hint","completion","start","end","invalidPropertyName","tokenizer","currentToken","tokTypes","name","eof","dotCursor","findPreviousDot","_codeMirror","replaceRange","appReady","initializeSession","previousEditor","handleEditorChange","setSession","installEditorListeners","isSupportedLanguage","eventName","changeList","uninstallEditorListeners","off","handleActiveEditorChange","current","previous","setJumpPosition","curPos","getCurrentFullEditor","setCursorPos","JSJumpToDefProvider","quickEditHelper","offset","response","requestJumptoDef","canJumpToDef","implicitChar","doJumpToDef","handleJumpResponse","result","requestJumpToDef","promise","setJumpSelection","setSelection","resolve","jumpResp","resultFile","resolvedPath","getResolvedPath","execute","FILE_OPEN","_jsCodeHintsHelper","_configureJSCodeHints","loadStyleSheet","handleProjectClose","handleProjectOpen","getActiveEditor","registerHintProvider","jdProvider","registerJumpToDefProvider","jsHints","SUPPORTED_LANGUAGES","jsHintProvider","_phProvider","window","handleJumpToDefinition","bind"],"mappings":"AAuBAA,OAAO,SAAUC,QAASC,QAASC,QAE/B,IAAIC,EAAIC,SAASC,UAAU,qBAEvBC,gBAA4BF,SAASC,UAAU,0BAC/CE,cAA4BH,SAASC,UAAU,wBAC/CG,SAA4BJ,SAASC,UAAU,oBAC/CI,eAA4BL,SAASC,UAAU,0BAC/CK,gBAA4BN,SAASC,UAAU,4BAC/CM,QAA4BP,SAASC,UAAU,iBAC/CO,eAA4BR,SAASC,UAAU,wBAC/CQ,YAA4BT,SAASC,UAAU,qBAC/CS,eAA4BV,SAASC,UAAU,0BAC/CU,mBAA4BX,SAASC,UAAU,kCAC/CW,QAA4BZ,SAASC,UAAU,WAC/CY,yBAA4BjB,QAAQ,4BAA4BiB,yBAChEC,sBAA4Bd,SAASC,UAAU,kCAC/Cc,UAA4Bf,SAASC,UAAU,qBAC/Ce,aAA4BhB,SAASC,UAAU,wBAC/CgB,QAA4BjB,SAASC,UAAU,mBAC/CiB,iBAA4BlB,SAASC,UAAU,6BAC/CkB,MAA4BnB,SAASC,UAAU,+BAE/CmB,QAAqB,KACrBC,aAAqB,KACrBC,YAAqB,KACrBC,WAAqB,KACrBC,YAAqB,KACrBC,QAAqB,KACrBC,gBAAqB,EACrBC,oBAAqB,EACrBC,cAAqB,EACrBC,aAGAC,uBAAyB,CAAC,OAAQ,OAClCC,WAAa,IAAIlB,yBA+BrB,SAASmB,mBACL,OAAuD,IAA/CrB,mBAAmBsB,IAAI,sBACkB,IAA5CtB,mBAAmBsB,IAAI,iBA6BhC,SAASC,UAAUC,cACf,IAAIC,OAASF,UAAUE,OACvBC,OAAOC,KAAKH,cAAcI,QAAQ,SAAUC,KACxCJ,OAAOI,KAAOL,aAAaK,OAG/BxB,aAAayB,WAAWN,cAU5B,SAASO,aACL,OAAOtB,QAaX,SAASuB,gBAAgBC,MAAOC,MAAOC,MAEnC,IAAIC,aACAC,eAMJ,SAASC,uBAAuBC,SAAUC,OAEjCxB,qBAILuB,SAASE,SAAS,uCAEjB,SAASC,cACFF,MAAMG,KACNC,EAAE,WAAWC,SAASN,UAAUE,SAAS,eAAeK,KAAK,OAAQN,MAAMG,KAAKI,GAAG,QAAS,SAAUC,OAClGA,MAAMC,2BACND,MAAME,oBAJlB,GASIV,MAAML,KACoB,MAAtBK,MAAML,KAAKgB,SACPX,MAAML,KAAKiB,OAAS,IACpBR,EAAE,SAAWJ,MAAML,KAAKkB,MAAM,MAAMC,KAAK,KAAKC,WAAWJ,OAAS,WAAWN,SAASN,UAAUE,SAAS,kCAE7GG,EAAE,SAAWJ,MAAML,KAAKkB,MAAM,MAAMC,KAAK,KAAKC,WAAWJ,OAAS,WAAWN,SAASN,UAAUE,SAAS,uBAGzGD,MAAMgB,SACNZ,EAAE,wBAAwBC,SAASN,UAAUE,SAAS,6BAI1DD,MAAMiB,MACNlB,SAASO,KAAK,QAASN,MAAMiB,KAC7Bb,EAAE,iBAAiBc,KAAKlB,MAAMiB,IAAIN,QAAQN,SAASN,UAAUE,SAAS,kBAkB9E,SAASkB,YAAY1B,MAAOC,OACxB,OAAOD,MAAM2B,IAAI,SAAUpB,OACvB,IAAID,SAAcK,EAAE,UAAUH,SAAS,qBAGvC,IAAKN,KAAK0B,WAAarB,MAAMsB,cAA2BC,IAAhBvB,MAAMwB,MAC1C,OAAQxB,MAAMwB,OACd,KAAK,EACDzB,SAASE,SAAS,iBAClB,MACJ,KAAK,EACDF,SAASE,SAAS,mBAClB,MACJ,KAAK,EACDF,SAASE,SAAS,gBAClB,MACJ,QACIF,SAASE,SAAS,mBAqC1B,OAhCID,MAAMyB,OACN1B,SAASE,SAAS,cAIlBD,MAAMgB,SACNjB,SAASE,SAAS,gBAGlBD,MAAM0B,SACN3B,SAASE,SAAS,gBAIlBD,MAAM2B,aACN3B,MAAM2B,aAAavC,QAAQ,SAAUwC,MAC7BA,KAAKC,QACL9B,SAAS+B,OAAO1B,EAAE,UACb0B,OAAOlF,EAAEmF,OAAOH,KAAKV,OACrBjB,SAAS,iBAEdF,SAAS+B,OAAOlF,EAAEmF,OAAOH,KAAKV,SAItCnB,SAASmB,KAAKlB,MAAMgC,OAGxBjC,SAASkC,KAAK,QAASjC,OAEvBF,uBAAuBC,SAAUC,OAE1BD,WAaf,OAzHIhB,UAAUE,OAAOiD,OACjBC,QAAQD,MAAM,QAAStF,EAAEwF,MAAM3C,MAAO,UAgH1CG,aAAehD,EAAE+D,KAAKjB,MAAO9B,UAAUyE,aAAezE,UAAU0E,cAQzD,CACH7C,MANAI,eADAJ,MACiB0B,YAAY1B,MAAOG,cAEnB,GAKjB2C,MAAO,KACPC,eAAe,EACfC,kBAAmBhD,MAAMgD,mBAOjC,SAASC,WAmCT,SAASC,qBAAqBlD,MAAOmD,OAAQjD,KAAMK,OAC/C7B,YAAcsB,MACdvB,aAAe0E,OACfxE,WAAauB,KACbtB,YAAc2B,MAMlB,SAAS6C,yBACL1E,YAAc,KACdD,aAAe,KACfE,WAAa,KACbC,YAAe,KAiDnB,SAASyE,wBAAwBC,UAC7B,IAAIC,SAAW7F,gBAAgB8F,mBAAmBF,SAASG,KAAKC,UAAUC,QAC1E,OAAqD,IAA9CzE,uBAAuB0E,QAAQL,UAG1C,SAASM,eAAeC,QACpB,MAAwC,eAAjCA,OAAOC,sBAQlB,SAASC,mBAOL,OANKnF,UACDA,QAAU,IAAIhB,YAAYoG,cAAc,CACpCC,qBAAqB,KAItBrF,QASX,SAASsF,gBAAgBC,eACrB,OAAQA,gBAAkBA,cAAcC,eAAe,UACzB,YAA1BD,cAAcE,QAsBtB,SAASC,gBAAgBtE,MAAOkD,OAAQjD,KAAMK,MAAOiE,gBAEjD,IAAIC,YAAcjG,QAAQkG,SAASzE,MAAO+D,oBAC1C,GAAIS,YAAYE,YAAa,CACzB,IAAIC,gBAAkBxG,aAAayG,eAAerG,QAC9CA,QAAQsF,OAAOR,UAmBnB,OAjBKkB,iBACDA,eAAiB7D,EAAEmE,YAGvBF,gBAAgBG,KAAK,WACjB,GAAIZ,gBAAgBK,gBAAiB,CAEjCtB,sBADAuB,YAAcjG,QAAQkG,SAASzE,MAAO+D,qBACLhE,MAAOmD,OAAQjD,KAAMK,OACtD,IAAIyE,aAAejF,gBAAgBrB,YAAauB,MAAOC,MACvDsE,eAAeS,YAAY,KAAM,CAACD,kBAEvCE,KAAK,WACAf,gBAAgBK,iBAChBA,eAAeW,WAIhBX,eACJ,GAAIL,gBAAgBK,gBAAiB,CACxCtB,qBAAqBuB,YAAYzE,MAAOmD,OAAQjD,KAAMK,OACtD,IAAIyE,aAAkBjF,gBAAgBrB,YAAauB,MAAOC,MAE1D,OADAsE,eAAeS,YAAY,KAAM,CAACD,eAC3B,KAGP,OADA9B,qBAAqBuB,YAAYzE,MAAOmD,OAAQjD,KAAMK,OAC/CR,gBAAgBrB,YAAauB,MAAOC,MA1ZnDnC,mBAAmBqH,iBAAiB,iCAAkC,QAAS,GAAI,CAC/EC,YAAarH,QAAQsH,kCAIzBvH,mBAAmBqH,iBAAiB,+BAAgC,SAAU,IAAO,CACjFC,YAAarH,QAAQuH,gCAIzBxH,mBAAmBqH,iBAAiB,2BAA4B,WAAW,EAAO,CAC9EC,YAAarH,QAAQwH,8BAIzBzH,mBAAmBqH,iBAAiB,mBAAoB,WAAW,EAAM,CACrEC,YAAarH,QAAQyH,uBAIzB1H,mBAAmBqH,iBAAiB,0BAA2B,WAAW,EAAM,CAC5EC,YAAarH,QAAQ0H,oCAYzB3H,mBAAmB+C,GAAG,SAAU,mBAAoB,WAChDhC,eAAiBM,qBAGrBrB,mBAAmB+C,GAAG,SAAU,gBAAiB,WAC7ChC,eAAiBM,qBAGrBrB,mBAAmB+C,GAAG,SAAU,2BAA4B,WACxD9B,eAAiBjB,mBAAmBsB,IAAI,8BAG5CtB,mBAAmB+C,GAAG,SAAU,0BAA2B,WACvD/B,mBAAqBhB,mBAAmBsB,IAAI,6BAsBhDC,UAAUE,OAAS,GAuKnByD,QAAQ0C,UAAUC,aAAe,SAAUpH,SACvC,IAAI2E,OAAU3E,QAAQqH,YAClB3F,KAAU1B,QAAQsH,UAEtB,OAAQpH,cAAgBD,eAAiBE,YACrCF,aAAasH,OAAS5C,OAAO4C,MAC7B7F,KAAK0B,WAAajD,WAAWiD,UAC7B1B,KAAK8F,UAAYrH,WAAWqH,SAC5B9F,KAAK+F,mBAAqBtH,WAAWsH,kBACpC/F,KAAKgG,iBAAmBvH,WAAWuH,iBACpChG,KAAKgG,gBAAgBC,KAAOxH,WAAWuH,gBAAgBC,IAuC/DlD,QAAQ0C,UAAUS,iBAAmB,SAAU5H,SAG3C,IAAI2E,OAAS3E,QAAQqH,YACjBtF,MAAQ/B,QAAQ6H,SAASlD,QACzBmD,UAAY1H,YAGhB,OAAKH,cAAgB0E,OAAO4C,OAAStH,aAAasH,OAI/B,OAAfxF,MAAML,OACNK,MAAQ/B,QAAQ+H,mBAAmBpD,SAGnCmD,WAAgC,OAAnBA,UAAUpG,OACvBoG,UAAY9H,QAAQ+H,mBAAmB9H,gBAKtC6H,YAAc/F,OACXA,MAAML,OAASoG,UAAUpG,OAO7BK,MAAMiG,OAAOrF,QAAUmF,UAAUE,OAAOrF,OACU,IAA3CZ,MAAMiG,OAAO5C,QAAQ0C,UAAUE,QAEY,IAA3CF,UAAUE,OAAO5C,QAAQrD,MAAMiG,WAwG9CvD,QAAQ0C,UAAUc,SAAW,SAAU3C,OAAQlE,KAC3C,GAAIpB,SAAWL,UAAUuI,YAAY9G,KAAMZ,cAAe,CAEtD,GAAIqE,wBAAwB7E,QAAQsF,OAAOR,YAClCO,eAAerF,QAAQsF,QACxB,OAAO,EAGf,IAAIX,OAAU3E,QAAQqH,YAClBtF,MAAU/B,QAAQ6H,SAASlD,QAG/B,GAAI5C,OAASpC,UAAUwI,SAASpG,OAC5B,OAAI/B,QAAQoI,mBAIRC,KAAKjB,aAAapH,WAClB4E,yBACAvE,QAAU,OAEP,GAGf,OAAO,GAWXoE,QAAQ0C,UAAUjB,SAAW,SAAU9E,KACnC,IAAIuD,OAAS3E,QAAQqH,YACjBtF,MAAQ/B,QAAQ6H,SAASlD,QAE7B,GAAI5C,OAASpC,UAAUuI,YAAY9G,KAAMZ,eAAiBb,UAAUwI,SAASpG,OAAQ,CACjF,IAAIL,KAAU1B,QAAQsH,UAClB7F,MAAUzB,QAAQsI,WAItB,GAAIxJ,gBAAgByJ,UAAYF,KAAKT,iBAAiB5H,SAClD,OAAO,KAKX,GAAIqI,KAAKjB,aAAapH,SAAU,CACxBoB,MACAxB,aAAa4I,iBAAiB,CAAC,CAACC,KAAM9D,OAAQ+D,GAAI/D,OAAQ1B,KAAM,CAAC7B,QACjEX,cAAe,GAGnB,IAAIkI,cAAkB/I,aAAagJ,aAAa5I,QAASA,QAAQsF,OAAOR,UACpEkB,eAAkB7D,EAAEmE,WACpBuC,aAAkB7I,QAmBtB,OAjBA2I,cAAcpC,KAAK,WACXZ,gBAAgBK,kBAEZ6C,eAAiB7I,QACjB+F,gBAAgBtE,MAAOkD,OAAQjD,KAAMK,MAAOiE,gBAE5CA,eAAeW,UAGvBkC,aAAe,OAChBnC,KAAK,WACAf,gBAAgBK,iBAChBA,eAAeW,SAEnBkC,aAAe,OAGZ7C,eAGX,GAAI9F,YACA,OAAO6F,gBAAgBtE,MAAOkD,OAAQjD,KAAMK,OAIpD,OAAO,MAUX0C,QAAQ0C,UAAU2B,WAAa,SAAUhH,UACrC,IAAIiH,KACAC,WADclH,SAASkC,KAAK,SACTD,MACnBY,OAAc3E,QAAQqH,YACtB5F,MAAczB,QAAQsI,WACtBW,MAAc,CAAC1B,KAAM5C,OAAO4C,KAAMI,GAAIhD,OAAOgD,GAAKlG,MAAMkB,QACxDuG,IAAc,CAAC3B,KAAM5C,OAAO4C,KAAMI,GAAIhD,OAAOgD,IAC7CwB,qBAAsB,EAE1B,GAAInJ,QAAQsH,UAAUlE,SAAU,CAM5B,IAAIgG,UAAYrJ,MAAMqJ,UAAUJ,YAC5BK,aAAeD,UAAUvB,WAc7B,GAXIwB,aAAa3H,OAAS3B,MAAMuJ,SAASC,MAASF,aAAa3H,KAAKqB,SAKhEsG,aAAeD,UAAUvB,YACRnG,OAAS3B,MAAMuJ,SAASE,MACrCL,qBAAsB,GAN1BA,qBAAsB,EAUtBA,oBAAqB,CAGrB,IAAIM,UAAYzJ,QAAQ0J,kBACpBD,YACAT,WAAa,KAAQA,WAAa,KAClCC,MAAM1B,KAAOkC,UAAUlC,KACvB0B,MAAMtB,GAAK8B,UAAU9B,GAAK,IAatC,OAHA3H,QAAQsF,OAAOqE,YAAYC,aAAaZ,WAAYC,MAAOC,MAGpD,GAIX/J,QAAQ0K,SAAS,WASb,SAASC,kBAAkBxE,OAAQyE,gBAC/B/J,QAAU,IAAIH,QAAQyF,QACtB1F,aAAaoK,mBAAmBhK,QAASsF,OAAOR,SAC5CiF,eAAiBA,eAAejF,SAAW,MAC/CnE,WAAWsJ,WAAWjK,SACtBE,YAAc,KAUlB,SAASgK,uBAAuB5E,OAAQyE,gBAEpCnF,yBAEKtE,iBAIDgF,QAAU3F,UAAUwK,oBAAoBjL,gBAAgB8F,mBAAmBM,OAAOR,SAASG,KAAKC,UAAUC,UAC1G2E,kBAAkBxE,OAAQyE,gBAC1BzE,OACKhD,GAAG3C,UAAUyK,UAAU,UAAW,SAAU7H,MAAO+C,OAAQ+E,YACnD5J,cACDb,aAAa4I,iBAAiB6B,YAElC5J,cAAe,KAGvBT,QAAU,MAUlB,SAASsK,yBAAyBhF,QAC1BA,QACAA,OAAOiF,IAAI5K,UAAUyK,UAAU,WAavC,SAASI,yBAAyBjI,MAAOkI,QAASC,UAE1CA,UACAA,SAAS5F,SACJyF,IAAI5K,UAAUyK,UAAU,oBAE7BK,SACAA,QAAQ3F,SACHxC,GAAG3C,UAAUyK,UAAU,mBAAoB,WAGxCE,yBAAyBG,SACzBP,uBAAuBO,WAInCH,yBAAyBI,UACzBR,uBAAuBO,QAASC,UAGpC,SAASC,gBAAgBC,QACrB7L,cAAc8L,uBAAuBC,aAAaF,OAAOrD,KAAMqD,OAAOjD,IAAI,GAG9E,SAASoD,uBA4FT,SAASC,kBACL,IAAIC,OAAajL,QAAQqH,YACrB6D,SAEJ,OAFiBtL,aAAauL,iBAAiBnL,QAASA,QAAQsF,OAAOR,SAAUmG,QA3FrFF,oBAAoB5D,UAAUiE,aAAe,SAAU9F,OAAQ+F,cAC3D,OAAO,GAMXN,oBAAoB5D,UAAUmE,YAAc,WACxC,IAAIC,mBAIJ,IAAKvL,SAAoD,eAAzCA,QAAQsF,OAAOC,sBAC3B,OAAO,KAGX,IAAIiG,OAAS,IAAIrJ,EAAEmE,SAOnB,SAASmF,iBAAiBzL,QAASiL,QAC/B,IAAIC,SAAWtL,aAAauL,iBAAiBnL,QAASA,QAAQsF,OAAOR,SAAUmG,QAE3EC,SAASrF,eAAe,YACxBqF,SAASQ,QAAQnF,KAAKgF,oBAAoB7E,KAAK,WAC3C8E,OAAO7E,WAsBnB,SAASgF,iBAAiB1C,MAAOC,KAC7BlJ,QAAQsF,OAAOsG,aAAa3C,MAAOC,KAAK,GACxCsC,OAAOK,SAAQ,GAQnBN,mBAAqB,SAAUO,UAE3B,GAAIA,SAASC,WACT,GAAID,SAASC,aAAeD,SAAS7G,KAAM,CACvC,IAAI+G,aAAepM,aAAaqM,gBAAgBH,SAASC,YACrDC,cACA/M,eAAeiN,QAAQlN,SAASmN,UAAW,CAACjH,SAAU8G,eACjDzF,KAAK,WACFoF,iBAAiBG,SAAS7C,MAAO6C,SAAS5C,YAItDyC,iBAAiBG,SAAS7C,MAAO6C,SAAS5C,UAG9CsC,OAAO7E,UAIf,IAAIsE,OAASjL,QAAQqH,YAIrB,OAFAoE,iBAAiBzL,QAASiL,QAEnBO,OAAOE,WAclB9M,SAASwN,mBAAqBpB,gBAG9BpM,SAASyN,sBAAwBvL,UAEjC1B,eAAekN,eAAe5N,OAAQ,gCAGtCK,cAAcuD,GAAG3C,UAAUyK,UAAU,sBAC7BI,0BAERlL,eAAegD,GAAG,qBAAsB,WACpC1C,aAAa2M,uBAGjBjN,eAAegD,GAAG,cAAe,WAC7B1C,aAAa4M,sBAIjBtC,uBAAuBnL,cAAc0N,mBAErC/M,sBAAsBgN,qBAAqB/L,WAAY,CAAC,cAAe,GAEvE,IAAIgM,WAAa,IAAI5B,oBACrBjL,iBAAiB8M,0BAA0BD,WAAY,CAAC,cAAe,GAEvE,IAAIE,QAAU,IAAIpI,QAClB3F,gBAAgB4N,qBAAqBG,QAASlN,UAAUmN,oBAAqB,GAG7ErO,QAAQ6C,WAAaA,WACrB7C,QAAQsO,eAAiBF,QACzBpO,QAAQuO,YAAcrM,WACtBsM,OAAOtM,WAAaA,WACpBlC,QAAQqL,kBAAoBA,kBAC5BrL,QAAQyO,uBAAyBP,WAAWrB,YAAY6B,KAAKR","sourcesContent":["/*\n * Copyright (c) 2013 - present Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\ndefine(function (require, exports, module) {\n\n    var _ = brackets.getModule(\"thirdparty/lodash\");\n\n    var CodeHintManager           = brackets.getModule(\"editor/CodeHintManager\"),\n        EditorManager             = brackets.getModule(\"editor/EditorManager\"),\n        Commands                  = brackets.getModule(\"command/Commands\"),\n        CommandManager            = brackets.getModule(\"command/CommandManager\"),\n        LanguageManager           = brackets.getModule(\"language/LanguageManager\"),\n        AppInit                   = brackets.getModule(\"utils/AppInit\"),\n        ExtensionUtils            = brackets.getModule(\"utils/ExtensionUtils\"),\n        StringMatch               = brackets.getModule(\"utils/StringMatch\"),\n        ProjectManager            = brackets.getModule(\"project/ProjectManager\"),\n        PreferencesManager        = brackets.getModule(\"preferences/PreferencesManager\"),\n        Strings                   = brackets.getModule(\"strings\"),\n        JSParameterHintsProvider  = require(\"./ParameterHintsProvider\").JSParameterHintsProvider,\n        ParameterHintsManager     = brackets.getModule(\"features/ParameterHintsManager\"),\n        HintUtils                 = brackets.getModule(\"JSUtils/HintUtils\"),\n        ScopeManager              = brackets.getModule(\"JSUtils/ScopeManager\"),\n        Session                   = brackets.getModule(\"JSUtils/Session\"),\n        JumpToDefManager          = brackets.getModule(\"features/JumpToDefManager\"),\n        Acorn                     = brackets.getModule(\"thirdparty/acorn/dist/acorn\");\n\n    var session            = null,  // object that encapsulates the current session state\n        cachedCursor       = null,  // last cursor of the current hinting session\n        cachedHints        = null,  // sorted hints for the current hinting session\n        cachedType         = null,  // describes the lookup type and the object context\n        cachedToken        = null,  // the token used in the current hinting session\n        matcher            = null,  // string matcher for hints\n        jsHintsEnabled     = true,  // preference setting to enable/disable the hint session\n        hintDetailsEnabled = true,  // preference setting to enable/disable hint type details\n        noHintsOnDot       = false, // preference setting to prevent hints on dot\n        ignoreChange;           // can ignore next \"change\" event if true;\n\n    // Languages that support inline JavaScript\n    var _inlineScriptLanguages = [\"html\", \"php\"],\n        phProvider = new JSParameterHintsProvider();\n\n    // Define the detectedExclusions which are files that have been detected to cause Tern to run out of control.\n    PreferencesManager.definePreference(\"jscodehints.detectedExclusions\", \"array\", [], {\n        description: Strings.DESCRIPTION_DETECTED_EXCLUSIONS\n    });\n\n    // This preference controls when Tern will time out when trying to understand files\n    PreferencesManager.definePreference(\"jscodehints.inferenceTimeout\", \"number\", 30000, {\n        description: Strings.DESCRIPTION_INFERENCE_TIMEOUT\n    });\n\n    // This preference controls whether to prevent hints from being displayed when dot is typed\n    PreferencesManager.definePreference(\"jscodehints.noHintsOnDot\", \"boolean\", false, {\n        description: Strings.DESCRIPTION_NO_HINTS_ON_DOT\n    });\n\n    // This preference controls whether to create a session and process all JS files or not.\n    PreferencesManager.definePreference(\"codehint.JSHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_JS_HINTS\n    });\n\n    // This preference controls whether detailed type metadata will be displayed within hint list. Defaults to true.\n    PreferencesManager.definePreference(\"jscodehints.typedetails\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_JS_HINTS_TYPE_DETAILS\n    });\n\n    /**\n     * Check whether any of code hints preferences for JS Code Hints is disabled\n     * @return {boolean} enabled/disabled\n     */\n    function _areHintsEnabled() {\n        return (PreferencesManager.get(\"codehint.JSHints\") !== false) &&\n            (PreferencesManager.get(\"showCodeHints\") !== false);\n    }\n\n    PreferencesManager.on(\"change\", \"codehint.JSHints\", function () {\n        jsHintsEnabled = _areHintsEnabled();\n    });\n\n    PreferencesManager.on(\"change\", \"showCodeHints\", function () {\n        jsHintsEnabled = _areHintsEnabled();\n    });\n\n    PreferencesManager.on(\"change\", \"jscodehints.noHintsOnDot\", function () {\n        noHintsOnDot = !!PreferencesManager.get(\"jscodehints.noHintsOnDot\");\n    });\n\n    PreferencesManager.on(\"change\", \"jscodehints.typedetails\", function () {\n        hintDetailsEnabled = PreferencesManager.get(\"jscodehints.typedetails\");\n    });\n\n    /**\n     * Sets the configuration, generally for testing/debugging use.\n     * Configuration keys are merged into the current configuration.\n     * The Tern worker is automatically updated to the new config as well.\n     *\n     * * debug: Set to true if you want verbose logging\n     * * noReset: Set to true if you don't want the worker to restart periodically\n     *\n     * @param {Object} configUpdate keys/values to merge into the config\n     */\n    function setConfig(configUpdate) {\n        var config = setConfig.config;\n        Object.keys(configUpdate).forEach(function (key) {\n            config[key] = configUpdate[key];\n        });\n\n        ScopeManager._setConfig(configUpdate);\n    }\n\n    setConfig.config = {};\n\n    /**\n     *  Get the value of current session.\n     *  Used for unit testing.\n     * @return {Session} - the current session.\n     */\n    function getSession() {\n        return session;\n    }\n\n    /**\n     * Creates a hint response object. Filters the hint list using the query\n     * string, formats the hints for display, and returns a hint response\n     * object according to the CodeHintManager's API for code hint providers.\n     *\n     * @param {Array.<Object>} hints - hints to be included in the response\n     * @param {string} query - querystring with which to filter the hint list\n     * @param {Object} type - the type of query, property vs. identifier\n     * @return {Object} - hint response as defined by the CodeHintManager API\n     */\n    function getHintResponse(hints, query, type) {\n\n        var trimmedQuery,\n            formattedHints;\n\n        if (setConfig.config.debug) {\n            console.debug(\"Hints\", _.pluck(hints, \"label\"));\n        }\n\n        function formatTypeDataForToken($hintObj, token) {\n\n            if (!hintDetailsEnabled) {\n                return;\n            }\n\n            $hintObj.addClass('brackets-js-hints-with-type-details');\n\n            (function _appendLink() {\n                if (token.url) {\n                    $('<a></a>').appendTo($hintObj).addClass(\"jshint-link\").attr('href', token.url).on(\"click\", function (event) {\n                        event.stopImmediatePropagation();\n                        event.stopPropagation();\n                    });\n                }\n            }());\n\n            if (token.type) {\n                if (token.type.trim() !== '?') {\n                    if (token.type.length < 30) {\n                        $('<span>' + token.type.split('->').join(':').toString().trim() + '</span>').appendTo($hintObj).addClass(\"brackets-js-hints-type-details\");\n                    }\n                    $('<span>' + token.type.split('->').join(':').toString().trim() + '</span>').appendTo($hintObj).addClass(\"jshint-description\");\n                }\n            } else {\n                if (token.keyword) {\n                    $('<span>keyword</span>').appendTo($hintObj).addClass(\"brackets-js-hints-keyword\");\n                }\n            }\n\n            if (token.doc) {\n                $hintObj.attr('title', token.doc);\n                $('<span></span>').text(token.doc.trim()).appendTo($hintObj).addClass(\"jshint-jsdoc\");\n            }\n        }\n\n\n        /*\n         * Returns a formatted list of hints with the query substring\n         * highlighted.\n         *\n         * @param {Array.<Object>} hints - the list of hints to format\n         * @param {string} query - querystring used for highlighting matched\n         *      poritions of each hint\n         * @return {jQuery.Deferred|{\n         *              hints: Array.<string|jQueryObject>,\n         *              match: string,\n         *              selectInitial: boolean,\n         *              handleWideResults: boolean}}\n         */\n        function formatHints(hints, query) {\n            return hints.map(function (token) {\n                var $hintObj    = $(\"<span>\").addClass(\"brackets-js-hints\");\n\n                // level indicates either variable scope or property confidence\n                if (!type.property && !token.builtin && token.depth !== undefined) {\n                    switch (token.depth) {\n                    case 0:\n                        $hintObj.addClass(\"priority-high\");\n                        break;\n                    case 1:\n                        $hintObj.addClass(\"priority-medium\");\n                        break;\n                    case 2:\n                        $hintObj.addClass(\"priority-low\");\n                        break;\n                    default:\n                        $hintObj.addClass(\"priority-lowest\");\n                        break;\n                    }\n                }\n\n                if (token.guess) {\n                    $hintObj.addClass(\"guess-hint\");\n                }\n\n                // is the token a keyword?\n                if (token.keyword) {\n                    $hintObj.addClass(\"keyword-hint\");\n                }\n\n                if (token.literal) {\n                    $hintObj.addClass(\"literal-hint\");\n                }\n\n                // highlight the matched portion of each hint\n                if (token.stringRanges) {\n                    token.stringRanges.forEach(function (item) {\n                        if (item.matched) {\n                            $hintObj.append($(\"<span>\")\n                                .append(_.escape(item.text))\n                                .addClass(\"matched-hint\"));\n                        } else {\n                            $hintObj.append(_.escape(item.text));\n                        }\n                    });\n                } else {\n                    $hintObj.text(token.value);\n                }\n\n                $hintObj.data(\"token\", token);\n\n                formatTypeDataForToken($hintObj, token);\n\n                return $hintObj;\n            });\n        }\n\n        // trim leading and trailing string literal delimiters from the query\n        trimmedQuery = _.trim(query, HintUtils.SINGLE_QUOTE + HintUtils.DOUBLE_QUOTE);\n\n        if (hints) {\n            formattedHints = formatHints(hints, trimmedQuery);\n        } else {\n            formattedHints = [];\n        }\n\n        return {\n            hints: formattedHints,\n            match: null, // the CodeHintManager should not format the results\n            selectInitial: true,\n            handleWideResults: hints.handleWideResults\n        };\n    }\n\n    /**\n     * @constructor\n     */\n    function JSHints() {\n    }\n\n    /**\n     * determine if the cached hint information should be invalidated and re-calculated\n     *\n     * @param {Session} session - the active hinting session\n     * @return {boolean} - true if the hints should be recalculated\n     */\n    JSHints.prototype.needNewHints = function (session) {\n        var cursor  = session.getCursor(),\n            type    = session.getType();\n\n        return !cachedHints || !cachedCursor || !cachedType ||\n            cachedCursor.line !== cursor.line ||\n            type.property !== cachedType.property ||\n            type.context !== cachedType.context ||\n            type.showFunctionType !== cachedType.showFunctionType ||\n            (type.functionCallPos && cachedType.functionCallPos &&\n            type.functionCallPos.ch !== cachedType.functionCallPos.ch);\n    };\n\n    /**\n     *  Cache the hints and the hint's context.\n     *\n     *  @param {Array.<string>} hints - array of hints\n     *  @param {{line:number, ch:number}} cursor - the location where the hints\n     *  were created.\n     * @param {{property: boolean,\n                showFunctionType:boolean,\n                context: string,\n                functionCallPos: {line:number, ch:number}}} type -\n     *  type information about the hints\n     *  @param {Object} token - CodeMirror token\n     */\n    function setCachedHintContext(hints, cursor, type, token) {\n        cachedHints = hints;\n        cachedCursor = cursor;\n        cachedType = type;\n        cachedToken = token;\n    }\n\n    /**\n     *  Reset cached hint context.\n     */\n    function resetCachedHintContext() {\n        cachedHints = null;\n        cachedCursor = null;\n        cachedType = null;\n        cachedToken =  null;\n    }\n\n    /**\n     *  Have conditions have changed enough to justify closing the hints popup?\n     *\n     * @param {Session} session - the active hinting session\n     * @return {boolean} - true if the hints popup should be closed.\n     */\n    JSHints.prototype.shouldCloseHints = function (session) {\n\n        // close if the token className has changed then close the hints.\n        var cursor = session.getCursor(),\n            token = session.getToken(cursor),\n            lastToken = cachedToken;\n\n        // if the line has changed, then close the hints\n        if (!cachedCursor || cursor.line !== cachedCursor.line) {\n            return true;\n        }\n\n        if (token.type === null) {\n            token = session.getNextTokenOnLine(cursor);\n        }\n\n        if (lastToken && lastToken.type === null) {\n            lastToken = session.getNextTokenOnLine(cachedCursor);\n        }\n\n        // Both of the tokens should never be null (happens when token is off\n        // the end of the line), so one is null then close the hints.\n        if (!lastToken || !token ||\n                token.type !== lastToken.type) {\n            return true;\n        }\n\n        // Test if one token string is a prefix of the other.\n        // If one is a prefix of the other then consider it the\n        // same token and don't close the hints.\n        if (token.string.length >= lastToken.string.length) {\n            return token.string.indexOf(lastToken.string) !== 0;\n        } else {\n            return lastToken.string.indexOf(token.string) !== 0;\n        }\n    };\n\n    /**\n     * @return {boolean} - true if the document supports inline JavaScript\n     */\n    function isInlineScriptSupported(document) {\n        var language = LanguageManager.getLanguageForPath(document.file.fullPath).getId();\n        return _inlineScriptLanguages.indexOf(language) !== -1;\n    }\n\n    function isInlineScript(editor) {\n        return editor.getModeForSelection() === \"javascript\";\n    }\n\n    /**\n     *  Create a new StringMatcher instance, if needed.\n     *\n     * @return {StringMatcher} - a StringMatcher instance.\n     */\n    function getStringMatcher() {\n        if (!matcher) {\n            matcher = new StringMatch.StringMatcher({\n                preferPrefixMatches: true\n            });\n        }\n\n        return matcher;\n    }\n\n    /**\n     *  Check if a hint response is pending.\n     *\n     * @param {jQuery.Deferred} deferredHints - deferred hint response\n     * @return {boolean} - true if deferred hints are pending, false otherwise.\n     */\n    function hintsArePending(deferredHints) {\n        return (deferredHints && !deferredHints.hasOwnProperty(\"hints\") &&\n            deferredHints.state() === \"pending\");\n    }\n\n    /**\n     *  Common code to get the session hints. Will get guesses if there were\n     *  no completions for the query.\n     *\n     * @param {string} query - user text to search hints with\n     *  @param {{line:number, ch:number}} cursor - the location where the hints\n     *  were created.\n     * @param {{property: boolean,\n                 showFunctionType:boolean,\n                 context: string,\n                 functionCallPos: {line:number, ch:number}}} type -\n     *  type information about the hints\n     *  @param {Object} token - CodeMirror token\n     * @param {jQuery.Deferred=} $deferredHints - existing Deferred we need to\n     * resolve (optional). If not supplied a new Deferred will be created if\n     * needed.\n     * @return {Object + jQuery.Deferred} - hint response (immediate or\n     *     deferred) as defined by the CodeHintManager API\n     */\n    function getSessionHints(query, cursor, type, token, $deferredHints) {\n\n        var hintResults = session.getHints(query, getStringMatcher());\n        if (hintResults.needGuesses) {\n            var guessesResponse = ScopeManager.requestGuesses(session,\n                session.editor.document);\n\n            if (!$deferredHints) {\n                $deferredHints = $.Deferred();\n            }\n\n            guessesResponse.done(function () {\n                if (hintsArePending($deferredHints)) {\n                    hintResults = session.getHints(query, getStringMatcher());\n                    setCachedHintContext(hintResults.hints, cursor, type, token);\n                    var hintResponse = getHintResponse(cachedHints, query, type);\n                    $deferredHints.resolveWith(null, [hintResponse]);\n                }\n            }).fail(function () {\n                if (hintsArePending($deferredHints)) {\n                    $deferredHints.reject();\n                }\n            });\n\n            return $deferredHints;\n        } else if (hintsArePending($deferredHints)) {\n            setCachedHintContext(hintResults.hints, cursor, type, token);\n            var hintResponse    = getHintResponse(cachedHints, query, type);\n            $deferredHints.resolveWith(null, [hintResponse]);\n            return null;\n        } else {\n            setCachedHintContext(hintResults.hints, cursor, type, token);\n            return getHintResponse(cachedHints, query, type);\n        }\n    }\n\n    /**\n     * Determine whether hints are available for a given editor context\n     *\n     * @param {Editor} editor - the current editor context\n     * @param {string} key - charCode of the last pressed key\n     * @return {boolean} - can the provider provide hints for this session?\n     */\n    JSHints.prototype.hasHints = function (editor, key) {\n        if (session && HintUtils.hintableKey(key, !noHintsOnDot)) {\n\n            if (isInlineScriptSupported(session.editor.document)) {\n                if (!isInlineScript(session.editor)) {\n                    return false;\n                }\n            }\n            var cursor  = session.getCursor(),\n                token   = session.getToken(cursor);\n\n            // don't autocomplete within strings or comments, etc.\n            if (token && HintUtils.hintable(token)) {\n                if (session.isFunctionName()) {\n                    return false;\n                }\n\n                if (this.needNewHints(session)) {\n                    resetCachedHintContext();\n                    matcher = null;\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n      * Return a list of hints, possibly deferred, for the current editor\n      * context\n      *\n      * @param {string} key - charCode of the last pressed key\n      * @return {Object + jQuery.Deferred} - hint response (immediate or\n      *     deferred) as defined by the CodeHintManager API\n      */\n    JSHints.prototype.getHints = function (key) {\n        var cursor = session.getCursor(),\n            token = session.getToken(cursor);\n\n        if (token && HintUtils.hintableKey(key, !noHintsOnDot) && HintUtils.hintable(token)) {\n            var type    = session.getType(),\n                query   = session.getQuery();\n\n            // If the hint context is changed and the hints are open, then\n            // close the hints by returning null;\n            if (CodeHintManager.isOpen() && this.shouldCloseHints(session)) {\n                return null;\n            }\n\n            // Compute fresh hints if none exist, or if the session\n            // type has changed since the last hint computation\n            if (this.needNewHints(session)) {\n                if (key) {\n                    ScopeManager.handleFileChange([{from: cursor, to: cursor, text: [key]}]);\n                    ignoreChange = true;\n                }\n\n                var scopeResponse   = ScopeManager.requestHints(session, session.editor.document),\n                    $deferredHints  = $.Deferred(),\n                    scopeSession    = session;\n\n                scopeResponse.done(function () {\n                    if (hintsArePending($deferredHints)) {\n                        // Verify we are still in same session\n                        if (scopeSession === session) {\n                            getSessionHints(query, cursor, type, token, $deferredHints);\n                        } else {\n                            $deferredHints.reject();\n                        }\n                    }\n                    scopeSession = null;\n                }).fail(function () {\n                    if (hintsArePending($deferredHints)) {\n                        $deferredHints.reject();\n                    }\n                    scopeSession = null;\n                });\n\n                return $deferredHints;\n            }\n\n            if (cachedHints) {\n                return getSessionHints(query, cursor, type, token);\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Inserts the hint selected by the user into the current editor.\n     *\n     * @param {jQuery.Object} $hintObj - hint object to insert into current editor\n     * @return {boolean} - should a new hinting session be requested\n     *      immediately after insertion?\n     */\n    JSHints.prototype.insertHint = function ($hintObj) {\n        var hint        = $hintObj.data(\"token\"),\n            completion  = hint.value,\n            cursor      = session.getCursor(),\n            query       = session.getQuery(),\n            start       = {line: cursor.line, ch: cursor.ch - query.length},\n            end         = {line: cursor.line, ch: cursor.ch},\n            invalidPropertyName = false;\n\n        if (session.getType().property) {\n            // if we're inserting a property name, we need to make sure the\n            // hint is a valid property name.\n            // to check this, run the hint through Acorns tokenizer\n            // it should result in one token, and that token should either be\n            // a 'name' or a 'keyword', as javascript allows keywords as property names\n            var tokenizer = Acorn.tokenizer(completion);\n            var currentToken = tokenizer.getToken();\n\n            // the name is invalid if the hint is not a 'name' or 'keyword' token\n            if (currentToken.type !== Acorn.tokTypes.name && !currentToken.type.keyword) {\n                invalidPropertyName = true;\n            } else {\n                // check for a second token - if there is one (other than 'eof')\n                // then the hint isn't a valid property name either\n                currentToken = tokenizer.getToken();\n                if (currentToken.type !== Acorn.tokTypes.eof) {\n                    invalidPropertyName = true;\n                }\n            }\n\n            if (invalidPropertyName) {\n                // need to walk back to the '.' and replace\n                // with '[\"<hint>\"]\n                var dotCursor = session.findPreviousDot();\n                if (dotCursor) {\n                    completion = \"[\\\"\" + completion + \"\\\"]\";\n                    start.line = dotCursor.line;\n                    start.ch = dotCursor.ch - 1;\n                }\n            }\n        }\n\n        // Replace the current token with the completion\n        // HACK (tracking adobe/brackets#1688): We talk to the private CodeMirror instance\n        // directly to replace the range instead of using the Document, as we should. The\n        // reason is due to a flaw in our current document synchronization architecture when\n        // inline editors are open.\n        session.editor._codeMirror.replaceRange(completion, start, end);\n\n        // Return false to indicate that another hinting session is not needed\n        return false;\n    };\n\n    // load the extension\n    AppInit.appReady(function () {\n\n        /*\n         * When the editor is changed, reset the hinting session and cached\n         * information, and reject any pending deferred requests.\n         *\n         * @param {!Editor} editor - editor context to be initialized.\n         * @param {?Editor} previousEditor - the previous editor.\n         */\n        function initializeSession(editor, previousEditor) {\n            session = new Session(editor);\n            ScopeManager.handleEditorChange(session, editor.document,\n                previousEditor ? previousEditor.document : null);\n            phProvider.setSession(session);\n            cachedHints = null;\n        }\n\n        /*\n         * Connects to the given editor, creating a new Session & adding listeners\n         *\n         * @param {?Editor} editor - editor context on which to listen for\n         *      changes. If null, 'session' is cleared.\n         * @param {?Editor} previousEditor - the previous editor\n         */\n        function installEditorListeners(editor, previousEditor) {\n            // always clean up cached scope and hint info\n            resetCachedHintContext();\n\n            if (!jsHintsEnabled) {\n                return;\n            }\n\n            if (editor && HintUtils.isSupportedLanguage(LanguageManager.getLanguageForPath(editor.document.file.fullPath).getId())) {\n                initializeSession(editor, previousEditor);\n                editor\n                    .on(HintUtils.eventName(\"change\"), function (event, editor, changeList) {\n                        if (!ignoreChange) {\n                            ScopeManager.handleFileChange(changeList);\n                        }\n                        ignoreChange = false;\n                    });\n            } else {\n                session = null;\n            }\n        }\n\n        /*\n         * Uninstall editor change listeners\n         *\n         * @param {Editor} editor - editor context on which to stop listening\n         *      for changes\n         */\n        function uninstallEditorListeners(editor) {\n            if (editor) {\n                editor.off(HintUtils.eventName(\"change\"));\n            }\n        }\n\n        /*\n         * Handle the activeEditorChange event fired by EditorManager.\n         * Uninstalls the change listener on the previous editor\n         * and installs a change listener on the new editor.\n         *\n         * @param {Event} event - editor change event (ignored)\n         * @param {Editor} current - the new current editor context\n         * @param {Editor} previous - the previous editor context\n         */\n        function handleActiveEditorChange(event, current, previous) {\n            // Uninstall \"languageChanged\" event listeners on previous editor's document & put them on current editor's doc\n            if (previous) {\n                previous.document\n                    .off(HintUtils.eventName(\"languageChanged\"));\n            }\n            if (current) {\n                current.document\n                    .on(HintUtils.eventName(\"languageChanged\"), function () {\n                        // If current doc's language changed, reset our state by treating it as if the user switched to a\n                        // different document altogether\n                        uninstallEditorListeners(current);\n                        installEditorListeners(current);\n                    });\n            }\n\n            uninstallEditorListeners(previous);\n            installEditorListeners(current, previous);\n        }\n\n        function setJumpPosition(curPos) {\n            EditorManager.getCurrentFullEditor().setCursorPos(curPos.line, curPos.ch, true);\n        }\n\n        function JSJumpToDefProvider() {\n        }\n\n        JSJumpToDefProvider.prototype.canJumpToDef = function (editor, implicitChar) {\n            return true;\n        };\n\n        /**\n         * Method to handle jump to definition feature.\n         */\n        JSJumpToDefProvider.prototype.doJumpToDef = function () {\n            var handleJumpResponse;\n\n\n            // Only provide jump-to-definition results when cursor is in JavaScript content\n            if (!session || session.editor.getModeForSelection() !== \"javascript\") {\n                return null;\n            }\n\n            var result = new $.Deferred();\n\n            /**\n             * Make a jump-to-def request based on the session and offset passed in.\n             * @param {Session} session - the session\n             * @param {number} offset - the offset of where to jump from\n             */\n            function requestJumpToDef(session, offset) {\n                var response = ScopeManager.requestJumptoDef(session, session.editor.document, offset);\n\n                if (response.hasOwnProperty(\"promise\")) {\n                    response.promise.done(handleJumpResponse).fail(function () {\n                        result.reject();\n                    });\n                }\n            }\n\n\n            /**\n             * Sets the selection to move the cursor to the result position.\n             * Assumes that the editor has already changed files, if necessary.\n             *\n             * Additionally, this will check to see if the selection looks like an\n             * assignment to a member expression - if it is, and the type is a function,\n             * then we will attempt to jump to the RHS of the expression.\n             *\n             * 'exports.foo = foo'\n             *\n             * if the selection is 'foo' in 'exports.foo', then we will attempt to jump to def\n             * on the rhs of the assignment.\n             *\n             * @param {number} start - the start of the selection\n             * @param {number} end - the end of the selection\n             */\n            function setJumpSelection(start, end) {\n                session.editor.setSelection(start, end, true);\n                result.resolve(true);\n            }\n\n            /**\n             * handle processing of the completed jump-to-def request.\n             * will open the appropriate file, and set the selection based\n             * on the response.\n             */\n            handleJumpResponse = function (jumpResp) {\n\n                if (jumpResp.resultFile) {\n                    if (jumpResp.resultFile !== jumpResp.file) {\n                        var resolvedPath = ScopeManager.getResolvedPath(jumpResp.resultFile);\n                        if (resolvedPath) {\n                            CommandManager.execute(Commands.FILE_OPEN, {fullPath: resolvedPath})\n                                .done(function () {\n                                    setJumpSelection(jumpResp.start, jumpResp.end);\n                                });\n                        }\n                    } else {\n                        setJumpSelection(jumpResp.start, jumpResp.end);\n                    }\n                } else {\n                    result.reject();\n                }\n            };\n\n            let offset = session.getCursor();\n            // request a jump-to-def\n            requestJumpToDef(session, offset);\n\n            return result.promise();\n        };\n\n        /*\n         * Helper for QuickEdit jump-to-definition request.\n         */\n        function quickEditHelper() {\n            var offset     = session.getCursor(),\n                response   = ScopeManager.requestJumptoDef(session, session.editor.document, offset);\n\n            return response;\n        }\n\n        // Register quickEditHelper.\n        brackets._jsCodeHintsHelper = quickEditHelper;\n\n        // Configuration function used for debugging\n        brackets._configureJSCodeHints = setConfig;\n\n        ExtensionUtils.loadStyleSheet(module, \"styles/brackets-js-hints.css\");\n\n        // uninstall/install change listener as the active editor changes\n        EditorManager.on(HintUtils.eventName(\"activeEditorChange\"),\n                handleActiveEditorChange);\n\n        ProjectManager.on(\"beforeProjectClose\", function () {\n            ScopeManager.handleProjectClose();\n        });\n\n        ProjectManager.on(\"projectOpen\", function () {\n            ScopeManager.handleProjectOpen();\n        });\n\n        // immediately install the current editor\n        installEditorListeners(EditorManager.getActiveEditor());\n\n        ParameterHintsManager.registerHintProvider(phProvider, [\"javascript\"], 0);\n        // init\n        var jdProvider = new JSJumpToDefProvider();\n        JumpToDefManager.registerJumpToDefProvider(jdProvider, [\"javascript\"], 0);\n\n        var jsHints = new JSHints();\n        CodeHintManager.registerHintProvider(jsHints, HintUtils.SUPPORTED_LANGUAGES, 0);\n\n        // for unit testing\n        exports.getSession = getSession;\n        exports.jsHintProvider = jsHints;\n        exports._phProvider = phProvider;\n        window.phProvider = phProvider;\n        exports.initializeSession = initializeSession;\n        exports.handleJumpToDefinition = jdProvider.doJumpToDef.bind(jdProvider);\n    });\n});\n"],"file":"main.js"}
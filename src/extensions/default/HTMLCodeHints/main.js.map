{"version":3,"sources":["extensions/default/HTMLCodeHints/main.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","CodeHintManager","HTMLUtils","PreferencesManager","Strings","HTMLTags","HTMLAttributes","tags","attributes","TagHints","this","exclusion","AttrHints","globalAttributes","readGlobalAttrHints","cachedHints","definePreference","description","DESCRIPTION_HTML_TAG_HINTS","DESCRIPTION_ATTR_HINTS","prototype","updateExclusion","textAfterCursor","tagInfo","tagName","substr","position","offset","hasValidExclusion","hasHints","editor","implicitChar","pos","getCursorPos","getTagInfo","tokenType","TAG_NAME","getHints","query","result","slice","hints","$","map","value","key","indexOf","sort","match","selectInitial","handleWideResults","insertHint","completion","start","line","ch","end","cursor","charCount","length","document","replaceRange","global","_getValueHintsForAttr","attrName","tagPlusAttr","attrInfo","type","attribOption","attrNameOnly","ATTR_NAME","attr","name","ATTR_VALUE","queryStr","Array","i","foundPrefix","tag","usedAttr","getTagAttributes","filter","unfiltered","concat","grep","inArray","console","assert","item","Object","hasOwnProperty","deferred","Deferred","done","asyncHints","resolveWith","insertedName","replaceExistingOne","valueAssigned","endQuote","shouldReplace","hasEndQuote","quoteChar","setCursorPos","appReady","JSON","parse","tagHints","attrHints","registerHintProvider","tagHintProvider","attrHintProvider"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Load dependent modules\n    var AppInit             = brackets.getModule(\"utils/AppInit\"),\n        CodeHintManager     = brackets.getModule(\"editor/CodeHintManager\"),\n        HTMLUtils           = brackets.getModule(\"language/HTMLUtils\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        Strings             = brackets.getModule(\"strings\"),\n        HTMLTags            = require(\"text!HtmlTags.json\"),\n        HTMLAttributes      = require(\"text!HtmlAttributes.json\"),\n        tags,\n        attributes;\n\n    PreferencesManager.definePreference(\"codehint.TagHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_HTML_TAG_HINTS\n    });\n\n    PreferencesManager.definePreference(\"codehint.AttrHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_ATTR_HINTS\n    });\n\n    /**\n     * @constructor\n     */\n    function TagHints() {\n        this.exclusion = null;\n    }\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     */\n    TagHints.prototype.updateExclusion = function () {\n        var textAfterCursor;\n        if (this.exclusion && this.tagInfo) {\n            textAfterCursor = this.tagInfo.tagName.substr(this.tagInfo.position.offset);\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    /**\n     * Determines whether HTML tag hints are available in the current editor\n     * context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non- null,\n     * whether it is appropriate to do so.\n     */\n    TagHints.prototype.hasHints = function (editor, implicitChar) {\n        var pos = editor.getCursorPos();\n\n        this.tagInfo = HTMLUtils.getTagInfo(editor, pos);\n        this.editor = editor;\n        if (implicitChar === null) {\n            if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n                if (this.tagInfo.position.offset >= 0) {\n                    if (this.tagInfo.position.offset === 0) {\n                        this.exclusion = this.tagInfo.tagName;\n                    } else {\n                        this.updateExclusion();\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (implicitChar === \"<\") {\n            this.exclusion = this.tagInfo.tagName;\n            return true;\n        }\n        return false;\n\n    };\n\n    /**\n     * Returns a list of availble HTML tag hints if possible for the current\n     * editor context.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    TagHints.prototype.getHints = function (implicitChar) {\n        var query,\n            result;\n\n        this.tagInfo = HTMLUtils.getTagInfo(this.editor, this.editor.getCursorPos());\n        if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n            if (this.tagInfo.position.offset >= 0) {\n                this.updateExclusion();\n                query = this.tagInfo.tagName.slice(0, this.tagInfo.position.offset);\n                result = $.map(tags, function (value, key) {\n                    if (key.indexOf(query) === 0) {\n                        return key;\n                    }\n                }).sort();\n\n                return {\n                    hints: result,\n                    match: query,\n                    selectInitial: true,\n                    handleWideResults: false\n                };\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Inserts a given HTML tag hint into the current editor context.\n     *\n     * @param {string} hint\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    TagHints.prototype.insertHint = function (completion) {\n        var start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            cursor = this.editor.getCursorPos(),\n            charCount = 0;\n\n        if (this.tagInfo.position.tokenType === HTMLUtils.TAG_NAME) {\n            var textAfterCursor = this.tagInfo.tagName.substr(this.tagInfo.position.offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = this.tagInfo.position.offset;\n            } else {\n                charCount = this.tagInfo.tagName.length;\n            }\n        }\n\n        end.line = start.line = cursor.line;\n        start.ch = cursor.ch - this.tagInfo.position.offset;\n        end.ch = start.ch + charCount;\n\n        if (this.exclusion || completion !== this.tagInfo.tagName) {\n            if (start.ch !== end.ch) {\n                this.editor.document.replaceRange(completion, start, end);\n            } else {\n                this.editor.document.replaceRange(completion, start);\n            }\n            this.exclusion = null;\n        }\n\n        return false;\n    };\n\n    /**\n     * @constructor\n     */\n    function AttrHints() {\n        this.globalAttributes = this.readGlobalAttrHints();\n        this.cachedHints = null;\n        this.exclusion = \"\";\n    }\n\n    /**\n     * @private\n     * Parse the code hints from JSON data and extract all hints from property names.\n     * @return {!Array.<string>} An array of code hints read from the JSON data source.\n     */\n    AttrHints.prototype.readGlobalAttrHints = function () {\n        return $.map(attributes, function (value, key) {\n            if (value.global === \"true\") {\n                return key;\n            }\n        });\n    };\n\n    /**\n     * Helper function that determines the possible value hints for a given html tag/attribute name pair\n     *\n     * @param {{queryStr: string}} query\n     * The current query\n     *\n     * @param {string} tagName\n     * HTML tag name\n     *\n     * @param {string} attrName\n     * HTML attribute name\n     *\n     * @return {!Array.<string>|$.Deferred}\n     * The (possibly deferred) hints.\n     */\n    AttrHints.prototype._getValueHintsForAttr = function (query, tagName, attrName) {\n        // We look up attribute values with tagName plus a slash and attrName first.\n        // If the lookup fails, then we fall back to look up with attrName only. Most\n        // of the attributes in JSON are using attribute name only as their properties,\n        // but in some cases like \"type\" attribute, we have different properties like\n        // \"script/type\", \"link/type\" and \"button/type\".\n        var hints = [];\n\n        var tagPlusAttr = tagName + \"/\" + attrName,\n            attrInfo = attributes[tagPlusAttr] || attributes[attrName];\n\n        if (attrInfo) {\n            if (attrInfo.type === \"boolean\") {\n                hints = [\"false\", \"true\"];\n            } else if (attrInfo.attribOption) {\n                hints = attrInfo.attribOption;\n            }\n        }\n\n        return hints;\n    };\n\n    /**\n     * Check whether the exclusion is still the same as text after the cursor.\n     * If not, reset it to null.\n     *\n     * @param {boolean} attrNameOnly\n     * true to indicate that we update the exclusion only if the cursor is inside an attribute name context.\n     * Otherwise, we also update exclusion for attribute value context.\n     */\n    AttrHints.prototype.updateExclusion = function (attrNameOnly) {\n        if (this.exclusion && this.tagInfo) {\n            var tokenType = this.tagInfo.position.tokenType,\n                offset = this.tagInfo.position.offset,\n                textAfterCursor;\n\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                textAfterCursor = this.tagInfo.attr.name.substr(offset);\n            } else if (!attrNameOnly && tokenType === HTMLUtils.ATTR_VALUE) {\n                textAfterCursor = this.tagInfo.attr.value.substr(offset);\n            }\n            if (!CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                this.exclusion = null;\n            }\n        }\n    };\n\n    /**\n     * Determines whether HTML attribute hints are available in the current\n     * editor context.\n     *\n     * @param {Editor} editor\n     * A non-null editor object for the active window.\n     *\n     * @param {string} implicitChar\n     * Either null, if the hinting request was explicit, or a single character\n     * that represents the last insertion and that indicates an implicit\n     * hinting request.\n     *\n     * @return {boolean}\n     * Determines whether the current provider is able to provide hints for\n     * the given editor context and, in case implicitChar is non-null,\n     * whether it is appropriate to do so.\n     */\n    AttrHints.prototype.hasHints = function (editor, implicitChar) {\n        var pos = editor.getCursorPos(),\n            tokenType,\n            offset,\n            query;\n\n        this.editor = editor;\n        this.tagInfo = HTMLUtils.getTagInfo(editor, pos);\n        tokenType = this.tagInfo.position.tokenType;\n        offset = this.tagInfo.position.offset;\n        if (implicitChar === null) {\n            query = null;\n\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                if (offset >= 0) {\n                    query = this.tagInfo.attr.name.slice(0, offset);\n                }\n            } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n                if (this.tagInfo.position.offset >= 0) {\n                    query = this.tagInfo.attr.value.slice(0, offset);\n                } else {\n                    // We get negative offset for a quoted attribute value with some leading whitespaces\n                    // as in <a rel= \"rtl\" where the cursor is just to the right of the \"=\".\n                    // So just set the queryStr to an empty string.\n                    query = \"\";\n                }\n\n                // If we're at an attribute value, check if it's an attribute name that has hintable values.\n                if (this.tagInfo.attr.name) {\n                    var hints = this._getValueHintsForAttr({queryStr: query},\n                                                           this.tagInfo.tagName,\n                                                           this.tagInfo.attr.name);\n                    if (hints instanceof Array) {\n                        // If we got synchronous hints, check if we have something we'll actually use\n                        var i, foundPrefix = false;\n                        for (i = 0; i < hints.length; i++) {\n                            if (hints[i].indexOf(query) === 0) {\n                                foundPrefix = true;\n                                break;\n                            }\n                        }\n                        if (!foundPrefix) {\n                            query = null;\n                        }\n                    }\n                }\n            }\n\n            if (offset >= 0) {\n                if (tokenType === HTMLUtils.ATTR_NAME && offset === 0) {\n                    this.exclusion = this.tagInfo.attr.name;\n                } else {\n                    this.updateExclusion(false);\n                }\n            }\n\n            return query !== null;\n        }\n        if (implicitChar === \" \" || implicitChar === \"'\" ||\n                    implicitChar === \"\\\"\" || implicitChar === \"=\") {\n            if (tokenType === HTMLUtils.ATTR_NAME) {\n                this.exclusion = this.tagInfo.attr.name;\n            }\n            return true;\n        }\n        return false;\n\n    };\n\n    /**\n     * Returns a list of availble HTML attribute hints if possible for the\n     * current editor context.\n     *\n     * @return {jQuery.Deferred|{\n     *              hints: Array.<string|jQueryObject>,\n     *              match: string,\n     *              selectInitial: boolean,\n     *              handleWideResults: boolean}}\n     * Null if the provider wishes to end the hinting session. Otherwise, a\n     * response object that provides:\n     * 1. a sorted array hints that consists of strings\n     * 2. a string match that is used by the manager to emphasize matching\n     *    substrings when rendering the hint list\n     * 3. a boolean that indicates whether the first result, if one exists,\n     *    should be selected by default in the hint list window.\n     * 4. handleWideResults, a boolean (or undefined) that indicates whether\n     *    to allow result string to stretch width of display.\n     */\n    AttrHints.prototype.getHints = function (implicitChar) {\n        var cursor = this.editor.getCursorPos(),\n            query = {queryStr: null},\n            tokenType,\n            offset,\n            result = [];\n\n        this.tagInfo = HTMLUtils.getTagInfo(this.editor, cursor);\n        tokenType = this.tagInfo.position.tokenType;\n        offset = this.tagInfo.position.offset;\n        if (tokenType === HTMLUtils.ATTR_NAME || tokenType === HTMLUtils.ATTR_VALUE) {\n            query.tag = this.tagInfo.tagName;\n\n            if (offset >= 0) {\n                if (tokenType === HTMLUtils.ATTR_NAME) {\n                    query.queryStr = this.tagInfo.attr.name.slice(0, offset);\n                } else {\n                    query.queryStr = this.tagInfo.attr.value.slice(0, offset);\n                    query.attrName = this.tagInfo.attr.name;\n                }\n                this.updateExclusion(false);\n            } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n                // We get negative offset for a quoted attribute value with some leading whitespaces\n                // as in <a rel= \"rtl\" where the cursor is just to the right of the \"=\".\n                // So just set the queryStr to an empty string.\n                query.queryStr = \"\";\n                query.attrName = this.tagInfo.attr.name;\n            }\n\n            query.usedAttr = HTMLUtils.getTagAttributes(this.editor, cursor);\n        }\n\n        if (query.tag && query.queryStr !== null) {\n            var tagName = query.tag,\n                attrName = query.attrName,\n                filter = query.queryStr,\n                unfiltered = [],\n                hints;\n\n            if (attrName) {\n                hints = this._getValueHintsForAttr(query, tagName, attrName);\n            } else if (tags && tags[tagName] && tags[tagName].attributes) {\n                unfiltered = tags[tagName].attributes.concat(this.globalAttributes);\n                hints = $.grep(unfiltered, function (attr, i) {\n                    return $.inArray(attr, query.usedAttr) < 0;\n                });\n            }\n\n            if (hints instanceof Array && hints.length) {\n                console.assert(!result.length);\n                result = $.map(hints, function (item) {\n                    if (item.indexOf(filter) === 0) {\n                        return item;\n                    }\n                }).sort();\n                return {\n                    hints: result,\n                    match: query.queryStr,\n                    selectInitial: true,\n                    handleWideResults: false\n                };\n            } else if (hints instanceof Object && hints.hasOwnProperty(\"done\")) { // Deferred hints\n                var deferred = $.Deferred();\n                hints.done(function (asyncHints) {\n                    deferred.resolveWith(this, [{\n                        hints: asyncHints,\n                        match: query.queryStr,\n                        selectInitial: true,\n                        handleWideResults: false\n                    }]);\n                });\n                return deferred;\n            }\n            return null;\n\n        }\n\n\n    };\n\n    /**\n     * Inserts a given HTML attribute hint into the current editor context.\n     *\n     * @param {string} hint\n     * The hint to be inserted into the editor context.\n     *\n     * @return {boolean}\n     * Indicates whether the manager should follow hint insertion with an\n     * additional explicit hint request.\n     */\n    AttrHints.prototype.insertHint = function (completion) {\n        var cursor = this.editor.getCursorPos(),\n            start = {line: -1, ch: -1},\n            end = {line: -1, ch: -1},\n            tokenType = this.tagInfo.position.tokenType,\n            offset = this.tagInfo.position.offset,\n            charCount = 0,\n            insertedName = false,\n            replaceExistingOne = this.tagInfo.attr.valueAssigned,\n            endQuote = \"\",\n            shouldReplace = true,\n            textAfterCursor;\n\n        if (tokenType === HTMLUtils.ATTR_NAME) {\n            textAfterCursor = this.tagInfo.attr.name.substr(offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = offset;\n                replaceExistingOne = false;\n            } else {\n                charCount = this.tagInfo.attr.name.length;\n            }\n            // Append an equal sign and two double quotes if the current attr is not an empty attr\n            // and then adjust cursor location before the last quote that we just inserted.\n            if (!replaceExistingOne && attributes && attributes[completion] &&\n                    attributes[completion].type !== \"flag\") {\n                completion += \"=\\\"\\\"\";\n                insertedName = true;\n            } else if (completion === this.tagInfo.attr.name) {\n                shouldReplace = false;\n            }\n        } else if (tokenType === HTMLUtils.ATTR_VALUE) {\n            textAfterCursor = this.tagInfo.attr.value.substr(offset);\n            if (CodeHintManager.hasValidExclusion(this.exclusion, textAfterCursor)) {\n                charCount = offset;\n                // Set exclusion to null only after attribute value insertion,\n                // not after attribute name insertion since we need to keep it\n                // for attribute value insertion.\n                this.exclusion = null;\n            } else {\n                charCount = this.tagInfo.attr.value.length;\n            }\n\n            if (!this.tagInfo.attr.hasEndQuote) {\n                endQuote = this.tagInfo.attr.quoteChar;\n                if (endQuote) {\n                    completion += endQuote;\n                } else if (offset === 0) {\n                    completion = \"\\\"\" + completion + \"\\\"\";\n                }\n            } else if (completion === this.tagInfo.attr.value) {\n                shouldReplace = false;\n            }\n        }\n\n        end.line = start.line = cursor.line;\n        start.ch = cursor.ch - offset;\n        end.ch = start.ch + charCount;\n\n        if (shouldReplace) {\n            if (start.ch !== end.ch) {\n                this.editor.document.replaceRange(completion, start, end);\n            } else {\n                this.editor.document.replaceRange(completion, start);\n            }\n        }\n\n        if (insertedName) {\n            this.editor.setCursorPos(start.line, start.ch + completion.length - 1);\n\n            // Since we're now inside the double-quotes we just inserted,\n            // immediately pop up the attribute value hint.\n            return true;\n        } else if (tokenType === HTMLUtils.ATTR_VALUE && this.tagInfo.attr.hasEndQuote) {\n            // Move the cursor to the right of the existing end quote after value insertion.\n            this.editor.setCursorPos(start.line, start.ch + completion.length + 1);\n        }\n\n        return false;\n    };\n\n    AppInit.appReady(function () {\n        // Parse JSON files\n        tags = JSON.parse(HTMLTags);\n        attributes = JSON.parse(HTMLAttributes);\n\n        // Register code hint providers\n        var tagHints = new TagHints();\n        var attrHints = new AttrHints();\n        CodeHintManager.registerHintProvider(tagHints, [\"html\"], 0);\n        CodeHintManager.registerHintProvider(attrHints, [\"html\"], 0);\n\n        // For unit testing\n        exports.tagHintProvider = tagHints;\n        exports.attrHintProvider = attrHints;\n    });\n});\n"],"file":"main.js"}
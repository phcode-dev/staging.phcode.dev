{"version":3,"sources":["extensions/default/Phoenix/utils.js"],"names":["define","require","exports","module","async","_ensureExistsAsync","path","Promise","resolve","reject","Phoenix","VFS","ensureExistsDir","err","_copyZippedItemToFS","item","destProjectDir","flattenFirstLevel","destPath","newPath","substr","indexOf","console","log","dir","window","dirname","then","data","fs","writeFile","Filer","Buffer","from","writeErr","catch","error","e","unzipFileToLocation","zipData","projectDir","endsWith","JSZip","loadAsync","zip","keys","Object","files","allPromises","forEach","push","all","unzipURLToLocation","url","JSZipUtils","getBinaryContent"],"mappings":"AAsBAA,OAAO,SAAUC,QAASC,QAASC,QAE/BC,eAAeC,mBAAmBC,MAC9B,OAAO,IAAIC,QAAQ,CAACC,QAASC,UACzBC,QAAQC,IAAIC,gBAAgBN,KAAOO,MAC5BA,IACCJ,OAAOI,KAEPL,cAMhB,SAASM,oBAAoBR,KAAMS,KAAMC,eAAgBC,mBACrD,OAAO,IAAIV,QAAQH,MAAOI,QAASC,UAC/B,IACI,IAAIS,YAAcF,iBAAiBV,OACnC,GAAGW,kBAAkB,CAEjB,IAAIE,QAAUb,KAAKc,OAAOd,KAAKe,QAAQ,KAAO,GAC9CH,YAAcF,iBAAiBG,UAC/BG,QAAQC,IAAIL,UAEbH,KAAKS,WACEnB,mBAAmBa,UACzBV,QAAQU,kBAEFb,mBAAmBoB,OAAOnB,KAAKoB,QAAQR,WAC7CH,KAAKX,MAAM,cAAcuB,KAAK,SAAUC,MACpCH,OAAOI,GAAGC,UAAUZ,SAAUa,MAAMC,OAAOC,KAAKL,MAAOM,WAChDA,SACCzB,OAAOyB,UAEP1B,QAAQU,cAGjBiB,MAAMC,QACL3B,OAAO2B,UAGjB,MAAOC,GACL5B,OAAO4B,MAgBnB,SAASC,oBAAoBC,QAASC,WAAYvB,mBAAoB,GAIlE,OAHIuB,WAAWC,SAAS,OACpBD,YAA0B,KAEvB,IAAIjC,QAAQ,CAACC,QAASC,UACzBiC,MAAMC,UAAUJ,SAASZ,KAAK,SAAUiB,KACpC,IAAIC,KAAOC,OAAOD,KAAKD,IAAIG,OACvBC,YAAY,GAChBH,KAAKI,QAAQ3C,OACT0C,YAAYE,KAAKpC,oBAAoBR,KAAMsC,IAAIG,MAAMzC,MAAOkC,WAAYvB,sBAE5EV,QAAQ4C,IAAIH,aAAarB,KAAK,KAC1BL,QAAQC,IAAI,mBAAoBiB,YAChChC,YACD2B,MAAMtB,MACLS,QAAQc,MAAM,eAAgBvB,KAC9BJ,OAAOI,WAiBvB,SAASuC,mBAAmBC,IAAKb,WAAYvB,mBAAoB,GAC7D,OAAO,IAAIV,QAAQ,CAACC,QAASC,UACzBgB,OAAO6B,WAAWC,iBAAiBF,IAAKjD,eAAeS,IAAKe,MACrDf,KACCS,QAAQc,sCAAsCiB,SAAUxC,KACxDJ,UAEA6B,oBAAoBV,KAAMY,WAAYvB,mBACjCU,KAAKnB,SACL2B,MAAM1B,YAK3BP,QAAQoC,oBAAsBA,oBAC9BpC,QAAQkD,mBAAqBA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*globals Phoenix, JSZip, Filer*/\n\ndefine(function (require, exports, module) {\n\n    async function _ensureExistsAsync(path) {\n        return new Promise((resolve, reject)=>{\n            Phoenix.VFS.ensureExistsDir(path, (err)=>{\n                if(err){\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n\n    function _copyZippedItemToFS(path, item, destProjectDir, flattenFirstLevel) {\n        return new Promise(async (resolve, reject) =>{ // eslint-disable-line\n            try {\n                let destPath = `${destProjectDir}${path}`;\n                if(flattenFirstLevel){\n                    // contents/index.html to index.html\n                    let newPath = path.substr(path.indexOf(\"/\") + 1);\n                    destPath = `${destProjectDir}${newPath}`;\n                    console.log(destPath);\n                }\n                if(item.dir){\n                    await _ensureExistsAsync(destPath);\n                    resolve(destPath);\n                } else {\n                    await _ensureExistsAsync(window.path.dirname(destPath));\n                    item.async(\"uint8array\").then(function (data) {\n                        window.fs.writeFile(destPath, Filer.Buffer.from(data), writeErr=>{\n                            if(writeErr){\n                                reject(writeErr);\n                            } else {\n                                resolve(destPath);\n                            }\n                        });\n                    }).catch(error=>{\n                        reject(error);\n                    });\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    /**\n     *\n     * @param zipData binary UInt8Array zip data\n     * @param projectDir To extract to\n     * @param flattenFirstLevel if set to true, then if zip contents are nested inside a directory, the nexted dir will\n     * be removed in the path structure in destination. For Eg. some Zip may contain a `contents` folder inside the zip\n     * which has all the contents. If we blindly extract the zio, all the contents will be placed inside a `contents`\n     * folder in root and not the root dir itself.\n     * See a sample zip file here: https://api.github.com/repos/StartBootstrap/startbootstrap-grayscales/zipball\n     * @returns {Promise}\n     */\n    function unzipFileToLocation(zipData, projectDir, flattenFirstLevel = false) {\n        if(!projectDir.endsWith('/')){\n            projectDir = projectDir + \"/\";\n        }\n        return new Promise((resolve, reject)=>{\n            JSZip.loadAsync(zipData).then(function (zip) {\n                let keys = Object.keys(zip.files);\n                let allPromises=[];\n                keys.forEach(path => {\n                    allPromises.push(_copyZippedItemToFS(path, zip.files[path], projectDir, flattenFirstLevel));\n                });\n                Promise.all(allPromises).then(()=>{\n                    console.log(\"Unzip complete: \", projectDir);\n                    resolve();\n                }).catch(err=>{\n                    console.error('unzip failed', err);\n                    reject(err);\n                });\n            });\n        });\n    }\n\n    /**\n     *\n     * @param url the zip fle URL\n     * @param projectDir To extract to\n     * @param flattenFirstLevel if set to true, then if zip contents are nested inside a directory, the nexted dir will\n     * be removed in the path structure in destination. For Eg. some Zip may contain a `contents` folder inside the zip\n     * which has all the contents. If we blindly extract the zio, all the contents will be placed inside a `contents`\n     * folder in root and not the root dir itself.\n     * See a sample zip file here: https://api.github.com/repos/StartBootstrap/startbootstrap-grayscales/zipball\n     * @returns {Promise}\n     */\n    function unzipURLToLocation(url, projectDir, flattenFirstLevel = false) {\n        return new Promise((resolve, reject)=>{\n            window.JSZipUtils.getBinaryContent(url, async function(err, data) {\n                if(err) {\n                    console.error(`could not load zip from URL: ${url}\\n `, err);\n                    reject();\n                } else {\n                    unzipFileToLocation(data, projectDir, flattenFirstLevel)\n                        .then(resolve)\n                        .catch(reject);\n                }\n            });\n        });\n    }\n    exports.unzipFileToLocation = unzipFileToLocation;\n    exports.unzipURLToLocation = unzipURLToLocation;\n});\n"],"file":"utils.js"}
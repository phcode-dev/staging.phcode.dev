{"version":3,"sources":["extensions/default/JavaScriptRefactoring/HighLightReferences.js"],"names":["define","require","exports","module","EditorManager","brackets","getModule","ScopeManager","Session","MessageIds","JSON","parse","Editor","session","initializeSession","editor","getRefs","fileInfo","offset","postMessage","type","TERN_REFS","addPendingRequest","name","requestFindRefs","document","path","file","fullPath","ternPromise","promise","TERN_FILE_INFO_TYPE_FULL","offsetLines","text","filterText","getJavascriptText","HIGHLIGHT_REFS_MARKER","_handleHighLightRefs","refsResp","references","refs","operation","ref","endsWith","markText","start","end","MARK_OPTION_MATCHING_REFS","_hasASingleCursor","selections","getSelections","length","line","ch","allowedHighlightTypes","lastHighlightToken","_cursorActivity","_evt","getModeForSelection","token","getToken","clearAllMarks","includes","getOffset","done","response","fail","err","console","error","_activeEditorChanged","current","previous","off","on"],"mappings":"AAqBAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,cAAuBC,SAASC,UAAU,wBAC1CC,aAAuBF,SAASC,UAAU,wBAC1CE,QAAuBH,SAASC,UAAU,mBAC1CG,WAAuBC,KAAKC,MAAMN,SAASC,UAAU,iCACrDM,OAAuBP,SAASC,UAAU,iBAAiBM,OAE3DC,QAAsB,KAG1B,SAASC,kBAAkBC,QACvBF,QAAU,IAAIL,QAAQO,QAI1B,SAASC,QAAQC,SAAUC,QAOvB,OANAX,aAAaY,YAAY,CACrBC,KAAMX,WAAWY,UACjBJ,SAAUA,SACVC,OAAQA,SAGLX,aAAae,kBAAkBL,SAASM,KAAML,OAAQT,WAAWY,WAI5E,SAASG,gBAAgBX,QAASY,SAAUP,QACxC,IAAKO,WAAaZ,QACd,OAEJ,IAAIa,KAAUD,SAASE,KAAKC,SACxBX,SAMAY,YAEJ,MAAO,CAACC,QAFUd,QANH,CACPI,KAAMX,WAAWsB,yBACjBR,KAAMG,KACNM,YAAa,EACbC,KAAM1B,aAAa2B,WAAWrB,QAAQsB,sBAEVjB,SAQxC,MAAMkB,sBAAwB,UAE9B,SAASC,qBAAqBtB,OAAQuB,UAC7BA,UAAaA,SAASC,YAAeD,SAASC,WAAWC,MAG9DzB,OAAO0B,UAAU,WACb,IAAI,IAAIC,OAAOJ,SAASC,WAAWC,KAC5BzB,OAAOU,SAASE,KAAKC,SAASe,SAASD,IAAIf,OAC1CZ,OAAO6B,SAASR,sBAAuBM,IAAIG,MAAOH,IAAII,IAAKlC,OAAOmC,6BAMlF,SAASC,kBAAkBjC,QACvB,IAAIkC,WAAalC,OAAOmC,gBACxB,GAAGD,WAAWE,OAAS,EAEnB,OAAO,EAEX,IAAIN,MAAQI,WAAW,GAAGJ,MACtBC,IAAMG,WAAW,GAAGH,IACxB,OAAGD,MAAMO,OAASN,IAAIM,MAAQP,MAAMQ,KAAOP,IAAIO,GAOnD,IAAIC,sBAAwB,CAAC,MAAO,WAAY,aAAc,aAAc,YACxEC,mBAAqB,GACzB,SAASC,gBAAgBC,KAAM1C,QAE3B,GAAqC,eAAjCA,OAAO2C,sBACP,OAGJ,IAAIC,MAAQ5C,OAAO6C,WACnB,GAAGL,qBAAuBI,MACtB,OAKJ,GAFA5C,OAAO8C,cAAczB,uBACrBmB,mBAAqBI,OACjBL,sBAAsBQ,SAASH,MAAMvC,MACrC,OAGJ,IAAIF,OAASL,QAAQkD,YAEjBf,kBAAkBjC,SAKtBS,gBAAgBX,QAASA,QAAQE,OAAOU,SAAUP,QAAQY,QACrDkC,KAAKC,WACF5B,qBAAqBtB,OAAQkD,YAEhCC,KAAK,SAAUC,KACZC,QAAQC,MAAM,gCAAiCF,OAI3D,SAASG,qBAAqBb,KAAOc,QAASC,UACvCA,UACCA,SAASC,IAAI,gCAEdF,UACCA,QAAQE,IAAI,gCACZF,QAAQG,GAAG,+BAAgClB,iBAC3C1C,kBAAkByD,SAClBf,gBAAgBC,KAAMc,UAI9BnE,cAAcsE,GAAG,qBAAsBJ,sBAEvCpE,QAAQkC,sBAAwBA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    let EditorManager        = brackets.getModule(\"editor/EditorManager\"),\n        ScopeManager         = brackets.getModule(\"JSUtils/ScopeManager\"),\n        Session              = brackets.getModule(\"JSUtils/Session\"),\n        MessageIds           = JSON.parse(brackets.getModule(\"text!JSUtils/MessageIds.json\")),\n        Editor               = brackets.getModule(\"editor/Editor\").Editor;\n\n    let session             = null;\n\n    //Create new session\n    function initializeSession(editor) {\n        session = new Session(editor);\n    }\n\n    //Post message to tern node domain that will request tern server to find refs\n    function getRefs(fileInfo, offset) {\n        ScopeManager.postMessage({\n            type: MessageIds.TERN_REFS,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return ScopeManager.addPendingRequest(fileInfo.name, offset, MessageIds.TERN_REFS);\n    }\n\n    //Create info required to find reference\n    function requestFindRefs(session, document, offset) {\n        if (!document || !session) {\n            return;\n        }\n        let path    = document.file.fullPath,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: ScopeManager.filterText(session.getJavascriptText())\n            };\n        let ternPromise = getRefs(fileInfo, offset);\n\n        return {promise: ternPromise};\n    }\n\n    // This is the highlight references under cursor feature. We should ideally move this to\n    // features/findReferencesManager\n\n    const HIGHLIGHT_REFS_MARKER = \"JS_REFS\";\n\n    function _handleHighLightRefs(editor, refsResp) {\n        if (!refsResp || !refsResp.references || !refsResp.references.refs) {\n            return;\n        }\n        editor.operation(function () {\n            for(let ref of refsResp.references.refs){\n                if(editor.document.file.fullPath.endsWith(ref.file)){\n                    editor.markText(HIGHLIGHT_REFS_MARKER, ref.start, ref.end, Editor.MARK_OPTION_MATCHING_REFS);\n                }\n            }\n        });\n    }\n\n    function _hasASingleCursor(editor) {\n        let selections = editor.getSelections();\n        if(selections.length > 1){\n            // multi cursor, no highlight\n            return false;\n        }\n        let start = selections[0].start,\n            end = selections[0].end;\n        if(start.line !== end.line || start.ch !== end.ch){\n            // has a range selection\n            return false;\n        }\n        return true;\n    }\n\n    let allowedHighlightTypes = [\"def\", \"variable\", \"variable-2\", \"variable-3\", \"property\"];\n    let lastHighlightToken = {};\n    function _cursorActivity(_evt, editor) {\n        // Only provide a JavaScript editor when cursor is in JavaScript content\n        if (editor.getModeForSelection() !== \"javascript\") {\n            return;\n        }\n\n        let token = editor.getToken();\n        if(lastHighlightToken === token) {\n            return;\n        }\n\n        editor.clearAllMarks(HIGHLIGHT_REFS_MARKER);\n        lastHighlightToken = token;\n        if(!allowedHighlightTypes.includes(token.type)){\n            return;\n        }\n\n        let offset = session.getOffset();\n\n        if(!_hasASingleCursor(editor)){\n            return;\n        }\n\n        // only do this request if token under cursor is a variable type\n        requestFindRefs(session, session.editor.document, offset).promise\n            .done(response =>{\n                _handleHighLightRefs(editor, response);\n            })\n            .fail(function (err) {\n                console.error(\"find references failed with: \", err);\n            });\n    }\n\n    function _activeEditorChanged(_evt,  current, previous) {\n        if(previous){\n            previous.off(\"cursorActivity.highlightRefs\");\n        }\n        if(current){\n            current.off(\"cursorActivity.highlightRefs\");\n            current.on(\"cursorActivity.highlightRefs\", _cursorActivity);\n            initializeSession(current);\n            _cursorActivity(_evt, current);\n        }\n    }\n\n    EditorManager.on(\"activeEditorChange\", _activeEditorChanged);\n\n    exports.HIGHLIGHT_REFS_MARKER = HIGHLIGHT_REFS_MARKER;\n});\n"],"file":"HighLightReferences.js"}
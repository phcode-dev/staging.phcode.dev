{"version":3,"sources":["extensions/default/JavaScriptRefactoring/RenameIdentifier.js"],"names":["define","require","exports","module","EditorManager","brackets","getModule","ScopeManager","Session","MessageIds","JSON","parse","TokenUtils","Strings","ProjectManager","session","keywords","initializeSession","editor","getRefs","fileInfo","offset","postMessage","type","TERN_REFS","addPendingRequest","name","requestFindRefs","document","path","file","fullPath","ternPromise","promise","TERN_FILE_INFO_TYPE_FULL","offsetLines","text","filterText","getJavascriptText","handleRename","getActiveEditor","handleFindRefs","token","getSelections","length","displayErrorMessageAtCursor","ERROR_RENAME_MULTICURSOR","getModeForSelection","getTokenAt","_codeMirror","posFromIndex","getOffset","indexOf","string","result","$","Deferred","requestFindReferences","ERROR_RENAME_GENERAL","isInSameFile","obj","refsResp","projectRoot","getProjectRoot","projectDir","fileName","slice","references","refs","inlineWidget","getFocusedInlineWidget","isInTextRange","find","item","start","line","_startLine","end","_endLine","ERROR_RENAME_QUICKEDIT","currentPosition","refsArray","primaryRef","filter","element","ch","primary","setSelections","response","hasOwnProperty","done","fail","reject"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var EditorManager        = brackets.getModule(\"editor/EditorManager\"),\n        ScopeManager         = brackets.getModule(\"JSUtils/ScopeManager\"),\n        Session              = brackets.getModule(\"JSUtils/Session\"),\n        MessageIds           = JSON.parse(brackets.getModule(\"text!JSUtils/MessageIds.json\")),\n        TokenUtils           = brackets.getModule(\"utils/TokenUtils\"),\n        Strings              = brackets.getModule(\"strings\"),\n        ProjectManager      = brackets.getModule(\"project/ProjectManager\");\n\n    var session             = null,  // object that encapsulates the current session state\n        keywords = [\"define\", \"alert\", \"exports\", \"require\", \"module\", \"arguments\"];\n\n    //Create new session\n    function initializeSession(editor) {\n        session = new Session(editor);\n    }\n\n    //Post message to tern node domain that will request tern server to find refs\n    function getRefs(fileInfo, offset) {\n        ScopeManager.postMessage({\n            type: MessageIds.TERN_REFS,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return ScopeManager.addPendingRequest(fileInfo.name, offset, MessageIds.TERN_REFS);\n    }\n\n    //Create info required to find reference\n    function requestFindRefs(session, document, offset) {\n        if (!document || !session) {\n            return;\n        }\n        var path    = document.file.fullPath,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: ScopeManager.filterText(session.getJavascriptText())\n            };\n        var ternPromise = getRefs(fileInfo, offset);\n\n        return {promise: ternPromise};\n    }\n\n    //Do rename of identifier which is at cursor\n    function handleRename() {\n        var editor = EditorManager.getActiveEditor(),\n            offset, handleFindRefs, token;\n\n        if (!editor) {\n            return;\n        }\n\n        if (editor.getSelections().length > 1) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_MULTICURSOR);\n            return;\n        }\n        initializeSession(editor);\n\n\n        if (!editor || editor.getModeForSelection() !== \"javascript\") {\n            return;\n        }\n\n        token = TokenUtils.getTokenAt(editor._codeMirror, editor._codeMirror.posFromIndex(session.getOffset()));\n\n        if (keywords.indexOf(token.string) >= 0) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_GENERAL);\n            return;\n        }\n\n        var result = new $.Deferred();\n\n        function isInSameFile(obj, refsResp) {\n            var projectRoot = ProjectManager.getProjectRoot(),\n                projectDir,\n                fileName = \"\";\n            if (projectRoot) {\n                projectDir = projectRoot.fullPath;\n            }\n\n            // get the relative path of File as Tern can also return\n            // references with file name as a relative path wrt projectRoot\n            // so refernce file name will be compared with both relative and absolute path to check if it is same file\n            if (projectDir && refsResp && refsResp.file && refsResp.file.indexOf(projectDir) === 0) {\n                fileName = refsResp.file.slice(projectDir.length);\n            }\n            // In case of unsaved files, After renameing once Tern is returning filename without forward slash\n            return (obj && (obj.file === refsResp.file || obj.file === fileName\n                            || obj.file === refsResp.file.slice(1, refsResp.file.length)));\n        }\n\n        /**\n         * Check if references are in this file only\n         * If yes then select all references\n         */\n        function handleFindRefs (refsResp) {\n            if (!refsResp || !refsResp.references || !refsResp.references.refs) {\n                return;\n            }\n\n            var inlineWidget = EditorManager.getFocusedInlineWidget(),\n                editor = EditorManager.getActiveEditor(),\n                refs = refsResp.references.refs;\n\n            //In case of inline widget if some references are outside widget's text range then don't allow for rename\n            if (inlineWidget) {\n                var isInTextRange  = !refs.find(function(item) {\n                    return (item.start.line < inlineWidget._startLine || item.end.line > inlineWidget._endLine);\n                });\n\n                if (!isInTextRange) {\n                    editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_QUICKEDIT);\n                    return;\n                }\n            }\n\n            var currentPosition = editor.posFromIndex(refsResp.offset),\n                refsArray;\n            refsArray = refs.filter(function (element) {\n                return isInSameFile(element, refsResp);\n            });\n            if (refsArray.length !== refs.length) {\n                // There are references across multiple files, we are not ready to handle this yet\n                // https://github.com/phcode-dev/phoenix/issues/604\n                return;\n            }\n\n            // Finding the Primary Reference in Array\n            var primaryRef = refsArray.find(function (element) {\n                return ((element.start.line === currentPosition.line || element.end.line === currentPosition.line)\n                        && currentPosition.ch <= element.end.ch && currentPosition.ch >= element.start.ch);\n            });\n            // Setting the primary flag of Primary Refence to true\n            primaryRef.primary = true;\n\n            editor.setSelections(refsArray);\n        }\n\n        /**\n         * Make a find ref request.\n         * @param {Session} session - the session\n         * @param {number} offset - the offset of where to jump from\n         */\n        function requestFindReferences(session, offset) {\n            var response = requestFindRefs(session, session.editor.document, offset);\n\n            if (response && response.hasOwnProperty(\"promise\")) {\n                response.promise.done(handleFindRefs).fail(function () {\n                    result.reject();\n                });\n            }\n        }\n\n        offset = session.getOffset();\n        requestFindReferences(session, offset);\n\n        return result.promise();\n    }\n\n    exports.handleRename = handleRename;\n});\n"],"file":"RenameIdentifier.js"}
{"version":3,"sources":["editor/MultiRangeInlineEditor.js"],"names":["define","require","exports","module","_","TextRange","InlineTextEditor","EditorManager","FileUtils","PreferencesManager","ProjectManager","Commands","Strings","CommandManager","_prevMatchCmd","_nextMatchCmd","_parseStyleSize","$target","styleName","parseInt","css","_getPrefsContext","projectRoot","getProjectRoot","location","scope","layer","layerID","fullPath","SearchResultItem","rangeResult","this","name","textRange","document","lineStart","lineEnd","_updateRangeLabel","listItem","range","labelCB","text","escape","startLine","html","attr","MultiRangeInlineEditor","ranges","messageCB","fileComparator","call","_ranges","map","_messageCB","_labelCB","_selectedRangeIndex","_collapsedFiles","_fileComparator","defaultComparator","file1","file2","comparePaths","sort","result1","result2","file","bind","getFocusedMultiRangeInlineEditor","focusedWidget","getFocusedInlineWidget","_previousRange","focusedMultiRangeInlineEditor","_selectPreviousRange","_nextRange","_selectNextRange","prototype","$listItem","Object","create","constructor","parentClass","$messageDiv","$relatedContainer","$related","$selectedMarker","$rangeList","_$headers","_createListItem","self","$rangeItem","$","data","appendTo","mousedown","setSelectedIndex","indexOf","_toggleSection","duringInit","$headerItem","$disclosureIcon","find","isCollapsing","hasClass","toggleClass","nextUntil","toggle","setting","getViewState","setViewState","_updateSelectedMarker","_ruleListHeightChanged","index","findIndex","resultItem","_createHeaderItem","doc","makeProjectRelativeIfPossible","click","_renderList","empty","lastSectionDoc","numItemsInSection","finalizeSection","append","forEach","load","hostEditor","apply","arguments","addClass","$editorHolder","on","e","stopPropagation","toCollapse","keys","length","$wrapper","before","_removeRange","indexToSelect","clickHandler","_onClick","$htmlContent","_updateCommands","enabled","hasFocus","setEnabled","onAdded","force","newIndex","Math","min","max","$previousItem","removeClass","editor","off","setInlineContent","hasHiddenMatches","INLINE_EDITOR_HIDDEN_MATCHES","done","msg","INLINE_EDITOR_NO_MATCHES","sizeInlineWidgetToContents","remove","_getSelectedRange","endLine","focus","_updateEditorMinHeight","refresh","_ensureCursorVisible","ruleListNaturalHeight","outerHeight","headerHeight","getScrollerElement","close","dispose","splice","addAndSelectRange","newRange","i","parent","animate","hide","containerHeight","height","itemTop","position","top","scrollTop","show","paddingTop","itemBottom","onClosed","searchResult","event","childEditor","editorRoot","getRootElement","editorPos","offset","containsClick","pageY","setCursorPos","lastLine","getLastVisibleLine","getLine","$parent","target","contains","window","activeElement","hostScrollPos","getScrollPos","cursorCoords","_codeMirror","scrollerTop","getVirtualScrollAreaTop","scrollIntoView","left","x","right","bottom","_onLostContent","cause","type","_getRanges","_selectNextPrev","dir","origDoc","widgetHeight","$header","setInlineWidgetHeight","onParentShown","register","CMD_QUICK_EDIT_PREV_MATCH","QUICK_EDIT_PREV_MATCH","CMD_QUICK_EDIT_NEXT_MATCH","QUICK_EDIT_NEXT_MATCH"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// FUTURE: Merge part (or all) of this class with InlineTextEditor\n\n/**\n * An inline editor for displaying and editing multiple text ranges. Each range corresponds to a\n * contiguous set of lines in a file.\n *\n * In the current implementation, only one range is visible at a time. A list on the right side\n * of the editor allows the user to select which range is visible.\n *\n * This module does not dispatch any events.\n */\ndefine(function (require, exports, module) {\n\n\n    var _ = require(\"thirdparty/lodash\");\n\n    // Load dependent modules\n    var TextRange           = require(\"document/TextRange\").TextRange,\n        InlineTextEditor    = require(\"editor/InlineTextEditor\").InlineTextEditor,\n        EditorManager       = require(\"editor/EditorManager\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        ProjectManager      = require(\"project/ProjectManager\"),\n        Commands            = require(\"command/Commands\"),\n        Strings             = require(\"strings\"),\n        CommandManager      = require(\"command/CommandManager\");\n\n    var _prevMatchCmd, _nextMatchCmd;\n\n    /**\n     * Remove trailing \"px\" from a style size value.\n     * @param {!JQuery} $target Element in DOM\n     * @param {!string} styleName Style name to query\n     * @return {number} Style value converted from string to number, removing \"px\" units\n     */\n    function _parseStyleSize($target, styleName) {\n        return parseInt($target.css(styleName), 10);\n    }\n\n    /** Returns a 'context' object for getting/setting project-specific preferences */\n    function _getPrefsContext() {\n        var projectRoot = ProjectManager.getProjectRoot();  // note: null during unit tests!\n        return { location: { scope: \"user\", layer: \"project\", layerID: projectRoot && projectRoot.fullPath } };\n    }\n\n\n    /**\n     * Stores one search result: its source file, line range, etc. plus the DOM node representing it\n     * in the results list.\n     * @constructor\n     */\n    function SearchResultItem(rangeResult) {\n        this.name = rangeResult.name;\n        this.textRange = new TextRange(rangeResult.document, rangeResult.lineStart, rangeResult.lineEnd);\n        // this.$listItem is assigned in load()\n    }\n    SearchResultItem.prototype.name = null;\n    SearchResultItem.prototype.textRange = null;\n    SearchResultItem.prototype.$listItem = null;\n\n    function _updateRangeLabel(listItem, range, labelCB) {\n        if (labelCB) {\n            range.name = labelCB(range.textRange);\n        }\n        var text = _.escape(range.name) + \" <span class='related-file'>:\" + (range.textRange.startLine + 1) + \"</span>\";\n        listItem.html(text);\n        listItem.attr(\"title\", listItem.text());\n    }\n\n\n    /**\n     * @constructor\n     * @param {Array.<{name:String,document:Document,lineStart:number,lineEnd:number}>} ranges The text\n     *      ranges to display. Results within the same file are expected to be contiguous in this array.\n     * @param {?function(): $.Promise} messageCB Optional; returns a promise resolved with a message to\n     *      show when no matches are available. The message should be already-escaped HTML.\n     * @param {?function(range): string} labelCB Optional; returns an updated label string for the given\n     *      range. Called when we detect that the content of a range has changed. The label is plain\n     *      text, not HTML.\n     * @param {?function(!File, !File):number} fileComparator Optional comparison function for sorting\n     *      the results list (based on range.document.file). Defaults to FileUtils.comparePaths().\n     * @extends {InlineTextEditor}\n     */\n    function MultiRangeInlineEditor(ranges, messageCB, labelCB, fileComparator) {\n        InlineTextEditor.call(this);\n\n        // Store the results to show in the range list. This creates TextRanges bound to the Document,\n        // which will stay up to date automatically (but we must be sure to detach them later)\n        this._ranges = ranges.map(function (rangeResult) {\n            return new SearchResultItem(rangeResult);\n        });\n        this._messageCB = messageCB;\n        this._labelCB = labelCB;\n\n        this._selectedRangeIndex = -1;\n        this._collapsedFiles = {};\n\n        // Set up list sort order\n        this._fileComparator = fileComparator || function defaultComparator(file1, file2) {\n            return FileUtils.comparePaths(file1.fullPath, file2.fullPath);\n        };\n        this._ranges.sort(function (result1, result2) {\n            return this._fileComparator(result1.textRange.document.file, result2.textRange.document.file);\n        }.bind(this));\n    }\n    MultiRangeInlineEditor.prototype = Object.create(InlineTextEditor.prototype);\n    MultiRangeInlineEditor.prototype.constructor = MultiRangeInlineEditor;\n    MultiRangeInlineEditor.prototype.parentClass = InlineTextEditor.prototype;\n\n    MultiRangeInlineEditor.prototype.$messageDiv = null;\n    MultiRangeInlineEditor.prototype.$relatedContainer = null;\n    MultiRangeInlineEditor.prototype.$related = null;\n    MultiRangeInlineEditor.prototype.$selectedMarker = null;\n\n    /** Includes all the _ranges[i].$listItem items, as well as section headers */\n    MultiRangeInlineEditor.prototype.$rangeList = null;\n\n    /**\n     * List of search results. Section headers are not represented in this list (they are implied before each group of\n     * of consecutive results from the same Document).\n     * @type {!Array.<SearchResultItem>}\n     */\n    MultiRangeInlineEditor.prototype._ranges = null;\n\n    /** Index into this._ranges - indices do not include section headers */\n    MultiRangeInlineEditor.prototype._selectedRangeIndex = null;\n\n    /**\n     * Map from fullPath to true if collapsed. May not agree with preferences, in cases where multiple inline editors make\n     * concurrent changes.\n     * @type {!Object.<string, boolean>}\n     */\n    MultiRangeInlineEditor.prototype._collapsedFiles = null;\n\n    MultiRangeInlineEditor.prototype._messageCB = null;\n    MultiRangeInlineEditor.prototype._labelCB = null;\n    MultiRangeInlineEditor.prototype._fileComparator = null;\n\n    /** @type {!Object.<string, jQueryObject>} Map from fullPath to section header DOM node */\n    MultiRangeInlineEditor.prototype._$headers = null;\n\n\n    /**\n     * @private\n     * Add a new result item <li> to the range list UI ($rangeList) and saves it in range.$listItem\n     * @param {SearchResultItem} range The range to add.\n     */\n    MultiRangeInlineEditor.prototype._createListItem = function (range) {\n        var self = this,\n            $rangeItem = $(\"<li/>\");\n\n        // Attach filename for unit test use\n        $rangeItem.data(\"filename\", range.textRange.document.file.name);\n\n        $rangeItem.appendTo(this.$rangeList);\n\n        _updateRangeLabel($rangeItem, range);\n        $rangeItem.mousedown(function () {\n            self.setSelectedIndex(self._ranges.indexOf(range));\n        });\n\n        range.$listItem = $rangeItem;\n    };\n\n    /** Collapses/expands a file section in the range list UI */\n    MultiRangeInlineEditor.prototype._toggleSection = function (fullPath, duringInit) {\n        var $headerItem = this._$headers[fullPath];\n        var $disclosureIcon = $headerItem.find(\".disclosure-triangle\");\n        var isCollapsing = $disclosureIcon.hasClass(\"expanded\");\n        $disclosureIcon.toggleClass(\"expanded\");\n        $headerItem.nextUntil(\".section-header\").toggle(!isCollapsing);  // explicit visibility arg, since during load() jQ doesn't think nodes are visible\n\n        // Update instance-specific state...\n        this._collapsedFiles[fullPath] = isCollapsing;\n        // ...AND persist as per-project view state\n        if (!duringInit) {\n            var setting = PreferencesManager.getViewState(\"inlineEditor.collapsedFiles\", _getPrefsContext()) || {};\n            if (isCollapsing) {\n                setting[fullPath] = true;\n            } else {\n                delete setting[fullPath];\n            }\n            PreferencesManager.setViewState(\"inlineEditor.collapsedFiles\", setting, _getPrefsContext());\n        }\n\n        // Show/hide selection indicator if selection was in collapsed section\n        this._updateSelectedMarker(false);\n\n        // Changing height of rule list may change ht of overall editor\n        this._ruleListHeightChanged();\n\n        // If user expands collapsed section and nothing selected yet, select first result in this section\n        if (this._selectedRangeIndex === -1 && !isCollapsing && !duringInit) {\n            var index = _.findIndex(this._ranges, function (resultItem) {\n                return resultItem.textRange.document.file.fullPath === fullPath;\n            });\n            this.setSelectedIndex(index);\n        }\n    };\n\n    /** Adds a file section header <li> to the range list UI ($rangeList) and adds it to the this._$headers map */\n    MultiRangeInlineEditor.prototype._createHeaderItem = function (doc) {\n        var $headerItem = $(\"<li class='section-header'><span class='disclosure-triangle expanded'/><span class='filename'>\" + _.escape(doc.file.name) + \"</span></li>\")\n            .attr(\"title\", ProjectManager.makeProjectRelativeIfPossible(doc.file.fullPath))\n            .appendTo(this.$rangeList);\n\n        $headerItem.click(function () {\n            this._toggleSection(doc.file.fullPath);\n        }.bind(this));\n\n        this._$headers[doc.file.fullPath] = $headerItem;\n    };\n\n    /** Refresh the contents of $rangeList */\n    MultiRangeInlineEditor.prototype._renderList = function () {\n        this.$rangeList.empty();\n        this._$headers = {};\n\n        var self = this,\n            lastSectionDoc,\n            numItemsInSection = 0;\n\n        // After seeing all results for a given file, update its header with total # of results\n        function finalizeSection() {\n            if (lastSectionDoc) {\n                self._$headers[lastSectionDoc.file.fullPath].append(\" (\" + numItemsInSection + \")\");\n                if (self._collapsedFiles[lastSectionDoc.file.fullPath]) {\n                    self._toggleSection(lastSectionDoc.file.fullPath, true);\n                }\n            }\n        }\n\n        this._ranges.forEach(function (resultItem) {\n            if (lastSectionDoc !== resultItem.textRange.document) {\n                // Finalize previous section\n                finalizeSection();\n\n                // Initialize new section\n                lastSectionDoc = resultItem.textRange.document;\n                numItemsInSection = 0;\n\n                // Create filename header for new section\n                this._createHeaderItem(lastSectionDoc);\n            }\n            numItemsInSection++;\n            this._createListItem(resultItem);\n        }, this);\n\n        // Finalize last section\n        finalizeSection();\n    };\n\n\n    /**\n     * @override\n     * @param {!Editor} hostEditor  Outer Editor instance that inline editor will sit within.\n     *\n     */\n    MultiRangeInlineEditor.prototype.load = function (hostEditor) {\n        MultiRangeInlineEditor.prototype.parentClass.load.apply(this, arguments);\n\n        // Create the message area\n        this.$messageDiv = $(\"<div/>\")\n            .addClass(\"inline-editor-message\");\n\n        // Prevent touch scroll events from bubbling up to the parent editor.\n        this.$editorHolder.on(\"mousewheel.MultiRangeInlineEditor\", function (e) {\n            e.stopPropagation();\n        });\n\n        // Outer container for border-left and scrolling\n        this.$relatedContainer = $(\"<div/>\").addClass(\"related-container\");\n\n        // List \"selection\" highlight\n        this.$selectedMarker = $(\"<div/>\").appendTo(this.$relatedContainer).addClass(\"selection\");\n\n        // Inner container\n        this.$related = $(\"<div/>\").appendTo(this.$relatedContainer).addClass(\"related\");\n\n        // Range list\n        this.$rangeList = $(\"<ul/>\").appendTo(this.$related);\n\n        // Determine which sections are initially collapsed (the actual collapsing happens after onAdded(),\n        // because jQuery.hide() requires the computed value of 'display' to work properly)\n        var toCollapse = PreferencesManager.getViewState(\"inlineEditor.collapsedFiles\", _getPrefsContext()) || {};\n        Object.keys(toCollapse).forEach(function (fullPath) {\n            this._collapsedFiles[fullPath] = true;\n        }.bind(this));\n\n        // Render list & section headers (matching collapsed state set above)\n        this._renderList();\n\n        if (this._ranges.length > 1) {      // attach to main container\n            this.$wrapper.before(this.$relatedContainer);\n        }\n\n        // Add TextRange listeners to update UI as text changes\n        var self = this;\n        this._ranges.forEach(function (range, index) {\n            // Update list item as TextRange changes\n            range.textRange.on(\"change\", function () {\n                _updateRangeLabel(range.$listItem, range);\n            }).on(\"contentChange\", function () {\n                _updateRangeLabel(range.$listItem, range, self._labelCB);\n            });\n\n            // If TextRange lost sync, remove it from the list (and close the widget if no other ranges are left)\n            range.textRange.on(\"lostSync\", function () {\n                self._removeRange(range);\n            });\n        });\n\n        // Initial selection is the first non-collapsed result item\n        var indexToSelect = _.findIndex(this._ranges, function (range) {\n            return !this._collapsedFiles[range.textRange.document.file.fullPath];\n        }.bind(this));\n        if (this._ranges.length === 1 && indexToSelect === -1) {\n            // If no right-hand rule list shown, select the one result even if it's in a collapsed file (since no way to expand)\n            indexToSelect = 0;\n        }\n\n        if (indexToSelect !== -1) {\n            // select the first visible range\n            this.setSelectedIndex(indexToSelect);\n        } else {\n            // force the message div to show\n            this.setSelectedIndex(-1);\n        }\n\n        // Listen for clicks directly on us, so we can set focus back to the editor\n        var clickHandler = this._onClick.bind(this);\n        this.$htmlContent.on(\"click.MultiRangeInlineEditor\", clickHandler);\n        // Also handle mouseup in case the user drags a little bit\n        this.$htmlContent.on(\"mouseup.MultiRangeInlineEditor\", clickHandler);\n\n        // Update the rule list navigation menu items when we gain/lose focus.\n        this.$htmlContent\n            .on(\"focusin.MultiRangeInlineEditor\", this._updateCommands.bind(this))\n            .on(\"focusout.MultiRangeInlineEditor\", this._updateCommands.bind(this));\n    };\n\n    /**\n     * @private\n     * Updates the enablement for the rule list navigation commands.\n     */\n    MultiRangeInlineEditor.prototype._updateCommands = function () {\n        var enabled = (this.hasFocus() && this._ranges.length > 1);\n        _prevMatchCmd.setEnabled(enabled && this._selectedRangeIndex > 0);\n        _nextMatchCmd.setEnabled(enabled && this._selectedRangeIndex !== -1 && this._selectedRangeIndex < this._ranges.length - 1);\n    };\n\n    /**\n     * @override\n     */\n    MultiRangeInlineEditor.prototype.onAdded = function () {\n        // Set the initial position of the selected marker now that we're laid out.\n        this._updateSelectedMarker(false);\n\n        // Call super\n        MultiRangeInlineEditor.prototype.parentClass.onAdded.apply(this, arguments);\n\n        // Initially size the inline widget (calls sizeInlineWidgetToContents())\n        this._ruleListHeightChanged();\n\n        this._updateCommands();\n    };\n\n    /**\n     * Specify the range that is shown in the editor.\n     *\n     * @param {!number} index The index of the range to select, or -1 to deselect all. Index into this._ranges,\n     *      so section headers are not included in the sequence.\n     * @param {boolean} force Whether to re-select the item even if we think it's already selected\n     *     (used if the range list has changed).\n     */\n    MultiRangeInlineEditor.prototype.setSelectedIndex = function (index, force) {\n        var newIndex = Math.min(Math.max(-1, index), this._ranges.length - 1),\n            self = this;\n\n        if (!force && newIndex !== -1 && newIndex === this._selectedRangeIndex) {\n            return;\n        }\n\n        // Remove selected class(es)\n        var $previousItem = (this._selectedRangeIndex >= 0) ? this._ranges[this._selectedRangeIndex].$listItem : null;\n        if ($previousItem) {\n            $previousItem.removeClass(\"selected\");\n        }\n\n        // Clear our listeners on the previous editor since it'll be destroyed in setInlineContent().\n        if (this.editor) {\n            this.editor.off(\".MultiRangeInlineEditor\");\n        }\n\n        this._selectedRangeIndex = newIndex;\n\n        if (newIndex === -1) {\n            // show the message div\n            this.setInlineContent(null);\n            var hasHiddenMatches = this._ranges.length > 0;\n            if (hasHiddenMatches) {\n                this.$messageDiv.text(Strings.INLINE_EDITOR_HIDDEN_MATCHES);\n            } else if (this._messageCB) {\n                this._messageCB(hasHiddenMatches).done(function (msg) {\n                    self.$messageDiv.html(msg);\n                });\n            } else {\n                this.$messageDiv.text(Strings.INLINE_EDITOR_NO_MATCHES);\n            }\n            this.$htmlContent.append(this.$messageDiv);\n            this.sizeInlineWidgetToContents();\n        } else {\n            this.$messageDiv.remove();\n\n            var range = this._getSelectedRange();\n            range.$listItem.addClass(\"selected\");\n\n            // Add new editor\n            this.setInlineContent(range.textRange.document, range.textRange.startLine, range.textRange.endLine);\n            this.editor.focus();\n\n            this._updateEditorMinHeight();\n            this.editor.refresh();\n\n            // Ensure the cursor position is visible in the host editor as the user is arrowing around.\n            this.editor.on(\"cursorActivity.MultiRangeInlineEditor\", this._ensureCursorVisible.bind(this));\n\n            // ensureVisibility is set to false because we don't want to scroll the main editor when the user selects a view\n            this.sizeInlineWidgetToContents();\n\n            this._updateSelectedMarker(true);\n        }\n\n        this._updateCommands();\n    };\n\n    /**\n     * Ensures that the editor's min-height is set so it never gets shorter than the rule list.\n     * This is necessary to make sure the editor's horizontal scrollbar stays at the bottom of the\n     * widget.\n     */\n    MultiRangeInlineEditor.prototype._updateEditorMinHeight = function () {\n        if (!this.editor) {\n            return;\n        }\n\n        // Set the scroller's min-height to the natural height of the rule list, so the editor\n        // always stays at least as tall as the rule list.\n        var ruleListNaturalHeight = this.$related.outerHeight(),\n            headerHeight = $(\".inline-editor-header\", this.$htmlContent).outerHeight();\n\n        // If the widget isn't fully loaded yet, bail--we'll get called again in onAdded().\n        if (!ruleListNaturalHeight || !headerHeight) {\n            return;\n        }\n\n        // We have to set this on the scroller instead of the wrapper because:\n        // * we want the wrapper's actual height to remain \"auto\"\n        // * if we set a min-height on the wrapper, the scroller's height: 100% doesn't\n        //   respect it (height: 100% doesn't seem to work properly with min-height on the parent)\n        $(this.editor.getScrollerElement())\n            .css(\"min-height\", (ruleListNaturalHeight - headerHeight) + \"px\");\n    };\n\n    /** Update inline widget height to reflect changed rule-list height */\n    MultiRangeInlineEditor.prototype._ruleListHeightChanged = function () {\n        // Editor's min height depends on rule list height\n        this._updateEditorMinHeight();\n\n        // Overall widget height may have changed too\n        this.sizeInlineWidgetToContents();\n    };\n\n    MultiRangeInlineEditor.prototype._removeRange = function (range) {\n        // If this is the last range, just close the whole widget\n        if (this._ranges.length <= 1) {\n            this.close();\n            return;  // note: the dispose() that would normally happen below is covered by close()\n        }\n\n        // Now we know there is at least one other range -> found out which one this is\n        var index = this._ranges.indexOf(range);\n\n        // If the range to be removed is the selected one, first switch to another one\n        if (index === this._selectedRangeIndex) {\n            // If possible, select the one below, else select the one above\n            if (index + 1 < this._ranges.length) {\n                this.setSelectedIndex(index + 1);\n            } else {\n                this.setSelectedIndex(index - 1);\n            }\n        }\n\n        // Now we can remove this range\n        range.textRange.dispose();\n        this._ranges.splice(index, 1);\n\n        // Re-render list & section headers\n        this._renderList();\n\n        // Move selection highlight if deletion affected its position\n        if (index < this._selectedRangeIndex) {\n            this._selectedRangeIndex--;\n            this._updateSelectedMarker(true);\n        }\n\n        if (this._ranges.length === 1) {\n            this.$relatedContainer.remove();\n\n            // Refresh the height of the inline editor since we remove\n            // the entire selector list.\n            if (this.editor) {\n                this.editor.refresh();\n            }\n        }\n\n        this._updateCommands();\n    };\n\n    /**\n     * Adds a new range to the inline editor and selects it. The range will be inserted\n     * immediately below the last range for the same document, or at the end of the list\n     * if there are no other ranges for that document.\n     * @param {string} name The label for the new range.\n     * @param {Document} doc The document the range is in.\n     * @param {number} lineStart The starting line of the range, 0-based, inclusive.\n     * @param {number} lineEnd The ending line of the range, 0-based, inclusive.\n     */\n    MultiRangeInlineEditor.prototype.addAndSelectRange = function (name, doc, lineStart, lineEnd) {\n        var newRange = new SearchResultItem({\n                name: name,\n                document: doc,\n                lineStart: lineStart,\n                lineEnd: lineEnd\n            }),\n            i;\n\n        // Insert the new range after the last range from the same doc, or at the\n        // end of the list.\n        for (i = 0; i < this._ranges.length; i++) {\n            if (this._fileComparator(this._ranges[i].textRange.document.file, doc.file) > 0) {\n                break;\n            }\n        }\n        this._ranges.splice(i, 0, newRange);\n\n        // Update rule list display\n        this._renderList();\n\n        // Ensure rule list is visible if there are now multiple results\n        if (this._ranges.length > 1 && !this.$relatedContainer.parent().length) {\n            this.$wrapper.before(this.$relatedContainer);\n        }\n\n        // If added rule is in a collapsed item, expand it for clarity\n        if (this._collapsedFiles[doc.file.fullPath]) {\n            this._toggleSection(doc.file.fullPath);\n        }\n\n        // Select new range, showing it in the editor\n        this.setSelectedIndex(i, true);  // force, since i might be same as before\n\n        this._updateCommands();\n    };\n\n    MultiRangeInlineEditor.prototype._updateSelectedMarker = function (animate) {\n        // If no selection or selection is in a collapsed section, just hide the marker\n        if (this._selectedRangeIndex < 0 || this._collapsedFiles[this._getSelectedRange().textRange.document.file.fullPath]) {\n            this.$selectedMarker.hide();\n            return;\n        }\n\n        var $rangeItem = this._ranges[this._selectedRangeIndex].$listItem;\n\n        // scroll the selection to the rangeItem\n        var containerHeight = this.$relatedContainer.height(),\n            itemTop = $rangeItem.position().top,\n            scrollTop = this.$relatedContainer.scrollTop();\n\n        this.$selectedMarker\n            .show()\n            .toggleClass(\"animate\", animate)\n            .css(\"top\", itemTop)\n            .height($rangeItem.outerHeight());\n\n        if (containerHeight <= 0) {\n            return;\n        }\n\n        var paddingTop = _parseStyleSize($rangeItem.parent(), \"paddingTop\");\n\n        if ((itemTop - paddingTop) < scrollTop) {\n            this.$relatedContainer.scrollTop(itemTop - paddingTop);\n        } else {\n            var itemBottom = itemTop + $rangeItem.height() + _parseStyleSize($rangeItem.parent(), \"paddingBottom\");\n\n            if (itemBottom > (scrollTop + containerHeight)) {\n                this.$relatedContainer.scrollTop(itemBottom - containerHeight);\n            }\n        }\n    };\n\n    /**\n     * Called any time inline is closed, whether manually (via closeThisInline()) or automatically\n     */\n    MultiRangeInlineEditor.prototype.onClosed = function () {\n        // Superclass onClosed() destroys editor\n        MultiRangeInlineEditor.prototype.parentClass.onClosed.apply(this, arguments);\n\n        // de-ref all the Documents in the search results\n        this._ranges.forEach(function (searchResult) {\n            searchResult.textRange.dispose();\n        });\n\n        // Remove event handlers\n        this.$htmlContent.off(\".MultiRangeInlineEditor\");\n        this.$editorHolder.off(\".MultiRangeInlineEditor\");\n    };\n\n    /**\n     * Prevent clicks in the dead areas of the inlineWidget from changing the focus and insertion point in the editor.\n     * This is done by detecting clicks in the inlineWidget that are not inside the editor or the range list and\n     * restoring focus and the insertion point.\n     */\n    MultiRangeInlineEditor.prototype._onClick = function (event) {\n        if (!this.editor) {\n            return;\n        }\n\n        var childEditor = this.editor,\n            editorRoot = childEditor.getRootElement(),\n            editorPos = $(editorRoot).offset();\n\n        function containsClick($parent) {\n            return $parent.find(event.target).length > 0 || $parent[0] === event.target;\n        }\n\n        // Ignore clicks in editor and clicks on filename link\n        // Check clicks on filename link in the context of the current inline widget.\n        if (!containsClick($(editorRoot)) && !containsClick($(\".filename\", this.$htmlContent))) {\n            childEditor.focus();\n            // Only set the cursor if the click isn't in the range list.\n            if (!containsClick(this.$relatedContainer)) {\n                if (event.pageY < editorPos.top) {\n                    childEditor.setCursorPos(0, 0);\n                } else if (event.pageY > editorPos.top + $(editorRoot).height()) {\n                    var lastLine = childEditor.getLastVisibleLine();\n                    childEditor.setCursorPos(lastLine, childEditor.document.getLine(lastLine).length);\n                }\n            }\n        }\n    };\n\n    /**\n     * Based on the position of the cursor in the inline editor, determine whether we need to change the\n     * vertical scroll position of the host editor to ensure that the cursor is visible.\n     */\n    MultiRangeInlineEditor.prototype._ensureCursorVisible = function () {\n        if (!this.editor) {\n            return;\n        }\n\n        if ($.contains(this.editor.getRootElement(), window.document.activeElement)) {\n            var hostScrollPos = this.hostEditor.getScrollPos(),\n                cursorCoords = this.editor._codeMirror.cursorCoords();\n\n            // Vertically, we want to set the scroll position relative to the overall host editor, not\n            // the lineSpace of the widget itself. We don't want to modify the horizontal scroll position.\n            var scrollerTop = this.hostEditor.getVirtualScrollAreaTop();\n            this.hostEditor._codeMirror.scrollIntoView({\n                left: hostScrollPos.x,\n                top: cursorCoords.top - scrollerTop,\n                right: hostScrollPos.x,\n                bottom: cursorCoords.bottom - scrollerTop\n            });\n        }\n    };\n\n    /**\n     * Overwrite InlineTextEditor's _onLostContent to do nothing if the document's file is deleted\n     * (deletes are handled via TextRange's lostSync).\n     */\n    MultiRangeInlineEditor.prototype._onLostContent = function (event, cause) {\n        // Ignore when the editor's content got lost due to a deleted file\n        if (cause && cause.type === \"deleted\") { return; }\n        // Else yield to the parent's implementation\n        return MultiRangeInlineEditor.prototype.parentClass._onLostContent.apply(this, arguments);\n    };\n\n    /**\n     * @return {Array.<SearchResultItem>}\n     */\n    MultiRangeInlineEditor.prototype._getRanges = function () {\n        return this._ranges;\n    };\n\n    /**\n     * @return {!SearchResultItem}\n     */\n    MultiRangeInlineEditor.prototype._getSelectedRange = function () {\n        return this._selectedRangeIndex >= 0 ? this._ranges[this._selectedRangeIndex] : null;\n    };\n\n    /**\n     * Move the selection up or down, skipping any collapsed groups. If selection is currently IN a\n     * collapsed group, we expand it first so that other items in the same file are eligible.\n     */\n    MultiRangeInlineEditor.prototype._selectNextPrev = function (dir) {\n        if (this._selectedRangeIndex === -1) {\n            return;\n        }\n\n        // Traverse up or down the list until we find an item eligible for selection\n        var origDoc = this._ranges[this._selectedRangeIndex].textRange.document,\n            i;\n        for (i = this._selectedRangeIndex + dir; i >= 0 && i < this._ranges.length; i += dir) {\n            var doc = this._ranges[i].textRange.document;\n\n            // If first candidate is in same collapsed group as current selection, expand it\n            if (doc === origDoc && this._collapsedFiles[doc.file.fullPath]) {\n                this._toggleSection(doc.file.fullPath);\n            }\n\n            // Only consider expanded groups now\n            if (!this._collapsedFiles[doc.file.fullPath]) {\n                this.setSelectedIndex(i);\n                return;\n            }\n        }\n        // If we got here, we couldn't find any eligible item - so do nothing. Happens if selection is\n        // already the first/last item, or if all remaining items above/below the selection are collapsed.\n    };\n\n    /**\n     * Display the next range in the range list\n     */\n    MultiRangeInlineEditor.prototype._selectNextRange = function () {\n        this._selectNextPrev(1);\n    };\n\n    /**\n     *  Display the previous range in the range list\n     */\n    MultiRangeInlineEditor.prototype._selectPreviousRange = function () {\n        this._selectNextPrev(-1);\n    };\n\n    /**\n     * Sizes the inline widget height to be the maximum between the range list height and the editor height\n     * @override\n     */\n    MultiRangeInlineEditor.prototype.sizeInlineWidgetToContents = function () {\n        // Size the code mirror editors height to the editor content\n        MultiRangeInlineEditor.prototype.parentClass.sizeInlineWidgetToContents.call(this);\n\n        // Size the widget height to the max between the editor/message content and the related ranges list\n        var widgetHeight = Math.max(this.$related.height(),\n                                    this.$header.outerHeight() +\n                                        (this._selectedRangeIndex === -1 ? this.$messageDiv.outerHeight() : this.$editorHolder.height()));\n\n        if (widgetHeight) {\n            this.hostEditor.setInlineWidgetHeight(this, widgetHeight, false);\n        }\n    };\n\n    /**\n     * Called when the editor containing the inline is made visible. Updates UI based on\n     * state that might have changed while the editor was hidden.\n     */\n    MultiRangeInlineEditor.prototype.onParentShown = function () {\n        MultiRangeInlineEditor.prototype.parentClass.onParentShown.apply(this, arguments);\n        this._updateSelectedMarker(false);\n    };\n\n    /**\n     * Refreshes the height of the inline editor and all child editors.\n     * @override\n     */\n    MultiRangeInlineEditor.prototype.refresh = function () {\n        MultiRangeInlineEditor.prototype.parentClass.refresh.apply(this, arguments);\n        this.sizeInlineWidgetToContents();\n        if (this.editor) {\n            this.editor.refresh();\n        }\n    };\n\n    /**\n     * Returns the currently focused MultiRangeInlineEditor.\n     * @return {MultiRangeInlineEditor}\n     */\n    function getFocusedMultiRangeInlineEditor() {\n        var focusedWidget = EditorManager.getFocusedInlineWidget();\n        if (focusedWidget instanceof MultiRangeInlineEditor) {\n            return focusedWidget;\n        }\n        return null;\n\n    }\n\n    /**\n     * Previous Range command handler\n     */\n    function _previousRange() {\n        var focusedMultiRangeInlineEditor = getFocusedMultiRangeInlineEditor();\n        if (focusedMultiRangeInlineEditor) {\n            focusedMultiRangeInlineEditor._selectPreviousRange();\n        }\n    }\n\n    /**\n     * Next Range command handler\n     */\n    function _nextRange() {\n        var focusedMultiRangeInlineEditor = getFocusedMultiRangeInlineEditor();\n        if (focusedMultiRangeInlineEditor) {\n            focusedMultiRangeInlineEditor._selectNextRange();\n        }\n    }\n\n    _prevMatchCmd = CommandManager.register(Strings.CMD_QUICK_EDIT_PREV_MATCH, Commands.QUICK_EDIT_PREV_MATCH, _previousRange);\n    _prevMatchCmd.setEnabled(false);\n    _nextMatchCmd = CommandManager.register(Strings.CMD_QUICK_EDIT_NEXT_MATCH, Commands.QUICK_EDIT_NEXT_MATCH, _nextRange);\n    _nextMatchCmd.setEnabled(false);\n\n    exports.MultiRangeInlineEditor = MultiRangeInlineEditor;\n    exports.getFocusedMultiRangeInlineEditor = getFocusedMultiRangeInlineEditor;\n});\n"],"file":"MultiRangeInlineEditor.js"}
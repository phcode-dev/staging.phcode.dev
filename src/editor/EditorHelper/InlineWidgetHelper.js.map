{"version":3,"sources":["editor/EditorHelper/InlineWidgetHelper.js"],"names":["define","require","exports","module","AnimationUtils","Async","CodeMirror","addInlineWidget","pos","inlineWidget","scrollLineIntoView","self","this","queue","_inlineWidgetQueues","line","deferred","$","Deferred","PromiseQueue","add","_addInlineWidgetInternal","promise","removeAllInlineWidgetsForLine","done","undefined","_codeMirror","scrollIntoView","info","addLineWidget","htmlContent","coverGutter","noHScroll","on","_removeInlineWidgetInternal","_inlineWidgets","push","$htmlContent","height","animateUsingClass","resolve","onAdded","removeAllInlineWidgets","widgets","concat","getInlineWidgets","doInParallel","removeInlineWidget","bind","finishRemoving","removeLineWidget","closePromise","_removeInlineWidgetFromList","isFullyVisible","lineNum","lineInfo","widgetInfos","length","allWidgetInfos","map","w","indexOf","l","i","splice","isClosed","onClosed","getFocusedInlineWidget","result","forEach","widget","hasFocus","setInlineWidgetHeight","ensureVisible","node","oldHeight","changed","isAttached","updateHeight","setOuterHeight","finishAnimating","e","target","off","hasClass","style","window","setTimeout","offset","position","scrollerTop","getVirtualScrollAreaTop","left","top","right","bottom","_getInlineWidgetLineNumber","getLineNumber","addHelpers","Editor","prototype"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * self program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * self program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with self program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Editor instance helpers for showing error popups. Only to be used from Editor.js.\n */\n\ndefine(function (require, exports, module) {\n\n    const AnimationUtils = require(\"utils/AnimationUtils\"),\n        Async = require(\"utils/Async\"),\n        CodeMirror = require(\"thirdparty/CodeMirror/lib/codemirror\");\n\n    /**\n     * ****** Update actual public API doc in Editor.js *****\n     *\n     * Adds an inline widget below the given line. If any inline widget was already open for that\n     * line, it is closed without warning.\n     * @param {!{line:number, ch:number}} pos  Position in text to anchor the inline.\n     * @param {!InlineWidget} inlineWidget The widget to add.\n     * @param {boolean=} scrollLineIntoView Scrolls the associated line into view. Default true.\n     * @return {$.Promise} A promise object that is resolved when the widget has been added (but might\n     *     still be animating open). Never rejected.\n     */\n    function addInlineWidget(pos, inlineWidget, scrollLineIntoView) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        let queue = self._inlineWidgetQueues[pos.line],\n            deferred = new $.Deferred();\n        if (!queue) {\n            queue = new Async.PromiseQueue();\n            self._inlineWidgetQueues[pos.line] = queue;\n        }\n        queue.add(function () {\n            self._addInlineWidgetInternal(pos, inlineWidget, scrollLineIntoView, deferred);\n            return deferred.promise();\n        });\n        return deferred.promise();\n    }\n\n    /**\n     * @private\n     * Does the actual work of addInlineWidget().\n     */\n    function _addInlineWidgetInternal(pos, inlineWidget, scrollLineIntoView, deferred) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n\n        self.removeAllInlineWidgetsForLine(pos.line).done(function () {\n            if (scrollLineIntoView === undefined) {\n                scrollLineIntoView = true;\n            }\n\n            if (scrollLineIntoView) {\n                self._codeMirror.scrollIntoView(pos);\n            }\n\n            inlineWidget.info = self._codeMirror.addLineWidget(pos.line, inlineWidget.htmlContent,\n                { coverGutter: true, noHScroll: true });\n            CodeMirror.on(inlineWidget.info.line, \"delete\", function () {\n                self._removeInlineWidgetInternal(inlineWidget);\n            });\n            self._inlineWidgets.push(inlineWidget);\n\n            // Set up the widget to start closed, then animate open when its initial height is set.\n            inlineWidget.$htmlContent.height(0);\n            AnimationUtils.animateUsingClass(inlineWidget.htmlContent, \"animating\")\n                .done(function () {\n                    deferred.resolve();\n                });\n\n            // Callback to widget once parented to the editor. The widget should call back to\n            // setInlineWidgetHeight() in order to set its initial height and animate open.\n            inlineWidget.onAdded();\n        });\n    }\n\n    /**\n     * ****** Update actual public API doc in Editor.js *****\n     *\n     * Removes all inline widgets\n     */\n    function removeAllInlineWidgets() {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        // copy the array because _removeInlineWidgetInternal will modify the original\n        let widgets = [].concat(self.getInlineWidgets());\n\n        return Async.doInParallel(\n            widgets,\n            self.removeInlineWidget.bind(self)\n        );\n    }\n\n    /**\n     * ****** Update actual public API doc in Editor.js *****\n     * Removes the given inline widget.\n     * @param {number} inlineWidget The widget to remove.\n     * @return {$.Promise} A promise that is resolved when the inline widget is fully closed and removed from the DOM.\n     */\n    function removeInlineWidget(inlineWidget) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        let deferred = new $.Deferred();\n\n        function finishRemoving() {\n            self._codeMirror.removeLineWidget(inlineWidget.info);\n            self._removeInlineWidgetInternal(inlineWidget);\n            deferred.resolve();\n        }\n\n        if (!inlineWidget.closePromise) {\n            // Remove the inline widget from our internal list immediately, so\n            // everyone external to us knows it's essentially already gone. We\n            // don't want to wait until it's done animating closed (but we do want\n            // the other stuff in _removeInlineWidgetInternal to wait until then).\n            self._removeInlineWidgetFromList(inlineWidget);\n\n            // If we're not visible (in which case the widget will have 0 client height),\n            // don't try to do the animation, because nothing will happen and we won't get\n            // called back right away. (The animation would happen later when we switch\n            // back to the editor.)\n            if (self.isFullyVisible()) {\n                AnimationUtils.animateUsingClass(inlineWidget.htmlContent, \"animating\")\n                    .done(finishRemoving);\n                inlineWidget.$htmlContent.height(0);\n            } else {\n                finishRemoving();\n            }\n            inlineWidget.closePromise = deferred.promise();\n        }\n        return inlineWidget.closePromise;\n    }\n\n    /**\n     * ****** Update actual public API doc in Editor.js *****\n     * Removes all inline widgets for a given line\n     * @param {number} lineNum The line number to modify\n     */\n    function removeAllInlineWidgetsForLine(lineNum) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        let lineInfo = self._codeMirror.lineInfo(lineNum),\n            widgetInfos = (lineInfo && lineInfo.widgets) ? [].concat(lineInfo.widgets) : null;\n\n        if (widgetInfos && widgetInfos.length) {\n            // Map from CodeMirror LineWidget to Brackets InlineWidget\n            let inlineWidget,\n                allWidgetInfos = self._inlineWidgets.map(function (w) {\n                    return w.info;\n                });\n\n            return Async.doInParallel(\n                widgetInfos,\n                function (info) {\n                    // Lookup the InlineWidget object using the same index\n                    inlineWidget = self._inlineWidgets[allWidgetInfos.indexOf(info)];\n                    if (inlineWidget) {\n                        return self.removeInlineWidget(inlineWidget);\n                    }\n                    return new $.Deferred().resolve().promise();\n\n                }\n            );\n        }\n        return new $.Deferred().resolve().promise();\n\n    }\n\n    /**\n     * Cleans up the given inline widget from our internal list of widgets. It's okay\n     * to call self multiple times for the same widget--it will just do nothing if\n     * the widget has already been removed.\n     * @param {InlineWidget} inlineWidget  an inline widget.\n     */\n    function _removeInlineWidgetFromList(inlineWidget) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        let l = self._inlineWidgets.length,\n            i;\n        for (i = 0; i < l; i++) {\n            if (self._inlineWidgets[i] === inlineWidget) {\n                self._inlineWidgets.splice(i, 1);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Removes the inline widget from the editor and notifies it to clean itself up.\n     * @param {InlineWidget} inlineWidget  an inline widget.\n     */\n    function _removeInlineWidgetInternal(inlineWidget) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        if (!inlineWidget.isClosed) {\n            self._removeInlineWidgetFromList(inlineWidget);\n            inlineWidget.onClosed();\n            inlineWidget.isClosed = true;\n        }\n    }\n\n    /**\n     * ****** Update actual public API doc in Editor.js *****\n     * Returns a list of all inline widgets currently open in self editor. Each entry contains the\n     * inline's id, and the data parameter that was passed to addInlineWidget().\n     * @return {!Array.<{id:number, data:Object}>}\n     */\n    function getInlineWidgets() {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        return self._inlineWidgets;\n    }\n\n    /**\n     * ****** Update actual public API doc in Editor.js *****\n     * Returns the currently focused inline widget, if any.\n     * @return {?InlineWidget}\n     */\n    function getFocusedInlineWidget() {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        let result = null;\n\n        self.getInlineWidgets().forEach(function (widget) {\n            if (widget.hasFocus()) {\n                result = widget;\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * ****** Update actual public API doc in Editor.js *****\n     * Sets the height of an inline widget in self editor.\n     * @param {!InlineWidget} inlineWidget The widget whose height should be set.\n     * @param {!number} height The height of the widget.\n     * @param {boolean=} ensureVisible Whether to scroll the entire widget into view. Default false.\n     */\n    function setInlineWidgetHeight(inlineWidget, height, ensureVisible) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        let node = inlineWidget.htmlContent,\n            oldHeight = (node && $(node).height()) || 0,\n            changed = (oldHeight !== height),\n            isAttached = inlineWidget.info !== undefined;\n\n        function updateHeight() {\n            // Notify CodeMirror for the height change.\n            if (isAttached) {\n                inlineWidget.info.changed();\n            }\n        }\n\n        function setOuterHeight() {\n            function finishAnimating(e) {\n                if (e.target === node) {\n                    updateHeight();\n                    $(node).off(\"webkitTransitionEnd\", finishAnimating);\n                }\n            }\n            $(node).height(height);\n            if ($(node).hasClass(\"animating\")) {\n                $(node).on(\"webkitTransitionEnd\", finishAnimating);\n            } else {\n                updateHeight();\n            }\n        }\n\n        // Make sure we set an explicit height on the widget, so children can use things like\n        // min-height if they want.\n        if (changed || !node.style.height) {\n            // If we're animating, set the wrapper's height on a timeout so the layout is finished before we animate.\n            if ($(node).hasClass(\"animating\")) {\n                window.setTimeout(setOuterHeight, 0);\n            } else {\n                setOuterHeight();\n            }\n        }\n\n        if (ensureVisible && isAttached) {\n            let offset = $(node).offset(), // offset relative to document\n                position = $(node).position(), // position within parent linespace\n                scrollerTop = self.getVirtualScrollAreaTop();\n\n            self._codeMirror.scrollIntoView({\n                left: position.left,\n                top: offset.top - scrollerTop,\n                right: position.left, // don't try to make the right edge visible\n                bottom: offset.top + height - scrollerTop\n            });\n        }\n    }\n\n    /**\n     * @private\n     * Get the starting line number for an inline widget.\n     * @param {!InlineWidget} inlineWidget\n     * @return {number} The line number of the widget or -1 if not found.\n     */\n    function _getInlineWidgetLineNumber(inlineWidget) {\n        // eslint-disable-next-line no-invalid-this\n        let self = this;\n        return self._codeMirror.getLineNumber(inlineWidget.info.line);\n    }\n\n    /**\n     * add required helpers to editor\n     * @param Editor\n     */\n    function addHelpers(Editor) {\n        // only private Editor APIs should be assigned below. Public APIs should be updated in Editor.js only.\n        Editor.prototype._addInlineWidgetInternal = _addInlineWidgetInternal;\n        Editor.prototype._removeInlineWidgetFromList = _removeInlineWidgetFromList;\n        Editor.prototype._removeInlineWidgetInternal = _removeInlineWidgetInternal;\n        Editor.prototype._getInlineWidgetLineNumber = _getInlineWidgetLineNumber;\n    }\n\n    exports.addHelpers = addHelpers;\n    exports.addInlineWidget = addInlineWidget;\n    exports.removeAllInlineWidgets = removeAllInlineWidgets;\n    exports.removeInlineWidget = removeInlineWidget;\n    exports.removeAllInlineWidgetsForLine = removeAllInlineWidgetsForLine;\n    exports.getInlineWidgets = getInlineWidgets;\n    exports.getFocusedInlineWidget = getFocusedInlineWidget;\n    exports.setInlineWidgetHeight = setInlineWidgetHeight;\n});\n"],"file":"InlineWidgetHelper.js"}
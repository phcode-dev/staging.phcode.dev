{"version":3,"sources":["phoenix/virtualServer/webserver.js"],"names":["importScripts","self","Serve","_serverBroadcastChannel","BroadcastChannel","fs","Path","path","instrumentedURLs","responseListeners","_getNewRequestID","Math","round","random","_getAllInstrumentedFullPaths","allURLs","rootPaths","Object","keys","subPath","push","normalize","formatContentDisposition","stats","filename","basename","modified","mtime","toUTCString","size","async","_wait","timeMs","Promise","resolve","setTimeout","_resolvingRead","encoding","readFile","error","contents","_resolvingStat","stat","FILE_READ_RETRY_COUNT","BACKOFF_TIME_MS","serve","download","phoenixInstanceID","reject","buildResponse","responseData","Response","body","config","serveError","err","code","HtmlFormatter","format404","format500","serveInstrumentedFile","includes","endsWith","_debugLivePreviewLog","requestID","postMessage","type","response","formatFile","headers","serveFile","i","fileResponse","BYTE_ARRAY_ENCODING","status","serveDir","maybeServeIndexFile","serveDirListing","indexPath","join","Config","disableIndexes","readdir","entries","formatDir","virtualServerBaseURL","fileStat","isDirectory","e","setInstrumentedURLs","event","data","root","paths","ports","processVirtualServerMessage","eventType","console","log","onmessage"],"mappings":"AAwBA,GAHAA,cAAc,2CACdA,cAAc,oCAEVC,KAAKC,MAAM,CACX,MAAMC,wBAA0B,IAAIC,iBAAiB,4BAC/CC,GAAKJ,KAAKI,GACVC,KAAOL,KAAKM,KAClB,IAAIC,iBAAmB,GACnBC,kBAAoB,GAExB,SAASC,mBACL,OAAOC,KAAKC,MAAqB,KAAdD,KAAKE,UAG5B,SAASC,+BACL,IAAIC,QAAU,GACd,IAAI,IAAIC,aAAaC,OAAOC,KAAKV,kBAC7B,IAAI,IAAIW,WAAWX,iBAAiBQ,WAChCD,QAAQK,KAAKd,KAAKe,UAAUL,UAAYG,UAGhD,OAAOJ,QAIX,SAASO,yBAAyBf,KAAMgB,OACpC,MAAMC,SAAWlB,KAAKmB,SAASlB,MACzBmB,SAAWH,MAAMI,MAAMC,cAC7B,+BAAgCJ,iCAAiCE,mBAAmBH,MAAMM,QAG9FC,eAAeC,MAAMC,QACjB,OAAO,IAAIC,QAASC,UAChBC,WAAWD,QAASF,UAK5BF,eAAeM,eAAe7B,KAAM8B,UAChC,OAAO,IAAIJ,QAASC,UAChB7B,GAAGiC,SAAS/B,KAAM8B,SAAU,SAAUE,MAAOC,UACzCN,QAAQ,CAACK,MAAAA,MAAOC,SAAAA,eAK5BV,eAAeW,eAAelC,MAC1B,OAAO,IAAI0B,QAASC,UAChB7B,GAAGqC,KAAKnC,KAAM,SAAUgC,MAAOhB,OAC3BW,QAAQ,CAACK,MAAAA,MAAOhB,MAAAA,YAI5B,MAAMoB,sBAAwB,EAC1BC,gBAAkB,GAEhBC,MAAQf,eAAgBvB,KAAMuC,SAAUC,mBAE1C,OADAxC,KAAOD,KAAKe,UAAUd,MACf,IAAI0B,QAAQH,MAAOI,QAASc,UAC/B,SAASC,cAAcC,cACnB,OAAO,IAAIC,SAASD,aAAaE,KAAMF,aAAaG,QAGxD,SAASC,WAAW/C,KAAMgD,KACtB,GAAiB,WAAbA,IAAIC,KACJ,OAAOtB,QAAQe,cAAcQ,cAAcC,UAAUnD,QAEzD2B,QAAQe,cAAcQ,cAAcE,UAAUpD,KAAMgD,OAGxD,SAASK,sBAAsBrD,MAC3B,IAAIQ,QAAUD,+BAEd,IAAIiC,oBACEhC,QAAQ8C,SAAStD,QAAUA,KAAKuD,SAAS,SAAWvD,KAAKuD,SAAS,QACpE,OAAO,EAEX7D,KAAK8D,qBAAqB,4CAA6CxD,MACvE,MAAMyD,UAAYtD,mBAkBlB,OAjBAP,wBAAwB8D,YAAY,CAChCC,KAAM,yBACN3D,KAAAA,KACAyD,UAAAA,UACAjB,kBAAAA,oBAEJtC,kBAAkBuD,WAAa,SAAUG,UACrC,GAAyB,KAAtBA,SAAS3B,WAAoB2B,SAAS3B,SAGrC,OAFAvC,KAAK8D,qBACD,8DAA+DxD,MAC5D2B,QAAQe,cAAcQ,cAAcC,UAAUnD,QAEzD,MAAM2C,aAAeO,cAAcW,WAAW7D,KAAM4D,SAAS3B,UACvD6B,QAAUF,SAASE,SAAW,GACpCnB,aAAaG,OAAOgB,QAAU,IAAKnB,aAAaG,OAAOgB,WAAYA,SACnEnC,QAAQ,IAAIiB,SAASD,aAAaE,KAAMF,aAAaG,WAElD,EAGXvB,eAAewC,UAAU/D,KAAMgB,OAC3B,IAAIgC,IAAM,KACV,IAAI,IAAIgB,EAAI,EAAGA,GAAK5B,sBAAuB4B,IAAI,CAG3C,IAAIC,mBAAqBpC,eAAe7B,KAAMF,GAAGoE,qBACjD,GAAGD,aAAajC,MAAM,CAClBgB,IAAMiB,aAAajC,YACbR,MAAMwC,EAAI3B,iBAChB,SAEJ,MAAMM,aAAeO,cAAcW,WAAW7D,KAAMiE,aAAahC,UASjE,OANmC,MAA/BU,aAAaG,OAAOqB,QAAkB5B,WACtCI,aAAaG,OAAOgB,QAAQ,uBACxB/C,yBAAyBf,KAAMgB,aAGvCW,QAAQ,IAAIiB,SAASD,aAAaE,KAAMF,aAAaG,SAGzDC,WAAW/C,KAAMgD,KAIrB,SAASoB,SAASpE,MAEd,SAASqE,sBACL,GAAGrE,KAAKuD,SAAS,MAGb,YADAe,kBAIJ,MAAMC,UAAYxE,KAAKyE,KAAKxE,KAAM,cAClCF,GAAGqC,KAAKoC,UAAW,SAAUvB,IAAKhC,OAC1BgC,IACiB,WAAbA,IAAIC,MAAsBwB,OAAOC,eAKjC3B,WAAW/C,KAAMgD,KAHjBsB,kBAOJP,UAAUQ,UAAWvD,SAKjC,SAASsD,kBACLxE,GAAG6E,QAAQ3E,KAAM,SAAUgD,IAAK4B,SAC5B,GAAI5B,IACA,OAAOD,WAAW/C,KAAMgD,KAG5B,MAAML,aAAeO,cAAc2B,UAAUC,qBAAsB9E,KAAM4E,SACzEjD,QAAQ,IAAIiB,SAASD,aAAaE,KAAMF,aAAaG,WAI7DuB,sBAGJ,IAAIrB,IAAM,KACV,IACI,GAAGK,sBAAsBrD,MACrB,OAEJ,IAAI,IAAIgE,EAAI,EAAGA,GAAK5B,sBAAuB4B,IAAI,CAC3C,IAAIe,eAAiB7C,eAAelC,MACpC,IAAG+E,SAAS/C,MAKZ,OAAI+C,SAAS/D,MAAMgE,cACRZ,SAASpE,MAEb+D,UAAU/D,KAAM+E,SAAS/D,OAP5BgC,IAAM+B,SAAS/C,YACTR,MAAMwC,EAAI3B,iBASxB,OAAOU,WAAW/C,KAAMgD,KAC1B,MAAOiC,GACLxC,OAAOwC,OAKnB1D,eAAe2D,oBAAoBC,OAC/B,MAAMC,KAAOD,MAAMC,KACbC,KAAOD,KAAKC,KACdC,MAAQF,KAAKE,MACjB5F,KAAK8D,qBAAqB,sCAAuC4B,MACjEnF,iBAAiBoF,MAAQC,MACzBH,MAAMI,MAAM,GAAG7B,aAAY,GAK/B,SAAS8B,4BAA4BL,OACjC,IAAIM,UACJ,OADgBN,MAAMC,MAAQD,MAAMC,KAAKzB,MAEzC,IAAK,mBACD,MAAMF,UAAY0B,MAAMC,KAAK3B,UAC7B,GAAG0B,MAAMC,KAAK3B,WAAavD,kBAAkBuD,WAGzC,OAFAvD,kBAAkBuD,WAAW0B,MAAMC,aAC5BlF,kBAAkBuD,YAClB,GAVnBiC,QAAQC,IAAI,uBAeZ/F,wBAAwBgG,UAAYJ,4BAEpC9F,KAAKC,MAAQ,CACT2C,MAAAA,MACA4C,oBAAAA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * modified by core.ai, based on work by David Humphrey <david.humphrey@senecacolleage.ca> (@humphd)\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* global Config, virtualServerBaseURL, HtmlFormatter*/\n\nimportScripts('phoenix/virtualServer/html-formatter.js');\nimportScripts('phoenix/virtualServer/config.js');\n\nif(!self.Serve){\n    const _serverBroadcastChannel = new BroadcastChannel(\"virtual_server_broadcast\");\n    const fs = self.fs;\n    const Path = self.path;\n    let instrumentedURLs = {},\n        responseListeners = {};\n\n    function _getNewRequestID() {\n        return Math.round( Math.random()*1000000000000);\n    }\n\n    function _getAllInstrumentedFullPaths() {\n        let allURLs = [];\n        for(let rootPaths of Object.keys(instrumentedURLs)){\n            for(let subPath of instrumentedURLs[rootPaths]){\n                allURLs.push(Path.normalize(rootPaths + subPath));\n            }\n        }\n        return allURLs;\n    }\n\n    // https://tools.ietf.org/html/rfc2183\n    function formatContentDisposition(path, stats) {\n        const filename = Path.basename(path);\n        const modified = stats.mtime.toUTCString();\n        return `attachment; filename=\"${filename}\"; modification-date=\"${modified}\"; size=${stats.size};`;\n    }\n\n    async function _wait(timeMs) {\n        return new Promise((resolve)=>{\n            setTimeout(resolve, timeMs);\n        });\n    }\n\n    // fs read that always resolves even if there is error\n    async function _resolvingRead(path, encoding) {\n        return new Promise((resolve)=>{\n            fs.readFile(path, encoding, function (error, contents) {\n                resolve({error, contents});\n            });\n        });\n    }\n    // fs stat that always resolves even if there is error\n    async function _resolvingStat(path) {\n        return new Promise((resolve)=>{\n            fs.stat(path, function (error, stats) {\n                resolve({error, stats});\n            });\n        });\n    }\n    const FILE_READ_RETRY_COUNT = 5,\n        BACKOFF_TIME_MS = 10;\n\n    const serve = async function (path, download, phoenixInstanceID) {\n        path = Path.normalize(path);\n        return new Promise(async (resolve, reject) => { // eslint-disable-line\n            function buildResponse(responseData) {\n                return new Response(responseData.body, responseData.config);\n            }\n\n            function serveError(path, err) {\n                if (err.code === 'ENOENT') {\n                    return resolve(buildResponse(HtmlFormatter.format404(path)));\n                }\n                resolve(buildResponse(HtmlFormatter.format500(path, err)));\n            }\n\n            function serveInstrumentedFile(path) {\n                let allURLs = _getAllInstrumentedFullPaths();\n                // html and htm files are always served by phoenix to prevent non instrumented transient content\n                if(!phoenixInstanceID ||\n                    (!allURLs.includes(path) && !path.endsWith(\"htm\") && !path.endsWith(\"html\"))){\n                    return false;\n                }\n                self._debugLivePreviewLog(\"Service worker: serving instrumented file\", path);\n                const requestID = _getNewRequestID();\n                _serverBroadcastChannel.postMessage({\n                    type: \"getInstrumentedContent\",\n                    path,\n                    requestID,\n                    phoenixInstanceID\n                });\n                responseListeners[requestID] = function (response) {\n                    if(response.contents !== \"\" && !response.contents){\n                        self._debugLivePreviewLog(\n                            \"Service worker: no instrumented file received from phoenix!\", path);\n                        return resolve(buildResponse(HtmlFormatter.format404(path)));\n                    }\n                    const responseData = HtmlFormatter.formatFile(path, response.contents);\n                    const headers = response.headers || {};\n                    responseData.config.headers = { ...responseData.config.headers, ...headers};\n                    resolve(new Response(responseData.body, responseData.config));\n                };\n                return true;\n            }\n\n            async function serveFile(path, stats) {\n                let err = null;\n                for(let i = 1; i <= FILE_READ_RETRY_COUNT; i++){\n                    // sometimes there is read after write contention in native fs between main thread and worker.\n                    // so we retry\n                    let fileResponse = await _resolvingRead(path, fs.BYTE_ARRAY_ENCODING);\n                    if(fileResponse.error){\n                        err = fileResponse.error;\n                        await _wait(i * BACKOFF_TIME_MS);\n                        continue;\n                    }\n                    const responseData = HtmlFormatter.formatFile(path, fileResponse.contents);\n\n                    // If we are supposed to serve this file or download, add headers\n                    if (responseData.config.status === 200 && download) {\n                        responseData.config.headers['Content-Disposition'] =\n                            formatContentDisposition(path, stats);\n                    }\n\n                    resolve(new Response(responseData.body, responseData.config));\n                    return;\n                }\n                serveError(path, err);\n            }\n\n            // Either serve /index.html (default index) or / (directory listing)\n            function serveDir(path) {\n\n                function maybeServeIndexFile() {\n                    if(path.endsWith(\"//\")){\n                        // this is for us to override and show the directory listing if the path ends with //\n                        serveDirListing();\n                        return;\n                    }\n\n                    const indexPath = Path.join(path, 'index.html');\n                    fs.stat(indexPath, function (err, stats) {\n                        if (err) {\n                            if (err.code === 'ENOENT' && !Config.disableIndexes) {\n                                // Fallback to a directory listing instead\n                                serveDirListing();\n                            } else {\n                                // Let the error (likely 404) pass through instead\n                                serveError(path, err);\n                            }\n                        } else {\n                            // Index file found, serve that instead\n                            serveFile(indexPath, stats);\n                        }\n                    });\n                }\n\n                function serveDirListing() {\n                    fs.readdir(path, function (err, entries) {\n                        if (err) {\n                            return serveError(path, err);\n                        }\n\n                        const responseData = HtmlFormatter.formatDir(virtualServerBaseURL, path, entries);\n                        resolve(new Response(responseData.body, responseData.config));\n                    });\n                }\n\n                maybeServeIndexFile();\n            }\n\n            let err = null;\n            try{\n                if(serveInstrumentedFile(path)){\n                    return;\n                }\n                for(let i = 1; i <= FILE_READ_RETRY_COUNT; i++){\n                    let fileStat = await _resolvingStat(path);\n                    if(fileStat.error){\n                        err = fileStat.error;\n                        await _wait(i * BACKOFF_TIME_MS);\n                        continue;\n                    }\n                    if (fileStat.stats.isDirectory()) {\n                        return serveDir(path);\n                    }\n                    return serveFile(path, fileStat.stats);\n\n                }\n                return serveError(path, err);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    async function setInstrumentedURLs(event) {\n        const data = event.data;\n        const root = data.root,\n            paths = data.paths;\n        self._debugLivePreviewLog(\"Service worker: setInstrumentedURLs\", data);\n        instrumentedURLs[root] = paths;\n        event.ports[0].postMessage(true);// acknowledge for the other side to resolve promise\n    }\n\n    console.log(\"service worker init\");\n\n    function processVirtualServerMessage(event) {\n        let eventType = event.data && event.data.type;\n        switch (eventType) {\n        case 'REQUEST_RESPONSE':\n            const requestID = event.data.requestID;\n            if(event.data.requestID && responseListeners[requestID]){\n                responseListeners[requestID](event.data);\n                delete responseListeners[requestID];\n                return true;\n            }\n        }\n    }\n\n    _serverBroadcastChannel.onmessage = processVirtualServerMessage;\n\n    self.Serve = {\n        serve,\n        setInstrumentedURLs\n    };\n\n}\n"],"file":"webserver.js"}
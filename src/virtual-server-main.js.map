{"version":3,"sources":["virtual-server-main.js"],"names":["importScripts","_debugSWCacheLogs","CACHE_FILE_NAME","CACHE_FS_PATH","workbox","setConfig","debug","Route","routing","cacheFirst","strategies","CacheFirst","StaleWhileRevalidate","ExpirationPlugin","expiration","CacheExpiration","DAYS_30_IN_SEC","CACHE_NAME_EVERYTHING","CACHE_NAME_CORE_SCRIPTS","CACHE_NAME_EXTERNAL","ExpirationManager","everything","maxAgeSeconds","coreScripts","external","_debugCacheLog","args","console","log","_removeParams","url","indexOf","substring","location","href","self","_debugLivePreviewLog","_debugSWLivePreviewLogs","baseURL","lastIndexOf","endsWith","CACHE_MANIFEST_URL","virtualServerBaseURL","Config","route","wwwRegex","RegExp","_isVirtualServing","startsWith","_shouldVirtualServe","request","_updateTTL","cacheName","urls","length","updateTimestamp","_getCurrentCacheManifest","Promise","resolve","fs","readFile","err","data","JSON","parse","_putCurrentCacheManifest","manifestObject","writeFile","stringify","error","_getNewCacheManifest","fetch","then","response","json","catch","_fixCache","currentCacheManifest","newCacheManifest","currentCacheKeys","Object","keys","newCacheKeys","reject","caches","open","cache","async","changedContentURLs","deletePromises","forEach","_index","_array","relativeURL","push","delete","all","addAll","registerRoute","path","pathname","match","download","phoenixInstanceID","decodeURI","pathSplit","split","replace","shift","join","Serve","serve","Response","redirect","refreshInProgress","_refreshCache","event","updatedFilesCount","ports","postMessage","e","_isCacheableExternalUrl","EXTERNAL_URLS","start","addEventListener","eventType","type","skipWaiting","debugMode","logLivePreview","__WB_DISABLE_DEV_LOGS","setInstrumentedURLs","msgProcessed","processVirtualServerMessage","DONT_CACHE_BASE_URLS","origin","_isNotCacheableUrl","CORE_SCRIPTS_URLS","_isCoreScript","coreScript","_belongsToEverythingCache","destination","disAllowedExtensions","test","allCachedRoutes","method","plugins","purgeOnQuotaError","freshnessPreferredRoutes","externalCachedRoutes","core","clientsClaim"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * modified by core.ai, based on work by David Humphrey <david.humphrey@senecacolleage.ca> (@humphd)\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* global workbox, importScripts, Serve, HtmlFormatter, Config*/\nimportScripts('phoenix/virtualfs.js');\nimportScripts('phoenix/virtualServer/mime-types.js');\nimportScripts('phoenix/virtualServer/config.js');\nimportScripts('phoenix/virtualServer/content-type.js');\nimportScripts('phoenix/virtualServer/webserver.js');\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js');\n\nconst _debugSWCacheLogs = false; // change debug to true to see more logs\nconst CACHE_FILE_NAME = \"cacheManifest.json\";\nconst CACHE_FS_PATH = `/${CACHE_FILE_NAME}`;\n\nworkbox.setConfig({debug: _debugSWCacheLogs});\n\nconst Route = workbox.routing.Route;\n// other strategies include CacheFirst, NetworkFirst Etc..\nconst cacheFirst = workbox.strategies.CacheFirst;\nconst StaleWhileRevalidate = workbox.strategies.StaleWhileRevalidate;\nconst ExpirationPlugin = workbox.expiration.ExpirationPlugin;\nconst CacheExpiration = workbox.expiration.CacheExpiration;\nconst DAYS_30_IN_SEC = 60 * 60 * 24 * 30;\nconst CACHE_NAME_EVERYTHING = \"everything\"; // This is referenced in index.html as well if you are changing te name.\nconst CACHE_NAME_CORE_SCRIPTS = \"coreScripts\";\nconst CACHE_NAME_EXTERNAL = \"external\";\nconst ExpirationManager ={\n    \"everything\": new CacheExpiration(CACHE_NAME_EVERYTHING, {\n            maxAgeSeconds: DAYS_30_IN_SEC\n        }),\n    \"coreScripts\": new CacheExpiration(CACHE_NAME_CORE_SCRIPTS, {\n            maxAgeSeconds: DAYS_30_IN_SEC\n        }),\n    \"external\": new CacheExpiration(CACHE_NAME_EXTERNAL, {\n        maxAgeSeconds: DAYS_30_IN_SEC\n    })\n};\n\nfunction _debugCacheLog(...args) {\n    if(_debugSWCacheLogs){\n        console.log(...args);\n    }\n}\n\nself._debugLivePreviewLog = function (...args) {\n    if(self._debugSWLivePreviewLogs){ // this is set from the debug menu\n        console.log(...args);\n    }\n}\n\nfunction _removeParams(url) {\n    if(url.indexOf( \"?\")>-1){\n        url = url.substring( 0, url.indexOf( \"?\")); // remove query string params\n    }\n    if(location.href.indexOf( \"#\")>-1){\n        url = url.substring( 0, url.indexOf( \"#\")); // remove hrefs in page\n    }\n    return url;\n}\n\n// service worker controlling route base url. This will be something like https://phcode.dev/ or http://localhost:8000/\nlet baseURL = location.href;\nbaseURL = _removeParams(location.href);\nif(location.href.indexOf( \"/\")>-1){\n    // http://phcode.dev/index.html -> http://phcode.dev\n    baseURL = baseURL.substring( 0, baseURL.lastIndexOf( \"/\"));\n}\nif(!baseURL.endsWith('/')){\n    baseURL = baseURL + '/';\n}\nconsole.log(\"Service worker: base URL is: \", baseURL);\n\nconst CACHE_MANIFEST_URL = `${baseURL}${CACHE_FILE_NAME}`;\nconsole.log(\"Service worker: cache manifest URL is: \", CACHE_MANIFEST_URL);\n\n// this is the base url where our file system virtual server lives. http://phcode.dev/phoenix/vfs in phoenix or\n// http://localhost:8000/phoenix/vfs in dev builds\nconst virtualServerBaseURL = `${baseURL}${Config.route}`;\nconsole.log(\"Service worker: Virtual server base URL is: \", virtualServerBaseURL);\n\n// Route with trailing slash (i.e., /path/into/filesystem)\nconst wwwRegex = new RegExp(`${Config.route}(/.*)`);\n// Route minus the trailing slash\n\nfunction _isVirtualServing(url) {\n    return url.startsWith(virtualServerBaseURL);\n}\n\nfunction _shouldVirtualServe(request) {\n    return _isVirtualServing(request.url.href);\n}\n\nworkbox.routing.registerRoute(\n    _shouldVirtualServe,\n    ({url}) => {\n        // Pull the filesystem path off the url\n        let path = url.pathname.match(wwwRegex)[1];\n        // Deal with encoding in the filename (e.g., spaces as %20)\n        path = decodeURI(path);\n\n        const download = false;\n        // commented Allow passing `?download` or `dl` to have the file downloaded vs. displayed\n        // url.searchParams.get('download') !== null ||\n        // url.searchParams.get('dl') !== null;\n        let phoenixInstanceID;\n        if(path.startsWith(\"/PHOENIX_LIVE_PREVIEW_\")){\n            let pathSplit = path.split(\"/\");\n            phoenixInstanceID = pathSplit[1].replace(\"PHOENIX_LIVE_PREVIEW_\",\"\");\n            pathSplit.shift();pathSplit.shift();\n            path = `/${pathSplit.join(\"/\")}`;\n        }\n\n        return Serve.serve(path, download, phoenixInstanceID);\n    },\n    'GET'\n);\n\n// Redirect if missing the / on our expected route\nworkbox.routing.registerRoute(\n    _shouldVirtualServe,\n    ({url}) => {\n        url.pathname = `${Config.route}/`;\n        return Promise.resolve(Response.redirect(url, 302));\n    },\n    'GET'\n);\n\nfunction _updateTTL(cacheName, urls) {\n    // this is needed for workbox to purge cache by ttl. purge behaviour is not part of w3c spec, but done by workbox.\n    // cache.addall browser api will not update expiry ttls that workbox lib needs. So we add it here.\n    console.log(`Service worker: Updating expiry for ${urls.length} urls in cache: ${cacheName}`);\n    for(let url of urls){\n        ExpirationManager[cacheName].updateTimestamp(url);\n    }\n}\n\nfunction _getCurrentCacheManifest() {\n    return new Promise((resolve)=>{\n        fs.readFile(CACHE_FS_PATH, \"utf8\", function (err, data) {\n            if (err) {\n                resolve(null);\n            } else {\n                resolve(JSON.parse(data));\n            }\n        });\n    });\n}\nfunction _putCurrentCacheManifest(manifestObject) {\n    return new Promise((resolve)=>{\n        fs.writeFile(CACHE_FS_PATH, JSON.stringify(manifestObject, null, 2), \"UTF8\", function (err) {\n            if (err) {\n                console.error(\"Service worker: Failed while writing cache manifest\", err);\n            }\n            resolve(null);\n        });\n    });\n}\nfunction _getNewCacheManifest() {\n    return new Promise((resolve) => {\n        fetch(CACHE_MANIFEST_URL)\n            .then((response) => response.json())\n            .then((data) => resolve(data))\n            .catch(err =>{\n                console.error(\"Service worker: could not fetch cache manifest for app updates\", err);\n                resolve(null);\n            });\n    });\n}\n\nfunction _fixCache(currentCacheManifest, newCacheManifest) {\n    const currentCacheKeys = Object.keys(currentCacheManifest);\n    const newCacheKeys = Object.keys(newCacheManifest);\n    console.log(`Service worker: Fixing Stale Cache Entries in ${CACHE_NAME_EVERYTHING}. num cache entries in manifest:\n    current: ${currentCacheKeys.length} new: ${newCacheKeys.length}`);\n    return new Promise((resolve, reject) => {\n        caches.open(CACHE_NAME_EVERYTHING).then((cache) => {\n            cache.keys().then(async (keys) => {\n                console.log(\"Service worker: Number of cached entries in everything cache: \", keys.length);\n                let changedContentURLs = [], deletePromises = [];\n                keys.forEach((request, _index, _array) => {\n                    let relativeURL = _removeParams(request.url);\n                    relativeURL = relativeURL.substring(baseURL.length, relativeURL.length);\n                    if(!newCacheManifest[relativeURL]){\n                        _debugCacheLog(\"Service worker: entry renewed as deleted\", relativeURL);\n                        deletePromises.push(cache.delete(request));\n                        return;\n                    }\n                    if(currentCacheManifest[relativeURL] !== newCacheManifest[relativeURL]){\n                        _debugCacheLog(\"Service worker: entry renewed as changed\", relativeURL);\n                        deletePromises.push(cache.delete(request));\n                        changedContentURLs.push(request.url);\n                    }\n                });\n                console.log(`Service worker: deleting ${deletePromises.length} stale cache entries in ${CACHE_NAME_EVERYTHING}`);\n                await Promise.all(deletePromises);\n                console.log(`Service worker: updating cache for ${changedContentURLs.length} in ${CACHE_NAME_EVERYTHING}`);\n                cache.addAll(changedContentURLs).then(()=>{\n                    console.log(`Service worker: cache refresh complete for ${changedContentURLs.length} URLS in ${CACHE_NAME_EVERYTHING}`);\n                    _updateTTL(CACHE_NAME_EVERYTHING, changedContentURLs);\n                    resolve(changedContentURLs.length);\n                }).catch(err=>{\n                    console.error(`Service worker: cache refresh failed for ${changedContentURLs.length} URLS in ${CACHE_NAME_EVERYTHING}`, err);\n                    reject();\n                });\n            });\n        }).catch(reject);\n    });\n}\n\nlet refreshInProgress = false;\nasync function _refreshCache(event) {\n    if(refreshInProgress){\n        console.log(\"Another cache refresh is in progress, ignoring.\");\n        return;\n    }\n    refreshInProgress = true;\n    try{\n        console.log(\"Service worker: Refreshing browser cache for app updates.\");\n        const currentCacheManifest = await _getCurrentCacheManifest();\n        const newCacheManifest = await _getNewCacheManifest();\n        if(!newCacheManifest){\n            console.log(\"Service worker: could not fetch new cache manifest. Cache refresh will not be done.\");\n            refreshInProgress = false;\n            return;\n        }\n        if(!currentCacheManifest && newCacheManifest){\n            console.log(`Service worker: Fresh install, writing cache manifest with ${Object.keys(newCacheManifest).length} entries`);\n            // do less.refresh(true) here. that is only possible in main thread and to be done once we move to new\n            // service worker management framework\n            await _putCurrentCacheManifest(newCacheManifest);\n            refreshInProgress = false;\n            return;\n        }\n        const updatedFilesCount = await _fixCache(currentCacheManifest, newCacheManifest);\n        await _putCurrentCacheManifest(newCacheManifest);\n        event.ports[0].postMessage({updatedFilesCount});\n    } catch (e) {\n        console.error(\"Service worker: error while refreshing cache\", e);\n    }\n    refreshInProgress = false;\n}\n\naddEventListener('message', (event) => {\n    // NB: Do not expect anything to persist in the service worker variables, the service worker may be reset at\n    // any time by the browser if it is not in use, and only load it when required. This means that if there is a\n    // long inactivity in the page, even if the tab is opened, the service worker will be unloaded by chrome. Then will\n    // be re-enabled when needed. Hens some of our stored variables transferred from browser tabs was being erased\n    // leading to live preview failures before. Use indexDB persistent storage only inside worker is you want to keep\n    // track of data transferred from the main browser tabs, never hold it in variables here!\n    let eventType = event.data && event.data.type;\n    switch (eventType) {\n        case 'SKIP_WAITING': self.skipWaiting(); break;\n        case 'INIT_PHOENIX_CONFIG':\n            Config.debug = event.data.debugMode;\n            self._debugSWLivePreviewLogs = event.data.logLivePreview;\n            self.__WB_DISABLE_DEV_LOGS = Config.debug && _debugSWCacheLogs;\n            event.ports[0].postMessage({baseURL}); break;\n        case 'REFRESH_CACHE': _refreshCache(event); break;\n        case 'setInstrumentedURLs': self.Serve.setInstrumentedURLs(event); return true;\n        default:\n            let msgProcessed = self.Serve && self.Serve.processVirtualServerMessage &&\n                self.Serve.processVirtualServerMessage(event);\n            if(!msgProcessed){\n                console.error(\"Service worker cannot process, received unknown message: \", event);\n            }\n    }\n});\n\nfunction _isCacheableExternalUrl(url) {\n    let EXTERNAL_URLS = [\n        'https://storage.googleapis.com/workbox-cdn/'\n    ];\n    for(let start of EXTERNAL_URLS){\n        if(url.startsWith(start)){\n            return true;\n        }\n    }\n    return false;\n}\n\n// queue cache update\n\nconst DONT_CACHE_BASE_URLS = [\n    `${location.origin}/src/`, `${location.origin}/test/`, `${location.origin}/dist/`, // https://phcode.dev/src or other\n    // https://phcode.dev/subfolder/src/ or other when phoenix is loaded from https://phcode.dev/subfolder/index.html\n    `${baseURL}src/`, `${baseURL}test/`, `${baseURL}dist/`, `${baseURL}cacheManifest.json`];\nfunction _isNotCacheableUrl(url) {\n    for(let start of DONT_CACHE_BASE_URLS){\n        if(url.startsWith(start)){\n            return true;\n        }\n    }\n    return false;\n}\n\n// we always try to load main worker scripts and index html from core scripts cache which uses stale while revalidate\n// to get aggressive updates.\nconst CORE_SCRIPTS_URLS = [`${location.origin}/index.html`, `${location.origin}/`, // https://phcode.dev/src or other\n    `${location.origin}/virtual-server-main.js`, `${location.origin}/phoenix/virtual-server-loader.js`,\n    // https://phcode.dev/subfolder/src/ or other when phoenix is loaded from https://phcode.dev/subfolder/index.html\n    `${baseURL}index.html`, `${baseURL}`,\n    `${baseURL}virtual-server-main.js`, `${baseURL}phoenix/virtual-server-loader.js`];\nfunction _isCoreScript(url) {\n    for(let coreScript of CORE_SCRIPTS_URLS){\n        if(url === coreScript){\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _belongsToEverythingCache(request) {\n    // now do url checks, Remove # ,http://localhost:9000/dist/styles/images/sprites.svg#leftArrowDisabled.\n    // we cache entries with query string parameters in static pages with base url starting with phoenix base\n    let href = request.url.split(\"#\")[0];\n    if(request.destination === 'video' || request.destination === 'audio'){\n        _debugCacheLog(\"Not Caching audio/video URL: \", request);\n        return false;\n    }\n    if(_isNotCacheableUrl(href)){\n        _debugCacheLog(\"Not Caching un cacheable URL in everything cache: \", request);\n        return false;\n    }\n    if(_isCoreScript(href)){\n        _debugCacheLog(\"Not Caching core scripts in everything cache: \", request);\n        return false;\n    }\n    if(_isCacheableExternalUrl(href)){\n        _debugCacheLog(\"Not Caching external url in everything cache: \", request);\n        return false;\n    }\n    let disAllowedExtensions =  /.zip$|.map$/i;\n    if(href.startsWith(baseURL) && !disAllowedExtensions.test(href)) {\n        return true;\n    }\n    _debugCacheLog(\"Not Caching URL: \", request);\n    return false;\n}\n\n// handle all document\nconst allCachedRoutes = new Route(({ request }) => {\n    return (request.method === 'GET'\n        && _belongsToEverythingCache(request) && !_isVirtualServing(request.url));\n}, new cacheFirst({\n    cacheName: CACHE_NAME_EVERYTHING,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\n// core scripts route\nconst freshnessPreferredRoutes = new Route(({ request }) => {\n    return request.method === 'GET' && _isCoreScript(request.url) && !_isVirtualServing(request.url);\n}, new StaleWhileRevalidate({\n    cacheName: CACHE_NAME_CORE_SCRIPTS,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\n// scripts with a different origin like third party libs\nconst externalCachedRoutes = new Route(({ request }) => {\n    return request.method === 'GET' && _isCacheableExternalUrl(request.url) && !_isVirtualServing(request.url);\n}, new StaleWhileRevalidate({\n    cacheName: CACHE_NAME_EXTERNAL,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\nworkbox.routing.registerRoute(allCachedRoutes);\nworkbox.routing.registerRoute(freshnessPreferredRoutes);\nworkbox.routing.registerRoute(externalCachedRoutes);\n\nworkbox.core.clientsClaim();\n"],"file":"virtual-server-main.js"}
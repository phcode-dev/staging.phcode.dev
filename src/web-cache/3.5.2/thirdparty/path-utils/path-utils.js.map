{"version":3,"sources":["thirdparty/path-utils/path-utils.js"],"names":["root","factory","define","amd","module","exports","PathUtils","this","urlParseRE","parsedUrlPropNames","defaultPorts","http","https","ftp","ftps","parseUrl","url","matches","exec","props","cnt","length","result","i","port","u","protocol","isSameDomain","absUrl1","absUrl2","domain","isRelativeUrl","isAbsoluteUrl","makePathAbsolute","relPath","absPath","charAt","absStack","replace","split","relStack","d","pop","push","join","makePathRelative","pathA","pathB","stackB","stackA","stackC","len","upLevel","startIndex","shift","concat","makeUrlAbsolute","relUrl","absUrl","relObj","absObj","doubleSlash","authority","hasPath","pathname","search","hash","filename","getterFunc","propName","prop"],"mappings":"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","sourcesContent":["/** \n * @license\n * path-utils.js - version 0.0.2\n * Copyright (c) 2011, Kin Blas\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the <organization> nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function (root, factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([], factory);\n\t} else if (typeof module === 'object' && module.exports) {\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like environments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory();\n\t} else {\n\t\t// Browser globals (root is window)\n\t\troot.PathUtils = factory();\n\t}\n}(this, function(){\n\t\n\tvar PathUtils = {\n\t\t// This scary looking regular expression parses an absolute URL or its relative\n\t\t// variants (protocol, site, document, query, and hash), into the various\n\t\t// components (protocol, host, path, query, fragment, etc that make up the\n\t\t// URL as well as some other commonly used sub-parts. When used with RegExp.exec()\n\t\t// or String.match, it parses the URL into a results array that looks like this:\n\t\t//\n\t\t//     [0]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread#msg-content\n\t\t//     [1]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread\n\t\t//     [2]: http://jblas:password@mycompany.com:8080/mail/inbox\n\t\t//     [3]: http://jblas:password@mycompany.com:8080\n\t\t//     [4]: http:\n\t\t//     [5]: //\n\t\t//     [6]: jblas:password@mycompany.com:8080\n\t\t//     [7]: jblas:password\n\t\t//     [8]: jblas\n\t\t//     [9]: password\n\t\t//    [10]: mycompany.com:8080\n\t\t//    [11]: mycompany.com\n\t\t//    [12]: 8080\n\t\t//    [13]: /mail/inbox\n\t\t//    [14]: /mail/\n\t\t//    [15]: inbox\n\t\t//    [16]: ?msg=1234&type=unread\n\t\t//    [17]: #msg-content\n\t\t//\n\t\turlParseRE: /^(((([^:\\/#\\?]+:)?(?:(\\/\\/)((?:(([^:@\\/#\\?]+)(?:\\:([^:@\\/#\\?]+))?)@)?(([^:\\/#\\?\\]\\[]+|\\[[^\\/\\]@#?]+\\])(?:\\:([0-9]+))?))?)?)?((\\/?(?:[^\\/\\?#]+\\/+)*)([^\\?#\\.]*(?:\\.[^\\?#\\.]+)*(\\.[^\\?#\\.]+)|[^\\?#]*)))?(\\?[^#]+)?)(#.*)?/,\n\n\t\t// These are the property names we set on the parsed url object. The order of the names\n\t\t// in this array must match the order of the sub-matches in urlParseRE!\n\t\tparsedUrlPropNames: [\n\t\t\t\t\"href\",\n\t\t\t\t\"hrefNoHash\",\n\t\t\t\t\"hrefNoSearch\",\n\t\t\t\t\"domain\",\n\t\t\t\t\"protocol\",\n\t\t\t\t\"doubleSlash\",\n\t\t\t\t\"authority\",\n\t\t\t\t\"userinfo\",\n\t\t\t\t\"username\",\n\t\t\t\t\"password\",\n\t\t\t\t\"host\",\n\t\t\t\t\"hostname\",\n\t\t\t\t\"port\",\n\t\t\t\t\"pathname\",\n\t\t\t\t\"directory\",\n\t\t\t\t\"filename\",\n\t\t\t\t\"filenameExtension\",\n\t\t\t\t\"search\",\n\t\t\t\t\"hash\"\n\t\t],\n\n\t\tdefaultPorts: { http: \"80\", https: \"443\", ftp: \"20\", ftps: \"990\" },\n\n\t\tparseUrl: function( url ) {\n\n\t\t\t// If we're passed an object, we'll assume that it is\n\t\t\t// a parsed url object and just return it back to the caller.\n\t\t\tif ( url && typeof url === \"object\" ) {\n\t\t\t\treturn url;\n\t\t\t}\n\n\t\t\tvar matches = PathUtils.urlParseRE.exec( url || \"\" ) || [],\n\t\t\t\tprops = PathUtils.parsedUrlPropNames,\n\t\t\t\tcnt = props.length,\n\t\t\t\tresult = {},\n\t\t\t\ti;\n\n\t\t\tfor ( i = 0; i < cnt; i++ ) {\n\t\t\t\t// Most browsers returns an empty string for empty sub-matches, but\n\t\t\t\t// IE returns undefined, so we need to make sure we normalize empty\n\t\t\t\t// sub-matches so results are consistent across all browsers.\n\n\t\t\t\tresult[ props[ i ] ] = matches[ i ] || \"\";\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\tport: function( url ) {\n\t\t\tvar u = PathUtils.parseUrl( url );\n\t\t\treturn u.port || PathUtils.defaultPorts[u.protocol];\n\t\t},\n\n\t\tisSameDomain: function( absUrl1, absUrl2 ) {\n\t\t\treturn PathUtils.parseUrl( absUrl1 ).domain === PathUtils.parseUrl( absUrl2 ).domain;\n\t\t},\n\n\t\t//Returns true for any relative variant.\n\t\tisRelativeUrl: function( url ) {\n\t\t\t// All relative Url variants have one thing in common, no protocol.\n\t\t\treturn PathUtils.parseUrl( url ).protocol === \"\";\n\t\t},\n\n\t\t//Returns true for an absolute url.\n\t\tisAbsoluteUrl: function( url ) {\n\t\t\treturn PathUtils.parseUrl( url ).protocol !== \"\";\n\t\t},\n\n\t\t// Turn relPath into an asbolute path. absPath is\n\t\t// an optional absolute path which describes what\n\t\t// relPath is relative to.\n\n\t\tmakePathAbsolute: function( relPath, absPath ) {\n\t\t\tif ( relPath && relPath.charAt( 0 ) === \"/\" ) {\n\t\t\t\treturn relPath;\n\t\t\t}\n\n\t\t\trelPath = relPath || \"\";\n\t\t\tabsPath = absPath ? absPath.replace( /^\\/|(\\/[^\\/]*|[^\\/]+)$/g, \"\" ) : \"\";\n\n\t\t\tvar absStack = absPath ? absPath.split( \"/\" ) : [],\n\t\t\t\trelStack = relPath.split( \"/\" );\n\t\t\tfor ( var i = 0; i < relStack.length; i++ ) {\n\t\t\t\tvar d = relStack[ i ];\n\t\t\t\tswitch ( d ) {\n\t\t\t\t\tcase \".\":\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"..\":\n\t\t\t\t\t\tif ( absStack.length ) {\n\t\t\t\t\t\t\tabsStack.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tabsStack.push( d );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"/\" + absStack.join( \"/\" );\n\t\t},\n\n\t\t// Turn absolute pathA into a path that is\n\t\t// relative to absolute pathB.\n\n\t\tmakePathRelative: function( pathA, pathB ) {\n\t\t\t// Remove any file reference in the path.\n\t\t\tpathB = pathB ? pathB.replace( /^\\/|\\/?[^\\/]*$/g, \"\" ) : \"\";\n\t\t\tpathA = pathA ? pathA.replace( /^\\//, \"\" ) : \"\";\n\n\t\t\tvar stackB = pathB ? pathB.split( \"/\" ) : [],\n\t\t\t\tstackA = pathA.split( \"/\" ),\n\t\t\t\tstackC = [],\n\t\t\t\tlen = stackB.length,\n\t\t\t\tupLevel = false,\n\t\t\t\tstartIndex = 0;\n\n\t\t\tfor ( var i = 0; i < len; i++ ) {\n\t\t\t\tupLevel = upLevel || stackA[ 0 ] !== stackB[ i ];\n\t\t\t\tif ( upLevel ) {\n\t\t\t\t\tstackC.push( \"..\" );\n\t\t\t\t} else {\n\t\t\t\t\tstackA.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn stackC.concat( stackA ).join( \"/\" );\n\t\t},\n\n\t\t// Turn any relative URL variant into an absolute URL.\n\n\t\tmakeUrlAbsolute: function( relUrl, absUrl ) {\n\t\t\tif ( !PathUtils.isRelativeUrl( relUrl ) ) {\n\t\t\t\treturn relUrl;\n\t\t\t}\n\n\t\t\tvar relObj = PathUtils.parseUrl( relUrl ),\n\t\t\t\tabsObj = PathUtils.parseUrl( absUrl ),\n\t\t\t\tprotocol = relObj.protocol || absObj.protocol,\n\t\t\t\tdoubleSlash = relObj.protocol ? relObj.doubleSlash : ( relObj.doubleSlash || absObj.doubleSlash ),\n\t\t\t\tauthority = relObj.authority || absObj.authority,\n\t\t\t\thasPath = relObj.pathname !== \"\",\n\t\t\t\tpathname = PathUtils.makePathAbsolute( relObj.pathname || absObj.filename, absObj.pathname ),\n\t\t\t\tsearch = relObj.search || ( !hasPath && absObj.search ) || \"\",\n\t\t\t\thash = relObj.hash;\n\n\t\t\treturn protocol + doubleSlash + authority + pathname + search + hash;\n\t\t}\n\t};\n\n\t// For every parsedUrlPropName, make sure there is a getter function defined on the PathUtils object.\n\n\tfunction getterFunc( propName )\n\t{\n\t\treturn function( url ){\n\t\t\treturn PathUtils.parseUrl( url )[ propName ];\n\t\t}\n\t}\n\n\tvar i, prop, props = PathUtils.parsedUrlPropNames, cnt = props.length;\n\tfor ( i = 0; i < cnt; i++ ) {\n\t\tprop = props[ i ];\n\t\tif ( !PathUtils[ prop ] ) {\n\t\t\tPathUtils[ prop ] = getterFunc( prop );\n\t\t}\n\t}\n\n\t// Expose PathUtils to the world.\n\treturn PathUtils;\n}));"],"file":"path-utils.js"}
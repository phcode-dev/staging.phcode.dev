{"version":3,"sources":["thirdparty/CodeMirror/addon/edit/continuelist.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","listRE","emptyListRE","unorderedListRE","incrementRemainingMarkdownListNumbers","cm","pos","startLine","line","lookAhead","skipCount","startItem","exec","getLine","startIndent","nextLineNumber","nextLine","nextItem","nextIndent","newNumber","parseInt","nextNumber","itemNumber","isNaN","length","replaceRange","replace","ch","commands","newlineAndIndentContinueMarkdownList","getOption","Pass","ranges","listSelections","replacements","i","head","eolState","getStateAfter","inner","innerMode","getMode","mode","name","helperType","execCommand","inList","state","list","inQuote","quote","match","cursorBeforeBullet","test","slice","empty","endOfQuote","endOfList","indent","after","numbered","indexOf","bullet","replaceSelections"],"mappings":"CAGA,SAAUA,KACc,iBAAXC,SAAwC,iBAAVC,OACvCF,IAAIG,QAAQ,yBACY,mBAAVC,QAAwBA,OAAOC,IAC7CD,OAAO,CAAC,wBAAyBJ,KAEjCA,IAAIM,YANR,CAOG,SAASA,YACV,aAEA,IAAIC,OAAS,2DACTC,YAAc,sDACdC,gBAAkB,UAmDtB,SAASC,sCAAsCC,GAAIC,KACjD,IAAIC,UAAYD,IAAIE,KAAMC,UAAY,EAAGC,UAAY,EACjDC,UAAYV,OAAOW,KAAKP,GAAGQ,QAAQN,YAAaO,YAAcH,UAAU,GAE5E,EAAG,CAED,IAAII,eAAiBR,WADrBE,WAAa,GAETO,SAAWX,GAAGQ,QAAQE,gBAAiBE,SAAWhB,OAAOW,KAAKI,UAElE,GAAIC,SAAU,CACZ,IAAIC,WAAaD,SAAS,GACtBE,UAAaC,SAAST,UAAU,GAAI,IAAMF,UAAYC,UACtDW,WAAcD,SAASH,SAAS,GAAI,IAAMK,WAAaD,WAE3D,GAAIP,cAAgBI,YAAeK,MAAMF,YAUlC,CACL,GAAIP,YAAYU,OAASN,WAAWM,OAAQ,OAG5C,GAAKV,YAAYU,OAASN,WAAWM,QAA0B,IAAdf,UAAkB,OACnEC,WAAa,OAdTS,YAAcE,aAAYC,WAAaD,WAAa,GACpDF,UAAYE,aAAYC,WAAaH,UAAY,GACrDd,GAAGoB,aACDT,SAASU,QAAQzB,OAAQiB,WAAaI,WAAaL,SAAS,GAAKA,SAAS,IAC5E,CACET,KAAMO,eAAgBY,GAAI,GACzB,CACDnB,KAAMO,eAAgBY,GAAIX,SAASQ,gBAUlCP,UAjFXjB,WAAW4B,SAASC,qCAAuC,SAASxB,IAClE,GAAIA,GAAGyB,UAAU,gBAAiB,OAAO9B,WAAW+B,KAEpD,IADA,IAAIC,OAAS3B,GAAG4B,iBAAkBC,aAAe,GACxCC,EAAI,EAAGA,EAAIH,OAAOR,OAAQW,IAAK,CACtC,IAAI7B,IAAM0B,OAAOG,GAAGC,KAGhBC,SAAWhC,GAAGiC,cAAchC,IAAIE,MAChC+B,MAAQvC,WAAWwC,UAAUnC,GAAGoC,UAAWJ,UAC/C,GAAwB,aAApBE,MAAMG,KAAKC,MAAiD,aAA1BJ,MAAMG,KAAKE,WAE/C,YADAvC,GAAGwC,YAAY,oBAMjB,IAAIC,QAA2B,KAH7BT,SAAWE,MAAMQ,OAGGC,KAClBC,QAA6B,IAAnBZ,SAASa,MAEnB1C,KAAOH,GAAGQ,QAAQP,IAAIE,MAAO2C,MAAQlD,OAAOW,KAAKJ,MACjD4C,mBAAqB,QAAQC,KAAK7C,KAAK8C,MAAM,EAAGhD,IAAIqB,KACxD,IAAKK,OAAOG,GAAGoB,UAAaT,SAAWG,UAAaE,OAASC,mBAE3D,YADA/C,GAAGwC,YAAY,oBAGjB,GAAI3C,YAAYmD,KAAK7C,MAAO,CAC1B,IAAIgD,WAAaP,SAAW,QAAQI,KAAK7C,MACrCiD,WAAa,QAAQJ,KAAK7C,OAC1BgD,YAAcC,YAAWpD,GAAGoB,aAAa,GAAI,CAC/CjB,KAAMF,IAAIE,KAAMmB,GAAI,GACnB,CACDnB,KAAMF,IAAIE,KAAMmB,GAAIrB,IAAIqB,GAAK,IAE/BO,aAAaC,GAAK,SACb,CACL,IAAIuB,OAASP,MAAM,GAAIQ,MAAQR,MAAM,GACjCS,WAAazD,gBAAgBkD,KAAKF,MAAM,KAAOA,MAAM,GAAGU,QAAQ,MAAQ,GACxEC,OAASF,SAAYxC,SAAS+B,MAAM,GAAI,IAAM,EAAKA,MAAM,GAAKA,MAAM,GAAGzB,QAAQ,IAAK,KACxFQ,aAAaC,GAAK,KAAOuB,OAASI,OAASH,MAEvCC,UAAUxD,sCAAsCC,GAAIC,MAI5DD,GAAG0D,kBAAkB7B","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var listRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]\\s|[*+-]\\s|(\\d+)([.)]))(\\s*)/,\n      emptyListRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]|[*+-]|(\\d+)[.)])(\\s*)$/,\n      unorderedListRE = /[*+-]\\s/;\n\n  CodeMirror.commands.newlineAndIndentContinueMarkdownList = function(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    var ranges = cm.listSelections(), replacements = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].head;\n\n      // If we're not in Markdown mode, fall back to normal newlineAndIndent\n      var eolState = cm.getStateAfter(pos.line);\n      var inner = CodeMirror.innerMode(cm.getMode(), eolState);\n      if (inner.mode.name !== \"markdown\" && inner.mode.helperType !== \"markdown\") {\n        cm.execCommand(\"newlineAndIndent\");\n        return;\n      } else {\n        eolState = inner.state;\n      }\n\n      var inList = eolState.list !== false;\n      var inQuote = eolState.quote !== 0;\n\n      var line = cm.getLine(pos.line), match = listRE.exec(line);\n      var cursorBeforeBullet = /^\\s*$/.test(line.slice(0, pos.ch));\n      if (!ranges[i].empty() || (!inList && !inQuote) || !match || cursorBeforeBullet) {\n        cm.execCommand(\"newlineAndIndent\");\n        return;\n      }\n      if (emptyListRE.test(line)) {\n        var endOfQuote = inQuote && />\\s*$/.test(line)\n        var endOfList = !/>\\s*$/.test(line)\n        if (endOfQuote || endOfList) cm.replaceRange(\"\", {\n          line: pos.line, ch: 0\n        }, {\n          line: pos.line, ch: pos.ch + 1\n        });\n        replacements[i] = \"\\n\";\n      } else {\n        var indent = match[1], after = match[5];\n        var numbered = !(unorderedListRE.test(match[2]) || match[2].indexOf(\">\") >= 0);\n        var bullet = numbered ? (parseInt(match[3], 10) + 1) + match[4] : match[2].replace(\"x\", \" \");\n        replacements[i] = \"\\n\" + indent + bullet + after;\n\n        if (numbered) incrementRemainingMarkdownListNumbers(cm, pos);\n      }\n    }\n\n    cm.replaceSelections(replacements);\n  };\n\n  // Auto-updating Markdown list numbers when a new item is added to the\n  // middle of a list\n  function incrementRemainingMarkdownListNumbers(cm, pos) {\n    var startLine = pos.line, lookAhead = 0, skipCount = 0;\n    var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];\n\n    do {\n      lookAhead += 1;\n      var nextLineNumber = startLine + lookAhead;\n      var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);\n\n      if (nextItem) {\n        var nextIndent = nextItem[1];\n        var newNumber = (parseInt(startItem[3], 10) + lookAhead - skipCount);\n        var nextNumber = (parseInt(nextItem[3], 10)), itemNumber = nextNumber;\n\n        if (startIndent === nextIndent && !isNaN(nextNumber)) {\n          if (newNumber === nextNumber) itemNumber = nextNumber + 1;\n          if (newNumber > nextNumber) itemNumber = newNumber + 1;\n          cm.replaceRange(\n            nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]),\n          {\n            line: nextLineNumber, ch: 0\n          }, {\n            line: nextLineNumber, ch: nextLine.length\n          });\n        } else {\n          if (startIndent.length > nextIndent.length) return;\n          // This doesn't run if the next line immediately indents, as it is\n          // not clear of the users intention (new indented item or same level)\n          if ((startIndent.length < nextIndent.length) && (lookAhead === 1)) return;\n          skipCount += 1;\n        }\n      }\n    } while (nextItem);\n  }\n});\n"],"file":"continuelist.js"}
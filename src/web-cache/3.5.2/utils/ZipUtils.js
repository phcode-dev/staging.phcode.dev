define(function(require,exports,module){const FileSystem=require("filesystem/FileSystem"),FileSystemError=require("filesystem/FileSystemError"),ignoredFolders=["__MACOSX"];async function _ensureExistsAsync(path){return new Promise((resolve,reject)=>{Phoenix.VFS.ensureExistsDir(path,err=>{err?reject(err):resolve()})})}function _copyZippedItemToFS(path,item,destProjectDir,flattenFirstLevel,zipControl){return new Promise(async(resolve,reject)=>{try{let destPath=`${destProjectDir}${path}`;if(flattenFirstLevel){let newPath=path.substr(path.indexOf("/")+1);destPath=`${destProjectDir}${newPath}`,console.log(destPath)}item.dir?(await _ensureExistsAsync(destPath),resolve(destPath)):(await _ensureExistsAsync(window.path.dirname(destPath)),item.async("uint8array").then(function(data){!zipControl||zipControl.continueExtraction?window.fs.writeFile(destPath,Filer.Buffer.from(data),{encoding:window.fs.BYTE_ARRAY_ENCODING},writeErr=>{writeErr?reject(writeErr):resolve(destPath)}):reject("aborted")}).catch(error=>{reject(error)}))}catch(e){reject(e)}})}function _isNestedContentDir(zip){let keys=Object.keys(zip.files),rootEntries={};for(let path of keys){let filePath=path.endsWith("/")?path.slice(0,-1):path,item;if(!zip.files[path].dir&&!filePath.includes("/"))return!1;let baseName=filePath.split("/")[0];ignoredFolders.includes(baseName)||(rootEntries[baseName]=!0)}return 1===Object.keys(rootEntries).length}function unzipBinDataToLocation(zipData,projectDir,flattenFirstLevel=!1,progressControlCallback){return projectDir.endsWith("/")||(projectDir+="/"),new Promise((resolve,reject)=>{JSZip.loadAsync(zipData).then(async function(zip){let keys=Object.keys(zip.files);try{const extractBatchSize=500,isNestedContent=_isNestedContentDir(zip);let extractError,totalCount=keys.length,doneCount=0,extractPromises=[],zipControl={continueExtraction:!0};function _unzipProgress(){doneCount++,progressControlCallback&&(zipControl.continueExtraction=zipControl.continueExtraction&&progressControlCallback(doneCount,totalCount))}function _extractFailed(err){extractError=err||"extract failed"}for(let path of keys){let extractPromise=_copyZippedItemToFS(path,zip.files[path],projectDir,isNestedContent&&flattenFirstLevel,zipControl);if(extractPromise.then(_unzipProgress).catch(_extractFailed),extractPromises.push(extractPromise),extractPromises.length===extractBatchSize&&(await Promise.allSettled(extractPromises),extractPromises=[]),!1===zipControl.continueExtraction)return void reject("Extraction cancelled by progress controller");if(extractError)return void reject(extractError)}if(extractPromises.length&&await Promise.allSettled(extractPromises),extractError)return void reject(extractError);console.log("Unzip complete: ",projectDir),resolve()}catch(err){console.error("unzip failed",err),reject(err)}})})}function _readContent(fileEntry){return new Promise((resolve,reject)=>{fileEntry.read({encoding:window.fs.BYTE_ARRAY_ENCODING},function(err,content,encoding,stat){if(err)return err===FileSystemError.NOT_FOUND?void resolve(null):void reject(err);let blob=new Blob([content],{type:"application/octet-stream"});resolve(blob)})})}function zipFolder(fullPath){return new Promise((resolve,reject)=>{const zip=new JSZip;let directory=FileSystem.getDirectoryForPath(fullPath);FileSystem.getAllDirectoryContents(directory,!0).then(async contents=>{for(let entry of contents){let relativePath=path.relative(fullPath,entry.fullPath);if(entry.isDirectory)zip.folder(relativePath);else{let blob=await _readContent(entry);blob&&zip.file(relativePath,blob)}}resolve(zip)}).catch(reject)})}function unzipURLToLocation(url,projectDir,flattenFirstLevel=!1){return new Promise((resolve,reject)=>{window.JSZipUtils.getBinaryContent(url,async function(err,data){err?(console.error(`could not load zip from URL: ${url}\n `,err),reject()):unzipBinDataToLocation(data,projectDir,flattenFirstLevel).then(resolve).catch(reject)})})}exports.unzipBinDataToLocation=unzipBinDataToLocation,exports.unzipURLToLocation=unzipURLToLocation,exports.zipFolder=zipFolder});
//# sourceMappingURL=ZipUtils.js.map

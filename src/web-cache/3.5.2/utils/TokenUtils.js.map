{"version":3,"sources":["utils/TokenUtils.js"],"names":["define","require","exports","module","_","CodeMirror","cache","_clearCache","cm","off","_manageCache","line","tokens","getLineTokens","unshift","getTokenAt","ch","timeStamp","Date","now","on","pos","precise","cachedTokens","tokenIndex","token","sortedIndex","end","getInitialContext","editor","movePrevToken","ctx","undefined","start","getLine","length","isAtStart","moveNextToken","eol","lineCount","isAtEnd","moveSkippingWhitespace","moveFxn","type","test","string","offsetInToken","offset","console","log","getModeAt","modeData","getMode","name","innerMode","state","mode","configuration"],"mappings":"AA0BAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,EAAcH,QAAQ,qBACtBI,WAAcJ,QAAQ,wCAEtBK,MAGJ,SAASC,YAAYC,IACjBF,MAAQ,KACJE,IACAA,GAAGC,IAAI,UAAWF,aAU1B,SAASG,aAAaF,GAAIG,MACtB,IAAKL,QAAUA,MAAMM,QAAUN,MAAMK,OAASA,MAAQL,MAAME,KAAOA,GAAI,CAEnE,IAAII,OAASJ,GAAGK,cAAcF,MAAM,GAEpCC,OAAOE,QAAQN,GAAGO,WAAW,CAACJ,KAAMA,KAAMK,GAAI,IAAI,IAClDV,MAAQ,CACJE,GAAIA,GACJG,KAAMA,KACNM,UAAWC,KAAKC,MAChBP,OAAQA,QAEZJ,GAAGC,IAAI,UAAWF,aAClBC,GAAGY,GAAG,UAAWb,aAErB,OAAOD,MAAMM,OAUjB,SAASG,WAAWP,GAAIa,IAAKC,SACzB,GAAIA,QAEA,OADAf,cACOC,GAAGO,WAAWM,IAAKC,SAE9B,IAAIC,aAAkBb,aAAaF,GAAIa,IAAIV,MACvCa,WACAC,MACJ,OADsBF,aADAnB,EAAEsB,YAAYH,aAAc,CAACI,IAAKN,IAAIL,IAAK,SAEjDR,GAAGO,WAAWM,IAAKC,SAUvC,SAASM,kBAAkBpB,GAAIa,KAC3B,MAAO,CACHQ,OAAUrB,GACVa,IAAOA,IACPI,MAASjB,GAAGO,WAAWM,KAAK,IAWpC,SAASS,cAAcC,IAAKT,SAKxB,QAJgBU,IAAZV,UACAA,SAAU,GAGVS,IAAIV,IAAIL,IAAM,GAAKe,IAAIN,MAAMQ,OAAS,EAAG,CAEzC,GAAIF,IAAIV,IAAIV,MAAQ,EAChB,OAAO,EAEXoB,IAAIV,IAAIV,OACRoB,IAAIV,IAAIL,GAAKe,IAAIF,OAAOK,QAAQH,IAAIV,IAAIV,MAAMwB,YAE9CJ,IAAIV,IAAIL,GAAKe,IAAIN,MAAMQ,MAG3B,OADAF,IAAIN,MAAQV,WAAWgB,IAAIF,OAAQE,IAAIV,IAAKC,UACrC,EAOX,SAASc,UAAUL,KACf,OAAQA,IAAIV,IAAIL,IAAM,GAAKe,IAAIN,MAAMQ,OAAS,IAAOF,IAAIV,IAAIV,MAAQ,EAUzE,SAAS0B,cAAcN,IAAKT,SACxB,IAAIgB,IAAMP,IAAIF,OAAOK,QAAQH,IAAIV,IAAIV,MAAMwB,OAK3C,QAJgBH,IAAZV,UACAA,SAAU,GAGVS,IAAIV,IAAIL,IAAMsB,KAAOP,IAAIN,MAAME,KAAOW,IAAK,CAE3C,GAAIP,IAAIV,IAAIV,MAAQoB,IAAIF,OAAOU,YAAc,EACzC,OAAO,EAEXR,IAAIV,IAAIV,OACRoB,IAAIV,IAAIL,GAAK,OAEbe,IAAIV,IAAIL,GAAKe,IAAIN,MAAME,IAAM,EAGjC,OADAI,IAAIN,MAAQV,WAAWgB,IAAIF,OAAQE,IAAIV,IAAKC,UACrC,EAOX,SAASkB,QAAQT,KACb,IAAIO,IAAMP,IAAIF,OAAOK,QAAQH,IAAIV,IAAIV,MAAMwB,OAC3C,OAAQJ,IAAIV,IAAIL,IAAMsB,KAAOP,IAAIN,MAAME,KAAOW,MAASP,IAAIV,IAAIV,MAAQoB,IAAIF,OAAOU,YAAc,EASpG,SAASE,uBAAuBC,QAASX,KACrC,IAAKW,QAAQX,KACT,OAAO,EAEX,MAAQA,IAAIN,MAAMkB,OAAS,KAAKC,KAAKb,IAAIN,MAAMoB,SAC3C,IAAKH,QAAQX,KACT,OAAO,EAGf,OAAO,EAQX,SAASe,cAAcf,KACnB,IAAIgB,OAAShB,IAAIV,IAAIL,GAAKe,IAAIN,MAAMQ,MAIpC,OAHIc,OAAS,GACTC,QAAQC,IAAI,kFAETF,OAUX,SAASG,UAAU1C,GAAIa,IAAKC,SACxBA,QAAUA,UAAW,EACrB,IAAI6B,SAAW3C,GAAG4C,UACdC,KASJ,OAPIF,SAASG,YACTH,SAAW9C,WAAWiD,UAAUH,SAAUpC,WAAWP,GAAIa,IAAKC,SAASiC,OAAOC,MAM3E,CAACA,KAAML,SAAUE,KAHxBA,KAA0B,QAAlBF,SAASE,KACTF,SAASM,cAAgBN,SAASE,MAK9CnD,QAAQa,WAA0BA,WAClCb,QAAQ4B,cAA0BA,cAClC5B,QAAQmC,cAA0BA,cAClCnC,QAAQkC,UAA0BA,UAClClC,QAAQsC,QAA0BA,QAClCtC,QAAQuC,uBAA0BA,uBAClCvC,QAAQ0B,kBAA0BA,kBAClC1B,QAAQ4C,cAA0BA,cAClC5C,QAAQgD,UAA0BA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Functions for iterating through tokens in the current editor buffer. Useful for doing\n * light parsing that can rely purely on information gathered by the code coloring mechanism.\n */\n\ndefine(function (require, exports, module) {\n\n\n    var _           = require(\"thirdparty/lodash\"),\n        CodeMirror  = require(\"thirdparty/CodeMirror/lib/codemirror\");\n\n    var cache;\n\n\n    function _clearCache(cm) {\n        cache = null;\n        if (cm) { // event handler\n            cm.off(\"changes\", _clearCache);\n        }\n    }\n\n    /*\n     * Caches the tokens for the given editor/line if needed\n     * @param {!CodeMirror} cm\n     * @param {!number} line\n     * @return {Array.<Object>} (Cached) array of tokens\n     */\n    function _manageCache(cm, line) {\n        if (!cache || !cache.tokens || cache.line !== line || cache.cm !== cm) {\n            // Cache is no longer matching -> Update\n            var tokens = cm.getLineTokens(line, false);\n            // Add empty beginning-of-line token for backwards compatibility\n            tokens.unshift(cm.getTokenAt({line: line, ch: 0}, false));\n            cache = {\n                cm: cm,\n                line: line,\n                timeStamp: Date.now(),\n                tokens: tokens\n            };\n            cm.off(\"changes\", _clearCache);\n            cm.on(\"changes\", _clearCache);\n        }\n        return cache.tokens;\n    }\n\n    /*\n     * Like cm.getTokenAt, but with caching. Way more performant for long lines.\n     * @param {!CodeMirror} cm\n     * @param {!{ch:number, line:number}} pos\n     * @param {boolean} precise If given, results in more current results. Suppresses caching.\n     * @return {Object} Token for position\n     */\n    function getTokenAt(cm, pos, precise) {\n        if (precise) {\n            _clearCache(); // reset cache\n            return cm.getTokenAt(pos, precise);\n        }\n        var cachedTokens    = _manageCache(cm, pos.line),\n            tokenIndex      = _.sortedIndex(cachedTokens, {end: pos.ch}, \"end\"), // binary search is faster for long arrays\n            token           = cachedTokens[tokenIndex];\n        return token || cm.getTokenAt(pos, precise); // fall back to CMs getTokenAt, for example in an empty line\n    }\n\n   /**\n     * Creates a context object for the given editor and position, suitable for passing to the\n     * move functions.\n     * @param {!CodeMirror} cm\n     * @param {!{ch:number, line:number}} pos\n     * @return {!{editor:!CodeMirror, pos:!{ch:number, line:number}, token:Object}}\n     */\n    function getInitialContext(cm, pos) {\n        return {\n            \"editor\": cm,\n            \"pos\": pos,\n            \"token\": cm.getTokenAt(pos, true)\n        };\n    }\n\n    /**\n     * Moves the given context backwards by one token.\n     * @param {!{editor:!CodeMirror, pos:!{ch:number, line:number}, token:Object}} ctx\n     * @param {boolean=} precise If code is being edited, use true (default) for accuracy.\n     *      If parsing unchanging code, use false to use cache for performance.\n     * @return {boolean} whether the context changed\n     */\n    function movePrevToken(ctx, precise) {\n        if (precise === undefined) {\n            precise = true;\n        }\n\n        if (ctx.pos.ch <= 0 || ctx.token.start <= 0) {\n            //move up a line\n            if (ctx.pos.line <= 0) {\n                return false; //at the top already\n            }\n            ctx.pos.line--;\n            ctx.pos.ch = ctx.editor.getLine(ctx.pos.line).length;\n        } else {\n            ctx.pos.ch = ctx.token.start;\n        }\n        ctx.token = getTokenAt(ctx.editor, ctx.pos, precise);\n        return true;\n    }\n\n    /**\n     * @param {!{editor:!CodeMirror, pos:!{ch:number, line:number}, token:Object}} ctx\n     * @return {boolean} true if movePrevToken() would return false without changing pos\n     */\n    function isAtStart(ctx) {\n        return (ctx.pos.ch <= 0 || ctx.token.start <= 0) && (ctx.pos.line <= 0);\n    }\n\n    /**\n     * Moves the given context forward by one token.\n     * @param {!{editor:!CodeMirror, pos:!{ch:number, line:number}, token:Object}} ctx\n     * @param {boolean=} precise If code is being edited, use true (default) for accuracy.\n     *      If parsing unchanging code, use false to use cache for performance.\n     * @return {boolean} whether the context changed\n     */\n    function moveNextToken(ctx, precise) {\n        var eol = ctx.editor.getLine(ctx.pos.line).length;\n        if (precise === undefined) {\n            precise = true;\n        }\n\n        if (ctx.pos.ch >= eol || ctx.token.end >= eol) {\n            //move down a line\n            if (ctx.pos.line >= ctx.editor.lineCount() - 1) {\n                return false; //at the bottom\n            }\n            ctx.pos.line++;\n            ctx.pos.ch = 0;\n        } else {\n            ctx.pos.ch = ctx.token.end + 1;\n        }\n        ctx.token = getTokenAt(ctx.editor, ctx.pos, precise);\n        return true;\n    }\n\n    /**\n     * @param {!{editor:!CodeMirror, pos:!{ch:number, line:number}, token:Object}} ctx\n     * @return {boolean} true if moveNextToken() would return false without changing pos\n     */\n    function isAtEnd(ctx) {\n        var eol = ctx.editor.getLine(ctx.pos.line).length;\n        return (ctx.pos.ch >= eol || ctx.token.end >= eol) && (ctx.pos.line >= ctx.editor.lineCount() - 1);\n    }\n\n   /**\n     * Moves the given context in the given direction, skipping any whitespace it hits.\n     * @param {function} moveFxn the function to move the context\n     * @param {!{editor:!CodeMirror, pos:!{ch:number, line:number}, token:Object}} ctx\n     * @return {boolean} whether the context changed\n     */\n    function moveSkippingWhitespace(moveFxn, ctx) {\n        if (!moveFxn(ctx)) {\n            return false;\n        }\n        while (!ctx.token.type && !/\\S/.test(ctx.token.string)) {\n            if (!moveFxn(ctx)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * In the given context, get the character offset of pos from the start of the token.\n     * @param {!{editor:!CodeMirror, pos:!{ch:number, line:number}, token:Object}} context\n     * @return {number}\n     */\n    function offsetInToken(ctx) {\n        var offset = ctx.pos.ch - ctx.token.start;\n        if (offset < 0) {\n            console.log(\"CodeHintUtils: _offsetInToken - Invalid context: pos not in the current token!\");\n        }\n        return offset;\n    }\n\n    /**\n     * Returns the mode object and mode name string at a given position\n     * @param {!CodeMirror} cm CodeMirror instance\n     * @param {!{line:number, ch:number}} pos Position to query for mode\n     * @param {boolean} precise If given, results in more current results. Suppresses caching.\n     * @return {mode:{Object}, name:string}\n     */\n    function getModeAt(cm, pos, precise) {\n        precise = precise || true;\n        var modeData = cm.getMode(),\n            name;\n\n        if (modeData.innerMode) {\n            modeData = CodeMirror.innerMode(modeData, getTokenAt(cm, pos, precise).state).mode;\n        }\n\n        name = (modeData.name === \"xml\") ?\n                modeData.configuration : modeData.name;\n\n        return {mode: modeData, name: name};\n    }\n\n    exports.getTokenAt              = getTokenAt;\n    exports.movePrevToken           = movePrevToken;\n    exports.moveNextToken           = moveNextToken;\n    exports.isAtStart               = isAtStart;\n    exports.isAtEnd                 = isAtEnd;\n    exports.moveSkippingWhitespace  = moveSkippingWhitespace;\n    exports.getInitialContext       = getInitialContext;\n    exports.offsetInToken           = offsetInToken;\n    exports.getModeAt               = getModeAt;\n});\n"],"file":"TokenUtils.js"}
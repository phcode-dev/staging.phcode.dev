{"version":3,"sources":["language/HTMLDOMDiff.js"],"names":["define","require","exports","module","generateAttributeEdits","oldNode","newNode","oldAttributes","$","extend","attributes","newAttributes","edits","Object","keys","forEach","attributeName","type","hasOwnProperty","push","tagID","attribute","value","getParentID","node","parent","generateChildEdits","oldParent","oldNodeMap","newParent","newNodeMap","newIndex","oldIndex","newChildren","children","oldChildren","newChild","oldChild","newEdits","newEdit","textAfterID","moves","newElements","finalizeNewEdits","beforeID","isBeingDeleted","edit","apply","addElementInsert","tag","parentID","addElementDelete","addTextInsert","content","afterID","firstChild","prevNode","addTextDelete","prev","previousEdit","length","addElementMove","possiblyMovedElement","hasMoved","oldChildInNewTree","isElement","isText","console","error","textSignature","lastChild","domdiff","queue","newElement","oldElement","nodeMap","queuePush","addEdits","delta","pop","attributeSignature","childSignature","subtreeSignature","unshift","tagIDs"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: HTML Instrumentation*/\n\ndefine(function (require, exports, module) {\n\n\n    /**\n     * @private\n     *\n     * Determines the changes made to attributes and generates edits for those changes.\n     *\n     * @param {SimpleNode} oldNode node from old tree\n     * @param {SimpleNode} newNode node from new tree\n     * @return {Array.<Object>} list of edits to mutate attributes from the old node to the new\n     */\n    function generateAttributeEdits(oldNode, newNode) {\n        // shallow copy the old attributes object so that we can modify it\n        var oldAttributes = $.extend({}, oldNode.attributes),\n            newAttributes = newNode.attributes,\n            edits = [];\n\n        Object.keys(newAttributes).forEach(function (attributeName) {\n            if (oldAttributes[attributeName] !== newAttributes[attributeName]) {\n                var type = oldAttributes.hasOwnProperty(attributeName) ? \"attrChange\" : \"attrAdd\";\n                edits.push({\n                    type: type,\n                    tagID: oldNode.tagID,\n                    attribute: attributeName,\n                    value: newAttributes[attributeName]\n                });\n            }\n            delete oldAttributes[attributeName];\n        });\n\n        Object.keys(oldAttributes).forEach(function (attributeName) {\n            edits.push({\n                type: \"attrDelete\",\n                tagID: oldNode.tagID,\n                attribute: attributeName\n            });\n        });\n\n        return edits;\n    }\n\n    /**\n     * @private\n     *\n     * Retrieve the parent tag ID of a SimpleDOM node.\n     *\n     * @param {Object} node SimpleDOM node for which to look up parent ID\n     * @return {int?} ID or null if there is no parent\n     */\n    function getParentID(node) {\n        return node.parent && node.parent.tagID;\n    }\n\n    /**\n     * @private\n     *\n     * When the main loop (see below) determines that something has changed with\n     * an element's immediate children, it calls this function to create edit\n     * operations for those changes.\n     *\n     * This adds to the edit list in place and does not return anything.\n     *\n     * @param {?Object} oldParent SimpleDOM node for the previous state of this element, null/undefined if the element is new\n     * @param {Object} newParent SimpleDOM node for the current state of the element\n     */\n    var generateChildEdits = function (oldParent, oldNodeMap, newParent, newNodeMap) {\n        /*jslint continue: true */\n\n        var newIndex = 0,\n            oldIndex = 0,\n            newChildren = newParent.children,\n            oldChildren = oldParent ? oldParent.children : [],\n            newChild,\n            oldChild,\n            newEdits = [],\n            newEdit,\n            textAfterID,\n            edits = [],\n            moves = [],\n            newElements = [];\n\n        /**\n         * We initially put new edit objects into the `newEdits` array so that we\n         * can fix them up with proper positioning information. This function is\n         * responsible for doing that fixup.\n         *\n         * The `beforeID` that appears in many edits tells the browser to make the\n         * change before the element with the given ID. In other words, an\n         * elementInsert with a `beforeID` of 32 would result in something like\n         * `parentElement.insertBefore(newChildElement, _queryBracketsID(32))`\n         *\n         * Many new edits are captured in the `newEdits` array so that a suitable\n         * `beforeID` can be added to them before they are added to the main edits\n         * list. This function sets the `beforeID` on any pending edits and adds\n         * them to the main list.\n         *\n         * If this item is not being deleted, then it will be used as the `afterID`\n         * for text edits that follow.\n         *\n         * @param {int} beforeID ID to set on the pending edits\n         * @param {boolean} isBeingDeleted true if the given item is being deleted. If so,\n         *     we can't use it as the `afterID` for future edits--whatever previous item\n         *     was set as the `textAfterID` is still okay.\n         */\n        var finalizeNewEdits = function (beforeID, isBeingDeleted) {\n            newEdits.forEach(function (edit) {\n                // elementDeletes don't need any positioning information\n                if (edit.type !== \"elementDelete\") {\n                    edit.beforeID = beforeID;\n                }\n            });\n            edits.push.apply(edits, newEdits);\n            newEdits = [];\n\n            // If the item we made this set of edits relative to\n            // is being deleted, we can't use it as the afterID for future\n            // edits. It's okay to just keep the previous afterID, since\n            // this node will no longer be in the tree by the time we get\n            // to any future edit that needs an afterID.\n            if (!isBeingDeleted) {\n                textAfterID = beforeID;\n            }\n        };\n\n        /**\n         * If the current element was not in the old DOM, then we will create\n         * an elementInsert edit for it.\n         *\n         * If the element was in the old DOM, this will return false and the\n         * main loop will either spot this element later in the child list\n         * or the element has been moved.\n         *\n         * @return {boolean} true if an elementInsert was created\n         */\n        var addElementInsert = function () {\n            if (!oldNodeMap[newChild.tagID]) {\n                newEdit = {\n                    type: \"elementInsert\",\n                    tag: newChild.tag,\n                    tagID: newChild.tagID,\n                    parentID: newChild.parent.tagID,\n                    attributes: newChild.attributes\n                };\n\n                newEdits.push(newEdit);\n\n                // This newly inserted node needs to have edits generated for its\n                // children, so we add it to the queue.\n                newElements.push(newChild);\n\n                // A textInsert edit that follows this elementInsert should use\n                // this element's ID.\n                textAfterID = newChild.tagID;\n\n                // new element means we need to move on to compare the next\n                // of the current tree with the one from the old tree that we\n                // just compared\n                newIndex++;\n                return true;\n            }\n            return false;\n        };\n\n        /**\n         * If the old element that we're looking at does not appear in the new\n         * DOM, that means it was deleted and we'll create an elementDelete edit.\n         *\n         * If the element is in the new DOM, then this will return false and\n         * the main loop with either spot this node later on or the element\n         * has been moved.\n         *\n         * @return {boolean} true if elementDelete was generated\n         */\n        var addElementDelete = function () {\n            if (!newNodeMap[oldChild.tagID]) {\n                // We can finalize existing edits relative to this node *before* it's\n                // deleted.\n                finalizeNewEdits(oldChild.tagID, true);\n\n                newEdit = {\n                    type: \"elementDelete\",\n                    tagID: oldChild.tagID\n                };\n                newEdits.push(newEdit);\n\n                // deleted element means we need to move on to compare the next\n                // of the old tree with the one from the current tree that we\n                // just compared\n                oldIndex++;\n                return true;\n            }\n            return false;\n        };\n\n        /**\n         * Adds a textInsert edit for a newly created text node.\n         */\n        var addTextInsert = function () {\n            newEdit = {\n                type: \"textInsert\",\n                content: newChild.content,\n                parentID: newChild.parent.tagID\n            };\n\n            // text changes will generally have afterID and beforeID, but we make\n            // special note if it's the first child.\n            if (textAfterID) {\n                newEdit.afterID = textAfterID;\n            } else {\n                newEdit.firstChild = true;\n            }\n            newEdits.push(newEdit);\n\n            // The text node is in the new tree, so we move to the next new tree item\n            newIndex++;\n        };\n\n        /**\n         * Finds the previous child of the new tree.\n         *\n         * @return {?Object} previous child or null if there wasn't one\n         */\n        var prevNode = function () {\n            if (newIndex > 0) {\n                return newParent.children[newIndex - 1];\n            }\n            return null;\n        };\n\n        /**\n         * Adds a textDelete edit for text node that is not in the new tree.\n         * Note that we actually create a textReplace rather than a textDelete\n         * if the previous node in current tree was a text node. We do this because\n         * text nodes are not individually addressable and a delete event would\n         * end up clearing out both that previous text node that we want to keep\n         * and this text node that we want to eliminate. Instead, we just log\n         * a textReplace which will result in the deletion of this node and\n         * the maintaining of the old content.\n         */\n        var addTextDelete = function () {\n            var prev = prevNode();\n            if (prev && !prev.children) {\n                newEdit = {\n                    type: \"textReplace\",\n                    content: prev.content\n                };\n            } else {\n                newEdit = {\n                    type: \"textDelete\"\n                };\n            }\n\n            // When elements are deleted or moved from the old set of children, you\n            // can end up with multiple text nodes in a row. A single textReplace edit\n            // will take care of those (and will contain all of the right content since\n            // the text nodes between elements in the new DOM are merged together).\n            // The check below looks to see if we're already in the process of adding\n            // a textReplace edit following the same element.\n            var previousEdit = newEdits.length > 0 && newEdits[newEdits.length - 1];\n            if (previousEdit && previousEdit.type === \"textReplace\" &&\n                    previousEdit.afterID === textAfterID) {\n                oldIndex++;\n                return;\n            }\n\n            newEdit.parentID = oldChild.parent.tagID;\n\n            // If there was only one child previously, we just pass along\n            // textDelete/textReplace with the parentID and the browser will\n            // clear all of the children\n            if (oldChild.parent.children.length === 1) {\n                newEdits.push(newEdit);\n            } else {\n                if (textAfterID) {\n                    newEdit.afterID = textAfterID;\n                }\n                newEdits.push(newEdit);\n            }\n\n            // This text appeared in the old tree but not the new one, so we\n            // increment the old children counter.\n            oldIndex++;\n        };\n\n        /**\n         * Adds an elementMove edit if the parent has changed between the old and new trees.\n         * These are fairly infrequent and generally occur if you make a change across\n         * tag boundaries.\n         *\n         * @return {boolean} true if an elementMove was generated\n         */\n        var addElementMove = function () {\n\n            // This check looks a little strange, but it suits what we're trying\n            // to do: as we're walking through the children, a child node that has moved\n            // from one parent to another will be found but would look like some kind\n            // of insert. The check that we're doing here is looking up the current\n            // child's ID in the *old* map and seeing if this child used to have a\n            // different parent.\n            var possiblyMovedElement = oldNodeMap[newChild.tagID];\n            if (possiblyMovedElement &&\n                    newParent.tagID !== getParentID(possiblyMovedElement)) {\n                newEdit = {\n                    type: \"elementMove\",\n                    tagID: newChild.tagID,\n                    parentID: newChild.parent.tagID\n                };\n                moves.push(newEdit.tagID);\n                newEdits.push(newEdit);\n\n                // this element in the new tree was a move to this spot, so we can move\n                // on to the next child in the new tree.\n                newIndex++;\n                return true;\n            }\n            return false;\n        };\n\n        /**\n         * Looks to see if the element in the old tree has moved by checking its\n         * current and former parents.\n         *\n         * @return {boolean} true if the element has moved\n         */\n        var hasMoved = function (oldChild) {\n            var oldChildInNewTree = newNodeMap[oldChild.tagID];\n\n            return oldChild.children && oldChildInNewTree && getParentID(oldChild) !== getParentID(oldChildInNewTree);\n        };\n\n        // Loop through the current and old children, comparing them one by one.\n        while (newIndex < newChildren.length && oldIndex < oldChildren.length) {\n            newChild = newChildren[newIndex];\n\n            // Check to see if the currentChild has been reparented from somewhere\n            // else in the old tree\n            if (newChild.children && addElementMove()) {\n                continue;\n            }\n\n            oldChild = oldChildren[oldIndex];\n\n            // Check to see if the oldChild has been moved to another parent.\n            // If it has, we deal with it on the other side (see above)\n            if (hasMoved(oldChild)) {\n                oldIndex++;\n                continue;\n            }\n\n            if (newChild.isElement() || oldChild.isElement()) {\n\n                if (newChild.isElement() && oldChild.isText()) {\n                    addTextDelete();\n\n                    // If this element is new, add it and move to the next child\n                    // in the current tree. Otherwise, we'll compare this same\n                    // current element with the next old element on the next pass\n                    // through the loop.\n                    addElementInsert();\n\n                } else if (oldChild.isElement() && newChild.isText()) {\n                    // If the old child has *not* been deleted, we assume that we've\n                    // inserted some text and will still encounter the old node\n                    if (!addElementDelete()) {\n                        addTextInsert();\n                    }\n\n                // both children are elements\n                } else {\n                    if (newChild.tagID !== oldChild.tagID) {\n\n                        // First, check to see if we're deleting an element.\n                        // If we are, get rid of that element and restart our comparison\n                        // logic with the same element from the new tree and the next one\n                        // from the old tree.\n                        if (!addElementDelete()) {\n                            // Since we're not deleting and these elements don't match up, we\n                            // must have a new element. Add an elementInsert (and log a problem\n                            // if no insert works.)\n                            if (!addElementInsert()) {\n                                console.error(\"HTML Instrumentation: This should not happen. Two elements have different tag IDs and there was no insert/delete. This generally means there was a reordering of elements.\");\n                                newIndex++;\n                                oldIndex++;\n                            }\n                        }\n\n                    // There has been no change in the tag we're looking at.\n                    } else {\n                        // Since this element hasn't moved, it is a suitable \"beforeID\"\n                        // for the edits we've logged.\n                        finalizeNewEdits(oldChild.tagID, false);\n                        newIndex++;\n                        oldIndex++;\n                    }\n                }\n\n            // We know we're comparing two texts. Just match up their signatures.\n            } else {\n                if (newChild.textSignature !== oldChild.textSignature) {\n                    newEdit = {\n                        type: \"textReplace\",\n                        content: newChild.content,\n                        parentID: newChild.parent.tagID\n                    };\n                    if (textAfterID) {\n                        newEdit.afterID = textAfterID;\n                    }\n                    newEdits.push(newEdit);\n                }\n\n                // Either we've done a text replace or both sides matched. In either\n                // case we're ready to move forward among both the old and new children.\n                newIndex++;\n                oldIndex++;\n            }\n        }\n\n        // At this point, we've used up all of the children in at least one of the\n        // two sets of children.\n\n        /**\n         * Take care of any remaining children in the old tree.\n         */\n        while (oldIndex < oldChildren.length) {\n            oldChild = oldChildren[oldIndex];\n\n            // Check for an element that has moved\n            if (hasMoved(oldChild)) {\n                // This element has moved, so we skip it on this side (the move\n                // is handled on the new tree side).\n                oldIndex++;\n\n            // is this an element? if so, delete it\n            } else if (oldChild.isElement()) {\n                if (!addElementDelete()) {\n                    console.error(\"HTML Instrumentation: failed to add elementDelete for remaining element in the original DOM. This should not happen.\", oldChild);\n                    oldIndex++;\n                }\n\n            // must be text. delete that.\n            } else {\n                addTextDelete();\n            }\n        }\n\n        /**\n         * Take care of the remaining children in the new tree.\n         */\n        while (newIndex < newChildren.length) {\n            newChild = newChildren[newIndex];\n\n            // Is this an element?\n            if (newChild.isElement()) {\n\n                // Look to see if the element has moved here.\n                if (!addElementMove()) {\n                    // Not a move, so we insert this element.\n                    if (!addElementInsert()) {\n                        console.error(\"HTML Instrumentation: failed to add elementInsert for remaining element in the updated DOM. This should not happen.\");\n                        newIndex++;\n                    }\n                }\n\n            // not a new element, so it must be new text.\n            } else {\n                addTextInsert();\n            }\n        }\n\n        /**\n         * Finalize remaining edits. For inserts and moves, we can set the `lastChild`\n         * flag and the browser can simply use `appendChild` to add these items.\n         */\n        newEdits.forEach(function (edit) {\n            if (edit.type === \"textInsert\" || edit.type === \"elementInsert\" || edit.type === \"elementMove\") {\n                edit.lastChild = true;\n                delete edit.firstChild;\n                delete edit.afterID;\n            }\n        });\n        edits.push.apply(edits, newEdits);\n\n        return {\n            edits: edits,\n            moves: moves,\n            newElements: newElements\n        };\n    };\n\n    /**\n     * Generate a list of edits that will mutate oldNode to look like newNode.\n     * Currently, there are the following possible edit operations:\n     *\n     * * elementInsert\n     * * elementDelete\n     * * elementMove\n     * * textInsert\n     * * textDelete\n     * * textReplace\n     * * attrDelete\n     * * attrChange\n     * * attrAdd\n     * * rememberNodes (a special instruction that reflects the need to hang on to moved nodes)\n     *\n     * @param {Object} oldNode SimpleDOM node with the original content\n     * @param {Object} newNode SimpleDOM node with the new content\n     * @return {Array.{Object}} list of edit operations\n     */\n    function domdiff(oldNode, newNode) {\n        var queue = [],\n            edits = [],\n            moves = [],\n            newElement,\n            oldElement,\n            oldNodeMap = oldNode ? oldNode.nodeMap : {},\n            newNodeMap = newNode.nodeMap;\n\n        /**\n         * Adds elements to the queue for generateChildEdits.\n         * Only elements (and not text nodes) are added. New nodes (ones that aren't in the\n         * old nodeMap), are not added here because they will be added when generateChildEdits\n         * creates the elementInsert edit.\n         */\n        var queuePush = function (node) {\n            if (node.children && oldNodeMap[node.tagID]) {\n                queue.push(node);\n            }\n        };\n\n        /**\n         * Aggregates the child edits in the proper data structures.\n         *\n         * @param {Object} delta edits, moves and newElements to add\n         */\n        var addEdits = function (delta) {\n            edits.push.apply(edits, delta.edits);\n            moves.push.apply(moves, delta.moves);\n            queue.push.apply(queue, delta.newElements);\n        };\n\n        // Start at the root of the current tree.\n        queue.push(newNode);\n\n        do {\n            newElement = queue.pop();\n            oldElement = oldNodeMap[newElement.tagID];\n\n            // Do we need to compare elements?\n            if (oldElement) {\n\n                // Are attributes different?\n                if (newElement.attributeSignature !== oldElement.attributeSignature) {\n                    // generate attribute edits\n                    edits.push.apply(edits, generateAttributeEdits(oldElement, newElement));\n                }\n\n                // Has there been a change to this node's immediate children?\n                if (newElement.childSignature !== oldElement.childSignature) {\n                    addEdits(generateChildEdits(oldElement, oldNodeMap, newElement, newNodeMap));\n                }\n\n                // If there's a change farther down in the tree, add the children to the queue.\n                // If not, we can skip that whole subtree.\n                if (newElement.subtreeSignature !== oldElement.subtreeSignature) {\n                    newElement.children.forEach(queuePush);\n                }\n\n            // This is a new element, so go straight to generating child edits (which will\n            // create the appropriate Insert edits).\n            } else {\n                // If this is the root (html) tag, we need to manufacture an insert for it here,\n                // because it isn't the child of any other node. The browser-side code doesn't\n                // care about parentage/positioning in this case, and will handle just setting the\n                // ID on the existing implied HTML tag in the browser without actually creating it.\n                if (!newElement.parent) {\n                    edits.push({\n                        type: \"elementInsert\",\n                        tag: newElement.tag,\n                        tagID: newElement.tagID,\n                        parentID: null,\n                        attributes: newElement.attributes\n                    });\n                }\n\n                addEdits(generateChildEdits(null, oldNodeMap, newElement, newNodeMap));\n            }\n        } while (queue.length);\n\n        // Special handling for moves: add edits to the beginning of the list so that\n        // moved nodes are set aside to ensure that they remain available at the time of their\n        // move.\n        if (moves.length > 0) {\n            edits.unshift({\n                type: \"rememberNodes\",\n                tagIDs: moves\n            });\n        }\n\n        return edits;\n    }\n\n    // Public API\n    exports.domdiff = domdiff;\n});\n"],"file":"HTMLDOMDiff.js"}
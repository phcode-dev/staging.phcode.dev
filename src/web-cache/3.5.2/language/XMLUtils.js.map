{"version":3,"sources":["language/XMLUtils.js"],"names":["define","require","exports","module","TokenUtils","TOKEN_TAG","TOKEN_ATTR","TOKEN_VALUE","regexWhitespace","_createTagInfo","token","tokenType","offset","exclusionList","tagName","attrName","shouldReplace","_getTagAttributes","editor","constPos","pos","ctx","ctxPrev","ctxNext","ctxTemp","$","extend","getInitialContext","_codeMirror","type","test","string","moveSkippingWhitespace","moveNextToken","movePrevToken","indexOf","push","_getTagAttributeValue","textBefore","textAfter","offsetInToken","substr","length","concat","split","slice","filter","value","getTagInfo","tagAttrs","tagAttrValue","charAt","end","ch","getValueQuery","tagInfo","query"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2015 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Load dependencies.\n    var TokenUtils  = require(\"utils/TokenUtils\");\n\n    // Enums of token types.\n    var TOKEN_TAG    = 1,\n        TOKEN_ATTR   = 2,\n        TOKEN_VALUE  = 3;\n\n    // Regex to find whitespace.\n    var regexWhitespace = /^\\s+$/;\n\n    /**\n     * Returns an object that represents all its params.\n     *\n     * @param {!Token} token CodeMirror token at the current pos\n     * @param {number} tokenType Type of current token\n     * @param {number} offset Offset in current token\n     * @param {Array.<string>} exclusionList List of attributes of a tag or attribute options used by an attribute\n     * @param {string} tagName Name of the current tag\n     * @param {string} attrName Name of the current attribute\n     * @param {boolean} shouldReplace true if we don't want to append =\"\" to an attribute\n     * @return {!{token: Token, tokenType: int, offset: int, exclusionList: Array.<string>, tagName: string, attrName: string, shouldReplace: boolean}}\n     */\n    function _createTagInfo(token, tokenType, offset, exclusionList, tagName, attrName, shouldReplace) {\n        return {\n            token: token || null,\n            tokenType: tokenType || null,\n            offset: offset || 0,\n            exclusionList: exclusionList || [],\n            tagName: tagName || \"\",\n            attrName: attrName || \"\",\n            shouldReplace: shouldReplace || false\n        };\n    }\n\n    /**\n     * Return the tagName and a list of attributes used by the tag.\n     *\n     * @param {!Editor} editor An instance of active editor\n     * @param {!{line: number, ch: number}} constPos The position of cursor in the active editor\n     * @return {!{tagName: string, exclusionList: Array.<string>, shouldReplace: boolean}}\n     */\n    function _getTagAttributes(editor, constPos) {\n        var pos, ctx, ctxPrev, ctxNext, ctxTemp, tagName, exclusionList = [], shouldReplace;\n\n        pos = $.extend({}, constPos);\n        ctx = TokenUtils.getInitialContext(editor._codeMirror, pos);\n\n        // Stop if the cursor is before = or an attribute value.\n        ctxTemp = $.extend(true, {}, ctx);\n        if (ctxTemp.token.type === null && regexWhitespace.test(ctxTemp.token.string)) {\n            if (TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctxTemp)) {\n                if ((ctxTemp.token.type === null && ctxTemp.token.string === \"=\") ||\n                        ctxTemp.token.type === \"string\") {\n                    return null;\n                }\n                TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctxTemp);\n            }\n        }\n\n        // Incase an attribute is followed by an equal sign, shouldReplace will be used\n        // to prevent from appending =\"\" again.\n        if (ctxTemp.token.type === \"attribute\") {\n            if (TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctxTemp)) {\n                if (ctxTemp.token.type === null && ctxTemp.token.string === \"=\") {\n                    shouldReplace = true;\n                }\n            }\n        }\n\n        // Look-Back and get the attributes and tag name.\n        pos = $.extend({}, constPos);\n        ctxPrev = TokenUtils.getInitialContext(editor._codeMirror, pos);\n        while (TokenUtils.movePrevToken(ctxPrev)) {\n            if (ctxPrev.token.type && ctxPrev.token.type.indexOf(\"tag bracket\") >= 0) {\n                // Disallow hints in closed tag and inside tag content\n                if (ctxPrev.token.string === \"</\" || ctxPrev.token.string.indexOf(\">\") !== -1) {\n                    return null;\n                }\n            }\n\n            // Get attributes.\n            if (ctxPrev.token.type === \"attribute\") {\n                exclusionList.push(ctxPrev.token.string);\n            }\n\n            // Get tag.\n            if (ctxPrev.token.type === \"tag\") {\n                tagName = ctxPrev.token.string;\n                if (TokenUtils.movePrevToken(ctxPrev)) {\n                    if (ctxPrev.token.type === \"tag bracket\" && ctxPrev.token.string === \"<\") {\n                        break;\n                    }\n                    return null;\n                }\n            }\n        }\n\n        // Look-Ahead and find rest of the attributes.\n        pos = $.extend({}, constPos);\n        ctxNext = TokenUtils.getInitialContext(editor._codeMirror, pos);\n        while (TokenUtils.moveNextToken(ctxNext)) {\n            if (ctxNext.token.type === \"string\" && ctxNext.token.string === \"\\\"\") {\n                return null;\n            }\n\n            // Stop on closing bracket of its own tag or opening bracket of next tag.\n            if (ctxNext.token.type === \"tag bracket\" &&\n                    (ctxNext.token.string.indexOf(\">\") >= 0 || ctxNext.token.string === \"<\")) {\n                break;\n            }\n            if (ctxNext.token.type === \"attribute\" && exclusionList.indexOf(ctxNext.token.string) === -1) {\n                exclusionList.push(ctxNext.token.string);\n            }\n        }\n        return {\n            tagName: tagName,\n            exclusionList: exclusionList,\n            shouldReplace: shouldReplace\n        };\n    }\n\n    /**\n     * Return the tag name, attribute name and a list of options used by the attribute\n     *\n     * @param {!Editor} editor An instance of active editor\n     * @param {!{line: number, ch: number}} pos Position of cursor in the editor\n     * @return {!{tagName: string, attrName: string, exclusionList: Array.<string>}}\n     */\n    function _getTagAttributeValue(editor, pos) {\n        var ctx, tagName, attrName, exclusionList = [], offset, textBefore, textAfter;\n\n        ctx = TokenUtils.getInitialContext(editor._codeMirror, pos);\n        offset = TokenUtils.offsetInToken(ctx);\n\n        // To support multiple options on the same attribute, we have\n        // to break the value, these values will not be available then.\n        if (ctx.token.type === \"string\" && /\\s+/.test(ctx.token.string)) {\n            textBefore = ctx.token.string.substr(1, offset);\n            textAfter = ctx.token.string.substr(offset);\n\n            // Remove quote from end of the string.\n            if (/^['\"]$/.test(ctx.token.string.substr(-1, 1))) {\n                textAfter = textAfter.substr(0, textAfter.length - 1);\n            }\n\n            // Split the text before and after the offset, skipping the current query.\n            exclusionList = exclusionList.concat(textBefore.split(/\\s+/).slice(0, -1));\n            exclusionList = exclusionList.concat(textAfter.split(/\\s+/));\n\n            // Filter through the list removing empty strings.\n            exclusionList = exclusionList.filter(function (value) {\n                if (value.length > 0) {\n                    return true;\n                }\n            });\n        }\n\n        // Look-back and find tag and attributes.\n        while (TokenUtils.movePrevToken(ctx)) {\n            if (ctx.token.type === \"tag bracket\") {\n                // Disallow hints in closing tags.\n                if (ctx.token.string === \"</\") {\n                    return null;\n                }\n                // Stop when closing bracket of another tag or opening bracket of its own in encountered.\n                if (ctx.token.string.indexOf(\">\") >= 0 || ctx.token.string === \"<\") {\n                    break;\n                }\n            }\n\n            // Get the first previous attribute.\n            if (ctx.token.type === \"attribute\" && !attrName) {\n                attrName = ctx.token.string;\n            }\n\n            // Stop if we get a bracket after tag.\n            if (ctx.token.type === \"tag\") {\n                tagName = ctx.token.string;\n                if (TokenUtils.movePrevToken(ctx)) {\n                    if (ctx.token.type === \"tag bracket\" && ctx.token.string === \"<\") {\n                        break;\n                    }\n                    return null;\n                }\n            }\n        }\n\n        return {\n            tagName: tagName,\n            attrName: attrName,\n            exclusionList: exclusionList\n        };\n    }\n\n    /**\n     * Return the tag info at a given position in the active editor\n     *\n     * @param {!Editor} editor Instance of active editor\n     * @param {!{line: number, ch: number}} pos Position of cursor in the editor\n     * @return {!{token: Object, tokenType: number, offset: number, exclusionList: Array.<string>, tagName: string, attrName: string, shouldReplace: boolean}}\n     */\n    function getTagInfo(editor, pos) {\n        var ctx, offset, tagAttrs, tagAttrValue;\n\n        ctx = TokenUtils.getInitialContext(editor._codeMirror, pos);\n        offset = TokenUtils.offsetInToken(ctx);\n\n        if (ctx.token && ctx.token.type === \"tag bracket\" && ctx.token.string === \"<\") {\n            // Returns tagInfo when an angle bracket is created.\n            return _createTagInfo(ctx.token, TOKEN_TAG);\n        } else if (ctx.token && ctx.token.type === \"tag\") {\n            // Return tagInfo when a tag is created.\n            if (TokenUtils.movePrevToken(ctx)) {\n                if (ctx.token.type === \"tag bracket\" && ctx.token.string === \"<\") {\n                    TokenUtils.moveNextToken(ctx);\n                    return _createTagInfo(ctx.token, TOKEN_TAG, offset);\n                }\n            }\n        } else if (ctx.token && (ctx.token.type === \"attribute\" ||\n                                 (ctx.token.type === null && regexWhitespace.test(ctx.token.string)))) {\n            // Return tagInfo when an attribute is created.\n            tagAttrs = _getTagAttributes(editor, pos);\n            if (tagAttrs && tagAttrs.tagName) {\n                return _createTagInfo(ctx.token, TOKEN_ATTR, offset, tagAttrs.exclusionList, tagAttrs.tagName, null, tagAttrs.shouldReplace);\n            }\n        } else if (ctx.token && ((ctx.token.type === null && ctx.token.string === \"=\") ||\n                                 (ctx.token.type === \"string\" && /^['\"]$/.test(ctx.token.string.charAt(0))))) {\n            // Return tag info when an attribute value is created.\n            // Allow no hints if the cursor is outside the value.\n            if (ctx.token.type === \"string\" &&\n                    /^['\"]$/.test(ctx.token.string.substr(-1, 1)) &&\n                    ctx.token.string.length !== 1 &&\n                    ctx.token.end === pos.ch) {\n                return _createTagInfo();\n            }\n\n            tagAttrValue = _getTagAttributeValue(editor, pos);\n            if (tagAttrValue && tagAttrValue.tagName && tagAttrValue.attrName) {\n                return _createTagInfo(ctx.token, TOKEN_VALUE, offset, tagAttrValue.exclusionList, tagAttrValue.tagName, tagAttrValue.attrName);\n            }\n        }\n        return _createTagInfo();\n    }\n\n    /**\n     * Return the query text of a value.\n     *\n     * @param {!{token: Object, tokenType: number, offset: number, exclusionList: Array.<string>, tagName: string, attrName: string, shouldReplace: boolean}}\n     * @return {string}  The query to use to matching hints.\n     */\n    function getValueQuery(tagInfo) {\n        var query;\n        if (tagInfo.token.string === \"=\") {\n            return \"\";\n        }\n        // Remove quotation marks in query.\n        query = tagInfo.token.string.substr(1, tagInfo.offset - 1);\n\n        // Get the last option to use as a query to support multiple options.\n        return query.split(/\\s+/).slice(-1)[0];\n    }\n\n    // Expose public API.\n    exports.getTagInfo      = getTagInfo;\n    exports.getValueQuery   = getValueQuery;\n    exports.regexWhitespace = regexWhitespace;\n    exports.TOKEN_TAG       = TOKEN_TAG;\n    exports.TOKEN_ATTR      = TOKEN_ATTR;\n    exports.TOKEN_VALUE     = TOKEN_VALUE;\n});\n"],"file":"XMLUtils.js"}
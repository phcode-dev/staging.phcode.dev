{"version":3,"sources":["extensions/default/JavaScriptRefactoring/RenameIdentifier.js"],"names":["define","require","exports","module","EditorManager","brackets","getModule","ScopeManager","Session","MessageIds","JSON","parse","TokenUtils","Strings","Editor","ProjectManager","session","keywords","MARK_TYPE_RENAME","initializeSession","editor","getRefs","fileInfo","offset","postMessage","type","TERN_REFS","addPendingRequest","name","requestFindRefs","document","path","file","fullPath","ternPromise","promise","TERN_FILE_INFO_TYPE_FULL","offsetLines","text","filterText","getJavascriptText","handleRename","getActiveEditor","token","getSelections","length","displayErrorMessageAtCursor","ERROR_RENAME_MULTICURSOR","getModeForSelection","getTokenAt","_codeMirror","posFromIndex","getOffset","indexOf","string","ERROR_RENAME_GENERAL","result","$","Deferred","isInSameFile","obj","refsResp","projectRoot","getProjectRoot","projectDir","fileName","slice","_multiFileRename","refs","_outlineText","currentEditor","selections","primary","getSelection","markText","start","end","MARK_OPTION_RENAME_OUTLINE","off","EVENT_BEFORE_SELECTION_CHANGE","on","_evt","newSelections","ranges","clearAllMarks","handleFindRefs","references","inlineWidget","getFocusedInlineWidget","isInTextRange","find","item","line","_startLine","_endLine","ERROR_RENAME_QUICKEDIT","currentPosition","refsArray","primaryRef","filter","element","ch","setSelections","requestFindReferences","response","hasOwnProperty","done","fail","errorMsg","reject","_MARK_TYPE_RENAME"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    const EditorManager        = brackets.getModule(\"editor/EditorManager\"),\n        ScopeManager         = brackets.getModule(\"JSUtils/ScopeManager\"),\n        Session              = brackets.getModule(\"JSUtils/Session\"),\n        MessageIds           = JSON.parse(brackets.getModule(\"text!JSUtils/MessageIds.json\")),\n        TokenUtils           = brackets.getModule(\"utils/TokenUtils\"),\n        Strings              = brackets.getModule(\"strings\"),\n        Editor               = brackets.getModule(\"editor/Editor\").Editor,\n        ProjectManager       = brackets.getModule(\"project/ProjectManager\");\n\n    let session             = null,  // object that encapsulates the current session state\n        keywords = [\"define\", \"alert\", \"exports\", \"require\", \"module\", \"arguments\"];\n\n    const MARK_TYPE_RENAME = \"renameVar\";\n\n    //Create new session\n    function initializeSession(editor) {\n        session = new Session(editor);\n    }\n\n    //Post message to tern node domain that will request tern server to find refs\n    function getRefs(fileInfo, offset) {\n        ScopeManager.postMessage({\n            type: MessageIds.TERN_REFS,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return ScopeManager.addPendingRequest(fileInfo.name, offset, MessageIds.TERN_REFS);\n    }\n\n    //Create info required to find reference\n    function requestFindRefs(session, document, offset) {\n        if (!document || !session) {\n            return;\n        }\n        let path    = document.file.fullPath,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: ScopeManager.filterText(session.getJavascriptText())\n            };\n        let ternPromise = getRefs(fileInfo, offset);\n\n        return {promise: ternPromise};\n    }\n\n    //Do rename of identifier which is at cursor\n    function handleRename() {\n        let editor = EditorManager.getActiveEditor(),\n            offset, token;\n\n        if (!editor) {\n            return;\n        }\n\n        if (editor.getSelections().length > 1) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_MULTICURSOR);\n            return;\n        }\n        initializeSession(editor);\n\n\n        if (!editor || editor.getModeForSelection() !== \"javascript\") {\n            return;\n        }\n\n        token = TokenUtils.getTokenAt(editor._codeMirror, editor._codeMirror.posFromIndex(session.getOffset()));\n\n        if (keywords.indexOf(token.string) >= 0) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_GENERAL);\n            return;\n        }\n\n        let result = new $.Deferred();\n\n        function isInSameFile(obj, refsResp) {\n            let projectRoot = ProjectManager.getProjectRoot(),\n                projectDir,\n                fileName = \"\";\n            if (projectRoot) {\n                projectDir = projectRoot.fullPath;\n            }\n\n            // get the relative path of File as Tern can also return\n            // references with file name as a relative path wrt projectRoot\n            // so refernce file name will be compared with both relative and absolute path to check if it is same file\n            if (projectDir && refsResp && refsResp.file && refsResp.file.indexOf(projectDir) === 0) {\n                fileName = refsResp.file.slice(projectDir.length);\n            }\n            // In case of unsaved files, After renameing once Tern is returning filename without forward slash\n            return (obj && (obj.file === refsResp.file || obj.file === fileName\n                            || obj.file === refsResp.file.slice(1, refsResp.file.length)));\n        }\n\n        function _multiFileRename(refs) {\n            // TODO: Multi file rename here\n            // note that before we enable this, we should load tern with the full code base to identify all\n            // references properly. This sadly needs refactoring the current tern integration heavily\n        }\n\n        function _outlineText(currentEditor) {\n            let selections = currentEditor.getSelections();\n            if(selections.length > 1 ){\n                let primary = currentEditor.getSelection();\n                currentEditor.markText(MARK_TYPE_RENAME, primary.start, primary.end, Editor.MARK_OPTION_RENAME_OUTLINE);\n                currentEditor.off(Editor.EVENT_BEFORE_SELECTION_CHANGE + \".renameVar\");\n                currentEditor.on(Editor.EVENT_BEFORE_SELECTION_CHANGE + \".renameVar\", function (_evt, newSelections) {\n                    if(newSelections.ranges && newSelections.ranges.length === 1) {\n                        currentEditor.clearAllMarks(MARK_TYPE_RENAME);\n                        currentEditor.off(Editor.EVENT_BEFORE_SELECTION_CHANGE + \".renameVar\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Check if references are in this file only\n         * If yes then select all references\n         */\n        function handleFindRefs (refsResp) {\n            if (!refsResp || !refsResp.references || !refsResp.references.refs) {\n                return;\n            }\n\n            let inlineWidget = EditorManager.getFocusedInlineWidget(),\n                editor = EditorManager.getActiveEditor(),\n                refs = refsResp.references.refs;\n\n            //In case of inline widget if some references are outside widget's text range then don't allow for rename\n            if (inlineWidget) {\n                let isInTextRange  = !refs.find(function(item) {\n                    return (item.start.line < inlineWidget._startLine || item.end.line > inlineWidget._endLine);\n                });\n\n                if (!isInTextRange) {\n                    editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_QUICKEDIT);\n                    return;\n                }\n            }\n\n            let currentPosition = editor.posFromIndex(refsResp.offset),\n                refsArray;\n            refsArray = refs.filter(function (element) {\n                return isInSameFile(element, refsResp);\n            });\n            if (refsArray.length !== refs.length) {\n                // There are references across multiple files, we are not ready to handle this yet\n                _multiFileRename(refs);\n                return;\n            }\n\n            // Finding the Primary Reference in Array\n            let primaryRef = refsArray.find(function (element) {\n                return ((element.start.line === currentPosition.line || element.end.line === currentPosition.line)\n                        && currentPosition.ch <= element.end.ch && currentPosition.ch >= element.start.ch);\n            });\n            // Setting the primary flag of Primary Refence to true\n            primaryRef.primary = true;\n\n            editor.setSelections(refsArray);\n            _outlineText(editor);\n        }\n\n        /**\n         * Make a find ref request.\n         * @param {Session} session - the session\n         * @param {number} offset - the offset of where to jump from\n         */\n        function requestFindReferences(session, offset) {\n            let response = requestFindRefs(session, session.editor.document, offset);\n\n            if (response && response.hasOwnProperty(\"promise\")) {\n                response.promise.done(handleFindRefs).fail(function (errorMsg) {\n                    EditorManager.getActiveEditor().displayErrorMessageAtCursor(errorMsg);\n                    result.reject();\n                });\n            }\n        }\n\n        offset = session.getOffset();\n        requestFindReferences(session, offset);\n\n        return result.promise();\n    }\n\n    // for tests\n    exports._MARK_TYPE_RENAME = MARK_TYPE_RENAME;\n\n    // public api\n    exports.handleRename = handleRename;\n});\n"],"file":"RenameIdentifier.js"}
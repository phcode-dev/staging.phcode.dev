{"version":3,"sources":["extensions/default/JavaScriptRefactoring/ExtractToFunction.js"],"names":["define","require","exports","module","ASTWalker","brackets","getModule","EditorManager","_","StringUtils","Session","RefactoringUtils","Strings","InlineMenu","template","JSON","parse","session","analyzeCode","text","scopes","srcScope","destScope","start","end","identifiers","inThisScope","thisPointerUsed","returnStatementUsed","variableDeclarations","changedValues","dependentValues","ast","getAST","doc","editor","document","restScopeStr","full","node","value","name","type","left","id","init","variableDeclarationNode","findSurroundASTNode","kind","argument","object","originNode","getText","substr","simple","Identifier","Expression","passProps","slice","reduce","props","scope","union","keys","retProps","passParams","intersection","difference","retParams","extract","isExpression","retObj","fnBody","fnName","getUniqueIdentifierName","fnDeclaration","fnCall","appendVarDeclaration","identifier","hasOwnProperty","isClass","format","functionCall","class","join","unshift","thisPointer","shift","normal","returnStatement","single","retParamsStr","length","multiple","map","param","assignment","functionDeclaration","posFromIndex","insertPos","clone","fnScopes","filter","isFnScope","i","surroundStatement","indexFromPos","ch","batchOperation","replaceRange","adjustPosForChange","split","setSelections","indexOf","line","numLines","_codeMirror","indentLine","handleExtractToFunction","getActiveEditor","result","$","Deferred","getSelections","displayErrorMessageAtCursor","ERROR_EXTRACTTO_FUNCTION_MULTICURSORS","resolve","initializeSession","selection","getSelection","normalizeText","getSelectedText","expns","inlineMenu","getScopeData","done","checkStatement","getExpression","getAllScopes","EXTRACTTO_FUNCTION_SELECT_SCOPE","open","onSelect","scopeId","close","onClose","ERROR_EXTRACTTO_FUNCTION_NOT_VALID","fail","ERROR_TERN_FAILED","promise"],"mappings":"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","sourcesContent":["/*\n*  Copyright (c) 2021 - present core.ai . All rights reserved.\n *  Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n*\n* Permission is hereby granted, free of charge, to any person obtaining a\n* copy of this software and associated documentation files (the \"Software\"),\n* to deal in the Software without restriction, including without limitation\n* the rights to use, copy, modify, merge, publish, distribute, sublicense,\n* and/or sell copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n* DEALINGS IN THE SOFTWARE.\n*\n*/\n\ndefine(function(require, exports, module) {\n\n\n    var ASTWalker           = brackets.getModule(\"thirdparty/acorn/dist/walk\"),\n        EditorManager       = brackets.getModule(\"editor/EditorManager\"),\n        _                   = brackets.getModule(\"thirdparty/lodash\"),\n        StringUtils         = brackets.getModule(\"utils/StringUtils\"),\n        Session             = brackets.getModule(\"JSUtils/Session\"),\n        RefactoringUtils    = require(\"RefactoringUtils\"),\n        Strings             = brackets.getModule(\"strings\"),\n        InlineMenu          = brackets.getModule(\"widgets/InlineMenu\").InlineMenu;\n\n    var template = JSON.parse(require(\"text!Templates.json\"));\n\n    var session = null;\n\n    /**\n     * Analyzes the code and finds values required for extract to function\n     * @param {!string} text - text to be extracted\n     * @param {!Array.<Scope>} - scopes\n     * @param {!Scope} srcScope - source scope of the extraction\n     * @param {!Scope} destScope - destination scope of the extraction\n     * @param {!number} start - the start offset\n     * @param {!number} end - the end offset\n     * @return {!{\n     *          passParams: Array.<string>,\n     *          retParams: Array.<string>,\n     *          thisPointerUsed: boolean,\n     *          varaibleDeclarations: {} // variable-name: kind\n     * }}\n     */\n    function analyzeCode(text, scopes, srcScope, destScope, start, end) {\n        var identifiers          = {},\n            inThisScope          = {},\n            thisPointerUsed      = false,\n            returnStatementUsed  = false,\n            variableDeclarations = {},\n            changedValues        = {},\n            dependentValues      = {},\n            ast                  = RefactoringUtils.getAST(text),\n            doc                  = session.editor.document,\n            restScopeStr;\n\n        ASTWalker.full(ast, function(node) {\n            var value, name;\n            switch (node.type) {\n            case \"AssignmentExpression\":\n                value = node.left;\n                break;\n            case \"VariableDeclarator\":\n                inThisScope[node.id.name] = true;\n                value = node.init && node.id;\n                var variableDeclarationNode = RefactoringUtils.findSurroundASTNode(ast, node, [\"VariableDeclaration\"]);\n                variableDeclarations[node.id.name] = variableDeclarationNode.kind;\n                break;\n            case \"ThisExpression\":\n                thisPointerUsed = true;\n                break;\n            case \"UpdateExpression\":\n                value = node.argument;\n                break;\n            case \"Identifier\":\n                identifiers[node.name] = true;\n                break;\n            case \"ReturnStatement\":\n                returnStatementUsed = true;\n                break;\n            }\n            if (value){\n                if (value.type === \"MemberExpression\") {\n                    name = value.object.name;\n                } else {\n                    name = value.name;\n                }\n                changedValues[name] = true;\n            }\n        });\n\n        if (srcScope.originNode) {\n            restScopeStr = doc.getText().substr(end, srcScope.originNode.end - end);\n        } else {\n            restScopeStr = doc.getText().substr(end);\n        }\n\n        ASTWalker.simple(RefactoringUtils.getAST(restScopeStr), {\n            Identifier: function(node) {\n                var name = node.name;\n                dependentValues[name] = true;\n            },\n            Expression: function(node) {\n                if (node.type === \"MemberExpression\") {\n                    var name = node.object.name;\n                    dependentValues[name] = true;\n                }\n            }\n        });\n\n        var passProps = scopes.slice(srcScope.id, destScope.id).reduce(function(props, scope) {\n            return _.union(props, _.keys(scope.props));\n        }, []);\n\n        var retProps = scopes.slice(srcScope.id, destScope.id + 1).reduce(function(props, scope) {\n            return _.union(props, _.keys(scope.props));\n        }, []);\n\n        return {\n            passParams: _.intersection(_.difference(_.keys(identifiers), _.keys(inThisScope)), passProps),\n            retParams: _.intersection( _.keys(changedValues), _.keys(dependentValues), retProps),\n            thisPointerUsed: thisPointerUsed,\n            returnStatementUsed: returnStatementUsed,\n            variableDeclarations: variableDeclarations\n        };\n    }\n\n    /**\n     * Does the actual extraction. i.e Replacing the text, Creating a function\n     * and multi select function names\n     */\n    function extract(ast, text, scopes, srcScope, destScope, start, end, isExpression) {\n        var retObj               = analyzeCode(text, scopes, srcScope, destScope, start, end),\n            passParams           = retObj.passParams,\n            retParams            = retObj.retParams,\n            thisPointerUsed      = retObj.thisPointerUsed,\n            returnStatementUsed  = retObj.returnStatementUsed,\n            variableDeclarations = retObj.variableDeclarations,\n            doc                  = session.editor.document,\n            fnBody               = text,\n            fnName               = RefactoringUtils.getUniqueIdentifierName(scopes, \"extracted\"),\n            fnDeclaration,\n            fnCall;\n\n        function appendVarDeclaration(identifier) {\n            if (variableDeclarations.hasOwnProperty(identifier)) {\n                return variableDeclarations[identifier] + \" \" + identifier;\n            }\n\n            return identifier;\n\n        }\n\n        if (destScope.isClass) {\n            fnCall = StringUtils.format(template.functionCall.class, fnName, passParams.join(\", \"));\n        } else if (thisPointerUsed) {\n            passParams.unshift(\"this\");\n            fnCall = StringUtils.format(template.functionCall.thisPointer, fnName, passParams.join(\", \"));\n            passParams.shift();\n        } else {\n            fnCall = StringUtils.format(template.functionCall.normal, fnName, passParams.join(\", \"));\n        }\n\n        // Append return to the fnCall, if the extracted text contains return statement\n        // Ideally in this case retParams should be empty.\n        if (returnStatementUsed) {\n            fnCall = \"return \" + fnCall;\n        }\n\n        if (isExpression) {\n            fnBody = StringUtils.format(template.returnStatement.single, fnBody);\n        } else {\n\n            var retParamsStr = \"\";\n            if (retParams.length > 1) {\n                retParamsStr = StringUtils.format(template.returnStatement.multiple, retParams.join(\", \"));\n                fnCall = \"var ret = \" + fnCall + \";\\n\";\n                fnCall += retParams.map(function (param) {\n                    return StringUtils.format(template.assignment, appendVarDeclaration(param),  \"ret.\" + param);\n                }).join(\"\\n\");\n            } else if (retParams.length === 1) {\n                retParamsStr = StringUtils.format(template.returnStatement.single, retParams.join(\", \"));\n                fnCall = StringUtils.format(template.assignment, appendVarDeclaration(retParams[0]), fnCall);\n            } else {\n                fnCall += \";\";\n            }\n\n            fnBody = fnBody + \"\\n\" + retParamsStr;\n        }\n\n        if (destScope.isClass) {\n            fnDeclaration = StringUtils.format(template.functionDeclaration.class, fnName, passParams.join(\", \"), fnBody);\n        } else {\n            fnDeclaration = StringUtils.format(template.functionDeclaration.normal, fnName, passParams.join(\", \"), fnBody);\n        }\n\n        start = session.editor.posFromIndex(start);\n        end   = session.editor.posFromIndex(end);\n\n        // Get the insertion pos for function declaration\n        var insertPos = _.clone(start);\n        var fnScopes = scopes.filter(RefactoringUtils.isFnScope);\n\n        for (var i = 0; i < fnScopes.length; ++i) {\n            if (fnScopes[i].id === destScope.id) {\n                if (fnScopes[i - 1]) {\n                    insertPos = session.editor.posFromIndex(fnScopes[i - 1].originNode.start);\n                     // If the origin node of the destination scope is a function expression or a arrow function expression,\n                     // get the surrounding statement to get the position\n                    if (fnScopes[i - 1].originNode.type === \"FunctionExpression\" || fnScopes[i - 1].originNode.type === \"ArrowFunctionExpression\") {\n                        var surroundStatement = RefactoringUtils.findSurroundASTNode(ast, { start: session.editor.indexFromPos(insertPos)}, [\"Statement\"]);\n                        insertPos = session.editor.posFromIndex(surroundStatement.start);\n                    }\n                }\n                break;\n            }\n        }\n\n        insertPos.ch = 0;\n\n        // Replace and multi-select and indent\n        doc.batchOperation(function() {\n            // Replace\n            doc.replaceRange(fnCall, start, end);\n            doc.replaceRange(fnDeclaration, insertPos);\n\n            // Set selections\n            start = doc.adjustPosForChange(start, fnDeclaration.split(\"\\n\"), insertPos, insertPos);\n            end   = doc.adjustPosForChange(end, fnDeclaration.split(\"\\n\"), insertPos, insertPos);\n\n            session.editor.setSelections([\n                {\n                    start: session.editor.posFromIndex(session.editor.indexFromPos(start) + fnCall.indexOf(fnName)),\n                    end: session.editor.posFromIndex(session.editor.indexFromPos(start) + fnCall.indexOf(fnName) + fnName.length)\n                },\n                {\n                    start: session.editor.posFromIndex(session.editor.indexFromPos(insertPos) + fnDeclaration.indexOf(fnName)),\n                    end: session.editor.posFromIndex(session.editor.indexFromPos(insertPos) + fnDeclaration.indexOf(fnName) + fnName.length)\n                }\n            ]);\n\n            // indent\n            for (var i = start.line; i < start.line + RefactoringUtils.numLines(fnCall); ++i) {\n                session.editor._codeMirror.indentLine(i, \"smart\");\n            }\n            for (var i = insertPos.line; i < insertPos.line + RefactoringUtils.numLines(fnDeclaration); ++i) {\n                session.editor._codeMirror.indentLine(i, \"smart\");\n            }\n        });\n    }\n\n    /**\n     * Main function that handles extract to function\n     */\n    function handleExtractToFunction() {\n        var editor = EditorManager.getActiveEditor();\n        var result = new $.Deferred(); // used only for testing purpose\n\n        if (editor.getSelections().length > 1) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_EXTRACTTO_FUNCTION_MULTICURSORS);\n            result.resolve(Strings.ERROR_EXTRACTTO_FUNCTION_MULTICURSORS);\n            return;\n        }\n        initializeSession(editor);\n\n        var selection = editor.getSelection(),\n            doc       = editor.document,\n            retObj    = RefactoringUtils.normalizeText(editor.getSelectedText(), editor.indexFromPos(selection.start), editor.indexFromPos(selection.end)),\n            text      = retObj.text,\n            start     = retObj.start,\n            end       = retObj.end,\n            ast,\n            scopes,\n            expns,\n            inlineMenu;\n\n        RefactoringUtils.getScopeData(session, editor.posFromIndex(start)).done(function(scope) {\n            ast = RefactoringUtils.getAST(doc.getText());\n\n            var isExpression = false;\n            if (!RefactoringUtils.checkStatement(ast, start, end, doc.getText())) {\n                isExpression = RefactoringUtils.getExpression(ast, start, end, doc.getText());\n                if (!isExpression) {\n                    editor.displayErrorMessageAtCursor(Strings.ERROR_EXTRACTTO_FUNCTION_NOT_VALID);\n                    result.resolve(Strings.ERROR_EXTRACTTO_FUNCTION_NOT_VALID);\n                    return;\n                }\n            }\n            scopes = RefactoringUtils.getAllScopes(ast, scope, doc.getText());\n\n            // if only one scope, extract without menu\n            if (scopes.length === 1) {\n                extract(ast, text, scopes, scopes[0], scopes[0], start, end, isExpression);\n                result.resolve();\n                return;\n            }\n\n            inlineMenu = new InlineMenu(editor, Strings.EXTRACTTO_FUNCTION_SELECT_SCOPE);\n\n            inlineMenu.open(scopes.filter(RefactoringUtils.isFnScope));\n\n            result.resolve(inlineMenu);\n\n            inlineMenu.onSelect(function (scopeId) {\n                extract(ast, text, scopes, scopes[0], scopes[scopeId], start, end, isExpression);\n                inlineMenu.close();\n            });\n\n            inlineMenu.onClose(function(){\n                inlineMenu.close();\n            });\n        }).fail(function() {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_TERN_FAILED);\n            result.resolve(Strings.ERROR_TERN_FAILED);\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Creates a new session from editor and stores it in session global variable\n     */\n    function initializeSession(editor) {\n        session = new Session(editor);\n    }\n\n    exports.handleExtractToFunction = handleExtractToFunction;\n});\n"],"file":"ExtractToFunction.js"}
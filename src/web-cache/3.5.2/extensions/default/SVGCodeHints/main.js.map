{"version":3,"sources":["extensions/default/SVGCodeHints/main.js"],"names":["define","require","exports","module","AppInit","brackets","getModule","CodeHintManager","PreferencesManager","XMLUtils","StringMatch","ExtensionUtils","ColorUtils","Strings","_","SVGTags","SVGAttributes","cachedAttributes","tagData","attributeData","isSVGEnabled","stringMatcherOptions","preferPrefixMatches","_isSVGHintsEnabled","get","getTagAttributes","tagName","tag","hasOwnProperty","tags","attributes","concat","attributeGroups","forEach","group","uniq","sort","formatHints","hints","query","hasColorSwatch","some","token","color","basicMatchSort","map","$hintObj","$","addClass","stringRanges","item","matched","append","text","value","formatColorHint","SVGCodeHints","this","tagInfo","definePreference","description","DESCRIPTION_SVG_HINTS","on","prototype","hasHints","editor","implicitChar","getModeForSelection","getTagInfo","getCursorPos","tokenType","getHints","options","index","isMultiple","tagSpecificOptions","string","substr","offset","trim","TOKEN_TAG","Object","keys","match","stringMatch","TOKEN_ATTR","attribute","exclusionList","indexOf","TOKEN_VALUE","attrName","attribOptions","multiple","type","COLOR_NAMES","test","getValueQuery","option","selectInitial","handleWideResults","insertHint","completion","pos","start","line","ch","end","startChar","endChar","quoteChar","jquery","document","replaceRange","shouldReplace","setCursorPos","length","regexWhitespace","charAt","appReady","JSON","parse","hintProvider","registerHintProvider","loadStyleSheet"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2015 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Load dependencies.\n    var AppInit             = brackets.getModule(\"utils/AppInit\"),\n        CodeHintManager     = brackets.getModule(\"editor/CodeHintManager\"),\n        PreferencesManager  = brackets.getModule(\"preferences/PreferencesManager\"),\n        XMLUtils            = brackets.getModule(\"language/XMLUtils\"),\n        StringMatch         = brackets.getModule(\"utils/StringMatch\"),\n        ExtensionUtils      = brackets.getModule(\"utils/ExtensionUtils\"),\n        ColorUtils          = brackets.getModule(\"utils/ColorUtils\"),\n        Strings             = brackets.getModule(\"strings\"),\n        _                   = brackets.getModule(\"thirdparty/lodash\"),\n        SVGTags             = require(\"text!SVGTags.json\"),\n        SVGAttributes       = require(\"text!SVGAttributes.json\"),\n        cachedAttributes    = {},\n        tagData,\n        attributeData,\n        isSVGEnabled;\n\n    var stringMatcherOptions = {\n        preferPrefixMatches: true\n    };\n\n    // Define our own pref for hinting.\n    PreferencesManager.definePreference(\"codehint.SVGHints\", \"boolean\", true, {\n        description: Strings.DESCRIPTION_SVG_HINTS\n    });\n\n    // Preferences to control hint.\n    function _isSVGHintsEnabled() {\n        return (PreferencesManager.get(\"codehint.SVGHints\") !== false &&\n                PreferencesManager.get(\"showCodeHints\") !== false);\n    }\n\n    PreferencesManager.on(\"change\", \"codehint.SVGHints\", function () {\n        isSVGEnabled = _isSVGHintsEnabled();\n    });\n\n    PreferencesManager.on(\"change\", \"showCodeHints\", function () {\n        isSVGEnabled = _isSVGHintsEnabled();\n    });\n\n    // Check if SVG Hints are available.\n    isSVGEnabled = _isSVGHintsEnabled();\n\n    /**\n     * Returns a list of attributes used by a tag.\n     *\n     * @param {string} tagName name of the SVG tag.\n     * @return {Array.<string>} list of attributes.\n     */\n    function getTagAttributes(tagName) {\n        var tag;\n\n        if (!cachedAttributes.hasOwnProperty(tagName)) {\n            tag = tagData.tags[tagName];\n            cachedAttributes[tagName] = [];\n            if (tag.attributes) {\n                cachedAttributes[tagName] =  cachedAttributes[tagName].concat(tag.attributes);\n            }\n            tag.attributeGroups.forEach(function (group) {\n                if (tagData.attributeGroups.hasOwnProperty(group)) {\n                    cachedAttributes[tagName] = cachedAttributes[tagName].concat(tagData.attributeGroups[group]);\n                }\n            });\n            cachedAttributes[tagName] = _.uniq(cachedAttributes[tagName].sort(), true);\n        }\n        return cachedAttributes[tagName];\n    }\n\n    /*\n     * Returns a sorted and formatted list of hints with the query substring\n     * highlighted.\n     *\n     * @param {Array.<Object>} hints - the list of hints to format\n     * @param {string} query - querystring used for highlighting matched\n     *      portions of each hint\n     * @return {Array.jQuery} sorted Array of jQuery DOM elements to insert\n     */\n    function formatHints(hints, query) {\n        var hasColorSwatch = hints.some(function (token) {\n            return token.color;\n        });\n\n        StringMatch.basicMatchSort(hints);\n        return hints.map(function (token) {\n            var $hintObj = $(\"<span>\").addClass(\"brackets-svg-hints\");\n\n            // highlight the matched portion of each hint\n            if (token.stringRanges) {\n                token.stringRanges.forEach(function (item) {\n                    if (item.matched) {\n                        $hintObj.append($(\"<span>\")\n                            .text(item.text)\n                            .addClass(\"matched-hint\"));\n                    } else {\n                        $hintObj.append(item.text);\n                    }\n                });\n            } else {\n                $hintObj.text(token.value);\n            }\n\n            if (hasColorSwatch) {\n                $hintObj = ColorUtils.formatColorHint($hintObj, token.color);\n            }\n\n            return $hintObj;\n        });\n    }\n\n    /**\n     * @constructor\n     */\n    function SVGCodeHints() {\n        this.tagInfo = null;\n    }\n\n    /**\n     * Determines whether SVG code hints are available in the current editor.\n     *\n     * @param {!Editor} editor An instance of Editor\n     * @param {string} implicitChar A single character that was inserted by the\n     * user or null if the request was explicitly made to start hinting session.\n     *\n     * @return {boolean} Determines whether or not hints are available in the current context.\n     */\n    SVGCodeHints.prototype.hasHints = function (editor, implicitChar) {\n        if (isSVGEnabled && editor.getModeForSelection() === \"image/svg+xml\") {\n            this.editor = editor;\n            this.tagInfo = XMLUtils.getTagInfo(this.editor, this.editor.getCursorPos());\n\n            if (this.tagInfo && this.tagInfo.tokenType) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    /**\n     * Returns a list of hints that are available in the current context,\n     * or null if there are no hints available.\n     *\n     * @param {string} implicitChar A character that the user typed in the hinting session.\n     * @return {!{hints: Array.<jQueryObject>, match: string, selectInitial: boolean, handleWideResults: boolean}}\n     */\n    SVGCodeHints.prototype.getHints = function (implicitChar) {\n        var hints = [], query, tagInfo, attributes = [], options = [], index, isMultiple, tagSpecificOptions;\n\n        tagInfo  = XMLUtils.getTagInfo(this.editor, this.editor.getCursorPos());\n        this.tagInfo = tagInfo;\n\n        if (tagInfo && tagInfo.tokenType) {\n            query = tagInfo.token.string.substr(0, tagInfo.offset).trim();\n\n            if (tagInfo.tokenType === XMLUtils.TOKEN_TAG) {\n                hints = $.map(Object.keys(tagData.tags), function (tag) {\n                    var match = StringMatch.stringMatch(tag, query, stringMatcherOptions);\n                    if (match) {\n                        return match;\n                    }\n                });\n            } else if (tagInfo.tokenType === XMLUtils.TOKEN_ATTR) {\n                if (!tagData.tags[tagInfo.tagName]) {\n                    return null;\n                }\n                // Get attributes.\n                attributes = getTagAttributes(tagInfo.tagName);\n                hints = $.map(attributes, function (attribute) {\n                    if (tagInfo.exclusionList.indexOf(attribute) === -1) {\n                        var match = StringMatch.stringMatch(attribute, query, stringMatcherOptions);\n                        if (match) {\n                            return match;\n                        }\n                    }\n                });\n            } else if (tagInfo.tokenType === XMLUtils.TOKEN_VALUE) {\n                index = tagInfo.tagName + \"/\" + tagInfo.attrName;\n                tagSpecificOptions = attributeData[index];\n\n                if (!tagData.tags[tagInfo.tagName] && !(attributeData[tagInfo.attrName] || tagSpecificOptions)) {\n                    return null;\n                }\n\n                // Get attribute options.\n                // Prefer tag/attribute for specific tags, else use general options for attributes.\n                if (tagSpecificOptions) {\n                    options = tagSpecificOptions.attribOptions;\n                    isMultiple = tagSpecificOptions.multiple;\n                } else if (attributeData[tagInfo.attrName]) {\n                    options = attributeData[tagInfo.attrName].attribOptions;\n                    isMultiple = attributeData[tagInfo.attrName].multiple;\n\n                    if (attributeData[tagInfo.attrName].type === \"color\") {\n                        options = ColorUtils.COLOR_NAMES.map(function (color) {\n                            return { text: color, color: color };\n                        });\n                        options = options.concat([\"currentColor\", \"transparent\"]);\n                    }\n                }\n\n                // Stop if the attribute doesn't support multiple options.\n                if (!isMultiple && /\\s+/.test(tagInfo.token.string)) {\n                    return null;\n                }\n\n                query = XMLUtils.getValueQuery(tagInfo);\n                hints = $.map(options, function (option) {\n                    if (tagInfo.exclusionList.indexOf(option) === -1) {\n                        var match = StringMatch.stringMatch(option.text || option, query, stringMatcherOptions);\n                        if (match) {\n                            if (option.color) {\n                                match.color = option.color;\n                            }\n\n                            return match;\n                        }\n                    }\n                });\n            }\n            return {\n                hints: formatHints(hints, query),\n                match: null,\n                selectInitial: true,\n                handleWideResults: false\n            };\n        }\n        return null;\n    };\n\n    /**\n     * Insert the selected hint into the editor\n     *\n     * @param {string} completion The string that user selected from the list\n     * @return {boolean} Determines whether or not to continue the hinting session\n     */\n    SVGCodeHints.prototype.insertHint = function (completion) {\n        var tagInfo = this.tagInfo,\n            pos     = this.editor.getCursorPos(),\n            start   = {line: -1, ch: -1},\n            end     = {line: -1, ch: -1},\n            query,\n            startChar,\n            endChar,\n            quoteChar;\n\n        if (completion.jquery) {\n            completion = completion.text();\n        }\n        start.line = end.line = pos.line;\n\n        if (tagInfo.tokenType === XMLUtils.TOKEN_TAG) {\n            start.ch = pos.ch - tagInfo.offset;\n            end.ch = tagInfo.token.end;\n            this.editor.document.replaceRange(completion, start, end);\n            return false;\n        } else if (tagInfo.tokenType === XMLUtils.TOKEN_ATTR) {\n            if (!tagInfo.shouldReplace) {\n                completion += \"=\\\"\\\"\";\n\n                // In case the current token is whitespace, start and end will be same.\n                if (XMLUtils.regexWhitespace.test(tagInfo.token.string)) {\n                    start.ch = end.ch = pos.ch;\n                } else {\n                    start.ch = pos.ch - tagInfo.offset;\n                    end.ch = pos.ch;\n                }\n                this.editor.document.replaceRange(completion, start, end);\n                this.editor.setCursorPos(start.line, start.ch + completion.length - 1);\n                return true;\n            }\n                // We don't append =\"\" again, just replace the attribute token.\n            start.ch = tagInfo.token.start;\n            end.ch = tagInfo.token.end;\n            this.editor.document.replaceRange(completion, start, end);\n            this.editor.setCursorPos(start.line, start.ch + completion.length);\n            return false;\n\n        } else if (tagInfo.tokenType === XMLUtils.TOKEN_VALUE) {\n            startChar = tagInfo.token.string.charAt(0);\n            endChar = tagInfo.token.string.substr(-1, 1);\n\n            // Get the quote character.\n            if (/^['\"]$/.test(startChar)) {\n                quoteChar = startChar;\n            } else {\n                quoteChar = \"\\\"\";\n            }\n\n            // Append quotes to attribute value if not already.\n            if (!/^['\"]$/.test(startChar)) {\n                completion = quoteChar + completion;\n            }\n            if (!/^['\"]$/.test(endChar) || tagInfo.token.string.length === 1) {\n                completion = completion + quoteChar;\n            }\n\n            query = XMLUtils.getValueQuery(tagInfo);\n            start.ch = pos.ch - query.length;\n            end.ch = pos.ch;\n            this.editor.document.replaceRange(completion, start, end);\n\n            // Place cursor outside the quote if the next char is quote.\n            if (/^['\"]$/.test(tagInfo.token.string.substr(tagInfo.offset, 1))) {\n                this.editor.setCursorPos(pos.line, start.ch + completion.length + 1);\n            }\n            return false;\n        }\n    };\n\n    AppInit.appReady(function () {\n        tagData = JSON.parse(SVGTags);\n        attributeData = JSON.parse(SVGAttributes);\n\n        var hintProvider = new SVGCodeHints();\n        CodeHintManager.registerHintProvider(hintProvider, [\"svg\"], 0);\n\n        ExtensionUtils.loadStyleSheet(module, \"styles/brackets-svg-hints.css\");\n        exports.hintProvider = hintProvider;\n    });\n});\n"],"file":"main.js"}
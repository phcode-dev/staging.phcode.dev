{"version":3,"sources":["thirdparty/CodeMirror/mode/wast/wast.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","kKeywords","defineSimpleMode","start","regex","token","RegExp","join","next","indent","dedent","comment","meta","dontIndentStates","defineMIME"],"mappings":"CAGA,SAAUA,KACc,iBAAXC,SAAwC,iBAAVC,OACvCF,IAAIG,QAAQ,wBAAyBA,QAAQ,4BACrB,mBAAVC,QAAwBA,OAAOC,IAC7CD,OAAO,CAAC,uBAAwB,2BAA4BJ,KAE5DA,IAAIM,YANR,CAOG,SAASA,YACZ,aAEA,IAAIC,UAAY,CACZ,QACA,QACA,gDACA,wBACA,iBACA,aACA,eACA,WACA,OACA,OACA,OACA,MACA,SACA,eACA,aACA,wBACA,KACA,SACA,2BACA,OACA,SACA,MACA,MACA,SACA,QACA,SACA,UACA,kCACA,SACA,QACA,qDACA,OACA,QACA,MACA,OACA,cACA,SAGA,6CACA,8BACA,mCACA,mGACA,2GACA,wBACA,iBACA,iCACA,mCACA,oBACA,mBACA,wBACA,wBACA,wBACA,wBAEA,0DACA,yEACA,kIAEA,kCACA,gCACA,uCACA,0BACA,mEACA,+DACA,4FACA,6DACA,sDACA,gGACA,iCACA,qDACA,2EACA,gDACA,sDACA,0FACA,sDACA,iDACA,qDAEA,YACA,cACA,gEACA,WACA,QACA,uBACA,aACA,0EACA,wBAGJD,WAAWE,iBAAiB,OAAQ,CAClCC,MAAO,CACL,CAACC,MAAO,iJAAkJC,MAAO,UACjK,CAACD,MAAO,IAAIE,OAAOL,UAAUM,KAAK,MAAOF,MAAO,WAChD,CAACD,MAAO,6DAA8DC,MAAO,QAC7E,CAACD,MAAO,iDAAkDC,MAAO,cACjE,CAACD,MAAO,iEAAkEC,MAAO,UACjF,CAACD,MAAO,SAAUC,MAAO,UAAWG,KAAM,WAC1C,CAACJ,MAAO,QAASC,MAAO,WACxB,CAACD,MAAO,KAAMK,QAAQ,GACtB,CAACL,MAAO,KAAMM,QAAQ,IAGxBC,QAAS,CACP,CAACP,MAAO,SAAUC,MAAO,UAAWG,KAAM,SAC1C,CAACJ,MAAO,KAAMC,MAAO,YAGvBO,KAAM,CACJC,iBAAkB,CAAC,cAMvBb,WAAWc,WAAW,mBAAoB","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../../addon/mode/simple\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../../addon/mode/simple\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar kKeywords = [\n    \"align\",\n    \"block\",\n    \"br(_if|_table|_on_(cast|data|func|i31|null))?\",\n    \"call(_indirect|_ref)?\",\n    \"current_memory\",\n    \"\\\\bdata\\\\b\",\n    \"catch(_all)?\",\n    \"delegate\",\n    \"drop\",\n    \"elem\",\n    \"else\",\n    \"end\",\n    \"export\",\n    \"\\\\bextern\\\\b\",\n    \"\\\\bfunc\\\\b\",\n    \"global(\\\\.(get|set))?\",\n    \"if\",\n    \"import\",\n    \"local(\\\\.(get|set|tee))?\",\n    \"loop\",\n    \"module\",\n    \"mut\",\n    \"nop\",\n    \"offset\",\n    \"param\",\n    \"result\",\n    \"rethrow\",\n    \"return(_call(_indirect|_ref)?)?\",\n    \"select\",\n    \"start\",\n    \"table(\\\\.(size|get|set|size|grow|fill|init|copy))?\",\n    \"then\",\n    \"throw\",\n    \"try\",\n    \"type\",\n    \"unreachable\",\n    \"unwind\",\n\n    // Numeric opcodes.\n    \"i(32|64)\\\\.(store(8|16)|(load(8|16)_[su]))\",\n    \"i64\\\\.(load32_[su]|store32)\",\n    \"[fi](32|64)\\\\.(const|load|store)\",\n    \"f(32|64)\\\\.(abs|add|ceil|copysign|div|eq|floor|[gl][et]|max|min|mul|nearest|neg?|sqrt|sub|trunc)\",\n    \"i(32|64)\\\\.(a[dn]d|c[lt]z|(div|rem)_[su]|eqz?|[gl][te]_[su]|mul|ne|popcnt|rot[lr]|sh(l|r_[su])|sub|x?or)\",\n    \"i64\\\\.extend_[su]_i32\",\n    \"i32\\\\.wrap_i64\",\n    \"i(32|64)\\\\.trunc_f(32|64)_[su]\",\n    \"f(32|64)\\\\.convert_i(32|64)_[su]\",\n    \"f64\\\\.promote_f32\",\n    \"f32\\\\.demote_f64\",\n    \"f32\\\\.reinterpret_i32\",\n    \"i32\\\\.reinterpret_f32\",\n    \"f64\\\\.reinterpret_i64\",\n    \"i64\\\\.reinterpret_f64\",\n    // Atomics.\n    \"memory(\\\\.((atomic\\\\.(notify|wait(32|64)))|grow|size))?\",\n    \"i64\\.atomic\\\\.(load32_u|store32|rmw32\\\\.(a[dn]d|sub|x?or|(cmp)?xchg)_u)\",\n    \"i(32|64)\\\\.atomic\\\\.(load((8|16)_u)?|store(8|16)?|rmw(\\\\.(a[dn]d|sub|x?or|(cmp)?xchg)|(8|16)\\\\.(a[dn]d|sub|x?or|(cmp)?xchg)_u))\",\n    // SIMD.\n    \"v128\\\\.load(8x8|16x4|32x2)_[su]\",\n    \"v128\\\\.load(8|16|32|64)_splat\",\n    \"v128\\\\.(load|store)(8|16|32|64)_lane\",\n    \"v128\\\\.load(32|64)_zero\",\n    \"v128\\.(load|store|const|not|andnot|and|or|xor|bitselect|any_true)\",\n    \"i(8x16|16x8)\\\\.(extract_lane_[su]|(add|sub)_sat_[su]|avgr_u)\",\n    \"i(8x16|16x8|32x4|64x2)\\\\.(neg|add|sub|abs|shl|shr_[su]|all_true|bitmask|eq|ne|[lg][te]_s)\",\n    \"(i(8x16|16x8|32x4|64x2)|f(32x4|64x2))\\.(splat|replace_lane)\",\n    \"i(8x16|16x8|32x4)\\\\.(([lg][te]_u)|((min|max)_[su]))\",\n    \"f(32x4|64x2)\\\\.(neg|add|sub|abs|nearest|eq|ne|[lg][te]|sqrt|mul|div|min|max|ceil|floor|trunc)\",\n    \"[fi](32x4|64x2)\\\\.extract_lane\",\n    \"i8x16\\\\.(shuffle|swizzle|popcnt|narrow_i16x8_[su])\",\n    \"i16x8\\\\.(narrow_i32x4_[su]|mul|extadd_pairwise_i8x16_[su]|q15mulr_sat_s)\",\n    \"i16x8\\\\.(extend|extmul)_(low|high)_i8x16_[su]\",\n    \"i32x4\\\\.(mul|dot_i16x8_s|trunc_sat_f64x2_[su]_zero)\",\n    \"i32x4\\\\.((extend|extmul)_(low|high)_i16x8_|trunc_sat_f32x4_|extadd_pairwise_i16x8_)[su]\",\n    \"i64x2\\\\.(mul|(extend|extmul)_(low|high)_i32x4_[su])\",\n    \"f32x4\\\\.(convert_i32x4_[su]|demote_f64x2_zero)\",\n    \"f64x2\\\\.(promote_low_f32x4|convert_low_i32x4_[su])\",\n    // Reference types, function references, and GC.\n    \"\\\\bany\\\\b\",\n    \"array\\\\.len\",\n    \"(array|struct)(\\\\.(new_(default_)?with_rtt|get(_[su])?|set))?\",\n    \"\\\\beq\\\\b\",\n    \"field\",\n    \"i31\\\\.(new|get_[su])\",\n    \"\\\\bnull\\\\b\",\n    \"ref(\\\\.(([ai]s_(data|func|i31))|cast|eq|func|(is_|as_non_)?null|test))?\",\n    \"rtt(\\\\.(canon|sub))?\",\n];\n\nCodeMirror.defineSimpleMode('wast', {\n  start: [\n    {regex: /[+\\-]?(?:nan(?::0x[0-9a-fA-F]+)?|infinity|inf|0x[0-9a-fA-F]+\\.?[0-9a-fA-F]*p[+\\/-]?\\d+|\\d+(?:\\.\\d*)?[eE][+\\-]?\\d*|\\d+\\.\\d*|0x[0-9a-fA-F]+|\\d+)/, token: \"number\"},\n    {regex: new RegExp(kKeywords.join('|')), token: \"keyword\"},\n    {regex: /\\b((any|data|eq|extern|i31|func)ref|[fi](32|64)|i(8|16))\\b/, token: \"atom\"},\n    {regex: /\\$([a-zA-Z0-9_`\\+\\-\\*\\/\\\\\\^~=<>!\\?@#$%&|:\\.]+)/, token: \"variable-2\"},\n    {regex: /\"(?:[^\"\\\\\\x00-\\x1f\\x7f]|\\\\[nt\\\\'\"]|\\\\[0-9a-fA-F][0-9a-fA-F])*\"/, token: \"string\"},\n    {regex: /\\(;.*?/, token: \"comment\", next: \"comment\"},\n    {regex: /;;.*$/, token: \"comment\"},\n    {regex: /\\(/, indent: true},\n    {regex: /\\)/, dedent: true},\n  ],\n\n  comment: [\n    {regex: /.*?;\\)/, token: \"comment\", next: \"start\"},\n    {regex: /.*/, token: \"comment\"},\n  ],\n\n  meta: {\n    dontIndentStates: ['comment'],\n  },\n});\n\n// https://github.com/WebAssembly/design/issues/981 mentions text/webassembly,\n// which seems like a reasonable choice, although it's not standard right now.\nCodeMirror.defineMIME(\"text/webassembly\", \"wast\");\n\n});\n"],"file":"wast.js"}
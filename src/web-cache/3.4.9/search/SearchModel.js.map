{"version":3,"sources":["search/SearchModel.js"],"names":["define","require","exports","module","FileUtils","EventDispatcher","FindUtils","MainViewManager","SearchModel","this","clear","makeEventDispatcher","prototype","MAX_TOTAL_RESULTS","results","queryInfo","queryExpr","isReplace","replaceText","scope","filter","numMatches","foundMaximum","exceedsMaximum","numMatchesBefore","fireChanged","setQueryInfo","parsedQuery","parseQueryInfo","valid","setResults","fullpath","resultInfo","removeResults","matches","length","collapsed","numFiles","pop","hasResults","Object","keys","countFilesMatches","files","prioritizeOpenFile","firstFile","workingSetFiles","getWorkingSet","ALL_PANES","workingSetFileFound","fileSetWithoutWorkingSet","startingWorkingFileSet","propertyName","i","fullPath","key","undefined","push","hasOwnProperty","concat","quickChange","trigger"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var FileUtils       = require(\"file/FileUtils\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        FindUtils       = require(\"search/FindUtils\"),\n        MainViewManager = require(\"view/MainViewManager\");\n\n    /**\n     * @constructor\n     * Manages a set of search query and result data.\n     * Dispatches these events:\n     *      \"change\" - whenever the results have been updated. Note that it's up to people who\n     *      edit the model to call fireChange() when necessary - it doesn't automatically fire.\n     */\n    function SearchModel() {\n        this.clear();\n    }\n    EventDispatcher.makeEventDispatcher(SearchModel.prototype);\n\n    /** @const Constant used to define the maximum results found.\n     *  Note that this is a soft limit - we'll likely go slightly over it since\n     *  we always add all the searches in a given file.\n     */\n    SearchModel.MAX_TOTAL_RESULTS = 100000;\n\n    /**\n     * The current set of results.\n     * @type {Object.<fullPath: string, {matches: Array.<Object>, collapsed: boolean, timestamp: Date}>}\n     */\n    SearchModel.prototype.results = null;\n\n    /**\n     * The query that generated these results.\n     * @type {{query: string, caseSensitive: boolean, isRegexp: boolean}}\n     */\n    SearchModel.prototype.queryInfo = null;\n\n    /**\n     * The compiled query, expressed as a regexp.\n     * @type {RegExp}\n     */\n    SearchModel.prototype.queryExpr = null;\n\n    /**\n     * Whether this is a find/replace query.\n     * @type {boolean}\n     */\n    SearchModel.prototype.isReplace = false;\n\n    /**\n     * The replacement text specified for this query, if any.\n     * @type {string}\n     */\n    SearchModel.prototype.replaceText = null;\n\n    /**\n     * The file/folder path representing the scope that this query was performed in.\n     * @type {FileSystemEntry}\n     */\n    SearchModel.prototype.scope = null;\n\n    /**\n     * A file filter (as returned from FileFilters) to apply within the main scope.\n     * @type {string}\n     */\n    SearchModel.prototype.filter = null;\n\n    /**\n     * The total number of matches in the model.\n     * @type {number}\n     */\n    SearchModel.prototype.numMatches = 0;\n\n    /**\n     * Whether or not we hit the maximum number of results for the type of search we did.\n     * @type {boolean}\n     */\n    SearchModel.prototype.foundMaximum = false;\n\n    /**\n     * Whether or not we exceeded the maximum number of results in the search we did.\n     * @type {boolean}\n     */\n    SearchModel.prototype.exceedsMaximum = false;\n\n    /**\n     * Clears out the model to an empty state.\n     */\n    SearchModel.prototype.clear = function () {\n        var numMatchesBefore = this.numMatches;\n        this.results = {};\n        this.queryInfo = null;\n        this.queryExpr = null;\n        this.isReplace = false;\n        this.replaceText = null;\n        this.scope = null;\n        this.numMatches = 0;\n        this.foundMaximum = false;\n        this.exceedsMaximum = false;\n        if (numMatchesBefore !== 0) {\n            this.fireChanged();\n        }\n    };\n\n    /**\n     * Sets the given query info and stores a compiled RegExp query in this.queryExpr.\n     * @param {{query: string, caseSensitive: boolean, isRegexp: boolean}} queryInfo\n     * @return {boolean} true if the query was valid and properly set, false if it was\n     *      invalid or empty.\n     */\n    SearchModel.prototype.setQueryInfo = function (queryInfo) {\n        var parsedQuery = FindUtils.parseQueryInfo(queryInfo);\n        if (parsedQuery.valid) {\n            this.queryInfo = queryInfo;\n            this.queryExpr = parsedQuery.queryExpr;\n            return true;\n        }\n        return false;\n\n    };\n\n    /**\n     * Sets the list of matches for the given path, removing the previous match info, if any, and updating\n     * the total match count. Note that for the count to remain accurate, the previous match info must not have\n     * been mutated since it was set.\n     * @param {string} fullpath Full path to the file containing the matches.\n     * @param {!{matches: Object, timestamp: Date, collapsed: boolean=}} resultInfo Info for the matches to set:\n     *      matches - Array of matches, in the format returned by FindInFiles._getSearchMatches()\n     *      timestamp - The timestamp of the document at the time we searched it.\n     *      collapsed - Optional: whether the results should be collapsed in the UI (default false).\n     */\n    SearchModel.prototype.setResults = function (fullpath, resultInfo) {\n        this.removeResults(fullpath);\n\n        if (this.foundMaximum || !resultInfo.matches.length) {\n            return;\n        }\n\n        // Make sure that the optional `collapsed` property is explicitly set to either true or false,\n        // to avoid logic issues later with comparing values.\n        resultInfo.collapsed = !!resultInfo.collapsed;\n\n        if(!this.results[fullpath] && this.numFiles >= 0){\n            this.numFiles++;\n        }\n        this.results[fullpath] = resultInfo;\n        this.numMatches += resultInfo.matches.length;\n        if (this.numMatches >= SearchModel.MAX_TOTAL_RESULTS) {\n            this.foundMaximum = true;\n\n            // Remove final result if there have been over MAX_TOTAL_RESULTS found\n            if (this.numMatches > SearchModel.MAX_TOTAL_RESULTS) {\n                this.results[fullpath].matches.pop();\n                this.numMatches--;\n                this.exceedsMaximum = true;\n            }\n        }\n    };\n\n    /**\n     * Removes the given result's matches from the search results and updates the total match count.\n     * @param {string} fullpath Full path to the file containing the matches.\n     */\n    SearchModel.prototype.removeResults = function (fullpath) {\n        if (this.results[fullpath]) {\n            this.numMatches -= this.results[fullpath].matches.length;\n            if(this.numFiles){\n                this.numFiles--;\n            }\n            delete this.results[fullpath];\n        }\n    };\n\n    /**\n     * @return {boolean} true if there are any results in this model.\n     */\n    SearchModel.prototype.hasResults = function () {\n        return Object.keys(this.results).length > 0;\n    };\n\n    /**\n     * Counts the total number of matches and files\n     * @return {{files: number, matches: number}}\n     */\n    SearchModel.prototype.countFilesMatches = function () {\n        return {files: (this.numFiles || Object.keys(this.results).length), matches: this.numMatches};\n    };\n\n    /**\n     * Prioritizes the open file and then the working set files to the starting of the list of files\n     * If node search is disabled, we sort the files too- Sorting is computation intensive, and our\n     * ProjectManager.getAllFiles with the sort flag is not working properly : TODO TOFIX\n     * @param {?string} firstFile If specified, the path to the file that should be sorted to the top.\n     * @return {Array.<string>}\n     */\n    SearchModel.prototype.prioritizeOpenFile = function (firstFile) {\n        var workingSetFiles = MainViewManager.getWorkingSet(MainViewManager.ALL_PANES),\n            workingSetFileFound = {},\n            fileSetWithoutWorkingSet = [],\n            startingWorkingFileSet = [],\n            propertyName = \"\",\n            i = 0;\n\n        firstFile = firstFile || \"\";\n\n        // Create a working set path map which indicates if a file in working set is found in file list\n        for (i = 0; i < workingSetFiles.length; i++) {\n            workingSetFileFound[workingSetFiles[i].fullPath] = false;\n        }\n\n        // Remove all the working set files from the filtration list\n        fileSetWithoutWorkingSet = Object.keys(this.results).filter(function (key) {\n            if (workingSetFileFound[key] !== undefined) {\n                workingSetFileFound[key] = true;\n                return false;\n            }\n            return true;\n        });\n\n        //push in the first file\n        if (workingSetFileFound[firstFile] === true) {\n            startingWorkingFileSet.push(firstFile);\n            workingSetFileFound[firstFile] = false;\n        }\n        //push in the rest of working set files already present in file list\n        for (propertyName in workingSetFileFound) {\n            if (workingSetFileFound.hasOwnProperty(propertyName) && workingSetFileFound[propertyName]) {\n                startingWorkingFileSet.push(propertyName);\n            }\n        }\n        return startingWorkingFileSet.concat(fileSetWithoutWorkingSet);\n    };\n\n    /**\n     * Notifies listeners that the set of results has changed. Must be called after the\n     * model is changed.\n     * @param {boolean} quickChange Whether this type of change is one that might occur\n     *      often, meaning that the view should buffer updates.\n     */\n    SearchModel.prototype.fireChanged = function (quickChange) {\n        this.trigger(\"change\", quickChange);\n    };\n\n    // Public API\n    exports.SearchModel = SearchModel;\n});\n"],"file":"SearchModel.js"}
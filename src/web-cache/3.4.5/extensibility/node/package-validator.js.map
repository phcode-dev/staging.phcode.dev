{"version":3,"sources":["extensibility/node/package-validator.js"],"names":["DecompressZip","require","semver","path","temp","fs","performNpmInstallIfRequired","track","Errors","NOT_FOUND_ERR","INVALID_ZIP_FILE","INVALID_PACKAGE_JSON","MISSING_PACKAGE_NAME","BAD_PACKAGE_NAME","MISSING_PACKAGE_VERSION","INVALID_VERSION_NUMBER","MISSING_MAIN","MISSING_PACKAGE_JSON","INVALID_BRACKETS_VERSION","DISALLOWED_WORDS","ignoredFolders","validateName","name","exec","_personRegex","parsePersonString","obj","parts","result","email","url","containsWords","wordlist","str","i","matches","length","re","RegExp","push","findCommonPrefix","extractDir","callback","readdir","err","files","forEach","folder","index","indexOf","splice","statSync","join","isDirectory","validatePackageJSON","packageJSON","options","errors","existsSync","readFile","encoding","data","metadata","JSON","parse","e","toString","undefined","version","valid","author","contributors","map","person","engines","brackets","range","validRange","disallowedWords","field","words","requirePackageJSON","extractAndValidateFiles","zipPath","unzipper","on","log","commonPrefix","mainJS","isTheme","theme","npmOptions","proxy","process","platform","startsWith","extract","filter","file","type","validate","exists","doesExist","mkdir","_tempDirCreated","exports","_parsePersonString"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*eslint-env node */\n/*jslint node: true, regexp: true */\n\n\n\nvar DecompressZip               = require(\"decompress-zip\"),\n    semver                      = require(\"semver\"),\n    path                        = require(\"path\"),\n    temp                        = require(\"temp\"),\n    fs                          = require(\"fs-extra\"),\n    performNpmInstallIfRequired = require(\"./npm-installer\").performNpmInstallIfRequired;\n\n// Track and cleanup files at exit\ntemp.track();\n\nvar Errors = {\n    NOT_FOUND_ERR: \"NOT_FOUND_ERR\",                       // {0} is path where ZIP file was expected\n    INVALID_ZIP_FILE: \"INVALID_ZIP_FILE\",                 // {0} is path to ZIP file\n    INVALID_PACKAGE_JSON: \"INVALID_PACKAGE_JSON\",         // {0} is JSON parse error, {1} is path to ZIP file\n    MISSING_PACKAGE_NAME: \"MISSING_PACKAGE_NAME\",         // {0} is path to ZIP file\n    BAD_PACKAGE_NAME: \"BAD_PACKAGE_NAME\",                 // {0} is the name\n    MISSING_PACKAGE_VERSION: \"MISSING_PACKAGE_VERSION\",   // {0} is path to ZIP file\n    INVALID_VERSION_NUMBER: \"INVALID_VERSION_NUMBER\",     // {0} is version string in JSON, {1} is path to ZIP file\n    MISSING_MAIN: \"MISSING_MAIN\",                         // {0} is path to ZIP file\n    MISSING_PACKAGE_JSON: \"MISSING_PACKAGE_JSON\",         // {0} is path to ZIP file\n    INVALID_BRACKETS_VERSION: \"INVALID_BRACKETS_VERSION\", // {0} is the version string in JSON, {1} is the path to the zip file,\n    DISALLOWED_WORDS: \"DISALLOWED_WORDS\"                  // {0} is the field with the word, {1} is a string list of words that were in violation, {2} is the path to the zip file\n};\n\n/*\n * Directories to ignore when determining whether the contents of an extension are\n * in a subfolder.\n */\nvar ignoredFolders = [ \"__MACOSX\" ];\n\n/**\n * Returns true if the name presented is acceptable as a package name. This enforces the\n * requirement as presented in the CommonJS spec: http://wiki.commonjs.org/wiki/Packages/1.0\n * which states:\n *\n * \"This must be a unique, lowercase alpha-numeric name without spaces. It may include \".\" or \"_\" or \"-\" characters.\"\n *\n * We add the additional requirement that the first character must be a letter or number\n * (there's a security implication to allowing a name like \"..\", because the name is\n * used in directory names).\n *\n * @param {string} name to test\n * @return {boolean} true if the name is valid\n */\nfunction validateName(name) {\n    if (/^[a-z0-9][a-z0-9._\\-]*$/.exec(name)) {\n        return true;\n    }\n    return false;\n}\n\n// Parses strings of the form \"name <email> (url)\" where email and url are optional\nvar _personRegex = /^([^<\\(]+)(?:\\s+<([^>]+)>)?(?:\\s+\\(([^\\)]+)\\))?$/;\n\n/**\n * Normalizes person fields from package.json.\n *\n * These fields can be an object with name, email and url properties or a\n * string of the form \"name <email> <url>\". This does a tolerant parsing of\n * the data to try to return an object with name and optional email and url.\n * If the string does not match the format, the string is returned as the\n * name on the resulting object.\n *\n * If an object other than a string is passed in, it's returned as is.\n *\n * @param <String|Object> obj to normalize\n * @return {Object} person object with name and optional email and url\n */\nfunction parsePersonString(obj) {\n    if (typeof (obj) === \"string\") {\n        var parts = _personRegex.exec(obj);\n\n        // No regex match, so we just synthesize an object with an opaque name string\n        if (!parts) {\n            return {\n                name: obj\n            };\n        }\n        var result = {\n            name: parts[1]\n        };\n        if (parts[2]) {\n            result.email = parts[2];\n        }\n        if (parts[3]) {\n            result.url = parts[3];\n        }\n        return result;\n\n    }\n        // obj is not a string, so return as is\n    return obj;\n\n}\n\n/**\n * Determines if any of the words in wordlist appear in str.\n *\n * @param {String[]} wordlist list of words to check\n * @param {String} str to check for words\n * @return {String[]} words that matched\n */\nfunction containsWords(wordlist, str) {\n    var i;\n    var matches = [];\n    for (i = 0; i < wordlist.length; i++) {\n        var re = new RegExp(\"\\\\b\" + wordlist[i] + \"\\\\b\", \"i\");\n        if (re.exec(str)) {\n            matches.push(wordlist[i]);\n        }\n    }\n    return matches;\n}\n\n/**\n * Finds the common prefix, if any, for the files in a package file.\n *\n * In some package files, all of the files are contained in a subdirectory, and this function\n * will identify that directory if it exists.\n *\n * @param {string} extractDir directory into which the package was extracted\n * @param {function(Error, string)} callback function to accept err, commonPrefix (which will be \"\" if there is none)\n */\nfunction findCommonPrefix(extractDir, callback) {\n    fs.readdir(extractDir, function (err, files) {\n        ignoredFolders.forEach(function (folder) {\n            var index = files.indexOf(folder);\n            if (index !== -1) {\n                files.splice(index, 1);\n            }\n        });\n        if (err) {\n            callback(err);\n        } else if (files.length === 1) {\n            var name = files[0];\n            if (fs.statSync(path.join(extractDir, name)).isDirectory()) {\n                callback(null, name);\n            } else {\n                callback(null, \"\");\n            }\n        } else {\n            callback(null, \"\");\n        }\n    });\n}\n\n/**\n * Validates the contents of package.json.\n *\n * @param {string} path path to package file (used in error reporting)\n * @param {string} packageJSON path to the package.json file to check\n * @param {Object} options validation options passed to `validate()`\n * @param {function(Error, Array.<Array.<string, ...>>, Object)} callback function to call with array of errors and metadata\n */\nfunction validatePackageJSON(path, packageJSON, options, callback) {\n    var errors = [];\n    if (fs.existsSync(packageJSON)) {\n        fs.readFile(packageJSON, {\n            encoding: \"utf8\"\n        }, function (err, data) {\n            if (err) {\n                callback(err, null, null);\n                return;\n            }\n\n            var metadata;\n\n            try {\n                metadata = JSON.parse(data);\n            } catch (e) {\n                errors.push([Errors.INVALID_PACKAGE_JSON, e.toString(), path]);\n                callback(null, errors, undefined);\n                return;\n            }\n\n            // confirm required fields in the metadata\n            if (!metadata.name) {\n                errors.push([Errors.MISSING_PACKAGE_NAME, path]);\n            } else if (!validateName(metadata.name)) {\n                errors.push([Errors.BAD_PACKAGE_NAME, metadata.name]);\n            }\n            if (!metadata.version) {\n                errors.push([Errors.MISSING_PACKAGE_VERSION, path]);\n            } else if (!semver.valid(metadata.version)) {\n                errors.push([Errors.INVALID_VERSION_NUMBER, metadata.version, path]);\n            }\n\n            // normalize the author\n            if (metadata.author) {\n                metadata.author = parsePersonString(metadata.author);\n            }\n\n            // contributors should be an array of people.\n            // normalize each entry.\n            if (metadata.contributors) {\n                if (metadata.contributors.map) {\n                    metadata.contributors = metadata.contributors.map(function (person) {\n                        return parsePersonString(person);\n                    });\n                } else {\n                    metadata.contributors = [\n                        parsePersonString(metadata.contributors)\n                    ];\n                }\n            }\n\n            if (metadata.engines && metadata.engines.brackets) {\n                var range = metadata.engines.brackets;\n                if (!semver.validRange(range)) {\n                    errors.push([Errors.INVALID_BRACKETS_VERSION, range, path]);\n                }\n            }\n\n            if (options.disallowedWords) {\n                [\"title\", \"description\", \"name\"].forEach(function (field) {\n                    var words = containsWords(options.disallowedWords, metadata[field]);\n                    if (words.length > 0) {\n                        errors.push([Errors.DISALLOWED_WORDS, field, words.toString(), path]);\n                    }\n                });\n            }\n            callback(null, errors, metadata);\n        });\n    } else {\n        if (options.requirePackageJSON) {\n            errors.push([Errors.MISSING_PACKAGE_JSON, path]);\n        }\n        callback(null, errors, null);\n    }\n}\n\n/**\n * Extracts the package into the given directory and then validates it.\n *\n * @param {string} zipPath path to package zip file\n * @param {string} extractDir directory to extract package into\n * @param {Object} options validation options\n * @param {function(Error, {errors: Array, metadata: Object, commonPrefix: string, extractDir: string})} callback function to call with the result\n */\nfunction extractAndValidateFiles(zipPath, extractDir, options, callback) {\n    var unzipper = new DecompressZip(zipPath);\n    unzipper.on(\"error\", function (err) {\n        // General error to report for problems reading the file\n        callback(null, {\n            errors: [[Errors.INVALID_ZIP_FILE, zipPath, err]]\n        });\n        return;\n    });\n\n    unzipper.on(\"extract\", function (log) {\n        findCommonPrefix(extractDir, function (err, commonPrefix) {\n            if (err) {\n                callback(err, null);\n                return;\n            }\n            var packageJSON = path.join(extractDir, commonPrefix, \"package.json\");\n            validatePackageJSON(zipPath, packageJSON, options, function (err, errors, metadata) {\n                if (err) {\n                    callback(err, null);\n                    return;\n                }\n                var mainJS  = path.join(extractDir, commonPrefix, \"main.js\"),\n                    isTheme = metadata && metadata.theme;\n\n                // Throw missing main.js file only for non-theme extensions\n                if (!isTheme && !fs.existsSync(mainJS)) {\n                    errors.push([Errors.MISSING_MAIN, zipPath, mainJS]);\n                }\n\n                var npmOptions = ['--production'];\n\n                if (options.proxy) {\n                    npmOptions.push('--proxy ' + options.proxy);\n                }\n\n                if (process.platform.startsWith('win')) {\n                    // On Windows force a 32 bit build until nodejs 64 bit is supported.\n                    npmOptions.push('--arch=ia32');\n                    npmOptions.push('--npm_config_arch=ia32');\n                    npmOptions.push('--npm_config_target_arch=ia32');\n                }\n\n                performNpmInstallIfRequired(npmOptions, {\n                    errors: errors,\n                    metadata: metadata,\n                    commonPrefix: commonPrefix,\n                    extractDir: extractDir\n                }, callback);\n            });\n        });\n    });\n\n    unzipper.extract({\n        path: extractDir,\n        filter: function (file) {\n            return file.type !== \"SymbolicLink\";\n        }\n    });\n}\n\n/**\n * Implements the \"validate\" command in the \"extensions\" domain.\n * Validates the zipped package at path.\n *\n * The \"err\" parameter of the callback is only set if there was an\n * unexpected error. Otherwise, errors are reported in the result.\n *\n * The result object has an \"errors\" property. It is an array of\n * arrays of strings. Each array in the array is a set of parameters\n * that can be passed to StringUtils.format for internationalization.\n * The array will be empty if there are no errors.\n *\n * The result will have a \"metadata\" property if the metadata was\n * read successfully from package.json in the zip file.\n *\n * @param {string} path Absolute path to the package zip file\n * @param {{requirePackageJSON: ?boolean, disallowedWords: ?Array.<string>, proxy: ?<string>}} options for validation\n * @param {function} callback (err, result)\n */\nfunction validate(path, options, callback) {\n    options = options || {};\n    fs.exists(path, function (doesExist) {\n        if (!doesExist) {\n            callback(null, {\n                errors: [[Errors.NOT_FOUND_ERR, path]]\n            });\n            return;\n        }\n        temp.mkdir(\"bracketsPackage_\", function _tempDirCreated(err, extractDir) {\n            if (err) {\n                callback(err, null);\n                return;\n            }\n            extractAndValidateFiles(path, extractDir, options, callback);\n        });\n    });\n}\n\n// exported for unit testing\nexports._parsePersonString = parsePersonString;\n\nexports.errors = Errors;\nexports.validate = validate;\n"],"file":"package-validator.js"}
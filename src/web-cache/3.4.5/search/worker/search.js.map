{"version":3,"sources":["search/worker/search.js"],"names":["MAX_DISPLAY_LENGTH","MAX_TOTAL_RESULTS","MAX_RESULTS_IN_A_FILE","MAX_RESULTS_TO_RETURN","results","numMatches","numFiles","evaluatedMatches","foundMaximum","exceedsMaximum","savedSearchObject","lastSearchedIndex","collapseResults","offsetToLineNum","textOrLines","offset","Array","isArray","lines","total","line","length","substr","split","getSearchMatches","contents","queryExpr","search","match","lineNum","ch","totalMatchLength","matchedLines","numMatchedLines","lastLineLength","endCh","padding","leftPadding","rightPadding","highlightOffset","highlightEndCh","matches","exec","index","lastIndexOf","Math","min","floor","ceil","substring","push","start","end","startOffset","endOffset","result","isChecked","lastIndex","setResults","fullpath","resultInfo","maxResultsToReturn","collapsed","doSearchInOneFile","filepath","text","async","doSearchInFiles","fileList","startFileIndex","i","getFileContentsForFile","console","log","regexEscape","str","replace","parseQueryInfo","queryInfo","query","empty","flags","isCaseSensitive","isRegexp","RegExp","e","valid","error","message","countNumMatches","getNumMatches","temp","doSearch","searchObject","nextPages","files","queryObject","getAllResults","crawlComplete","send_object","allResultsAvailable","getNextPage","setCollapseResults","collapse","WorkerComm","setExecHandler"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2015 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*eslint-env node */\n/*jslint node: true */\n/*global getFileContentsForFile, files, crawlComplete, WorkerComm */\n\nvar MAX_DISPLAY_LENGTH = 200,\n    MAX_TOTAL_RESULTS = 100000, // only 100,000 search results are supported\n    MAX_RESULTS_IN_A_FILE = MAX_TOTAL_RESULTS,\n    MAX_RESULTS_TO_RETURN = 120;\n\nvar results = {},\n    numMatches = 0,\n    numFiles = 0,\n    evaluatedMatches,\n    foundMaximum = false,\n    exceedsMaximum = false,\n    savedSearchObject = null,\n    lastSearchedIndex = 0,\n    collapseResults = false;\n\n/**\n * Copied from StringUtils.js\n * Returns a line number corresponding to an offset in some text. The text can\n * be specified as a single string or as an array of strings that correspond to\n * the lines of the string.\n *\n * Specify the text in lines when repeatedly calling the function on the same\n * text in a loop. Use getLines() to divide the text into lines, then repeatedly call\n * this function to compute a line number from the offset.\n *\n * @param {string | Array.<string>} textOrLines - string or array of lines from which\n *      to compute the line number from the offset\n * @param {number} offset\n * @return {number} line number\n */\nfunction offsetToLineNum(textOrLines, offset) {\n    if (Array.isArray(textOrLines)) {\n        var lines = textOrLines,\n            total = 0,\n            line;\n        for (line = 0; line < lines.length; line++) {\n            if (total < offset) {\n                // add 1 per line since /n were removed by splitting, but they needed to\n                // contribute to the total offset count\n                total += lines[line].length + 1;\n            } else if (total === offset) {\n                return line;\n            } else {\n                return line - 1;\n            }\n        }\n\n        // if offset is NOT over the total then offset is in the last line\n        if (offset <= total) {\n            return line - 1;\n        }\n        return undefined;\n\n    }\n    return textOrLines.substr(0, offset).split(\"\\n\").length - 1;\n\n}\n\n/**\n * Searches through the contents and returns an array of matches\n * @param {string} contents\n * @param {RegExp} queryExpr\n * @return {!Array.<{start: {line:number,ch:number}, end: {line:number,ch:number}, line: string}>}\n */\nfunction getSearchMatches(contents, queryExpr) {\n    if (!contents) {\n        return;\n    }\n    // Quick exit if not found or if we hit the limit\n    if (foundMaximum || contents.search(queryExpr) === -1) {\n        return [];\n    }\n\n    var match, lineNum, line, ch, totalMatchLength, matchedLines, numMatchedLines, lastLineLength, endCh,\n        padding, leftPadding, rightPadding, highlightOffset, highlightEndCh,\n        lines   = contents.split(\"\\n\"),\n        matches = [];\n\n    while ((match = queryExpr.exec(contents)) !== null) {\n        lineNum          = offsetToLineNum(lines, match.index);\n        line             = lines[lineNum];\n        ch               = match.index - contents.lastIndexOf(\"\\n\", match.index) - 1;  // 0-based index\n        matchedLines     = match[0].split(\"\\n\");\n        numMatchedLines  = matchedLines.length;\n        totalMatchLength = match[0].length;\n        lastLineLength   = matchedLines[matchedLines.length - 1].length;\n        endCh            = (numMatchedLines === 1 ? ch + totalMatchLength : lastLineLength);\n        highlightEndCh   = (numMatchedLines === 1 ? endCh : line.length);\n        highlightOffset  = 0;\n\n        if (highlightEndCh <= MAX_DISPLAY_LENGTH) {\n            // Don't store more than 200 chars per line\n            line = line.substr(0, Math.min(MAX_DISPLAY_LENGTH, line.length));\n        } else if (totalMatchLength > MAX_DISPLAY_LENGTH) {\n            // impossible to display the whole match\n            line = line.substr(ch, ch + MAX_DISPLAY_LENGTH);\n            highlightOffset = ch;\n        } else {\n            // Try to have both beginning and end of match displayed\n            padding = MAX_DISPLAY_LENGTH - totalMatchLength;\n            rightPadding = Math.floor(Math.min(padding / 2, line.length - highlightEndCh));\n            leftPadding = Math.ceil(padding - rightPadding);\n            highlightOffset = ch - leftPadding;\n            line = line.substring(highlightOffset, highlightEndCh + rightPadding);\n        }\n\n        matches.push({\n            start: {line: lineNum, ch: ch},\n            end: {line: lineNum + numMatchedLines - 1, ch: endCh},\n\n            highlightOffset: highlightOffset,\n\n            // Note that the following offsets from the beginning of the file are *not* updated if the search\n            // results change. These are currently only used for multi-file replacement, and we always\n            // abort the replace (by shutting the results panel) if we detect any result changes, so we don't\n            // need to keep them up to date. Eventually, we should either get rid of the need for these (by\n            // doing everything in terms of line/ch offsets, though that will require re-splitting files when\n            // doing a replace) or properly update them.\n            startOffset: match.index,\n            endOffset: match.index + totalMatchLength,\n\n            line: line,\n            result: match,\n            isChecked: true\n        });\n\n        // We have the max hits in just this 1 file. Stop searching this file.\n        // This fixed issue #1829 where code hangs on too many hits.\n        // Adds one over MAX_RESULTS_IN_A_FILE in order to know if the search has exceeded\n        // or is equal to MAX_RESULTS_IN_A_FILE. Additional result removed in SearchModel\n        if (matches.length > MAX_RESULTS_IN_A_FILE) {\n            queryExpr.lastIndex = 0;\n            break;\n        }\n\n        // Pathological regexps like /^/ return 0-length matches. Ensure we make progress anyway\n        if (totalMatchLength === 0) {\n            queryExpr.lastIndex++;\n        }\n    }\n\n    return matches;\n}\n\n/**\n * Sets the list of matches for the given path, removing the previous match info, if any, and updating\n * the total match count. Note that for the count to remain accurate, the previous match info must not have\n * been mutated since it was set.\n * @param {string} fullpath Full path to the file containing the matches.\n * @param {!{matches: Object, collapsed: boolean=}} resultInfo Info for the matches to set:\n *      matches - Array of matches, in the format returned by FindInFiles.getSearchMatches()\n *      collapsed - Optional: whether the results should be collapsed in the UI (default false).\n */\nfunction setResults(fullpath, resultInfo, maxResultsToReturn) {\n    if (results[fullpath]) {\n        numMatches -= results[fullpath].matches.length;\n        delete results[fullpath];\n    }\n\n    if (foundMaximum || !resultInfo || !resultInfo.matches || !resultInfo.matches.length) {\n        return;\n    }\n\n    // Make sure that the optional `collapsed` property is explicitly set to either true or false,\n    // to avoid logic issues later with comparing values.\n    resultInfo.collapsed = collapseResults;\n\n    results[fullpath] = resultInfo;\n    numMatches += resultInfo.matches.length;\n    evaluatedMatches += resultInfo.matches.length;\n    maxResultsToReturn = maxResultsToReturn || MAX_RESULTS_TO_RETURN;\n    if (numMatches >= maxResultsToReturn || evaluatedMatches > MAX_TOTAL_RESULTS) {\n        foundMaximum = true;\n    }\n}\n\n/**\n * Finds search results in the given file and adds them to 'results'\n * @param {string} filepath\n * @param {string} text   contents of the file\n * @param {Object} queryExpr\n * @param {number} maxResultsToReturn the maximum of results that should be returned in the current search.\n */\nfunction doSearchInOneFile(filepath, text, queryExpr, maxResultsToReturn) {\n    var matches = getSearchMatches(text, queryExpr);\n    setResults(filepath, {matches: matches}, maxResultsToReturn);\n}\n\n/**\n * Search in the list of files given and populate the results\n * @param {array} fileList           array of file paths\n * @param {Object} queryExpr\n * @param {number} startFileIndex    the start index of the array from which the search has to be done\n * @param {number} maxResultsToReturn  the maximum number of results to return in this search\n */\nasync function doSearchInFiles(fileList, queryExpr, startFileIndex, maxResultsToReturn) {\n    var i;\n    if (fileList.length === 0) {\n        console.log('no files found');\n        return;\n\n    }\n    startFileIndex = startFileIndex || 0;\n    for (i = startFileIndex; i < fileList.length && !foundMaximum; i++) {\n        let contents = await getFileContentsForFile(fileList[i]);\n        doSearchInOneFile(fileList[i], contents, queryExpr, maxResultsToReturn);\n    }\n    lastSearchedIndex = i;\n\n}\n\n// Copied from StringUtils.js\nfunction regexEscape(str) {\n    return str.replace(/([.?*+\\^$\\[\\]\\\\(){}|\\-])/g, \"\\\\$1\");\n}\n\n/**\n * Parses the given query into a regexp, and returns whether it was valid or not.\n * @param {{query: string, caseSensitive: boolean, isRegexp: boolean}} queryInfo\n * @return {{queryExpr: RegExp, valid: boolean, empty: boolean, error: string}}\n *      queryExpr - the regexp representing the query\n *      valid - set to true if query is a nonempty string or a valid regexp.\n *      empty - set to true if query was empty.\n *      error - set to an error string if valid is false and query is nonempty.\n */\nfunction parseQueryInfo(queryInfo) {\n    var queryExpr;\n\n    // TODO: only major difference between this one and the one in FindReplace is that\n    // this always returns a regexp even for simple strings. Reconcile.\n    if (!queryInfo || !queryInfo.query) {\n        return {empty: true};\n    }\n\n    // For now, treat all matches as multiline (i.e. ^/$ match on every line, not the whole\n    // document). This is consistent with how single-file find works. Eventually we should add\n    // an option for this.\n    var flags = \"gm\";\n    if (!queryInfo.isCaseSensitive) {\n        flags += \"i\";\n    }\n\n    // Is it a (non-blank) regex?\n    if (queryInfo.isRegexp) {\n        try {\n            queryExpr = new RegExp(queryInfo.query, flags);\n        } catch (e) {\n            return {valid: false, error: e.message};\n        }\n    } else {\n        // Query is a plain string. Turn it into a regexp\n        queryExpr = new RegExp(regexEscape(queryInfo.query), flags);\n    }\n    return {valid: true, queryExpr: queryExpr};\n}\n\n/**\n * Counts the number of matches matching the queryExpr in the given contents\n * @param   {String} contents  The contents to search on\n * @param   {Object} queryExpr\n * @return {number} number of matches\n */\nfunction countNumMatches(contents, queryExpr) {\n    if (!contents) {\n        return 0;\n    }\n    var matches = contents.match(queryExpr);\n    return matches ? matches.length : 0;\n}\n\n/**\n * Get the total number of matches from all the files in fileList\n * @param   {array} fileList  file path array\n * @param   {Object} queryExpr\n * @return {Number} total number of matches\n */\nasync function getNumMatches(fileList, queryExpr) {\n    let i,\n        matches = 0;\n    for (i = 0; i < fileList.length; i++) {\n        let contents = await getFileContentsForFile(fileList[i]);\n        let temp = countNumMatches(contents, queryExpr);\n        if (temp) {\n            numFiles++;\n            matches += temp;\n        }\n        if (matches > MAX_TOTAL_RESULTS) {\n            exceedsMaximum = true;\n            break;\n        }\n    }\n    return matches;\n}\n\n/**\n * Do a search with the searchObject context and return the results\n * @param   {Object}   searchObject\n * @param   {boolean} nextPages    set to true if to indicate that next page of an existing page is being fetched\n * @return {Object}   search results\n */\nasync function doSearch(searchObject, nextPages) {\n\n    savedSearchObject = searchObject;\n    if (!files) {\n        console.log(\"file indexer: search was called before indexing or there are no files in project!\");\n        return {\n            \"results\": {},\n            \"foundMaximum\": false,\n            \"exceedsMaximum\": false\n        };\n    }\n    results = {};\n    numMatches = 0;\n    numFiles = 0;\n    foundMaximum = false;\n    if (!nextPages) {\n        exceedsMaximum = false;\n        evaluatedMatches = 0;\n    }\n    var queryObject = parseQueryInfo(searchObject.queryInfo);\n    if (searchObject.files) {\n        files = searchObject.files;\n    }\n    if (searchObject.getAllResults) {\n        searchObject.maxResultsToReturn = MAX_TOTAL_RESULTS;\n    }\n    await doSearchInFiles(files, queryObject.queryExpr, searchObject.startFileIndex, searchObject.maxResultsToReturn);\n    if (crawlComplete && !nextPages) {\n        numMatches = await getNumMatches(files, queryObject.queryExpr);\n    }\n    var send_object = {\n        \"results\": results,\n        \"foundMaximum\": foundMaximum,\n        \"exceedsMaximum\": exceedsMaximum\n    };\n\n    if (!nextPages) {\n        send_object.numMatches = numMatches;\n        send_object.numFiles = numFiles;\n    }\n\n    if (searchObject.getAllResults) {\n        send_object.allResultsAvailable = true;\n    }\n    return send_object;\n}\n\n/**\n * Gets the next page of results of the ongoing search\n * @return {Object} search results\n */\nasync function getNextPage() {\n    var send_object = {\n        \"results\": {},\n        \"numMatches\": 0,\n        \"foundMaximum\": foundMaximum,\n        \"exceedsMaximum\": exceedsMaximum\n    };\n    if (!savedSearchObject) {\n        return send_object;\n    }\n    savedSearchObject.startFileIndex = lastSearchedIndex;\n    return doSearch(savedSearchObject, true);\n}\n\n/**\n * Gets all the results for the saved search query if present or empty search results\n * @return {Object} The results object\n */\nasync function getAllResults() {\n    var send_object = {\n        \"results\": {},\n        \"numMatches\": 0,\n        \"foundMaximum\": foundMaximum,\n        \"exceedsMaximum\": exceedsMaximum\n    };\n    if (!savedSearchObject) {\n        return send_object;\n    }\n    savedSearchObject.startFileIndex = 0;\n    savedSearchObject.getAllResults = true;\n    return doSearch(savedSearchObject);\n}\n\n/**\n * Sets if the results should be collapsed\n * @param {boolean} collapse true to collapse\n */\nfunction setCollapseResults(collapse) {\n    collapseResults = collapse;\n}\n\n\nWorkerComm.setExecHandler(\"doSearch\", doSearch);\nWorkerComm.setExecHandler(\"nextPage\", getNextPage);\nWorkerComm.setExecHandler(\"getAllResults\", getAllResults);\nWorkerComm.setExecHandler(\"collapseResults\", setCollapseResults);\n"],"file":"search.js"}
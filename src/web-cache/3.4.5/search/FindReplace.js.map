{"version":3,"sources":["search/FindReplace.js"],"names":["define","require","exports","module","CommandManager","Commands","MainViewManager","Strings","StringUtils","Editor","EditorManager","FindBar","FindUtils","FindInFilesUI","ScrollTrackMarkers","_","CodeMirror","FIND_MAX_FILE_SIZE","FIND_HIGHLIGHT_MAX","findBar","SearchState","this","searchStartPos","parsedQuery","queryInfo","foundAny","marked","resultSet","matchIndex","markedCurrent","getSearchState","cm","_searchState","getSearchCursor","state","pos","isCaseSensitive","parseQuery","showError","parsed","parseQueryInfo","empty","valid","queryExpr","error","setQueryInfo","_updateFindBarWithMatchInfo","matchRange","searchBackwards","findIndex","length","isEqual","console","assert","showFindCount","format","FIND_MATCH_INDEX","_getNextMatch","editor","wrap","_codeMirror","cursor","getCursorPos","lastMatch","find","line","lineCount","ch","start","from","end","to","setCursor","_selectAndScrollTo","selections","center","preferNoScroll","primarySelection","sel","primary","last","resultVisible","isLineVisible","centerOptions","BOUNDARY_CHECK_NORMAL","BOUNDARY_IGNORE_TOP","scrollIntoView","setSelections","_getWordAt","getLine","isWordChar","charAt","text","slice","_selEq","sel1","sel2","cmpPos","_expandWordAndAddNextToSelection","removePrimary","getActiveEditor","getSelections","primarySel","primaryIndex","searchText","added","each","index","isEmpty","document","getRange","wordInfo","query","isRegexp","searchStart","nextMatch","isInSelection","partial","push","splice","_skipCurrentMatch","_findAllAndSelect","getSelection","newSelections","clearCurrentMatchHighlight","clear","markCurrent","findNext","operation","isClosed","curentMatchClassName","markText","className","startStyle","endStyle","clearHighlights","forEach","markedRange","clearSearch","toggleHighlighting","enabled","$","getRootElement","addClass","removeClass","setVisible","updateResultSet","indicateHasMatches","numResults","showNoResults","getQueryInfo","enableNavigation","enableReplace","getValue","result","scrollTrackPositions","map","addTickmarks","FIND_NO_RESULTS","handleQueryChange","initial","lastParsedQuery","openSearchBar","replace","initialQuery","getInitialQuery","close","multifile","initialReplaceText","replaceText","queryPlaceholder","FIND_QUERY_PLACEHOLDER","open","on","e","off","doSearch","_handleFileChanged","doReplace","all","getReplaceText","options","readOnly","searchAndReplaceResults","file","searchAndShowResults","replaceSelection","parseDollars","getOptions","isReplaceEnabled","_launchFind","_findNext","_findPrevious","_replace","register","CMD_FIND","CMD_FIND_NEXT","CMD_REPLACE","CMD_FIND_PREVIOUS","CMD_FIND_ALL_AND_SELECT","CMD_ADD_NEXT_MATCH","CMD_SKIP_CURRENT_MATCH"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: FindReplace*/\n\n/**\n * Adds Find and Replace commands\n *\n * Originally based on the code in CodeMirror/lib/util/search.js.\n */\ndefine(function (require, exports, module) {\n\n\n    var CommandManager      = require(\"command/CommandManager\"),\n        Commands            = require(\"command/Commands\"),\n        MainViewManager     = require(\"view/MainViewManager\"),\n        Strings             = require(\"strings\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        Editor              = require(\"editor/Editor\"),\n        EditorManager       = require(\"editor/EditorManager\"),\n        FindBar             = require(\"search/FindBar\").FindBar,\n        FindUtils           = require(\"search/FindUtils\"),\n        FindInFilesUI       = require(\"search/FindInFilesUI\"),\n        ScrollTrackMarkers  = require(\"search/ScrollTrackMarkers\"),\n        _                   = require(\"thirdparty/lodash\"),\n        CodeMirror          = require(\"thirdparty/CodeMirror/lib/codemirror\");\n\n    /**\n     * Maximum file size to search within (in chars)\n     * @const {number}\n     */\n    var FIND_MAX_FILE_SIZE  = 500000;\n\n    /**\n     * If the number of matches exceeds this limit, inline text highlighting and scroll-track tickmarks are disabled\n     * @const {number}\n     */\n    var FIND_HIGHLIGHT_MAX  = 2000;\n\n    /**\n     * Currently open Find or Find/Replace bar, if any\n     * @type {?FindBar}\n     */\n    var findBar;\n\n    function SearchState() {\n        this.searchStartPos = null;\n        this.parsedQuery = null;\n        this.queryInfo = null;\n        this.foundAny = false;\n        this.marked = [];\n        this.resultSet = [];\n        this.matchIndex = -1;\n        this.markedCurrent = null;\n    }\n\n    function getSearchState(cm) {\n        if (!cm._searchState) {\n            cm._searchState = new SearchState();\n        }\n        return cm._searchState;\n    }\n\n    function getSearchCursor(cm, state, pos) {\n        // Heuristic: if the query string is all lowercase, do a case insensitive search.\n        return cm.getSearchCursor(state.parsedQuery, pos, !state.queryInfo.isCaseSensitive);\n    }\n\n    function parseQuery(queryInfo) {\n        if (findBar) {\n            findBar.showError(null);\n        }\n\n        var parsed = FindUtils.parseQueryInfo(queryInfo);\n        if (parsed.empty === true) {\n            return \"\";\n        }\n\n        if (!parsed.valid) {\n            if (findBar) {\n                findBar.showError(parsed.error);\n            }\n            return \"\";\n        }\n\n        return parsed.queryExpr;\n    }\n\n    /**\n     * @private\n     * Determine the query from the given info and store it in the state.\n     * @param {SearchState} state The state to store the parsed query in\n     * @param {{query: string, caseSensitive: boolean, isRegexp: boolean}} queryInfo\n     *      The query info object as returned by FindBar.getQueryInfo()\n     */\n    function setQueryInfo(state, queryInfo) {\n        state.queryInfo = queryInfo;\n        if (!queryInfo) {\n            state.parsedQuery = null;\n        } else {\n            state.parsedQuery = parseQuery(queryInfo);\n        }\n    }\n\n    /**\n     * @private\n     * Show the current match index by finding matchRange in the resultSet stored\n     * in the search state if this is the first call for a new search query. For\n     * subsequent calls, just compare matchRange with the next match in the resultSet\n     * based on the search direction and show the next match if they are the same.\n     * If not, then find the match index by searching matchRange in the entire resultSet.\n     *\n     * @param {!SearchState} state The search state that has the array of search result\n     * @param {!{from: {line: number, ch: number}, to: {line: number, ch: number}}} matchRange - the range of current match\n     * @param {!boolean} searchBackwards true if searching backwards\n     */\n    function _updateFindBarWithMatchInfo(state, matchRange, searchBackwards) {\n        // Bail if there is no result set.\n        if (!state.foundAny) {\n            return;\n        }\n\n        if (findBar) {\n            if (state.matchIndex === -1) {\n                state.matchIndex = _.findIndex(state.resultSet, matchRange);\n            } else {\n                state.matchIndex = searchBackwards ? state.matchIndex - 1 : state.matchIndex + 1;\n                // Adjust matchIndex for modulo wraparound\n                state.matchIndex = (state.matchIndex + state.resultSet.length) % state.resultSet.length;\n\n                // Confirm that we find the right matchIndex. If not, then search\n                // matchRange in the entire resultSet.\n                if (!_.isEqual(state.resultSet[state.matchIndex], matchRange)) {\n                    state.matchIndex = _.findIndex(state.resultSet, matchRange);\n                }\n            }\n\n            console.assert(state.matchIndex !== -1);\n            if (state.matchIndex !== -1) {\n                // Convert to 1-based by adding one before showing the index.\n                findBar.showFindCount(StringUtils.format(Strings.FIND_MATCH_INDEX,\n                                                        state.matchIndex + 1, state.resultSet.length));\n            }\n        }\n    }\n\n    /**\n     * @private\n     * Returns the next match for the current query (from the search state) before/after the given position. Wraps around\n     * the end of the document if no match is found before the end.\n     *\n     * @param {!Editor} editor The editor to search in\n     * @param {boolean} searchBackwards true to search backwards\n     * @param {{line: number, ch: number}=} pos The position to start from. Defaults to the current primary selection's\n     *      head cursor position.\n     * @param {boolean=} wrap Whether to wrap the search around if we hit the end of the document. Default true.\n     * @return {?{start: {line: number, ch: number}, end: {line: number, ch: number}}} The range for the next match, or\n     *      null if there is no match.\n     */\n    function _getNextMatch(editor, searchBackwards, pos, wrap) {\n        var cm = editor._codeMirror;\n        var state = getSearchState(cm);\n        var cursor = getSearchCursor(cm, state, pos || editor.getCursorPos(false, searchBackwards ? \"start\" : \"end\"));\n\n        state.lastMatch = cursor.find(searchBackwards);\n        if (!state.lastMatch && wrap !== false) {\n            // If no result found before hitting edge of file, try wrapping around\n            cursor = getSearchCursor(cm, state, searchBackwards ? {line: cm.lineCount() - 1} : {line: 0, ch: 0});\n            state.lastMatch = cursor.find(searchBackwards);\n        }\n        if (!state.lastMatch) {\n            // No result found, period: clear selection & bail\n            cm.setCursor(editor.getCursorPos());  // collapses selection, keeping cursor in place to avoid scrolling\n            return null;\n        }\n\n        return {start: cursor.from(), end: cursor.to()};\n    }\n\n    /**\n     * @private\n     * Sets the given selections in the editor and applies some heuristics to determine whether and how we should\n     * center the primary selection.\n     *\n     * @param {!Editor} editor The editor to search in\n     * @param {!Array<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean}>} selections\n     *      The selections to set. Must not be empty.\n     * @param {boolean} center Whether to try to center the primary selection vertically on the screen. If false, the selection will still be scrolled\n     *      into view if it's offscreen, but will not be centered.\n     * @param {boolean=} preferNoScroll If center is true, whether to avoid scrolling if the hit is in the top half of the screen. Default false.\n     */\n    function _selectAndScrollTo(editor, selections, center, preferNoScroll) {\n        var primarySelection = _.find(selections, function (sel) { return sel.primary; }) || _.last(selections),\n            resultVisible = editor.isLineVisible(primarySelection.start.line),\n            centerOptions = Editor.BOUNDARY_CHECK_NORMAL;\n\n        if (preferNoScroll && resultVisible) {\n            // no need to scroll if the line with the match is in view\n            centerOptions = Editor.BOUNDARY_IGNORE_TOP;\n        }\n\n        // Make sure the primary selection is fully visible on screen.\n        var primary = _.find(selections, function (sel) {\n            return sel.primary;\n        });\n        if (!primary) {\n            primary = _.last(selections);\n        }\n\n        editor._codeMirror.scrollIntoView({from: primary.start, to: primary.end});\n        editor.setSelections(selections, center, centerOptions);\n    }\n\n    /**\n     * Returns the range of the word surrounding the given editor position. Similar to getWordAt() from CodeMirror.\n     *\n     * @param {!Editor} editor The editor to search in\n     * @param {!{line: number, ch: number}} pos The position to find a word at.\n     * @return {{start:{line: number, ch: number}, end:{line:number, ch:number}, text:string}} The range and content of the found word. If\n     *     there is no word, start will equal end and the text will be the empty string.\n     */\n    function _getWordAt(editor, pos) {\n        var cm = editor._codeMirror,\n            start = pos.ch,\n            end = start,\n            line = cm.getLine(pos.line);\n        while (start && CodeMirror.isWordChar(line.charAt(start - 1))) {\n            --start;\n        }\n        while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) {\n            ++end;\n        }\n        return {start: {line: pos.line, ch: start}, end: {line: pos.line, ch: end}, text: line.slice(start, end)};\n    }\n\n    /**\n     * @private\n     * Helper function. Returns true if two selections are equal.\n     * @param {!{start: {line: number, ch: number}, end: {line: number, ch: number}}} sel1 The first selection to compare\n     * @param {!{start: {line: number, ch: number}, end: {line: number, ch: number}}} sel2 The second selection to compare\n     * @return {boolean} true if the selections are equal\n     */\n    function _selEq(sel1, sel2) {\n        return (CodeMirror.cmpPos(sel1.start, sel2.start) === 0 && CodeMirror.cmpPos(sel1.end, sel2.end) === 0);\n    }\n\n    /**\n     * Expands each empty range in the selection to the nearest word boundaries. Then, if the primary selection\n     * was already a range (even a non-word range), adds the next instance of the contents of that range as a selection.\n     *\n     * @param {!Editor} editor The editor to search in\n     * @param {boolean=} removePrimary Whether to remove the current primary selection in addition to adding the\n     * next one. If true, we add the next match even if the current primary selection is a cursor (we expand it\n     * first to determine what to match).\n     */\n    function _expandWordAndAddNextToSelection(editor, removePrimary) {\n        editor = editor || EditorManager.getActiveEditor();\n        if (!editor) {\n            return;\n        }\n\n        var selections = editor.getSelections(),\n            primarySel,\n            primaryIndex,\n            searchText,\n            added = false;\n\n        _.each(selections, function (sel, index) {\n            var isEmpty = (CodeMirror.cmpPos(sel.start, sel.end) === 0);\n            if (sel.primary) {\n                primarySel = sel;\n                primaryIndex = index;\n                if (!isEmpty) {\n                    searchText = editor.document.getRange(primarySel.start, primarySel.end);\n                }\n            }\n            if (isEmpty) {\n                var wordInfo = _getWordAt(editor, sel.start);\n                sel.start = wordInfo.start;\n                sel.end = wordInfo.end;\n                if (sel.primary && removePrimary) {\n                    // Get the expanded text, even though we're going to remove this selection,\n                    // since in this case we still want to select the next match.\n                    searchText = wordInfo.text;\n                }\n            }\n        });\n\n        if (searchText && searchText.length) {\n            // We store this as a query in the state so that if the user next does a \"Find Next\",\n            // it will use the same query (but throw away the existing selection).\n            var state = getSearchState(editor._codeMirror);\n            setQueryInfo(state, { query: searchText, isCaseSensitive: false, isRegexp: false });\n\n            // Skip over matches that are already in the selection.\n            var searchStart = primarySel.end,\n                nextMatch,\n                isInSelection;\n            do {\n                nextMatch = _getNextMatch(editor, false, searchStart);\n                if (nextMatch) {\n                    // This is a little silly, but if we just stick the equivalence test function in here\n                    // JSLint complains about creating a function in a loop, even though it's safe in this case.\n                    isInSelection = _.find(selections, _.partial(_selEq, nextMatch));\n                    searchStart = nextMatch.end;\n\n                    // If we've gone all the way around, then all instances must have been selected already.\n                    if (CodeMirror.cmpPos(searchStart, primarySel.end) === 0) {\n                        nextMatch = null;\n                        break;\n                    }\n                }\n            } while (nextMatch && isInSelection);\n\n            if (nextMatch) {\n                nextMatch.primary = true;\n                selections.push(nextMatch);\n                added = true;\n            }\n        }\n\n        if (removePrimary) {\n            selections.splice(primaryIndex, 1);\n        }\n\n        if (added) {\n            // Center the new match, but avoid scrolling to matches that are already on screen.\n            _selectAndScrollTo(editor, selections, true, true);\n        } else {\n            // If all we did was expand some selections, don't center anything.\n            _selectAndScrollTo(editor, selections, false);\n        }\n    }\n\n    function _skipCurrentMatch(editor) {\n        return _expandWordAndAddNextToSelection(editor, true);\n    }\n\n    /**\n     * Takes the primary selection, expands it to a word range if necessary, then sets the selection to\n     * include all instances of that range. Removes all other selections. Does nothing if the selection\n     * is not a range after expansion.\n     */\n    function _findAllAndSelect(editor) {\n        editor = editor || EditorManager.getActiveEditor();\n        if (!editor) {\n            return;\n        }\n\n        var sel = editor.getSelection(),\n            newSelections = [];\n        if (CodeMirror.cmpPos(sel.start, sel.end) === 0) {\n            sel = _getWordAt(editor, sel.start);\n        }\n        if (CodeMirror.cmpPos(sel.start, sel.end) !== 0) {\n            var searchStart = {line: 0, ch: 0},\n                state = getSearchState(editor._codeMirror),\n                nextMatch;\n            setQueryInfo(state, { query: editor.document.getRange(sel.start, sel.end), isCaseSensitive: false, isRegexp: false });\n\n            while ((nextMatch = _getNextMatch(editor, false, searchStart, false)) !== null) {\n                if (_selEq(sel, nextMatch)) {\n                    nextMatch.primary = true;\n                }\n                newSelections.push(nextMatch);\n                searchStart = nextMatch.end;\n            }\n\n            // This should find at least the original selection, but just in case...\n            if (newSelections.length) {\n                // Don't change the scroll position.\n                editor.setSelections(newSelections, false);\n            }\n        }\n    }\n\n    /** Removes the current-match highlight, leaving all matches marked in the generic highlight style */\n    function clearCurrentMatchHighlight(cm, state) {\n        if (state.markedCurrent) {\n            state.markedCurrent.clear();\n            ScrollTrackMarkers.markCurrent(-1);\n        }\n    }\n\n    /**\n     * Selects the next match (or prev match, if searchBackwards==true) starting from either the current position\n     * (if pos unspecified) or the given position (if pos specified explicitly). The starting position\n     * need not be an existing match. If a new match is found, sets to state.lastMatch either the regex\n     * match result, or simply true for a plain-string match. If no match found, sets state.lastMatch\n     * to false.\n     * @param {!Editor} editor\n     * @param {?boolean} searchBackwards\n     * @param {?boolean} preferNoScroll\n     * @param {?Pos} pos\n     */\n    function findNext(editor, searchBackwards, preferNoScroll, pos) {\n        var cm = editor._codeMirror;\n        cm.operation(function () {\n            var state = getSearchState(cm);\n            clearCurrentMatchHighlight(cm, state);\n\n            var nextMatch = _getNextMatch(editor, searchBackwards, pos);\n            if (nextMatch) {\n                // Update match index indicators - only possible if we have resultSet saved (missing if FIND_MAX_FILE_SIZE threshold hit)\n                if (state.resultSet.length) {\n                    _updateFindBarWithMatchInfo(state,\n                                                {from: nextMatch.start, to: nextMatch.end}, searchBackwards);\n                    // Update current-tickmark indicator - only if highlighting enabled (disabled if FIND_HIGHLIGHT_MAX threshold hit)\n                    if (state.marked.length) {\n                        ScrollTrackMarkers.markCurrent(state.matchIndex);  // _updateFindBarWithMatchInfo() has updated this index\n                    }\n                }\n\n                _selectAndScrollTo(editor, [nextMatch], true, preferNoScroll);\n\n                // Only mark text with \"current match\" highlight if search bar still open\n                if (findBar && !findBar.isClosed()) {\n                    // If highlighting disabled, apply both match AND current-match styles for correct appearance\n                    var curentMatchClassName = state.marked.length ? \"searching-current-match\" : \"CodeMirror-searching searching-current-match\";\n                    state.markedCurrent = cm.markText(nextMatch.start, nextMatch.end,\n                         { className: curentMatchClassName, startStyle: \"searching-first\", endStyle: \"searching-last\" });\n                }\n            } else {\n                cm.setCursor(editor.getCursorPos());  // collapses selection, keeping cursor in place to avoid scrolling\n                // (nothing more to do: previous highlights already cleared above)\n            }\n        });\n    }\n\n    /** Clears all match highlights, including the current match */\n    function clearHighlights(cm, state) {\n        cm.operation(function () {\n            state.marked.forEach(function (markedRange) {\n                markedRange.clear();\n            });\n            clearCurrentMatchHighlight(cm, state);\n        });\n        state.marked.length = 0;\n        state.markedCurrent = null;\n\n        ScrollTrackMarkers.clear();\n\n        state.resultSet = [];\n        state.matchIndex = -1;\n    }\n\n    function clearSearch(cm) {\n        cm.operation(function () {\n            var state = getSearchState(cm);\n            if (!state.parsedQuery) {\n                return;\n            }\n            setQueryInfo(state, null);\n\n            clearHighlights(cm, state);\n        });\n    }\n\n    function toggleHighlighting(editor, enabled) {\n        // Temporarily change selection color to improve highlighting - see LESS code for details\n        if (enabled) {\n            $(editor.getRootElement()).addClass(\"find-highlighting\");\n        } else {\n            $(editor.getRootElement()).removeClass(\"find-highlighting\");\n        }\n\n        ScrollTrackMarkers.setVisible(editor, enabled);\n    }\n\n    /**\n     * Called each time the search query changes or document is modified (via Replace). Updates\n     * the match count, match highlights and scrollbar tickmarks. Does not change the cursor pos.\n     */\n    function updateResultSet(editor) {\n        var cm = editor._codeMirror,\n            state = getSearchState(cm);\n\n        function indicateHasMatches(numResults) {\n            // Make the field red if it's not blank and it has no matches (which also covers invalid regexes)\n            findBar.showNoResults(!state.foundAny && findBar.getQueryInfo().query);\n\n            // Navigation buttons enabled if we have a query and more than one match\n            findBar.enableNavigation(state.foundAny && numResults > 1);\n            findBar.enableReplace(state.foundAny);\n        }\n\n        cm.operation(function () {\n            // Clear old highlights\n            if (state.marked) {\n                clearHighlights(cm, state);\n            }\n\n            if (!state.parsedQuery) {\n                // Search field is empty - no results\n                findBar.showFindCount(\"\");\n                state.foundAny = false;\n                indicateHasMatches();\n                return;\n            }\n\n            // Find *all* matches, searching from start of document\n            // (Except on huge documents, where this is too expensive)\n            var cursor = getSearchCursor(cm, state);\n            if (cm.getValue().length <= FIND_MAX_FILE_SIZE) {\n                // FUTURE: if last query was prefix of this one, could optimize by filtering last result set\n                state.resultSet = [];\n                while (cursor.findNext()) {\n                    state.resultSet.push(cursor.pos);  // pos is unique obj per search result\n                }\n\n                // Highlight all matches if there aren't too many\n                if (state.resultSet.length <= FIND_HIGHLIGHT_MAX) {\n                    toggleHighlighting(editor, true);\n\n                    state.resultSet.forEach(function (result) {\n                        state.marked.push(cm.markText(result.from, result.to,\n                             { className: \"CodeMirror-searching\", startStyle: \"searching-first\", endStyle: \"searching-last\" }));\n                    });\n                    var scrollTrackPositions = state.resultSet.map(function (result) {\n                        return result.from;\n                    });\n\n                    ScrollTrackMarkers.addTickmarks(editor, scrollTrackPositions);\n                }\n\n                // Here we only update find bar with no result. In the case of a match\n                // a findNext() call is guaranteed to be followed by this function call,\n                // and findNext() in turn calls _updateFindBarWithMatchInfo() to show the\n                // match index.\n                if (state.resultSet.length === 0) {\n                    findBar.showFindCount(Strings.FIND_NO_RESULTS);\n                }\n\n                state.foundAny = (state.resultSet.length > 0);\n                indicateHasMatches(state.resultSet.length);\n\n            } else {\n                // On huge documents, just look for first match & then stop\n                findBar.showFindCount(\"\");\n                state.foundAny = cursor.findNext();\n                indicateHasMatches();\n            }\n        });\n    }\n\n    /**\n     * Called each time the search query field changes. Updates state.parsedQuery (parsedQuery will be falsy if the field\n     * was blank OR contained a regexp with invalid syntax). Then calls updateResultSet(), and then jumps to\n     * the first matching result, starting from the original cursor position.\n     * @param {!Editor} editor The editor we're searching in.\n     * @param {Object} state The current query state.\n     * @param {boolean} initial Whether this is the initial population of the query when the search bar opens.\n     *     In that case, we don't want to change the selection unnecessarily.\n     */\n    function handleQueryChange(editor, state, initial) {\n        setQueryInfo(state, findBar.getQueryInfo());\n        updateResultSet(editor);\n\n        if (state.parsedQuery) {\n            // 3rd arg: prefer to avoid scrolling if result is anywhere within view, since in this case user\n            // is in the middle of typing, not navigating explicitly; viewport jumping would be distracting.\n            findNext(editor, false, true, state.searchStartPos);\n        } else if (!initial) {\n            // Blank or invalid query: just jump back to initial pos\n            editor._codeMirror.setCursor(state.searchStartPos);\n        }\n\n        editor.lastParsedQuery = state.parsedQuery;\n    }\n\n\n    /**\n     * Creates a Find bar for the current search session.\n     * @param {!Editor} editor\n     * @param {boolean} replace Whether to show the Replace UI; default false\n     */\n    function openSearchBar(editor, replace) {\n        var cm = editor._codeMirror,\n            state = getSearchState(cm);\n\n        // Use the selection start as the searchStartPos. This way if you\n        // start with a pre-populated search and enter an additional character,\n        // it will extend the initial selection instead of jumping to the next\n        // occurrence.\n        state.searchStartPos = editor.getCursorPos(false, \"start\");\n\n        // Prepopulate the search field\n        var initialQuery = FindBar.getInitialQuery(findBar, editor);\n        if (initialQuery.query === \"\" && editor.lastParsedQuery !== \"\") {\n            initialQuery.query = editor.lastParsedQuery;\n        }\n\n        // Close our previous find bar, if any. (The open() of the new findBar will\n        // take care of closing any other find bar instances.)\n        if (findBar) {\n            findBar.close();\n        }\n\n        // Create the search bar UI (closing any previous find bar in the process)\n        findBar = new FindBar({\n            multifile: false,\n            replace: replace,\n            initialQuery: initialQuery.query,\n            initialReplaceText: initialQuery.replaceText,\n            queryPlaceholder: Strings.FIND_QUERY_PLACEHOLDER\n        });\n        findBar.open();\n\n        findBar\n            .on(\"queryChange.FindReplace\", function (e) {\n                handleQueryChange(editor, state);\n            })\n            .on(\"doFind.FindReplace\", function (e, searchBackwards) {\n                findNext(editor, searchBackwards);\n            })\n            .on(\"close.FindReplace\", function (e) {\n                editor.lastParsedQuery = state.parsedQuery;\n                // Clear highlights but leave search state in place so Find Next/Previous work after closing\n                clearHighlights(cm, state);\n\n                // Dispose highlighting UI (important to restore normal selection color as soon as focus goes back to the editor)\n                toggleHighlighting(editor, false);\n\n                findBar.off(\".FindReplace\");\n                findBar = null;\n            });\n\n        handleQueryChange(editor, state, true);\n    }\n\n    /**\n     * If no search pending, opens the Find dialog. If search bar already open, moves to\n     * next/prev result (depending on 'searchBackwards')\n     */\n    function doSearch(editor, searchBackwards) {\n        var state = getSearchState(editor._codeMirror);\n\n        if (state.parsedQuery) {\n            findNext(editor, searchBackwards);\n        } else {\n            openSearchBar(editor, false);\n        }\n    }\n\n\n    /**\n     * @private\n     * When the user switches documents (or closes the last document), ensure that the find bar\n     * closes, and also close the Replace All panel.\n     */\n    function _handleFileChanged() {\n        if (findBar) {\n            findBar.close();\n        }\n    }\n\n    function doReplace(editor, all) {\n        var cm = editor._codeMirror,\n            state = getSearchState(cm),\n            replaceText = findBar.getReplaceText();\n\n        // Do not replace if editor is set to read only\n        if (cm.options.readOnly) {\n            return;\n        }\n\n        if (all === null) {\n            findBar.close();\n            FindInFilesUI.searchAndReplaceResults(state.queryInfo, editor.document.file, null, replaceText);\n        } else if (all) {\n            findBar.close();\n            // Delegate to Replace in Files.\n            FindInFilesUI.searchAndShowResults(state.queryInfo, editor.document.file, null, replaceText);\n        } else {\n            cm.replaceSelection(state.queryInfo.isRegexp ? FindUtils.parseDollars(replaceText, state.lastMatch) : replaceText);\n\n            updateResultSet(editor);  // we updated the text, so result count & tickmarks must be refreshed\n\n            findNext(editor);\n            if (!state.lastMatch) {\n                // No more matches, so destroy find bar\n                findBar.close();\n            }\n        }\n    }\n\n    function replace(editor) {\n        // If Replace bar already open, treat the shortcut as a hotkey for the Replace button\n        if (findBar && findBar.getOptions().replace && findBar.isReplaceEnabled()) {\n            doReplace(editor, false);\n            return;\n        }\n\n        openSearchBar(editor, true);\n\n        findBar\n            .on(\"doReplace.FindReplace\", function (e) {\n                doReplace(editor, false);\n            })\n            .on(\"doReplaceBatch.FindReplace\", function (e) {\n                doReplace(editor, true);\n            })\n            .on(\"doReplaceAll.FindReplace\", function (e) {\n                doReplace(editor, null);\n            });\n    }\n\n    function _launchFind() {\n        var editor = EditorManager.getActiveEditor();\n\n        if (editor) {\n            // Create a new instance of the search bar UI\n            clearSearch(editor._codeMirror);\n            doSearch(editor, false);\n        }\n    }\n\n    function _findNext() {\n        var editor = EditorManager.getActiveEditor();\n        if (editor) {\n            doSearch(editor);\n        }\n    }\n\n    function _findPrevious() {\n        var editor = EditorManager.getActiveEditor();\n        if (editor) {\n            doSearch(editor, true);\n        }\n    }\n\n    function _replace() {\n        var editor = EditorManager.getActiveEditor();\n        if (editor) {\n            replace(editor);\n        }\n    }\n\n    MainViewManager.on(\"currentFileChange\", _handleFileChanged);\n\n    CommandManager.register(Strings.CMD_FIND,                   Commands.CMD_FIND,                  _launchFind);\n    CommandManager.register(Strings.CMD_FIND_NEXT,              Commands.CMD_FIND_NEXT,             _findNext);\n    CommandManager.register(Strings.CMD_REPLACE,                Commands.CMD_REPLACE,               _replace);\n    CommandManager.register(Strings.CMD_FIND_PREVIOUS,          Commands.CMD_FIND_PREVIOUS,         _findPrevious);\n    CommandManager.register(Strings.CMD_FIND_ALL_AND_SELECT,    Commands.CMD_FIND_ALL_AND_SELECT,   _findAllAndSelect);\n    CommandManager.register(Strings.CMD_ADD_NEXT_MATCH,         Commands.CMD_ADD_NEXT_MATCH,        _expandWordAndAddNextToSelection);\n    CommandManager.register(Strings.CMD_SKIP_CURRENT_MATCH,     Commands.CMD_SKIP_CURRENT_MATCH,    _skipCurrentMatch);\n\n    // For unit testing\n    exports._getWordAt                       = _getWordAt;\n    exports._expandWordAndAddNextToSelection = _expandWordAndAddNextToSelection;\n    exports._findAllAndSelect                = _findAllAndSelect;\n});\n"],"file":"FindReplace.js"}
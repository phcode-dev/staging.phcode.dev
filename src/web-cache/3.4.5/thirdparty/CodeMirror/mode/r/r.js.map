{"version":3,"sources":["thirdparty/CodeMirror/mode/r/r.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","registerHelper","defineMode","config","wordObj","words","res","i","length","commonAtoms","commonBuiltins","commonKeywords","commonBlockKeywords","concat","atoms","builtins","keywords","blockkeywords","opChars","curPunc","tokenBase","stream","state","ch","next","skipToEnd","eat","eatWhile","match","test","tokenize","tokenString","word","current","propertyIsEnumerable","skipTo","ctx","argList","quote","backUp","ALIGN_YES","ALIGN_NO","BRACELESS","push","type","indent","flags","column","prev","setFlag","flag","pop","startState","indentUnit","afterIdent","token","sol","indentation","eatSpace","style","textAfter","firstChar","charAt","closing","lineComment","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"wordChars\", \"r\", /[\\w.]/);\n\nCodeMirror.defineMode(\"r\", function(config) {\n  function wordObj(words) {\n    var res = {};\n    for (var i = 0; i < words.length; ++i) res[words[i]] = true;\n    return res;\n  }\n  var commonAtoms = [\"NULL\", \"NA\", \"Inf\", \"NaN\", \"NA_integer_\", \"NA_real_\", \"NA_complex_\", \"NA_character_\", \"TRUE\", \"FALSE\"];\n  var commonBuiltins = [\"list\", \"quote\", \"bquote\", \"eval\", \"return\", \"call\", \"parse\", \"deparse\"];\n  var commonKeywords = [\"if\", \"else\", \"repeat\", \"while\", \"function\", \"for\", \"in\", \"next\", \"break\"];\n  var commonBlockKeywords = [\"if\", \"else\", \"repeat\", \"while\", \"function\", \"for\"];\n\n  CodeMirror.registerHelper(\"hintWords\", \"r\", commonAtoms.concat(commonBuiltins, commonKeywords));\n\n  var atoms = wordObj(commonAtoms);\n  var builtins = wordObj(commonBuiltins);\n  var keywords = wordObj(commonKeywords);\n  var blockkeywords = wordObj(commonBlockKeywords);\n  var opChars = /[+\\-*\\/^<>=!&|~$:]/;\n  var curPunc;\n\n  function tokenBase(stream, state) {\n    curPunc = null;\n    var ch = stream.next();\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    } else if (ch == \"0\" && stream.eat(\"x\")) {\n      stream.eatWhile(/[\\da-f]/i);\n      return \"number\";\n    } else if (ch == \".\" && stream.eat(/\\d/)) {\n      stream.match(/\\d*(?:e[+\\-]?\\d+)?/);\n      return \"number\";\n    } else if (/\\d/.test(ch)) {\n      stream.match(/\\d*(?:\\.\\d+)?(?:e[+\\-]\\d+)?L?/);\n      return \"number\";\n    } else if (ch == \"'\" || ch == '\"') {\n      state.tokenize = tokenString(ch);\n      return \"string\";\n    } else if (ch == \"`\") {\n      stream.match(/[^`]+`/);\n      return \"variable-3\";\n    } else if (ch == \".\" && stream.match(/.(?:[.]|\\d+)/)) {\n      return \"keyword\";\n    } else if (/[a-zA-Z\\.]/.test(ch)) {\n      stream.eatWhile(/[\\w\\.]/);\n      var word = stream.current();\n      if (atoms.propertyIsEnumerable(word)) return \"atom\";\n      if (keywords.propertyIsEnumerable(word)) {\n        // Block keywords start new blocks, except 'else if', which only starts\n        // one new block for the 'if', no block for the 'else'.\n        if (blockkeywords.propertyIsEnumerable(word) &&\n            !stream.match(/\\s*if(\\s+|$)/, false))\n          curPunc = \"block\";\n        return \"keyword\";\n      }\n      if (builtins.propertyIsEnumerable(word)) return \"builtin\";\n      return \"variable\";\n    } else if (ch == \"%\") {\n      if (stream.skipTo(\"%\")) stream.next();\n      return \"operator variable-2\";\n    } else if (\n        (ch == \"<\" && stream.eat(\"-\")) ||\n        (ch == \"<\" && stream.match(\"<-\")) ||\n        (ch == \"-\" && stream.match(/>>?/))\n      ) {\n      return \"operator arrow\";\n    } else if (ch == \"=\" && state.ctx.argList) {\n      return \"arg-is\";\n    } else if (opChars.test(ch)) {\n      if (ch == \"$\") return \"operator dollar\";\n      stream.eatWhile(opChars);\n      return \"operator\";\n    } else if (/[\\(\\){}\\[\\];]/.test(ch)) {\n      curPunc = ch;\n      if (ch == \";\") return \"semi\";\n      return null;\n    } else {\n      return null;\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      if (stream.eat(\"\\\\\")) {\n        var ch = stream.next();\n        if (ch == \"x\") stream.match(/^[a-f0-9]{2}/i);\n        else if ((ch == \"u\" || ch == \"U\") && stream.eat(\"{\") && stream.skipTo(\"}\")) stream.next();\n        else if (ch == \"u\") stream.match(/^[a-f0-9]{4}/i);\n        else if (ch == \"U\") stream.match(/^[a-f0-9]{8}/i);\n        else if (/[0-7]/.test(ch)) stream.match(/^[0-7]{1,2}/);\n        return \"string-2\";\n      } else {\n        var next;\n        while ((next = stream.next()) != null) {\n          if (next == quote) { state.tokenize = tokenBase; break; }\n          if (next == \"\\\\\") { stream.backUp(1); break; }\n        }\n        return \"string\";\n      }\n    };\n  }\n\n  var ALIGN_YES = 1, ALIGN_NO = 2, BRACELESS = 4\n\n  function push(state, type, stream) {\n    state.ctx = {type: type,\n                 indent: state.indent,\n                 flags: 0,\n                 column: stream.column(),\n                 prev: state.ctx};\n  }\n  function setFlag(state, flag) {\n    var ctx = state.ctx\n    state.ctx = {type: ctx.type,\n                 indent: ctx.indent,\n                 flags: ctx.flags | flag,\n                 column: ctx.column,\n                 prev: ctx.prev}\n  }\n  function pop(state) {\n    state.indent = state.ctx.indent;\n    state.ctx = state.ctx.prev;\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: tokenBase,\n              ctx: {type: \"top\",\n                    indent: -config.indentUnit,\n                    flags: ALIGN_NO},\n              indent: 0,\n              afterIdent: false};\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if ((state.ctx.flags & 3) == 0) state.ctx.flags |= ALIGN_NO\n        if (state.ctx.flags & BRACELESS) pop(state)\n        state.indent = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (style != \"comment\" && (state.ctx.flags & ALIGN_NO) == 0) setFlag(state, ALIGN_YES)\n\n      if ((curPunc == \";\" || curPunc == \"{\" || curPunc == \"}\") && state.ctx.type == \"block\") pop(state);\n      if (curPunc == \"{\") push(state, \"}\", stream);\n      else if (curPunc == \"(\") {\n        push(state, \")\", stream);\n        if (state.afterIdent) state.ctx.argList = true;\n      }\n      else if (curPunc == \"[\") push(state, \"]\", stream);\n      else if (curPunc == \"block\") push(state, \"block\", stream);\n      else if (curPunc == state.ctx.type) pop(state);\n      else if (state.ctx.type == \"block\" && style != \"comment\") setFlag(state, BRACELESS)\n      state.afterIdent = style == \"variable\" || style == \"keyword\";\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), ctx = state.ctx,\n          closing = firstChar == ctx.type;\n      if (ctx.flags & BRACELESS) ctx = ctx.prev\n      if (ctx.type == \"block\") return ctx.indent + (firstChar == \"{\" ? 0 : config.indentUnit);\n      else if (ctx.flags & ALIGN_YES) return ctx.column + (closing ? 0 : 1);\n      else return ctx.indent + (closing ? 0 : config.indentUnit);\n    },\n\n    lineComment: \"#\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-rsrc\", \"r\");\n\n});\n"],"file":"r.js"}
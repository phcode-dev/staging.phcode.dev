{"version":3,"sources":["thirdparty/CodeMirror/mode/haxe/haxe.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","parserConfig","indentUnit","kw","type","style","A","B","C","operator","atom","attribute","keywords","if","while","else","do","try","return","break","continue","new","throw","var","inline","static","using","public","private","cast","import","macro","function","catch","untyped","callback","for","switch","case","default","in","never","trace","class","abstract","enum","interface","typedef","extends","implements","dynamic","true","false","null","isOperatorChar","content","chain","stream","state","f","tokenize","toUnescaped","end","escaped","next","ret","tp","cont","haxeTokenBase","ch","word","haxeTokenString","test","eat","eatWhile","match","reAllowed","haxeTokenComment","skipToEnd","current","known","propertyIsEnumerable","kwAllowed","quote","maybeEnd","atomicTypes","number","variable","string","regexp","HaxeLexical","indented","column","align","prev","info","this","inScope","varname","v","localVars","name","parseHaxe","cc","cx","marked","lexical","hasOwnProperty","combinator","length","pop","statement","lex","imported","typename","charAt","len","importedtypes","i","registerimport","importname","t","pass","arguments","push","apply","inList","list","register","context","globalVars","defaultVars","pushcontext","vars","popcontext","pushlex","result","poplex","expect","wanted","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","startState","basecolumn","defaulttypes","token","sol","indentation","eatSpace","indent","textAfter","firstChar","closing","electricChars","blockCommentStart","blockCommentEnd","lineComment","defineMIME","inString","peek","skipTo"],"mappings":"CAGA,SAAUA,KACc,iBAAXC,SAAwC,iBAAVC,OACvCF,IAAIG,QAAQ,yBACY,mBAAVC,QAAwBA,OAAOC,IAC7CD,OAAO,CAAC,wBAAyBJ,KAEjCA,IAAIM,YANR,CAOG,SAASA,YACZ,aAEAA,WAAWC,WAAW,OAAQ,SAASC,OAAQC,cAC7C,IAAIC,WAAaF,OAAOE,WAIxB,SAASC,GAAGC,MAAO,MAAO,CAACA,KAAMA,KAAMC,MAAO,WAC9C,IAAIC,EAAIH,GAAG,aAAcI,EAAIJ,GAAG,aAAcK,EAAIL,GAAG,aACjDM,SAAWN,GAAG,YAAaO,KAAO,CAACN,KAAM,OAAQC,MAAO,QAASM,UAAY,CAACP,KAAK,YAAaC,MAAO,aACvGD,KAAOD,GAAG,WACVS,SAAW,CACbC,GAAMP,EAAGQ,MAASR,EAAGS,KAAQR,EAAGS,GAAMT,EAAGU,IAAOV,EAChDW,OAAUV,EAAGW,MAASX,EAAGY,SAAYZ,EAAGa,IAAOb,EAAGc,MAASd,EAC3De,IAAOpB,GAAG,OAAQqB,OAASb,UAAWc,OAAUd,UAAWe,MAAQvB,GAAG,UACtEwB,OAAUhB,UAAWiB,QAAWjB,UAAWkB,KAAQ1B,GAAG,QAAS2B,OAAU3B,GAAG,UAAW4B,MAAS5B,GAAG,SACnG6B,SAAY7B,GAAG,YAAa8B,MAAS9B,GAAG,SAAU+B,QAAW/B,GAAG,WAAYgC,SAAYhC,GAAG,MAC3FiC,IAAOjC,GAAG,OAAQkC,OAAUlC,GAAG,UAAWmC,KAAQnC,GAAG,QAASoC,QAAWpC,GAAG,WAC5EqC,GAAM/B,SAAUgC,MAAStC,GAAG,mBAAoBuC,MAAQvC,GAAG,SAC3DwC,MAASvC,KAAMwC,SAAWxC,KAAMyC,KAAOzC,KAAM0C,UAAY1C,KAAM2C,QAAU3C,KAAM4C,QAAU5C,KAAM6C,WAAa7C,KAAM8C,QAAU9C,KAC5H+C,KAAQzC,KAAM0C,MAAS1C,KAAM2C,KAAQ3C,MAGnC4C,eAAiB,iBAkBjBlD,KAAMmD,QAhBV,SAASC,MAAMC,OAAQC,MAAOC,GAE5B,OADAD,MAAME,SAAWD,EACVA,EAAEF,OAAQC,OAGnB,SAASG,YAAYJ,OAAQK,KAE3B,IADA,IAAIC,SAAU,EAAOC,KACY,OAAzBA,KAAOP,OAAOO,SAAiB,CACrC,GAAIA,MAAQF,MAAQC,QAClB,OAAO,EACTA,SAAWA,SAAmB,MAARC,MAO1B,SAASC,IAAIC,GAAI7D,MAAO8D,MAEtB,OADA/D,KAAO8D,GAAIX,QAAUY,KACd9D,MAGT,SAAS+D,cAAcX,OAAQC,OAC7B,IAAIW,GAAKZ,OAAOO,OAoCVM,KAnCN,GAAU,KAAND,IAAmB,KAANA,GACf,OAAOb,MAAMC,OAAQC,MAAOa,gBAAgBF,KACvC,GAAI,qBAAqBG,KAAKH,IACnC,OAAOJ,IAAII,IACN,GAAU,KAANA,IAAaZ,OAAOgB,IAAI,MAEjC,OADAhB,OAAOiB,SAAS,YACTT,IAAI,SAAU,UAChB,GAAI,KAAKO,KAAKH,KAAa,KAANA,IAAaZ,OAAOgB,IAAI,MAElD,OADAhB,OAAOkB,MAAM,0CACNV,IAAI,SAAU,UAChB,GAAIP,MAAMkB,WAAoB,KAANP,IAAaZ,OAAOgB,IAAI,MAGrD,OAFAZ,YAAYJ,OAAQ,KACpBA,OAAOiB,SAAS,WACTT,IAAI,SAAU,YAChB,GAAU,KAANI,GACT,OAAIZ,OAAOgB,IAAI,KACNjB,MAAMC,OAAQC,MAAOmB,kBACnBpB,OAAOgB,IAAI,MACpBhB,OAAOqB,YACAb,IAAI,UAAW,aAEtBR,OAAOiB,SAASpB,gBACTW,IAAI,WAAY,KAAMR,OAAOsB,YAEjC,GAAU,KAANV,GAEP,OADAZ,OAAOqB,YACAb,IAAI,cAAe,QACvB,GAAU,KAANI,GAGT,OAFAZ,OAAOgB,IAAI,KACXhB,OAAOiB,SAAS,SACTT,IAAK,WAAY,QACnB,GAAIX,eAAekB,KAAKH,IAE7B,OADAZ,OAAOiB,SAASpB,gBACTW,IAAI,WAAY,KAAMR,OAAOsB,WAGpC,GAAG,QAAQP,KAAKH,IAGd,OAFAZ,OAAOiB,SAAS,WAETT,IAAI,OAAQ,aADnBK,KAAOb,OAAOsB,WAGdtB,OAAOiB,SAAS,SAChB,IAAIJ,KAAOb,OAAOsB,UAAWC,MAAQpE,SAASqE,qBAAqBX,OAAS1D,SAAS0D,MACrF,OAAQU,OAAStB,MAAMwB,UAAajB,IAAIe,MAAM5E,KAAM4E,MAAM3E,MAAOiE,MAClDL,IAAI,WAAY,WAAYK,MAKjD,SAASC,gBAAgBY,OACvB,OAAO,SAAS1B,OAAQC,OAGtB,OAFIG,YAAYJ,OAAQ0B,SACtBzB,MAAME,SAAWQ,eACZH,IAAI,SAAU,WAIzB,SAASY,iBAAiBpB,OAAQC,OAEhC,IADA,IAAI0B,UAAW,EAAOf,GACfA,GAAKZ,OAAOO,QAAQ,CACzB,GAAU,KAANK,IAAae,SAAU,CACzB1B,MAAME,SAAWQ,cACjB,MAEFgB,SAAkB,KAANf,GAEd,OAAOJ,IAAI,UAAW,WAKxB,IAAIoB,YAAc,CAAC3E,MAAQ,EAAM4E,QAAU,EAAMC,UAAY,EAAMC,QAAU,EAAMC,QAAU,GAE7F,SAASC,YAAYC,SAAUC,OAAQxF,KAAMyF,MAAOC,KAAMC,MACxDC,KAAKL,SAAWA,SAChBK,KAAKJ,OAASA,OACdI,KAAK5F,KAAOA,KACZ4F,KAAKF,KAAOA,KACZE,KAAKD,KAAOA,KACC,MAATF,QAAeG,KAAKH,MAAQA,OAGlC,SAASI,QAAQvC,MAAOwC,SACtB,IAAK,IAAIC,EAAIzC,MAAM0C,UAAWD,EAAGA,EAAIA,EAAEnC,KACrC,GAAImC,EAAEE,MAAQH,QAAS,OAAO,EAGlC,SAASI,UAAU5C,MAAOrD,MAAOD,KAAMmD,QAASE,QAC9C,IAAI8C,GAAK7C,MAAM6C,GAQf,IALAC,GAAG9C,MAAQA,MAAO8C,GAAG/C,OAASA,OAAQ+C,GAAGC,OAAS,KAAMD,GAAGD,GAAKA,GAE3D7C,MAAMgD,QAAQC,eAAe,WAChCjD,MAAMgD,QAAQb,OAAQ,KAEZ,CACV,IAAIe,WACJ,IADiBL,GAAGM,OAASN,GAAGO,MAAQC,WACzB3G,KAAMmD,SAAU,CAC7B,KAAMgD,GAAGM,QAAUN,GAAGA,GAAGM,OAAS,GAAGG,KACnCT,GAAGO,KAAHP,GACF,OAAIC,GAAGC,OAAeD,GAAGC,OACb,YAARrG,MAAsB6F,QAAQvC,MAAOH,SAAiB,aAC9C,YAARnD,MAAsB6G,SAASvD,MAAOH,SAAiB,aACpDlD,QAKb,SAAS4G,SAASvD,MAAOwD,UACvB,GAAI,QAAQ1C,KAAK0C,SAASC,OAAO,IAC/B,OAAO,EAET,IADA,IAAIC,IAAM1D,MAAM2D,cAAcR,OACrBS,EAAI,EAAGA,EAAEF,IAAKE,IACrB,GAAG5D,MAAM2D,cAAcC,IAAIJ,SAAU,OAAO,EAGhD,SAASK,eAAeC,YAEtB,IADA,IAAI9D,MAAQ8C,GAAG9C,MACN+D,EAAI/D,MAAM2D,cAAeI,EAAGA,EAAIA,EAAEzD,KACzC,GAAGyD,EAAEpB,MAAQmB,WAAY,OAC3B9D,MAAM2D,cAAgB,CAAEhB,KAAMmB,WAAYxD,KAAMN,MAAM2D,eAIxD,IAAIb,GAAK,CAAC9C,MAAO,KAAMkC,OAAQ,KAAMa,OAAQ,KAAMF,GAAI,MACvD,SAASmB,OACP,IAAK,IAAIJ,EAAIK,UAAUd,OAAS,EAAGS,GAAK,EAAGA,IAAKd,GAAGD,GAAGqB,KAAKD,UAAUL,IAEvE,SAASnD,OAEP,OADAuD,KAAKG,MAAM,KAAMF,YACV,EAET,SAASG,OAAOzB,KAAM0B,MACpB,IAAK,IAAI5B,EAAI4B,KAAM5B,EAAGA,EAAIA,EAAEnC,KAC1B,GAAImC,EAAEE,MAAQA,KAAM,OAAO,EAC7B,OAAO,EAET,SAAS2B,SAAS9B,SAChB,IAAIxC,MAAQ8C,GAAG9C,MACf,GAAIA,MAAMuE,QAAS,CAEjB,GADAzB,GAAGC,OAAS,MACRqB,OAAO5B,QAASxC,MAAM0C,WAAY,OACtC1C,MAAM0C,UAAY,CAACC,KAAMH,QAASlC,KAAMN,MAAM0C,gBACzC,GAAI1C,MAAMwE,WAAY,CAC3B,GAAIJ,OAAO5B,QAASxC,MAAMwE,YAAa,OACvCxE,MAAMwE,WAAa,CAAC7B,KAAMH,QAASlC,KAAMN,MAAMwE,aAMnD,IAAIC,YAAc,CAAC9B,KAAM,OAAQrC,KAAM,MACvC,SAASoE,cACF5B,GAAG9C,MAAMuE,UAASzB,GAAG9C,MAAM0C,UAAY+B,aAC5C3B,GAAG9C,MAAMuE,QAAU,CAACnC,KAAMU,GAAG9C,MAAMuE,QAASI,KAAM7B,GAAG9C,MAAM0C,WAE7D,SAASkC,aACP9B,GAAG9C,MAAM0C,UAAYI,GAAG9C,MAAMuE,QAAQI,KACtC7B,GAAG9C,MAAMuE,QAAUzB,GAAG9C,MAAMuE,QAAQnC,KAGtC,SAASyC,QAAQnI,KAAM2F,MACrB,IAAIyC,OAAS,WACX,IAAI9E,MAAQ8C,GAAG9C,MACfA,MAAMgD,QAAU,IAAIhB,YAAYhC,MAAMiC,SAAUa,GAAG/C,OAAOmC,SAAUxF,KAAM,KAAMsD,MAAMgD,QAASX,OAGjG,OADAyC,OAAOxB,KAAM,EACNwB,OAET,SAASC,SACP,IAAI/E,MAAQ8C,GAAG9C,MACXA,MAAMgD,QAAQZ,OACU,KAAtBpC,MAAMgD,QAAQtG,OAChBsD,MAAMiC,SAAWjC,MAAMgD,QAAQf,UACjCjC,MAAMgD,QAAUhD,MAAMgD,QAAQZ,MAKlC,SAAS4C,OAAOC,QACd,SAAShF,EAAEvD,MACT,OAAIA,MAAQuI,OAAexE,OACR,KAAVwE,OAAsBjB,OACnBvD,KAAKR,GAEnB,OAAOA,EAGT,SAASoD,UAAU3G,MACjB,MAAY,KAARA,KAAoB+D,KAAKyE,SACjB,OAARxI,KAAsB+D,KAAKoE,QAAQ,UAAWM,QAASH,OAAO,KAAMD,QAC5D,aAARrI,KAA4B+D,KAAKoE,QAAQ,QAASO,WAAY/B,UAAW0B,QACjE,aAARrI,KAA4B+D,KAAKoE,QAAQ,QAASxB,UAAW0B,QACrD,KAARrI,KAAoB+D,KAAKoE,QAAQ,KAAMH,YAAaW,MAAON,OAAQH,YAC3D,KAARlI,KAAoB+D,OACZ,aAAR/D,KAA4B+D,KAAK6E,gBACzB,YAAR5I,KAA2B+D,KAAK8E,aACxB,OAAR7I,KAAsB+D,KAAKoE,QAAQ,QAASG,OAAO,KAAMH,QAAQ,KAAMW,SAAUR,OAAO,KAC7DD,OAAQ1B,UAAW0B,QACtC,YAARrI,KAA2B+D,KAAKoE,QAAQ,QAASY,YACzC,UAAR/I,KAAyB+D,KAAKoE,QAAQ,QAASO,WAAYP,QAAQ,IAAK,UAAWG,OAAO,KAC5DK,MAAON,OAAQA,QACrC,QAARrI,KAAuB+D,KAAK2E,WAAYJ,OAAO,MACvC,WAARtI,KAA0B+D,KAAKuE,OAAO,MAC9B,SAARtI,KAAwB+D,KAAKoE,QAAQ,QAASH,YAAaM,OAAO,KAAMU,OAAQV,OAAO,KAC1D3B,UAAW0B,OAAQH,YACxC,UAARlI,KAAyB+D,KAAKkF,UAAWX,OAAO,MACxC,WAARtI,KAA0B+D,KAAKpB,SAC5B2E,KAAKa,QAAQ,QAASO,WAAYJ,OAAO,KAAMD,QAExD,SAASK,WAAW1I,MAClB,OAAIiF,YAAYsB,eAAevG,MAAc+D,KAAKmF,eACtC,QAARlJ,KAAwB+D,KAAKmF,eACrB,YAARlJ,KAA2B+D,KAAK8E,aACxB,aAAR7I,KAA4B+D,KAAKoF,iBACzB,KAARnJ,KAAoB+D,KAAKoE,QAAQ,KAAMgB,gBAAiBb,OAAO,KAAMD,OAAQa,eACrE,YAARlJ,KAA2B+D,KAAK2E,YACxB,KAAR1I,KAAoB+D,KAAKoE,QAAQ,KAAMiB,SAASD,gBAAiB,KAAMd,OAAQa,eACvE,KAARlJ,KAAoB+D,KAAKoE,QAAQ,KAAMiB,SAASC,QAAS,KAAMhB,OAAQa,eACpEnF,OAET,SAASoF,gBAAgBnJ,MACvB,OAAIA,KAAKuE,MAAM,cAAsB+C,OAC9BA,KAAKoB,YAGd,SAASQ,cAAclJ,KAAMsJ,OAC3B,MAAY,YAARtJ,MAAsB,UAAUoE,KAAKkF,OAAevF,KAAKmF,eACjD,YAARlJ,MAA8B,KAARA,KAAoB+D,KAAK2E,YACvC,KAAR1I,KACQ,KAARA,KAAoB+D,KAAKoE,QAAQ,KAAMiB,SAASV,WAAY,KAAML,OAAQa,eAClE,KAARlJ,KAAoB+D,KAAKwF,SAAUL,eAC3B,KAARlJ,KAAoB+D,KAAKoE,QAAQ,KAAMO,WAAYJ,OAAO,KAAMD,OAAQa,oBAA5E,OAHA,EAMF,SAASN,eAAe5I,MACtB,MAAY,aAARA,KAA4B+D,KAAK6E,gBACzB,YAAR5I,KAA2B+D,KAAK8E,aACxB,OAAR7I,KAAsB+D,KAAK0E,cAA/B,EAGF,SAASD,QAAQxI,MACf,MAAW,KAARA,KAAoB+D,KAAKyE,SACjB,YAARxI,KAA2B+D,KAAKyE,SACxB,KAARxI,KAAoB+D,KAAKoE,QAAQ,KAAMiB,SAASI,SAAU,KAAMnB,OAAQ1B,gBAA3E,EAEF,SAAS6C,SAASxJ,MAChB,GAAW,YAARA,KAAoB,OAAO+D,OAGhC,SAASkF,UAAWjJ,KAAMsJ,OACxB,MAAW,YAARtJ,MAAsB,QAAQoE,KAAKkF,MAAMvC,OAAO,KAAOI,eAAemC,OAAevF,QACxE,YAAR/D,MAA8B,YAARA,MAA8B,KAARA,MAAwB,KAATsJ,MAAqBvF,KAAKkF,gBAAxF,EAGP,SAAStG,QAAS3C,KAAMsJ,OAEtB,MAAW,YAARtJ,MAAsB,QAAQoE,KAAKkF,MAAMvC,OAAO,KAAOI,eAAemC,OAAevF,QACvE,QAAR/D,MAAkB,QAAQoE,KAAKkF,MAAMvC,OAAO,IAAchD,YAA9D,EAGP,SAASgF,WAAW/I,MAClB,MAAY,KAARA,KAAoB+D,KAAKsE,OAAQ1B,WAC9BW,KAAK4B,cAAeZ,OAAO,KAAMD,QAE1C,SAASkB,SAASvJ,MAChB,GAAY,YAARA,KAA6C,OAAxBoG,GAAGC,OAAS,WAAmBtC,OAE1D,SAASsF,QAAQrJ,MAEf,GADY,YAARA,OAAoBoG,GAAGC,OAAS,YAChCpB,YAAYsB,eAAevG,MAAO,OAAO+D,KAAKuE,OAAO,KAAMI,YAEjE,SAASU,SAASK,KAAM/F,KACtB,SAASgG,QAAQ1J,MACf,MAAY,KAARA,KAAoB+D,KAAK0F,KAAMC,SAC/B1J,MAAQ0D,IAAYK,OACjBA,KAAKuE,OAAO5E,MAErB,OAAO,SAAS1D,MACd,OAAIA,MAAQ0D,IAAYK,OACZuD,KAAKmC,KAAMC,UAG3B,SAASf,MAAM3I,MACb,MAAY,KAARA,KAAoB+D,OACjBuD,KAAKX,UAAWgC,OAEzB,SAASF,QAAQzI,KAAMsJ,OACrB,MAAY,YAARtJ,MAAoB4H,SAAS0B,OAAevF,KAAK4F,QAASC,UACvD7F,OAET,SAAS6F,QAAQ5J,KAAMsJ,OACrB,MAAa,KAATA,MAAqBvF,KAAK2E,WAAYkB,SAC9B,KAAR5J,KAAoB+D,KAAK0E,cAA7B,EAEF,SAASK,SAAS9I,KAAMsJ,OACtB,MAAY,YAARtJ,MACF4H,SAAS0B,OACFvF,KAAK8F,MAAOnB,aAEZpB,OAGX,SAASuC,MAAMC,MAAOR,OACpB,GAAa,MAATA,MAAe,OAAOvF,OAE5B,SAAS8E,YAAY7I,KAAMsJ,OAEzB,MAAY,YAARtJ,MAA8B,QAARA,MAAiB4H,SAAS0B,OAAevF,KAAK8E,cAC3D,OAATS,MAAuBvF,KAAK8E,aACpB,KAAR7I,KAAoB+D,KAAKoE,QAAQ,KAAMH,YAAaoB,SAASJ,OAAQ,KAAMX,OAAQsB,QAAShD,UAAWuB,iBAA3G,EAEF,SAASyB,QAAQ3J,MACf,GAAW,KAARA,KAAa,OAAO+D,KAAKgG,YAE9B,SAASA,WAAW/J,MAClB,MAAW,QAARA,KAAuB+D,OACf,YAAR/D,KAA2B+D,OACnB,KAAR/D,KAAoB+D,KAAKoE,QAAQ,KAAMiB,SAASY,SAAU,KAAM3B,aAAnE,EAEF,SAAS2B,SAAShK,MAChB,GAAW,YAARA,KAAoB,OAAO+D,KAAK4F,SAErC,SAASX,OAAOhJ,KAAMsJ,OACpB,GAAY,YAARtJ,KAAsC,OAAjB4H,SAAS0B,OAAevF,KAAK4F,SAIxD,OAxKAzB,WAAWtB,KAAM,EAiBjByB,OAAOzB,KAAM,EAuJN,CACLqD,WAAY,SAASC,YACnB,IAAIC,aAAe,CAAC,MAAO,QAAS,SAAU,OAAQ,MAAO,OAAQ,UAAW,SAC5E7G,MAAQ,CACVE,SAAUQ,cACVQ,WAAW,EACXM,WAAW,EACXqB,GAAI,GACJG,QAAS,IAAIhB,aAAa4E,YAAc,GAAKpK,WAAY,EAAG,SAAS,GACrEkG,UAAWnG,aAAamG,UACxBiB,cAAekD,aACftC,QAAShI,aAAamG,WAAa,CAACiC,KAAMpI,aAAamG,WACvDT,SAAU,GAIZ,OAFI1F,aAAaiI,YAAgD,iBAA3BjI,aAAaiI,aACjDxE,MAAMwE,WAAajI,aAAaiI,YAC3BxE,OAGT8G,MAAO,SAAS/G,OAAQC,OAMtB,GALID,OAAOgH,QACJ/G,MAAMgD,QAAQC,eAAe,WAChCjD,MAAMgD,QAAQb,OAAQ,GACxBnC,MAAMiC,SAAWlC,OAAOiH,eAEtBjH,OAAOkH,WAAY,OAAO,KAC9B,IAAItK,MAAQqD,MAAME,SAASH,OAAQC,OACnC,MAAY,WAARtD,KAA0BC,OAC9BqD,MAAMkB,YAAuB,YAARxE,MAA8B,aAARA,OAAuBA,KAAKuE,MAAM,kBAC7EjB,MAAMwB,UAAoB,KAAR9E,KACXkG,UAAU5C,MAAOrD,MAAOD,KAAMmD,QAASE,UAGhDmH,OAAQ,SAASlH,MAAOmH,WACtB,GAAInH,MAAME,UAAYQ,cAAe,OAAO,EAC5C,IAAI0G,UAAYD,WAAaA,UAAU1D,OAAO,GAAIT,QAAUhD,MAAMgD,QAC9C,QAAhBA,QAAQtG,MAA+B,KAAb0K,YAAkBpE,QAAUA,QAAQZ,MAClE,IAAI1F,KAAOsG,QAAQtG,KAAM2K,QAAUD,WAAa1K,KAChD,MAAY,UAARA,KAAyBsG,QAAQf,SAAW,EAC/B,QAARvF,MAA+B,KAAb0K,UAAyBpE,QAAQf,SAC3C,QAARvF,MAA0B,QAARA,KAAuBsG,QAAQf,SAAWzF,WAC5C,UAAhBwG,QAAQX,MAAqBgF,QAE7BrE,QAAQb,MAAca,QAAQd,QAAUmF,QAAU,EAAI,GACnDrE,QAAQf,UAAYoF,QAAU,EAAI7K,YAFrCwG,QAAQf,UAAY,sBAAsBnB,KAAKqG,WAAa3K,WAAa,EAAIA,aAKxF8K,cAAe,KACfC,kBAAmB,KACnBC,gBAAiB,KACjBC,YAAa,QAIjBrL,WAAWsL,WAAW,cAAe,QAErCtL,WAAWC,WAAW,OAAQ,WAE5B,MAAO,CACLsK,WAAY,WACV,MAAO,CACLzK,QAAQ,EACRyL,UAAU,IAGdb,MAAO,SAAU/G,OAAQC,OACvB,IAAIW,GAAKZ,OAAO6H,OACZb,IAAMhH,OAAOgH,MAGjB,GAAU,KAANpG,GAEF,OADAZ,OAAOqB,YACA,UAET,GAAI2F,KAAa,KAANpG,GAAW,CACpB,IAAIhE,MAAQ,aAgBZ,OAdAoD,OAAOgB,IAAI,KAEU,KAAjBhB,OAAO6H,SACT7H,OAAOgB,IAAI,KACXpE,MAAQ,aAGW,KAAjBoD,OAAO6H,SACT7H,OAAOgB,IAAI,OACXpE,MAAQ,YACRqD,MAAM9D,QAAS,GAGjB6D,OAAOiB,SAAS,UACTrE,MAGT,IAAIgE,GAAKZ,OAAO6H,OAOhB,OALsB,GAAlB5H,MAAM2H,UAA2B,KAANhH,KAC7BX,MAAM2H,UAAW,EACjB5H,OAAOO,QAGa,GAAlBN,MAAM2H,UACJ5H,OAAO8H,OAAO,MAGhB9H,OAAOqB,YAGY,KAAjBrB,OAAO6H,SACT7H,OAAOO,OACPN,MAAM2H,UAAW,GAGZ,WAGT5H,OAAOO,OACA,OAETmH,YAAa,OAIjBrL,WAAWsL,WAAW,cAAe","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"haxe\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n\n  // Tokenizer\n\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n  var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\n  var type = kw(\"typedef\");\n  var keywords = {\n    \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n    \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n    \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n    \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n    \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n    \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n    \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n    \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n    \"true\": atom, \"false\": atom, \"null\": atom\n  };\n\n  var isOperatorChar = /[+\\-*&%=<>!?|]/;\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  function toUnescaped(stream, end) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (next == end && !escaped)\n        return true;\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n\n  function haxeTokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      return chain(stream, state, haxeTokenString(ch));\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n      stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n      toUnescaped(stream, \"/\");\n      stream.eatWhile(/[gimsu]/);\n      return ret(\"regexp\", \"string-2\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        return chain(stream, state, haxeTokenComment);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      }\n    } else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"conditional\", \"meta\");\n    } else if (ch == \"@\") {\n      stream.eat(/:/);\n      stream.eatWhile(/[\\w_]/);\n      return ret (\"metadata\", \"meta\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    } else {\n      var word;\n      if(/[A-Z]/.test(ch)) {\n        stream.eatWhile(/[\\w_<>]/);\n        word = stream.current();\n        return ret(\"type\", \"variable-3\", word);\n      } else {\n        stream.eatWhile(/[\\w_]/);\n        var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n        return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n                       ret(\"variable\", \"variable\", word);\n      }\n    }\n  }\n\n  function haxeTokenString(quote) {\n    return function(stream, state) {\n      if (toUnescaped(stream, quote))\n        state.tokenize = haxeTokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function haxeTokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = haxeTokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\n  function HaxeLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n  }\n\n  function parseHaxe(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        if (type == \"variable\" && imported(state, content)) return \"variable-3\";\n        return style;\n      }\n    }\n  }\n\n  function imported(state, typename) {\n    if (/[a-z]/.test(typename.charAt(0)))\n      return false;\n    var len = state.importedtypes.length;\n    for (var i = 0; i<len; i++)\n      if(state.importedtypes[i]==typename) return true;\n  }\n\n  function registerimport(importname) {\n    var state = cx.state;\n    for (var t = state.importedtypes; t; t = t.next)\n      if(t.name == importname) return;\n    state.importedtypes = { name: importname, next: state.importedtypes };\n  }\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next)\n      if (v.name == name) return true;\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      if (inList(varname, state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else if (state.globalVars) {\n      if (inList(varname, state.globalVars)) return;\n      state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: null};\n  function pushcontext() {\n    if (!cx.state.context) cx.state.localVars = defaultVars;\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  popcontext.lex = true;\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state;\n      state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function f(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(f);\n    }\n    return f;\n  }\n\n  function statement(type) {\n    if (type == \"@\") return cont(metadef);\n    if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"attribute\") return cont(maybeattribute);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                   poplex, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"import\") return cont(importdef, expect(\";\"));\n    if (type == \"typedef\") return cont(typedef);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n    if (type == \"type\" ) return cont(maybeoperator);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"keyword c\") return cont(maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n    if (type == \"operator\") return cont(expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperator(type, value) {\n    if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n    if (type == \"operator\" || type == \":\") return cont(expression);\n    if (type == \";\") return;\n    if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n    if (type == \".\") return cont(property, maybeoperator);\n    if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n  }\n\n  function maybeattribute(type) {\n    if (type == \"attribute\") return cont(maybeattribute);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"var\") return cont(vardef1);\n  }\n\n  function metadef(type) {\n    if(type == \":\") return cont(metadef);\n    if(type == \"variable\") return cont(metadef);\n    if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n  }\n  function metaargs(type) {\n    if(type == \"variable\") return cont();\n  }\n\n  function importdef (type, value) {\n    if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n    else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n  }\n\n  function typedef (type, value)\n  {\n    if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n    else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n  }\n\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperator, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type) {\n    if (type == \"variable\") cx.marked = \"property\";\n    if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") return cont(what, proceed);\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      else return pass(what, proceed);\n    };\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function vardef1(type, value) {\n    if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n    return cont();\n  }\n  function vardef2(type, value) {\n    if (value == \"=\") return cont(expression, vardef2);\n    if (type == \",\") return cont(vardef1);\n  }\n  function forspec1(type, value) {\n    if (type == \"variable\") {\n      register(value);\n      return cont(forin, expression)\n    } else {\n      return pass()\n    }\n  }\n  function forin(_type, value) {\n    if (value == \"in\") return cont();\n  }\n  function functiondef(type, value) {\n    //function names starting with upper-case letters are recognised as types, so cludging them together here.\n    if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n    if (value == \"new\") return cont(functiondef);\n    if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n  }\n  function typeuse(type) {\n    if(type == \":\") return cont(typestring);\n  }\n  function typestring(type) {\n    if(type == \"type\") return cont();\n    if(type == \"variable\") return cont();\n    if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n  }\n  function typeprop(type) {\n    if(type == \"variable\") return cont(typeuse);\n  }\n  function funarg(type, value) {\n    if (type == \"variable\") {register(value); return cont(typeuse);}\n  }\n\n  // Interface\n  return {\n    startState: function(basecolumn) {\n      var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n      var state = {\n        tokenize: haxeTokenBase,\n        reAllowed: true,\n        kwAllowed: true,\n        cc: [],\n        lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        importedtypes: defaulttypes,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n      state.kwAllowed = type != '.';\n      return parseHaxe(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != haxeTokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n      if (type == \"vardef\") return lexical.indented + 4;\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;\n      else if (lexical.info == \"switch\" && !closing)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: \"{}\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-haxe\", \"haxe\");\n\nCodeMirror.defineMode(\"hxml\", function () {\n\n  return {\n    startState: function () {\n      return {\n        define: false,\n        inString: false\n      };\n    },\n    token: function (stream, state) {\n      var ch = stream.peek();\n      var sol = stream.sol();\n\n      ///* comments */\n      if (ch == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      if (sol && ch == \"-\") {\n        var style = \"variable-2\";\n\n        stream.eat(/-/);\n\n        if (stream.peek() == \"-\") {\n          stream.eat(/-/);\n          style = \"keyword a\";\n        }\n\n        if (stream.peek() == \"D\") {\n          stream.eat(/[D]/);\n          style = \"keyword c\";\n          state.define = true;\n        }\n\n        stream.eatWhile(/[A-Z]/i);\n        return style;\n      }\n\n      var ch = stream.peek();\n\n      if (state.inString == false && ch == \"'\") {\n        state.inString = true;\n        stream.next();\n      }\n\n      if (state.inString == true) {\n        if (stream.skipTo(\"'\")) {\n\n        } else {\n          stream.skipToEnd();\n        }\n\n        if (stream.peek() == \"'\") {\n          stream.next();\n          state.inString = false;\n        }\n\n        return \"string\";\n      }\n\n      stream.next();\n      return null;\n    },\n    lineComment: \"#\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-hxml\", \"hxml\");\n\n});\n"],"file":"haxe.js"}
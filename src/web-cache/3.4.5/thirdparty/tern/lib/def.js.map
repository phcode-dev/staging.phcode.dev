{"version":3,"sources":["thirdparty/tern/lib/def.js"],"names":["mod","exports","module","init","define","amd","tern","def","infer","hop","obj","prop","Object","prototype","hasOwnProperty","call","TypeParser","spec","start","base","forceNew","this","pos","unwrapType","type","self","args","extractProp","retval","rv","AVal","propagate","IsCallee","ANull","getProp","computedFunc","name","retType","generator","cArgs","realArgs","i","length","push","Fn","computedUnion","types","union","maxWeight","computedArray","inner","Arr","computedTuple","map","tp","computedObject","names","Obj","forEach","defProp","addType","addArgCallEffects","arg","addArgCallEffect","argNum","addEffect","_self","cx","topScope","parseType","fn","handler","replaceRet","oldCmp","computeRet","argNodes","handled","old","eat","str","charAt","indexOf","word","re","ch","test","error","Error","parseFnType","comp","top","computed","computeRetStart","colon","argname","slice","argType","retStart","computeRetSource","main","parseTypeMaybeProp","next","result","parseTypeInner","extendWithProp","propName","apply","gen","propType","path","localDefs","parsePath","proto","descendProps","getObjType","parsePoly","hasCtor","getInstance","getSymbol","Number","fname","customFunctions","fromWord","num","bool","match","value","instance","parseEffect","effect","m","p","origin","target","andRet","getCallee","getSelf","getArgs","callee","slf","as","customFunc","getFrom","getTo","from","to","forAllProps","val","local","DefProp","currentTopScope","scope","cached","paths","origPath","split","parts","getFunctionType","getType","hasProp","propVal","isEmpty","emptyObj","ctor","empty","create","props","isShell","isSimpleAnnotation","passOne","protos","charCodeAt","passTwo","effects","copyInfo","known","innerPath","doc","url","span","metaData","doLoadEnvironment","data","server","parent","addOrigin","curOrigin","origins","definitions","signal","load","oldScope","parse","registerFunction","f","IsCreated","constraint","construct","created","derived","cur","vtp","PropSpec","connect","IsBound","argNames","Math","min","makePromise","defs","ecmascript","arr","hasType","content","valProp","valArg","exec","reject","Promise_reject","PromiseResolvesTo","output","constructor","WG_PROMISE_KEEP_VALUE","ty","_val","_args"],"mappings":"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","sourcesContent":["// Type description parser\n//\n// Type description JSON files (such as ecmascript.json and browser.json)\n// are used to\n//\n// A) describe types that come from native code\n//\n// B) to cheaply load the types for big libraries, or libraries that\n//    can't be inferred well\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    return exports.init = mod;\n  if (typeof define == \"function\" && define.amd) // AMD\n    return define({init: mod});\n  tern.def = {init: mod};\n})(function(exports, infer) {\n  \"use strict\";\n\n  function hop(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  var TypeParser = exports.TypeParser = function(spec, start, base, forceNew) {\n    this.pos = start || 0;\n    this.spec = spec;\n    this.base = base;\n    this.forceNew = forceNew;\n  };\n\n  function unwrapType(type, self, args) {\n    return type.call ? type(self, args) : type;\n  }\n\n  function extractProp(type, prop) {\n    if (prop == \"!ret\") {\n      if (type.retval) return type.retval;\n      var rv = new infer.AVal;\n      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));\n      return rv;\n    } else {\n      return type.getProp(prop);\n    }\n  }\n\n  function computedFunc(name, args, retType, generator) {\n    return function(self, cArgs) {\n      var realArgs = [];\n      for (var i = 0; i < args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));\n      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs), generator);\n    };\n  }\n  function computedUnion(types) {\n    return function(self, args) {\n      var union = new infer.AVal;\n      for (var i = 0; i < types.length; i++) unwrapType(types[i], self, args).propagate(union);\n      union.maxWeight = 1e5;\n      return union;\n    };\n  }\n  function computedArray(inner) {\n    return function(self, args) {\n      return new infer.Arr(inner(self, args));\n    };\n  }\n  function computedTuple(types) {\n    return function(self, args) {\n      return new infer.Arr(types.map(function(tp) { return unwrapType(tp, self, args) }));\n    };\n  }\n  function computedObject(names, types) {\n    return function(self, args) {\n      var obj = new infer.Obj;\n      names.forEach(function (prop, i) {\n        obj.defProp(prop).addType(unwrapType(types[i], self, args));\n      });\n      return obj;\n    };\n  }\n\n  TypeParser.prototype = {\n    eat: function(str) {\n      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {\n        this.pos += str.length;\n        return true;\n      }\n    },\n    word: function(re) {\n      var word = \"\", ch, re = re || /[\\w$]/;\n      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) { word += ch; ++this.pos; }\n      return word;\n    },\n    error: function() {\n      throw new Error(\"Unrecognized type spec: \" + this.spec + \" (at \" + this.pos + \")\");\n    },\n    parseFnType: function(comp, name, top, generator) {\n      var args = [], names = [], computed = false;\n      if (!this.eat(\")\")) for (var i = 0; ; ++i) {\n        var colon = this.spec.indexOf(\": \", this.pos), argname;\n        if (colon != -1) {\n          argname = this.spec.slice(this.pos, colon);\n          if (/^(\\.\\.\\.)?[$\\w?]+$/.test(argname))\n            this.pos = colon + 2;\n          else\n            argname = null;\n        }\n        names.push(argname);\n        var argType = this.parseType(comp);\n        if (argType.call) computed = true;\n        args.push(argType);\n        if (!this.eat(\", \")) {\n          this.eat(\")\") || this.error();\n          break;\n        }\n      }\n      var retType, computeRet, computeRetStart, fn;\n      if (this.eat(\" -> \")) {\n        var retStart = this.pos;\n        retType = this.parseType(true);\n        if (retType.call && !computed) {\n          computeRet = retType;\n          retType = infer.ANull;\n          computeRetStart = retStart;\n        }\n      } else {\n        retType = infer.ANull;\n      }\n      if (computed) return computedFunc(name, args, retType, generator);\n\n      if (top && (fn = this.base))\n        infer.Fn.call(this.base, name, infer.ANull, args, names, retType, generator);\n      else\n        fn = new infer.Fn(name, infer.ANull, args, names, retType, generator);\n      if (computeRet) fn.computeRet = computeRet;\n      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);\n      return fn;\n    },\n    parseType: function(comp, name, top) {\n      var main = this.parseTypeMaybeProp(comp, name, top);\n      if (!this.eat(\"|\")) return main;\n      var types = [main], computed = main.call;\n      for (;;) {\n        var next = this.parseTypeMaybeProp(comp, name, top);\n        types.push(next);\n        if (next.call) computed = true;\n        if (!this.eat(\"|\")) break;\n      }\n      if (computed) return computedUnion(types);\n      var union = new infer.AVal;\n      for (var i = 0; i < types.length; i++) types[i].propagate(union);\n      union.maxWeight = 1e5;\n      return union;\n    },\n    parseTypeMaybeProp: function(comp, name, top) {\n      var result = this.parseTypeInner(comp, name, top);\n      while (comp && this.eat(\".\")) result = this.extendWithProp(result);\n      return result;\n    },\n    extendWithProp: function(base) {\n      var propName = this.word(/[\\w<>$!:]/) || this.error();\n      if (base.apply) return function(self, args) {\n        return extractProp(base(self, args), propName);\n      };\n      return extractProp(base, propName);\n    },\n    parseTypeInner: function(comp, name, top) {\n      var gen;\n      if (this.eat(\"fn(\") || (gen = this.eat(\"fn*(\"))) {\n        return this.parseFnType(comp, name, top, gen);\n      } else if (this.eat(\"[\")) {\n        var inner = this.parseType(comp), types, computed = inner.call;\n        while (this.eat(\", \")) {\n          if (!types) types = [inner];\n          var next = this.parseType(comp);\n          types.push(next);\n          computed = computed || next.call;\n        }\n        this.eat(\"]\") || this.error();\n        if (computed) return types ? computedTuple(types) : computedArray(inner);\n        if (top && this.base) {\n          infer.Arr.call(this.base, types || inner);\n          return this.base;\n        }\n        return new infer.Arr(types || inner);\n      } else if (this.eat(\"{\")) {\n        var types = [], names = [], computed = false;\n        if (!this.eat(\"}\")) {\n          for (var i = 0; ; ++i) {\n            var colon = this.spec.indexOf(\": \", this.pos), propName;\n            if (colon != -1) {\n              propName = this.spec.slice(this.pos, colon);\n              if (/^[$\\w?]+$/.test(propName))\n                this.pos = colon + 2;\n              else\n                propName = null;\n            }\n            var propType = this.parseType(comp);\n            if (propType.call) computed = true;\n            names.push(propName);\n            types.push(propType);\n            if (!this.eat(\", \")) {\n              this.eat(\"}\") || this.error();\n              break;\n            }\n          }\n        }\n        if (computed) return computedObject(names, types);\n        var obj = new infer.Obj;\n        names.forEach(function (prop, i) {\n          obj.defProp(prop).addType(types[i]);\n        });\n        return obj;\n      } else if (this.eat(\"+\")) {\n        var path = this.word(/[\\w$<>\\.:!]/);\n        var base = infer.cx().localDefs[path + \".prototype\"];\n        if (!base) {\n          var base = parsePath(path);\n          if (!(base instanceof infer.Obj)) return base;\n          var proto = descendProps(base, [\"prototype\"]);\n          if (proto && (proto = proto.getObjType()))\n            base = proto;\n        }\n        if (comp && this.eat(\"[\")) return this.parsePoly(base);\n        if (top && this.base) {\n          this.base.proto = base;\n          var name = base.hasCtor && base.hasCtor.name || base.name;\n          if (name) this.base.name = name;\n          return this.base;\n        }\n        if (top && this.forceNew) return new infer.Obj(base);\n        return infer.getInstance(base);\n      } else if (this.eat(\":\")) {\n        var name = this.word(/[\\w$\\.]/);\n        return infer.getSymbol(name);\n      } else if (comp && this.eat(\"!\")) {\n        var arg = this.word(/\\d/);\n        if (arg) {\n          arg = Number(arg);\n          return function(_self, args) {return args[arg] || infer.ANull;};\n        } else if (this.eat(\"this\")) {\n          return function(self) {return self;};\n        } else if (this.eat(\"custom:\")) {\n          var fname = this.word(/[\\w$]/);\n          return customFunctions[fname] || function() { return infer.ANull; };\n        } else {\n          return this.fromWord(\"!\" + this.word(/[\\w$<>\\.!:]/));\n        }\n      } else if (this.eat(\"?\")) {\n        return infer.ANull;\n      } else {\n        return this.fromWord(this.word(/[\\w$<>\\.!:`]/));\n      }\n    },\n    fromWord: function(spec) {\n      var cx = infer.cx();\n      switch (spec) {\n      case \"number\": return cx.num;\n      case \"string\": return cx.str;\n      case \"bool\": return cx.bool;\n      case \"<top>\": return cx.topScope;\n      }\n      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];\n      return parsePath(spec);\n    },\n    parsePoly: function(base) {\n      var propName = \"<i>\", match;\n      if (match = this.spec.slice(this.pos).match(/^\\s*([\\w$:]+)\\s*=\\s*/)) {\n        propName = match[1];\n        this.pos += match[0].length;\n      }\n      var value = this.parseType(true);\n      if (!this.eat(\"]\")) this.error();\n      if (value.call) return function(self, args) {\n        var instance = new infer.Obj(base);\n        value(self, args).propagate(instance.defProp(propName));\n        return instance;\n      };\n      var instance = new infer.Obj(base);\n      value.propagate(instance.defProp(propName));\n      return instance;\n    }\n  };\n\n  function addArgCallEffects(type) {\n    if (type instanceof infer.Fn && type.args) for (var i = 0; i < type.args.length; ++i) {\n      var arg = type.args[i];\n      if (arg instanceof infer.Fn && arg.args && arg.args.length) addArgCallEffect(type, i);\n    }\n  }\n\n  function addArgCallEffect(type, argNum) {\n    addEffect(type, function(_self, args) {\n      if (args[argNum]) args[argNum].propagate(\n        new infer.IsCallee(infer.cx().topScope, type.args[argNum].args, null, infer.ANull));\n    });\n  }\n\n  function parseType(spec, name, base, forceNew) {\n    var type = new TypeParser(spec, null, base, forceNew).parseType(false, name, true);\n    if (type instanceof infer.AVal) type.types.forEach(addArgCallEffects);\n    else addArgCallEffects(type);\n    return type;\n  }\n\n  function addEffect(fn, handler, replaceRet) {\n    var oldCmp = fn.computeRet, rv = fn.retval;\n    fn.computeRet = function(self, args, argNodes) {\n      var handled = handler(self, args, argNodes);\n      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;\n      return replaceRet ? handled : old;\n    };\n  }\n\n  var parseEffect = exports.parseEffect = function(effect, fn) {\n    var m;\n    if (effect.indexOf(\"propagate \") == 0) {\n      var p = new TypeParser(effect, 10);\n      var origin = p.parseType(true);\n      if (!p.eat(\" \")) p.error();\n      var target = p.parseType(true);\n      addEffect(fn, function(self, args) {\n        unwrapType(origin, self, args).propagate(unwrapType(target, self, args));\n      });\n    } else if (effect.indexOf(\"call \") == 0) {\n      var andRet = effect.indexOf(\"and return \", 5) == 5;\n      var p = new TypeParser(effect, andRet ? 16 : 5);\n      var getCallee = p.parseType(true), getSelf = null, getArgs = [];\n      if (p.eat(\" this=\")) getSelf = p.parseType(true);\n      while (p.eat(\" \")) getArgs.push(p.parseType(true));\n      addEffect(fn, function(self, args) {\n        var callee = unwrapType(getCallee, self, args);\n        var slf = getSelf ? unwrapType(getSelf, self, args) : infer.ANull, as = [];\n        for (var i = 0; i < getArgs.length; ++i) as.push(unwrapType(getArgs[i], self, args));\n        var result = andRet ? new infer.AVal : infer.ANull;\n        callee.propagate(new infer.IsCallee(slf, as, null, result));\n        return result;\n      }, andRet);\n    } else if (m = effect.match(/^custom (\\S+)\\s*(.*)/)) {\n      var customFunc = customFunctions[m[1]];\n      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);\n    } else if (effect.indexOf(\"copy \") == 0) {\n      var p = new TypeParser(effect, 5);\n      var getFrom = p.parseType(true);\n      p.eat(\" \");\n      var getTo = p.parseType(true);\n      addEffect(fn, function(self, args) {\n        var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);\n        from.forAllProps(function(prop, val, local) {\n          if (local && prop != \"<i>\")\n            to.propagate(new infer.DefProp(prop, val));\n        });\n      });\n    } else {\n      throw new Error(\"Unknown effect type: \" + effect);\n    }\n  };\n\n  var currentTopScope;\n\n  var parsePath = exports.parsePath = function(path, scope) {\n    var cx = infer.cx(), cached = cx.paths[path], origPath = path;\n    if (cached != null) return cached;\n    cx.paths[path] = infer.ANull;\n\n    var base = scope || currentTopScope || cx.topScope;\n\n    if (cx.localDefs) for (var name in cx.localDefs) {\n      if (path.indexOf(name) == 0) {\n        if (path == name) return cx.paths[path] = cx.localDefs[path];\n        if (path.charAt(name.length) == \".\") {\n          base = cx.localDefs[name];\n          path = path.slice(name.length + 1);\n          break;\n        }\n      }\n    }\n\n    var result = descendProps(base, path.split(\".\"));\n    // Uncomment this to get feedback on your poorly written .json files\n    // if (result == infer.ANull) console.error(\"bad path: \" + origPath + \" (\" + cx.curOrigin + \")\")\n    cx.paths[origPath] = result == infer.ANull ? null : result;\n    return result;\n  };\n\n  function descendProps(base, parts) {\n    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {\n      var prop = parts[i];\n      if (prop.charAt(0) == \"!\") {\n        if (prop == \"!proto\") {\n          base = (base instanceof infer.Obj && base.proto) || infer.ANull;\n        } else {\n          var fn = base.getFunctionType();\n          if (!fn) {\n            base = infer.ANull;\n          } else if (prop == \"!ret\") {\n            base = fn.retval && fn.retval.getType(false) || infer.ANull;\n          } else {\n            var arg = fn.args && fn.args[Number(prop.slice(1))];\n            base = (arg && arg.getType(false)) || infer.ANull;\n          }\n        }\n      } else if (base instanceof infer.Obj &&\n                 (prop == \"prototype\" && base instanceof infer.Fn || base.hasProp(prop))) {\n        var propVal = base.getProp(prop);\n        if (!propVal || propVal.isEmpty())\n          base = infer.ANull;\n        else\n          base = propVal.types[0];\n      } else {\n        base = infer.ANull;\n      }\n    }\n    return base;\n  }\n\n  function emptyObj(ctor) {\n    var empty = Object.create(ctor.prototype);\n    empty.props = Object.create(null);\n    empty.isShell = true;\n    return empty;\n  }\n\n  function isSimpleAnnotation(spec) {\n    if (!spec[\"!type\"] || /^(fn\\(|\\[|\\+)/.test(spec[\"!type\"])) return false;\n    for (var prop in spec)\n      if (prop != \"!type\" && prop != \"!doc\" && prop != \"!url\" && prop != \"!span\" && prop != \"!data\")\n        return false;\n    return true;\n  }\n\n  function passOne(base, spec, path) {\n    if (!base) {\n      var tp = spec[\"!type\"];\n      if (tp) {\n        if (/^fn\\(/.test(tp)) base = emptyObj(infer.Fn);\n        else if (tp.charAt(0) == \"[\") base = emptyObj(infer.Arr);\n        else if (tp.charAt(0) == \"+\") base = emptyObj(infer.Obj);\n        else throw new Error(\"Invalid !type spec: \" + tp);\n      } else if (spec[\"!stdProto\"]) {\n        base = infer.cx().protos[spec[\"!stdProto\"]];\n      } else {\n        base = emptyObj(infer.Obj);\n      }\n      base.name = path;\n    }\n\n    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {\n      var inner = spec[name];\n      if (typeof inner == \"string\" || isSimpleAnnotation(inner)) continue;\n      var prop = base.defProp(name);\n      passOne(prop.getObjType(), inner, path ? path + \".\" + name : name).propagate(prop);\n    }\n    return base;\n  }\n\n  function passTwo(base, spec, path) {\n    if (base.isShell) {\n      delete base.isShell;\n      var tp = spec[\"!type\"];\n      if (tp) {\n        parseType(tp, path, base);\n      } else {\n        var proto = spec[\"!proto\"] && parseType(spec[\"!proto\"]);\n        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);\n      }\n    }\n\n    var effects = spec[\"!effects\"];\n    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)\n      parseEffect(effects[i], base);\n    copyInfo(spec, base);\n\n    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {\n      var inner = spec[name], known = base.defProp(name), innerPath = path ? path + \".\" + name : name;\n      if (typeof inner == \"string\") {\n        if (known.isEmpty()) parseType(inner, innerPath).propagate(known);\n      } else {\n        if (!isSimpleAnnotation(inner))\n          passTwo(known.getObjType(), inner, innerPath);\n        else if (known.isEmpty())\n          parseType(inner[\"!type\"], innerPath, null, true).propagate(known);\n        else\n          continue;\n        if (inner[\"!doc\"]) known.doc = inner[\"!doc\"];\n        if (inner[\"!url\"]) known.url = inner[\"!url\"];\n        if (inner[\"!span\"]) known.span = inner[\"!span\"];\n      }\n    }\n    return base;\n  }\n\n  function copyInfo(spec, type) {\n    if (spec[\"!doc\"]) type.doc = spec[\"!doc\"];\n    if (spec[\"!url\"]) type.url = spec[\"!url\"];\n    if (spec[\"!span\"]) type.span = spec[\"!span\"];\n    if (spec[\"!data\"]) type.metaData = spec[\"!data\"];\n  }\n\n  function doLoadEnvironment(data, scope) {\n    var cx = infer.cx(), server = cx.parent;\n\n    infer.addOrigin(cx.curOrigin = data[\"!name\"] || \"env#\" + cx.origins.length);\n    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);\n\n    if (server) server.signal(\"preLoadDef\", data);\n\n    passOne(scope, data);\n\n    var def = data[\"!define\"];\n    if (def) {\n      for (var name in def) {\n        var spec = def[name];\n        cx.localDefs[name] = typeof spec == \"string\" ? parsePath(spec) : passOne(null, spec, name);\n      }\n      for (var name in def) {\n        var spec = def[name];\n        if (typeof spec != \"string\") passTwo(cx.localDefs[name], def[name], name);\n      }\n    }\n\n    passTwo(scope, data);\n\n    if (server) server.signal(\"postLoadDef\", data);\n\n    cx.curOrigin = cx.localDefs = null;\n  }\n\n  exports.load = function(data, scope) {\n    if (!scope) scope = infer.cx().topScope;\n    var oldScope = currentTopScope;\n    currentTopScope = scope;\n    try {\n      doLoadEnvironment(data, scope);\n    } finally {\n      currentTopScope = oldScope;\n    }\n  };\n\n  exports.parse = function(data, origin, path) {\n    var cx = infer.cx();\n    if (origin) {\n      cx.origin = origin;\n      cx.localDefs = cx.definitions[origin];\n    }\n\n    try {\n      if (typeof data == \"string\")\n        return parseType(data, path);\n      else\n        return passTwo(passOne(null, data, path), data, path);\n    } finally {\n      if (origin) cx.origin = cx.localDefs = null;\n    }\n  };\n\n  // Used to register custom logic for more involved effect or type\n  // computation.\n  var customFunctions = Object.create(null);\n  infer.registerFunction = function(name, f) { customFunctions[name] = f; };\n\n  var IsCreated = infer.constraint({\n    construct: function(created, target, spec) {\n      this.created = created;\n      this.target = target;\n      this.spec = spec;\n    },\n    addType: function(tp) {\n      if (tp instanceof infer.Obj && this.created++ < 5) {\n        var derived = new infer.Obj(tp), spec = this.spec;\n        if (spec instanceof infer.AVal) spec = spec.getObjType(false);\n        if (spec instanceof infer.Obj) for (var prop in spec.props) {\n          var cur = spec.props[prop].types[0];\n          var p = derived.defProp(prop);\n          if (cur && cur instanceof infer.Obj && cur.props.value) {\n            var vtp = cur.props.value.getType(false);\n            if (vtp) p.addType(vtp);\n          }\n        }\n        this.target.addType(derived);\n      }\n    }\n  });\n\n  infer.registerFunction(\"Object_create\", function(_self, args, argNodes) {\n    if (argNodes && argNodes.length && argNodes[0].type == \"Literal\" && argNodes[0].value == null)\n      return new infer.Obj();\n\n    var result = new infer.AVal;\n    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));\n    return result;\n  });\n\n  var PropSpec = infer.constraint({\n    construct: function(target) { this.target = target; },\n    addType: function(tp) {\n      if (!(tp instanceof infer.Obj)) return;\n      if (tp.hasProp(\"value\"))\n        tp.getProp(\"value\").propagate(this.target);\n      else if (tp.hasProp(\"get\"))\n        tp.getProp(\"get\").propagate(new infer.IsCallee(infer.ANull, [], null, this.target));\n    }\n  });\n\n  infer.registerFunction(\"Object_defineProperty\", function(_self, args, argNodes) {\n    if (argNodes && argNodes.length >= 3 && argNodes[1].type == \"Literal\" &&\n        typeof argNodes[1].value == \"string\") {\n      var obj = args[0], connect = new infer.AVal;\n      obj.propagate(new infer.DefProp(argNodes[1].value, connect, argNodes[1]));\n      args[2].propagate(new PropSpec(connect));\n    }\n    return infer.ANull;\n  });\n\n  infer.registerFunction(\"Object_defineProperties\", function(_self, args, argNodes) {\n    if (args.length >= 2) {\n      var obj = args[0];\n      args[1].forAllProps(function(prop, val, local) {\n        if (!local) return;\n        var connect = new infer.AVal;\n        obj.propagate(new infer.DefProp(prop, connect, argNodes && argNodes[1]));\n        val.propagate(new PropSpec(connect));\n      });\n    }\n    return infer.ANull;\n  });\n\n  var IsBound = infer.constraint({\n    construct: function(self, args, target) {\n      this.self = self; this.args = args; this.target = target;\n    },\n    addType: function(tp) {\n      if (!(tp instanceof infer.Fn)) return;\n      this.target.addType(new infer.Fn(tp.name, infer.ANull, tp.args.slice(this.args.length),\n                                       tp.argNames.slice(this.args.length), tp.retval, tp.generator));\n      this.self.propagate(tp.self);\n      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)\n        this.args[i].propagate(tp.args[i]);\n    }\n  });\n\n  infer.registerFunction(\"Function_bind\", function(self, args) {\n    if (!args.length) return infer.ANull;\n    var result = new infer.AVal;\n    self.propagate(new IsBound(args[0], args.slice(1), result));\n    return result;\n  });\n\n  infer.registerFunction(\"Array_ctor\", function(_self, args) {\n    var arr = new infer.Arr;\n    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {\n      var content = arr.getProp(\"<i>\");\n      for (var i = 0; i < args.length; ++i) args[i].propagate(content);\n    }\n    return arr;\n  });\n\n  function makePromise() {\n    var defs = infer.cx().definitions.ecmascript;\n    return defs && new infer.Obj(defs[\"Promise.prototype\"]);\n  }\n\n  infer.registerFunction(\"Promise_ctor\", function(_self, args, argNodes) {\n    var self = makePromise();\n    if (!self || args.length < 1) return infer.ANull;\n    var valProp = self.defProp(\":t\", argNodes && argNodes[0]);\n    var valArg = new infer.AVal;\n    valArg.propagate(valProp);\n    var exec = new infer.Fn(\"execute\", infer.ANull, [valArg], [\"value\"], infer.ANull);\n    var reject = infer.cx().definitions.ecmascript.Promise_reject;\n    args[0].propagate(new infer.IsCallee(infer.ANull, [exec, reject], null, infer.ANull));\n    return self;\n  });\n\n  // Definition for Promise.resolve()\n  // The behavior is different for Promise and non-Promise arguments, so we\n  // need a custom definition to handle the different cases properly.\n  infer.registerFunction(\"Promise_resolve\", function(_self, args, argNodes) {\n    var self = makePromise();\n    if (!self) return infer.ANull;\n    if (args.length) {\n      var valProp = self.defProp(\":t\", argNodes && argNodes[0]);\n      var valArg = new infer.AVal;\n      valArg.propagate(valProp);\n      args[0].propagate(new PromiseResolvesTo(valArg));\n    }\n    return self;\n  });\n\n  var PromiseResolvesTo = infer.constraint({\n    construct: function(output) { this.output = output; },\n    addType: function(tp) {\n      if (tp.constructor == infer.Obj && tp.name == \"Promise\" && tp.hasProp(\":t\"))\n        tp.getProp(\":t\").propagate(this.output);\n      else\n        tp.propagate(this.output);\n    }\n  });\n\n  var WG_PROMISE_KEEP_VALUE = 50;\n\n  infer.registerFunction(\"Promise_then\", function(self, args, argNodes) {\n    var fn = args.length && args[0].getFunctionType();\n    var defs = infer.cx().definitions.ecmascript;\n    if (!fn || !defs) return self;\n\n    var result = new infer.Obj(defs[\"Promise.prototype\"]);\n    var value = result.defProp(\":t\", argNodes && argNodes[0]), ty;\n    if (fn.retval.isEmpty() && (ty = self.getType()) instanceof infer.Obj && ty.hasProp(\":t\"))\n      ty.getProp(\":t\").propagate(value, WG_PROMISE_KEEP_VALUE);\n    fn.retval.propagate(new PromiseResolvesTo(value));\n    return result;\n  });\n\n  infer.registerFunction(\"getOwnPropertySymbols\", function(_self, args) {\n    if (!args.length) return infer.ANull;\n    var result = new infer.AVal;\n    args[0].forAllProps(function(prop, _val, local) {\n      if (local && prop.charAt(0) == \":\") result.addType(infer.getSymbol(prop.slice(1)));\n    });\n    return result;\n  });\n\n  infer.registerFunction(\"getSymbol\", function(_self, _args, argNodes) {\n    if (argNodes && argNodes.length && argNodes[0].type == \"Literal\" && typeof argNodes[0].value == \"string\")\n      return infer.getSymbol(argNodes[0].value);\n    else\n      return infer.ANull;\n  });\n\n  return exports;\n});\n"],"file":"def.js"}
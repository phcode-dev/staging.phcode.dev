{"version":3,"sources":["project/FileTreeViewModel.js"],"names":["define","require","exports","module","Immutable","_","EventDispatcher","FileUtils","EVENT_CHANGE","isFile","entry","undefined","get","FileTreeViewModel","this","_commit","bind","_filePathToObjectPath","treeData","path","parts","split","part","shift","result","node","push","_isFilePathVisible","_getOpenNodes","projectRootPath","openNodes","addNodesAtDepth","parent","depth","forEach","value","key","directoryPath","nodeList","_getChildDirectories","childDirectories","_setIn","objectPath","newValue","updateIn","oldValue","_moveMarker","markerName","oldPath","newPath","newTreeData","lastObjectPath","delete","length","set","_setDirectoryOpen","open","directory","getIn","needsLoading","alreadyOpen","_closeSubtree","children","keySeq","name","subdir","_mergeContentsIntoChildren","contents","keysSeen","withMutations","match","matchIsFile","Map","currentEntries","toJS","deletedEntries","difference","_createNotFullyLoadedDirectory","merge","notFullyLoaded","_createIntermediateDirectories","treePointer","_openPath","setOpen","pop","_createPlaceholder","basedir","isFolder","options","parentPath","newObject","notInCreateMode","creating","newFile","doNotOpen","childrenPath","clone","_deleteAtPath","originalName","last","_addTimestamp","item","Date","getTime","_markAsChanged","changed","filePath","_addNewEntries","added","substr","getDirectoryPath","parentObjectPath","basename","getBaseName","makeEventDispatcher","prototype","sortDirectoriesFirst","_treeData","Object","defineProperty","_selectionViewInfo","width","scrollTop","scrollLeft","offsetTop","hasContext","hasSelection","_rootChanged","selectionViewInfo","trigger","isFilePathVisible","isPathLoaded","getOpenNodes","getChildDirectories","moveMarker","renameItem","oldObjectPath","newDirectoryPath","getParentPath","newObjectPath","newName","currentObject","setDirectoryOpen","_getObject","closeSubtree","subtreePath","setDirectoryContents","stripTrailingSlash","intermediate","openPath","createPlaceholder","deleteAtPath","processChanges","changes","removed","ensureDirectoryExists","pathWithoutSlash","targetPath","setSortDirectoriesFirst","setSelectionWidth","setSelectionScrollerInfo","scrollWidth"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: FileTreeViewModel*/\n\n/**\n * The view model (or a Store in the Flux terminology) used by the file tree.\n *\n * Many of the view model's methods are implemented by pure functions, which can be\n * helpful for composability. Many of the methods commit the new treeData and send a\n * change event when they're done whereas the functions do not do this.\n */\ndefine(function (require, exports, module) {\n\n\n    var Immutable           = require(\"thirdparty/immutable\"),\n        _                   = require(\"thirdparty/lodash\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        FileUtils           = require(\"file/FileUtils\");\n\n    // Constants\n    var EVENT_CHANGE = \"change\";\n\n    /**\n     * Determine if an entry from the treeData map is a file.\n     *\n     * @param {Immutable.Map} entry entry to test\n     * @return {boolean} true if this is a file and not a directory\n     */\n    function isFile(entry) {\n        return entry.get(\"children\") === undefined;\n    }\n\n    /**\n     * @constructor\n     *\n     * Contains the treeData used to generate the file tree and methods used to update that\n     * treeData.\n     *\n     * Instances dispatch the following events:\n     * - \"change\" (FileTreeViewModel.EVENT_CHANGE constant): Fired any time there's a change that should be reflected in the view.\n     */\n    function FileTreeViewModel() {\n        // For convenience in callbacks, make a bound version of this method so that we can\n        // just refer to it as this._commit when passing in a callback.\n        this._commit = this._commit.bind(this);\n    }\n    EventDispatcher.makeEventDispatcher(FileTreeViewModel.prototype);\n\n    /**\n     * @type {boolean}\n     *\n     * Preference for whether directories should all be sorted to the top of listings\n     */\n    FileTreeViewModel.prototype.sortDirectoriesFirst = false;\n\n    /**\n     * @type {Immutable.Map}\n     * @private\n     *\n     * The data for the tree. Some notes about its structure:\n     *\n     * * It starts with a Map for the project root's contents.\n     * * Each directory entry has a `children` key.\n     *     * `children` will be null if the directory has not been loaded\n     *     * An `open` key denotes whether the directory is open\n     * * Most file entries are just empty maps\n     *     * They can have flags like selected, context, rename, create with state information for the tree\n     */\n    FileTreeViewModel.prototype._treeData = Immutable.Map();\n\n    Object.defineProperty(FileTreeViewModel.prototype, \"treeData\", {\n        get: function () {\n            return this._treeData;\n        }\n    });\n\n    /**\n     * @private\n     * @type {Immutable.Map}\n     * Selection view information determines how the selection bar appears.\n     *\n     * * width: visible width of the selection area\n     * * scrollTop: current scroll position.\n     * * scrollLeft: current horizontal scroll position\n     * * offsetTop: top of the scroller element\n     * * hasSelection: is the selection bar visible?\n     * * hasContext: is the context bar visible?\n     */\n    FileTreeViewModel.prototype._selectionViewInfo = Immutable.Map({\n        width: 0,\n        scrollTop: 0,\n        scrollLeft: 0,\n        offsetTop: 0,\n        hasContext: false,\n        hasSelection: false\n    });\n\n    Object.defineProperty(FileTreeViewModel.prototype, \"selectionViewInfo\", {\n        get: function () {\n            return this._selectionViewInfo;\n        }\n    });\n\n    /**\n     * @private\n     *\n     * If the project root changes, we reset the tree data so that everything will be re-read.\n     */\n    FileTreeViewModel.prototype._rootChanged = function () {\n        this._treeData = Immutable.Map();\n    };\n\n    /**\n     * @private\n     *\n     * The FileTreeViewModel is like a database for storing the directory contents and its\n     * state moves atomically from one value to the next. This method stores the next version\n     * of the state, if it has changed, and triggers a change event so that the UI can update.\n     *\n     * @param {?Immutable.Map} treeData new treeData state\n     * @param {?Immutable.Map} selectionViewInfo updated information for the selection/context bars\n     */\n    FileTreeViewModel.prototype._commit = function (treeData, selectionViewInfo) {\n        var changed = false;\n        if (treeData && treeData !== this._treeData) {\n            this._treeData = treeData;\n            changed = true;\n        }\n\n        if (selectionViewInfo && selectionViewInfo !== this._selectionViewInfo) {\n            this._selectionViewInfo = selectionViewInfo;\n            changed = true;\n        }\n        if (changed) {\n            this.trigger(EVENT_CHANGE);\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Converts a project-relative file path into an object path array suitable for\n     * `Immutable.Map.getIn` and `Immutable.Map.updateIn`.\n     *\n     * The root path is \"\".\n     *\n     * @param {Immutable.Map} treeData\n     * @param {string} path project relative path to the file or directory. Can include trailing slash.\n     * @return {Array.<string>|null} Returns null if the path can't be found in the tree, otherwise an array of strings representing the path through the object.\n     */\n    function _filePathToObjectPath(treeData, path) {\n        if (path === null) {\n            return null;\n        } else if (path === \"\") {\n            return [];\n        }\n\n        var parts = path.split(\"/\"),\n            part = parts.shift(),\n            result = [],\n            node;\n\n        // Step through the parts of the path and the treeData object simultaneously\n        while (part) {\n            // We hit the end of the tree without finding our object, so return null\n            if (!treeData) {\n                return null;\n            }\n\n            node = treeData.get(part);\n\n            // The name represented by `part` isn't in the tree, so return null.\n            if (node === undefined) {\n                return null;\n            }\n\n            // We've verified this part, so store it.\n            result.push(part);\n\n            // Pull the next part of the path\n            part = parts.shift();\n\n            // If we haven't passed the end of the path string, then the object we've got in hand\n            // *should* be a directory. Confirm that and add `children` to the path to move down\n            // to the next directory level.\n            if (part) {\n                treeData = node.get(\"children\");\n                if (treeData) {\n                    result.push(\"children\");\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @private\n     *\n     * See `FileTreeViewModel.isFilePathVisible`\n     */\n    function _isFilePathVisible(treeData, path) {\n        if (path === null) {\n            return null;\n        } else if (path === \"\") {\n            return true;\n        }\n\n        var parts = path.split(\"/\"),\n            part = parts.shift(),\n            result = [],\n            node;\n\n        while (part) {\n            if (treeData === null) {\n                return false;\n            }\n            node = treeData.get(part);\n            if (node === undefined) {\n                return null;\n            }\n            result.push(part);\n            part = parts.shift();\n            if (part) {\n                if (!node.get(\"open\")) {\n                    return false;\n                }\n                treeData = node.get(\"children\");\n                if (treeData) {\n                    result.push(\"children\");\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Determines if a given file path is visible within the tree.\n     *\n     * For detailed documentation on how the loop works, see `_filePathToObjectPath` which\n     * follows the same pattern. This differs from that function in that this one checks for\n     * the open state of directories and has a different return value.\n     *\n     * @param {string} path project relative file path\n     * @return {boolean|null} true if the given path is currently visible in the tree, null if the given path is not present in the tree.\n     */\n    FileTreeViewModel.prototype.isFilePathVisible = function (path) {\n        return _isFilePathVisible(this._treeData, path);\n    };\n\n    /**\n     * Determines if a given path has been loaded.\n     *\n     * @param {string} path project relative file or directory path\n     * @return {boolean} true if the path has been loaded\n     */\n    FileTreeViewModel.prototype.isPathLoaded = function (path) {\n        var objectPath = _filePathToObjectPath(this._treeData, path);\n\n        if (!objectPath) {\n            return false;\n        }\n\n        // If it's a directory, make sure that its children are loaded\n        if (_.last(path) === \"/\") {\n            var directory = this._treeData.getIn(objectPath);\n            if (!directory.get(\"children\") || directory.get(\"notFullyLoaded\")) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * @private\n     *\n     * See `FileTreeViewModel.getOpenNodes`.\n     */\n    function _getOpenNodes(treeData, projectRootPath) {\n        var openNodes = [];\n\n        function addNodesAtDepth(treeData, parent, depth) {\n            if (!treeData) {\n                return;\n            }\n\n            treeData.forEach(function (value, key) {\n                if (isFile(value)) {\n                    return;\n                }\n\n                var directoryPath = parent + key + \"/\";\n\n                if (value.get(\"open\")) {\n                    var nodeList = openNodes[depth];\n                    if (!nodeList) {\n                        nodeList = openNodes[depth] = [];\n                    }\n                    nodeList.push(directoryPath);\n                    addNodesAtDepth(value.get(\"children\"), directoryPath, depth + 1);\n                }\n            });\n        }\n\n        // start at the top of the tree and the first array element\n        addNodesAtDepth(treeData, projectRootPath, 0);\n        return openNodes;\n    }\n\n    /**\n     * @private\n     * TODO: merge with _getOpenNodes?!\n     * See `FileTreeViewModel.getChildNodes`.\n     */\n    function _getChildDirectories(treeData, projectRootPath) {\n        var childDirectories = [];\n\n        function addNodesAtDepth(treeData, parent, depth) {\n            if (!treeData) {\n                return;\n            }\n\n            treeData.forEach(function (value, key) {\n                if (!isFile(value)) {\n                    var directoryPath = key + \"/\";\n\n                    childDirectories.push(directoryPath);\n                }\n            });\n        }\n\n        // start at the top of the tree and the first array element\n        addNodesAtDepth(treeData, projectRootPath, 0);\n        return childDirectories;\n    }\n\n    /**\n     * Creates an array of arrays where each entry of the top-level array has an array\n     * of paths that are at the same depth in the tree. All of the paths are full paths.\n     *\n     * This is used for saving the current set of open nodes to the preferences system\n     * for restoring on project open.\n     *\n     * @param {string} projectRootPath Full path to the project root\n     * @return {Array.<Array.<string>>} Array of array of full paths, organized by depth in the tree.\n     */\n    FileTreeViewModel.prototype.getOpenNodes = function (projectRootPath) {\n        return _getOpenNodes(this._treeData, projectRootPath);\n    };\n\n    FileTreeViewModel.prototype.getChildDirectories = function (parent) {\n        var treeData = this._treeData,\n            objectPath = _filePathToObjectPath(treeData, parent);\n\n        if (!objectPath) {\n            return;\n        }\n\n        var children;\n        if (objectPath.length === 0) {\n            // this is the root of the tree\n            children = this._treeData;\n        } else {\n            objectPath.push(\"children\");\n            children = this._treeData.getIn(objectPath);\n        }\n\n        return _getChildDirectories(children, parent);\n    };\n\n    /**\n     * @private\n     *\n     * The Immutable package does not have a `setIn` method, which is what this effectively\n     * provides. This is a simple function that does an `updateIn` on treeData, replacing\n     * the current value with the new one.\n     *\n     * @param {Immutable.Map} treeData\n     * @param {Array.<string>} objectPath path to object that should be replaced\n     * @param {Immutable.Map} newValue new value to provide at that path\n     * @return {Immutable.Map} updated treeData\n     */\n    function _setIn(treeData, objectPath, newValue) {\n        return treeData.updateIn(objectPath, function (oldValue) {\n            return newValue;\n        });\n    }\n\n    /**\n     * @private\n     *\n     * See `FileTreeViewModel.moveMarker`\n     */\n    function _moveMarker(treeData, markerName, oldPath, newPath) {\n        var objectPath;\n\n        if (newPath) {\n            objectPath = _filePathToObjectPath(treeData, newPath);\n        }\n\n        var newTreeData = treeData;\n\n        if (oldPath && oldPath !== newPath) {\n            var lastObjectPath = _filePathToObjectPath(treeData, oldPath);\n            if (lastObjectPath) {\n                newTreeData = newTreeData.updateIn(lastObjectPath, function (entry) {\n                    return entry.delete(markerName);\n                });\n            }\n        }\n\n        if (newPath && objectPath && objectPath.length !== 0) {\n            newTreeData = newTreeData.updateIn(objectPath, function (entry) {\n                return entry.set(markerName, true);\n            });\n        }\n\n        return newTreeData;\n    }\n\n    /**\n     * Moves a boolean marker flag from one file path to another.\n     *\n     * @param {string} markerName Name of the flag to set (for example, \"selected\")\n     * @param {string|null} oldPath Project relative file path with the location of the marker to move, or null if it's not being moved from elsewhere in the tree\n     * @param {string|null} newPath Project relative file path with where to place the marker, or null if the marker is being removed from the tree\n     */\n    FileTreeViewModel.prototype.moveMarker = function (markerName, oldPath, newPath) {\n        var newTreeData = _moveMarker(this._treeData, markerName, oldPath, newPath),\n            selectionViewInfo = this._selectionViewInfo;\n\n        if (markerName === \"selected\") {\n            selectionViewInfo = selectionViewInfo.set(\"hasSelection\", !!newPath);\n        } else if (markerName === \"context\") {\n            selectionViewInfo = selectionViewInfo.set(\"hasContext\", !!newPath);\n        }\n        this._commit(newTreeData, selectionViewInfo);\n    };\n\n    /**\n     * Changes the path of the item at the `currentPath` to `newPath`.\n     *\n     * @param {string} currentPath project relative file path to the current item\n     * @param {string} newPath project relative new path to give the item\n     */\n    FileTreeViewModel.prototype.renameItem = function (oldPath, newPath) {\n        var treeData = this._treeData,\n            oldObjectPath = _filePathToObjectPath(treeData, oldPath),\n            newDirectoryPath = FileUtils.getParentPath(newPath),\n            newObjectPath = _filePathToObjectPath(treeData, newDirectoryPath);\n\n        if (!oldObjectPath || !newObjectPath) {\n            return;\n        }\n\n        var originalName = _.last(oldObjectPath),\n            newName = FileUtils.getBaseName(newPath),\n            currentObject;\n\n        // Back up to the parent directory\n        oldObjectPath.pop();\n\n        // Remove the oldPath\n        treeData = treeData.updateIn(oldObjectPath, function (directory) {\n            currentObject = directory.get(originalName);\n            directory = directory.delete(originalName);\n            return directory;\n        });\n\n        // Add the newPath\n\n        // If the new directory is not loaded, create a not fully loaded directory there,\n        // so that we can add the new item as a child of new directory\n        if (!this.isPathLoaded(newDirectoryPath)) {\n            treeData = treeData.updateIn(newObjectPath, _createNotFullyLoadedDirectory);\n        }\n\n        // If item moved to root directory, objectPath should not have \"children\",\n        // otherwise the objectPath should have \"children\"\n        if (newObjectPath.length > 0) {\n            newObjectPath.push(\"children\");\n        }\n\n        treeData = treeData.updateIn(newObjectPath, function (children) {\n            return children.set(newName, currentObject);\n        });\n\n        this._commit(treeData);\n    };\n\n\n    /**\n     * @private\n     *\n     * See `FileTreeViewModel.setDirectoryOpen`\n     */\n    function _setDirectoryOpen(treeData, path, open) {\n        var objectPath = _filePathToObjectPath(treeData, path),\n            directory = treeData.getIn(objectPath);\n\n        if (!objectPath) {\n            return {\n                needsLoading: true,\n                treeData: treeData\n            };\n        }\n\n        if (isFile(directory)) {\n            return;\n        }\n\n        var alreadyOpen = directory.get(\"open\") === true;\n\n        if ((alreadyOpen && open) || (!alreadyOpen && !open)) {\n            return;\n        }\n\n        treeData = treeData.updateIn(objectPath, function (directory) {\n            if (open) {\n                return directory.set(\"open\", true);\n            }\n            return directory.delete(\"open\");\n\n        });\n\n        if (open && (directory.get(\"children\") === null || directory.get(\"notFullyLoaded\"))) {\n            return {\n                needsLoading: true,\n                treeData: treeData\n            };\n        }\n        return {\n            needsLoading: false,\n            treeData: treeData\n        };\n    }\n\n    /**\n     * Sets the directory at the given path to open or closed. Returns true if the directory\n     * contents need to be loaded.\n     *\n     * @param {string} path Project relative file path to the directory\n     * @param {boolean} open True to open the directory\n     * @return {boolean} true if the directory contents need to be loaded.\n     */\n    FileTreeViewModel.prototype.setDirectoryOpen = function (path, open) {\n        var result = _setDirectoryOpen(this._treeData, path, open);\n        if (result && result.treeData) {\n            this._commit(result.treeData);\n        }\n        return result ? result.needsLoading : false;\n    };\n\n    /**\n     * Returns the object at the given file path.\n     *\n     * @param {string} path Path to the object\n     * @return {Immutable.Map=} directory or file object from the tree. Null if it's not found.\n     */\n    FileTreeViewModel.prototype._getObject = function (path) {\n        var objectPath = _filePathToObjectPath(this._treeData, path);\n        if (!objectPath) {\n            return null;\n        }\n        return this._treeData.getIn(objectPath);\n    };\n\n    /**\n     * Closes a subtree path, given by an object path.\n     *\n     * @param {Immutable.Map} directory Current directory\n     * @return {Immutable.Map} new directory\n     */\n    function _closeSubtree(directory) {\n        directory = directory.delete(\"open\");\n\n        var children = directory.get(\"children\");\n        if (children) {\n            children.keySeq().forEach(function (name) {\n                var subdir = children.get(name);\n                if (!isFile(subdir)) {\n                    subdir = _closeSubtree(subdir);\n                    children = children.set(name, subdir);\n                }\n            });\n        }\n\n        directory = directory.set(\"children\", children);\n        return directory;\n    }\n\n    /**\n     * Closes the directory at path and recursively closes all of its children.\n     *\n     * @param {string} path Path of subtree to close\n     */\n    FileTreeViewModel.prototype.closeSubtree = function (path) {\n        var treeData = this._treeData,\n            subtreePath = _filePathToObjectPath(treeData, path);\n\n        if (!subtreePath) {\n            return;\n        }\n\n        var directory = treeData.getIn(subtreePath);\n\n        directory = _closeSubtree(directory);\n        treeData = _setIn(treeData, subtreePath, directory);\n        this._commit(treeData);\n    };\n\n    /**\n     * @private\n     *\n     * Takes an array of file system entries and merges them into the children map\n     * of a directory in the view model treeData.\n     *\n     * @param {Immutable.Map} children current children in the directory\n     * @param {Array.<FileSystemEntry>} contents FileSystemEntry objects currently in the directory\n     * @return {Immutable.Map} updated children\n     */\n    function _mergeContentsIntoChildren(children, contents) {\n\n        // We keep track of the names we've seen among the current directory entries to make\n        // it easy to spot the names that we *haven't* seen (in other words, files that have\n        // been deleted).\n        var keysSeen = [];\n\n        children = children.withMutations(function (children) {\n\n            // Loop through the directory entries\n            contents.forEach(function (entry) {\n                keysSeen.push(entry.name);\n\n                var match = children.get(entry.name);\n                if (match) {\n                    // Confirm that a name that used to represent a file and now represents a\n                    // directory (or vice versa) isn't what we've encountered here. If we have\n                    // hit this situation, pretend the current child of treeData doesn't exist\n                    // so we can replace it.\n                    var matchIsFile = isFile(match);\n                    if (matchIsFile !== entry.isFile) {\n                        match = undefined;\n                    }\n                }\n\n                // We've got a new entry that we need to add.\n                if (!match) {\n                    if (entry.isFile) {\n                        children.set(entry.name, Immutable.Map());\n                    } else {\n                        children.set(entry.name, Immutable.Map({\n                            children: null\n                        }));\n                    }\n                }\n            });\n\n            // Look at the list of names that we currently have in the treeData that no longer\n            // appear in the directory and delete those.\n            var currentEntries = children.keySeq().toJS(),\n                deletedEntries = _.difference(currentEntries, keysSeen);\n\n            deletedEntries.forEach(function (name) {\n                children.delete(name);\n            });\n        });\n        return children;\n    }\n\n    /**\n     * @private\n     *\n     * Creates a directory object (or updates an existing directory object) to look like one\n     * that has not yet been loaded, but in which we want to start displaying entries.\n     * @param {Immutable.Map=} directory Directory entry to update\n     * @return {Immutable.Map} New or updated directory object\n     */\n    function _createNotFullyLoadedDirectory(directory) {\n        if (!directory) {\n            return Immutable.Map({\n                notFullyLoaded: true,\n                children: Immutable.Map()\n            });\n        }\n        return directory.merge({\n            notFullyLoaded: true,\n            children: Immutable.Map()\n        });\n    }\n\n    /**\n     * @private\n     *\n     * Creates the directories necessary to display the given path, even if those directories\n     * do not yet exist in the tree and have not been loaded.\n     *\n     * @param {Immutable.Map} treeData\n     * @param {string} path Path to the final directory to be added in the tree\n     * @return {{treeData: Immutable.Map, objectPath: Array.<string>}} updated treeData and object path to the created object\n     */\n    function _createIntermediateDirectories(treeData, path) {\n        var objectPath = [],\n            result = {\n                objectPath: objectPath,\n                treeData: treeData\n            },\n            treePointer = treeData;\n\n        if (path === \"\") {\n            return result;\n        }\n\n        var parts = path.split(\"/\"),\n            part = parts.shift(),\n            node;\n\n        while (part) {\n            if (treePointer === null) {\n                return null;\n            }\n            node = treePointer.get(part);\n            objectPath.push(part);\n\n            // This directory is missing, so create it.\n            if (node === undefined) {\n                treeData = treeData.updateIn(objectPath, _createNotFullyLoadedDirectory);\n                node = treeData.getIn(objectPath);\n            }\n\n            part = parts.shift();\n            if (part) {\n                treePointer = node.get(\"children\");\n\n                if (treePointer) {\n                    objectPath.push(\"children\");\n                } else {\n\n                    // The directory is there, but the directory hasn't been loaded.\n                    // Update the directory to be a `notFullyLoaded` directory.\n                    treeData = treeData.updateIn(objectPath, _createNotFullyLoadedDirectory);\n                    objectPath.push(\"children\");\n                    treePointer = treeData.getIn(objectPath);\n                }\n            }\n        }\n\n        result.treeData = treeData;\n        return result;\n    }\n\n    /**\n     * Updates the directory at the given path with the new contents. If the parent directories\n     * of this directory have not been loaded yet, they will be created. This allows directories\n     * to be loaded in any order.\n     *\n     * @param {string} Project relative path to the directory that is being updated.\n     * @param {Array.<FileSystemEntry>} Current contents of the directory\n     */\n    FileTreeViewModel.prototype.setDirectoryContents = function (path, contents) {\n        path = FileUtils.stripTrailingSlash(path);\n\n        var intermediate = _createIntermediateDirectories(this._treeData, path),\n            objectPath = intermediate.objectPath,\n            treeData = intermediate.treeData;\n\n        if (objectPath === null) {\n            return;\n        }\n\n        var directory = treeData.getIn(objectPath),\n            children = directory;\n\n        // The root directory doesn't need this special handling.\n        if (path !== \"\") {\n\n            // The user of this API passed in a path to a file rather than a directory.\n            // Perhaps this should be an exception?\n            if (isFile(directory)) {\n                return;\n            }\n\n            // If the directory had been created previously as `notFullyLoaded`, we can\n            // remove that flag now because this is the step that is loading the directory.\n            if (directory.get(\"notFullyLoaded\")) {\n                directory = directory.delete(\"notFullyLoaded\");\n            }\n\n            if (!directory.get(\"children\")) {\n                directory = directory.set(\"children\", Immutable.Map());\n            }\n\n            treeData = _setIn(treeData, objectPath, directory);\n\n            objectPath.push(\"children\");\n            children = directory.get(\"children\");\n        }\n\n        children = _mergeContentsIntoChildren(children, contents);\n        treeData = _setIn(treeData, objectPath, children);\n        this._commit(treeData);\n    };\n\n    /**\n     * @private\n     *\n     * Opens the directories along the provided path.\n     *\n     * @param {Immutable.Map} treeData\n     * @param {string} path Path to open\n     */\n    function _openPath(treeData, path) {\n        var objectPath = _filePathToObjectPath(treeData, path);\n\n        function setOpen(node) {\n            return node.set(\"open\", true);\n        }\n\n        while (objectPath && objectPath.length) {\n            var node = treeData.getIn(objectPath);\n            if (isFile(node)) {\n                objectPath.pop();\n            } else {\n                if (!node.get(\"open\")) {\n                    treeData = treeData.updateIn(objectPath, setOpen);\n                }\n                objectPath.pop();\n                if (objectPath.length) {\n                    objectPath.pop();\n                }\n            }\n        }\n\n        return treeData;\n    }\n\n    /**\n     * Opens the directories along the given path.\n     *\n     * @param {string} path Project-relative path\n     */\n    FileTreeViewModel.prototype.openPath = function (path) {\n        this._commit(_openPath(this._treeData, path));\n    };\n\n    /**\n     * @private\n     *\n     * See FileTreeViewModel.createPlaceholder\n     */\n    function _createPlaceholder(treeData, basedir, name, isFolder, options) {\n        options = options || {};\n        var parentPath = _filePathToObjectPath(treeData, basedir);\n\n        if (!parentPath) {\n            return;\n        }\n\n        var newObject = {\n        };\n\n        if (!options.notInCreateMode) {\n            newObject.creating = true;\n        }\n\n        if (isFolder) {\n            // If we're creating a folder, then we know it's empty.\n            // But if we're not in create mode, (we're adding a folder based on an\n            // FS event), we don't know anything about the new directory's children.\n            if (options.notInCreateMode) {\n                newObject.children = null;\n            } else {\n                newObject.children = Immutable.Map();\n            }\n        }\n\n        var newFile = Immutable.Map(newObject);\n\n        if (!options.doNotOpen) {\n            treeData = _openPath(treeData, basedir);\n        }\n        if (parentPath.length > 0) {\n            var childrenPath = _.clone(parentPath);\n            childrenPath.push(\"children\");\n\n            treeData = treeData.updateIn(childrenPath, function (children) {\n                return children.set(name, newFile);\n            });\n        } else {\n            treeData = treeData.set(name, newFile);\n        }\n        return treeData;\n    }\n\n    /**\n     * Creates a placeholder file or directory that appears in the tree so that the user\n     * can provide a name for the new entry.\n     *\n     * @param {string} basedir Directory that contains the new file or folder\n     * @param {string} name Initial name to give the new entry\n     * @param {boolean} isFolder true if the entry being created is a folder\n     */\n    FileTreeViewModel.prototype.createPlaceholder = function (basedir, name, isFolder) {\n        var treeData = _createPlaceholder(this._treeData, basedir, name, isFolder);\n        this._commit(treeData);\n    };\n\n    /**\n     * @private\n     *\n     * See FileTreeViewModel.deleteAtPath\n     */\n    function _deleteAtPath(treeData, path) {\n        var objectPath = _filePathToObjectPath(treeData, path);\n\n        if (!objectPath) {\n            return;\n        }\n\n        var originalName = _.last(objectPath);\n\n        // Back up to the parent directory\n        objectPath.pop();\n\n        treeData = treeData.updateIn(objectPath, function (directory) {\n            directory = directory.delete(originalName);\n            return directory;\n        });\n\n        return treeData;\n    }\n\n    /**\n     * Deletes the entry at the given path.\n     *\n     * @param {string} path Project-relative path to delete\n     */\n    FileTreeViewModel.prototype.deleteAtPath = function (path) {\n        var treeData = _deleteAtPath(this._treeData, path);\n        if (treeData) {\n            this._commit(treeData);\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Adds a timestamp to an entry (much like the \"touch\" command) to force a given entry\n     * to rerender.\n     */\n    function _addTimestamp(item) {\n        return item.set(\"_timestamp\", new Date().getTime());\n    }\n\n    /**\n     * @private\n     *\n     * Sets/updates the timestamp on the file paths listed in the `changed` array.\n     *\n     * @param {Immutable.Map} treeData\n     * @param {Array.<string>} changed list of changed project-relative file paths\n     * @return {Immutable.Map} revised treeData\n     */\n    function _markAsChanged(treeData, changed) {\n        changed.forEach(function (filePath) {\n            var objectPath = _filePathToObjectPath(treeData, filePath);\n            if (objectPath) {\n                treeData = treeData.updateIn(objectPath, _addTimestamp);\n            }\n        });\n        return treeData;\n    }\n\n    /**\n     * @private\n     *\n     * Adds entries at the paths listed in the `added` array. Directories should have a trailing slash.\n     *\n     * @param {Immutable.Map} treeData\n     * @param {Array.<string>} added list of new project-relative file paths\n     * @return {Immutable.Map} revised treeData\n     */\n    function _addNewEntries(treeData, added) {\n        added.forEach(function (filePath) {\n            var isFolder = _.last(filePath) === \"/\";\n\n            filePath = isFolder ? filePath.substr(0, filePath.length - 1) : filePath;\n\n            var parentPath = FileUtils.getDirectoryPath(filePath),\n                parentObjectPath = _filePathToObjectPath(treeData, parentPath),\n                basename = FileUtils.getBaseName(filePath);\n\n            if (parentObjectPath) {\n                // Verify that the children are loaded\n                var childrenPath = _.clone(parentObjectPath);\n                childrenPath.push(\"children\");\n                if (treeData.getIn(childrenPath) === null) {\n                    return;\n                }\n\n                treeData = _createPlaceholder(treeData, parentPath, basename, isFolder, {\n                    notInCreateMode: true,\n                    doNotOpen: true\n                });\n            }\n        });\n\n        return treeData;\n    }\n\n    /**\n     * Applies changes to the tree. The `changes` object can have one or more of the following keys which all\n     * have arrays of project-relative paths as their values:\n     *\n     * * `changed`: entries that have changed in some way that should be re-rendered\n     * * `added`: new entries that need to appear in the tree\n     * * `removed`: entries that have been deleted from the tree\n     *\n     * @param {{changed: Array.<string>=, added: Array.<string>=, removed: Array.<string>=}}\n     */\n    FileTreeViewModel.prototype.processChanges = function (changes) {\n        var treeData = this._treeData;\n\n        if (changes.changed) {\n            treeData = _markAsChanged(treeData, changes.changed);\n        }\n\n        if (changes.added) {\n            treeData = _addNewEntries(treeData, changes.added);\n        }\n\n        if (changes.removed) {\n            changes.removed.forEach(function (path) {\n                treeData = _deleteAtPath(treeData, path);\n            });\n        }\n\n        this._commit(treeData);\n    };\n\n    /**\n     * Makes sure that the directory exists. This will create a directory object (unloaded)\n     * if the directory does not already exist. A change message is also fired in that case.\n     *\n     * This is useful for file system events which can refer to a directory that we don't\n     * know about already.\n     *\n     * @param {string} path Project-relative path to the directory\n     */\n    FileTreeViewModel.prototype.ensureDirectoryExists = function (path) {\n        var treeData          = this._treeData,\n            pathWithoutSlash  = FileUtils.stripTrailingSlash(path),\n            parentPath        = FileUtils.getDirectoryPath(pathWithoutSlash),\n            name              = pathWithoutSlash.substr(parentPath.length),\n            targetPath        = [];\n\n        if (parentPath) {\n            targetPath = _filePathToObjectPath(treeData, parentPath);\n            if (!targetPath) {\n                return;\n            }\n            targetPath.push(\"children\");\n            if (!treeData.getIn(targetPath)) {\n                return;\n            }\n        }\n\n        targetPath.push(name);\n\n        if (treeData.getIn(targetPath)) {\n            return;\n        }\n\n        treeData = _setIn(treeData, targetPath, Immutable.Map({\n            children: null\n        }));\n\n        this._commit(treeData);\n    };\n\n    /**\n     * Sets the value of the `sortDirectoriesFirst` flag which tells to view that directories\n     * should be listed before the alphabetical listing of files.\n     *\n     * @param {boolean} sortDirectoriesFirst True if directories should be displayed first\n     */\n    FileTreeViewModel.prototype.setSortDirectoriesFirst = function (sortDirectoriesFirst) {\n        if (sortDirectoriesFirst !== this.sortDirectoriesFirst) {\n            this.sortDirectoriesFirst = sortDirectoriesFirst;\n            this.trigger(EVENT_CHANGE);\n        }\n    };\n\n    /**\n     * Sets the width of the selection bar.\n     *\n     * @param {int} width New width\n     */\n    FileTreeViewModel.prototype.setSelectionWidth = function (width) {\n        var selectionViewInfo = this._selectionViewInfo;\n        selectionViewInfo = selectionViewInfo.set(\"width\", width);\n        this._commit(null, selectionViewInfo);\n    };\n\n    /**\n     * Sets the scroll position of the file tree to help position the selection bar.\n     * SPECIAL CASE NOTE: this does not trigger a change event because this data is\n     * explicitly set in the rendering process (see ProjectManager._renderTree).\n     *\n     * @param {int} scrollWidth width of the tree content\n     * @param {int} scrollTop Scroll position\n     * @param {int=} scrollLeft Horizontal scroll position\n     * @param {int=} offsetTop top of the scroller\n     */\n    FileTreeViewModel.prototype.setSelectionScrollerInfo = function (scrollWidth, scrollTop, scrollLeft, offsetTop) {\n        this._selectionViewInfo = this._selectionViewInfo.set(\"scrollWidth\", scrollWidth);\n        this._selectionViewInfo = this._selectionViewInfo.set(\"scrollTop\", scrollTop);\n\n        if (scrollLeft !== undefined) {\n            this._selectionViewInfo = this._selectionViewInfo.set(\"scrollLeft\", scrollLeft);\n        }\n\n        if (offsetTop !== undefined) {\n            this._selectionViewInfo = this._selectionViewInfo.set(\"offsetTop\", offsetTop);\n        }\n        // Does not emit change event. See SPECIAL CASE NOTE in docstring above.\n    };\n\n    // Private API\n    exports.EVENT_CHANGE          = EVENT_CHANGE;\n    exports._filePathToObjectPath = _filePathToObjectPath;\n    exports._isFilePathVisible    = _isFilePathVisible;\n    exports._createPlaceholder    = _createPlaceholder;\n\n    // Public API\n    exports.isFile            = isFile;\n    exports.FileTreeViewModel = FileTreeViewModel;\n});\n"],"file":"FileTreeViewModel.js"}
{"version":3,"sources":["project/FileTreeView.js"],"names":["define","require","exports","module","Preact","Classnames","Immutable","_","FileUtils","LanguageManager","FileTreeViewModel","ViewUtils","KeyEvent","PreferencesManager","DOM","_extensions","Map","_draggedItemPath","RIGHT_MOUSE_BUTTON","LEFT_MOUSE_BUTTON","INDENTATION_WIDTH","_getName","fullname","extension","substring","length","pathComputer","myPath","result","this","props","parentPath","name","isFile","entry","last","_measureText","text","measuringElement","$","css","position","top","left","visibility","white-space","appendTo","width","remove","_createThickness","depth","div","style","display","_createAlignedIns","ins","className","marginLeft","renameBehavior","handleClick","e","stopPropagation","button","preventDefault","handleKeyDown","actions","setRenameValue","refs","value","trim","keyCode","DOM_VK_ESCAPE","cancelRename","DOM_VK_RETURN","performRename","handleInput","DOM_VK_LEFT","DOM_VK_RIGHT","node","newWidth","handleBlur","dragAndDrop","handleDrag","get","dataTransfer","setData","JSON","stringify","path","dragItem","setDragImage","handleDrop","data","parse","getData","moveItem","setDraggedOver","clearDragTimeout","handleDragEnd","handleDragOver","getParentPath","self","dragOverTimeout","window","setTimeout","setDirectoryOpen","handleDragLeave","clearTimeout","draggedOver","state","setState","document","createElement","textContent","classList","add","body","appendChild","removeChild","fileRenameInput","createFactory","createClass","mixins","componentDidMount","getCompoundFileExtension","setSelectionRange","focus","scrollElementIntoView","render","input","type","defaultValue","autoFocus","onKeyDown","onInput","onClick","onBlur","ref","contextSettable","handleMouseDown","platform","ctrlKey","setContext","selectNode","isDefined","undefined","extendable","getIcons","extensions","getDataForExtension","iconProviders","toArray","iconProviderCB","iconResult","isValidElement","span","dangerouslySetInnerHTML","__html","outerHTML","push","console","error","stack","getClasses","classes","classProviders","succeededPriority","classProviderCB","priority","classResult","fileNode","getInitialState","shouldComponentUpdate","nextProps","nextState","forceRender","componentDidUpdate","prevProps","prevState","wasSelected","isSelected","findDOMNode","startRename","language","getLanguageForPath","doNotOpen","isBinary","getId","shouldOpenInExternalApplication","getFileExtension","toLowerCase","setSelected","handleDoubleClick","openWithExternalApplication","selectInWorkingSet","fullPath","nameDisplay","cx","fileClasses","jstree-clicked selected-node","context-node","liArgs","onMouseDown","onDoubleClick","draggable","onDragStart","thickness","aArgs","flatten","href","a","apply","li","directoryNode","directoryContents","_buildDirsFirstComparator","contents","_dirsFirstCompare","b","aIsFile","bIsFile","compareFilenames","_sortDirectoryContents","dirsFirst","keySeq","sort","directoryRenameInput","sortDirectoriesFirst","event","isOpen","setOpen","metaKey","altKey","toggleSubdirectories","closeSubtree","nodeClass","childNodes","children","directoryClasses","jstree-clicked sidebar-selection","nodeClasses","onDrop","onDragEnd","onDragOver","onDragLeave","iconClass","ulProps","isRoot","namesInOrder","ul","map","key","bind","fileSelectionBox","visible","selectedNode","parentNode","find","selectedClassName","selectionViewInfo","offset","scrollWidth","overflow","selectionExtension","closest","baselineHeight","dataset","initialHeight","height","scrollerTop","outerHeight","difference","parseInt","outerWidth","fileTreeView","treeData","selectionBackground","forceUpdate","contextBackground","extensionForSelection","extensionForContext","args","element","viewModel","projectRoot","_addExtension","category","callback","callbackList","List","sortBy","f","set","addIconProvider","addClassesProvider","_sortFormattedDirectory","_fileNode","_directoryNode","_directoryContents","_fileTreeView"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: FileTreeView*/\n\n/**\n * This is the view layer (template) for the file tree in the sidebar. It takes a FileTreeViewModel\n * and renders it to the given element using Preact. User actions are signaled via an ActionCreator\n * (in the Flux sense).\n */\ndefine(function (require, exports, module) {\n\n\n    var Preact            = require(\"thirdparty/preact\"),\n        Classnames        = require(\"thirdparty/classnames\"),\n        Immutable         = require(\"thirdparty/immutable\"),\n        _                 = require(\"thirdparty/lodash\"),\n        FileUtils         = require(\"file/FileUtils\"),\n        LanguageManager   = require(\"language/LanguageManager\"),\n        FileTreeViewModel = require(\"project/FileTreeViewModel\"),\n        ViewUtils         = require(\"utils/ViewUtils\"),\n        KeyEvent          = require(\"utils/KeyEvent\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\");\n\n    var DOM = Preact.DOM;\n\n    /**\n     * @private\n     * @type {Immutable.Map}\n     *\n     * Stores the file tree extensions for adding classes and icons. The keys of the map\n     * are the \"categories\" of the extensions and values are vectors of the callback functions.\n     */\n    var _extensions = Immutable.Map();\n\n     /**\n     * @private\n     * @type {string}\n     *\n     * Stores the path of the currently dragged item in the filetree.\n     */\n    var _draggedItemPath;\n\n\n    // Constants\n\n    // Time range from first click to second click to invoke renaming.\n    const RIGHT_MOUSE_BUTTON    = 2,\n        LEFT_MOUSE_BUTTON     = 0;\n\n    const INDENTATION_WIDTH     = 10;\n\n    /**\n     * @private\n     *\n     * Returns the name of a file without its extension.\n     *\n     * @param {string} fullname The complete name of the file (not including the rest of the path)\n     * @param {string} extension The file extension\n     * @return {string} The fullname without the extension\n     */\n    function _getName(fullname, extension) {\n        return extension !== \"\" ? fullname.substring(0, fullname.length - extension.length - 1) : fullname;\n    }\n\n    /**\n     * Mixin that allows a component to compute the full path to its directory entry.\n     */\n    var pathComputer = {\n        /**\n         * Computes the full path of the file represented by this input.\n         */\n        myPath: function () {\n            var result = this.props.parentPath + this.props.name;\n\n            // Add trailing slash for directories\n            if (!FileTreeViewModel.isFile(this.props.entry) && _.last(result) !== \"/\") {\n                result += \"/\";\n            }\n\n            return result;\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Gets an appropriate width given the text provided.\n     *\n     * @param {string} text Text to measure\n     * @return {int} Width to use\n     */\n    function _measureText(text) {\n        var measuringElement = $(\"<span />\", { css: { \"position\": \"absolute\", \"top\": \"-200px\", \"left\": \"-1000px\", \"visibility\": \"hidden\", \"white-space\": \"pre\" } }).appendTo(\"body\");\n        measuringElement.text(\"pW\" + text);\n        var width = measuringElement.width();\n        measuringElement.remove();\n        return width;\n    }\n\n    /**\n     * @private\n     *\n     * Create an appropriate div based \"thickness\" to indent the tree correctly.\n     *\n     * @param {int} depth The depth of the current node.\n     * @return {PreactComponent} The resulting div.\n     */\n    function _createThickness(depth) {\n        return DOM.div({\n            style: {\n                display: \"inline-block\",\n                width: INDENTATION_WIDTH * depth\n            }\n        });\n    }\n\n    /**\n     * @private\n     *\n     * Create, and indent correctly, the arrow icons used for the folders.\n     *\n     * @param {int} depth The depth of the current node.\n     * @return {PreactComponent} The resulting ins.\n     */\n    function _createAlignedIns(depth) {\n        return DOM.ins({\n            className: \"jstree-icon\",\n            style: {\n                marginLeft: INDENTATION_WIDTH * depth\n            }\n        });\n    }\n\n    /**\n     * This is a mixin that provides rename input behavior. It is responsible for taking keyboard input\n     * and invoking the correct action based on that input.\n     */\n    var renameBehavior = {\n        /**\n         * Stop clicks from propagating so that clicking on the rename input doesn't\n         * cause directories to collapse.\n         */\n        handleClick: function (e) {\n            e.stopPropagation();\n            if (e.button !== LEFT_MOUSE_BUTTON) {\n                e.preventDefault();\n            }\n        },\n\n        /**\n         * If the user presses enter or escape, we either successfully complete or cancel, respectively,\n         * the rename or create operation that is underway.\n         */\n        handleKeyDown: function (e) {\n            this.props.actions.setRenameValue(this.props.parentPath + this.refs.name.value.trim());\n            if (e.keyCode === KeyEvent.DOM_VK_ESCAPE) {\n                this.props.actions.cancelRename();\n            } else if (e.keyCode === KeyEvent.DOM_VK_RETURN) {\n                this.props.actions.performRename();\n            }\n        },\n\n        /**\n         * The rename or create operation can be completed or canceled by actions outside of\n         * this component, so we keep the model up to date by sending every update via an action.\n         */\n        handleInput: function (e) {\n            this.props.actions.setRenameValue(this.props.parentPath + this.refs.name.value.trim());\n\n            if (e.keyCode !== KeyEvent.DOM_VK_LEFT &&\n                    e.keyCode !== KeyEvent.DOM_VK_RIGHT) {\n                // update the width of the input field\n                var node = this.refs.name,\n                    newWidth = _measureText(node.value);\n                $(node).width(newWidth);\n            }\n        },\n\n        /**\n         * If we leave the field for any reason, complete the rename.\n         */\n        handleBlur: function () {\n            this.props.actions.performRename();\n        }\n    };\n\n    /**\n     * This is a mixin that provides drag and drop move function.\n     */\n    var dragAndDrop = {\n        handleDrag: function(e) {\n            // Disable drag when renaming\n            if (this.props.entry.get(\"rename\")) {\n                e.preventDefault();\n                e.stopPropagation();\n                return false;\n            }\n\n            // In newer CEF versions, the drag and drop data from the event\n            // (i.e. e.dataTransfer.getData) cannot be used to read data in dragOver event,\n            // so store the drag and drop data in a global variable to read it in the dragOver\n            // event.\n            _draggedItemPath = this.myPath();\n\n            // Pass the dragged item path.\n            e.dataTransfer.setData(\"text\", JSON.stringify({\n                path: _draggedItemPath\n            }));\n\n            this.props.actions.dragItem(this.myPath());\n\n            this.setDragImage(e);\n            e.stopPropagation();\n        },\n        handleDrop: function(e) {\n            var data = JSON.parse(e.dataTransfer.getData(\"text\"));\n\n            this.props.actions.moveItem(data.path, this.myPath());\n            this.setDraggedOver(false);\n\n            this.clearDragTimeout();\n            e.stopPropagation();\n        },\n\n        handleDragEnd: function(e) {\n            this.clearDragTimeout();\n        },\n\n        handleDragOver: function(e) {\n            var data = e.dataTransfer.getData(\"text\"),\n                path;\n\n            if (data) {\n                path = JSON.parse(data).path;\n            } else {\n                path = _draggedItemPath;\n            }\n\n            if (path === this.myPath() || FileUtils.getParentPath(path) === this.myPath()) {\n                e.preventDefault();\n                e.stopPropagation();\n                return;\n            }\n            var self = this;\n            this.setDraggedOver(true);\n\n            // Open the directory tree when item is dragged over a directory\n            if (!this.dragOverTimeout) {\n                this.dragOverTimeout = window.setTimeout(function() {\n                    self.props.actions.setDirectoryOpen(self.myPath(), true);\n                    self.dragOverTimeout = null;\n                }, 800);\n            }\n\n            e.preventDefault(); // Allow the drop\n            e.stopPropagation();\n        },\n\n        handleDragLeave: function(e) {\n            this.setDraggedOver(false);\n            this.clearDragTimeout();\n        },\n\n        clearDragTimeout: function() {\n            if (this.dragOverTimeout) {\n                clearTimeout(this.dragOverTimeout);\n                this.dragOverTimeout = null;\n            }\n        },\n        setDraggedOver: function(draggedOver) {\n            if (this.state.draggedOver !== draggedOver) {\n                this.setState({\n                    draggedOver: draggedOver\n                });\n            }\n        },\n\n        setDragImage: function(e) {\n            var div = window.document.createElement('div');\n            div.textContent = this.props.name;\n            div.classList.add('jstree-dragImage');\n            window.document.body.appendChild(div);\n            e.dataTransfer.setDragImage(div, -10, -10);\n            setTimeout(function() {\n                window.document.body.removeChild(div);\n            }, 0);\n        }\n    };\n\n    /**\n     * @private\n     *\n     * This component presents an input field to the user for renaming a file.\n     *\n     * Props:\n     * * parentPath: the full path of the directory containing this file\n     * * name: the name of the file, including the extension\n     * * actions: the action creator responsible for communicating actions the user has taken\n     */\n    var fileRenameInput = Preact.createFactory(Preact.createClass({\n        mixins: [renameBehavior],\n\n        /**\n         * When this component is displayed, we scroll it into view and select the portion\n         * of the filename that excludes the extension.\n         */\n        componentDidMount: function () {\n            var fullname = this.props.name,\n                extension = LanguageManager.getCompoundFileExtension(fullname);\n\n            var node = this.refs.name;\n            node.setSelectionRange(0, _getName(fullname, extension).length);\n            node.focus(); // set focus on the rename input\n            ViewUtils.scrollElementIntoView($(\"#project-files-container\"), $(node), true);\n        },\n\n        render: function () {\n            var width = _measureText(this.props.name);\n\n            return DOM.input({\n                className: \"jstree-rename-input\",\n                type: \"text\",\n                defaultValue: this.props.name,\n                autoFocus: true,\n                onKeyDown: this.handleKeyDown,\n                onInput: this.handleInput,\n                onClick: this.handleClick,\n                onBlur: this.handleBlur,\n                style: {\n                    width: width\n                },\n                ref: \"name\"\n            });\n        }\n    }));\n\n    /**\n     * @private\n     *\n     * This mixin handles right click (or control click on Mac) action to make a file\n     * the \"context\" object for performing operations like rename.\n     */\n    var contextSettable = {\n\n        /**\n         * Send matching mouseDown events to the action creator as a setContext action.\n         */\n        handleMouseDown: function (e) {\n            e.stopPropagation();\n            if (e.button === RIGHT_MOUSE_BUTTON ||\n                    (this.props.platform === \"mac\" && e.button === LEFT_MOUSE_BUTTON && e.ctrlKey)) {\n                this.props.actions.setContext(this.myPath());\n                e.preventDefault();\n                return;\n            }\n            // Return true only for mouse down in rename mode.\n            if (this.props.entry.get(\"rename\")) {\n                return;\n            }\n            this.selectNode(e);\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Returns true if the value is defined (used in `.filter`)\n     *\n     * @param {Object} value value to test\n     * @return {boolean} true if value is defined\n     */\n    function isDefined(value) {\n        return value !== undefined;\n    }\n\n    /**\n     * Mixin for components that support the \"icons\" and \"addClass\" extension points.\n     * `fileNode` and `directoryNode` support this.\n     */\n    var extendable = {\n\n        /**\n         * Calls the icon providers to get the collection of icons (most likely just one) for\n         * the current file or directory.\n         *\n         * @return {Array.<PreactComponent>} icon components to render\n         */\n        getIcons: function () {\n            let result= [],\n                extensions = this.props.extensions;\n            if (extensions && extensions.get(\"icons\")) {\n                let data = this.getDataForExtension();\n                let iconProviders = extensions.get(\"icons\").toArray();\n                // the iconProviders list is sorted by priority at insertion\n                for(let iconProviderCB of iconProviders){\n                    try {\n                        let iconResult = iconProviderCB(data);\n                        if (iconResult && !Preact.isValidElement(iconResult)) {\n                            iconResult = Preact.DOM.span({\n                                dangerouslySetInnerHTML: {\n                                    __html: $(iconResult)[0].outerHTML\n                                }\n                            });\n                        }\n                        // by this point, returns either undefined or a Preact object\n                        if(iconResult){\n                            result.push(iconResult);\n                            break;\n                        }\n                    } catch (e) {\n                        console.error(\"Exception thrown in FileTreeView icon provider: \" + e, e.stack);\n                    }\n                }\n            }\n\n            if (!result || result.length === 0) {\n                result = [DOM.ins({\n                    className: \"jstree-icon\"\n                }, \" \")];\n            }\n            return result;\n        },\n\n        /**\n         * Calls the addClass providers to get the classes (in string form) to add for the current\n         * file or directory.\n         *\n         * @param {string} classes Initial classes for this node\n         * @return {string} classes for the current node\n         */\n        getClasses: function (classes) {\n            let extensions = this.props.extensions;\n\n            if (extensions && extensions.get(\"addClass\")) {\n                let data = this.getDataForExtension();\n                let classProviders = extensions.get(\"addClass\").toArray();\n                let succeededPriority = null;\n                // the classProviders list is sorted by priority at insertion\n                for(let classProviderCB of classProviders){\n                    if(succeededPriority !== null && (succeededPriority !== classProviderCB.priority)){\n                        // we need to append all class of the same priority and break once we shift to lower priority.\n                        break;\n                    }\n                    try{\n                        let classResult = classProviderCB(data);\n                        if(classResult){\n                            classes = classes + \" \" + classResult;\n                            succeededPriority = classProviderCB.priority;\n                        }\n                    } catch (e) {\n                        console.error(\"Exception thrown in FileTreeView addClass provider: \" + e, e.stack);\n                    }\n                }\n            }\n\n            return classes;\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Component to display a file in the tree.\n     *\n     * Props:\n     * * parentPath: the full path of the directory containing this file\n     * * name: the name of the file, including the extension\n     * * entry: the object with the relevant metadata for the file (whether it's selected or is the context file)\n     * * actions: the action creator responsible for communicating actions the user has taken\n     * * extensions: registered extensions for the file tree\n     * * forceRender: causes the component to run render\n     */\n    var fileNode = Preact.createFactory(Preact.createClass({\n        mixins: [contextSettable, pathComputer, extendable, dragAndDrop],\n\n        /**\n         * Ensures that we always have a state object.\n         */\n        getInitialState: function () {\n            return {};\n        },\n\n        /**\n         * Thanks to immutable objects, we can just do a start object identity check to know\n         * whether or not we need to re-render.\n         */\n        shouldComponentUpdate: function (nextProps, nextState) {\n            return nextProps.forceRender ||\n                this.props.entry !== nextProps.entry ||\n                this.props.extensions !== nextProps.extensions;\n        },\n\n        /**\n         * If this node is newly selected, scroll it into view. Also, move the selection or\n         * context boxes as appropriate.\n         */\n        componentDidUpdate: function (prevProps, prevState) {\n            var wasSelected = prevProps.entry.get(\"selected\"),\n                isSelected  = this.props.entry.get(\"selected\");\n\n            if (isSelected && !wasSelected) {\n                // TODO: This shouldn't really know about project-files-container\n                // directly. It is probably the case that our Preact tree should actually\n                // start with project-files-container instead of just the interior of\n                // project-files-container and then the file tree will be one self-contained\n                // functional unit.\n                ViewUtils.scrollElementIntoView($(\"#project-files-container\"), $(Preact.findDOMNode(this)), true);\n            }\n        },\n\n        startRename: function () {\n            if (!this.props.entry.get(\"rename\")) {\n                this.props.actions.startRename(this.myPath());\n            }\n        },\n\n        /**\n         * When the user clicks on the node, we'll either select it or, if they've clicked twice\n         * with a bit of delay in between, we'll invoke the `startRename` action.\n         */\n        handleClick: function (e) {\n            // If we're renaming, allow the click to go through to the rename input.\n            if (this.props.entry.get(\"rename\")) {\n                e.stopPropagation();\n                return;\n            }\n\n            if (e.button !== LEFT_MOUSE_BUTTON) {\n                return;\n            }\n\n            if (!(this.props.entry.get(\"selected\") && !e.ctrlKey)) {\n                var language = LanguageManager.getLanguageForPath(this.myPath()),\n                    doNotOpen = false;\n                if (language && language.isBinary() && \"image\" !== language.getId() &&\n                        FileUtils.shouldOpenInExternalApplication(\n                            FileUtils.getFileExtension(this.myPath()).toLowerCase()\n                        )\n                    ) {\n                    doNotOpen = true;\n                }\n                this.props.actions.setSelected(this.myPath(), doNotOpen);\n            }\n            e.stopPropagation();\n            e.preventDefault();\n        },\n\n        /**\n         * select the current node in the file tree on mouse down event on files.\n         * This is to increase click responsiveness of file tree.\n         */\n        selectNode: function (e) {\n            if (e.button !== LEFT_MOUSE_BUTTON) {\n                return;\n            }\n\n            var language = LanguageManager.getLanguageForPath(this.myPath()),\n                doNotOpen = false;\n            if (language && language.isBinary() && \"image\" !== language.getId() &&\n                FileUtils.shouldOpenInExternalApplication(\n                    FileUtils.getFileExtension(this.myPath()).toLowerCase()\n                )\n            ) {\n                doNotOpen = true;\n            }\n            this.props.actions.setSelected(this.myPath(), doNotOpen);\n            this.render();\n        },\n\n        /**\n         * When the user double clicks, we will select this file and add it to the working\n         * set (via the `selectInWorkingSet` action.)\n         */\n        handleDoubleClick: function () {\n            if (!this.props.entry.get(\"rename\")) {\n                if (FileUtils.shouldOpenInExternalApplication(\n                        FileUtils.getFileExtension(this.myPath()).toLowerCase()\n                      )) {\n                    this.props.actions.openWithExternalApplication(this.myPath());\n                    return;\n                }\n                this.props.actions.selectInWorkingSet(this.myPath());\n            }\n        },\n\n        /**\n         * Create the data object to pass to extensions.\n         *\n         * @return {!{name:string, isFile:boolean, fullPath:string}} Data for extensions\n         */\n        getDataForExtension: function () {\n            return {\n                name: this.props.name,\n                isFile: true,\n                fullPath: this.myPath()\n            };\n        },\n\n        render: function () {\n            var fullname = this.props.name,\n                extension = LanguageManager.getCompoundFileExtension(fullname),\n                name = _getName(fullname, extension);\n\n            // React automatically wraps content in a span element whereas preact doesn't, so do it manually\n            if (name) {\n                name = DOM.span({}, name);\n            }\n\n            if (extension) {\n                extension = DOM.span({\n                    className: \"extension\"\n                }, \".\" + extension);\n            }\n\n            var nameDisplay,\n                cx = Classnames;\n\n            var fileClasses = cx({\n                'jstree-clicked selected-node': this.props.entry.get(\"selected\"),\n                'context-node': this.props.entry.get(\"context\")\n            });\n\n            var liArgs = [\n                {\n                    className: this.getClasses(\"jstree-leaf\"),\n                    onClick: this.handleClick,\n                    onMouseDown: this.handleMouseDown,\n                    onDoubleClick: this.handleDoubleClick,\n                    draggable: true,\n                    onDragStart: this.handleDrag\n                },\n                DOM.ins({\n                    className: \"jstree-icon\"\n                })\n            ];\n\n            var thickness = _createThickness(this.props.depth);\n\n            if (this.props.entry.get(\"rename\")) {\n                liArgs.push(thickness);\n                nameDisplay = fileRenameInput({\n                    actions: this.props.actions,\n                    entry: this.props.entry,\n                    name: this.props.name,\n                    parentPath: this.props.parentPath\n                });\n            } else {\n                // Need to flatten the argument list because getIcons returns an array\n                var aArgs = _.flatten([{\n                    href: \"#\",\n                    className: fileClasses\n                }, thickness, this.getIcons(), name, extension]);\n                nameDisplay = DOM.a.apply(DOM.a, aArgs);\n            }\n\n            liArgs.push(nameDisplay);\n\n            return DOM.li.apply(DOM.li, liArgs);\n        }\n    }));\n\n    /**\n     * @private\n     *\n     * Creates a comparison function for sorting a directory's contents with directories\n     * appearing before files.\n     *\n     * We're sorting the keys of the directory (the names) based partly on the values,\n     * so we use a closure to capture the map itself so that we can look up the\n     * values as needed.\n     *\n     * @param {Immutable.Map} contents The directory's contents\n     * @return {function(string,string)} Comparator that sorts directories first.\n     */\n    function _buildDirsFirstComparator(contents) {\n        function _dirsFirstCompare(a, b) {\n            var aIsFile = FileTreeViewModel.isFile(contents.get(a)),\n                bIsFile = FileTreeViewModel.isFile(contents.get(b));\n\n            if (!aIsFile && bIsFile) {\n                return -1;\n            } else if (aIsFile && !bIsFile) {\n                return 1;\n            }\n            return FileUtils.compareFilenames(a, b);\n\n        }\n        return _dirsFirstCompare;\n    }\n\n    /**\n     * @private\n     *\n     * Sort a directory either alphabetically or with subdirectories listed first.\n     *\n     * @param {Immutable.Map} contents the directory's contents\n     * @param {boolean} dirsFirst true to sort subdirectories first\n     * @return {Immutable.Map} sorted mapping\n     */\n    function _sortDirectoryContents(contents, dirsFirst) {\n        if (dirsFirst) {\n            return contents.keySeq().sort(_buildDirsFirstComparator(contents));\n        }\n        return contents.keySeq().sort(FileUtils.compareFilenames);\n\n    }\n\n    // Forward references to keep JSLint happy.\n    var directoryNode, directoryContents;\n\n    /**\n     * @private\n     *\n     * Component that provides the input for renaming a directory.\n     *\n     * Props:\n     * * parentPath: the full path of the directory containing this file\n     * * name: the name of the file, including the extension\n     * * actions: the action creator responsible for communicating actions the user has taken\n     */\n    var directoryRenameInput = Preact.createFactory(Preact.createClass({\n        mixins: [renameBehavior],\n\n        /**\n         * When this component is displayed, we scroll it into view and select the folder name.\n         */\n        componentDidMount: function () {\n            var fullname = this.props.name;\n\n            var node = this.refs.name;\n            node.setSelectionRange(0, fullname.length);\n            node.focus(); // set focus on the rename input\n            ViewUtils.scrollElementIntoView($(\"#project-files-container\"), $(node), true);\n        },\n\n        render: function () {\n            var width = _measureText(this.props.name);\n\n            return DOM.input({\n                className: \"jstree-rename-input\",\n                type: \"text\",\n                defaultValue: this.props.name,\n                autoFocus: true,\n                onKeyDown: this.handleKeyDown,\n                onInput: this.handleInput,\n                onBlur: this.handleBlur,\n                style: {\n                    width: width\n                },\n                onClick: this.handleClick,\n                ref: \"name\"\n            });\n        }\n    }));\n\n    /**\n     * @private\n     *\n     * Displays a directory (but not its contents) in the tree.\n     *\n     * Props:\n     * * parentPath: the full path of the directory containing this file\n     * * name: the name of the directory\n     * * entry: the object with the relevant metadata for the file (whether it's selected or is the context file)\n     * * actions: the action creator responsible for communicating actions the user has taken\n     * * sortDirectoriesFirst: whether the directories should be displayed first when listing the contents of a directory\n     * * extensions: registered extensions for the file tree\n     * * forceRender: causes the component to run render\n     */\n    directoryNode = Preact.createFactory(Preact.createClass({\n        mixins: [contextSettable, pathComputer, extendable, dragAndDrop],\n\n        getInitialState: function() {\n            return {\n                draggedOver: false\n            };\n        },\n\n        /**\n         * We need to update this component if the sort order changes or our entry object\n         * changes. Thanks to immutability, if any of the directory contents change, our\n         * entry object will change.\n         */\n        shouldComponentUpdate: function (nextProps, nextState) {\n            return nextProps.forceRender ||\n                this.props.entry !== nextProps.entry ||\n                this.props.sortDirectoriesFirst !== nextProps.sortDirectoriesFirst ||\n                this.props.extensions !== nextProps.extensions ||\n                (nextState !== undefined && this.state.draggedOver !== nextState.draggedOver);\n        },\n\n        /**\n         * If you click on a directory, it will toggle between open and closed.\n         */\n        handleClick: function (event) {\n            if (this.props.entry.get(\"rename\")) {\n                event.stopPropagation();\n                return;\n            }\n\n            if (event.button !== LEFT_MOUSE_BUTTON) {\n                return;\n            }\n\n            var isOpen = this.props.entry.get(\"open\"),\n                setOpen = isOpen ? false : true;\n\n            if (event.metaKey || event.ctrlKey) {\n                // ctrl-alt-click toggles this directory and its children\n                if (event.altKey) {\n                    if (setOpen) {\n                        // when opening, we only open the immediate children because\n                        // opening a whole subtree could be really slow (consider\n                        // a `node_modules` directory, for example).\n                        this.props.actions.toggleSubdirectories(this.myPath(), setOpen);\n                        this.props.actions.setDirectoryOpen(this.myPath(), setOpen);\n                    } else {\n                        // When closing, we recursively close the whole subtree.\n                        this.props.actions.closeSubtree(this.myPath());\n                    }\n                } else {\n                    // ctrl-click toggles the sibling directories\n                    this.props.actions.toggleSubdirectories(this.props.parentPath, setOpen);\n                }\n            } else {\n                // directory toggle with no modifier\n                this.props.actions.setDirectoryOpen(this.myPath(), setOpen);\n            }\n            event.stopPropagation();\n            event.preventDefault();\n        },\n\n        /**\n         * select the current node in the file tree\n         */\n        selectNode: function (e) {\n            // Do nothing for folders on keydown event. Only expand the file tree on click event\n            // to prevent jarring directory accordion expansion in ui.\n        },\n\n        /**\n         * Create the data object to pass to extensions.\n         *\n         * @return {{name: {string}, isFile: {boolean}, fullPath: {string}}} Data for extensions\n         */\n        getDataForExtension: function () {\n            return {\n                name: this.props.name,\n                isFile: false,\n                fullPath: this.myPath()\n            };\n        },\n\n        render: function () {\n            var entry = this.props.entry,\n                nodeClass,\n                childNodes,\n                children = entry.get(\"children\"),\n                isOpen = entry.get(\"open\");\n\n            if (isOpen && children) {\n                nodeClass = \"open\";\n                childNodes = directoryContents({\n                    depth: this.props.depth + 1,\n                    parentPath: this.myPath(),\n                    contents: children,\n                    extensions: this.props.extensions,\n                    actions: this.props.actions,\n                    forceRender: this.props.forceRender,\n                    platform: this.props.platform,\n                    sortDirectoriesFirst: this.props.sortDirectoriesFirst\n                });\n            } else {\n                nodeClass = \"closed\";\n            }\n\n            var nameDisplay,\n                cx = Classnames;\n\n            var directoryClasses = cx({\n                'jstree-clicked sidebar-selection': entry.get(\"selected\"),\n                'context-node': entry.get(\"context\")\n            });\n\n            var nodeClasses = \"jstree-\" + nodeClass;\n            if (this.state.draggedOver) {\n                nodeClasses += \" jstree-draggedOver\";\n            }\n\n            var liArgs = [\n                {\n                    className: this.getClasses(nodeClasses),\n                    onClick: this.handleClick,\n                    onMouseDown: this.handleMouseDown,\n                    draggable: true,\n                    onDragStart: this.handleDrag,\n                    onDrop: this.handleDrop,\n                    onDragEnd: this.handleDragEnd,\n                    onDragOver: this.handleDragOver,\n                    onDragLeave: this.handleDragLeave\n                },\n                _createAlignedIns(this.props.depth)\n            ];\n\n            var thickness = _createThickness(this.props.depth);\n\n            if (entry.get(\"rename\")) {\n                liArgs.push(thickness);\n                nameDisplay = directoryRenameInput({\n                    actions: this.props.actions,\n                    entry: entry,\n                    name: this.props.name,\n                    parentPath: this.props.parentPath\n                });\n            } else {\n                // React automatically wraps content in a span element whereas preact doesn't, so do it manually\n                if (this.props.name) {\n                    var name = DOM.span({}, this.props.name);\n                }\n\n                // Need to flatten the arguments because getIcons returns an array\n                var aArgs = _.flatten([{\n                    href: \"#\",\n                    className: directoryClasses\n                }, thickness, this.getIcons(), name]);\n                nameDisplay = DOM.a.apply(DOM.a, aArgs);\n            }\n\n            liArgs.push(nameDisplay);\n            liArgs.push(childNodes);\n\n            return DOM.li.apply(DOM.li, liArgs);\n        }\n    }));\n\n    /**\n     * @private\n     *\n     * Displays the contents of a directory.\n     *\n     * Props:\n     * * isRoot: whether this directory is the root of the tree\n     * * parentPath: the full path of the directory containing this file\n     * * contents: the map of name/child entry pairs for this directory\n     * * actions: the action creator responsible for communicating actions the user has taken\n     * * sortDirectoriesFirst: whether the directories should be displayed first when listing the contents of a directory\n     * * extensions: registered extensions for the file tree\n     * * forceRender: causes the component to run render\n     */\n    directoryContents = Preact.createFactory(Preact.createClass({\n\n        /**\n         * Need to re-render if the sort order or the contents change.\n         */\n        shouldComponentUpdate: function (nextProps, nextState) {\n            return nextProps.forceRender ||\n                this.props.contents !== nextProps.contents ||\n                this.props.sortDirectoriesFirst !== nextProps.sortDirectoriesFirst ||\n                this.props.extensions !== nextProps.extensions;\n        },\n\n        render: function () {\n            var extensions = this.props.extensions,\n                iconClass = extensions && extensions.get(\"icons\") ? \"jstree-icons\" : \"jstree-no-icons\",\n                ulProps = this.props.isRoot ? {\n                    className: \"jstree-brackets jstree-no-dots \" + iconClass\n                } : null;\n\n            var contents = this.props.contents,\n                namesInOrder = _sortDirectoryContents(contents, this.props.sortDirectoriesFirst);\n\n            return DOM.ul(ulProps, namesInOrder.map(function (name) {\n                var entry = contents.get(name);\n\n                if (FileTreeViewModel.isFile(entry)) {\n                    return fileNode({\n                        depth: this.props.depth,\n                        parentPath: this.props.parentPath,\n                        name: name,\n                        entry: entry,\n                        actions: this.props.actions,\n                        extensions: this.props.extensions,\n                        forceRender: this.props.forceRender,\n                        platform: this.props.platform,\n                        key: name\n                    });\n                }\n                return directoryNode({\n                    depth: this.props.depth,\n                    parentPath: this.props.parentPath,\n                    name: name,\n                    entry: entry,\n                    actions: this.props.actions,\n                    extensions: this.props.extensions,\n                    sortDirectoriesFirst: this.props.sortDirectoriesFirst,\n                    forceRender: this.props.forceRender,\n                    platform: this.props.platform,\n                    key: name\n                });\n\n            }.bind(this)).toArray());\n        }\n    }));\n\n    /**\n     * Displays the absolutely positioned box for the selection or context in the\n     * file tree. Its position is determined by passed-in info about the scroller in which\n     * the tree resides and the top of the selected node (as reported by the node itself).\n     *\n     * Props:\n     * * selectionViewInfo: Immutable.Map with width, scrollTop, scrollLeft and offsetTop for the tree container\n     * * visible: should this be visible now\n     * * selectedClassName: class name applied to the element that is selected\n     */\n    var fileSelectionBox = Preact.createFactory(Preact.createClass({\n        /**\n         * When the component has updated in the DOM, reposition it to where the currently\n         * selected node is located now.\n         */\n        componentDidUpdate: function () {\n            if (!this.props.visible) {\n                return;\n            }\n\n            var node = Preact.findDOMNode(this),\n                selectedNode = $(node.parentNode).find(this.props.selectedClassName),\n                selectionViewInfo = this.props.selectionViewInfo;\n\n            if (selectedNode.length === 0) {\n                return;\n            }\n\n            node.style.top = selectedNode.offset().top - selectionViewInfo.get(\"offsetTop\") + selectionViewInfo.get(\"scrollTop\") - selectedNode.position().top + \"px\";\n        },\n\n        render: function () {\n            var selectionViewInfo = this.props.selectionViewInfo,\n                left = selectionViewInfo.get(\"scrollLeft\"),\n                width = selectionViewInfo.get(\"width\"),\n                scrollWidth = selectionViewInfo.get(\"scrollWidth\");\n\n            return DOM.div({\n                style: {\n                    overflow: \"auto\",\n                    left: left,\n                    display: this.props.visible ? \"block\" : \"none\"\n                },\n                className: this.props.className\n            });\n        }\n    }));\n\n    /**\n     * On Windows and Linux, the selection bar in the tree does not extend over the scroll bar.\n     * The selectionExtension sits on top of the scroll bar to make the selection bar appear to span the\n     * whole width of the sidebar.\n     *\n     * Props:\n     * * selectionViewInfo: Immutable.Map with width, scrollTop, scrollLeft and offsetTop for the tree container\n     * * visible: should this be visible now\n     * * selectedClassName: class name applied to the element that is selected\n     * * className: class to be applied to the extension element\n     */\n    var selectionExtension = Preact.createFactory(Preact.createClass({\n        /**\n         * When the component has updated in the DOM, reposition it to where the currently\n         * selected node is located now.\n         */\n        componentDidUpdate: function () {\n            if (!this.props.visible) {\n                return;\n            }\n\n            var node = Preact.findDOMNode(this),\n                selectedNode = $(node.parentNode).find(this.props.selectedClassName).closest(\"li\"),\n                selectionViewInfo = this.props.selectionViewInfo;\n\n            if (selectedNode.length === 0) {\n                return;\n            }\n\n            var top = selectedNode.offset().top,\n                baselineHeight = node.dataset.initialHeight,\n                height = baselineHeight,\n                scrollerTop = selectionViewInfo.get(\"offsetTop\");\n\n            if (!baselineHeight) {\n                baselineHeight = $(node).outerHeight();\n                node.dataset.initialHeight = baselineHeight;\n                height = baselineHeight;\n            }\n\n            // Check to see if the selection is completely scrolled out of view\n            // to prevent the extension from appearing in the working set area.\n            if (top < scrollerTop - baselineHeight) {\n                node.style.display = \"none\";\n                return;\n            }\n\n            node.style.display = \"block\";\n\n            // The selectionExtension sits on top of the other nodes\n            // so we need to shrink it if only part of the selection node is visible\n            if (top < scrollerTop) {\n                var difference = scrollerTop - top;\n                top += difference;\n                height = parseInt(height, 10);\n                height -= difference;\n            }\n\n            node.style.top = top + \"px\";\n            node.style.height = height + \"px\";\n            node.style.left = selectionViewInfo.get(\"width\") - $(node).outerWidth() + \"px\";\n        },\n\n        render: function () {\n            return DOM.div({\n                style: {\n                    display: this.props.visible ? \"block\" : \"none\"\n                },\n                className: this.props.className\n            });\n        }\n    }));\n\n    /**\n     * @private\n     *\n     * This is the root component of the file tree.\n     *\n     * Props:\n     * * treeData: the root of the tree (an Immutable.Map with the contents of the project root)\n     * * sortDirectoriesFirst: whether the directories should be displayed first when listing the contents of a directory\n     * * parentPath: the full path of the directory containing this file\n     * * actions: the action creator responsible for communicating actions the user has taken\n     * * extensions: registered extensions for the file tree\n     * * forceRender: causes the component to run render\n     * * platform: platform that Brackets is running on\n     */\n    var fileTreeView = Preact.createFactory(Preact.createClass({\n\n        /**\n         * Update for any change in the tree data or directory sorting preference.\n         */\n        shouldComponentUpdate: function (nextProps, nextState) {\n            return nextProps.forceRender ||\n                this.props.treeData !== nextProps.treeData ||\n                this.props.sortDirectoriesFirst !== nextProps.sortDirectoriesFirst ||\n                this.props.extensions !== nextProps.extensions ||\n                this.props.selectionViewInfo !== nextProps.selectionViewInfo;\n        },\n\n        handleDrop: function(e) {\n            var data = JSON.parse(e.dataTransfer.getData(\"text\"));\n            this.props.actions.moveItem(data.path, this.props.parentPath);\n            e.stopPropagation();\n        },\n\n        /**\n         * Allow the Drop\n         */\n        handleDragOver: function(e) {\n            e.preventDefault();\n        },\n\n        render: function () {\n            var selectionBackground = fileSelectionBox({\n                    ref: \"selectionBackground\",\n                    selectionViewInfo: this.props.selectionViewInfo,\n                    className: \"filetree-selection\",\n                    visible: this.props.selectionViewInfo.get(\"hasSelection\"),\n                    selectedClassName: \".selected-node\",\n                    forceUpdate: true\n                }),\n                contextBackground = fileSelectionBox({\n                    ref: \"contextBackground\",\n                    selectionViewInfo: this.props.selectionViewInfo,\n                    className: \"filetree-context\",\n                    visible: this.props.selectionViewInfo.get(\"hasContext\"),\n                    selectedClassName: \".context-node\",\n                    forceUpdate: true\n                }),\n                extensionForSelection = selectionExtension({\n                    selectionViewInfo: this.props.selectionViewInfo,\n                    selectedClassName: \".selected-node\",\n                    visible: this.props.selectionViewInfo.get(\"hasSelection\"),\n                    forceUpdate: true,\n                    className: \"filetree-selection-extension\"\n                }),\n                extensionForContext = selectionExtension({\n                    selectionViewInfo: this.props.selectionViewInfo,\n                    selectedClassName: \".context-node\",\n                    visible: this.props.selectionViewInfo.get(\"hasContext\"),\n                    forceUpdate: true,\n                    className: \"filetree-context-extension\"\n                }),\n                contents = directoryContents({\n                    isRoot: true,\n                    depth: 1,\n                    parentPath: this.props.parentPath,\n                    sortDirectoriesFirst: this.props.sortDirectoriesFirst,\n                    contents: this.props.treeData,\n                    extensions: this.props.extensions,\n                    actions: this.props.actions,\n                    forceRender: this.props.forceRender,\n                    platform: this.props.platform\n                }),\n                args = {\n                    onDrop: this.handleDrop,\n                    onDragOver: this.handleDragOver\n                };\n\n\n            return DOM.div(\n                args,\n                contents,\n                selectionBackground,\n                contextBackground,\n                extensionForSelection,\n                extensionForContext\n            );\n        }\n    }));\n\n    /**\n     * Renders the file tree to the given element.\n     *\n     * @param {DOMNode|jQuery} element Element in which to render this file tree\n     * @param {FileTreeViewModel} viewModel the data container\n     * @param {Directory} projectRoot Directory object from which the fullPath of the project root is extracted\n     * @param {ActionCreator} actions object with methods used to communicate events that originate from the user\n     * @param {boolean} forceRender Run render on the entire tree (useful if an extension has new data that it needs rendered)\n     * @param {string} platform mac, win, linux\n     */\n    function render(element, viewModel, projectRoot, actions, forceRender, platform) {\n        if (!projectRoot) {\n            return;\n        }\n\n        Preact.render(fileTreeView({\n            treeData: viewModel.treeData,\n            selectionViewInfo: viewModel.selectionViewInfo,\n            sortDirectoriesFirst: viewModel.sortDirectoriesFirst,\n            parentPath: projectRoot.fullPath,\n            actions: actions,\n            extensions: _extensions,\n            platform: platform,\n            forceRender: forceRender\n        }),\n              element);\n    }\n\n    /**\n     * @private\n     *\n     * Add an extension for the given category (icons, addClass).\n     *\n     * @param {string} category Category to which the extension is being added\n     * @param {function} callback The extension function itself\n     */\n    function _addExtension(category, callback) {\n        if (!callback || typeof callback !== \"function\") {\n            console.error(\"Attempt to add FileTreeView\", category, \"extension without a callback function\");\n            return;\n        }\n        var callbackList = _extensions.get(category);\n        if (!callbackList) {\n            callbackList = Immutable.List();\n        }\n        callbackList = callbackList.push(callback);\n        callbackList = callbackList.sortBy((f) => -f.priority);\n        _extensions = _extensions.set(category, callbackList);\n    }\n\n    /**\n     * Adds an icon provider. The callback is invoked before each working set item is created, and can\n     * return content to prepend to the item if it supports the icon.\n     *\n     * @param {!function(!{name:string, fullPath:string, isFile:boolean}):?string|jQuery|DOMNode} callback\n     * Return a string representing the HTML, a jQuery object or DOM node, or undefined. If undefined,\n     * nothing is prepended to the list item and the default or an available icon will be used.\n     * @param {number} [priority] optional priority. 0 being lowest. The icons with the highest priority wins if there\n     * are multiple callback providers attached. icon providers of the same priority first valid response wins.\n     */\n    function addIconProvider(callback, priority= 0) {\n        callback.priority = priority;\n        _addExtension(\"icons\", callback);\n    }\n\n    /**\n     * Adds a CSS class provider, invoked before each working set item is created or updated. When called\n     * to update an existing item, all previously applied classes have been cleared.\n     *\n     * @param {!function(!{name:string, fullPath:string, isFile:boolean}):?string} callback\n     * Return a string containing space-separated CSS class(es) to add, or undefined to leave CSS unchanged.\n     * @param {number} [priority] optional priority. 0 being lowest. The class with the highest priority wins if there\n     * are multiple callback classes attached. class providers of the same priority will be appended.\n     */\n    function addClassesProvider(callback, priority = 0) {\n        callback.priority = priority;\n        _addExtension(\"addClass\", callback);\n    }\n\n    // Private API for testing\n    exports._sortFormattedDirectory = _sortDirectoryContents;\n    exports._fileNode = fileNode;\n    exports._directoryNode = directoryNode;\n    exports._directoryContents = directoryContents;\n    exports._fileTreeView = fileTreeView;\n\n    // Public API\n    exports.addIconProvider = addIconProvider;\n    exports.addClassesProvider = addClassesProvider;\n    exports.render = render;\n});\n"],"file":"FileTreeView.js"}
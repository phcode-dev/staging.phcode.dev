{"version":3,"sources":["extensions/default/InlineTimingFunctionEditor/StepEditor.js"],"names":["define","require","exports","module","KeyEvent","brackets","getModule","Strings","Mustache","TimingFunctionUtils","StepEditorTemplate","STEP_LINE","DASH_LINE","StepParameters","params","this","count","timing","StepCanvas","canvas","stepParams","padding","getPadding","ctx","getContext","p","scale","width","height","translate","_canvasKeyDown","e","code","keyCode","self","stepEditor","target","DOM_VK_LEFT","DOM_VK_DOWN","preventDefault","stepCanvas","DOM_VK_UP","DOM_VK_RIGHT","_stepParams","_commitTimingFunction","_updateCanvas","DOM_VK_ESCAPE","StepEditor","$parent","stepMatch","callback","$element","$","render","append","_callback","_getStepParams","hint","elem","originalString","showHideHint","toString","find","on","prototype","drawBackground","beginPath","lineWidth","settings","borderWidth","strokeStyle","borderColor","fillStyle","bgColor","moveTo","lineTo","stroke","fill","closePath","drawPoint","x","y","isFilled","pointLineWidth","stepColor","arc","pointRadius","Math","PI","drawLine","x1","y1","x2","y2","type","stepLineWidth","dashLineWidth","dashColor","drawStartInterval","pr","drawEndInterval","plot","setting","i","j","last","interval","sp","isStart","defaultSettings","hasOwnProperty","clearRect","length","destroy","off","getRootElement","focus","stepFuncVal","match","parseInt","window","console","log","_getCanvasBoundingBox","$canvas","canvasOffset","offset","left","top","handleExternalUpdate"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var KeyEvent    = brackets.getModule(\"utils/KeyEvent\"),\n        Strings     = brackets.getModule(\"strings\"),\n        Mustache    = brackets.getModule(\"thirdparty/mustache/mustache\");\n\n    var TimingFunctionUtils = require(\"TimingFunctionUtils\");\n\n    /** Mustache template that forms the bare DOM structure of the UI */\n    var StepEditorTemplate   = require(\"text!StepEditorTemplate.html\");\n\n    /** @const @type {number} */\n    var STEP_LINE   = 1,\n        DASH_LINE   = 2;\n\n    /**\n     * StepParameters object constructor\n     *\n     * @param {{ count: number, timing: string}} params Parameters passed to steps()\n     *      either in string or array format.\n     */\n    function StepParameters(params) {\n        if (!params) {\n            throw \"No parameters were defined\";\n        }\n\n        this.count  = params.count;\n        this.timing = params.timing;\n    }\n\n    /**\n     * StepCanvas object constructor\n     *\n     * @param {Element} canvas Inline editor <canvas> element\n     * @param {StepParameters} stepParams Associated StepParameters object\n     * @param {number|Array.number} padding Element padding\n     */\n    function StepCanvas(canvas, stepParams, padding) {\n        this.canvas     = canvas;\n        this.stepParams = stepParams;\n        this.padding    = this.getPadding(padding);\n\n        // Convert to a cartesian coordinate system with axes from 0 to 1\n        var ctx = this.canvas.getContext(\"2d\"),\n            p = this.padding;\n\n        ctx.scale(canvas.width * (1 - p[1] - p[3]), -canvas.height * (1 - p[0] - p[2]));\n        ctx.translate(p[3] / (1 - p[1] - p[3]), (-1 - p[0] / (1 - p[0] - p[2])));\n    }\n\n    StepCanvas.prototype = {\n\n        drawBackground: function () {\n            this.ctx.beginPath();\n            this.ctx.lineWidth   = this.settings.borderWidth;\n            this.ctx.strokeStyle = this.settings.borderColor;\n            this.ctx.fillStyle = this.settings.bgColor;\n            this.ctx.moveTo(0, 0);\n            this.ctx.lineTo(0, 1);\n            this.ctx.lineTo(1, 1);\n            this.ctx.lineTo(1, 0);\n            this.ctx.lineTo(0, 0);\n            this.ctx.stroke();\n            this.ctx.fill();\n            this.ctx.closePath();\n        },\n\n        drawPoint: function (x, y, isFilled) {\n            // Points are always step color\n            this.ctx.beginPath();\n            this.ctx.lineWidth   = this.settings.pointLineWidth;\n            this.ctx.strokeStyle = this.settings.stepColor;\n            this.ctx.arc(x, y, this.settings.pointRadius, 0, 2 * Math.PI, false);\n            this.ctx.stroke();\n            if (isFilled) {\n                this.ctx.fillStyle = this.settings.stepColor;\n                this.ctx.fill();\n            }\n            this.ctx.closePath();\n        },\n\n        drawLine: function (x1, y1, x2, y2, type) {\n            this.ctx.beginPath();\n            if (type === STEP_LINE) {\n                this.ctx.lineWidth   = this.settings.stepLineWidth;\n                this.ctx.strokeStyle = this.settings.stepColor;\n            } else if (type === DASH_LINE) {\n                this.ctx.lineWidth   = this.settings.dashLineWidth;\n                this.ctx.strokeStyle = this.settings.dashColor;\n            }\n            this.ctx.moveTo(x1, y1);\n            this.ctx.lineTo(x2, y2);\n            this.ctx.stroke();\n            this.ctx.closePath();\n        },\n\n        drawStartInterval: function (x1, y1, x2, y2) {\n            var pr = this.settings.pointRadius;\n\n            // Draw empty start point\n            this.drawPoint(x1, y1, false);\n\n            // Draw dashed line up to next step\n            this.drawLine(x1, y1 + pr, x1, y2, DASH_LINE);\n\n            // Draw filled mid point\n            this.drawPoint(x1, y2, true);\n\n            // Draw step line\n            this.drawLine(x1, y2, x2 - pr, y2, STEP_LINE);\n        },\n\n        drawEndInterval: function (x1, y1, x2, y2) {\n            var pr = this.settings.pointRadius;\n\n            // Draw filled start point\n            this.drawPoint(x1, y1, true);\n\n            // Draw step line\n            this.drawLine(x1, y1, x2 - pr, y1, STEP_LINE);\n\n            // Draw empty mid point\n            this.drawPoint(x2, y1, false);\n\n            // Draw dashed line up to next step\n            this.drawLine(x2, y1 + pr, x2, y2, DASH_LINE);\n        },\n\n        /**\n         * Paint canvas\n         *\n         * @param {Object} settings Paint settings\n         */\n        plot: function (settings) {\n            var setting, i, j, last, interval,\n                sp = this.stepParams,\n                isStart = (sp.timing === \"start\"),\n                p = [];\n\n            var defaultSettings = {\n                bgColor: \"transparent\",\n                borderColor: \"#bbb\",\n                stepColor: \"#2893ef\",\n                dashColor: \"#b8b8b8\",\n                borderWidth: 0.00667,\n                stepLineWidth: 0.02,\n                dashLineWidth: 0.008,\n                pointLineWidth: 0.008,\n                pointRadius: 0.015\n            };\n\n            this.settings = settings || {};\n\n            for (setting in defaultSettings) {\n                if (defaultSettings.hasOwnProperty(setting)) {\n                    if (!this.settings.hasOwnProperty(setting)) {\n                        this.settings[setting] = defaultSettings[setting];\n                    }\n                }\n            }\n\n            this.ctx = this.canvas.getContext(\"2d\");\n\n            // Build points array. There's a starting point at 0,0\n            // plus a point for each step\n            p[0] = { x: 0, y: 0 };\n            for (i = 1; i <= sp.count; i++) {\n                interval = i / sp.count;\n                p[i] = { x: interval, y: interval };\n            }\n\n            // Start with a clean slate\n            this.ctx.clearRect(-0.5, -0.5, 2, 2);\n            this.drawBackground();\n\n            // Draw each interval\n            last = p.length - 1;\n            for (i = 0, j = 1; i < last; i++, j++) {\n                if (isStart) {\n                    this.drawStartInterval(p[i].x, p[i].y, p[j].x, p[j].y);\n                } else {\n                    this.drawEndInterval(p[i].x, p[i].y, p[j].x, p[j].y);\n                }\n            }\n\n            // Each interval draws start and mid point for that interval,\n            // so we need to draw last point. It's always filled.\n            this.drawPoint(p[last].x, p[last].y, true);\n        },\n\n        /**\n         * Convert CSS padding shorthand to longhand\n         *\n         * @param {number|Array.number} padding Element padding\n         * @return {Array.number}\n         */\n        getPadding: function (padding) {\n            var p = (typeof padding === \"number\") ? [padding] : padding;\n\n            if (p.length === 1) {\n                p[1] = p[0];\n            }\n            if (p.length === 2) {\n                p[2] = p[0];\n            }\n            if (p.length === 3) {\n                p[3] = p[1];\n            }\n\n            return p;\n        }\n    };\n\n    // Event handlers\n\n    /**\n     * Handle key down in <canvas> element\n     *\n     * @param {Event} e Key down event\n     */\n    function _canvasKeyDown(e) {\n        var code = e.keyCode,\n            self = e.target,\n            stepEditor = self.stepEditor;\n\n        if (code >= KeyEvent.DOM_VK_LEFT && code <= KeyEvent.DOM_VK_DOWN) {\n            e.preventDefault();\n\n            // Arrow keys pressed\n            switch (code) {\n            case KeyEvent.DOM_VK_LEFT:\n                stepEditor.stepCanvas.stepParams.timing = \"start\";\n                break;\n            case KeyEvent.DOM_VK_UP:\n                // No upper limit\n                stepEditor.stepCanvas.stepParams.count++;\n                break;\n            case KeyEvent.DOM_VK_RIGHT:\n                stepEditor.stepCanvas.stepParams.timing = \"end\";\n                break;\n            case KeyEvent.DOM_VK_DOWN:\n                if (stepEditor.stepCanvas.stepParams.count > 1) {\n                    stepEditor.stepCanvas.stepParams.count--;\n                }\n                break;\n            }\n\n            // update step params\n            stepEditor._stepParams = stepEditor.stepCanvas.stepParams;\n\n            stepEditor._commitTimingFunction();\n            stepEditor._updateCanvas();\n            return true;\n\n        } else if (code === KeyEvent.DOM_VK_ESCAPE) {\n            return true;\n        }\n\n        return false;\n    }\n\n\n    /**\n     * Constructor for StepEditor Object. This control may be used standalone\n     * or within an InlineTimingFunctionEditor inline widget.\n     *\n     * @param {!jQuery} $parent  DOM node into which to append the root of the step editor UI\n     * @param {!RegExpMatch} stepMatch  RegExp match object of initially selected step function\n     * @param {!function(string)} callback  Called whenever selected step function changes\n     */\n    function StepEditor($parent, stepMatch, callback) {\n        // Create the DOM structure, filling in localized strings via Mustache\n        this.$element = $(Mustache.render(StepEditorTemplate, Strings));\n        $parent.append(this.$element);\n\n        this._callback = callback;\n\n        // current step function params\n        this._stepParams = this._getStepParams(stepMatch);\n\n        this.hint = {};\n        this.hint.elem = $(\".hint\", this.$element);\n        // If function was auto-corrected, then originalString holds the original function,\n        // and an informational message needs to be shown\n        if (stepMatch.originalString) {\n            TimingFunctionUtils.showHideHint(this.hint, true, stepMatch.originalString, \"steps(\" + this._stepParams.count.toString() + \", \" + this._stepParams.timing + \")\");\n        } else {\n            TimingFunctionUtils.showHideHint(this.hint, false);\n        }\n\n        this.canvas = this.$element.find(\".steps\")[0];\n\n        this.canvas.stepEditor = this;\n\n        // Padding (3rd param)is scaled, so 0.1 translates to 15px\n        // Note that this is rendered inside canvas CSS \"content\"\n        // (i.e. this does not map to CSS padding)\n        this.stepCanvas = new StepCanvas(this.canvas, null, [0.1]);\n\n        // redraw canvas\n        this._updateCanvas();\n\n        $(this.canvas).on(\"keydown\", _canvasKeyDown);\n    }\n\n    /**\n     * Destructor called by InlineTimingFunctionEditor.onClosed()\n     */\n    StepEditor.prototype.destroy = function () {\n        this.canvas.stepEditor = null;\n        $(this.canvas).off(\"keydown\", _canvasKeyDown);\n    };\n\n\n    /** Returns the root DOM node of the StepEditor UI */\n    StepEditor.prototype.getRootElement = function () {\n        return this.$element;\n    };\n\n    /**\n     * Default focus needs to go somewhere, so give it to canvas\n     */\n    StepEditor.prototype.focus = function () {\n        this.canvas.focus();\n        return true;\n    };\n\n    /**\n     * Generates step function based on parameters, and updates the doc\n     */\n    StepEditor.prototype._commitTimingFunction = function () {\n        var stepFuncVal = \"steps(\" +\n            this._stepParams.count.toString() + \", \" +\n            this._stepParams.timing + \")\";\n        this._callback(stepFuncVal);\n        TimingFunctionUtils.showHideHint(this.hint, false);\n    };\n\n    /**\n     * Handle all matches returned from TimingFunctionUtils.stepMatch() and\n     * return array of coords\n     *\n     * @param {RegExp.match} match Matches returned from stepMatch()\n     * @return {{count: number, timing: string}}\n     */\n    StepEditor.prototype._getStepParams = function (match) {\n\n        if (match[0].match(/^steps/)) {\n            // steps()\n            return {\n                count: parseInt(match[1], 10),\n                timing: match[2] || \"end\"\n            };\n        }\n            // handle special cases of steps functions\n        switch (match[0]) {\n        case \"step-start\":\n            return { count: 1, timing: \"start\" };\n        case \"step-end\":\n            return { count: 1, timing: \"end\" };\n        }\n\n\n        window.console.log(\"step timing function: _getStepParams() passed invalid RegExp match array\");\n        return { count: 1, timing: \"end\" };\n    };\n\n    /**\n     * Get <canvas> element's bounding box\n     *\n     * @return {left: number, top: number, width: number, height: number}\n     */\n    StepEditor.prototype._getCanvasBoundingBox = function () {\n        var $canvas = this.$element.find(\".steps\"),\n            canvasOffset = $canvas.offset();\n\n        return {\n            left: canvasOffset.left,\n            top: canvasOffset.top,\n            width: $canvas.width(),\n            height: $canvas.height()\n        };\n    };\n\n    /**\n     * Update <canvas> after a change\n     */\n    StepEditor.prototype._updateCanvas = function () {\n        // collect data, build model\n        if (this._stepParams) {\n            this.stepCanvas.stepParams = window.stepParams = new StepParameters(this._stepParams);\n\n            this.stepCanvas.plot();\n        }\n    };\n\n    /**\n     * Handle external update\n     *\n     * @param {!RegExpMatch} stepMatch  RegExp match object of updated step function\n     */\n    StepEditor.prototype.handleExternalUpdate = function (stepMatch) {\n        this._stepParams = this._getStepParams(stepMatch);\n        this._updateCanvas();\n        // If function was auto-corrected, then originalString holds the original function,\n        // and an informational message needs to be shown\n        if (stepMatch.originalString) {\n            TimingFunctionUtils.showHideHint(this.hint, true, stepMatch.originalString, \"steps(\" + this._stepParams.count.toString() + \", \" + this._stepParams.timing + \")\");\n        } else {\n            TimingFunctionUtils.showHideHint(this.hint, false);\n        }\n    };\n\n\n    exports.StepEditor = StepEditor;\n});\n"],"file":"StepEditor.js"}
{"version":3,"sources":["extensions/default/CodeFolding/foldhelpers/indentFold.js"],"names":["define","require","exports","module","CodeMirror","brackets","getModule","cols","countColumn","pos","Pos","lastNonEmptyLineNumber","cm","lc","lastLine","line","getLine","trim","length","indentFold","start","lineText","tabSize","getOption","lineIndent","collapsible","lineCount","token","getTokenAt","type","i","indent","currentLine","from","to"],"mappings":"AAMAA,OAAO,SAAUC,QAASC,QAASC,QAE/B,IAAIC,WAAcC,SAASC,UAAU,wCACjCC,KAAcH,WAAWI,YACzBC,IAAcL,WAAWM,IAE7B,SAASC,uBAAuBC,IAE5B,IADA,IAAIC,GAAKD,GAAGE,WAAYC,KAAOH,GAAGI,QAAQH,IACnCA,GAAK,GAA4B,IAAvBE,KAAKE,OAAOC,QACzBL,KACAE,KAAOH,GAAGI,QAAQH,IAEtB,OAAOA,GAGX,SAASM,WAAWP,GAAIQ,OACpB,IAAIC,SAAWT,GAAGI,QAAQI,MAAML,MAAOO,QAAUV,GAAGW,UAAU,WAE1DC,WAAajB,KAAKc,SAAU,KAAMC,SAAUG,aAAc,EAAOC,UAAYd,GAAGc,YAChFC,MAAQf,GAAGgB,WAAWnB,IAAIW,MAAML,KAAMS,WAAa,IAEvD,KAA+B,IAA3BH,SAASJ,OAAOC,QAAiBS,OAAwB,YAAfA,MAAME,MAApD,CAGA,IAAIC,EAAGC,OAAQC,YACf,IAAKF,EAAIV,MAAML,KAAO,EAAGe,EAAIJ,UAAWI,IAMpC,GALAE,YAAcpB,GAAGI,QAAQc,GACzBC,OAASxB,KAAKyB,YAAa,KAAMV,SAEjCK,MAAQf,GAAGgB,WAAWnB,IAAIqB,EAAGC,OAAS,IAEJ,IAA9BC,YAAYf,OAAOC,QAAiBS,OAAwB,YAAfA,MAAME,KAAqB,CACxE,GAAKJ,aAKD,GAAIM,QAAUP,WACV,MAAO,CAACS,KAAMxB,IAAIW,MAAML,KAAMM,SAASH,QACnCgB,GAAIzB,IAAIqB,EAAI,EAAGlB,GAAGI,QAAQc,EAAI,GAAGZ,cANrCa,OAASP,aACTC,aAAc,GAStB,GAAIM,SAAWP,YAAcO,OAASP,WAClC,OAKZ,OAAIC,aACAK,EAAInB,uBAAuBC,IACpB,CAACqB,KAAMxB,IAAIW,MAAML,KAAMM,SAASH,QAASgB,GAAIzB,IAAIqB,EAAGlB,GAAGI,QAAQc,GAAGZ,eAF7E,GAMJf,OAAOD,QAAUiB","sourcesContent":["/**\n * Fold range finder based on line indentations. Ignores blank lines and commented lines\n * @author Patrick Oladimeji\n * @date 12/27/13 21:54:41 PM\n */\n\ndefine(function (require, exports, module) {\n\n    var CodeMirror  = brackets.getModule(\"thirdparty/CodeMirror/lib/codemirror\"),\n        cols        = CodeMirror.countColumn,\n        pos         = CodeMirror.Pos;\n\n    function lastNonEmptyLineNumber(cm) {\n        var lc = cm.lastLine(), line = cm.getLine(lc);\n        while (lc > 0 && line.trim().length === 0) {\n            lc--;\n            line = cm.getLine(lc);\n        }\n        return lc;\n    }\n\n    function indentFold(cm, start) {\n        var lineText = cm.getLine(start.line), tabSize = cm.getOption(\"tabSize\");\n\n        var lineIndent = cols(lineText, null, tabSize), collapsible = false, lineCount = cm.lineCount();\n        var token = cm.getTokenAt(pos(start.line, lineIndent + 1));\n        //no folding for blank lines or commented lines\n        if (lineText.trim().length === 0 || (token && token.type === \"comment\")) {\n            return;\n        }\n        var i, indent, currentLine;\n        for (i = start.line + 1; i < lineCount; i++) {\n            currentLine = cm.getLine(i);\n            indent = cols(currentLine, null, tabSize);\n\n            token = cm.getTokenAt(pos(i, indent + 1));\n            //only fold for non blank lines or non commented lines\n            if (currentLine.trim().length !== 0 && (token && token.type !== \"comment\")) {\n                if (!collapsible) {\n                    if (indent > lineIndent) {\n                        collapsible = true;\n                    }\n                } else {\n                    if (indent <= lineIndent) {\n                        return {from: pos(start.line, lineText.length),\n                            to: pos(i - 1, cm.getLine(i - 1).length)};\n                    }\n                }\n\n                if (indent === lineIndent || indent < lineIndent) {\n                    return;\n                }\n            }\n        }\n        //use last nonempty line as the end of the folding region if there is no explicit end to this indent\n        if (collapsible) {\n            i = lastNonEmptyLineNumber(cm);\n            return {from: pos(start.line, lineText.length), to: pos(i, cm.getLine(i).length)};\n        }\n    }\n\n    module.exports = indentFold;\n});\n"],"file":"indentFold.js"}
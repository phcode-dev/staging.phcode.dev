{"version":3,"sources":["extensions/default/JavaScriptCodeHints/ParameterHintsProvider.js"],"names":["define","require","exports","module","ScopeManager","brackets","getModule","OVERWRITE_EXISTING_HINT","JSParameterHintsProvider","this","hintState","hintStack","preserveHintStack","session","prototype","setSession","value","isHintDisplayed","visible","pushHintOnStack","push","popHintFromStack","length","pop","clearFunctionHintStack","hasFunctionCallPosChanged","functionCallPos","oldFunctionCallPos","undefined","line","ch","cleanHintState","_getParameterHint","pushExistingHint","hint","functionInfo","result","$","Deferred","pushHint","getFunctionInfo","inFunctionCall","reject","request","setFnType","resolveWith","requestParameterHint","self","done","fnType","hints","getParameterHint","resolve","fail","hasParameterHints","getParameterHints","explicit","onCursorActivity","token","getToken","string","poppedFunctionCallPos","currentFunctionCallPos"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2013 - present Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\ndefine(function (require, exports, module) {\n\n    var ScopeManager = brackets.getModule(\"JSUtils/ScopeManager\"),\n        OVERWRITE_EXISTING_HINT = false;\n\n    function JSParameterHintsProvider() {\n        this.hintState = {};\n        this.hintStack = [];\n        this.preserveHintStack = null; // close a function hint without clearing stack\n        this.session = null; // current editor session, updated by main\n    }\n\n    /**\n     * Update the current session for use by the Function Hint Manager.\n     *\n     * @param {Session} value - current session.\n     */\n    JSParameterHintsProvider.prototype.setSession = function (value) {\n        this.session = value;\n    };\n\n    /**\n     * Test if a function hint is being displayed.\n     *\n     * @return {boolean} - true if a function hint is being displayed, false\n     * otherwise.\n     */\n    JSParameterHintsProvider.prototype.isHintDisplayed = function () {\n        return this.hintState.visible === true;\n    };\n\n    /**\n     * Save the state of the current hint. Called when popping up a parameter hint\n     * for a parameter, when the parameter already part of an existing parameter\n     * hint.\n     */\n    JSParameterHintsProvider.prototype.pushHintOnStack = function () {\n        this.hintStack.push(this.hintState);\n    };\n\n    /**\n     * Restore the state of the previous function hint.\n     *\n     * @return {boolean} - true the a parameter hint has been popped, false otherwise.\n     */\n    JSParameterHintsProvider.prototype.popHintFromStack = function () {\n        if (this.hintStack.length > 0) {\n            this.hintState = this.hintStack.pop();\n            this.hintState.visible = false;\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * Reset the function hint stack.\n     */\n    JSParameterHintsProvider.prototype.clearFunctionHintStack = function () {\n        this.hintStack = [];\n    };\n\n    /**\n     * Test if the function call at the cursor is different from the currently displayed\n     * function hint.\n     *\n     * @param {{line:number, ch:number}} functionCallPos - the offset of the function call.\n     * @return {boolean}\n     */\n    JSParameterHintsProvider.prototype.hasFunctionCallPosChanged = function (functionCallPos) {\n        var oldFunctionCallPos = this.hintState.functionCallPos;\n        return (oldFunctionCallPos === undefined ||\n            oldFunctionCallPos.line !== functionCallPos.line ||\n            oldFunctionCallPos.ch !== functionCallPos.ch);\n    };\n\n    /**\n     * Dismiss the function hint.\n     *\n     */\n    JSParameterHintsProvider.prototype.cleanHintState = function () {\n        if (this.hintState.visible) {\n            if (!this.preserveHintStack) {\n                this.clearFunctionHintStack();\n            }\n        }\n    };\n\n    /**\n     * Pop up a function hint on the line above the caret position.\n     *\n     * @param {boolean=} pushExistingHint - if true, push the existing hint on the stack. Default is false, not\n     * to push the hint.\n     * @param {string=} hint - function hint string from tern.\n     * @param {{inFunctionCall: boolean, functionCallPos:\n     * {line: number, ch: number}}=} functionInfo -\n     * if the functionInfo is already known, it can be passed in to avoid\n     * figuring it out again.\n     * @return {jQuery.Promise} - The promise will not complete until the\n     *      hint has completed. Returns null, if the function hint is already\n     *      displayed or there is no function hint at the cursor.\n     *\n     */\n    JSParameterHintsProvider.prototype._getParameterHint = function (pushExistingHint, hint, functionInfo) {\n        var result = $.Deferred();\n        functionInfo = functionInfo || this.session.getFunctionInfo();\n        if (!functionInfo.inFunctionCall) {\n            this.cleanHintState();\n            return result.reject(null);\n        }\n\n        if (this.hasFunctionCallPosChanged(functionInfo.functionCallPos)) {\n\n            var pushHint = pushExistingHint && this.isHintDisplayed();\n            if (pushHint) {\n                this.pushHintOnStack();\n                this.preserveHintStack = true;\n            }\n\n            this.cleanHintState();\n            this.preserveHintStack = false;\n        } else if (this.isHintDisplayed()) {\n            return result.reject(null);\n        }\n\n        this.hintState.functionCallPos = functionInfo.functionCallPos;\n\n        var request = null;\n        if (!hint) {\n            request = ScopeManager.requestParameterHint(this.session, functionInfo.functionCallPos);\n        } else {\n            this.session.setFnType(hint);\n            request = $.Deferred();\n            request.resolveWith(null, [hint]);\n        }\n\n        var self = this;\n        request.done(function (fnType) {\n            var hints = self.session.getParameterHint(functionInfo.functionCallPos);\n            hints.functionCallPos = functionInfo.functionCallPos;\n            result.resolve(hints);\n        }).fail(function () {\n            self.hintState = {};\n            result.reject(null);\n        });\n\n        return result;\n    };\n\n    JSParameterHintsProvider.prototype.hasParameterHints = function () {\n        var functionInfo = this.session.getFunctionInfo();\n\n        return functionInfo.inFunctionCall;\n    };\n\n    JSParameterHintsProvider.prototype.getParameterHints = function (explicit, onCursorActivity) {\n        var functionInfo = this.session.getFunctionInfo(),\n            result = null;\n\n        if (!onCursorActivity) {\n            if (functionInfo.inFunctionCall) {\n                var token = this.session.getToken();\n\n                if ((token && token.string === \"(\") || explicit) {\n                    return this._getParameterHint();\n                }\n            } else {\n                this.cleanHintState();\n            }\n\n            return $.Deferred().reject(null);\n        }\n\n        if (!functionInfo.inFunctionCall) {\n            this.cleanHintState();\n            return $.Deferred().reject(null);\n        }\n\n        // If in a different function hint, then dismiss the old one and\n        // display the new one if there is one on the stack\n        if (this.hasFunctionCallPosChanged(functionInfo.functionCallPos)) {\n            if (this.popHintFromStack()) {\n                var poppedFunctionCallPos = this.hintState.functionCallPos,\n                    currentFunctionCallPos = this.functionInfo.functionCallPos;\n\n                if (poppedFunctionCallPos.line === currentFunctionCallPos.line &&\n                        poppedFunctionCallPos.ch === currentFunctionCallPos.ch) {\n                    this.preserveHintStack = true;\n                    result = this._getParameterHint(OVERWRITE_EXISTING_HINT,\n                        this.hintState.fnType, functionInfo);\n                    this.preserveHintStack = false;\n                    return result;\n                }\n            } else {\n                this.cleanHintState();\n            }\n        }\n\n        var hints = this.session.getParameterHint(functionInfo.functionCallPos);\n        hints.functionCallPos = functionInfo.functionCallPos;\n        return $.Deferred().resolve(hints);\n    };\n\n    exports.JSParameterHintsProvider = JSParameterHintsProvider;\n});\n"],"file":"ParameterHintsProvider.js"}
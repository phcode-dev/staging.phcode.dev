{"version":3,"sources":["extensions/default/InlineColorEditor/InlineColorEditor.js"],"names":["define","require","exports","module","InlineWidget","brackets","getModule","ColorEditor","ColorUtils","MAX_USED_COLORS","lastOriginId","InlineColorEditor","color","marker","this","_color","_marker","_isOwnChange","_isHostChange","_origin","_handleColorChange","bind","_handleHostDocumentChange","call","_colorSort","a","b","count","prototype","Object","create","constructor","parentClass","colorEditor","getCurrentRange","pos","start","end","find","from","to","line","matches","hostEditor","document","getLine","substr","ch","match","COLOR_REGEX","undefined","length","clear","_codeMirror","markText","colorString","self","range","endPos","batchOperation","setSelection","replaceRange","load","apply","arguments","allColorsInDoc","getText","swatchInfo","_collateColors","$htmlContent","onAdded","doc","addRef","on","setInlineWidgetHeight","getRootElement","outerHeight","focus","onClosed","off","releaseRef","destroy","originalArray","maxLength","colorInfo","forEach","originalColor","key","toLowerCase","value","uniqueColors","$","map","info","sort","slice","newColor","getRange","isValidColor","setColorFromString","close"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var InlineWidget         = brackets.getModule(\"editor/InlineWidget\").InlineWidget,\n        ColorEditor          = require(\"ColorEditor\").ColorEditor,\n        ColorUtils           = brackets.getModule(\"utils/ColorUtils\");\n\n\n    /** @const @type {number} */\n    var MAX_USED_COLORS = 7;\n\n    /** @type {number} Global var used to provide a unique ID for each color editor instance's _origin field. */\n    var lastOriginId = 1;\n\n    /**\n     * Inline widget containing a ColorEditor control\n     * @param {!string} color  Initially selected color\n     * @param {!CodeMirror.TextMarker} marker\n     */\n    function InlineColorEditor(color, marker) {\n        this._color = color;\n        this._marker = marker;\n        this._isOwnChange = false;\n        this._isHostChange = false;\n        this._origin = \"+InlineColorEditor_\" + (lastOriginId++);\n\n        this._handleColorChange = this._handleColorChange.bind(this);\n        this._handleHostDocumentChange = this._handleHostDocumentChange.bind(this);\n\n        InlineWidget.call(this);\n    }\n\n    InlineColorEditor.prototype = Object.create(InlineWidget.prototype);\n    InlineColorEditor.prototype.constructor = InlineColorEditor;\n    InlineColorEditor.prototype.parentClass = InlineWidget.prototype;\n\n    /** @type {!ColorPicker} ColorPicker instance */\n    InlineColorEditor.prototype.colorEditor = null;\n\n    /** @type {!string} Current value of the color picker control */\n    InlineColorEditor.prototype._color = null;\n\n    /**\n     * Range of code we're attached to; _marker.find() may by null if sync is lost.\n     * @type {!CodeMirror.TextMarker}\n     */\n    InlineColorEditor.prototype._marker = null;\n\n    /** @type {boolean} True while we're syncing a color picker change into the code editor */\n    InlineColorEditor.prototype._isOwnChange = null;\n\n    /** @type {boolean} True while we're syncing a code editor change into the color picker */\n    InlineColorEditor.prototype._isHostChange = null;\n\n    /** @type {number} ID used to identify edits coming from this inline widget for undo batching */\n    InlineColorEditor.prototype._origin = null;\n\n\n    /**\n     * Returns the current text range of the color we're attached to, or null if\n     * we've lost sync with what's in the code.\n     * @return {?{start:{line:number, ch:number}, end:{line:number, ch:number}}}\n     */\n    InlineColorEditor.prototype.getCurrentRange = function () {\n        var pos, start, end;\n\n        pos = this._marker && this._marker.find();\n\n        start = pos && pos.from;\n        if (!start) {\n            return null;\n        }\n\n        end = pos.to;\n        if (!end) {\n            end = {line: start.line};\n        }\n\n        // Even if we think we have a good range end, we want to run the\n        // regexp match to see if there's a valid match that extends past the marker.\n        // This can happen if the user deletes the end of the existing color and then\n        // types some more.\n\n        var line = this.hostEditor.document.getLine(start.line),\n            matches = line.substr(start.ch).match(ColorUtils.COLOR_REGEX);\n\n        // Note that end.ch is exclusive, so we don't need to add 1 before comparing to\n        // the matched length here.\n        if (matches && (end.ch === undefined || end.ch - start.ch < matches[0].length)) {\n            end.ch = start.ch + matches[0].length;\n            this._marker.clear();\n            this._marker = this.hostEditor._codeMirror.markText(start, end);\n        }\n\n        if (end.ch === undefined) {\n            // We were unable to resync the marker.\n            return null;\n        }\n        return {start: start, end: end};\n\n    };\n\n    /**\n     * When the color picker's selected color changes, update text in code editor\n     * @param {!string} colorString\n     */\n    InlineColorEditor.prototype._handleColorChange = function (colorString) {\n        var self = this;\n        if (colorString !== this._color) {\n            var range = this.getCurrentRange();\n\n            if (!range) {\n                return;\n            }\n\n            // Don't push the change back into the host editor if it came from the host editor.\n            if (!this._isHostChange) {\n                var endPos = {\n                    line: range.start.line,\n                    ch: range.start.ch + colorString.length\n                };\n                this._isOwnChange = true;\n                this.hostEditor.document.batchOperation(function () {\n                    // Replace old color in code with the picker's color, and select it\n                    self.hostEditor.setSelection(range.start, range.end); // workaround for #2805\n                    self.hostEditor.document.replaceRange(colorString, range.start, range.end, self._origin);\n                    self.hostEditor.setSelection(range.start, endPos);\n                    if (self._marker) {\n                        self._marker.clear();\n                        self._marker = self.hostEditor._codeMirror.markText(range.start, endPos);\n                    }\n                });\n                this._isOwnChange = false;\n            }\n\n            this._color = colorString;\n        }\n    };\n\n    /**\n     * @override\n     * @param {!Editor} hostEditor\n     */\n    InlineColorEditor.prototype.load = function (hostEditor) {\n        InlineColorEditor.prototype.parentClass.load.apply(this, arguments);\n\n        // Create color picker control\n        var allColorsInDoc = this.hostEditor.document.getText().match(ColorUtils.COLOR_REGEX);\n        var swatchInfo = this._collateColors(allColorsInDoc, MAX_USED_COLORS);\n        this.colorEditor = new ColorEditor(this.$htmlContent, this._color, this._handleColorChange, swatchInfo);\n    };\n\n    /**\n     * @override\n     * Perform sizing & focus once we've been added to Editor's DOM\n     */\n    InlineColorEditor.prototype.onAdded = function () {\n        InlineColorEditor.prototype.parentClass.onAdded.apply(this, arguments);\n\n        var doc = this.hostEditor.document;\n        doc.addRef();\n        doc.on(\"change\", this._handleHostDocumentChange);\n\n        this.hostEditor.setInlineWidgetHeight(this, this.colorEditor.getRootElement().outerHeight(), true);\n\n        this.colorEditor.focus();\n    };\n\n    /**\n     * @override\n     * Called whenever the inline widget is closed, whether automatically or explicitly\n     */\n    InlineColorEditor.prototype.onClosed = function () {\n        InlineColorEditor.prototype.parentClass.onClosed.apply(this, arguments);\n\n        if (this._marker) {\n            this._marker.clear();\n        }\n\n        var doc = this.hostEditor.document;\n        doc.off(\"change\", this._handleHostDocumentChange);\n        doc.releaseRef();\n        this.colorEditor.destroy();\n    };\n\n    /** Comparator to sort by which colors are used the most */\n    function _colorSort(a, b) {\n        if (a.count === b.count) {\n            return 0;\n        }\n        if (a.count > b.count) {\n            return -1;\n        }\n        if (a.count < b.count) {\n            return 1;\n        }\n    }\n\n    /**\n     * Counts how many times each color in originalArray occurs (ignoring case) and\n     * retuns the top 'maxLength' number of unique colors.\n     * @param {!Array.<string>} originalArray\n     * @param {number} maxLength\n     * @return {!Array.<{value:string, count:number}>}\n     */\n    InlineColorEditor.prototype._collateColors = function (originalArray, maxLength) {\n        // Maps from lowercase color name to swatch info (user-case color name & occurrence count)\n        /* @type {Object.<string, {value:string, count:number}>} */\n        var colorInfo = {};\n\n        // Count how many times each color is used\n        originalArray.forEach(function (originalColor) {\n            var key = originalColor.toLowerCase();\n            if (colorInfo[key]) {\n                colorInfo[key].count++;\n            } else {\n                colorInfo[key] = { value: originalColor, count: 1 };\n            }\n        });\n\n        // Convert to an array\n        var uniqueColors = $.map(colorInfo, function (info) {\n            return info;\n        });\n\n        // Sort by most-used and return the top N\n        uniqueColors.sort(_colorSort);\n        return uniqueColors.slice(0, maxLength);\n    };\n\n    /**\n     * When text in the code editor changes, update color picker to reflect it\n     */\n    InlineColorEditor.prototype._handleHostDocumentChange = function () {\n        // Don't push the change into the color editor if it came from the color editor.\n        if (this._isOwnChange) {\n            return;\n        }\n\n        var range = this.getCurrentRange();\n        if (range) {\n            var newColor = this.hostEditor.document.getRange(range.start, range.end);\n            if (newColor !== this._color) {\n                if (this.colorEditor.isValidColor(newColor)) { // only update the editor if the color string is valid\n                    this._isHostChange = true;\n                    this.colorEditor.setColorFromString(newColor);\n                    this._isHostChange = false;\n                }\n            }\n        } else {\n            // The edit caused our range to become invalid. Close the editor.\n            this.close();\n        }\n    };\n\n    exports.InlineColorEditor = InlineColorEditor;\n});\n"],"file":"InlineColorEditor.js"}
{"version":3,"sources":["thirdparty/CodeMirror/addon/comment/continuecomment.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","nonspace","repeat","String","prototype","n","Array","join","this","continueComment","cm","getOption","Pass","ranges","listSelections","mode","inserts","i","length","pos","head","test","getTokenTypeAt","modeHere","getModeAt","insert","line","found","blockStart","blockCommentStart","lineCmt","lineComment","blockCommentContinue","end","getLine","lastIndexOf","blockCommentEnd","ch","nonspaceAfter","slice","tabSize","options","numTabs","countColumn","indentWithTabs","call","Math","floor","indexOf","continueLineCommentEnabled","next","nextFound","match","operation","replaceRange","from","to","str","lastIndex","m","exec","index","opt","continueLineComment","defineOption","val","prev","Init","removeKeyMap","key","map","name","addKeyMap"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var nonspace = /\\S/g;\n  var repeat = String.prototype.repeat || function (n) { return Array(n + 1).join(this); };\n  function continueComment(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    var ranges = cm.listSelections(), mode, inserts = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].head\n      if (!/\\bcomment\\b/.test(cm.getTokenTypeAt(pos))) return CodeMirror.Pass;\n      var modeHere = cm.getModeAt(pos)\n      if (!mode) mode = modeHere;\n      else if (mode != modeHere) return CodeMirror.Pass;\n\n      var insert = null, line, found;\n      var blockStart = mode.blockCommentStart, lineCmt = mode.lineComment;\n      if (blockStart && mode.blockCommentContinue) {\n        line = cm.getLine(pos.line);\n        var end = line.lastIndexOf(mode.blockCommentEnd, pos.ch - mode.blockCommentEnd.length);\n        // 1. if this block comment ended\n        // 2. if this is actually inside a line comment\n        if (end != -1 && end == pos.ch - mode.blockCommentEnd.length ||\n            lineCmt && (found = line.lastIndexOf(lineCmt, pos.ch - 1)) > -1 &&\n            /\\bcomment\\b/.test(cm.getTokenTypeAt({line: pos.line, ch: found + 1}))) {\n          // ...then don't continue it\n        } else if (pos.ch >= blockStart.length &&\n                   (found = line.lastIndexOf(blockStart, pos.ch - blockStart.length)) > -1 &&\n                   found > end) {\n          // reuse the existing leading spaces/tabs/mixed\n          // or build the correct indent using CM's tab/indent options\n          if (nonspaceAfter(0, line) >= found) {\n            insert = line.slice(0, found);\n          } else {\n            var tabSize = cm.options.tabSize, numTabs;\n            found = CodeMirror.countColumn(line, found, tabSize);\n            insert = !cm.options.indentWithTabs ? repeat.call(\" \", found) :\n              repeat.call(\"\\t\", (numTabs = Math.floor(found / tabSize))) +\n              repeat.call(\" \", found - tabSize * numTabs);\n          }\n        } else if ((found = line.indexOf(mode.blockCommentContinue)) > -1 &&\n                   found <= pos.ch &&\n                   found <= nonspaceAfter(0, line)) {\n          insert = line.slice(0, found);\n        }\n        if (insert != null) insert += mode.blockCommentContinue\n      }\n      if (insert == null && lineCmt && continueLineCommentEnabled(cm)) {\n        if (line == null) line = cm.getLine(pos.line);\n        found = line.indexOf(lineCmt);\n        // cursor at pos 0, line comment also at pos 0 => shift it down, don't continue\n        if (!pos.ch && !found) insert = \"\";\n        // continue only if the line starts with an optional space + line comment\n        else if (found > -1 && nonspaceAfter(0, line) >= found) {\n          // don't continue if there's only space(s) after cursor or the end of the line\n          insert = nonspaceAfter(pos.ch, line) > -1;\n          // but always continue if the next line starts with a line comment too\n          if (!insert) {\n            var next = cm.getLine(pos.line + 1) || '',\n                nextFound = next.indexOf(lineCmt);\n            insert = nextFound > -1 && nonspaceAfter(0, next) >= nextFound || null;\n          }\n          if (insert) {\n            insert = line.slice(0, found) + lineCmt +\n                     line.slice(found + lineCmt.length).match(/^\\s*/)[0];\n          }\n        }\n      }\n      if (insert == null) return CodeMirror.Pass;\n      inserts[i] = \"\\n\" + insert;\n    }\n\n    cm.operation(function() {\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(inserts[i], ranges[i].from(), ranges[i].to(), \"+insert\");\n    });\n  }\n\n  function nonspaceAfter(ch, str) {\n    nonspace.lastIndex = ch;\n    var m = nonspace.exec(str);\n    return m ? m.index : -1;\n  }\n\n  function continueLineCommentEnabled(cm) {\n    var opt = cm.getOption(\"continueComments\");\n    if (opt && typeof opt == \"object\")\n      return opt.continueLineComment !== false;\n    return true;\n  }\n\n  CodeMirror.defineOption(\"continueComments\", null, function(cm, val, prev) {\n    if (prev && prev != CodeMirror.Init)\n      cm.removeKeyMap(\"continueComment\");\n    if (val) {\n      var key = \"Enter\";\n      if (typeof val == \"string\")\n        key = val;\n      else if (typeof val == \"object\" && val.key)\n        key = val.key;\n      var map = {name: \"continueComment\"};\n      map[key] = continueComment;\n      cm.addKeyMap(map);\n    }\n  });\n});\n"],"file":"continuecomment.js"}
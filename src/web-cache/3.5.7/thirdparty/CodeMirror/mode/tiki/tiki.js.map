{"version":3,"sources":["thirdparty/CodeMirror/mode/tiki/tiki.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","inBlock","style","terminator","returnTokenizer","stream","state","eol","match","tokenize","inText","next","inLine","chain","parser","sol","ch","eat","eatSpace","eatWhile","inPlugin","indentUnit","pluginName","type","curState","setStyle","peek","test","inAttributeNoQuote","inAttribute","quote","pass","i","arguments","length","cc","push","cont","apply","pushContext","startOfLine","noIndent","context","prev","indent","indented","popContext","element","attributes","endplugin","err","endcloseplugin","name","attvalue","attvaluemaybe","startState","token","indentation","comb","pop","textAfter","electricChars","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode('tiki', function(config) {\n  function inBlock(style, terminator, returnTokenizer) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n\n      if (returnTokenizer) state.tokenize = returnTokenizer;\n\n      return style;\n    };\n  }\n\n  function inLine(style) {\n    return function(stream, state) {\n      while(!stream.eol()) {\n        stream.next();\n      }\n      state.tokenize = inText;\n      return style;\n    };\n  }\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var sol = stream.sol();\n    var ch = stream.next();\n\n    //non start of line\n    switch (ch) { //switch is generally much faster than if, so it is used here\n    case \"{\": //plugin\n      stream.eat(\"/\");\n      stream.eatSpace();\n      stream.eatWhile(/[^\\s\\u00a0=\\\"\\'\\/?(}]/);\n      state.tokenize = inPlugin;\n      return \"tag\";\n    case \"_\": //bold\n      if (stream.eat(\"_\"))\n        return chain(inBlock(\"strong\", \"__\", inText));\n      break;\n    case \"'\": //italics\n      if (stream.eat(\"'\"))\n        return chain(inBlock(\"em\", \"''\", inText));\n      break;\n    case \"(\":// Wiki Link\n      if (stream.eat(\"(\"))\n        return chain(inBlock(\"variable-2\", \"))\", inText));\n      break;\n    case \"[\":// Weblink\n      return chain(inBlock(\"variable-3\", \"]\", inText));\n      break;\n    case \"|\": //table\n      if (stream.eat(\"|\"))\n        return chain(inBlock(\"comment\", \"||\"));\n      break;\n    case \"-\":\n      if (stream.eat(\"=\")) {//titleBar\n        return chain(inBlock(\"header string\", \"=-\", inText));\n      } else if (stream.eat(\"-\")) {//deleted\n        return chain(inBlock(\"error tw-deleted\", \"--\", inText));\n      }\n      break;\n    case \"=\": //underline\n      if (stream.match(\"==\"))\n        return chain(inBlock(\"tw-underline\", \"===\", inText));\n      break;\n    case \":\":\n      if (stream.eat(\":\"))\n        return chain(inBlock(\"comment\", \"::\"));\n      break;\n    case \"^\": //box\n      return chain(inBlock(\"tw-box\", \"^\"));\n      break;\n    case \"~\": //np\n      if (stream.match(\"np~\"))\n        return chain(inBlock(\"meta\", \"~/np~\"));\n      break;\n    }\n\n    //start of line types\n    if (sol) {\n      switch (ch) {\n      case \"!\": //header at start of line\n        if (stream.match('!!!!!')) {\n          return chain(inLine(\"header string\"));\n        } else if (stream.match('!!!!')) {\n          return chain(inLine(\"header string\"));\n        } else if (stream.match('!!!')) {\n          return chain(inLine(\"header string\"));\n        } else if (stream.match('!!')) {\n          return chain(inLine(\"header string\"));\n        } else {\n          return chain(inLine(\"header string\"));\n        }\n        break;\n      case \"*\": //unordered list line item, or <li /> at start of line\n      case \"#\": //ordered list line item, or <li /> at start of line\n      case \"+\": //ordered list line item, or <li /> at start of line\n        return chain(inLine(\"tw-listitem bracket\"));\n        break;\n      }\n    }\n\n    //stream.eatWhile(/[&{]/); was eating up plugins, turned off to act less like html and more like tiki\n    return null;\n  }\n\n  var indentUnit = config.indentUnit;\n\n  // Return variables for tokenizers\n  var pluginName, type;\n  function inPlugin(stream, state) {\n    var ch = stream.next();\n    var peek = stream.peek();\n\n    if (ch == \"}\") {\n      state.tokenize = inText;\n      //type = ch == \")\" ? \"endPlugin\" : \"selfclosePlugin\"; inPlugin\n      return \"tag\";\n    } else if (ch == \"(\" || ch == \")\") {\n      return \"bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n\n      if (peek == \">\") {\n        stream.next();\n        peek = stream.peek();\n      }\n\n      //here we detect values directly after equal character with no quotes\n      if (!/[\\'\\\"]/.test(peek)) {\n        state.tokenize = inAttributeNoQuote();\n      }\n      //end detect values\n\n      return \"operator\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      return state.tokenize(stream, state);\n    } else {\n      stream.eatWhile(/[^\\s\\u00a0=\\\"\\'\\/?]/);\n      return \"keyword\";\n    }\n  }\n\n  function inAttribute(quote) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inPlugin;\n          break;\n        }\n      }\n      return \"string\";\n    };\n  }\n\n  function inAttributeNoQuote() {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        var ch = stream.next();\n        var peek = stream.peek();\n        if (ch == \" \" || ch == \",\" || /[ )}]/.test(peek)) {\n      state.tokenize = inPlugin;\n      break;\n    }\n  }\n  return \"string\";\n};\n                     }\n\nvar curState, setStyle;\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);\n}\n\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\n\nfunction pushContext(pluginName, startOfLine) {\n  var noIndent = curState.context && curState.context.noIndent;\n  curState.context = {\n    prev: curState.context,\n    pluginName: pluginName,\n    indent: curState.indented,\n    startOfLine: startOfLine,\n    noIndent: noIndent\n  };\n}\n\nfunction popContext() {\n  if (curState.context) curState.context = curState.context.prev;\n}\n\nfunction element(type) {\n  if (type == \"openPlugin\") {curState.pluginName = pluginName; return cont(attributes, endplugin(curState.startOfLine));}\n  else if (type == \"closePlugin\") {\n    var err = false;\n    if (curState.context) {\n      err = curState.context.pluginName != pluginName;\n      popContext();\n    } else {\n      err = true;\n    }\n    if (err) setStyle = \"error\";\n    return cont(endcloseplugin(err));\n  }\n  else if (type == \"string\") {\n    if (!curState.context || curState.context.name != \"!cdata\") pushContext(\"!cdata\");\n    if (curState.tokenize == inText) popContext();\n    return cont();\n  }\n  else return cont();\n}\n\nfunction endplugin(startOfLine) {\n  return function(type) {\n    if (\n      type == \"selfclosePlugin\" ||\n        type == \"endPlugin\"\n    )\n      return cont();\n    if (type == \"endPlugin\") {pushContext(curState.pluginName, startOfLine); return cont();}\n    return cont();\n  };\n}\n\nfunction endcloseplugin(err) {\n  return function(type) {\n    if (err) setStyle = \"error\";\n    if (type == \"endPlugin\") return cont();\n    return pass();\n  };\n}\n\nfunction attributes(type) {\n  if (type == \"keyword\") {setStyle = \"attribute\"; return cont(attributes);}\n  if (type == \"equals\") return cont(attvalue, attributes);\n  return pass();\n}\nfunction attvalue(type) {\n  if (type == \"keyword\") {setStyle = \"string\"; return cont();}\n  if (type == \"string\") return cont(attvaluemaybe);\n  return pass();\n}\nfunction attvaluemaybe(type) {\n  if (type == \"string\") return cont(attvaluemaybe);\n  else return pass();\n}\nreturn {\n  startState: function() {\n    return {tokenize: inText, cc: [], indented: 0, startOfLine: true, pluginName: null, context: null};\n  },\n  token: function(stream, state) {\n    if (stream.sol()) {\n      state.startOfLine = true;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n\n    setStyle = type = pluginName = null;\n    var style = state.tokenize(stream, state);\n    if ((style || type) && style != \"comment\") {\n      curState = state;\n      while (true) {\n        var comb = state.cc.pop() || element;\n        if (comb(type || style)) break;\n      }\n    }\n    state.startOfLine = false;\n    return setStyle || style;\n  },\n  indent: function(state, textAfter) {\n    var context = state.context;\n    if (context && context.noIndent) return 0;\n    if (context && /^{\\//.test(textAfter))\n        context = context.prev;\n    while (context && !context.startOfLine)\n        context = context.prev;\n    if (context) return context.indent + indentUnit;\n    else return 0;\n  },\n  electricChars: \"/\"\n};\n});\n\nCodeMirror.defineMIME(\"text/tiki\", \"tiki\");\n\n});\n"],"file":"tiki.js"}
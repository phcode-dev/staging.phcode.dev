{"version":3,"sources":["thirdparty/tern/lib/condense.js"],"names":["root","mod","exports","module","require","define","amd","tern","this","infer","State","origins","name","options","cx","server","parent","signal","maxOrigin","Infinity","i","length","Math","max","indexOf","output","!name","!define","types","Object","create","altPaths","patchUp","roots","pathLen","path","len","pos","dot","charAt","hop","obj","prop","prototype","hasOwnProperty","call","isSimpleInstance","o","proto","Fn","protos","hasCtor","reach","type","id","state","byName","actual","getType","orig","origin","relevant","origPos","isTarget","newPath","oldPath","shorter","Prim","reached","data","span","getSpan","doc","metaData","reachByName","aval","patchUpSimpleInstance","nameOverride","props","createPath","parts","base","defs","part","me","store","out","info","typeName","protoName","storeAlt","split","last","pop","known","join","constructor","Obj","condense","topScope","hasDef","_def","simplify","sortOutput","node","spans","srv","file","originNode","findFile","start","end","pStart","asLineChar","pEnd","line","ch","Arr","concrete","tuple","getProp","String","args","retval","condenseForceInclude","push","hasProps","typeNameStack","value","isType","Type","sort","sawType","sawOther","sortObject","AVal","simplified","simplifyTypes","strs","ANull","Sym","asPropName","content","generator","argNames","computeRetSource","isEmpty"],"mappings":"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","sourcesContent":["// Condensing an inferred set of types to a JSON description document.\n\n// This code can be used to, after a library has been analyzed,\n// extract the types defined in that library and dump them as a JSON\n// structure (as parsed by def.js).\n\n// The idea being that big libraries can be analyzed once, dumped, and\n// then cheaply included in later analysis.\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    return mod(exports, require(\"./infer\"));\n  if (typeof define == \"function\" && define.amd) // AMD\n    return define([\"exports\", \"./infer\"], mod);\n  mod(root.tern || (root.tern = {}), tern); // Plain browser env\n})(this, function(exports, infer) {\n  \"use strict\";\n\n  exports.condense = function(origins, name, options) {\n    if (typeof origins == \"string\") origins = [origins];\n    var state = new State(origins, name || origins[0], options || {});\n\n    state.server.signal(\"preCondenseReach\", state);\n\n    state.cx.topScope.path = \"<top>\";\n    state.cx.topScope.reached(\"\", state);\n    for (var path in state.roots)\n      reach(state.roots[path], null, path, state);\n    for (var i = 0; i < state.patchUp.length; ++i)\n      patchUpSimpleInstance(state.patchUp[i], state);\n\n    state.server.signal(\"postCondenseReach\", state);\n\n    for (var path in state.types)\n      store(createPath(path.split(\".\"), state), state.types[path], state);\n    for (var path in state.altPaths)\n      storeAlt(path, state.altPaths[path], state);\n    var hasDef = false;\n    for (var _def in state.output[\"!define\"]) { hasDef = true; break; }\n    if (!hasDef) delete state.output[\"!define\"];\n\n    state.server.signal(\"postCondense\", state);\n\n    return simplify(state.output, state.options.sortOutput);\n  };\n\n  function State(origins, name, options) {\n    this.origins = origins;\n    this.cx = infer.cx();\n    this.server = options.server || this.cx.parent || {signal: function() {}};\n    this.maxOrigin = -Infinity;\n    for (var i = 0; i < origins.length; ++i)\n      this.maxOrigin = Math.max(this.maxOrigin, this.cx.origins.indexOf(origins[i]));\n    this.output = {\"!name\": name, \"!define\": {}};\n    this.options = options;\n    this.types = Object.create(null);\n    this.altPaths = Object.create(null);\n    this.patchUp = [];\n    this.roots = Object.create(null);\n  }\n\n  State.prototype.isTarget = function(origin) {\n    return this.origins.indexOf(origin) > -1;\n  };\n\n  State.prototype.getSpan = function(node) {\n    if (this.options.spans == false || !this.isTarget(node.origin)) return null;\n    if (node.span) return node.span;\n    var srv = this.cx.parent, file;\n    if (!srv || !node.originNode || !(file = srv.findFile(node.origin))) return null;\n    var start = node.originNode.start, end = node.originNode.end;\n    var pStart = file.asLineChar(start), pEnd = file.asLineChar(end);\n    return start + \"[\" + pStart.line + \":\" + pStart.ch + \"]-\" +\n      end + \"[\" + pEnd.line + \":\" + pEnd.ch + \"]\";\n  };\n\n  function pathLen(path) {\n    var len = 1, pos = 0, dot;\n    while ((dot = path.indexOf(\".\", pos)) != -1) {\n      pos = dot + 1;\n      len += path.charAt(pos) == \"!\" ? 10 : 1;\n    }\n    return len;\n  }\n\n  function hop(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  function isSimpleInstance(o) {\n    return o.proto && !(o instanceof infer.Fn) && o.proto != infer.cx().protos.Object &&\n      o.proto.hasCtor && !o.hasCtor;\n  }\n\n  function reach(type, path, id, state, byName) {\n    var actual = type.getType(false);\n    if (!actual) return;\n    var orig = type.origin || actual.origin, relevant = false;\n    if (orig) {\n      var origPos = state.cx.origins.indexOf(orig);\n      // This is a path that is newer than the code we are interested in.\n      if (origPos > state.maxOrigin) return;\n      relevant = state.isTarget(orig);\n    }\n    var newPath = path ? path + \".\" + id : id, oldPath = actual.path;\n    var shorter = !oldPath || pathLen(oldPath) > pathLen(newPath);\n    if (shorter) {\n      if (!(actual instanceof infer.Prim)) actual.path = newPath;\n      if (actual.reached(newPath, state, !relevant) && relevant) {\n        var data = state.types[oldPath];\n        if (data) {\n          delete state.types[oldPath];\n          state.altPaths[oldPath] = actual;\n        } else data = {type: actual};\n        data.span = state.getSpan(type) || (actual != type && state.isTarget(actual.origin) && state.getSpan(actual)) || data.span;\n        data.doc = type.doc || (actual != type && state.isTarget(actual.origin) && actual.doc) || data.doc;\n        data.data = actual.metaData;\n        data.byName = data.byName == null ? !!byName : data.byName && byName;\n        state.types[newPath] = data;\n      }\n    } else {\n      if (relevant) state.altPaths[newPath] = actual;\n    }\n  }\n  function reachByName(aval, path, id, state) {\n    var type = aval.getType();\n    if (type) reach(type, path, id, state, true);\n  }\n\n  infer.Prim.prototype.reached = function() {return true;};\n\n  infer.Arr.prototype.reached = function(path, state, concrete) {\n    if (concrete) return true;\n    if (this.tuple) {\n      for (var i = 0; i < this.tuple; i++)\n        reachByName(this.getProp(String(i)), path, String(i), state);\n    } else {\n      reachByName(this.getProp(\"<i>\"), path, \"<i>\", state);\n    }\n    return true;\n  };\n\n  infer.Fn.prototype.reached = function(path, state, concrete) {\n    infer.Obj.prototype.reached.call(this, path, state, concrete);\n    if (!concrete) {\n      for (var i = 0; i < this.args.length; ++i)\n        reachByName(this.args[i], path, \"!\" + i, state);\n      reachByName(this.retval, path, \"!ret\", state);\n    }\n    return true;\n  };\n\n  infer.Obj.prototype.reached = function(path, state, concrete) {\n    if (isSimpleInstance(this) && !this.condenseForceInclude) {\n      if (state.patchUp.indexOf(this) == -1) state.patchUp.push(this);\n      return true;\n    } else if (this.proto && !concrete) {\n      reach(this.proto, path, \"!proto\", state);\n    }\n    var hasProps = false;\n    for (var prop in this.props) {\n      reach(this.props[prop], path, prop, state);\n      hasProps = true;\n    }\n    if (!hasProps && !this.condenseForceInclude && !(this instanceof infer.Fn)) {\n      this.nameOverride = \"?\";\n      return false;\n    }\n    return true;\n  };\n\n  function patchUpSimpleInstance(obj, state) {\n    var path = obj.proto.hasCtor.path;\n    if (path) {\n      obj.nameOverride = \"+\" + path;\n    } else {\n      path = obj.path;\n    }\n    for (var prop in obj.props)\n      reach(obj.props[prop], path, prop, state);\n  }\n\n  function createPath(parts, state) {\n    var base = state.output, defs = state.output[\"!define\"];\n    for (var i = 0, path; i < parts.length; ++i) {\n      var part = parts[i];\n      path = path ? path + \".\" + part : part;\n      var me = state.types[path];\n      if (part.charAt(0) == \"!\" || me && me.byName) {\n        if (hop(defs, path)) base = defs[path];\n        else defs[path] = base = {};\n      } else {\n        if (hop(base, parts[i])) base = base[part];\n        else base = base[part] = {};\n      }\n    }\n    return base;\n  }\n\n  function store(out, info, state) {\n    var name = typeName(info.type);\n    if (name != info.type.path && name != \"?\") {\n      out[\"!type\"] = name;\n    } else if (info.type.proto && info.type.proto != state.cx.protos.Object) {\n      var protoName = typeName(info.type.proto);\n      if (protoName != \"?\") out[\"!proto\"] = protoName;\n    }\n    if (info.span) out[\"!span\"] = info.span;\n    if (info.doc) out[\"!doc\"] = info.doc;\n    if (info.data) out[\"!data\"] = info.data;\n  }\n\n  function storeAlt(path, type, state) {\n    var parts = path.split(\".\"), last = parts.pop();\n    if (last[0] == \"!\") return;\n    var known = state.types[parts.join(\".\")];\n    var base = createPath(parts, state);\n    if (known && known.type.constructor != infer.Obj) return;\n    if (!hop(base, last)) base[last] = type.nameOverride || type.path;\n  }\n\n  var typeNameStack = [];\n  function typeName(value) {\n    var isType = value instanceof infer.Type;\n    if (isType) {\n      if (typeNameStack.indexOf(value) > -1)\n        return value.path || \"?\";\n      typeNameStack.push(value);\n    }\n    var name = value.typeName();\n    if (isType) typeNameStack.pop();\n    return name;\n  }\n\n  infer.AVal.prototype.typeName = function() {\n    if (this.types.length == 0) return \"?\";\n    if (this.types.length == 1) return typeName(this.types[0]);\n    var simplified = infer.simplifyTypes(this.types);\n    if (simplified.length > 2) return \"?\";\n    for (var strs = [], i = 0; i < simplified.length; i++)\n      strs.push(typeName(simplified[i]));\n    return strs.join(\"|\");\n  };\n\n  infer.ANull.typeName = function() { return \"?\"; };\n\n  infer.Prim.prototype.typeName = function() { return this.name; };\n\n  infer.Sym.prototype.typeName = function() { return this.asPropName };\n\n  infer.Arr.prototype.typeName = function() {\n    if (!this.tuple) return \"[\" + typeName(this.getProp(\"<i>\")) + \"]\";\n    var content = [];\n    for (var i = 0; i < this.tuple; i++)\n      content.push(typeName(this.getProp(String(i))));\n    return \"[\" + content.join(\", \") + \"]\";\n  };\n\n  infer.Fn.prototype.typeName = function() {\n    var out = this.generator ? \"fn*(\" : \"fn(\";\n    for (var i = 0; i < this.args.length; ++i) {\n      if (i) out += \", \";\n      var name = this.argNames[i];\n      if (name && name != \"?\") out += name + \": \";\n      out += typeName(this.args[i]);\n    }\n    out += \")\";\n    if (this.computeRetSource)\n      out += \" -> \" + this.computeRetSource;\n    else if (!this.retval.isEmpty())\n      out += \" -> \" + typeName(this.retval);\n    return out;\n  };\n\n  infer.Obj.prototype.typeName = function() {\n    if (this.nameOverride) return this.nameOverride;\n    if (!this.path) return \"?\";\n    return this.path;\n  };\n\n  function simplify(data, sort) {\n    if (typeof data != \"object\") return data;\n    var sawType = false, sawOther = false;\n    for (var prop in data) {\n      if (prop == \"!type\") sawType = true;\n      else sawOther = true;\n      if (prop != \"!data\")\n        data[prop] = simplify(data[prop], sort);\n    }\n    if (sawType && !sawOther) return data[\"!type\"];\n    return sort ? sortObject(data) : data;\n  }\n\n  function sortObject(obj) {\n    var props = [], out = {};\n    for (var prop in obj) props.push(prop);\n    props.sort();\n    for (var i = 0; i < props.length; ++i) {\n      var prop = props[i];\n      out[prop] = obj[prop];\n    }\n    return out;\n  }\n});\n"],"file":"condense.js"}
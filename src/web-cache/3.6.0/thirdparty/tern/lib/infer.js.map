{"version":3,"sources":["thirdparty/tern/lib/infer.js"],"names":["root","mod","exports","module","require","define","amd","tern","acorn","loose","walk","def","signal","this","acorn_loose","toString","type","maxDepth","parent","ANull","mixin","addType","propagate","getProp","forAllProps","hasType","isEmpty","getFunctionType","getObjType","getSymbolType","getType","gatherProperties","propagatesTo","typeHint","propHint","extend","proto","props","obj","Object","create","prop","WG_DEFAULT","WG_NEW_INSTANCE","WG_MADEUP_PROTO","WG_MULTI_MEMBER","WG_CATCH_ERROR","WG_PHANTOM_OBJ","WG_GLOBAL_THIS","WG_SPECULATIVE_THIS","WG_SPECULATIVE_PROTO_THIS","AVal","types","forward","maxWeight","similarAVal","a","b","depth","typeA","typeB","similarType","constructor","Arr","Obj","propsA","propsB","same","Math","max","Fn","args","length","every","tp","i","retval","self","innerA","innerB","prototype","weight","indexOf","push","withWorklist","add","target","Type","Muffle","ignoredProp","found","GetProp","c","ForAllProps","seen","name","Sym","guess","makeupType","canonicalType","simplified","simplifyTypes","map","join","makeupPropType","propName","propertyName","protoProp","hasProp","fromProto","computedProp","val","computed","propertyOf","hint","guessing","foundProp","cx","completingProperty","objs","objsWithProp","matches","search","hasCtor","getInstance","canon","f","guessProperties","guessed","outer","j","similar","arrays","fns","prim","Prim","kinds","maxScore","maxTp","score","constraint","methods","ctor","origin","curOrigin","construct","apply","arguments","m","hasOwnProperty","test","pathExt","DefProp","PropHasSubset","originNode","defProp","withDisabledComputing","fn","body","disabledComputing","prev","result","IsCallee","argNodes","disabled","isArrowFn","topScope","compute","computeRet","d","old","async","generator","defs","definitions","ecmascript","rtnval","maybeIterator","names","HasMethodCall","callee","IsCtor","noReuse","options","reuseInstances","IsProto","instances","cur","instance","o","_weight","count","protos","Array","FnPrototype","adder","SpeculativeThis","_prop","local","IsAdded","other","str","num","IfObj","t","HasProto","replaceProto","inner","min","w","isInteger","c0","charCodeAt","match","exec","maybeProps","etc","sort","searchProto","normalizeIntegerProp","p","av","maybeUnregProtoPropHandler","broadcastProp","ensureMaybeProps","_","Scope","registerProp","onNewProp","h","onProtoProp","_local","maybe","unregPropHandler","removeProp","_n","handler","splice","charAt","geckoIterators","StopIteration","argNames","call","Function","known","contentType","content","isArray","tuple","String","Symbol","symName","data","asPropName","getSymbol","cleanName","replace","symbols","Context","origins","paths","purgeGen","workList","curSuperCtor","curSuper","withContext","RegExp","Number","Boolean","bool","load","startAnalysis","timeout","context","TimedOut","message","stack","Error","withTimeout","ms","end","Date","oldEnd","addOrigin","baseMaxWorkDepth","reduceMaxWorkDepth","list","ret","withSuper","oldCtor","oldObj","isBlock","isCatch","functionScope","scope","arrow","fnType","maybeInstantiate","instantiateScore","defVar","s","NotSmaller","nodeSmallerThan","node","n","simple","Expression","e","maybeTagAsInstantiated","setFunctionInstantiated","refScope","oldOrigin","scopeCopy","v","slice","argset","recursive","scopeGatherer","inferWrapper","maybeTagAsGeneric","targetInner","asArray","foundPath","explore","parsed","TypeParser","parseType","computeRetSource","aval","path","newPath","dest","addVar","nameNode","patternName","left","properties","value","elements","argument","isBlockScopedDecl","kind","patternScopes","make","VariablePattern","scopes","AssignmentPattern","right","AssignmentExpression","MemberPattern","argVals","decl","params","param","arg","id","expression","BlockStatement","some","base","CatchClause","ecma","VariableDeclaration","targetScope","declarations","init","ClassDeclaration","superClass","ForInStatement","ForStatement","ImportDeclaration","specifiers","rmScope","ForOfStatement","scopeClearer","ForInStateMent","clearScopes","ast","inferInScope","key","property","symbolName","infer","sym","unopResultType","op","binopIsBoolean","literalType","regex","joined","connectParams","connectPattern","ensureVar","inferPatternVisitor","Identifier","source","MemberExpression","object","pName","RestElement","ObjectPattern","ArrayPattern","connecter","getThis","fnScope","maybeAddPhantomObj","inferClass","sup","supCtor","delayed","supVal","supProto","objType","inst","method","static","initializer","methodFn","arrayLiteralType","homogenous","litType","elt","eltVal","out","r","fill","inferExprVisitor","ArrayExpression","ObjectExpression","waitForProto","protoVal","FunctionExpression","ClassExpression","SequenceExpression","l","expressions","UnaryExpression","operator","UpdateExpression","BinaryExpression","lhs","rhs","over","iteratesOver","fromRight","LogicalExpression","ConditionalExpression","consequent","alternate","NewExpression","CallExpression","outerFn","superType","knownFn","AwaitExpression","wg","propType","ThisExpression","_node","Super","Literal","TemplateLiteral","TaggedTemplateExpression","quasi","tag","YieldExpression","output","yieldval","delegate","loopPattern","ArrowFunctionExpression","FunctionDeclaration","Statement","ExportDefaultDeclaration","declaration","ReturnStatement","pattern","await","parse","text","thirdArg","makePredicate","start","arr","pos","findByPropertyName","generatorResult","input","valObj","retObj","async_generator_prototype","generator_prototype","computeReturnType","funcNode","findType","analyze","purge","typeFinder","propN","MethodDefinition","finder","searchVisitor","_st","Property","st","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","searchExprVisitor","fullVisitor","findExpressionAt","defaultScope","filter","_t","findNodeAt","findClosestExpression","findNodeAround","findExpressionAround","expressionType","state","parentNode","child","override","top","pop","findTypeFromContext","get","calleeType","_parent","fnNode","sourceFile","VariableDeclarator","typeFromContext","fromContext","resetGuessing","didGuess","forAllPropertiesOf","findRefs","baseScope","handleId","ancestors","ancestor","simpleWalker","_scope","findPropRefs","isObjTypeProto","scopeAt","forAllLocalsAt"],"mappings":"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","sourcesContent":["// Main type inference engine\n\n// Walks an AST, building up a graph of abstract values and constraints\n// that cause types to flow from one node to another. Also defines a\n// number of utilities for accessing ASTs and scopes.\n\n// Analysis is done in a context, which is tracked by the dynamically\n// bound cx variable. Use withContext to set the current context.\n\n// For memory-saving reasons, individual types export an interface\n// similar to abstract values (which can hold multiple types), and can\n// thus be used in place abstract values that only ever contain a\n// single type.\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    return mod(exports, require(\"acorn\"), require(\"acorn-loose\"), require(\"acorn-walk\"),\n               require(\"./def\"), require(\"./signal\"));\n  if (typeof define == \"function\" && define.amd) // AMD\n    return define([\"exports\", \"acorn/dist/acorn\", \"acorn-loose/dist/acorn-loose\", \"acorn-walk/dist/walk\", \"./def\", \"./signal\"], mod);\n  mod(root.tern || (root.tern = {}), acorn, acorn.loose, acorn.walk, tern.def, tern.signal); // Plain browser env\n})(this, function(exports, acorn, acorn_loose, walk, def, signal) {\n  \"use strict\";\n\n  var toString = exports.toString = function(type, maxDepth, parent) {\n    if (!type || type == parent || maxDepth && maxDepth < -3) return \"?\";\n    return type.toString(maxDepth, parent);\n  };\n\n  // A variant of AVal used for unknown, dead-end values. Also serves\n  // as prototype for AVals, Types, and Constraints because it\n  // implements 'empty' versions of all the methods that the code\n  // expects.\n  var ANull = exports.ANull = signal.mixin({\n    addType: function() {},\n    propagate: function() {},\n    getProp: function() { return ANull; },\n    forAllProps: function() {},\n    hasType: function() { return false; },\n    isEmpty: function() { return true; },\n    getFunctionType: function() {},\n    getObjType: function() {},\n    getSymbolType: function() {},\n    getType: function() {},\n    gatherProperties: function() {},\n    propagatesTo: function() {},\n    typeHint: function() {},\n    propHint: function() {},\n    toString: function() { return \"?\"; }\n  });\n\n  function extend(proto, props) {\n    var obj = Object.create(proto);\n    if (props) for (var prop in props) obj[prop] = props[prop];\n    return obj;\n  }\n\n  // ABSTRACT VALUES\n\n  var WG_DEFAULT = 100, WG_NEW_INSTANCE = 90, WG_MADEUP_PROTO = 10,\n      WG_MULTI_MEMBER = 6, WG_CATCH_ERROR = 6,\n      WG_PHANTOM_OBJ = 1,\n      WG_GLOBAL_THIS = 90, WG_SPECULATIVE_THIS = 2, WG_SPECULATIVE_PROTO_THIS = 4;\n\n  var AVal = exports.AVal = function() {\n    this.types = [];\n    this.forward = null;\n    this.maxWeight = 0;\n  };\n  AVal.prototype = extend(ANull, {\n    addType: function(type, weight) {\n      weight = weight || WG_DEFAULT;\n      if (this.maxWeight < weight) {\n        this.maxWeight = weight;\n        if (this.types.length == 1 && this.types[0] == type) return;\n        this.types.length = 0;\n      } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {\n        return;\n      }\n\n      this.signal(\"addType\", type);\n      this.types.push(type);\n      var forward = this.forward;\n      if (forward) withWorklist(function(add) {\n        for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);\n      });\n    },\n\n    propagate: function(target, weight) {\n      if (target == ANull || (target instanceof Type && this.forward && this.forward.length > 2)) return;\n      if (weight && weight != WG_DEFAULT) target = new Muffle(target, weight);\n      (this.forward || (this.forward = [])).push(target);\n      var types = this.types;\n      if (types.length) withWorklist(function(add) {\n        for (var i = 0; i < types.length; ++i) add(types[i], target, weight);\n      });\n    },\n\n    getProp: function(prop) {\n      if (ignoredProp(prop)) return ANull;\n      var found = (this.props || (this.props = Object.create(null)))[prop];\n      if (!found) {\n        found = this.props[prop] = new AVal;\n        this.propagate(new GetProp(prop, found));\n      }\n      return found;\n    },\n\n    forAllProps: function(c) {\n      this.propagate(new ForAllProps(c));\n    },\n\n    hasType: function(type) {\n      return this.types.indexOf(type) > -1;\n    },\n    isEmpty: function() { return this.types.length === 0; },\n    getFunctionType: function() {\n      for (var i = this.types.length - 1; i >= 0; --i)\n        if (this.types[i] instanceof Fn) return this.types[i];\n    },\n    getObjType: function() {\n      var seen = null;\n      for (var i = this.types.length - 1; i >= 0; --i) {\n        var type = this.types[i];\n        if (!(type instanceof Obj)) continue;\n        if (type.name) return type;\n        if (!seen) seen = type;\n      }\n      return seen;\n    },\n\n    getSymbolType: function() {\n      for (var i = this.types.length - 1; i >= 0; --i)\n        if (this.types[i] instanceof Sym) return this.types[i];\n    },\n\n    getType: function(guess) {\n      if (this.types.length === 0 && guess !== false) return this.makeupType();\n      if (this.types.length === 1) return this.types[0];\n      return canonicalType(this.types);\n    },\n\n    toString: function(maxDepth, parent) {\n      if (this.types.length == 0) return toString(this.makeupType(), maxDepth, parent);\n      if (this.types.length == 1) return toString(this.types[0], maxDepth, parent);\n      var simplified = simplifyTypes(this.types);\n      if (simplified.length > 2) return \"?\";\n      return simplified.map(function(tp) { return toString(tp, maxDepth, parent); }).join(\"|\");\n    },\n\n    makeupPropType: function(obj) {\n      var propName = this.propertyName;\n\n      var protoProp = obj.proto && obj.proto.hasProp(propName);\n      if (protoProp) {\n        var fromProto = protoProp.getType();\n        if (fromProto) return fromProto;\n      }\n\n      if (propName != \"<i>\") {\n        var computedProp = obj.hasProp(\"<i>\");\n        if (computedProp) return computedProp.getType();\n      } else if (obj.props[\"<i>\"] != this) {\n        for (var prop in obj.props) {\n          var val = obj.props[prop];\n          if (!val.isEmpty()) return val.getType();\n        }\n      }\n    },\n\n    makeupType: function() {\n      var computed = this.propertyOf && this.makeupPropType(this.propertyOf);\n      if (computed) return computed;\n\n      if (!this.forward) return null;\n      for (var i = this.forward.length - 1; i >= 0; --i) {\n        var hint = this.forward[i].typeHint();\n        if (hint && !hint.isEmpty()) {guessing = true; return hint;}\n      }\n\n      var props = Object.create(null), foundProp = null;\n      for (var i = 0; i < this.forward.length; ++i) {\n        var prop = this.forward[i].propHint();\n        if (prop && prop != \"length\" && prop != \"<i>\" && prop != \"✖\" && prop != cx.completingProperty) {\n          props[prop] = true;\n          foundProp = prop;\n        }\n      }\n      if (!foundProp) return null;\n\n      var objs = objsWithProp(foundProp);\n      if (objs) {\n        var matches = [];\n        search: for (var i = 0; i < objs.length; ++i) {\n          var obj = objs[i];\n          for (var prop in props) if (!obj.hasProp(prop)) continue search;\n          if (obj.hasCtor) obj = getInstance(obj);\n          matches.push(obj);\n        }\n        var canon = canonicalType(matches);\n        if (canon) {guessing = true; return canon;}\n      }\n    },\n\n    typeHint: function() { return this.types.length ? this.getType() : null; },\n    propagatesTo: function() { return this; },\n\n    gatherProperties: function(f, depth) {\n      for (var i = 0; i < this.types.length; ++i)\n        this.types[i].gatherProperties(f, depth);\n    },\n\n    guessProperties: function(f) {\n      if (this.forward) for (var i = 0; i < this.forward.length; ++i) {\n        var prop = this.forward[i].propHint();\n        if (prop) f(prop, null, 0);\n      }\n      var guessed = this.makeupType();\n      if (guessed) guessed.gatherProperties(f);\n    }\n  });\n\n  function similarAVal(a, b, depth) {\n    var typeA = a.getType(false), typeB = b.getType(false);\n    if (!typeA || !typeB) return true;\n    return similarType(typeA, typeB, depth);\n  }\n\n  function similarType(a, b, depth) {\n    if (!a || depth >= 5) return b;\n    if (!a || a == b) return a;\n    if (!b) return a;\n    if (a.constructor != b.constructor) return false;\n    if (a.constructor == Arr) {\n      var innerA = a.getProp(\"<i>\").getType(false);\n      if (!innerA) return b;\n      var innerB = b.getProp(\"<i>\").getType(false);\n      if (!innerB || similarType(innerA, innerB, depth + 1)) return b;\n    } else if (a.constructor == Obj) {\n      var propsA = 0, propsB = 0, same = 0;\n      for (var prop in a.props) {\n        propsA++;\n        if (prop in b.props && similarAVal(a.props[prop], b.props[prop], depth + 1))\n          same++;\n      }\n      for (var prop in b.props) propsB++;\n      if (propsA && propsB && same < Math.max(propsA, propsB) / 2) return false;\n      return propsA > propsB ? a : b;\n    } else if (a.constructor == Fn) {\n      if (a.args.length != b.args.length ||\n          !a.args.every(function(tp, i) { return similarAVal(tp, b.args[i], depth + 1); }) ||\n          !similarAVal(a.retval, b.retval, depth + 1) || !similarAVal(a.self, b.self, depth + 1))\n        return false;\n      return a;\n    } else {\n      return false;\n    }\n  }\n\n  var simplifyTypes = exports.simplifyTypes = function(types) {\n    var found = [];\n    outer: for (var i = 0; i < types.length; ++i) {\n      var tp = types[i];\n      for (var j = 0; j < found.length; j++) {\n        var similar = similarType(tp, found[j], 0);\n        if (similar) {\n          found[j] = similar;\n          continue outer;\n        }\n      }\n      found.push(tp);\n    }\n    return found;\n  };\n\n  function canonicalType(types) {\n    var arrays = 0, fns = 0, objs = 0, prim = null;\n    for (var i = 0; i < types.length; ++i) {\n      var tp = types[i];\n      if (tp instanceof Arr) ++arrays;\n      else if (tp instanceof Fn) ++fns;\n      else if (tp instanceof Obj) ++objs;\n      else if (tp instanceof Prim) {\n        if (prim && tp.name != prim.name) return null;\n        prim = tp;\n      }\n    }\n    var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);\n    if (kinds > 1) return null;\n    if (prim) return prim;\n\n    var maxScore = 0, maxTp = null;\n    for (var i = 0; i < types.length; ++i) {\n      var tp = types[i], score = 0;\n      if (arrays) {\n        score = tp.getProp(\"<i>\").isEmpty() ? 1 : 2;\n      } else if (fns) {\n        score = 1;\n        for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;\n        if (!tp.retval.isEmpty()) ++score;\n      } else if (objs) {\n        score = tp.name ? 100 : 2;\n      }\n      if (score >= maxScore) { maxScore = score; maxTp = tp; }\n    }\n    return maxTp;\n  }\n\n  // PROPAGATION STRATEGIES\n\n  var constraint = exports.constraint = function(methods) {\n    var ctor = function() {\n      this.origin = cx.curOrigin;\n      this.construct.apply(this, arguments);\n    };\n    ctor.prototype = Object.create(ANull);\n    for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];\n    return ctor;\n  };\n\n  var GetProp = constraint({\n    construct: function(prop, target) {\n      this.prop = prop; this.target = target;\n    },\n    addType: function(type, weight) {\n      if (type.getProp)\n        type.getProp(this.prop).propagate(this.target, weight);\n    },\n    propHint: function() { return this.prop; },\n    propagatesTo: function() {\n      if (this.prop == \"<i>\" || !/[^\\w_]/.test(this.prop))\n        return {target: this.target, pathExt: \".\" + this.prop};\n    }\n  });\n\n  var DefProp = exports.PropHasSubset = exports.DefProp = constraint({\n    construct: function(prop, type, originNode) {\n      this.prop = prop; this.type = type; this.originNode = originNode;\n    },\n    addType: function(type, weight) {\n      if (!(type instanceof Obj)) return;\n      var prop = type.defProp(this.prop, this.originNode);\n      if (!prop.origin) prop.origin = this.origin;\n      this.type.propagate(prop, weight);\n    },\n    propHint: function() { return this.prop; }\n  });\n\n  var ForAllProps = constraint({\n    construct: function(c) { this.c = c; },\n    addType: function(type) {\n      if (!(type instanceof Obj)) return;\n      type.forAllProps(this.c);\n    }\n  });\n\n  function withDisabledComputing(fn, body) {\n    cx.disabledComputing = {fn: fn, prev: cx.disabledComputing};\n    var result = body();\n    cx.disabledComputing = cx.disabledComputing.prev;\n    return result;\n  }\n  var IsCallee = exports.IsCallee = constraint({\n    construct: function(self, args, argNodes, retval) {\n      this.self = self; this.args = args; this.argNodes = argNodes; this.retval = retval;\n      this.disabled = cx.disabledComputing;\n    },\n    addType: function(fn, weight) {\n      if (!(fn instanceof Fn)) return;\n      for (var i = 0; i < this.args.length; ++i) {\n        if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);\n        if (fn.arguments) this.args[i].propagate(fn.arguments, weight);\n      }\n      if (!fn.isArrowFn())\n        this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);\n      var compute = fn.computeRet, result = fn.retval;\n      if (compute) for (var d = this.disabled; d; d = d.prev)\n        if (d.fn == fn || fn.originNode && d.fn.originNode == fn.originNode) compute = null;\n      if (compute) {\n        var old = cx.disabledComputing;\n        cx.disabledComputing = this.disabled;\n        result = compute(this.self, this.args, this.argNodes);\n        cx.disabledComputing = old;\n      }\n      if (fn.async && !fn.generator) {\n        var tp = result.getType();\n        if (!(tp && tp.constructor == Obj && tp.name == \"Promise\")) {\n          var defs = cx.definitions.ecmascript;\n          var rtnval = defs && new Obj(defs[\"Promise.prototype\"]);\n          if (rtnval) {\n            rtnval.getType().propagate(new DefProp(':t', result));\n            result = rtnval;            \n          }\n        }\n      }\n      maybeIterator(fn, result).propagate(this.retval, weight);\n    },\n    typeHint: function() {\n      var names = [];\n      for (var i = 0; i < this.args.length; ++i) names.push(\"?\");\n      return new Fn(null, this.self, this.args, names, ANull);\n    },\n    propagatesTo: function() {\n      return {target: this.retval, pathExt: \".!ret\"};\n    }\n  });\n\n  var HasMethodCall = constraint({\n    construct: function(propName, args, argNodes, retval) {\n      this.propName = propName; this.args = args; this.argNodes = argNodes; this.retval = retval;\n      this.disabled = cx.disabledComputing;\n    },\n    addType: function(obj, weight) {\n      var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);\n      callee.disabled = this.disabled;\n      obj.getProp(this.propName).propagate(callee, weight);\n    },\n    propHint: function() { return this.propName; }\n  });\n\n  var IsCtor = exports.IsCtor = constraint({\n    construct: function(target, noReuse) {\n      this.target = target; this.noReuse = noReuse;\n    },\n    addType: function(f, weight) {\n      if (!(f instanceof Fn)) return;\n      if (cx.parent && !cx.parent.options.reuseInstances) this.noReuse = true;\n      f.getProp(\"prototype\").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);\n    }\n  });\n\n  var getInstance = exports.getInstance = function(obj, ctor) {\n    if (ctor === false) return new Obj(obj);\n\n    if (!ctor) ctor = obj.hasCtor;\n    if (!obj.instances) obj.instances = [];\n    for (var i = 0; i < obj.instances.length; ++i) {\n      var cur = obj.instances[i];\n      if (cur.ctor == ctor) return cur.instance;\n    }\n    var instance = new Obj(obj, ctor && ctor.name);\n    instance.origin = obj.origin;\n    obj.instances.push({ctor: ctor, instance: instance});\n    return instance;\n  };\n\n  var IsProto = exports.IsProto = constraint({\n    construct: function(ctor, target) {\n      this.ctor = ctor; this.target = target;\n    },\n    addType: function(o, _weight) {\n      if (!(o instanceof Obj)) return;\n      if ((this.count = (this.count || 0) + 1) > 8) return;\n      if (o == cx.protos.Array)\n        this.target.addType(new Arr);\n      else\n        this.target.addType(getInstance(o, this.ctor));\n    }\n  });\n\n  var FnPrototype = constraint({\n    construct: function(fn) { this.fn = fn; },\n    addType: function(o, _weight) {\n      if (o instanceof Obj && !o.hasCtor) {\n        o.hasCtor = this.fn;\n        var adder = new SpeculativeThis(o, this.fn);\n        adder.addType(this.fn);\n        o.forAllProps(function(_prop, val, local) {\n          if (local) val.propagate(adder);\n        });\n      }\n    }\n  });\n\n  var IsAdded = constraint({\n    construct: function(other, target) {\n      this.other = other; this.target = target;\n    },\n    addType: function(type, weight) {\n      if (type == cx.str)\n        this.target.addType(cx.str, weight);\n      else if (type == cx.num && this.other.hasType(cx.num))\n        this.target.addType(cx.num, weight);\n    },\n    typeHint: function() { return this.other; }\n  });\n\n  var IfObj = exports.IfObj = constraint({\n    construct: function(target) { this.target = target; },\n    addType: function(t, weight) {\n      if (t instanceof Obj) this.target.addType(t, weight);\n    },\n    propagatesTo: function() { return this.target; }\n  });\n\n  var SpeculativeThis = constraint({\n    construct: function(obj, ctor) { this.obj = obj; this.ctor = ctor; },\n    addType: function(tp) {\n      if (tp instanceof Fn && tp.self)\n        tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_PROTO_THIS);\n    }\n  });\n\n  var HasProto = constraint({\n    construct: function(obj) { this.obj = obj },\n    addType: function(tp) {\n      if (tp instanceof Obj && this.obj.proto == cx.protos.Object)\n        this.obj.replaceProto(tp);\n    }\n  });\n\n  var Muffle = constraint({\n    construct: function(inner, weight) {\n      this.inner = inner; this.weight = weight;\n    },\n    addType: function(tp, weight) {\n      this.inner.addType(tp, Math.min(weight, this.weight));\n    },\n    propagatesTo: function() { return this.inner.propagatesTo(); },\n    typeHint: function() { return this.inner.typeHint(); },\n    propHint: function() { return this.inner.propHint(); }\n  });\n\n  // TYPE OBJECTS\n\n  var Type = exports.Type = function() {};\n  Type.prototype = extend(ANull, {\n    constructor: Type,\n    propagate: function(c, w) { c.addType(this, w); },\n    hasType: function(other) { return other == this; },\n    isEmpty: function() { return false; },\n    typeHint: function() { return this; },\n    getType: function() { return this; }\n  });\n\n  var Prim = exports.Prim = function(proto, name) { this.name = name; this.proto = proto; };\n  Prim.prototype = extend(Type.prototype, {\n    constructor: Prim,\n    toString: function() { return this.name; },\n    getProp: function(prop) {return this.proto.hasProp(prop) || ANull;},\n    gatherProperties: function(f, depth) {\n      if (this.proto) this.proto.gatherProperties(f, depth);\n    }\n  });\n\n  function isInteger(str) {\n    var c0 = str.charCodeAt(0);\n    if (c0 >= 48 && c0 <= 57) return !/\\D/.test(str);\n    else return false;\n  }\n\n  var Obj = exports.Obj = function(proto, name) {\n    if (!this.props) this.props = Object.create(null);\n    this.proto = proto === true ? cx.protos.Object : proto;\n    if (proto && proto != cx.protos.Object && !name && proto.name && !(this instanceof Fn)) {\n      var match = /^(.*)\\.prototype$/.exec(this.proto.name);\n      if (match) name = match[1];\n    }\n    this.name = name;\n    this.maybeProps = null;\n    this.origin = cx.curOrigin;\n  };\n  Obj.prototype = extend(Type.prototype, {\n    constructor: Obj,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0;\n      if (maxDepth <= 0 && this.name) return this.name;\n      var props = [], etc = false;\n      for (var prop in this.props) if (prop != \"<i>\") {\n        if (props.length > 5) { etc = true; break; }\n        if (maxDepth)\n          props.push(prop + \": \" + toString(this.props[prop], maxDepth - 1, this));\n        else\n          props.push(prop);\n      }\n      props.sort();\n      if (etc) props.push(\"...\");\n      return \"{\" + props.join(\", \") + \"}\";\n    },\n    hasProp: function(prop, searchProto) {\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop);\n      var found = this.props[prop];\n      if (searchProto !== false)\n        for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];\n      return found;\n    },\n    defProp: function(prop, originNode) {\n      var found = this.hasProp(prop, false);\n      if (found) {\n        if (originNode && !found.originNode) found.originNode = originNode;\n        return found;\n      }\n      if (ignoredProp(prop)) return ANull;\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop);\n\n      var av = this.maybeProps && this.maybeProps[prop];\n      if (av) {\n        delete this.maybeProps[prop];\n        this.maybeUnregProtoPropHandler();\n      } else {\n        av = new AVal;\n        av.propertyOf = this;\n        av.propertyName = prop;\n      }\n\n      this.props[prop] = av;\n      av.originNode = originNode;\n      av.origin = cx.curOrigin;\n      this.broadcastProp(prop, av, true);\n      return av;\n    },\n    getProp: function(prop) {\n      var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);\n      if (found) return found;\n      if (ignoredProp(prop)) return ANull;\n      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop);\n      var av = this.ensureMaybeProps()[prop] = new AVal;\n      av.propertyOf = this;\n      av.propertyName = prop;\n      return av;\n    },\n    normalizeIntegerProp: function(_) { return \"<i>\" },\n    broadcastProp: function(prop, val, local) {\n      if (local) {\n        this.signal(\"addProp\", prop, val);\n        // If this is a scope, it shouldn't be registered\n        if (!(this instanceof Scope)) registerProp(prop, this);\n      }\n\n      if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {\n        var h = this.onNewProp[i];\n        h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);\n      }\n    },\n    onProtoProp: function(prop, val, _local) {\n      var maybe = this.maybeProps && this.maybeProps[prop];\n      if (maybe) {\n        delete this.maybeProps[prop];\n        this.maybeUnregProtoPropHandler();\n        this.proto.getProp(prop).propagate(maybe);\n      }\n      this.broadcastProp(prop, val, false);\n    },\n    replaceProto: function(proto) {\n      for (var o = proto; o; o = o.proto)\n        if (o == this) return;\n      if (this.proto && this.maybeProps)\n        this.proto.unregPropHandler(this);\n      this.proto = proto;\n      if (this.maybeProps)\n        this.proto.forAllProps(this);\n    },\n    ensureMaybeProps: function() {\n      if (!this.maybeProps) {\n        if (this.proto) this.proto.forAllProps(this);\n        this.maybeProps = Object.create(null);\n      }\n      return this.maybeProps;\n    },\n    removeProp: function(prop) {\n      var av = this.props[prop];\n      delete this.props[prop];\n      this.ensureMaybeProps()[prop] = av;\n      av.types.length = 0;\n    },\n    forAllProps: function(c) {\n      if (!this.onNewProp) {\n        this.onNewProp = [];\n        if (this.proto) this.proto.forAllProps(this);\n      }\n      this.onNewProp.push(c);\n      for (var o = this; o; o = o.proto) for (var prop in o.props) {\n        if (c.onProtoProp)\n          c.onProtoProp(prop, o.props[prop], o == this);\n        else\n          c(prop, o.props[prop], o == this);\n      }\n    },\n    maybeUnregProtoPropHandler: function() {\n      if (this.maybeProps) {\n        for (var _n in this.maybeProps) return;\n        this.maybeProps = null;\n      }\n      if (!this.proto || this.onNewProp && this.onNewProp.length) return;\n      this.proto.unregPropHandler(this);\n    },\n    unregPropHandler: function(handler) {\n      for (var i = 0; i < this.onNewProp.length; ++i)\n        if (this.onNewProp[i] == handler) { this.onNewProp.splice(i, 1); break; }\n      this.maybeUnregProtoPropHandler();\n    },\n    gatherProperties: function(f, depth) {\n      for (var prop in this.props) if (prop != \"<i>\" && prop.charAt(0) != \":\")\n        f(prop, this, depth);\n      if (this.proto) this.proto.gatherProperties(f, depth + 1);\n    },\n    getObjType: function() { return this; }\n  });\n\n  var geckoIterators = typeof StopIteration != \"undefined\";\n  function ignoredProp(name) {\n    return name == \"__proto__\" || name == \"✖\" || geckoIterators && name == \"__iterator__\";\n  }\n\n  var Fn = exports.Fn = function(name, self, args, argNames, retval, generator, async) {\n    Obj.call(this, cx.protos.Function, name);\n    this.self = self;\n    this.args = args;\n    this.argNames = argNames;\n    this.retval = retval;\n    this.generator = generator;\n    this.async = async;\n  };\n  Fn.prototype = extend(Obj.prototype, {\n    constructor: Fn,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0;\n      var str = this.generator ? \"fn*(\" : \"fn(\";\n      for (var i = 0; i < this.args.length; ++i) {\n        if (i) str += \", \";\n        var name = this.argNames[i];\n        if (name && name != \"?\") str += name + \": \";\n        str += maxDepth > -3 ? toString(this.args[i], maxDepth - 1, this) : \"?\";\n      }\n      str += \")\";\n      if (!this.retval.isEmpty())\n        str += \" -> \" + (maxDepth > -3 ? toString(this.retval, maxDepth - 1, this) : \"?\");\n      return str;\n    },\n    getProp: function(prop) {\n      if (prop == \"prototype\") {\n        var known = this.hasProp(prop, false);\n        if (!known) {\n          known = this.defProp(prop);\n          var proto = new Obj(true, this.name && this.name + \".prototype\");\n          proto.origin = this.origin;\n          known.addType(proto, WG_MADEUP_PROTO);\n        }\n        return known;\n      }\n      return Obj.prototype.getProp.call(this, prop);\n    },\n    defProp: function(prop, originNode) {\n      if (prop == \"prototype\") {\n        var found = this.hasProp(prop, false);\n        if (found) return found;\n        found = Obj.prototype.defProp.call(this, prop, originNode);\n        found.origin = this.origin;\n        found.propagate(new FnPrototype(this));\n        return found;\n      }\n      return Obj.prototype.defProp.call(this, prop, originNode);\n    },\n    getFunctionType: function() { return this; },\n    isArrowFn: function() { return this.originNode && this.originNode.type == \"ArrowFunctionExpression\" }\n  });\n\n  var Arr = exports.Arr = function(contentType) {\n    Obj.call(this, cx.protos.Array);\n    var content = this.defProp(\"<i>\");\n    if (Array.isArray(contentType)) {\n      this.tuple = contentType.length;\n      for (var i = 0; i < contentType.length; i++) {\n        var prop = this.defProp(String(i));\n        contentType[i].propagate(prop);\n        prop.propagate(content);\n      }\n    } else if (contentType) {\n      this.tuple = 0;\n      contentType.propagate(content);\n    }\n  };\n  Arr.prototype = extend(Obj.prototype, {\n    constructor: Arr,\n    toString: function(maxDepth) {\n      if (maxDepth == null) maxDepth = 0;\n      if (maxDepth <= -3) return \"[?]\";\n      var content = \"\";\n      if (this.tuple) {\n        var similar;\n        for (var i = 0; i in this.props; i++) {\n          var type = toString(this.getProp(String(i)), maxDepth - 1, this);\n          if (similar == null)\n            similar = type;\n          else if (similar != type)\n            similar = false;\n          else\n            similar = type;\n          content += (content ? \", \" : \"\") + type;\n        }\n        if (similar) content = similar;\n      } else {\n        content = toString(this.getProp(\"<i>\"), maxDepth - 1, this);\n      }\n      return \"[\" + content + \"]\";\n    },\n    normalizeIntegerProp: function(prop) {\n      if (+prop < this.tuple) return prop;\n      else return \"<i>\";\n    }\n  });\n\n  var Sym = exports.Sym = function(name, originNode) {\n    Prim.call(this, cx.protos.Symbol, \"Symbol\");\n    this.symName = name;\n    this.originNode = originNode;\n  };\n  Sym.prototype = extend(Prim.prototype, {\n    constructor: Sym,\n    asPropName: function() { return \":\" + this.symName },\n    getSymbolType: function() { return this }\n  });\n\n  exports.getSymbol = function(name, originNode) {\n    var cleanName = name.replace(/[^\\w$\\.]/g, \"_\");\n    var known = cx.symbols[cleanName];\n    if (known) {\n      if (originNode && !known.originNode) known.originNode = originNode;\n      return known;\n    }\n    return cx.symbols[cleanName] = new Sym(cleanName, originNode);\n  };\n\n  // THE PROPERTY REGISTRY\n\n  function registerProp(prop, obj) {\n    var data = cx.props[prop] || (cx.props[prop] = []);\n    data.push(obj);\n  }\n\n  function objsWithProp(prop) {\n    return cx.props[prop];\n  }\n\n  // INFERENCE CONTEXT\n\n  exports.Context = function(defs, parent) {\n    this.parent = parent;\n    this.props = Object.create(null);\n    this.protos = Object.create(null);\n    this.origins = [];\n    this.curOrigin = \"ecmascript\";\n    this.paths = Object.create(null);\n    this.definitions = Object.create(null);\n    this.purgeGen = 0;\n    this.workList = null;\n    this.disabledComputing = null;\n    this.curSuperCtor = this.curSuper = null;\n    this.symbols = Object.create(null);\n\n    exports.withContext(this, function() {\n      cx.protos.Object = new Obj(null, \"Object.prototype\");\n      cx.topScope = new Scope();\n      cx.topScope.name = \"<top>\";\n      cx.protos.Array = new Obj(true, \"Array.prototype\");\n      cx.protos.Function = new Fn(\"Function.prototype\", ANull, [], [], ANull);\n      cx.protos.Function.proto = cx.protos.Object;\n      cx.protos.RegExp = new Obj(true, \"RegExp.prototype\");\n      cx.protos.String = new Obj(true, \"String.prototype\");\n      cx.protos.Number = new Obj(true, \"Number.prototype\");\n      cx.protos.Boolean = new Obj(true, \"Boolean.prototype\");\n      cx.protos.Symbol = new Obj(true, \"Symbol.prototype\");\n      cx.str = new Prim(cx.protos.String, \"string\");\n      cx.bool = new Prim(cx.protos.Boolean, \"bool\");\n      cx.num = new Prim(cx.protos.Number, \"number\");\n      cx.curOrigin = null;\n\n      if (defs) for (var i = 0; i < defs.length; ++i)\n        def.load(defs[i]);\n    });\n  };\n\n  exports.Context.prototype.startAnalysis = function() {\n    this.disabledComputing = this.workList = this.curSuperCtor = this.curSuper = null;\n  };\n\n  var cx = null;\n  exports.cx = function() { return cx; };\n\n  exports.withContext = function(context, f) {\n    var old = cx;\n    cx = context;\n    try { return f(); }\n    finally { cx = old; }\n  };\n\n  exports.TimedOut = function() {\n    this.message = \"Timed out\";\n    this.stack = (new Error()).stack;\n  };\n  exports.TimedOut.prototype = Object.create(Error.prototype);\n  exports.TimedOut.prototype.name = \"infer.TimedOut\";\n\n  var timeout;\n  exports.withTimeout = function(ms, f) {\n    var end = +new Date + ms;\n    var oldEnd = timeout;\n    if (oldEnd && oldEnd < end) return f();\n    timeout = end;\n    try { return f(); }\n    finally { timeout = oldEnd; }\n  };\n\n  exports.addOrigin = function(origin) {\n    if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);\n  };\n\n  var baseMaxWorkDepth = 20, reduceMaxWorkDepth = 0.0001;\n  function withWorklist(f) {\n    if (cx.workList) return f(cx.workList);\n\n    var list = [], depth = 0;\n    var add = cx.workList = function(type, target, weight) {\n      if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)\n        list.push(type, target, weight, depth);\n    };\n    var ret = f(add);\n    for (var i = 0; i < list.length; i += 4) {\n      if (timeout && +new Date >= timeout)\n        throw new exports.TimedOut();\n      depth = list[i + 3] + 1;\n      list[i + 1].addType(list[i], list[i + 2]);\n    }\n    cx.workList = null;\n    return ret;\n  }\n\n  function withSuper(ctor, obj, f) {\n    var oldCtor = cx.curSuperCtor, oldObj = cx.curSuper;\n    cx.curSuperCtor = ctor; cx.curSuper = obj;\n    var result = f();\n    cx.curSuperCtor = oldCtor; cx.curSuper = oldObj;\n    return result;\n  }\n\n  // SCOPES\n\n  var Scope = exports.Scope = function(prev, originNode, isBlock, isCatch) {\n    Obj.call(this, prev || true);\n    this.prev = prev;\n    this.originNode = originNode;\n    this.isBlock = !!isBlock;\n    this.isCatch = !!isCatch;\n  };\n  Scope.prototype = extend(Obj.prototype, {\n    constructor: Scope,\n    defVar: function(name, originNode) {\n      for (var s = this; ; s = s.proto) {\n        var found = s.props[name];\n        if (found) return found;\n        if (!s.prev) return s.defProp(name, originNode);\n      }\n    }\n  });\n\n  function functionScope(scope, arrow) {\n    while (scope.isBlock || scope.isCatch || (arrow === false && scope.fnType && scope.fnType.isArrowFn()))\n      scope = scope.prev;\n    return scope;\n  }\n\n\n  // RETVAL COMPUTATION HEURISTICS\n\n  function maybeInstantiate(scope, score) {\n    var fn = functionScope(scope).fnType;\n    if (fn) fn.instantiateScore = (fn.instantiateScore || 0) + score;\n  }\n\n  var NotSmaller = {};\n  function nodeSmallerThan(node, n) {\n    try {\n      walk.simple(node, {Expression: function() { if (--n <= 0) throw NotSmaller; }});\n      return true;\n    } catch(e) {\n      if (e == NotSmaller) return false;\n      throw e;\n    }\n  }\n\n  function maybeTagAsInstantiated(node, fn) {\n    var score = fn.instantiateScore;\n    if (!cx.disabledComputing && score && fn.args.length && nodeSmallerThan(node, score * 5)) {\n      maybeInstantiate(functionScope(fn.originNode.scope.prev), score / 2);\n      setFunctionInstantiated(node, fn);\n      return true;\n    } else {\n      fn.instantiateScore = null;\n    }\n  }\n\n  function setFunctionInstantiated(node, fn) {\n    // Disconnect the arg avals, so that we can add info to them without side effects\n    var refScope = node.scope;\n    for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;\n    fn.self = new AVal;\n    fn.computeRet = function(self, args) {\n      // Prevent recursion\n      return withDisabledComputing(fn, function() {\n        var oldOrigin = cx.curOrigin;\n        cx.curOrigin = fn.origin;\n        var scope = node.scope ? node.scope : refScope;\n        var scopeCopy = new Scope(scope.prev, scope.originNode);\n        for (var v in scope.props) {\n          var local = scopeCopy.defProp(v, scope.props[v].originNode);\n          for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)\n            args[i].propagate(local);\n        }\n        var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;\n        while (argNames.length < args.length) argNames.push(\"?\");\n        scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull, fn.generator, fn.async);\n        scopeCopy.fnType.originNode = fn.originNode;\n        if (fn.arguments) {\n          var argset = scopeCopy.fnType.arguments = new AVal;\n          scopeCopy.defProp(\"arguments\").addType(new Arr(argset));\n          for (var i = 0; i < args.length; ++i) args[i].propagate(argset);\n        }\n        node.scope = scopeCopy;\n        walk.recursive(node.body, scopeCopy, null, scopeGatherer);\n        walk.recursive(node.body, scopeCopy, null, inferWrapper);\n        cx.curOrigin = oldOrigin;\n        return scopeCopy.fnType.retval;\n      });\n    };\n  }\n\n  function maybeTagAsGeneric(fn) {\n    var target = fn.retval;\n    if (target == ANull || fn.isArrowFn()) return;\n    var targetInner, asArray;\n    if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr)\n      target = asArray = targetInner.getProp(\"<i>\");\n\n    function explore(aval, path, depth) {\n      if (depth > 3 || !aval.forward) return;\n      for (var i = 0; i < aval.forward.length; ++i) {\n        var prop = aval.forward[i].propagatesTo();\n        if (!prop) continue;\n        var newPath = path, dest;\n        if (prop instanceof AVal) {\n          dest = prop;\n        } else if (prop.target instanceof AVal) {\n          newPath += prop.pathExt;\n          dest = prop.target;\n        } else continue;\n        if (dest == target) return newPath;\n        var found = explore(dest, newPath, depth + 1);\n        if (found) return found;\n      }\n    }\n\n    var foundPath = explore(fn.self, \"!this\", 0);\n    for (var i = 0; !foundPath && i < fn.args.length; ++i)\n      foundPath = explore(fn.args[i], \"!\" + i, 0);\n\n    if (foundPath) {\n      if (asArray) foundPath = \"[\" + foundPath + \"]\";\n      var p = new def.TypeParser(foundPath);\n      var parsed = p.parseType(true);\n      fn.computeRet = parsed.apply ? parsed : function() { return parsed; };\n      fn.computeRetSource = foundPath;\n      return true;\n    }\n  }\n\n  // SCOPE GATHERING PASS\n\n  function addVar(scope, nameNode) {\n    return scope.defProp(nameNode.name, nameNode);\n  }\n  function patternName(node) {\n    if (node.type == \"Identifier\") return node.name;\n    if (node.type == \"AssignmentPattern\") return patternName(node.left);\n    if (node.type == \"ObjectPattern\") return \"{\" + node.properties.map(function(e) { return patternName(e.type === 'RestElement' ? e : e.value) }).join(\", \") + \"}\";\n    if (node.type == \"ArrayPattern\") return \"[\" + node.elements.map(function(e) { return e ? patternName(e) : \"\" }).join(\", \") + \"]\";\n    if (node.type == \"RestElement\") return \"...\" + patternName(node.argument);\n    return \"_\";\n  }\n\n  function isBlockScopedDecl(node) {\n    return node.type == \"VariableDeclaration\" && node.kind != \"var\" ||\n      node.type == \"FunctionDeclaration\" ||\n      node.type == \"ClassDeclaration\";\n  }\n\n  function patternScopes(inner, outer) {\n    return {inner: inner, outer: outer || inner};\n  }\n\n  var scopeGatherer = exports.scopeGatherer = walk.make({\n    VariablePattern: function(node, scopes) {\n      if (scopes.inner) addVar(scopes.inner, node);\n    },\n    AssignmentPattern: function(node, scopes, c) {\n      c(node.left, scopes, \"Pattern\");\n      c(node.right, scopes.outer, \"Expression\");\n    },\n    AssignmentExpression: function(node, scope, c) {\n      if (node.left.type == \"MemberExpression\")\n        c(node.left, scope, \"Expression\");\n      else\n        c(node.left, patternScopes(false, scope), \"Pattern\");\n      c(node.right, scope, \"Expression\");\n    },\n    MemberPattern: function(node, scope, c) {\n      c(node, scope.outer);\n    },\n    Function: function(node, scope, c) {\n      var inner = node.scope = new Scope(scope, node);\n      var argVals = [], argNames = [];\n      for (var i = 0; i < node.params.length; ++i) {\n        var param = node.params[i];\n        argNames.push(patternName(param));\n        if (param.type == \"Identifier\") {\n          argVals.push(addVar(inner, param));\n        } else {\n          var arg = new AVal;\n          argVals.push(arg);\n          arg.originNode = param;\n          c(param, patternScopes(inner), \"Pattern\");\n        }\n      }\n      inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull, node.generator, node.async);\n      inner.fnType.originNode = node;\n      if (node.id) {\n        var decl = node.type == \"FunctionDeclaration\";\n        addVar(decl ? scope : inner, node.id);\n      }\n      c(node.body, inner, node.expression ? \"Expression\" : \"Statement\");\n    },\n    BlockStatement: function(node, scope, c) {\n      if (!node.scope && node.body.some(isBlockScopedDecl))\n        scope = node.scope = new Scope(scope, node, true);\n      walk.base.BlockStatement(node, scope, c);\n    },\n    CatchClause: function(node, scope, c) {\n      if (!node.param) { return; }\n      scope = node.scope = new Scope(scope, node, false, true);\n      if (node.param.type == \"Identifier\") {\n        var v = addVar(scope, node.param);\n        c(node.body, scope, \"Statement\");\n        var ecma = cx.definitions.ecmascript;\n        if (ecma && v.isEmpty()) getInstance(ecma[\"Error.prototype\"]).propagate(v, WG_CATCH_ERROR);\n      } else {\n        c(node.param, patternScopes(scope), \"Pattern\");\n      }\n    },\n    VariableDeclaration: function(node, scope, c) {\n      var targetScope = node.kind == \"var\" ? functionScope(scope) : scope;\n      for (var i = 0; i < node.declarations.length; ++i) {\n        var decl = node.declarations[i];\n        c(decl.id, patternScopes(targetScope, scope), \"Pattern\");\n        if (decl.init) c(decl.init, scope, \"Expression\");\n      }\n    },\n    ClassDeclaration: function(node, scope, c) {\n      if (node.id) addVar(scope, node.id);\n      if (node.superClass) c(node.superClass, scope, \"Expression\");\n      for (var i = 0; i < node.body.body.length; i++)\n        c(node.body.body[i], scope);\n    },\n    ForInStatement: function(node, scope, c) {\n      if (!node.scope && isBlockScopedDecl(node.left))\n        scope = node.scope = new Scope(scope, node, true);\n      walk.base.ForInStatement(node, scope, c);\n    },\n    ForStatement: function(node, scope, c) {\n      if (!node.scope && node.init && isBlockScopedDecl(node.init))\n        scope = node.scope = new Scope(scope, node, true);\n      walk.base.ForStatement(node, scope, c);\n    },\n    ImportDeclaration: function(node, scope) {\n      for (var i = 0; i < node.specifiers.length; i++)\n        addVar(scope, node.specifiers[i].local);\n    }\n  });\n  scopeGatherer.ForOfStatement = scopeGatherer.ForInStatement;\n\n  function rmScope(node) { if (node.scope) node.scope = null }\n  var scopeClearer = {BlockStatement: rmScope, Function: rmScope, CatchClause: rmScope,\n                      ForInStateMent: rmScope, ForStatement: rmScope};\n  exports.clearScopes = function(ast) {\n    walk.simple(ast, scopeClearer);\n  };\n\n  // CONSTRAINT GATHERING PASS\n\n  var propName = exports.propName = function(node, inferInScope) {\n    var key = node.property || node.key;\n    if (!node.computed && key.type == \"Identifier\") return key.name;\n    if (key.type == \"Literal\") {\n      if (typeof key.value == \"string\") return key.value;\n      if (typeof key.value == \"number\") return String(key.value);\n    }\n    if (inferInScope) {\n      var symName = symbolName(infer(key, inferInScope));\n      if (symName) return node.propName = symName;\n    } else if (node.propName) {\n      return node.propName;\n    }\n    return \"<i>\";\n  };\n  function symbolName(val) {\n    var sym = val.getSymbolType();\n    if (sym) return sym.asPropName();\n  }\n\n  function unopResultType(op) {\n    switch (op) {\n    case \"+\": case \"-\": case \"~\": return cx.num;\n    case \"!\": return cx.bool;\n    case \"typeof\": return cx.str;\n    case \"void\": case \"delete\": return ANull;\n    }\n  }\n  function binopIsBoolean(op) {\n    switch (op) {\n    case \"==\": case \"!=\": case \"===\": case \"!==\": case \"<\": case \">\": case \">=\": case \"<=\":\n    case \"in\": case \"instanceof\": return true;\n    }\n  }\n  function literalType(node) {\n    if (node.regex) return getInstance(cx.protos.RegExp);\n    switch (typeof node.value) {\n    case \"boolean\": return cx.bool;\n    case \"number\": return cx.num;\n    case \"string\": return cx.str;\n    case \"object\":\n    case \"function\":\n      if (!node.value) return ANull;\n      return getInstance(cx.protos.RegExp);\n    }\n  }\n\n  function join(a, b) {\n    if (a == b || b == ANull) return a;\n    if (a == ANull) return b;\n    var joined = new AVal;\n    a.propagate(joined);\n    b.propagate(joined);\n    return joined;\n  }\n\n  function connectParams(node, scope) {\n    for (var i = 0; i < node.params.length; i++) {\n      var param = node.params[i];\n      if (param.type == \"Identifier\") continue;\n      connectPattern(param, scope, node.scope.fnType.args[i]);\n    }\n  }\n\n  function ensureVar(node, scope) {\n    return scope.hasProp(node.name) || cx.topScope.defProp(node.name, node);\n  }\n\n  var inferPatternVisitor = exports.inferPatternVisitor = {\n    Identifier: function(node, scope, source) {\n      source.propagate(ensureVar(node, scope));\n    },\n    MemberExpression: function(node, scope, source) {\n      var obj = infer(node.object, scope);\n      var pName = propName(node, scope);\n      obj.propagate(new DefProp(pName, source, node.property));\n    },\n    RestElement: function(node, scope, source) {\n      connectPattern(node.argument, scope, new Arr(source));\n    },\n    ObjectPattern: function(node, scope, source) {\n      for (var i = 0; i < node.properties.length; ++i) {\n        var prop = node.properties[i];\n        if (prop.type == 'RestElement') { continue; }\n        connectPattern(prop.value, scope, source.getProp(propName(prop)));\n      }\n    },\n    ArrayPattern: function(node, scope, source) {\n      for (var i = 0; i < node.elements.length; i++)\n        if (node.elements[i])\n          connectPattern(node.elements[i], scope, source.getProp(String(i)));\n    },\n    AssignmentPattern: function(node, scope, source) {\n      connectPattern(node.left, scope, join(source, infer(node.right, scope)));\n    }\n  };\n\n  function connectPattern(node, scope, source) {\n    var connecter = inferPatternVisitor[node.type];\n    if (connecter) connecter(node, scope, source);\n  }\n\n  function getThis(scope) {\n    var fnScope = functionScope(scope);\n    return fnScope.fnType ? fnScope.fnType.self : fnScope;\n  }\n\n  function maybeAddPhantomObj(obj) {\n    if (!obj.isEmpty() || !obj.propertyOf) return;\n    obj.propertyOf.getProp(obj.propertyName).addType(new Obj, WG_PHANTOM_OBJ);\n    maybeAddPhantomObj(obj.propertyOf);\n  }\n\n  function inferClass(node, scope, name) {\n    if (!name && node.id) name = node.id.name;\n\n    var sup = cx.protos.Object, supCtor, delayed;\n    if (node.superClass) {\n      if (node.superClass.type == \"Literal\" && node.superClass.value == null) {\n        sup = null;\n      } else {\n        var supVal = infer(node.superClass, scope), supProto;\n        supCtor = supVal.getFunctionType();\n        if (supCtor && (supProto = supCtor.getProp(\"prototype\").getObjType())) {\n          sup = supProto;\n        } else {\n          supCtor = supVal;\n          delayed = supVal.getProp(\"prototype\");\n        }\n      }\n    }\n    var proto = new Obj(sup, name && name + \".prototype\");\n    if (delayed) delayed.propagate(new HasProto(proto));\n\n    return withSuper(supCtor, delayed || sup, function() {\n      var ctor, body = node.body.body;\n      for (var i = 0; i < body.length; i++)\n        if (body[i].kind == \"constructor\") ctor = body[i].value;\n      var fn = node.objType = ctor ? infer(ctor, scope) : new Fn(name, ANull, [], null, ANull);\n      fn.originNode = node.id || ctor || node;\n\n      var inst = getInstance(proto, fn);\n      fn.self.addType(inst);\n      fn.defProp(\"prototype\", node).addType(proto);\n      for (var i = 0; i < body.length; i++) {\n        var method = body[i], target;\n        if (method.kind == \"constructor\") continue;\n        var pName = propName(method, scope);\n        if (pName == \"<i>\" || method.kind == \"set\") {\n          target = ANull;\n        } else {\n          target = (method.static ? fn : proto).defProp(pName, method.key);\n          target.initializer = true;\n          if (method.kind == \"get\") target = new IsCallee(inst, [], null, target);\n        }\n        infer(method.value, scope, target);\n        var methodFn = target.getFunctionType();\n        if (methodFn) methodFn.self.addType(inst);\n      }\n      return fn;\n    });\n  }\n\n  function arrayLiteralType(elements, scope, inner) {\n    var tuple = elements.length > 1 && elements.length < 6;\n    if (tuple) {\n      var homogenous = true, litType;\n      for (var i = 0; i < elements.length; i++) {\n        var elt = elements[i];\n        if (!elt)\n          tuple = false;\n        else if (elt.type != \"Literal\" || (litType && litType != typeof elt.value))\n          homogenous = false;\n        else\n          litType = typeof elt.value;\n      }\n      if (homogenous) tuple = false;\n    }\n\n    if (tuple) {\n      var types = [];\n      for (var i = 0; i < elements.length; ++i)\n        types.push(inner(elements[i], scope));\n      return new Arr(types);\n    } else if (elements.length < 2) {\n      return new Arr(elements[0] && inner(elements[0], scope));\n    } else {\n      var eltVal = new AVal;\n      for (var i = 0; i < elements.length; i++)\n        if (elements[i]) inner(elements[i], scope).propagate(eltVal);\n      return new Arr(eltVal);\n    }\n  }\n\n  function ret(f) {\n    return function(node, scope, out, name) {\n      var r = f(node, scope, name);\n      if (out) r.propagate(out);\n      return r;\n    };\n  }\n  function fill(f) {\n    return function(node, scope, out, name) {\n      if (!out) out = new AVal;\n      f(node, scope, out, name);\n      return out;\n    };\n  }\n\n  var inferExprVisitor = exports.inferExprVisitor = {\n    ArrayExpression: ret(function(node, scope) {\n      return arrayLiteralType(node.elements, scope, infer);\n    }),\n    ObjectExpression: ret(function(node, scope, name) {\n      var proto = cx.protos.Object, waitForProto;\n      for (var i = 0; i < node.properties.length; ++i) {\n        var prop = node.properties[i];\n        if (prop.type == 'SpreadElement') { continue; }\n        if (prop.key.name == \"__proto__\") {\n          if (prop.value.type == \"Literal\" && prop.value.value == null) {\n            proto = null;\n          } else {\n            var protoVal = infer(prop.value, scope), known = protoVal.getObjType();\n            if (known) proto = known;\n            else waitForProto = protoVal;\n          }\n        }\n      }\n\n      var obj = node.objType = new Obj(proto, name);\n      if (waitForProto) waitForProto.propagate(new HasProto(obj));\n      obj.originNode = node;\n\n      withSuper(null, waitForProto || proto, function() {\n        for (var i = 0; i < node.properties.length; ++i) {\n          var prop = node.properties[i], key = prop.key;\n          if (prop.type == 'SpreadElement' || ignoredProp(prop.key.name)) continue;\n\n          var name = propName(prop, scope), target;\n          if (name == \"<i>\" || prop.kind == \"set\") {\n            target = ANull;\n          } else {\n            target = obj.defProp(name, key);\n            var val = target;\n            val.initializer = true;\n            if (prop.kind == \"get\")\n              target = new IsCallee(obj, [], null, val);\n          }\n          infer(prop.value, scope, target, name);\n          if (prop.value.type == \"FunctionExpression\")\n            prop.value.scope.fnType.self.addType(obj, WG_SPECULATIVE_THIS);\n        }\n      });\n      return obj;\n    }),\n    FunctionExpression: ret(function(node, scope, name) {\n      var inner = node.scope, fn = inner.fnType;\n      if (name && !fn.name) fn.name = name;\n      connectParams(node, inner);\n      if (node.expression)\n        infer(node.body, inner, inner.fnType.retval = new AVal);\n      else\n        walk.recursive(node.body, inner, null, inferWrapper, \"Statement\");\n      if (node.type == \"ArrowFunctionExpression\")\n        getThis(scope).propagate(fn.self);\n      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);\n      if (node.id) inner.getProp(node.id.name).addType(fn);\n      return fn;\n    }),\n    ClassExpression: ret(inferClass),\n    SequenceExpression: ret(function(node, scope) {\n      for (var i = 0, l = node.expressions.length - 1; i < l; ++i)\n        infer(node.expressions[i], scope, ANull);\n      return infer(node.expressions[l], scope);\n    }),\n    UnaryExpression: ret(function(node, scope) {\n      infer(node.argument, scope, ANull);\n      return unopResultType(node.operator);\n    }),\n    UpdateExpression: ret(function(node, scope) {\n      infer(node.argument, scope, ANull);\n      return cx.num;\n    }),\n    BinaryExpression: ret(function(node, scope) {\n      if (node.operator == \"+\") {\n        var lhs = infer(node.left, scope);\n        var rhs = infer(node.right, scope);\n        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;\n        if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;\n        var result = new AVal;\n        lhs.propagate(new IsAdded(rhs, result));\n        rhs.propagate(new IsAdded(lhs, result));\n        return result;\n      } else {\n        infer(node.left, scope, ANull);\n        infer(node.right, scope, ANull);\n        return binopIsBoolean(node.operator) ? cx.bool : cx.num;\n      }\n    }),\n    AssignmentExpression: ret(function(node, scope, name) {\n      var rhs, pName;\n      if (node.left.type == \"MemberExpression\") {\n        pName = propName(node.left, scope);\n        if (!name)\n          name = node.left.object.type == \"Identifier\" ? node.left.object.name + \".\" + pName : pName;\n      } else if (!name && node.left.type == \"Identifier\") {\n        name = node.left.name;\n      }\n\n      if (node.operator && node.operator != \"=\" && node.operator != \"+=\") {\n        infer(node.right, scope, ANull);\n        rhs = cx.num;\n      } else {\n        rhs = infer(node.right, scope, null, name);\n      }\n\n      if (node.left.type == \"MemberExpression\") {\n        var obj = infer(node.left.object, scope);\n        if (pName == \"prototype\") maybeInstantiate(scope, 20);\n        if (pName == \"<i>\") {\n          // This is a hack to recognize for/in loops that copy\n          // properties, and do the copying ourselves, insofar as we\n          // manage, because such loops tend to be relevant for type\n          // information.\n          var v = node.left.property.name, local = scope.props[v], over = local && local.iteratesOver;\n          if (over) {\n            maybeInstantiate(scope, 20);\n            var fromRight = node.right.type == \"MemberExpression\" && node.right.computed && node.right.property.name == v;\n            over.forAllProps(function(prop, val, local) {\n              if (local && prop != \"prototype\" && prop != \"<i>\")\n                obj.propagate(new DefProp(prop, fromRight ? val : ANull));\n            });\n            return rhs;\n          }\n        }\n\n        obj.propagate(new DefProp(pName, rhs, node.left.property));\n        maybeAddPhantomObj(obj);\n        if (node.right.type == \"FunctionExpression\")\n          obj.propagate(node.right.scope.fnType.self, WG_SPECULATIVE_THIS);\n      } else {\n        connectPattern(node.left, scope, rhs);\n      }\n      return rhs;\n    }),\n    LogicalExpression: fill(function(node, scope, out) {\n      infer(node.left, scope, out);\n      infer(node.right, scope, out);\n    }),\n    ConditionalExpression: fill(function(node, scope, out) {\n      infer(node.test, scope, ANull);\n      infer(node.consequent, scope, out);\n      infer(node.alternate, scope, out);\n    }),\n    NewExpression: fill(function(node, scope, out, name) {\n      if (node.callee.type == \"Identifier\" && node.callee.name in scope.props)\n        maybeInstantiate(scope, 20);\n\n      for (var i = 0, args = []; i < node.arguments.length; ++i)\n        args.push(infer(node.arguments[i], scope));\n      var callee = infer(node.callee, scope);\n      var self = new AVal;\n      callee.propagate(new IsCtor(self, name && /\\.prototype$/.test(name)));\n      self.propagate(out, WG_NEW_INSTANCE);\n      callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));\n    }),\n    CallExpression: fill(function(node, scope, out) {\n      for (var i = 0, args = []; i < node.arguments.length; ++i)\n        args.push(infer(node.arguments[i], scope));\n      var outerFn = functionScope(scope).fnType;\n      if (node.callee.type == \"MemberExpression\") {\n        var self = infer(node.callee.object, scope);\n        var pName = propName(node.callee, scope);\n        if (outerFn && (pName == \"call\" || pName == \"apply\") &&\n            outerFn.args.indexOf(self) > -1)\n          maybeInstantiate(scope, 30);\n        self.propagate(new HasMethodCall(pName, args, node.arguments, out));\n      } else if (node.callee.type == \"Super\" && cx.curSuperCtor) {\n        node.callee.superType = cx.curSuperCtor;\n        cx.curSuperCtor.propagate(new IsCallee(getThis(scope), args, node.arguments, out));\n        getThis(scope).propagate(out, WG_NEW_INSTANCE);\n      } else {\n        var callee = infer(node.callee, scope);\n        if (outerFn && outerFn.args.indexOf(callee) > -1)\n          maybeInstantiate(scope, 30);\n        var knownFn = callee.getFunctionType();\n        if (knownFn && knownFn.instantiateScore && outerFn)\n          maybeInstantiate(scope, knownFn.instantiateScore / 5);\n        callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));\n      }\n    }),\n    AwaitExpression: fill(function(node, scope, out, name) {\n      var arg = infer(node.argument, scope, null, name);\n      var tp = arg.getType();\n      if (tp && tp.constructor == Obj && tp.name == \"Promise\") {\n        if (tp.hasProp(\":t\")) {\n          tp.getProp(\":t\").propagate(out);\n        }\n      } else {\n        arg.propagate(out);\n      }\n    }),\n    MemberExpression: fill(function(node, scope, out) {\n      var name = propName(node), wg;\n      if (name == \"<i>\") {\n        var propType = infer(node.property, scope);\n        var symName = symbolName(propType);\n        if (symName)\n          name = node.propName = symName;\n        else if (!propType.hasType(cx.num))\n          wg = WG_MULTI_MEMBER;\n      }\n      infer(node.object, scope).getProp(name).propagate(out, wg);\n    }),\n    Identifier: ret(function(node, scope) {\n      if (node.name == \"arguments\") {\n        var fnScope = functionScope(scope, false);\n        if (fnScope.fnType && !(node.name in fnScope.props))\n          fnScope.defProp(node.name, fnScope.fnType.originNode)\n            .addType(new Arr(fnScope.fnType.arguments = new AVal));\n      }\n      return scope.getProp(node.name);\n    }),\n    ThisExpression: ret(function(_node, scope) {\n      return getThis(scope);\n    }),\n    Super: ret(function(node) {\n      return node.superType = cx.curSuper || ANull;\n    }),\n    Literal: ret(function(node) {\n      return literalType(node);\n    }),\n    TemplateLiteral: ret(function(node, scope) {\n      for (var i = 0; i < node.expressions.length; ++i)\n        infer(node.expressions[i], scope, ANull);\n      return cx.str;\n    }),\n    TaggedTemplateExpression: fill(function(node, scope, out) {\n      var args = [new Arr(cx.str)];\n      for (var i = 0; i < node.quasi.expressions.length; ++i)\n        args.push(infer(node.quasi.expressions[i], scope));\n      infer(node.tag, scope, new IsCallee(cx.topScope, args, node.quasi.expressions, out));\n    }),\n    YieldExpression: ret(function(node, scope) {\n      var output = ANull, fn = functionScope(scope).fnType;\n      if (fn) {\n        if (fn.retval == ANull) fn.retval = new AVal;\n        if (!fn.yieldval) fn.yieldval = new AVal;\n        output = fn.retval;\n      }\n      if (node.argument) {\n        if (node.delegate) {\n          infer(node.argument, scope, new HasMethodCall(\"next\", [], null,\n                                                        new GetProp(\"value\", output)));\n        } else {\n          infer(node.argument, scope, output);\n        }\n      }\n      return fn ? fn.yieldval : ANull;\n    })\n  };\n  inferExprVisitor.ArrowFunctionExpression = inferExprVisitor.FunctionExpression;\n\n  function infer(node, scope, out, name) {\n    var handler = inferExprVisitor[node.type];\n    return handler ? handler(node, scope, out, name) : ANull;\n  }\n\n  function loopPattern(init) {\n    return init.type == \"VariableDeclaration\" ? init.declarations[0].id : init;\n  }\n\n  var inferWrapper = exports.inferWrapper = walk.make({\n    Expression: function(node, scope) {\n      infer(node, node.scope || scope, ANull);\n    },\n\n    ObjectExpression: function(node, scope) {\n      infer(node, node.scope || scope, ANull);\n    },\n\n    FunctionDeclaration: function(node, scope, c) {\n      var inner = node.scope, fn = inner.fnType;\n      connectParams(node, inner);\n      c(node.body, inner, \"Statement\");\n      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);\n      if (node.id) scope.getProp(node.id.name).addType(fn);\n    },\n\n    Statement: function(node, scope, c) {\n      c(node, node.scope || scope);\n    },\n\n    ExportDefaultDeclaration: function(node, scope, c) {\n      c(node.declaration, node.scope || scope);\n    },\n\n    VariableDeclaration: function(node, scope) {\n      for (var i = 0; i < node.declarations.length; ++i) {\n        var decl = node.declarations[i];\n        if (decl.id.type == \"Identifier\") {\n          var prop = scope.getProp(decl.id.name);\n          if (decl.init)\n            infer(decl.init, scope, prop, decl.id.name);\n        } else if (decl.init) {\n          connectPattern(decl.id, scope, infer(decl.init, scope));\n        }\n      }\n    },\n\n    ClassDeclaration: function(node, scope) {\n      if (!node.id) inferClass(node, scope);\n      else scope.getProp(node.id.name).addType(inferClass(node, scope, node.id.name));\n    },\n\n    ReturnStatement: function(node, scope) {\n      if (!node.argument) return;\n      var output = ANull, fn = functionScope(scope).fnType;\n      if (fn) {\n        if (fn.retval == ANull) fn.retval = new AVal;\n        output = fn.retval;\n      }\n      infer(node.argument, scope, output);\n    },\n\n    ForInStatement: function(node, scope, c) {\n      var source = infer(node.right, scope);\n      if ((node.right.type == \"Identifier\" && node.right.name in scope.props) ||\n          (node.right.type == \"MemberExpression\" && node.right.property.name == \"prototype\")) {\n        maybeInstantiate(scope, 5);\n        var pattern = loopPattern(node.left);\n        if (pattern.type == \"Identifier\") {\n          if (pattern.name in scope.props)\n            scope.getProp(pattern.name).iteratesOver = source;\n          source.getProp(\"<i>\").propagate(ensureVar(pattern, scope));\n        } else {\n          connectPattern(pattern, scope, source.getProp(\"<i>\"));\n        }\n      }\n      c(node.body, scope, \"Statement\");\n    },\n\n    ForOfStatement: function(node, scope, c) {\n      var pattern = loopPattern(node.left), target;\n      if (pattern.type == \"Identifier\")\n        target = ensureVar(pattern, scope);\n      else\n        connectPattern(pattern, scope, target = new AVal);\n\n      if (node.await) {\n        infer(node.right, scope, new HasMethodCall(\":Symbol.asyncIterator\", [], null,\n                                                   new HasMethodCall(\"next\", [], null,\n                                                                     new GetProp(\":t\",\n                                                                                 new GetProp(\"value\", target)))));\n      } else {\n        infer(node.right, scope, new HasMethodCall(\":Symbol.iterator\", [], null,\n                                                   new HasMethodCall(\"next\", [], null,\n                                                                     new GetProp(\"value\", target))));\n      }\n      c(node.body, scope, \"Statement\");\n    }\n  });\n\n  // PARSING\n\n  var parse = exports.parse = function(text, options, thirdArg) {\n    if (!options || Array.isArray(options)) options = thirdArg;\n    var ast;\n    try { ast = acorn.parse(text, options); }\n    catch(e) { ast = acorn_loose.parse(text, options); }\n    return ast;\n  };\n\n  // ANALYSIS INTERFACE\n\n  exports.analyze = function(ast, name, scope) {\n    if (typeof ast == \"string\") ast = parse(ast);\n\n    if (!name) name = \"file#\" + cx.origins.length;\n    exports.addOrigin(cx.curOrigin = name);\n\n    if (!scope) scope = cx.topScope;\n    cx.startAnalysis();\n\n    walk.recursive(ast, scope, null, scopeGatherer);\n    if (cx.parent) cx.parent.signal(\"preInfer\", ast, scope);\n    walk.recursive(ast, scope, null, inferWrapper);\n    if (cx.parent) cx.parent.signal(\"postInfer\", ast, scope);\n\n    cx.curOrigin = null;\n  };\n\n  // PURGING\n\n  exports.purge = function(origins, start, end) {\n    var test = makePredicate(origins, start, end);\n    ++cx.purgeGen;\n    cx.topScope.purge(test);\n    for (var prop in cx.props) {\n      var list = cx.props[prop];\n      for (var i = 0; i < list.length; ++i) {\n        var obj = list[i], av = obj.props[prop];\n        if (!av || test(av, av.originNode)) list.splice(i--, 1);\n      }\n      if (!list.length) delete cx.props[prop];\n    }\n  };\n\n  function makePredicate(origins, start, end) {\n    var arr = Array.isArray(origins);\n    if (arr && origins.length == 1) { origins = origins[0]; arr = false; }\n    if (arr) {\n      if (end == null) return function(n) { return origins.indexOf(n.origin) > -1; };\n      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1; };\n    } else {\n      if (end == null) return function(n) { return n.origin == origins; };\n      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && n.origin == origins; };\n    }\n  }\n\n  AVal.prototype.purge = function(test) {\n    if (this.purgeGen == cx.purgeGen) return;\n    this.purgeGen = cx.purgeGen;\n    for (var i = 0; i < this.types.length; ++i) {\n      var type = this.types[i];\n      if (test(type, type.originNode))\n        this.types.splice(i--, 1);\n      else\n        type.purge(test);\n    }\n    if (!this.types.length) this.maxWeight = 0;\n\n    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {\n      var f = this.forward[i];\n      if (test(f)) {\n        this.forward.splice(i--, 1);\n        if (this.props) this.props = null;\n      } else if (f.purge) {\n        f.purge(test);\n      }\n    }\n  };\n  ANull.purge = function() {};\n  Obj.prototype.purge = function(test) {\n    if (this.purgeGen == cx.purgeGen) return true;\n    this.purgeGen = cx.purgeGen;\n    for (var p in this.props) {\n      var av = this.props[p];\n      if (test(av, av.originNode))\n        this.removeProp(p);\n      av.purge(test);\n    }\n  };\n  Fn.prototype.purge = function(test) {\n    if (Obj.prototype.purge.call(this, test)) return;\n    this.self.purge(test);\n    this.retval.purge(test);\n    for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);\n  };\n\n  // EXPRESSION TYPE DETERMINATION\n\n  function findByPropertyName(name) {\n    guessing = true;\n    var found = objsWithProp(name);\n    if (found) for (var i = 0; i < found.length; ++i) {\n      var val = found[i].getProp(name);\n      if (!val.isEmpty()) return val;\n    }\n    return ANull;\n  }\n\n  function generatorResult(input, output, async) {\n    var defs = cx.definitions.ecmascript;\n    var valObj = new Obj(true);\n    valObj.defProp(\"done\").addType(cx.bool);\n    output.propagate(valObj.defProp(\"value\"));\n    var retObj = valObj;\n    if (async && defs) {\n      retObj = new Obj(defs[\"Promise.prototype\"]);\n      retObj.getType().propagate(new DefProp(':t', valObj));\n    }\n    var method = new Fn(null, ANull, input ? [input] : [], input ? [\"?\"] : [], retObj);\n    var result = new Obj(defs ? async ? defs.async_generator_prototype : defs.generator_prototype : true);\n    result.defProp(\"next\").addType(method);\n    return result;\n  }\n\n  function maybeIterator(fn, output) {\n    if (!fn.generator) return output;\n    if (!fn.computeRet) { // Reuse iterator objects for non-computed return types\n      if (fn.generator === true) fn.generator = generatorResult(fn.yieldval, output, fn.async);\n      return fn.generator;\n    }\n    return generatorResult(fn.yieldval, output, fn.async);\n  }\n\n  function computeReturnType(funcNode, argNodes, scope) {\n    var fn = findType(funcNode, scope).getFunctionType();\n    if (!fn) return ANull;\n    var result = fn.retval;\n    if (fn.computeRet) {\n      for (var i = 0, args = []; i < argNodes.length; ++i)\n        args.push(findType(argNodes[i], scope));\n      var self = ANull;\n      if (funcNode.type == \"MemberExpression\")\n        self = findType(funcNode.object, scope);\n      result = fn.computeRet(self, args, argNodes);\n    }\n    return maybeIterator(fn, result);\n  }\n\n  var typeFinder = exports.typeFinder = {\n    ArrayExpression: function(node, scope) {\n      return arrayLiteralType(node.elements, scope, findType);\n    },\n    ObjectExpression: function(node) {\n      return node.objType;\n    },\n    ClassDeclaration: function(node) {\n      return node.objType;\n    },\n    ClassExpression: function(node) {\n      return node.objType;\n    },\n    FunctionDeclaration: function(node) {\n      return node.scope.fnType;\n    },\n    FunctionExpression: function(node) {\n      return node.scope.fnType;\n    },\n    ArrowFunctionExpression: function(node) {\n      return node.scope.fnType;\n    },\n    SequenceExpression: function(node, scope) {\n      return findType(node.expressions[node.expressions.length-1], scope);\n    },\n    UnaryExpression: function(node) {\n      return unopResultType(node.operator);\n    },\n    UpdateExpression: function() {\n      return cx.num;\n    },\n    BinaryExpression: function(node, scope) {\n      if (binopIsBoolean(node.operator)) return cx.bool;\n      if (node.operator == \"+\") {\n        var lhs = findType(node.left, scope);\n        var rhs = findType(node.right, scope);\n        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;\n      }\n      return cx.num;\n    },\n    AssignmentExpression: function(node, scope) {\n      return findType(node.right, scope);\n    },\n    LogicalExpression: function(node, scope) {\n      var lhs = findType(node.left, scope);\n      return lhs.isEmpty() ? findType(node.right, scope) : lhs;\n    },\n    ConditionalExpression: function(node, scope) {\n      var lhs = findType(node.consequent, scope);\n      return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;\n    },\n    NewExpression: function(node, scope) {\n      var f = findType(node.callee, scope).getFunctionType();\n      var proto = f && f.getProp(\"prototype\").getObjType();\n      if (!proto) return ANull;\n      return getInstance(proto, f);\n    },\n    CallExpression: function(node, scope) {\n      return computeReturnType(node.callee, node.arguments, scope);\n    },\n    MemberExpression: function(node, scope) {\n      var propN = propName(node), obj = findType(node.object, scope).getType();\n      if (obj) return obj.getProp(propN);\n      if (propN == \"<i>\") return ANull;\n      return findByPropertyName(propN);\n    },\n    MethodDefinition: function(node) {\n      var propN = propName(node), obj = getThis(node.value.scope).getType();\n      if (obj) return obj.getProp(propN);\n      return ANull;\n    },\n    Identifier: function(node, scope) {\n      return scope.hasProp(node.name) || ANull;\n    },\n    ThisExpression: function(_node, scope) {\n      return getThis(scope);\n    },\n    Literal: function(node) {\n      return literalType(node);\n    },\n    Super: ret(function(node) {\n      return node.superType;\n    }),\n    TemplateLiteral: function() {\n      return cx.str;\n    },\n    TaggedTemplateExpression: function(node, scope) {\n      return computeReturnType(node.tag, node.quasi.expressions, scope);\n    },\n    YieldExpression: function(_node, scope) {\n      var fn = functionScope(scope).fnType;\n      return fn ? fn.yieldval : ANull;\n    }\n  };\n\n  function findType(node, scope) {\n    var finder = typeFinder[node.type];\n    return finder ? finder(node, scope) : ANull;\n  }\n\n  var searchVisitor = exports.searchVisitor = walk.make({\n    Function: function(node, _st, c) {\n      walk.base.Function(node, node.scope, c);\n    },\n    CatchClause: function(node, _st, c) {\n      walk.base.CatchClause(node, node.scope, c);\n    },\n    Property: function(node, st, c) {\n      if (node.computed) c(node.key, st, \"Expression\");\n      if (node.key != node.value) c(node.value, st, \"Expression\");\n    },\n    Statement: function(node, st, c) {\n      c(node, node.scope || st);\n    },\n    ImportSpecifier: function(node, st, c) {\n      c(node.local, st);\n    },\n    ImportDefaultSpecifier: function(node, st, c) {\n      c(node.local, st);\n    },\n    ImportNamespaceSpecifier: function(node, st, c) {\n      c(node.local, st);\n    }\n  });\n  var searchExprVisitor = exports.searchExprVisitor = walk.make({\n    MemberExpression: function(node, st, c) {\n      c(node.object, st, \"Expression\");\n      if (node.computed) { c(node.property, st, \"Expression\"); }\n    },\n    Property: function(node, st, c) {\n      if (node.computed) c(node.key, st, \"Expression\");\n      c(node.value, st, \"Expression\");\n    }\n  }, searchVisitor);\n  exports.fullVisitor = walk.make({\n    MemberExpression: function(node, st, c) {\n      c(node.object, st, \"Expression\");\n      c(node.property, st, node.computed ? \"Expression\" : null);\n    },\n    Property: function(node, st, c) {\n      if (node.computed) c(node.key, st, \"Expression\");\n      c(node.value, st, \"Expression\");\n    }\n  }, searchVisitor);\n\n  exports.findExpressionAt = function(ast, start, end, defaultScope, filter) {\n    var test = filter || function(_t, node) {\n      if (node.type == \"Identifier\" && node.name == \"✖\") return false;\n      return typeFinder.hasOwnProperty(node.type);\n    };\n    return walk.findNodeAt(ast, start, end, test, searchExprVisitor, defaultScope || cx.topScope);\n  };\n  exports.findClosestExpression = function(ast, start, end, defaultScope, filter) {\n    var test = filter || function(_t, node) {\n      if (start != null && node.start > start) return false;\n      if (node.type == \"Identifier\" && node.name == \"✖\") return false;\n      return typeFinder.hasOwnProperty(node.type);\n    };\n    return walk.findNodeAround(ast, end, test, searchExprVisitor, defaultScope || cx.topScope);\n  };\n\n  exports.findExpressionAround = function(ast, start, end, defaultScope, filter) {\n    var test = filter || function(_t, node) {\n      if (start != null && node.start > start) return false;\n      if (node.type == \"Identifier\" && node.name == \"✖\") return false;\n      return typeFinder.hasOwnProperty(node.type);\n    };\n    return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);\n  };\n\n  exports.expressionType = function(found) {\n    return findType(found.node, found.state);\n  };\n\n  // Finding the expected type of something, from context\n\n  exports.parentNode = function(child, ast) {\n    var stack = [];\n    function c(node, st, override) {\n      if (node.start <= child.start && node.end >= child.end) {\n        var top = stack[stack.length - 1];\n        if (node == child) throw {found: top};\n        if (top != node) stack.push(node);\n        walk.base[override || node.type](node, st, c);\n        if (top != node) stack.pop();\n      }\n    }\n    try {\n      c(ast, null);\n    } catch (e) {\n      if (e.found) return e.found;\n      throw e;\n    }\n  };\n\n  var findTypeFromContext = exports.findTypeFromContext = {\n    ArrayExpression: function(parent, _, get) { return get(parent, true).getProp(\"<i>\"); },\n    ObjectExpression: function(parent, node, get) {\n      for (var i = 0; i < parent.properties.length; ++i) {\n        var prop = node.properties[i];\n        if (prop.value == node)\n          return get(parent, true).getProp(propName(prop));\n      }\n    },\n    UnaryExpression: function(parent) { return unopResultType(parent.operator); },\n    UpdateExpression: function() { return cx.num; },\n    BinaryExpression: function(parent) { return binopIsBoolean(parent.operator) ? cx.bool : cx.num; },\n    AssignmentExpression: function(parent, _, get) { return get(parent.left); },\n    LogicalExpression: function(parent, _, get) { return get(parent, true); },\n    ConditionalExpression: function(parent, node, get) {\n      if (parent.consequent == node || parent.alternate == node) return get(parent, true);\n    },\n    CallExpression: function(parent, node, get) {\n      for (var i = 0; i < parent.arguments.length; i++) {\n        var arg = parent.arguments[i];\n        if (arg == node) {\n          var calleeType = get(parent.callee).getFunctionType();\n          if (calleeType instanceof Fn)\n            return calleeType.args[i];\n          break;\n        }\n      }\n    },\n    ReturnStatement: function(_parent, node, get) {\n      // tweaking search position to avoid endless recursion\n      // when looking for definition of key in fn ( return fn ( return object ) )\n      // see ternjs/tern#777\n      var fnNode = walk.findNodeAround(node.sourceFile.ast, node.start - 1, \"Function\");\n      if (fnNode) {\n        var fnType = fnNode.node.type != \"FunctionDeclaration\"\n          ? get(fnNode.node, true).getFunctionType()\n          : fnNode.node.scope.fnType;\n        if (fnType) return fnType.retval.getType();\n      }\n    },\n    VariableDeclarator: function(parent, node, get) {\n      if (parent.init == node) return get(parent.id);\n    }\n  };\n  findTypeFromContext.NewExpression = findTypeFromContext.CallExpression;\n\n  exports.typeFromContext = function(ast, found) {\n    var parent = exports.parentNode(found.node, ast);\n    var type = null;\n    if (findTypeFromContext.hasOwnProperty(parent.type)) {\n      var finder = findTypeFromContext[parent.type];\n      type = finder && finder(parent, found.node, function(node, fromContext) {\n        var obj = {node: node, state: found.state};\n        var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);\n        return tp || ANull;\n      });\n    }\n    return type || exports.expressionType(found);\n  };\n\n  // Flag used to indicate that some wild guessing was used to produce\n  // a type or set of completions.\n  var guessing = false;\n\n  exports.resetGuessing = function(val) { guessing = val; };\n  exports.didGuess = function() { return guessing; };\n\n  exports.forAllPropertiesOf = function(type, f) {\n    type.gatherProperties(f, 0);\n  };\n\n  exports.findRefs = function(ast, baseScope, name, refScope, f) {\n    function handleId(node, scope, ancestors) {\n      var parent = ancestors[ancestors.length - 2];\n      if (parent.type == \"MemberExpression\" && !parent.computed && !!node.object) return;\n      if (node.name != name ||\n          (node == ast.id && ast.type == \"FunctionDeclaration\")) return;\n      if (parent.property === node) return;\n      for (var s = scope; s; s = s.prev) {\n        if (s == refScope) f(node, scope, ancestors);\n        if (name in s.props) return;\n      }\n    }\n    walk.ancestor(ast, {Identifier: handleId, VariablePattern: handleId},\n                  exports.fullVisitor, baseScope);\n  };\n\n  var simpleWalker = walk.make({\n    Function: function(node, _scope, c) {\n      c(node.body, node.scope, node.expression ? \"Expression\" : \"Statement\");\n    },\n    Statement: function(node, scope, c) {\n      c(node, node.scope || scope);\n    }\n  });\n\n  exports.findPropRefs = function(ast, scope, objType, name, f) {\n    // Find the type which owns the property in hierarchy\n    while (objType && !objType.props[name] && !(objType.maybeProps && objType.maybeProps[name])) {\n      objType = objType.proto;\n    }\n    if (!objType) throw new Error(\"Couldn't locate property in the base object type.\");\n\n    function isObjTypeProto(type) {\n      // Check whether the found type has objType in its hierarchy\n      while (type && type != objType) {\n        // Ff property is overriden higher in the hierarchy, return false\n        if (type.props[name] || (type.maybeProps && type.maybeProps[name])) {\n          return false;\n        }\n        type = type.proto;\n      }\n      return type;\n    }\n\n    walk.simple(ast, {\n      MemberExpression: function(node, scope) {\n        if (node.computed || propName(node) != name) return;\n        if (isObjTypeProto(findType(node.object, scope).getType())) f(node.property, scope);\n      },\n      ObjectExpression: function(node, scope) {\n        if (findType(node, scope).getType() != objType) return;\n        for (var i = 0; i < node.properties.length; ++i)\n          if (propName(node.properties[i]) == name) f(node.properties[i].key, scope);\n      },\n      MethodDefinition: function(node) {\n        if (propName(node) != name) return;\n        if (node.value && isObjTypeProto(getThis(node.value.scope).getType())) f(node.key, node.value.scope);\n      }\n    }, simpleWalker, scope);\n  };\n\n  // LOCAL-VARIABLE QUERIES\n\n  var scopeAt = exports.scopeAt = function(ast, pos, defaultScope) {\n    var found = walk.findNodeAround(ast, pos, function(_, node) {\n      return node.scope;\n    });\n    if (found) return found.node.scope;\n    else return defaultScope || cx.topScope;\n  };\n\n  exports.forAllLocalsAt = function(ast, pos, defaultScope, f) {\n    var scope = scopeAt(ast, pos, defaultScope);\n    scope.gatherProperties(f, 0);\n  };\n\n  // INIT DEF MODULE\n\n  // Delayed initialization because of cyclic dependencies.\n  def = exports.def = def.init({}, exports);\n});\n"],"file":"infer.js"}
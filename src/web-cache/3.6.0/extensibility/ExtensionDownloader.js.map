{"version":3,"sources":["extensibility/ExtensionDownloader.js"],"names":["define","require","exports","module","EventDispatcher","ExtensionLoader","Package","FileSystem","ZipUtils","makeEventDispatcher","EVENT_DOWNLOAD_FILE_PROGRESS","EVENT_EXTRACT_FILE_PROGRESS","downloadCancelled","_unzipExtension","data","projectPath","flattenFirstLevelInZip","progressCb","Promise","resolve","reject","unzipBinDataToLocation","then","catch","_getExtensionName","fileNameHint","guessedName","path","basename","substring","lastIndexOf","downloadFile","downloadId","url","filenameHint","destinationDirectory","_proxy","d","$","Deferred","getUserExtensionPath","console","log","window","JSZipUtils","getBinaryContent","callback","async","err","error","_progressCB","done","total","trigger","getFileForPath","unlink","extractErr","unlinkError","progress","status","percent","abortCheck","promise","abortDownload","install","config","name","nameHint","installationStatus","InstallationStatuses","INSTALLED","installedTo","remove","update"],"mappings":"AAsBAA,OAAO,SAAUC,QAASC,QAASC,QAC/B,MAAMC,gBAAkBH,QAAQ,yBAC5BI,gBAAkBJ,QAAQ,yBAC1BK,QAAWL,QAAQ,yBACnBM,WAAaN,QAAQ,yBACrBO,SAAWP,QAAQ,kBACvBG,gBAAgBK,oBAAoBP,SAEpC,MAAMQ,6BAA+B,mBACjCC,4BAA8B,kBAC9BC,kBAAoB,GAExB,SAASC,gBAAgBC,KAAMC,YAAaC,uBAAwBC,YAChE,OAAO,IAAIC,QAAQ,CAACC,QAASC,UACzBZ,SAASa,uBAAuBP,KAAMC,YAAaC,uBAAwBC,YACtEK,KAAKH,SACLI,MAAMH,UAInB,SAASI,kBAAkBC,cACvB,IAAIC,YAAcC,KAAKC,SAASH,aAAc,QAE9C,OADAC,YAAcA,YAAYG,UAAU,EAAGH,YAAYI,YAAY,MAInE,SAASC,aAAaC,YAAYC,IAACA,IAAGC,aAAEA,aAAYC,qBAAEA,sBAAuBC,QACzE,MAAMC,EAAI,IAAIC,EAAEC,SAChB,IAAIb,YAAcF,kBAAkBU,cAiDpC,OAhDAC,qBAAuBA,sBAAwB9B,gBAAgBmC,uBAC/DC,QAAQC,IAAI,qBAAsBV,WAAYC,IAAKC,aAAcR,aACjEiB,OAAOC,WAAWC,iBAAiBZ,IAAK,CACpCa,SAAUC,eAAeC,IAAKlC,MAC1B,GAAGF,kBAAkBoB,YACjBK,EAAEjB,gBACKR,kBAAkBoB,iBACtB,GAAGgB,IACNP,QAAQQ,MAAM,yCAA0CD,KACxDX,EAAEjB,aACC,CACH,SAAS8B,YAAYC,KAAMC,OAEvB,OADAlD,QAAQmD,QAAQ1C,4BAA6BwC,KAAMC,QAC3CxC,kBAAkBoB,YAE9BzB,WAAW+C,eAAenB,qBAAuB,IAAMT,aAAa6B,OAAO,KAEvEd,QAAQC,IAAI,yBAA0BV,WAAYC,IAAKC,aAAcR,aACrEb,gBAAgBC,KAAMqB,qBAAuB,IAAMT,aAAa,EAAMwB,aACjE5B,KAAK,KACFmB,QAAQC,IAAI,8BAA+BV,WAAYC,IAAKC,aAAcR,aAC1EW,EAAElB,QAAQgB,qBAAuB,IAAMT,eAE1CH,MAAOiC,aACJf,QAAQQ,MAAM,8CAA+CO,YAC7DjD,WAAW+C,eAAenB,qBAAuB,IAAMT,aAClD6B,OAAQE,cACFA,aACChB,QAAQQ,MAAM,wCACVd,qBAAuB,IAAMsB,aAErCpB,EAAEjB,iBAM9BsC,SAAU,SAAUC,QACM,MAAnBA,OAAOC,QAIV1D,QAAQmD,QAAQ3C,6BAA8BiD,OAAOC,SAAW,GAH5D1D,QAAQmD,QAAQ1C,4BAA6B,IAKrDkD,WAAY,WACR,OAAOjD,kBAAkBoB,eAG1BK,EAAEyB,UAGb,SAASC,cAAc/B,YACnBpB,kBAAkBoB,aAAc,EAGpC,SAASgC,QAAQrC,KAAMQ,qBAAsB8B,QACzC,MAAM5B,EAAI,IAAIC,EAAEC,SAOhB,OALAF,EAAElB,QAAQ,CACN+C,KAAM1C,kBAAkByC,OAAOE,UAC/BC,mBAAoB9D,QAAQ+D,qBAAqBC,UACjDC,YAAa5C,OAEVU,EAAEyB,UAUb,SAASU,OAAO7C,MACZ,MAAMU,EAAI,IAAIC,EAAEC,SAQhB,OAPAhC,WAAW+C,eAAe3B,MAAM4B,OAAOP,MAChCA,IACCX,EAAEjB,SAGNiB,EAAElB,YAECkB,EAAEyB,UAGb5D,QAAQ6B,aAAeA,aACvB7B,QAAQ6D,cAAgBA,cACxB7D,QAAQ8D,QAAUA,QAClB9D,QAAQsE,OAASA,OACjBtE,QAAQuE,OAAST,QACjB9D,QAAQQ,6BAA+BA,6BACvCR,QAAQS,4BAA8BA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global path*/\n\ndefine(function (require, exports, module) {\n    const EventDispatcher = require(\"utils/EventDispatcher\"),\n        ExtensionLoader = require(\"utils/ExtensionLoader\"),\n        Package  = require(\"extensibility/Package\"),\n        FileSystem = require(\"filesystem/FileSystem\"),\n        ZipUtils = require(\"utils/ZipUtils\");\n    EventDispatcher.makeEventDispatcher(exports);\n\n    const EVENT_DOWNLOAD_FILE_PROGRESS = \"DownloadProgress\",\n        EVENT_EXTRACT_FILE_PROGRESS = \"ExtractProgress\",\n        downloadCancelled = {};\n\n    function _unzipExtension(data, projectPath, flattenFirstLevelInZip, progressCb) {\n        return new Promise((resolve, reject)=>{\n            ZipUtils.unzipBinDataToLocation(data, projectPath, flattenFirstLevelInZip, progressCb)\n                .then(resolve)\n                .catch(reject);\n        });\n    }\n\n    function _getExtensionName(fileNameHint) {\n        let guessedName = path.basename(fileNameHint, \".zip\"); //Eg. c/x/rain.monokai-dark-soda-1.0.9.zip is input\n        guessedName = guessedName.substring(0, guessedName.lastIndexOf(\"-\"));\n        return guessedName; //rain.monokai-dark-soda\n    }\n\n    function downloadFile(downloadId, {url, filenameHint, destinationDirectory}, _proxy) {\n        const d = new $.Deferred();\n        let guessedName = _getExtensionName(filenameHint);\n        destinationDirectory = destinationDirectory || ExtensionLoader.getUserExtensionPath();\n        console.log(\"Download extension\", downloadId, url, filenameHint, guessedName);\n        window.JSZipUtils.getBinaryContent(url, {\n            callback: async function(err, data) {\n                if(downloadCancelled[downloadId]){\n                    d.reject();\n                    delete downloadCancelled[downloadId];\n                } else if(err) {\n                    console.error(\"could not download extension zip file!\", err);\n                    d.reject();\n                } else {\n                    function _progressCB(done, total) {\n                        exports.trigger(EVENT_EXTRACT_FILE_PROGRESS, done, total);\n                        return !downloadCancelled[downloadId]; // continueExtraction id not download cancelled\n                    }\n                    FileSystem.getFileForPath(destinationDirectory + \"/\" + guessedName).unlink(()=>{\n                        // we dont mind the error if there is any to delete the folder\n                        console.log(\"[Extension] extracting\", downloadId, url, filenameHint, guessedName);\n                        _unzipExtension(data, destinationDirectory + \"/\" + guessedName, true, _progressCB)\n                            .then(()=>{\n                                console.log(\"[Extension] extraction done\", downloadId, url, filenameHint, guessedName);\n                                d.resolve(destinationDirectory + \"/\" + guessedName);\n                            })\n                            .catch((extractErr)=>{\n                                console.error(\"Error extracting extension zip, cleaning up\", extractErr);\n                                FileSystem.getFileForPath(destinationDirectory + \"/\" + guessedName)\n                                    .unlink((unlinkError)=>{\n                                        if(unlinkError){\n                                            console.error(\"Error cleaning up extenstion folder: \",\n                                                destinationDirectory + \"/\" + unlinkError);\n                                        }\n                                        d.reject();\n                                    });\n                            });\n                    });\n                }\n            },\n            progress: function (status){\n                if(status.percent === 100) {\n                    exports.trigger(EVENT_EXTRACT_FILE_PROGRESS, 0);\n                    return;\n                }\n                exports.trigger(EVENT_DOWNLOAD_FILE_PROGRESS, status.percent || 0);\n            },\n            abortCheck: function () {\n                return downloadCancelled[downloadId];\n            }\n        });\n        return d.promise();\n    }\n\n    function abortDownload(downloadId) {\n        downloadCancelled[downloadId] = true;\n    }\n\n    function install(path, destinationDirectory, config) {\n        const d = new $.Deferred();\n        // if we reached here in phoenix, install succeded\n        d.resolve({\n            name: _getExtensionName(config.nameHint),\n            installationStatus: Package.InstallationStatuses.INSTALLED,\n            installedTo: path\n        });\n        return d.promise();\n    }\n\n    /**\n     * Removes the extension at the given path.\n     *\n     * @param {string} path The absolute path to the extension to remove.\n     * @return {$.Promise} A promise that's resolved when the extension is removed, or\n     *     rejected if there was an error.\n     */\n    function remove(path) {\n        const d = new $.Deferred();\n        FileSystem.getFileForPath(path).unlink(err=>{\n            if(err){\n                d.reject();\n                return;\n            }\n            d.resolve();\n        });\n        return d.promise();\n    }\n\n    exports.downloadFile = downloadFile;\n    exports.abortDownload = abortDownload;\n    exports.install = install;\n    exports.remove = remove;\n    exports.update = install;\n    exports.EVENT_DOWNLOAD_FILE_PROGRESS = EVENT_DOWNLOAD_FILE_PROGRESS;\n    exports.EVENT_EXTRACT_FILE_PROGRESS = EVENT_EXTRACT_FILE_PROGRESS;\n});\n"],"file":"ExtensionDownloader.js"}
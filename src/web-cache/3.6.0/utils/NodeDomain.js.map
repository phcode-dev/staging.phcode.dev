{"version":3,"sources":["utils/NodeDomain.js"],"names":["define","require","exports","module","NodeConnection","EventDispatcher","EVENT_NAMESPACE","NodeDomain","domainName","domainPath","connection","this","_domainName","_domainPath","_domainLoaded","_load","bind","_connectionPromise","connect","then","on","event","promise","off","makeEventDispatcher","prototype","loadDomains","done","eventNames","Object","keys","domainEvents","forEach","domainEvent","connectionEvent","params","Array","slice","call","arguments","triggerWithArray","fail","err","console","error","ready","connected","deferred","$","Deferred","resolve","reject","exec","name","execConnected","domain","domains","fn","execResult","apply","result"],"mappings":"AAqBAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,eAAiBH,QAAQ,wBACzBI,gBAAkBJ,QAAQ,yBAG1BK,gBAAkB,mBA4BtB,SAASC,WAAWC,WAAYC,YAC5B,IAAIC,WAAa,IAAIN,eAErBO,KAAKD,WAAaA,WAClBC,KAAKC,YAAcJ,WACnBG,KAAKE,YAAcJ,WACnBE,KAAKG,eAAgB,EACrBH,KAAKI,MAAQJ,KAAKI,MAAMC,KAAKL,MAC7BA,KAAKM,mBAAqBP,WAAWQ,SAAQ,GACxCC,KAAKR,KAAKI,OAEfL,WAAWU,GAAG,QAAS,SAAUC,MAAOC,SACpCX,KAAKD,WAAWa,IAAIjB,iBACpBK,KAAKG,eAAgB,EACrBH,KAAKM,mBAAqBK,QAAQH,KAAKR,KAAKI,QAC9CC,KAAKL,OAEXN,gBAAgBmB,oBAAoBjB,WAAWkB,WAO/ClB,WAAWkB,UAAUf,WAAa,KASlCH,WAAWkB,UAAUR,mBAAqB,KAQ1CV,WAAWkB,UAAUb,YAAc,KAQnCL,WAAWkB,UAAUZ,YAAc,KAQnCN,WAAWkB,UAAUX,eAAgB,EAUrCP,WAAWkB,UAAUV,MAAQ,WACzB,IAAIL,WAAaC,KAAKD,WACtB,OAAOA,WAAWgB,YAAYf,KAAKE,aAAa,GAC3Cc,KAAK,WAIF,IAAIC,WAHJjB,KAAKG,eAAgB,EACrBH,KAAKM,mBAAqB,KAETY,OAAOC,KAAKpB,WAAWqB,aAAapB,KAAKC,cAC/CoB,QAAQ,SAAUC,aACzB,IAAIC,gBAAkBvB,KAAKC,YAAc,IAAMqB,YAAc3B,gBAE7DI,WAAWU,GAAGc,gBAAiB,WAC3B,IAAIC,OAASC,MAAMX,UAAUY,MAAMC,KAAKC,UAAW,GACnDlC,gBAAgBmC,iBAAiB7B,KAAMsB,YAAaE,SACtDnB,KAAKL,QACRA,OACLK,KAAKL,OACN8B,KAAK,SAAUC,KACZC,QAAQC,MAAM,sCAAyCjC,KAAKC,YAAc,MAAS8B,MACrF1B,KAAKL,QASfJ,WAAWkB,UAAUoB,MAAQ,WACzB,OAAOlC,KAAKG,eAAiBH,KAAKD,WAAWoC,aASjDvC,WAAWkB,UAAUH,QAAU,WAC3B,GAAIX,KAAKM,mBACL,OAAON,KAAKM,mBAEhB,IAAI8B,SAAW,IAAIC,EAAEC,SAQrB,OANItC,KAAKkC,QACLE,SAASG,UAETH,SAASI,SAGNJ,SAASzB,WAcpBf,WAAWkB,UAAU2B,KAAO,SAAUC,MAClC,IAAI3C,WAAaC,KAAKD,WAClByB,OAASC,MAAMX,UAAUY,MAAMC,KAAKC,UAAW,GAC/Ce,cAAgB,WACZ,IAAIC,OAAU7C,WAAW8C,QAAQ7C,KAAKC,aAClC6C,GAAUF,QAAUA,OAAOF,MAC3BK,WAOJ,OAJIA,WADAD,GACaA,GAAGE,MAAMJ,OAAQpB,SAEjB,IAAIa,EAAEC,UAAWE,SAAS7B,WAG7CN,KAAKL,MAEPiD,OAQJ,OANIA,OADAjD,KAAKkC,QACIS,gBACF3C,KAAKM,mBACHN,KAAKM,mBAAmBE,KAAKmC,gBAE7B,IAAIN,EAAEC,SAASE,QAAS7B,WAKzCnB,OAAOD,QAAUK","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var NodeConnection = require(\"utils/NodeConnection\"),\n        EventDispatcher = require(\"utils/EventDispatcher\");\n\n    // Used to remove all listeners at once when the connection drops\n    var EVENT_NAMESPACE = \".NodeDomainEvent\";\n\n    /**\n     * Provides a simple abstraction for executing the commands of a single\n     * domain loaded via a NodeConnection. Automatically handles connection\n     * management and domain loading, and exposes each command in the domain as\n     * a promise-returning method that can safely be called regardless of the\n     * current status of the underlying connection. Example usage:\n     *\n     *     var myDomain = new NodeDomain(\"someDomain\", \"/path/to/SomeDomainDef.js\"),\n     *         $result = myDomain.exec(\"someCommand\", arg1, arg2);\n     *\n     *     $result.done(function (value) {\n     *         // the command succeeded!\n     *     });\n     *\n     *     $result.fail(function (err) {\n     *         // the command failed; act accordingly!\n     *     });\n     *\n     * To handle domain events, just listen for the event on the domain:\n     *\n     *     myDomain.on(\"someEvent\", someHandler);\n     *\n     * @constructor\n     * @param {string} domainName Name of the registered Node Domain\n     * @param {string} domainPath Full path of the JavaScript Node domain specification\n     */\n    function NodeDomain(domainName, domainPath) {\n        var connection = new NodeConnection();\n\n        this.connection = connection;\n        this._domainName = domainName;\n        this._domainPath = domainPath;\n        this._domainLoaded = false;\n        this._load = this._load.bind(this);\n        this._connectionPromise = connection.connect(true)\n            .then(this._load);\n\n        connection.on(\"close\", function (event, promise) {\n            this.connection.off(EVENT_NAMESPACE);\n            this._domainLoaded = false;\n            this._connectionPromise = promise.then(this._load);\n        }.bind(this));\n    }\n    EventDispatcher.makeEventDispatcher(NodeDomain.prototype);\n\n    /**\n     * The underlying Node connection object for this domain.\n     *\n     * @type {NodeConnection}\n     */\n    NodeDomain.prototype.connection = null;\n\n    /**\n     * A promise that is resolved once the NodeConnection is connected and the\n     * domain has been loaded.\n     *\n     * @type {?jQuery.Promise}\n     * @private\n     */\n    NodeDomain.prototype._connectionPromise = null;\n\n    /**\n     * The name of this domain.\n     *\n     * @type {string}\n     * @private\n     */\n    NodeDomain.prototype._domainName = null;\n\n    /**\n     * The path at which the Node definition of this domain resides.\n     *\n     * @type {string}\n     * @private\n     */\n    NodeDomain.prototype._domainPath = null;\n\n    /**\n     * Whether or not the domain has been successfully loaded.\n     *\n     * @type {boolean}\n     * @private\n     */\n    NodeDomain.prototype._domainLoaded = false;\n\n    /**\n     * Loads the domain via the underlying connection object and exposes the\n     * domain's commands as methods on this object. Assumes the underlying\n     * connection has already been opened.\n     *\n     * @return {jQuery.Promise} Resolves once the domain is been loaded.\n     * @private\n     */\n    NodeDomain.prototype._load = function () {\n        var connection = this.connection;\n        return connection.loadDomains(this._domainPath, true)\n            .done(function () {\n                this._domainLoaded = true;\n                this._connectionPromise = null;\n\n                var eventNames = Object.keys(connection.domainEvents[this._domainName]);\n                eventNames.forEach(function (domainEvent) {\n                    var connectionEvent = this._domainName + \":\" + domainEvent + EVENT_NAMESPACE;\n\n                    connection.on(connectionEvent, function () {\n                        var params = Array.prototype.slice.call(arguments, 1);\n                        EventDispatcher.triggerWithArray(this, domainEvent, params);\n                    }.bind(this));\n                }, this);\n            }.bind(this))\n            .fail(function (err) {\n                console.error(\"[NodeDomain] Error loading domain \\\"\" + this._domainName + \"\\\": \" + err);\n            }.bind(this));\n    };\n\n    /**\n     * Synchronously determine whether the domain is ready; i.e., whether the\n     * connection is open and the domain is loaded.\n     *\n     * @return {boolean} Whether or not the domain is currently ready.\n     */\n    NodeDomain.prototype.ready = function () {\n        return this._domainLoaded && this.connection.connected();\n    };\n\n    /**\n     * Get a promise that resolves when the connection is open and the domain\n     * is loaded.\n     *\n     * @return {jQuery.Promise}\n     */\n    NodeDomain.prototype.promise = function () {\n        if (this._connectionPromise) {\n            return this._connectionPromise;\n        }\n        var deferred = new $.Deferred();\n\n        if (this.ready()) {\n            deferred.resolve();\n        } else {\n            deferred.reject();\n        }\n\n        return deferred.promise();\n\n    };\n\n    /**\n     * Applies the named command from the domain to a list of parameters, which\n     * are passed as extra arguments to this method. If the connection is open\n     * and the domain is loaded, the function is applied immediately. Otherwise\n     * the function is applied as soon as the connection has been opened and the\n     * domain has finished loading.\n     *\n     * @param {string} name The name of the domain command to execute\n     * @return {jQuery.Promise} Resolves with the result of the command\n     */\n    NodeDomain.prototype.exec = function (name) {\n        var connection = this.connection,\n            params = Array.prototype.slice.call(arguments, 1),\n            execConnected = function () {\n                var domain  = connection.domains[this._domainName],\n                    fn      = domain && domain[name],\n                    execResult;\n\n                if (fn) {\n                    execResult = fn.apply(domain, params);\n                } else {\n                    execResult = new $.Deferred().reject().promise();\n                }\n                return execResult;\n            }.bind(this);\n\n        var result;\n        if (this.ready()) {\n            result = execConnected();\n        } else if (this._connectionPromise) {\n            result = this._connectionPromise.then(execConnected);\n        } else {\n            result = new $.Deferred.reject().promise();\n        }\n        return result;\n    };\n\n    module.exports = NodeDomain;\n});\n"],"file":"NodeDomain.js"}
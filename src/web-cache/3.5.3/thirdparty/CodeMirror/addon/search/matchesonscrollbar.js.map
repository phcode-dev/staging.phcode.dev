{"version":3,"sources":["thirdparty/CodeMirror/addon/search/matchesonscrollbar.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","SearchAnnotation","cm","query","caseFold","options","this","annotateOptions","listenForChanges","prop","className","annotation","annotateScrollbar","gap","from","firstLine","to","lastLine","matches","update","findMatches","self","on","changeHandler","_cm","change","onChange","defineExtension","MAX_MATCHES","offsetLine","line","changeStart","sizeChange","Math","max","prototype","i","length","match","splice","cursor","getSearchCursor","Pos","multiline","maxMatches","findNext","startLine","endLine","changeEnd","min","newFrom","ch","newTo","clearTimeout","setTimeout","updateAfterChange","clear","off"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./searchcursor\"), require(\"../scroll/annotatescrollbar\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./searchcursor\", \"../scroll/annotatescrollbar\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"showMatchesOnScrollbar\", function(query, caseFold, options) {\n    if (typeof options == \"string\") options = {className: options};\n    if (!options) options = {};\n    return new SearchAnnotation(this, query, caseFold, options);\n  });\n\n  function SearchAnnotation(cm, query, caseFold, options) {\n    this.cm = cm;\n    this.options = options;\n    var annotateOptions = {listenForChanges: false};\n    for (var prop in options) annotateOptions[prop] = options[prop];\n    if (!annotateOptions.className) annotateOptions.className = \"CodeMirror-search-match\";\n    this.annotation = cm.annotateScrollbar(annotateOptions);\n    this.query = query;\n    this.caseFold = caseFold;\n    this.gap = {from: cm.firstLine(), to: cm.lastLine() + 1};\n    this.matches = [];\n    this.update = null;\n\n    this.findMatches();\n    this.annotation.update(this.matches);\n\n    var self = this;\n    cm.on(\"change\", this.changeHandler = function(_cm, change) { self.onChange(change); });\n  }\n\n  var MAX_MATCHES = 1000;\n\n  SearchAnnotation.prototype.findMatches = function() {\n    if (!this.gap) return;\n    for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      if (match.from.line >= this.gap.to) break;\n      if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);\n    }\n    var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), {caseFold: this.caseFold, multiline: this.options.multiline});\n    var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;\n    while (cursor.findNext()) {\n      var match = {from: cursor.from(), to: cursor.to()};\n      if (match.from.line >= this.gap.to) break;\n      this.matches.splice(i++, 0, match);\n      if (this.matches.length > maxMatches) break;\n    }\n    this.gap = null;\n  };\n\n  function offsetLine(line, changeStart, sizeChange) {\n    if (line <= changeStart) return line;\n    return Math.max(changeStart, line + sizeChange);\n  }\n\n  SearchAnnotation.prototype.onChange = function(change) {\n    var startLine = change.from.line;\n    var endLine = CodeMirror.changeEnd(change).line;\n    var sizeChange = endLine - change.to.line;\n    if (this.gap) {\n      this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);\n      this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);\n    } else {\n      this.gap = {from: change.from.line, to: endLine + 1};\n    }\n\n    if (sizeChange) for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      var newFrom = offsetLine(match.from.line, startLine, sizeChange);\n      if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);\n      var newTo = offsetLine(match.to.line, startLine, sizeChange);\n      if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);\n    }\n    clearTimeout(this.update);\n    var self = this;\n    this.update = setTimeout(function() { self.updateAfterChange(); }, 250);\n  };\n\n  SearchAnnotation.prototype.updateAfterChange = function() {\n    this.findMatches();\n    this.annotation.update(this.matches);\n  };\n\n  SearchAnnotation.prototype.clear = function() {\n    this.cm.off(\"change\", this.changeHandler);\n    this.annotation.clear();\n  };\n});\n"],"file":"matchesonscrollbar.js"}
{"version":3,"sources":["thirdparty/CodeMirror/addon/selection/mark-selection.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","onCursorActivity","cm","state","markedSelection","operation","update","onChange","length","clear","defineOption","val","old","prev","Init","markedSelectionStyle","reset","on","off","CHUNK_SIZE","Pos","cmp","cmpPos","coverRange","from","to","addAt","array","cls","line","start","endLine","atEnd","end","mark","markText","className","push","splice","i","ranges","listSelections","somethingSelected","getCursor","coverStart","find","coverEnd","shift","pop"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Because sometimes you need to mark the selected *text*.\n//\n// Adds an option 'styleSelectedText' which, when enabled, gives\n// selected text the CSS class given as option value, or\n// \"CodeMirror-selectedtext\" when the value is not a string.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\n    var prev = old && old != CodeMirror.Init;\n    if (val && !prev) {\n      cm.state.markedSelection = [];\n      cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\n      reset(cm);\n      cm.on(\"cursorActivity\", onCursorActivity);\n      cm.on(\"change\", onChange);\n    } else if (!val && prev) {\n      cm.off(\"cursorActivity\", onCursorActivity);\n      cm.off(\"change\", onChange);\n      clear(cm);\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n    }\n  });\n\n  function onCursorActivity(cm) {\n    if (cm.state.markedSelection)\n      cm.operation(function() { update(cm); });\n  }\n\n  function onChange(cm) {\n    if (cm.state.markedSelection && cm.state.markedSelection.length)\n      cm.operation(function() { clear(cm); });\n  }\n\n  var CHUNK_SIZE = 8;\n  var Pos = CodeMirror.Pos;\n  var cmp = CodeMirror.cmpPos;\n\n  function coverRange(cm, from, to, addAt) {\n    if (cmp(from, to) == 0) return;\n    var array = cm.state.markedSelection;\n    var cls = cm.state.markedSelectionStyle;\n    for (var line = from.line;;) {\n      var start = line == from.line ? from : Pos(line, 0);\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\n      var end = atEnd ? to : Pos(endLine, 0);\n      var mark = cm.markText(start, end, {className: cls});\n      if (addAt == null) array.push(mark);\n      else array.splice(addAt++, 0, mark);\n      if (atEnd) break;\n      line = endLine;\n    }\n  }\n\n  function clear(cm) {\n    var array = cm.state.markedSelection;\n    for (var i = 0; i < array.length; ++i) array[i].clear();\n    array.length = 0;\n  }\n\n  function reset(cm) {\n    clear(cm);\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n\n  function update(cm) {\n    if (!cm.somethingSelected()) return clear(cm);\n    if (cm.listSelections().length > 1) return reset(cm);\n\n    var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\n\n    var array = cm.state.markedSelection;\n    if (!array.length) return coverRange(cm, from, to);\n\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\n    if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE ||\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\n      return reset(cm);\n\n    while (cmp(from, coverStart.from) > 0) {\n      array.shift().clear();\n      coverStart = array[0].find();\n    }\n    if (cmp(from, coverStart.from) < 0) {\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\n        array.shift().clear();\n        coverRange(cm, from, coverStart.to, 0);\n      } else {\n        coverRange(cm, from, coverStart.from, 0);\n      }\n    }\n\n    while (cmp(to, coverEnd.to) < 0) {\n      array.pop().clear();\n      coverEnd = array[array.length - 1].find();\n    }\n    if (cmp(to, coverEnd.to) > 0) {\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n        array.pop().clear();\n        coverRange(cm, coverEnd.from, to);\n      } else {\n        coverRange(cm, coverEnd.to, to);\n      }\n    }\n  }\n});\n"],"file":"mark-selection.js"}
{"version":3,"sources":["document/TextRange.js"],"names":["define","require","exports","module","EventDispatcher","TextRange","document","startLine","endLine","this","addRef","_handleDocumentChange","bind","_handleDocumentDeleted","on","makeEventDispatcher","prototype","dispose","editor","change","releaseRef","off","_applySingleChangeToRange","from","to","hasChanged","hasContentChanged","line","numAdded","text","length","result","_applyChangesToRange","changeList","i","trigger","event","doc","toString"],"mappings":"AAuBAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,gBA6BJ,SAASC,UAAUC,SAAUC,UAAWC,SACpCC,KAAKF,UAAYA,UACjBE,KAAKD,QAAUA,QAEfC,KAAKH,SAAWA,SAChBA,SAASI,SAETD,KAAKE,sBAAwBF,KAAKE,sBAAsBC,KAAKH,MAC7DA,KAAKI,uBAAyBJ,KAAKI,uBAAuBD,KAAKH,MAC/DH,SAASQ,GAAG,SAAUL,KAAKE,uBAC3BL,SAASQ,GAAG,UAAWL,KAAKI,wBAvCVZ,QAAQ,yBAyCdc,oBAAoBV,UAAUW,WAI9CX,UAAUW,UAAUC,QAAU,SAAUC,OAAQC,QAE5CV,KAAKH,SAASc,aACdX,KAAKH,SAASe,IAAI,SAAUZ,KAAKE,uBACjCF,KAAKH,SAASe,IAAI,UAAWZ,KAAKI,yBAQtCR,UAAUW,UAAUV,SAAW,KAM/BD,UAAUW,UAAUT,UAAY,KAMhCF,UAAUW,UAAUR,QAAU,KAU9BH,UAAUW,UAAUM,0BAA4B,SAAUH,QAMtD,IAAKA,OAAOI,OAASJ,OAAOK,GAGxB,OAFAf,KAAKF,UAAY,KACjBE,KAAKD,QAAU,KACR,CAACiB,YAAY,EAAMC,mBAAmB,GAe1C,GAAKP,OAAOI,KAAKI,KAAOlB,KAAKF,WAAaY,OAAOK,GAAGG,MAAQlB,KAAKF,WAC5DY,OAAOI,KAAKI,MAAQlB,KAAKD,SAAWW,OAAOK,GAAGG,KAAOlB,KAAKD,QAGlE,OAFAC,KAAKF,UAAY,KACjBE,KAAKD,QAAU,KACR,CAACiB,YAAY,EAAMC,mBAAmB,GAMjD,IAAIE,SAAWT,OAAOU,KAAKC,QAAUX,OAAOK,GAAGG,KAAOR,OAAOI,KAAKI,KAAO,GACrEI,OAAS,CAACN,YAAY,EAAOC,mBAAmB,GAsBpD,OAlBiB,IAAbE,WACIT,OAAOK,GAAGG,KAAOlB,KAAKF,YACtBE,KAAKF,WAAaqB,SAClBG,OAAON,YAAa,GAEpBN,OAAOK,GAAGG,MAAQlB,KAAKD,UACvBC,KAAKD,SAAWoB,SAChBG,OAAON,YAAa,IAGxBN,OAAOI,KAAKI,MAAQlB,KAAKF,WAAaY,OAAOI,KAAKI,MAAQlB,KAAKD,UAG/DuB,OAAOL,mBAAoB,GAKxBK,QASX1B,UAAUW,UAAUgB,qBAAuB,SAAUC,YACjD,IAAIR,YAAa,EAAOC,mBAAoB,EACxCQ,EACJ,IAAKA,EAAI,EAAGA,EAAID,WAAWH,OAAQI,IAAK,CAEpC,IAAIH,OAAStB,KAAKa,0BAA0BW,WAAWC,IAKvD,GAJAT,WAAaA,YAAcM,OAAON,WAClCC,kBAAoBA,mBAAqBK,OAAOL,kBAGzB,OAAnBjB,KAAKF,WAAuC,OAAjBE,KAAKD,QAAkB,CAClDC,KAAK0B,QAAQ,YACb,OAIJV,YACAhB,KAAK0B,QAAQ,UAEbT,mBACAjB,KAAK0B,QAAQ,kBAIrB9B,UAAUW,UAAUL,sBAAwB,SAAUyB,MAAOC,IAAKJ,YAC9DxB,KAAKuB,qBAAqBC,aAG9B5B,UAAUW,UAAUH,uBAAyB,SAAUuB,OACnD3B,KAAK0B,QAAQ,aAKjB9B,UAAUW,UAAUsB,SAAW,WAC3B,MAAO,cAAgB7B,KAAKF,UAAY,IAAME,KAAKD,QAAU,OAASC,KAAKH,SAAW,KAK1FJ,QAAQG,UAAYA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n */\ndefine(function (require, exports, module) {\n\n\n    var EventDispatcher = require(\"utils/EventDispatcher\");\n\n\n    /**\n     * Stores a range of lines that is automatically maintained as the Document changes. The range\n     * MAY drop out of sync with the Document in certain edge cases; startLine & endLine will become\n     * null when that happens.\n     *\n     * Important: you must dispose() a TextRange when you're done with it. Because TextRange addRef()s\n     * the Document (in order to listen to it), you will leak Documents otherwise.\n     *\n     * TextRange dispatches these events:\n     *  - change -- When the range boundary line numbers change (due to a Document change)\n     *  - contentChange -- When the actual content of the range changes. This might or might not\n     *    be accompanied by a change in the boundary line numbers.\n     *  - lostSync -- When the backing Document changes in such a way that the range can no longer\n     *    accurately be maintained. Generally, occurs whenever an edit spans a range boundary.\n     *    After this, startLine & endLine will be unusable (set to null).\n     *    Also occurs when the document is deleted, though startLine & endLine won't be modified\n     * These events only ever occur in response to Document changes, so if you are already listening\n     * to the Document, you could ignore the TextRange events and just read its updated value in your\n     * own Document change handler.\n     *\n     * @constructor\n     *\n     * @param {!Document} document\n     * @param {number} startLine First line in range (0-based, inclusive)\n     * @param {number} endLine   Last line in range (0-based, inclusive)\n     */\n    function TextRange(document, startLine, endLine) {\n        this.startLine = startLine;\n        this.endLine = endLine;\n\n        this.document = document;\n        document.addRef();\n        // store this-bound versions of listeners so we can remove them later\n        this._handleDocumentChange = this._handleDocumentChange.bind(this);\n        this._handleDocumentDeleted = this._handleDocumentDeleted.bind(this);\n        document.on(\"change\", this._handleDocumentChange);\n        document.on(\"deleted\", this._handleDocumentDeleted);\n    }\n    EventDispatcher.makeEventDispatcher(TextRange.prototype);\n\n\n    /** Detaches from the Document. The TextRange will no longer update or send change events */\n    TextRange.prototype.dispose = function (editor, change) {\n        // Disconnect from Document\n        this.document.releaseRef();\n        this.document.off(\"change\", this._handleDocumentChange);\n        this.document.off(\"deleted\", this._handleDocumentDeleted);\n    };\n\n\n    /**\n     * Containing document\n     * @type {!Document}\n     */\n    TextRange.prototype.document = null;\n\n    /**\n     * Starting Line\n     * @type {?number} Null after \"lostSync\" is dispatched\n     */\n    TextRange.prototype.startLine = null;\n\n    /**\n     * Ending Line\n     * @type {?number} Null after \"lostSync\" is dispatched\n     */\n    TextRange.prototype.endLine = null;\n\n\n    /**\n     * Applies a single Document change object (out of the linked list of multiple such objects)\n     * to this range.\n     * @param {Object} change The CodeMirror change record.\n     * @return {{hasChanged: boolean, hasContentChanged: boolean}} Whether the range boundary\n     *     and/or content has changed.\n     */\n    TextRange.prototype._applySingleChangeToRange = function (change) {\n        // console.log(this + \" applying change to (\" +\n        //         (change.from && (change.from.line+\",\"+change.from.ch)) + \" - \" +\n        //         (change.to && (change.to.line+\",\"+change.to.ch)) + \")\");\n\n        // Special case: the range is no longer meaningful since the entire text was replaced\n        if (!change.from || !change.to) {\n            this.startLine = null;\n            this.endLine = null;\n            return {hasChanged: true, hasContentChanged: true};\n\n        // Special case: certain changes around the edges of the range are problematic, because\n        // if they're undone, we'll be unable to determine how to fix up the range to include the\n        // undone content. (The \"undo\" will just look like an insertion outside our bounds.) So\n        // in those cases, we destroy the range instead of fixing it up incorrectly. The specific\n        // cases are:\n        // 1. Edit crosses the start boundary of the inline editor (defined as character 0\n        //    of the first line).\n        // 2. Edit crosses the end boundary of the inline editor (defined as the newline at\n        //    the end of the last line).\n        // Note: we also used to disallow edits that start at the beginning of the range (character 0\n        //    of the first line) if they crossed a newline. This was a vestige from before case #1\n        //    was added; now that edits crossing the top boundary (actually, undos of such edits) are\n        //    out of the picture, edits on the first line of the range unambiguously belong inside it.\n        } else if ((change.from.line < this.startLine && change.to.line >= this.startLine) ||\n                   (change.from.line <= this.endLine && change.to.line > this.endLine)) {\n            this.startLine = null;\n            this.endLine = null;\n            return {hasChanged: true, hasContentChanged: true};\n\n        // Normal case: update the range end points if any content was added before them. Note that\n        // we don't rely on line handles for this since we want to gracefully handle cases where the\n        // start or end line was deleted during a change.\n        }\n        var numAdded = change.text.length - (change.to.line - change.from.line + 1);\n        var result = {hasChanged: false, hasContentChanged: false};\n\n            // This logic is so simple because we've already excluded all cases where the change\n            // crosses the range boundaries\n        if (numAdded !== 0) {\n            if (change.to.line < this.startLine) {\n                this.startLine += numAdded;\n                result.hasChanged = true;\n            }\n            if (change.to.line <= this.endLine) {\n                this.endLine += numAdded;\n                result.hasChanged = true;\n            }\n        }\n        if (change.from.line >= this.startLine && change.from.line <= this.endLine) {\n                // Since we know the change doesn't cross the range boundary, as long as the\n                // start of the change is within the range, we know the content changed.\n            result.hasContentChanged = true;\n        }\n\n            // console.log(\"Now \" + this);\n\n        return result;\n\n    };\n\n    /**\n     * Updates the range based on the changeList from a Document \"change\" event. Dispatches a\n     * \"change\" event if the range was adjusted at all. Dispatches a \"lostSync\" event instead if the\n     * range can no longer be accurately maintained.\n     */\n    TextRange.prototype._applyChangesToRange = function (changeList) {\n        var hasChanged = false, hasContentChanged = false;\n        var i;\n        for (i = 0; i < changeList.length; i++) {\n            // Apply this step of the change list\n            var result = this._applySingleChangeToRange(changeList[i]);\n            hasChanged = hasChanged || result.hasChanged;\n            hasContentChanged = hasContentChanged || result.hasContentChanged;\n\n            // If we lost sync with the range, just bail now\n            if (this.startLine === null || this.endLine === null) {\n                this.trigger(\"lostSync\");\n                break;\n            }\n        }\n\n        if (hasChanged) {\n            this.trigger(\"change\");\n        }\n        if (hasContentChanged) {\n            this.trigger(\"contentChange\");\n        }\n    };\n\n    TextRange.prototype._handleDocumentChange = function (event, doc, changeList) {\n        this._applyChangesToRange(changeList);\n    };\n\n    TextRange.prototype._handleDocumentDeleted = function (event) {\n        this.trigger(\"lostSync\");\n    };\n\n\n    /* (pretty toString(), to aid debugging) */\n    TextRange.prototype.toString = function () {\n        return \"[TextRange \" + this.startLine + \"-\" + this.endLine + \" in \" + this.document + \"]\";\n    };\n\n\n    // Define public API\n    exports.TextRange = TextRange;\n});\n"],"file":"TextRange.js"}
{"version":3,"sources":["extensions/default/CodeFolding/foldhelpers/foldgutter.js"],"names":["define","require","exports","module","CodeMirror","brackets","getModule","prefs","State","options","this","from","to","parseOptions","opts","gutter","indicatorOpen","indicatorFolded","marker","spec","elt","window","document","createElement","className","isFold","m","__isFold","updateFoldInfo","cm","minFoldSize","getSetting","state","foldGutter","fade","$gutter","$","getGutterElement","i","clear","_isCurrentlyFolded","line","keys","Object","_lineFolds","range","length","setTimeout","vp","getViewport","sr","mark","pos","Pos","func","rangeFinder","fold","auto","is","isFolded","findMarksAt","filter","forEach","setGutterMarker","updateInViewport","isNaN","operation","getFoldOnLine","folds","undefined","syncDocToFoldsCache","lineAdded","find","moveRange","numLines","ch","updateFoldsCache","linesDiff","oldRange","newRange","foldedLines","map","d","rf","indexOf","newFolds","Math","abs","onChange","changeObj","origin","getValidFolds","foldCode","lineChanges","text","removed","max","clearTimeout","changeUpdate","onViewportChange","onCursorActivity","onFold","onUnFold","init","defineOption","val","old","Init","clearGutter","off","onGutterClick","on"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n// Based on http://codemirror.net/addon/fold/foldgutter.js\n// Modified by Patrick Oladimeji for Brackets\n\ndefine(function (require, exports, module) {\n\n    var CodeMirror      = brackets.getModule(\"thirdparty/CodeMirror/lib/codemirror\"),\n        prefs           = require(\"Prefs\");\n\n    function State(options) {\n        this.options = options;\n        this.from = this.to = 0;\n    }\n\n    function parseOptions(opts) {\n        if (opts === true) { opts = {}; }\n        if (!opts.gutter) { opts.gutter = \"CodeMirror-foldgutter\"; }\n        if (!opts.indicatorOpen) { opts.indicatorOpen = \"CodeMirror-foldgutter-open\"; }\n        if (!opts.indicatorFolded) { opts.indicatorFolded = \"CodeMirror-foldgutter-folded\"; }\n        return opts;\n    }\n\n    /**\n      * Utility for creating fold markers in fold gutter\n      * @param {string} spec the className for the marker\n      * @return {HTMLElement} a htmlelement representing the fold marker\n      */\n    function marker(spec) {\n        var elt = window.document.createElement(\"div\");\n        elt.className = spec;\n        return elt;\n    }\n\n    /**\n     * Checks whether or not a marker is a code-folding marker\n     * @param   {Object}   m a CodeMirror TextMarker object\n     * @returns {boolean} true if the marker is a codefolding range marker or false otherwise\n     */\n    function isFold(m) {\n        return m.__isFold;\n    }\n\n    /**\n      * Updates the gutter markers for the specified range\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n      * @param {!number} from the starting line for the update\n      * @param {!number} to the ending line for the update\n      */\n    function updateFoldInfo(cm, from, to) {\n        var minFoldSize = prefs.getSetting(\"minFoldSize\") || 2;\n        var opts = cm.state.foldGutter.options;\n        var fade = prefs.getSetting(\"hideUntilMouseover\");\n        var $gutter = $(cm.getGutterElement());\n        var i = from;\n\n        function clear(m) {\n            return m.clear();\n        }\n\n        /**\n          * @private\n          * helper function to check if the given line is in a folded region in the editor.\n          * @param {number} line the\n          * @return {Object} the range that hides the specified line or undefine if the line is not hidden\n          */\n        function _isCurrentlyFolded(line) {\n            var keys = Object.keys(cm._lineFolds), i = 0, range;\n            while (i < keys.length) {\n                range = cm._lineFolds[keys[i]];\n                if (range.from.line < line && range.to.line >= line) {\n                    return range;\n                }\n                i++;\n            }\n        }\n\n        /**\n            This case is needed when unfolding a region that does not cause the viewport to change.\n            For instance in a file with about 15 lines, if some code regions are folded and unfolded, the\n            viewport change event isn't fired by CodeMirror. The setTimeout is a workaround to trigger the\n            gutter update after the viewport has been drawn.\n        */\n        if (i === to) {\n            window.setTimeout(function () {\n                var vp = cm.getViewport();\n                updateFoldInfo(cm, vp.from, vp.to);\n            }, 200);\n        }\n\n        while (i < to) {\n            var sr = _isCurrentlyFolded(i), // surrounding range for the current line if one exists\n                range;\n            var mark = marker(\"CodeMirror-foldgutter-blank\");\n            var pos = CodeMirror.Pos(i, 0),\n                func = opts.rangeFinder || CodeMirror.fold.auto;\n            // don't look inside collapsed ranges\n            if (sr) {\n                i = sr.to.line + 1;\n            } else {\n                range = cm._lineFolds[i] || (func && func(cm, pos));\n\n                if (!fade || (fade && $gutter.is(\":hover\"))) {\n                    if (cm.isFolded(i)) {\n                        // expand fold if invalid\n                        if (range) {\n                            mark = marker(opts.indicatorFolded);\n                        } else {\n                            cm.findMarksAt(pos).filter(isFold)\n                                .forEach(clear);\n                        }\n                    } else {\n                        if (range && range.to.line - range.from.line >= minFoldSize) {\n                            mark = marker(opts.indicatorOpen);\n                        }\n                    }\n                }\n                cm.setGutterMarker(i, opts.gutter, mark);\n                i++;\n            }\n        }\n    }\n\n    /**\n      * Updates the fold information in the viewport for the specified range\n      * @param {CodeMirror} cm the instance of the CodeMirror object\n      * @param {?number} from the starting line number for the update\n      * @param {?number} to the end line number for the update\n      */\n    function updateInViewport(cm, from, to) {\n        var vp = cm.getViewport(), state = cm.state.foldGutter;\n        from = isNaN(from) ? vp.from : from;\n        to = isNaN(to) ? vp.to : to;\n\n        if (!state) { return; }\n        cm.operation(function () {\n            updateFoldInfo(cm, from, to);\n        });\n        state.from = from;\n        state.to = to;\n    }\n\n    /**\n     * Helper function to return the fold text marker on a line in an editor\n     * @param   {CodeMirror} cm   The CodeMirror instance for the active editor\n     * @param   {Number}     line The line number representing the position of the fold marker\n     * @returns {TextMarker} A CodeMirror TextMarker object\n     */\n    function getFoldOnLine(cm, line) {\n        var pos = CodeMirror.Pos(line, 0);\n        var folds = cm.findMarksAt(pos) || [];\n        folds = folds.filter(isFold);\n        return folds.length ? folds[0] : undefined;\n    }\n\n    /**\n     * Synchronises the code folding states in the CM doc to cm._lineFolds cache.\n     * When an undo operation is done, if folded code fragments are restored, then\n     * we need to update cm._lineFolds with the fragments\n     * @param {Object}   cm       cm the CodeMirror instance for the active  editor\n     * @param {Object}   from     starting position in the doc to sync the fold states from\n     * @param {[[Type]]} lineAdded a number to show how many lines where added to the document\n     */\n    function syncDocToFoldsCache(cm, from, lineAdded) {\n        var minFoldSize = prefs.getSetting(\"minFoldSize\") || 2;\n        var i, fold, range;\n        if (lineAdded <= 0) {\n            return;\n        }\n\n        for (i = from; i <= from + lineAdded; i = i + 1) {\n            fold = getFoldOnLine(cm, i);\n            if (fold) {\n                range = fold.find();\n                if (range && range.to.line - range.from.line >= minFoldSize) {\n                    cm._lineFolds[i] = range;\n                    i = range.to.line;\n                } else {\n                    delete cm._lineFolds[i];\n                }\n            }\n        }\n    }\n\n    /**\n     * Helper function to move a fold range object by the specified number of lines\n     * @param {Object} range    An object specifying the fold range to move. It contains {from, to} which are CodeMirror.Pos objects.\n     * @param {Number} numLines A positive or negative number representing the numbe of lines to move the range by\n     */\n    function moveRange(range, numLines) {\n        return {from: CodeMirror.Pos(range.from.line + numLines, range.from.ch),\n            to: CodeMirror.Pos(range.to.line + numLines, range.to.ch)};\n    }\n\n    /**\n      * Updates the line folds cache usually when the document changes.\n      * The following cases are accounted for:\n      * 1.  When the change does not add a new line to the document we check if the line being modified\n      *     is folded. If that is the case, changes to this line might affect the range stored in the cache\n      *     so we update the range using the range finder function.\n      * 2.  If lines have been added, we need to update the records for all lines in the folds cache\n      *     which are greater than the line position at which we are adding the new line(s). When existing\n      *     folds are above the addition we keep the original position in the cache.\n      * 3.  If lines are being removed, we need to update the records for all lines in the folds cache which are\n      *     greater than the line position at which we are removing the new lines, while making sure to\n      *     not include any folded lines in the cache that are part of the removed chunk.\n      * @param {!CodeMirror} cm        the CodeMirror instance for the active editor\n      * @param {!number}     from      the line number designating the start position of the change\n      * @param {!number}     linesDiff a number to show how many lines where removed or added to the document.\n      *                                This value is negative for deletions and positive for additions.\n      */\n    function updateFoldsCache(cm, from, linesDiff) {\n        var oldRange, newRange;\n        var minFoldSize = prefs.getSetting(\"minFoldSize\") || 2;\n        var foldedLines = Object.keys(cm._lineFolds).map(function (d) {\n            return +d;\n        });\n        var opts = cm.state.foldGutter.options || {};\n        var rf = opts.rangeFinder || CodeMirror.fold.auto;\n\n        if (linesDiff === 0) {\n            if (foldedLines.indexOf(from) >= 0) {\n                newRange = rf(cm, CodeMirror.Pos(from, 0));\n                if (newRange && newRange.to.line - newRange.from.line >= minFoldSize) {\n                    cm._lineFolds[from] = newRange;\n                } else {\n                    delete cm._lineFolds[from];\n                }\n            }\n        } else if (foldedLines.length) {\n            var newFolds = {};\n            foldedLines.forEach(function (line) {\n                oldRange = cm._lineFolds[line];\n                //update range with lines-diff\n                newRange = moveRange(oldRange, linesDiff);\n                // for removed lines we want to check lines that lie outside the deleted range\n                if (linesDiff < 0) {\n                    if (line < from) {\n                        newFolds[line] = oldRange;\n                    } else if (line >= from + Math.abs(linesDiff)) {\n                        newFolds[line + linesDiff] = newRange;\n                    }\n                } else {\n                    if (line < from) {\n                        newFolds[line] = oldRange;\n                    } else if (line >= from) {\n                        newFolds[line + linesDiff] = newRange;\n                    }\n                }\n            });\n            cm._lineFolds = newFolds;\n        }\n    }\n\n    /**\n      * Triggered when the content of the document changes. When the entire content of the document\n      * is changed - e.g., changes made from a different editor, the same lineFolds are kept only if\n      * they are still valid in the context of the new document content.\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n      * @param {!Object} changeObj detailed information about the change that occurred in the document\n      */\n    function onChange(cm, changeObj) {\n        if (changeObj.origin === \"setValue\") { //text content has changed outside of brackets\n            var folds = cm.getValidFolds(cm._lineFolds);\n            cm._lineFolds = folds;\n            Object.keys(folds).forEach(function (line) {\n                cm.foldCode(+line);\n            });\n        } else {\n            var state = cm.state.foldGutter;\n            var lineChanges = changeObj.text.length - changeObj.removed.length;\n            // for undo actions that add new line(s) to the document first update the folds cache as normal\n            // and then update the folds cache with any line folds that exist in the new lines\n            if (changeObj.origin === \"undo\" && lineChanges > 0) {\n                updateFoldsCache(cm, changeObj.from.line, lineChanges);\n                syncDocToFoldsCache(cm, changeObj.from.line, lineChanges);\n            } else {\n                updateFoldsCache(cm, changeObj.from.line, lineChanges);\n            }\n            if (lineChanges !== 0) {\n                updateFoldInfo(cm, Math.max(0, changeObj.from.line + lineChanges), Math.max(0, changeObj.from.line + lineChanges) + 1);\n            }\n            state.from = changeObj.from.line;\n            state.to = 0;\n            window.clearTimeout(state.changeUpdate);\n            state.changeUpdate = window.setTimeout(function () {\n                updateInViewport(cm);\n            }, 600);\n        }\n    }\n\n    /**\n      * Triggered on viewport changes e.g., user scrolls or resizes the viewport.\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n      */\n    function onViewportChange(cm) {\n        var state = cm.state.foldGutter;\n        window.clearTimeout(state.changeUpdate);\n        state.changeUpdate = window.setTimeout(function () {\n            var vp = cm.getViewport();\n            if (state.from === state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n                updateInViewport(cm);\n            } else {\n                cm.operation(function () {\n                    if (vp.from < state.from) {\n                        updateFoldInfo(cm, vp.from, state.from);\n                        state.from = vp.from;\n                    }\n                    if (vp.to > state.to) {\n                        updateFoldInfo(cm, state.to, vp.to);\n                        state.to = vp.to;\n                    } else {\n                        updateFoldInfo(cm, vp.from, vp.to);\n                        state.to = vp.to;\n                        state.from = vp.from;\n                    }\n                });\n            }\n        }, 400);\n    }\n\n    /**\n     * Triggered when the cursor moves in the editor and used to detect text selection changes\n     * in the editor.\n     * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n     */\n    function onCursorActivity(cm) {\n        var state = cm.state.foldGutter;\n        var vp = cm.getViewport();\n        window.clearTimeout(state.changeUpdate);\n        state.changeUpdate = window.setTimeout(function () {\n            //need to render the entire visible viewport to remove fold marks rendered from previous selections if any\n            updateInViewport(cm, vp.from, vp.to);\n        }, 400);\n    }\n\n    /**\n      * Triggered when a code segment is folded.\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n      * @param {!Object} from  the ch and line position that designates the start of the region\n      * @param {!Object} to the ch and line position that designates the end of the region\n      */\n    function onFold(cm, from, to) {\n        var state = cm.state.foldGutter;\n        updateFoldInfo(cm, from.line, from.line + 1);\n    }\n\n    /**\n      * Triggered when a folded code segment is unfolded.\n      * @param {!CodeMirror} cm the CodeMirror instance for the active editor\n      * @param {!{line:number, ch:number}} from  the ch and line position that designates the start of the region\n      * @param {!{line:number, ch:number}} to the ch and line position that designates the end of the region\n      */\n    function onUnFold(cm, from, to) {\n        var state = cm.state.foldGutter;\n        var vp = cm.getViewport();\n        delete cm._lineFolds[from.line];\n        updateFoldInfo(cm, from.line, to.line || vp.to);\n    }\n\n    /**\n      * Initialises the fold gutter and registers event handlers for changes to document, viewport\n      * and user interactions.\n      */\n    function init() {\n        CodeMirror.defineOption(\"foldGutter\", false, function (cm, val, old) {\n            if (old && old !== CodeMirror.Init) {\n                cm.clearGutter(cm.state.foldGutter.options.gutter);\n                cm.state.foldGutter = null;\n                cm.off(\"gutterClick\", old.onGutterClick);\n                cm.off(\"change\", onChange);\n                cm.off(\"viewportChange\", onViewportChange);\n                cm.off(\"cursorActivity\", onCursorActivity);\n\n                cm.off(\"fold\", onFold);\n                cm.off(\"unfold\", onUnFold);\n                cm.off(\"swapDoc\", updateInViewport);\n            }\n            if (val) {\n                cm.state.foldGutter = new State(parseOptions(val));\n                updateInViewport(cm);\n                cm.on(\"gutterClick\", val.onGutterClick);\n                cm.on(\"change\", onChange);\n                cm.on(\"viewportChange\", onViewportChange);\n                cm.on(\"cursorActivity\", onCursorActivity);\n                cm.on(\"fold\", onFold);\n                cm.on(\"unfold\", onUnFold);\n                cm.on(\"swapDoc\", updateInViewport);\n            }\n        });\n    }\n\n    exports.init = init;\n    exports.updateInViewport = updateInViewport;\n\n});\n"],"file":"foldgutter.js"}
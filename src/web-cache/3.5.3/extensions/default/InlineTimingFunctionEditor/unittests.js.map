{"version":3,"sources":["extensions/default/InlineTimingFunctionEditor/unittests.js"],"names":["define","require","exports","module","SpecRunnerUtils","brackets","getModule","KeyEvent","testContentCSS","provider","inlineTimingFunctionEditorProvider","TimingFunctionUtils","BezierCurveEditor","StepEditor","describe","testDocument","testEditor","inline","async","makeTimingFunctionEditor","cursor","promise","done","inlineResult","onAdded","awaitsForDone","expectArraysToBeEqual","a1","a2","len","expect","length","toEqual","forEach","entry","index","match","testInvalidBezier","str","expectedArray","timingFunctionMatch","originalString","it","toBeTruthy","toBeFalsy","testInvalidStep","undefined","testOpenTimingFunction","start","end","_startBookmark","find","ch","toBe","_endBookmark","beforeEach","mock","createMockEditor","doc","editor","afterEach","destroyMockEditor","line","timingFuncEditor","makeTimingFuncUI","initialTimingFunction","callback","parent","$","window","document","body","cb","isBezier","isStep","getRootElement","css","remove","_cubicBezierCoords","matchUpdate","handleExternalUpdate","_stepParams","count","timing","translatePointFromBezierToCanvas","bezierPoint","Math","round","eventAtOffset","event","$item","offsets","trigger","Event","pageX","offset","left","pageY","top","which","testCubicBezierClick","opts","item","clickAt","expected","testCubicBezierDrag","$downItem","downItem","$dragItem","dragItem","dragTo","makeKeyEvent","keyCode","key","shiftKey","shift","triggerTimingFunctionEditorKey","func","focus","DOM_VK_RIGHT","DOM_VK_UP","DOM_VK_LEFT","DOM_VK_DOWN","calledBack","_callback","timingFunctionString"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global describe, it, expect, beforeEach, afterEach, awaitsForDone */\n\ndefine(function (require, exports, module) {\n\n\n    // Modules from the SpecRunner window\n    var SpecRunnerUtils         = brackets.getModule(\"spec/SpecRunnerUtils\"),\n        KeyEvent                = brackets.getModule(\"utils/KeyEvent\"),\n        testContentCSS          = require(\"text!unittest-files/unittests.css\"),\n        provider                = require(\"main\").inlineTimingFunctionEditorProvider,\n        TimingFunctionUtils     = require(\"TimingFunctionUtils\"),\n        BezierCurveEditor       = require(\"BezierCurveEditor\").BezierCurveEditor,\n        StepEditor              = require(\"StepEditor\").StepEditor;\n\n    describe(\"unit:Inline Timing Function Editor\", function () {\n\n        var testDocument, testEditor, inline;\n\n        /**\n         * Creates an inline timing function editor connected to the given cursor position in the test editor.\n         * Note that this does *not* actually open it as an inline editor in the test editor.\n         * Tests that use this must wrap their contents in a runs() block.\n         * @param {!{line:number, ch: number}} cursor Position for which to open the inline editor.\n         *    if the provider did not create an inline editor.\n         */\n        async function makeTimingFunctionEditor(cursor) {\n            var promise = provider(testEditor, cursor);\n            if (promise) {\n                promise.done(function (inlineResult) {\n                    inlineResult.onAdded();\n                    inline = inlineResult;\n                });\n                await awaitsForDone(promise, \"open timing function editor\");\n            }\n        }\n\n        /**\n         * Expects arrays to be of specified length and equal.\n         * @param {Array} a1 Result to test\n         * @param {Array} a2 Expected values.\n         * @param {number} len Expected length.\n         */\n        function expectArraysToBeEqual(a1, a2, len) {\n            expect(a2.length).toEqual(a1.length);\n            a2.forEach(function (entry, index) {\n                expect(entry).toEqual(a1[index]);\n            });\n        }\n\n        describe(\"TimingFunctionUtils for bezier curve functions\", function () {\n            var match;\n\n            /**\n             * Expects an invalid steps() function to be corrected the right way, with the right match\n             * and originalString given a string to match and an expectation of the output match.\n             * @param {string} str The string to match\n             * @param {Array} expectedArray The array that should equal the output match.\n             */\n            function testInvalidBezier(str, expectedArray) {\n                var match = TimingFunctionUtils.timingFunctionMatch(str, false);\n                expectArraysToBeEqual(match, expectedArray);\n                expect(match.originalString).toEqual(str);\n            }\n\n            // Valid cubic-bezier function cases\n            it(\"should match bezier curve function in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"cubic-bezier(.1, .2, .3, .4)\", false);\n                expect(match).toBeTruthy();\n                expectArraysToBeEqual(match, [\"cubic-bezier(.1, .2, .3, .4)\", \".1\", \".2\", \".3\", \".4\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match bezier curve function in lax mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"cubic-bezier(.1, .2, .3, .4)\", true);\n                expect(match).toBeTruthy();\n                expectArraysToBeEqual(match, [\"cubic-bezier(.1, .2, .3, .4)\", \".1\", \".2\", \".3\", \".4\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match bezier curve function with negative value\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"cubic-bezier(0, -.2, 1, 1.2)\", false);\n                expectArraysToBeEqual(match, [\"cubic-bezier(0, -.2, 1, 1.2)\", \"0\", \"-.2\", \"1\", \"1.2\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match bezier curve function in full line of longhand css\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"    transition-timing-function: cubic-bezier(.37, .28, .83, .94);\", false);\n                expectArraysToBeEqual(match, [\"cubic-bezier(.37, .28, .83, .94)\", \".37\", \".28\", \".83\", \".94\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match bezier curve function in full line of shorthand css\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"    transition: top 100ms cubic-bezier(.37, .28, .83, .94) 0;\", false);\n                expectArraysToBeEqual(match, [\"cubic-bezier(.37, .28, .83, .94)\", \".37\", \".28\", \".83\", \".94\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match bezier curve function with leading zeros\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"cubic-bezier(0.1, 0.2, 0.3, 0.4)\", false);\n                expectArraysToBeEqual(match, [\"cubic-bezier(0.1, 0.2, 0.3, 0.4)\", \"0.1\", \"0.2\", \"0.3\", \"0.4\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match bezier curve function with no optional whitespace\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"cubic-bezier(.1,.2,.3,.4)\", false);\n                expectArraysToBeEqual(match, [\"cubic-bezier(.1,.2,.3,.4)\", \".1\", \".2\", \".3\", \".4\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match bezier curve function with extra optional whitespace\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"cubic-bezier( .1 , .2 , .3 , .4 )\", false);\n                expectArraysToBeEqual(match, [\"cubic-bezier( .1 , .2 , .3 , .4 )\", \".1\", \".2\", \".3\", \".4\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n\n            // Valid other functions\n            it(\"should match linear animation function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"animation-timing-function: linear;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"linear\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease animation function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"animation-timing-function: ease;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease-in animation function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"animation-timing-function: ease-in;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease-in\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease-out animation function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"animation-timing-function: ease-out;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease-out\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease-in-out animation function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"animation-timing-function: ease-in-out;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease-in-out\");\n                expect(match.originalString).toBeFalsy();\n            });\n\n            it(\"should match linear function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"transition-timing-function: linear;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"linear\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match linear function value in lax mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"linear\", true);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"linear\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"transition-timing-function: ease;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease function value in lax mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"ease\", true);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease-in function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"transition-timing-function: ease-in;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease-in\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease-in function value in lax mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"ease-in\", true);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease-in\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease-out function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"transition-timing-function: ease-out;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease-out\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease-out function value in lax mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"ease-out\", true);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease-out\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease-in-out function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"transition-timing-function: ease-in-out;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease-in-out\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match ease-in-out function value in lax mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"ease-in-out\", true);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"ease-in-out\");\n                expect(match.originalString).toBeFalsy();\n            });\n\n            // Invalid cubic-beziers - they should be corrected automatically\n            it(\"should correct cubic-bezier function with out-of-range X parameters\", function () {\n                testInvalidBezier(\"cubic-bezier(-.2, 0, 1.2, 1)\", [\"cubic-bezier(0, 0, 1, 1)\", \"0\", \"0\", \"1\", \"1\"]);\n            });\n            it(\"should correct cubic-bezier function with Infinity parameters\", function () {\n                testInvalidBezier(\"cubic-bezier(0, Infinity, 1, -Infinity)\", [\"cubic-bezier(0, 0, 1, 1)\", \"0\", \"0\", \"1\", \"1\"]);\n            });\n            it(\"should correct cubic-bezier function with non-numeric parameters\", function () {\n                testInvalidBezier(\"cubic-bezier(x1, y1, x2, y2)\", [\"cubic-bezier(.42, 0, .58, 1)\", \".42\", \"0\", \".58\", \"1\"]);\n            });\n            it(\"should correct cubic-bezier function with no parameters\", function () {\n                testInvalidBezier(\"cubic-bezier()\", [\"cubic-bezier(.42, 0, .58, 1)\", \".42\", \"0\", \".58\", \"1\"]);\n            });\n            it(\"should correct cubic-bezier function with 3 parameters\", function () {\n                testInvalidBezier(\"cubic-bezier(0, 0, 1)\", [\"cubic-bezier(0, 0, 1, 1)\", \"0\", \"0\", \"1\", \"1\"]);\n            });\n            it(\"should correct cubic-bezier function with 5 parameters\", function () {\n                testInvalidBezier(\"cubic-bezier(0, 0, 1, 1, 1)\", [\"cubic-bezier(0, 0, 1, 1)\", \"0\", \"0\", \"1\", \"1\"]);\n            });\n            it(\"should correct cubic-bezier function with trailing comma\", function () {\n                testInvalidBezier(\"cubic-bezier(.42, 0, .58, .5,)\", [\"cubic-bezier(.42, 0, .58, .5)\", \".42\", \"0\", \".58\", \".5\"]);\n            });\n\n            // Real invalid cubic-beziers - they should NOT be corrected automatically\n            it(\"should not match cubic-bezier function with invalid whitespace\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"cubic-bezier (0, 0, 1, 1)\", false);\n                expect(match).toBeFalsy();\n            });\n            it(\"should not match cubic-bezier function with UPPER-CASE\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"CUBIC-BEZIER(0, 0, 1, 1)\", false);\n                expect(match).toBeFalsy();\n            });\n            it(\"should not match unknown timing function\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"ease-out-in\", false);\n                expect(match).toBeFalsy();\n            });\n            it(\"should not match linear when not a timing function\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"background: linear-gradient(to bottom, blue, white);\", false);\n                expect(match).toBeFalsy();\n            });\n        });\n\n        describe(\"TimingFunctionUtils for step functions\", function () {\n            var match;\n\n            /**\n             * Expects an invalid steps() function to be corrected the right way, with the right match\n             * and originalString given a string to match and an expectation of the output match.\n             * @param {string} str The string to match\n             * @param {Array} expectedArray The array that should equal the output match.\n             */\n            function testInvalidStep(str, expectedArray) {\n                var match = TimingFunctionUtils.timingFunctionMatch(str, false);\n                expectArraysToBeEqual(match, expectedArray);\n                expect(match.originalString).toEqual(str);\n            }\n\n            // Valid steps function cases\n            it(\"should match steps function in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"steps(3, start)\", false);\n                expect(match).toBeTruthy();\n                expectArraysToBeEqual(match, [\"steps(3, start)\", \"3\", \"start\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match steps function in lax mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"steps(3, start)\", true);\n                expect(match).toBeTruthy();\n                expectArraysToBeEqual(match, [\"steps(3, start)\", \"3\", \"start\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match steps function with second parameter of end\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"steps(12, end)\", false);\n                expectArraysToBeEqual(match, [\"steps(12, end)\", \"12\", \"end\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match steps function with only 1 parameter\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"steps(8)\", false);\n                expectArraysToBeEqual(match, [\"steps(8)\", \"8\", undefined]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match steps function in full line of longhand css\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"    transition-timing-function: steps(5, start);\", false);\n                expectArraysToBeEqual(match, [\"steps(5, start)\", \"5\", \"start\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match steps function in full line of shorthand css\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"    transition: top 100ms steps(10) 0;\", false);\n                expectArraysToBeEqual(match, [\"steps(10)\", \"10\", undefined]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match steps function with leading zeros\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"steps(04, end)\", false);\n                expectArraysToBeEqual(match, [\"steps(04, end)\", \"04\", \"end\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match steps function with no optional whitespace with 1 param\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"steps(3)\", false);\n                expectArraysToBeEqual(match, [\"steps(3)\", \"3\", undefined]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match steps function with no optional whitespace with 2 params\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"steps(3,end)\", false);\n                expectArraysToBeEqual(match, [\"steps(3,end)\", \"3\", \"end\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match steps function with extra optional whitespace with 1 param\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"steps( 7 )\", false);\n                expectArraysToBeEqual(match, [\"steps( 7 )\", \"7\", undefined]);\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match steps function with extra optional whitespace with 2 params\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"steps( 8 , start )\", false);\n                expectArraysToBeEqual(match, [\"steps( 8 , start )\", \"8\", \"start\"]);\n                expect(match.originalString).toBeFalsy();\n            });\n\n            // Valid other functions\n            it(\"should match step-start function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"transition-timing-function: step-start;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"step-start\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match step-start function value in lax mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"step-start\", true);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"step-start\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match step-end function in declaration in strict mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"transition-timing-function: step-end;\", false);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"step-end\");\n                expect(match.originalString).toBeFalsy();\n            });\n            it(\"should match step-end function value in lax mode\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"step-end\", true);\n                expect(match.length).toEqual(1);\n                expect(match[0]).toEqual(\"step-end\");\n                expect(match.originalString).toBeFalsy();\n            });\n\n            // Invalid steps - they should be corrected automatically\n            it(\"should correct steps function with zero steps\", function () {\n                testInvalidStep(\"steps(0)\", [\"steps(5, end)\", \"5\", \"end\"]);\n            });\n            it(\"should correct steps function with a non-integer number of steps\", function () {\n                testInvalidStep(\"steps(3.0)\", [\"steps(3, end)\", \"3\", \"end\"]);\n            });\n            it(\"should correct steps function with a negative number of steps\", function () {\n                testInvalidStep(\"steps(-2)\", [\"steps(5, end)\", \"5\", \"end\"]);\n            });\n            it(\"should correct steps function with an infinite number of steps\", function () {\n                testInvalidStep(\"steps(Infinity,)\", [\"steps(5, end)\", \"5\", \"end\"]);\n            });\n            it(\"should correct steps function with NaN number of steps\", function () {\n                testInvalidStep(\"steps(NaN,)\", [\"steps(5, end)\", \"5\", \"end\"]);\n            });\n            it(\"should correct steps function with non-numeric number of steps\", function () {\n                testInvalidStep(\"steps(x)\", [\"steps(5, end)\", \"5\", \"end\"]);\n            });\n            it(\"should correct steps function with a string-value number of steps\", function () {\n                testInvalidStep(\"steps('3')\", [\"steps(3, end)\", \"3\", \"end\"]);\n            });\n            it(\"should correct steps function with no parameters\", function () {\n                testInvalidStep(\"steps()\", [\"steps(5, end)\", \"5\", \"end\"]);\n            });\n            it(\"should correct steps function with empty second parameter\", function () {\n                testInvalidStep(\"steps(1,)\", [\"steps(1, end)\", \"1\", \"end\"]);\n            });\n            it(\"should correct steps function with undefined second parameter\", function () {\n                testInvalidStep(\"steps(1, middle)\", [\"steps(1, end)\", \"1\", \"end\"]);\n            });\n            it(\"should correct steps function with typo in second parameter\", function () {\n                testInvalidStep(\"steps(1, satrt)\", [\"steps(1, start)\", \"1\", \"start\"]);\n            });\n            it(\"should correct steps function with a string as second parameter\", function () {\n                testInvalidStep(\"steps(1, 'start')\", [\"steps(1, start)\", \"1\", \"start\"]);\n            });\n            it(\"should correct steps function with 3 parameters\", function () {\n                testInvalidStep(\"steps(1, start, end)\", [\"steps(1, start)\", \"1\", \"start\"]);\n            });\n\n            // Real invalid cubic-beziers - they should NOT be corrected automatically\n            it(\"should not match steps function with no parens\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"steps\", false);\n                expect(match).toBeFalsy();\n            });\n            it(\"should not match steps function with invalid whitespace\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"steps (1, end)\", false);\n                expect(match).toBeFalsy();\n            });\n            it(\"should not match steps function with UPPER-CASE\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"STEPS(12)\", false);\n                expect(match).toBeFalsy();\n            });\n            it(\"should not match unknown timing function\", function () {\n                match = TimingFunctionUtils.timingFunctionMatch(\"step\", false);\n                expect(match).toBeFalsy();\n            });\n        });\n\n\n        describe(\"Bookmark Timing Function\", function () {\n            beforeEach(function () {\n                var mock = SpecRunnerUtils.createMockEditor(testContentCSS, \"css\");\n                testDocument = mock.doc;\n                testEditor = mock.editor;\n            });\n\n            afterEach(function () {\n                SpecRunnerUtils.destroyMockEditor(testDocument);\n                testEditor = null;\n                testDocument = null;\n                inline = null;\n            });\n\n            /**\n             * Expects an inline editor to be opened at the given cursor position and to have the\n             * given initial timing function (which should match the timing function at that position).\n             * @param {!{line:number, ch:number}} cursor The cursor position to try opening the inline at.\n             * @param {number} start The expected start of timing function.\n             * @param {number} end The expected end of timing function.\n             */\n            async function testOpenTimingFunction(cursor, start, end) {\n                await makeTimingFunctionEditor(cursor);\n                expect(inline).toBeTruthy();\n                expect(inline._startBookmark.find().ch).toBe(start);\n                expect(inline._endBookmark.find().ch).toBe(end);\n            }\n\n            it(\"should bookmark cubic-bezier() function when opened in inline editor\", async function () {\n                await testOpenTimingFunction({line: 3, ch: 34}, 32, 60);\n            });\n            it(\"should bookmark linear function when opened in inline editor\", async function () {\n                await testOpenTimingFunction({line: 5, ch: 35}, 32, 38);\n            });\n            it(\"should bookmark second cubic-bezier() function when opened in inline editor\", async function () {\n                await testOpenTimingFunction({line: 13, ch: 80}, 75, 107);\n            });\n            it(\"should bookmark steps() function when opened in inline editor\", async function () {\n                await testOpenTimingFunction({line: 17, ch: 37}, 32, 45);\n            });\n            it(\"should bookmark step-start function when opened in inline editor\", async function () {\n                await testOpenTimingFunction({line: 20, ch: 40}, 32, 42);\n            });\n            it(\"should bookmark long, invalid cubic-bezier() function when opened in inline editor\", async function () {\n                await testOpenTimingFunction({line: 25, ch: 52}, 32, 74);\n            });\n            it(\"should bookmark empty, invalid cubic-bezier() function when opened in inline editor\", async function () {\n                await testOpenTimingFunction({line: 26, ch: 47}, 32, 46);\n            });\n            it(\"should bookmark long, invalid steps() function when opened in inline editor\", async function () {\n                await testOpenTimingFunction({line: 30, ch: 44}, 32, 50);\n            });\n            it(\"should bookmark empty, invalid steps() function when opened in inline editor\", async function () {\n                await testOpenTimingFunction({line: 31, ch: 45}, 32, 39);\n            });\n        });\n\n        describe(\"TimingFunction editor UI\", function () {\n            var timingFuncEditor;\n\n            /**\n             * Creates a hidden BezierCurveEditor and appends it to the body. Note that this is a\n             * standalone BezierCurveEditor, not inside an InlineTimingFunctionEditor.\n             * @param {string} initialTimingFunction The timingFunction that should be initially set\n             *     in the BezierCurveEditor.\n             * @param {?function} callback An optional callback to be passed as the BezierCurveEditor's\n             *     callback. If none is supplied, a dummy function is passed.\n             */\n            function makeTimingFuncUI(initialTimingFunction, callback) {\n                var parent = $(window.document.body),\n                    match = TimingFunctionUtils.timingFunctionMatch(initialTimingFunction, true),\n                    cb = callback || function () { };\n\n                if (match.isBezier) {\n                    timingFuncEditor = new BezierCurveEditor(parent, match, cb);\n                } else if (match.isStep) {\n                    timingFuncEditor = new StepEditor(parent, match, cb);\n                }\n\n                // Hide it\n                timingFuncEditor.getRootElement().css(\"display\", \"none\");\n            }\n\n            afterEach(function () {\n                timingFuncEditor.getRootElement().remove();\n                timingFuncEditor = null;\n            });\n\n\n            describe(\"Initial Load and External Update\", function () {\n\n                it(\"should load the initial cubic-bezier function correctly\", async function () {\n                    makeTimingFuncUI(\"cubic-bezier(.2, .3, .4, .5)\");\n                    expect(timingFuncEditor).toBeTruthy();\n                    expect(timingFuncEditor._cubicBezierCoords).toBeTruthy();\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\".2\", \".3\", \".4\", \".5\"]);\n                });\n                it(\"should load externally updated cubic-bezier function correctly\", function () {\n                    makeTimingFuncUI(\"cubic-bezier(.1, .3, .5, .7)\");\n                    var matchUpdate = TimingFunctionUtils.timingFunctionMatch(\"cubic-bezier(.2, .4, .6, .8)\", true);\n                    timingFuncEditor.handleExternalUpdate(matchUpdate);\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\".2\", \".4\", \".6\", \".8\"]);\n                });\n                it(\"should load the initial steps function correctly\", function () {\n                    makeTimingFuncUI(\"steps(5, start)\");\n                    expect(timingFuncEditor).toBeTruthy();\n                    expect(timingFuncEditor._stepParams).toBeTruthy();\n                    expect(timingFuncEditor._stepParams.count).toEqual(5);\n                    expect(timingFuncEditor._stepParams.timing).toEqual(\"start\");\n                });\n                it(\"should load externally updated steps function correctly\", function () {\n                    makeTimingFuncUI(\"steps(5, start)\");\n                    var matchUpdate = TimingFunctionUtils.timingFunctionMatch(\"steps(6, end)\", true);\n                    timingFuncEditor.handleExternalUpdate(matchUpdate);\n                    expect(timingFuncEditor._stepParams.count).toEqual(6);\n                    expect(timingFuncEditor._stepParams.timing).toEqual(\"end\");\n                });\n            });\n\n            describe(\"Conversions\", function () {\n\n                it(\"should convert linear function to cubic-bezier function parameters\", function () {\n                    makeTimingFuncUI(\"linear\");\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\"0\", \"0\", \"1\", \"1\"]);\n                });\n                it(\"should convert ease function to cubic-bezier function parameters\", function () {\n                    makeTimingFuncUI(\"ease\");\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\".25\", \".1\", \".25\", \"1\"]);\n                });\n                it(\"should convert ease-in function to cubic-bezier function parameters\", function () {\n                    makeTimingFuncUI(\"ease-in\");\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\".42\", \"0\", \"1\", \"1\"]);\n                });\n                it(\"should convert ease-out function to cubic-bezier function parameters\", function () {\n                    makeTimingFuncUI(\"ease-out\");\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\"0\", \"0\", \".58\", \"1\"]);\n                });\n                it(\"should convert ease-in-out function to cubic-bezier function parameters\", function () {\n                    makeTimingFuncUI(\"ease-in-out\");\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\".42\", \"0\", \".58\", \"1\"]);\n                });\n                it(\"should convert step-start function to steps function parameters\", function () {\n                    makeTimingFuncUI(\"step-start\");\n                    expect(timingFuncEditor).toBeTruthy();\n                    expect(timingFuncEditor._stepParams).toBeTruthy();\n                    expect(timingFuncEditor._stepParams.count).toEqual(1);\n                    expect(timingFuncEditor._stepParams.timing).toEqual(\"start\");\n                });\n                it(\"should convert step-end function to steps function parameters\", function () {\n                    makeTimingFuncUI(\"step-end\");\n                    expect(timingFuncEditor._stepParams.count).toEqual(1);\n                    expect(timingFuncEditor._stepParams.timing).toEqual(\"end\");\n                });\n            });\n\n            describe(\"Editing with Mouse\", function () {\n\n                /**\n                 * Translate from a bezier-curve point (1.0 x 1.0 grid)\n                 *           to a canvas element point (150px x 150px grid).\n                 * @param  {Array} bezierPoint The bezier point [x, y].\n                 * @return {Array} canvas element point in [x, y]\n                 */\n                function translatePointFromBezierToCanvas(bezierPoint) {\n                    return [\n                        Math.round(bezierPoint[0] * 150),\n                        Math.round(((1 - bezierPoint[1]) * 150) + 75)\n                    ];\n                }\n                /**\n                 * Simulate the given event with clientX/clientY specified by the given\n                 * offsets by the left/top of the item.\n                 * @param {string} event The name of the event to simulate.\n                 * @param {object} $item A jQuery object to trigger the event on.\n                 * @param {Array.<number>} offsets Numbers the x and y positions of the\n                 *      event relative to the item's top and left.\n                 */\n                function eventAtOffset(event, $item, offsets) {\n                    $item.trigger($.Event(event, {\n                        pageX: $item.offset().left + offsets[0],\n                        pageY: $item.offset().top  + offsets[1],\n                        which: 1\n                    }));\n                }\n\n                /**\n                 * Test a mouse down event on the given UI element in a cubic-bezier function.\n                 * @param {object} opts The parameters to test:\n                 *     item: The (string) name of the member of BezierCurveEditor that\n                 *          references the element to test.\n                 *     clickAt: An [x, y] array specifying the simulated x/y mouse position as\n                 *          an offset of the item's width/height.\n                 *     expected: The expected array of values for _cubicBezierCoords.\n                 */\n                function testCubicBezierClick(opts) {\n                    makeTimingFuncUI(\"cubic-bezier(.42, 0, .58 ,1)\");\n                    var $item = $(timingFuncEditor[opts.item]);\n                    eventAtOffset(\"click\", $item, opts.clickAt);\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, opts.expected);\n                }\n\n                /**\n                 * Test a drag event on the given UI element.\n                 * @param {object} opts The parameters to test:\n                 *     downItem: The (string) name of the member of BezierCurveEditor\n                 *          that references the element to mousedown on to drag.\n                 *     clickAt: An [x, y] array specifying the simulated x/y mouse position as an offset of the\n                 *          item's width/height.\n                 *     dragItem: The (string) name of the member of BezierCurveEditor\n                 *          that references the element to drag item to.\n                 *     dragTo: An [x, y] array specifying the location to drag to, using the same convention as clickAt.\n                 *     expected: The expected array of values for _cubicBezierCoords.\n                 */\n                function testCubicBezierDrag(opts) {\n                    makeTimingFuncUI(\"cubic-bezier(.42, 0, .58 ,1)\");\n                    var $downItem = $(timingFuncEditor[opts.downItem]),\n                        $dragItem = $(timingFuncEditor[opts.dragItem]);\n\n                    eventAtOffset(\"mousedown\", $downItem, opts.clickAt);\n                    eventAtOffset(\"mousemove\", $dragItem, opts.dragTo);\n                    $downItem.trigger(\"mouseup\");\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, opts.expected);\n                }\n\n                it(\"should move point P1 on mousedown in curve\", function () {\n                    testCubicBezierClick({\n                        item: \"curve\",\n                        clickAt: translatePointFromBezierToCanvas([0.5, 0.1]),\n                        expected: [\".5\", \".1\", \".58\", \"1\"]\n                    });\n                });\n                it(\"should move point P2 on mousedown in curve\", function () {\n                    testCubicBezierClick({\n                        item: \"curve\",\n                        clickAt: translatePointFromBezierToCanvas([0.6, 1.2]),\n                        expected: [\".42\", \"0\", \".6\", \"1.2\"]\n                    });\n                });\n                it(\"should move point P1 on drag\", function () {\n                    testCubicBezierDrag({\n                        downItem: \"P1\",        // mouse down on this element\n                        clickAt: [5, 5],\n                        dragItem: \"curve\",     // drag over this element\n                        dragTo: translatePointFromBezierToCanvas([0.6, -0.1]),\n                        expected: [\".6\", \"-0.1\", \".58\", \"1\"]\n                    });\n                });\n                it(\"should move point P2 on drag\", function () {\n                    testCubicBezierDrag({\n                        downItem: \"P2\",        // mouse down on this element\n                        clickAt: [5, 5],\n                        dragItem: \"curve\",     // drag over this element\n                        dragTo: translatePointFromBezierToCanvas([0.8, 0.9]),\n                        expected: [\".42\", \"0\", \".8\", \".9\"]\n                    });\n                });\n                it(\"should not move point P2 x-value out-of-range on drag\", function () {\n                    testCubicBezierDrag({\n                        downItem: \"P2\",        // mouse down on this element\n                        clickAt: [5, 5],\n                        dragItem: \"curve\",     // drag over this element\n                        dragTo: translatePointFromBezierToCanvas([1.1, 1]),\n                        expected: [\".42\", \"0\", \"1\", \"1\"]\n                    });\n                });\n            });\n\n            describe(\"Editing with Keyboard\", function () {\n\n                function makeKeyEvent(opts) {\n                    return $.Event(\"keydown\", { keyCode: opts.key, shiftKey: !!opts.shift });\n                }\n\n                /**\n                 * Create a timing function editor and trigger a key event on it.\n                 * @param {object} opts The parameters to test:\n                 *     func: The initial timing function\n                 *     item: The (string) name of the member of BezierCurveEditor\n                 *          that references the element to test.\n                 *     key: The KeyEvent key code to simulate.\n                 *     shift: Optional boolean specifying whether to simulate the shift\n                 *          key being down (default false).\n                 *     expected: The expected array of values for _cubicBezierCoords.\n                 */\n                function triggerTimingFunctionEditorKey(opts) {\n                    makeTimingFuncUI(opts.func, opts.callback);\n                    var $item = $(timingFuncEditor[opts.item]);\n                    $item.focus();\n                    $item.trigger(makeKeyEvent(opts));\n                }\n\n                // cubic-bezier() tests\n                it(\"should increase P1 x-value by .02 on right arrow in cubic-bezier()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"cubic-bezier(.42, 0, .58, 1)\",\n                        item: \"P1\",\n                        key: KeyEvent.DOM_VK_RIGHT,\n                        shift: false\n                    });\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\".44\", \"0\", \".58\", \"1\"]);\n                });\n                it(\"should increase P1 y-value by .1 on shift up arrow in cubic-bezier()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"cubic-bezier(.42, 0, .58, 1)\",\n                        item: \"P1\",\n                        key: KeyEvent.DOM_VK_UP,\n                        shift: true\n                    });\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\".42\", \".1\", \".58\", \"1\"]);\n                });\n                it(\"should decrease P2 x-value by .02 on left arrow in cubic-bezier()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"cubic-bezier(.42, 0, .58, 1)\",\n                        item: \"P2\",\n                        key: KeyEvent.DOM_VK_LEFT,\n                        shift: false\n                    });\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\".42\", \"0\", \".56\", \"1\"]);\n                });\n                it(\"should decrease P2 y-value by .1 on shift down arrow in cubic-bezier()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"cubic-bezier(.42, 0, .58 ,1)\",\n                        item: \"P2\",\n                        key: KeyEvent.DOM_VK_DOWN,\n                        shift: true\n                    });\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\".42\", \"0\", \".58\", \".9\"]);\n                });\n                it(\"should not decrease P1 x-value below 0 on left arrow in cubic-bezier()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"cubic-bezier(0, 0, 1, 1)\",\n                        item: \"P1\",\n                        key: KeyEvent.DOM_VK_LEFT,\n                        shift: false\n                    });\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\"0\", \"0\", \"1\", \"1\"]);\n                });\n                it(\"should not increase P2 x-value above 0 on shift right arrow in cubic-bezier()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"cubic-bezier(0, 0, 1, 1)\",\n                        item: \"P2\",\n                        key: KeyEvent.DOM_VK_RIGHT,\n                        shift: true\n                    });\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\"0\", \"0\", \"1\", \"1\"]);\n                });\n                it(\"should call callback function after cubic-bezier edit in cubic-bezier()\", function () {\n                    var calledBack = false;\n\n                    var _callback = function (timingFunctionString) {\n                        calledBack = true;\n                        expect(timingFunctionString).toBe(\"cubic-bezier(.42, .1, .58, 1)\");\n                    };\n\n                    triggerTimingFunctionEditorKey({\n                        func: \"cubic-bezier(.42, 0, .58 ,1)\",\n                        item: \"P1\",\n                        key: KeyEvent.DOM_VK_UP,\n                        shift: true,\n                        callback: _callback\n                    });\n                    expectArraysToBeEqual(timingFuncEditor._cubicBezierCoords, [\".42\", \".1\", \".58\", \"1\"]);\n\n                    expect(calledBack).toBeTruthy();\n                });\n\n                // steps() tests\n                it(\"should increase count by 1 on up arrow in steps()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"steps(5)\",\n                        item: \"canvas\",\n                        key: KeyEvent.DOM_VK_UP\n                    });\n                    expect(timingFuncEditor._stepParams.count).toEqual(6);\n                });\n                it(\"should decrease count by 1 on down arrow in steps()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"steps(5)\",\n                        item: \"canvas\",\n                        key: KeyEvent.DOM_VK_DOWN\n                    });\n                    expect(timingFuncEditor._stepParams.count).toEqual(4);\n                });\n                it(\"should change start to end on right arrow in steps()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"steps(5, start)\",\n                        item: \"canvas\",\n                        key: KeyEvent.DOM_VK_RIGHT\n                    });\n                    expect(timingFuncEditor._stepParams.timing).toEqual(\"end\");\n                });\n                it(\"should change end to start on left arrow in steps()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"steps(5, end)\",\n                        item: \"canvas\",\n                        key: KeyEvent.DOM_VK_LEFT\n                    });\n                    expect(timingFuncEditor._stepParams.timing).toEqual(\"start\");\n                });\n                it(\"should not decrease count to be less than 1 on down arrow in steps()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"steps(1)\",\n                        item: \"canvas\",\n                        key: KeyEvent.DOM_VK_DOWN\n                    });\n                    expect(timingFuncEditor._stepParams.count).toEqual(1);\n                });\n                it(\"should not change start to end on left arrow in steps()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"steps(5, start)\",\n                        item: \"canvas\",\n                        key: KeyEvent.DOM_VK_LEFT\n                    });\n                    expect(timingFuncEditor._stepParams.timing).toEqual(\"start\");\n                });\n                it(\"should not change end to start on right arrow in steps()\", function () {\n                    triggerTimingFunctionEditorKey({\n                        func: \"steps(5, end)\",\n                        item: \"canvas\",\n                        key: KeyEvent.DOM_VK_RIGHT\n                    });\n                    expect(timingFuncEditor._stepParams.timing).toEqual(\"end\");\n                });\n\n                it(\"should call callback function after steps function edit\", async function () {\n                    var calledBack = false;\n\n                    var _callback = function (timingFunctionString) {\n                        calledBack = true;\n                        expect(timingFunctionString).toBe(\"steps(5, start)\");\n                    };\n\n                    triggerTimingFunctionEditorKey({\n                        func: \"steps(4, start)\",\n                        item: \"canvas\",\n                        key: KeyEvent.DOM_VK_UP,\n                        callback: _callback\n                    });\n                    expect(timingFuncEditor._stepParams.count).toEqual(5);\n\n                    expect(calledBack).toBeTruthy();\n                });\n\n            });\n        });\n    });\n});\n"],"file":"unittests.js"}
{"version":3,"sources":["extensions/default/JavaScriptRefactoring/WrapSelection.js"],"names":["define","require","exports","module","_","brackets","getModule","EditorManager","TokenUtils","Strings","RefactoringUtils","RefactoringSession","WRAP_IN_CONDITION","ARROW_FUNCTION","GETTERS_SETTERS","TRY_CATCH","current","initializeRefactoringSession","editor","_wrapSelectedStatements","wrapperName","err","getActiveEditor","startIndex","endIndex","selectedText","pos","length","statementNode","findSurroundASTNode","ast","start","displayErrorMessageAtCursor","text","substr","end","selectionDetails","normalizeText","checkStatement","cm","posFromIndex","document","batchOperation","replaceTextFromTemplate","body","cursorLine","getSelection","line","startCursorCh","getLine","indexOf","endCursorCh","setSelection","ch","wrapInTryCatch","ERROR_TRY_CATCH","wrapInCondition","ERROR_WRAP_IN_CONDITION","convertToArrowFunction","funcExprNode","type","id","noOfStatements","param","dontChangeParam","numberOfParams","params","treatAsManyParam","forEach","item","push","name","splice","loc","fullFunctionScope","functionsDeclOnly","locPos","isReturnStatement","bodyStatements","join","statement","trimRight","trim","setCursorPos","ERROR_ARROW_FUNCTION","createGettersAndSetters","token","getTokenAt","commaString","isLastNode","templateParams","parentNode","propertyEndPos","getParentNode","properties","propertyNodeArray","properyNodeIndex","findIndex","element","propertyNode","nextPropertNode","nextPropertyStartPos","getSetPos","isLastNodeInScope","lineEndPosition","startPos","adjustPosForChange","split","getName","string","setName","tokenName","replaceRange","ERROR_GETTERS_SETTERS"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var _ = brackets.getModule(\"thirdparty/lodash\");\n\n    var EditorManager        = brackets.getModule(\"editor/EditorManager\"),\n        TokenUtils           = brackets.getModule(\"utils/TokenUtils\"),\n        Strings              = brackets.getModule(\"strings\"),\n        RefactoringUtils     = require(\"RefactoringUtils\"),\n        RefactoringSession   = RefactoringUtils.RefactoringSession;\n\n    //Template keys mentioned in Templates.json\n    var WRAP_IN_CONDITION       = \"wrapCondition\",\n        ARROW_FUNCTION          = \"arrowFunction\",\n        GETTERS_SETTERS         = \"gettersSetters\",\n        TRY_CATCH               = \"tryCatch\";\n\n    //Active session which will contain information about editor, selection etc\n    var current = null;\n\n    /**\n     * Initialize session\n     */\n    function initializeRefactoringSession(editor) {\n        current = new RefactoringSession(editor);\n    }\n\n    /**\n     * Wrap selected statements\n     *\n     * @param {string} wrapperName - template name where we want wrap selected statements\n     * @param {string} err- error message if we can't wrap selected code\n     */\n    function _wrapSelectedStatements (wrapperName, err) {\n        var editor = EditorManager.getActiveEditor();\n        if (!editor) {\n            return;\n        }\n        initializeRefactoringSession(editor);\n\n        var startIndex = current.startIndex,\n            endIndex = current.endIndex,\n            selectedText = current.selectedText,\n            pos;\n\n        if (selectedText.length === 0) {\n            var statementNode = RefactoringUtils.findSurroundASTNode(current.ast, {start: startIndex}, [\"Statement\"]);\n            if (!statementNode) {\n                current.editor.displayErrorMessageAtCursor(err);\n                return;\n            }\n            selectedText = current.text.substr(statementNode.start, statementNode.end - statementNode.start);\n            startIndex = statementNode.start;\n            endIndex = statementNode.end;\n        } else {\n            var selectionDetails = RefactoringUtils.normalizeText(selectedText, startIndex, endIndex);\n            selectedText = selectionDetails.text;\n            startIndex = selectionDetails.start;\n            endIndex = selectionDetails.end;\n        }\n\n        if (!RefactoringUtils.checkStatement(current.ast, startIndex, endIndex, selectedText)) {\n            current.editor.displayErrorMessageAtCursor(err);\n            return;\n        }\n\n        pos = {\n            \"start\": current.cm.posFromIndex(startIndex),\n            \"end\": current.cm.posFromIndex(endIndex)\n        };\n\n        current.document.batchOperation(function() {\n            current.replaceTextFromTemplate(wrapperName, {body: selectedText}, pos);\n        });\n\n        if (wrapperName === TRY_CATCH) {\n            var cursorLine = current.editor.getSelection().end.line - 1,\n                startCursorCh = current.document.getLine(cursorLine).indexOf(\"\\/\\/\"),\n                endCursorCh = current.document.getLine(cursorLine).length;\n\n            current.editor.setSelection({\"line\": cursorLine, \"ch\": startCursorCh}, {\"line\": cursorLine, \"ch\": endCursorCh});\n        } else if (wrapperName === WRAP_IN_CONDITION) {\n            current.editor.setSelection({\"line\": pos.start.line, \"ch\": pos.start.ch + 4}, {\"line\": pos.start.line, \"ch\": pos.start.ch + 13});\n        }\n    }\n\n\n     //Wrap selected statements in try catch block\n    function wrapInTryCatch() {\n        _wrapSelectedStatements(TRY_CATCH, Strings.ERROR_TRY_CATCH);\n    }\n\n    //Wrap selected statements in try condition\n    function wrapInCondition() {\n        _wrapSelectedStatements(WRAP_IN_CONDITION, Strings.ERROR_WRAP_IN_CONDITION);\n    }\n\n    //Convert function to arrow function\n    function convertToArrowFunction() {\n        var editor = EditorManager.getActiveEditor();\n        if (!editor) {\n            return;\n        }\n        initializeRefactoringSession(editor);\n\n        var funcExprNode = RefactoringUtils.findSurroundASTNode(current.ast, {start: current.startIndex}, [\"Function\"]);\n\n        if (!funcExprNode || funcExprNode.type !== \"FunctionExpression\" || funcExprNode.id) {\n            current.editor.displayErrorMessageAtCursor(Strings.ERROR_ARROW_FUNCTION);\n            return;\n        }\n\n        if (funcExprNode === \"FunctionDeclaration\") {\n            current.editor.displayErrorMessageAtCursor(Strings.ERROR_ARROW_FUNCTION);\n            return;\n        }\n\n        if (!funcExprNode.body) {\n            return;\n        }\n\n        var noOfStatements = funcExprNode.body.body.length,\n            selectedText = current.text.substr(funcExprNode.start, funcExprNode.end - funcExprNode.start),\n            param = [],\n            dontChangeParam = false,\n            numberOfParams = funcExprNode.params.length,\n            treatAsManyParam = false;\n\n        funcExprNode.params.forEach(function (item) {\n            if (item.type === \"Identifier\") {\n                param.push(item.name);\n            } else if (item.type === \"AssignmentPattern\") {\n                dontChangeParam = true;\n            }\n        });\n\n        //In case defaults params keep params as it is\n        if (dontChangeParam) {\n            if (numberOfParams >= 1) {\n                param.splice(0, param.length);\n                param.push(current.text.substr(funcExprNode.params[0].start, funcExprNode.params[numberOfParams-1].end - funcExprNode.params[0].start));\n                // In case default param, treat them as many paramater because to use\n                // one parameter template, That param should be an identifier\n                if (numberOfParams === 1) {\n                    treatAsManyParam = true;\n                }\n            }\n            dontChangeParam = false;\n        }\n\n        var loc = {\n                \"fullFunctionScope\": {\n                    start: funcExprNode.start,\n                    end: funcExprNode.end\n                },\n                \"functionsDeclOnly\": {\n                    start: funcExprNode.start,\n                    end: funcExprNode.body.start\n                }\n            },\n            locPos = {\n                \"fullFunctionScope\": {\n                    \"start\": current.cm.posFromIndex(loc.fullFunctionScope.start),\n                    \"end\": current.cm.posFromIndex(loc.fullFunctionScope.end)\n                },\n                \"functionsDeclOnly\": {\n                    \"start\": current.cm.posFromIndex(loc.functionsDeclOnly.start),\n                    \"end\": current.cm.posFromIndex(loc.functionsDeclOnly.end)\n                }\n            },\n            isReturnStatement = (noOfStatements >= 1 && funcExprNode.body.body[0].type === \"ReturnStatement\"),\n            bodyStatements = funcExprNode.body.body[0],\n            params;\n\n            // If there is nothing in function body, then get the text b/w curly braces\n            // In this case, We will update params only as per Arrow function expression\n        if (!bodyStatements) {\n            bodyStatements = funcExprNode.body;\n        }\n        params = {\n            \"params\": param.join(\", \"),\n            \"statement\": _.trimRight(current.text.substr(bodyStatements.start, bodyStatements.end - bodyStatements.start), \";\")\n        };\n\n        if (isReturnStatement) {\n            params.statement = params.statement.substr(7).trim();\n        }\n\n        if (noOfStatements === 1) {\n            current.document.batchOperation(function() {\n                (numberOfParams === 1 && !treatAsManyParam) ?  current.replaceTextFromTemplate(ARROW_FUNCTION, params, locPos.fullFunctionScope, \"oneParamOneStament\") :\n                current.replaceTextFromTemplate(ARROW_FUNCTION, params, locPos.fullFunctionScope, \"manyParamOneStament\");\n\n            });\n        } else {\n            current.document.batchOperation(function() {\n                (numberOfParams === 1 && !treatAsManyParam) ?  current.replaceTextFromTemplate(ARROW_FUNCTION, {params: param},\n                locPos.functionsDeclOnly, \"oneParamManyStament\") :\n                current.replaceTextFromTemplate(ARROW_FUNCTION, {params: param.join(\", \")}, locPos.functionsDeclOnly, \"manyParamManyStament\");\n            });\n        }\n\n        current.editor.setCursorPos(locPos.functionsDeclOnly.end.line, locPos.functionsDeclOnly.end.ch, false);\n    }\n\n    // Create gtteres and setters for a property\n    function createGettersAndSetters() {\n        var editor = EditorManager.getActiveEditor();\n        if (!editor) {\n            return;\n        }\n        initializeRefactoringSession(editor);\n\n        var startIndex = current.startIndex,\n            endIndex = current.endIndex,\n            selectedText = current.selectedText;\n\n        if (selectedText.length >= 1) {\n            var selectionDetails = RefactoringUtils.normalizeText(selectedText, startIndex, endIndex);\n            selectedText = selectionDetails.text;\n            startIndex = selectionDetails.start;\n            endIndex = selectionDetails.end;\n        }\n\n        var token = TokenUtils.getTokenAt(current.cm, current.cm.posFromIndex(endIndex)),\n            commaString = \",\",\n            isLastNode,\n            templateParams,\n            parentNode,\n            propertyEndPos;\n\n        //Create getters and setters only if selected reference is a property\n        if (token.type !== \"property\") {\n            current.editor.displayErrorMessageAtCursor(Strings.ERROR_GETTERS_SETTERS);\n            return;\n        }\n\n        parentNode = current.getParentNode(current.ast, endIndex);\n        // Check if selected propery is child of a object expression\n        if (!parentNode || !parentNode.properties) {\n            current.editor.displayErrorMessageAtCursor(Strings.ERROR_GETTERS_SETTERS);\n            return;\n        }\n\n\n        var propertyNodeArray = parentNode.properties;\n        // Find the last Propery Node before endIndex\n        var properyNodeIndex = propertyNodeArray.findIndex(function (element) {\n            return (endIndex >= element.start && endIndex < element.end);\n        });\n\n        var propertyNode = propertyNodeArray[properyNodeIndex];\n\n        //Get Current Selected Property End Index;\n        propertyEndPos = editor.posFromIndex(propertyNode.end);\n\n\n        //We have to add ',' so we need to find position of current property selected\n        isLastNode = current.isLastNodeInScope(current.ast, endIndex);\n        var nextPropertNode, nextPropertyStartPos;\n        if(!isLastNode && properyNodeIndex + 1 <= propertyNodeArray.length - 1) {\n            nextPropertNode = propertyNodeArray[properyNodeIndex + 1];\n            nextPropertyStartPos = editor.posFromIndex(nextPropertNode.start);\n\n            if(propertyEndPos.line !== nextPropertyStartPos.line) {\n                propertyEndPos = current.lineEndPosition(current.startPos.line);\n            } else {\n                propertyEndPos = nextPropertyStartPos;\n                commaString = \", \";\n            }\n        }\n\n        var getSetPos;\n        if (isLastNode) {\n            getSetPos = current.document.adjustPosForChange(propertyEndPos, commaString.split(\"\\n\"),\n                                                            propertyEndPos, propertyEndPos);\n        } else {\n            getSetPos = propertyEndPos;\n        }\n        templateParams = {\n            \"getName\": token.string,\n            \"setName\": token.string,\n            \"tokenName\": token.string\n        };\n\n        // Replace, setSelection, IndentLine\n        // We need to call batchOperation as indentLine don't have option to add origin as like replaceRange\n        current.document.batchOperation(function() {\n            if (isLastNode) {\n                //Add ',' in the end of current line\n                current.document.replaceRange(commaString, propertyEndPos, propertyEndPos);\n            }\n\n            current.editor.setSelection(getSetPos); //Selection on line end\n\n            // Add getters and setters for given token using template at current cursor position\n            current.replaceTextFromTemplate(GETTERS_SETTERS, templateParams);\n\n            if (!isLastNode) {\n                // Add ',' at the end setter\n                current.document.replaceRange(commaString, current.editor.getSelection().start, current.editor.getSelection().start);\n            }\n        });\n    }\n\n    exports.wrapInCondition         = wrapInCondition;\n    exports.wrapInTryCatch          = wrapInTryCatch;\n    exports.convertToArrowFunction  = convertToArrowFunction;\n    exports.createGettersAndSetters = createGettersAndSetters;\n});\n"],"file":"WrapSelection.js"}
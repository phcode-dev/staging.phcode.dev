{"version":3,"sources":["editor/CSSInlineEditor.js"],"names":["define","require","exports","module","CSSUtils","DropdownButton","CommandManager","Commands","DocumentManager","EditorManager","Editor","LanguageManager","ProjectManager","FileUtils","HTMLUtils","MultiRangeInlineEditor","Strings","ViewUtils","Metrics","_","_newRuleCmd","_newRuleHandlers","_getCSSFilesInProject","getAllFiles","getLanguageFilter","_getSelectorName","editor","pos","tagInfo","getTagInfo","selectorName","reason","position","tokenType","TAG_NAME","CLOSING_TAG","tagName","ATTR_NAME","ATTR_VALUE","attr","name","attributeValue","value","test","startIndex","substr","offset","lastIndexOf","endIndex","indexOf","substring","length","ERROR_CSSQUICKEDIT_BETWEENCLASSES","ERROR_CSSQUICKEDIT_CLASSNOTFOUND","trimmedVal","trim","ERROR_CSSQUICKEDIT_IDNOTFOUND","ERROR_CSSQUICKEDIT_UNSUPPORTEDATTR","_addRule","inlineEditor","path","getDocumentForPath","done","styleDoc","newRuleInfo","addRuleToDocument","getUseTabChar","getSpaceUnits","addAndSelectRange","range","from","line","to","setCursorPos","ch","_handleNewRule","getFocusedMultiRangeInlineEditor","handlerInfo","find","entry","handler","_stylesheetListRenderer","item","html","escape","subDirStr","htmlToCSSProvider","hostEditor","getLanguageForSelection","getId","countEvent","EVENT_TYPE","EDITOR","sel","getSelection","start","end","selectorResult","result","$","Deferred","cssInlineEditor","cssFileInfos","newRuleButton","_onDropdownSelect","event","fileInfo","fullPath","_getNoRulesMsg","fileInfos","resolve","CSS_QUICK_EDIT_NO_MATCHES","CSS_QUICK_EDIT_NO_STYLESHEETS","_updateCommands","setEnabled","hasFocus","$button","hasClass","_handleNewRuleClick","e","toggleDropdown","_fileComparator","a","b","aIsCSS","getLanguageForPath","bIsCSS","comparePaths","_prepFileList","files","sort","fileNames","forEach","file","push","displayPaths","getDirNamesForDuplicateFiles","i","_onHostEditorScroll","closeDropdown","findMatchingRules","document","rules","inlineEditorDeferred","consolidateRules","getRangeSelectors","load","$htmlContent","on","off","$header","BUTTON_NEW_RULE","addClass","append","stylesheetsPromise","when","promise","removeClass","focus","items","fail","error","console","warn","reject","registerInlineEditProvider","register","CMD_CSS_QUICK_EDIT_NEW_RULE","CSS_QUICK_EDIT_NEW_RULE"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Load dependent modules\n    var CSSUtils                = require(\"language/CSSUtils\"),\n        DropdownButton          = require(\"widgets/DropdownButton\").DropdownButton,\n        CommandManager          = require(\"command/CommandManager\"),\n        Commands                = require(\"command/Commands\"),\n        DocumentManager         = require(\"document/DocumentManager\"),\n        EditorManager           = require(\"editor/EditorManager\"),\n        Editor                  = require(\"editor/Editor\").Editor,\n        LanguageManager         = require(\"language/LanguageManager\"),\n        ProjectManager          = require(\"project/ProjectManager\"),\n        FileUtils               = require(\"file/FileUtils\"),\n        HTMLUtils               = require(\"language/HTMLUtils\"),\n        MultiRangeInlineEditor  = require(\"editor/MultiRangeInlineEditor\"),\n        Strings                 = require(\"strings\"),\n        ViewUtils               = require(\"utils/ViewUtils\"),\n        Metrics                 = require(\"utils/Metrics\"),\n        _                       = require(\"thirdparty/lodash\");\n\n    var _newRuleCmd,\n        _newRuleHandlers = [];\n\n    function _getCSSFilesInProject() {\n        return ProjectManager.getAllFiles(ProjectManager.getLanguageFilter([\"css\", \"less\", \"scss\"]));\n    }\n\n    /**\n     * Given a position in an HTML editor, returns the relevant selector for the attribute/tag\n     * surrounding that position, or \"\" if none is found.\n     * @param {!Editor} editor\n     * @param {!{line:Number, ch:Number}} pos\n     * @return {selectorName: {string}, reason: {string}}\n     * @private\n     */\n    function _getSelectorName(editor, pos) {\n        var tagInfo = HTMLUtils.getTagInfo(editor, pos),\n            selectorName = \"\",\n            reason;\n\n        if (tagInfo.position.tokenType === HTMLUtils.TAG_NAME || tagInfo.position.tokenType === HTMLUtils.CLOSING_TAG) {\n            // Type selector\n            selectorName = tagInfo.tagName;\n        } else if (tagInfo.position.tokenType === HTMLUtils.ATTR_NAME ||\n                   tagInfo.position.tokenType === HTMLUtils.ATTR_VALUE) {\n            if (tagInfo.attr.name === \"class\") {\n                // Class selector. We only look for the class name\n                // that includes the insertion point. For example, if\n                // the attribute is:\n                //   class=\"error-dialog modal hide\"\n                // and the insertion point is inside \"modal\", we want \".modal\"\n                var attributeValue = tagInfo.attr.value;\n                if (/\\S/.test(attributeValue)) {\n                    var startIndex = attributeValue.substr(0, tagInfo.position.offset).lastIndexOf(\" \");\n                    var endIndex = attributeValue.indexOf(\" \", tagInfo.position.offset);\n                    selectorName = \".\" +\n                        attributeValue.substring(\n                            startIndex === -1 ? 0 : startIndex + 1,\n                            endIndex === -1 ? attributeValue.length : endIndex\n                        );\n\n                    // If the insertion point is surrounded by space between two classnames, selectorName is \".\"\n                    if (selectorName === \".\") {\n                        selectorName = \"\";\n                        reason = Strings.ERROR_CSSQUICKEDIT_BETWEENCLASSES;\n                    }\n                } else {\n                    reason = Strings.ERROR_CSSQUICKEDIT_CLASSNOTFOUND;\n                }\n            } else if (tagInfo.attr.name === \"id\") {\n                // ID selector\n                var trimmedVal = tagInfo.attr.value.trim();\n                if (trimmedVal) {\n                    selectorName = \"#\" + trimmedVal;\n                } else {\n                    reason = Strings.ERROR_CSSQUICKEDIT_IDNOTFOUND;\n                }\n            } else {\n                reason = Strings.ERROR_CSSQUICKEDIT_UNSUPPORTEDATTR;\n            }\n        }\n\n        return {\n            selectorName: selectorName,\n            reason: reason\n        };\n    }\n\n    /**\n     * @private\n     * Add a new rule for the given selector to the given stylesheet, then add the rule to the\n     * given inline editor.\n     * @param {string} selectorName The selector to create a rule for.\n     * @param {MultiRangeInlineEditor} inlineEditor The inline editor to display the new rule in.\n     * @param {string} path The path to the stylesheet file.\n     */\n    function _addRule(selectorName, inlineEditor, path) {\n        DocumentManager.getDocumentForPath(path).done(function (styleDoc) {\n            var newRuleInfo = CSSUtils.addRuleToDocument(styleDoc, selectorName, Editor.getUseTabChar(path), Editor.getSpaceUnits(path));\n            inlineEditor.addAndSelectRange(selectorName, styleDoc, newRuleInfo.range.from.line, newRuleInfo.range.to.line);\n            inlineEditor.editor.setCursorPos(newRuleInfo.pos.line, newRuleInfo.pos.ch);\n        });\n    }\n\n    /**\n     * @private\n     * Handle the \"new rule\" menu item by dispatching it to the handler for the focused inline editor.\n     */\n    function _handleNewRule() {\n        var inlineEditor = MultiRangeInlineEditor.getFocusedMultiRangeInlineEditor();\n        if (inlineEditor) {\n            var handlerInfo = _.find(_newRuleHandlers, function (entry) {\n                return entry.inlineEditor === inlineEditor;\n            });\n            if (handlerInfo) {\n                handlerInfo.handler();\n            }\n        }\n    }\n\n    /** Item renderer for stylesheet-picker dropdown */\n    function _stylesheetListRenderer(item) {\n        var html = \"<span class='stylesheet-name'>\" + _.escape(item.name);\n        if (item.subDirStr) {\n            html += \"<span class='stylesheet-dir'> — \" + _.escape(item.subDirStr) + \"</span>\";\n        }\n        html += \"</span>\";\n        return html;\n    }\n\n    /**\n     * This function is registered with EditManager as an inline editor provider. It creates a CSSInlineEditor\n     * when cursor is on an HTML tag name, class attribute, or id attribute, find associated\n     * CSS rules and show (one/all of them) in an inline editor.\n     *\n     * @param {!Editor} editor\n     * @param {!{line:Number, ch:Number}} pos\n     * @return {?$.Promise} synchronously resolved with an InlineWidget; or error\n     *         {string} if pos is in tag but not in tag name, class attr, or id attr; or null if the\n     *         selection isn't even close to a context where we could provide anything.\n     */\n    function htmlToCSSProvider(hostEditor, pos) {\n\n        // Only provide a CSS editor when cursor is in HTML content\n        if (hostEditor.getLanguageForSelection().getId() !== \"html\") {\n            return null;\n        }\n\n        //Send analytics data for QuickEdit open\n        Metrics.countEvent(\n            Metrics.EVENT_TYPE.EDITOR,\n            \"QuickEdit\",\n            \"CSSInlineEditor\"\n        );\n\n        // Only provide CSS editor if the selection is within a single line\n        var sel = hostEditor.getSelection();\n        if (sel.start.line !== sel.end.line) {\n            return null;\n        }\n\n        // Always use the selection start for determining selector name. The pos\n        // parameter is usually the selection end.\n        var selectorResult = _getSelectorName(hostEditor, sel.start);\n        if (selectorResult.selectorName === \"\") {\n            return selectorResult.reason || null;\n        }\n\n        var selectorName = selectorResult.selectorName;\n\n        var result = new $.Deferred(),\n            cssInlineEditor,\n            cssFileInfos = [],\n            newRuleButton;\n\n        /**\n         * @private\n         * Callback when item from dropdown list is selected\n         */\n        function _onDropdownSelect(event, fileInfo) {\n            _addRule(selectorName, cssInlineEditor, fileInfo.fullPath);\n        }\n\n        /**\n         * @private\n         * Checks to see if there are any stylesheets in the project, and returns the appropriate\n         * \"no rules\"/\"no stylesheets\" message accordingly.\n         * @return {$.Promise} a promise that is resolved with the message to show. Never rejected.\n         */\n        function _getNoRulesMsg() {\n            var result = new $.Deferred();\n            _getCSSFilesInProject().done(function (fileInfos) {\n                result.resolve(fileInfos.length ? Strings.CSS_QUICK_EDIT_NO_MATCHES : Strings.CSS_QUICK_EDIT_NO_STYLESHEETS);\n            });\n            return result;\n        }\n\n        /**\n         * @private\n         * Update the enablement of associated menu commands.\n         */\n        function _updateCommands() {\n            _newRuleCmd.setEnabled(cssInlineEditor.hasFocus() && !newRuleButton.$button.hasClass(\"disabled\"));\n        }\n\n        /**\n         * @private\n         * Create a new rule on click.\n         */\n        function _handleNewRuleClick(e) {\n            if (!newRuleButton.$button.hasClass(\"disabled\")) {\n                if (cssFileInfos.length === 1) {\n                    // Just go ahead and create the rule.\n                    _addRule(selectorName, cssInlineEditor, cssFileInfos[0].fullPath);\n                } else {\n                    // Although not attached to button click in 'dropdown mode', this handler can still be\n                    // invoked via the command shortcut. Just toggle dropdown open/closed in that case.\n                    newRuleButton.toggleDropdown();\n                }\n            }\n        }\n\n        /**\n         * @private\n         * Sort files with LESS/SCSS above CSS, and then within each grouping sort by path & filename\n         * (the same order we use for Find in Files)\n         * @param {!File} a, b\n         * @return {number}\n         */\n        function _fileComparator(a, b) {\n            var aIsCSS = LanguageManager.getLanguageForPath(a.fullPath).getId() === \"css\",\n                bIsCSS = LanguageManager.getLanguageForPath(b.fullPath).getId() === \"css\";\n            if (aIsCSS && !bIsCSS) {\n                return 1;\n            } else if (!aIsCSS && bIsCSS) {\n                return -1;\n            }\n            return FileUtils.comparePaths(a.fullPath, b.fullPath);\n\n        }\n\n        /**\n         * @private\n         * Prepare file list for display\n         */\n        function _prepFileList(files) {\n            // First, sort list (the same ordering we use for the results list)\n            files.sort(_fileComparator);\n\n            // Find any files that share the same name (with different path)\n            var fileNames = {};\n            files.forEach(function (file) {\n                if (!fileNames[file.name]) {\n                    fileNames[file.name] = [];\n                }\n                fileNames[file.name].push(file);\n            });\n\n            // For any duplicate filenames, set subDirStr to a path snippet the helps\n            // the user distinguish each file in the list.\n            _.forEach(fileNames, function (files) {\n                if (files.length > 1) {\n                    var displayPaths = ViewUtils.getDirNamesForDuplicateFiles(files);\n                    files.forEach(function (file, i) {\n                        file.subDirStr = displayPaths[i];\n                    });\n                }\n            });\n\n            return files;\n        }\n\n        function _onHostEditorScroll() {\n            newRuleButton.closeDropdown();\n        }\n\n        CSSUtils.findMatchingRules(selectorName, hostEditor.document)\n            .done(function (rules) {\n                var inlineEditorDeferred = new $.Deferred();\n                cssInlineEditor = new MultiRangeInlineEditor.MultiRangeInlineEditor(CSSUtils.consolidateRules(rules),\n                                                                                    _getNoRulesMsg, CSSUtils.getRangeSelectors,\n                                                                                    _fileComparator);\n                cssInlineEditor.load(hostEditor);\n                cssInlineEditor.$htmlContent\n                    .on(\"focusin\", _updateCommands)\n                    .on(\"focusout\", _updateCommands);\n                cssInlineEditor.on(\"add\", function () {\n                    inlineEditorDeferred.resolve();\n                });\n                cssInlineEditor.on(\"close\", function () {\n                    newRuleButton.closeDropdown();\n                    hostEditor.off(\"scroll\", _onHostEditorScroll);\n                });\n\n                var $header = $(\".inline-editor-header\", cssInlineEditor.$htmlContent);\n                newRuleButton = new DropdownButton(Strings.BUTTON_NEW_RULE, [], _stylesheetListRenderer); // actual item list populated later, below\n                newRuleButton.$button.addClass(\"disabled\");  // disabled until list is known\n                newRuleButton.$button.addClass(\"btn-mini stylesheet-button\");\n                $header.append(newRuleButton.$button);\n                _newRuleHandlers.push({inlineEditor: cssInlineEditor, handler: _handleNewRuleClick});\n\n                hostEditor.on(\"scroll\", _onHostEditorScroll);\n\n                result.resolve(cssInlineEditor);\n\n\n                // Now that dialog has been built, collect list of stylesheets\n                var stylesheetsPromise = _getCSSFilesInProject();\n\n                // After both the stylesheets are loaded and the inline editor has been added to the DOM,\n                // update the UI accordingly. (Those can happen in either order, so we need to wait for both.)\n                // Note that the stylesheetsPromise needs to be passed first in order for the fileInfos to be\n                // properly passed to the handler, since $.when() passes the results in order of the argument\n                // list.\n                $.when(stylesheetsPromise, inlineEditorDeferred.promise())\n                    .done(function (fileInfos) {\n                        cssFileInfos = _prepFileList(fileInfos);\n\n                        // \"New Rule\" button is disabled by default and gets enabled\n                        // here if there are any stylesheets in project\n                        if (cssFileInfos.length > 0) {\n                            newRuleButton.$button.removeClass(\"disabled\");\n                            if (!rules.length) {\n                                // Force focus to the button so the user can create a new rule from the keyboard.\n                                newRuleButton.$button.focus();\n                            }\n\n                            if (cssFileInfos.length === 1) {\n                                // Make it look & feel like a plain button in this case\n                                newRuleButton.$button.removeClass(\"btn-dropdown\");\n                                newRuleButton.$button.on(\"click\", _handleNewRuleClick);\n                            } else {\n                                // Fill out remaining dropdown attributes otherwise\n                                newRuleButton.items = cssFileInfos;\n                                newRuleButton.on(\"select\", _onDropdownSelect);\n                            }\n                        }\n\n                        _updateCommands();\n                    });\n            })\n            .fail(function (error) {\n                console.warn(\"Error in findMatchingRules()\", error);\n                result.reject();\n            });\n\n        return result.promise();\n    }\n\n    EditorManager.registerInlineEditProvider(htmlToCSSProvider);\n\n    _newRuleCmd = CommandManager.register(Strings.CMD_CSS_QUICK_EDIT_NEW_RULE, Commands.CSS_QUICK_EDIT_NEW_RULE, _handleNewRule);\n    _newRuleCmd.setEnabled(false);\n});\n"],"file":"CSSInlineEditor.js"}
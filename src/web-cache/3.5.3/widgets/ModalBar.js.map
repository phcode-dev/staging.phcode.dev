{"version":3,"sources":["widgets/ModalBar.js"],"names":["define","require","exports","module","MainViewManager","EventDispatcher","KeyEvent","AnimationUtils","WorkspaceManager","ModalBar","template","autoClose","animate","undefined","this","_handleKeydown","bind","_handleFocusChange","_$root","$","html","insertBefore","addClass","window","getComputedStyle","get","getPropertyValue","removeClass","focusActivePane","_autoClose","on","document","body","addEventListener","$firstInput","first","length","focus","cacheScrollState","ALL_PANES","recomputeLayout","restoreAdjustedScrollState","height","makeEventDispatcher","prototype","isLockedOpen","CLOSE_ESCAPE","CLOSE_BLUR","CLOSE_API","outerHeight","prepareClose","restoreScrollPos","top","css","barHeight","close","_reason","result","Deferred","self","doRemove","remove","resolve","hasClass","removeEventListener","trigger","animateUsingClass","done","promise","e","keyCode","DOM_VK_ESCAPE","stopPropagation","preventDefault","effectiveElem","target","data","contains","getRoot"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * A \"modal bar\" component. This is a lightweight replacement for modal dialogs that\n * appears at the top of the editor area for operations like Find and Quick Open.\n */\ndefine(function (require, exports, module) {\n\n\n    var MainViewManager  = require(\"view/MainViewManager\"),\n        EventDispatcher  = require(\"utils/EventDispatcher\"),\n        KeyEvent         = require(\"utils/KeyEvent\"),\n        AnimationUtils   = require(\"utils/AnimationUtils\"),\n        WorkspaceManager = require(\"view/WorkspaceManager\");\n\n    /**\n     * Creates a modal bar whose contents are the given template.\n     *\n     * Dispatches one event:\n     * - close - When the bar is closed, either via close() or via autoClose. After this event, the\n     *     bar may remain visible and in the DOM while its closing animation is playing. However,\n     *     by the time \"close\" is fired, the bar has been \"popped out\" of the layout and the\n     *     editor scroll position has already been restored.\n     *     Second argument is the reason for closing (one of ModalBar.CLOSE_*).\n     *     Third argument is the Promise that close() will be returning.\n     *\n     * @constructor\n     *\n     * @param {string} template The HTML contents of the modal bar.\n     * @param {boolean} autoClose If true, then close the dialog if the user hits Esc\n     *      or if the bar loses focus.\n     * @param {boolean} animate If true (the default), animate the dialog closed, otherwise\n     *      close it immediately.\n     */\n    function ModalBar(template, autoClose, animate) {\n        if (animate === undefined) {\n            animate = true;\n        }\n\n        this._handleKeydown = this._handleKeydown.bind(this);\n        this._handleFocusChange = this._handleFocusChange.bind(this);\n\n        this._$root = $(\"<div class='modal-bar'/>\")\n            .html(template)\n            .insertBefore(\"#editor-holder\");\n\n        if (animate) {\n            this._$root.addClass(\"popout offscreen\");\n            // Forcing the renderer to do a layout, which will cause it to apply the transform for the \"offscreen\"\n            // class, so it will animate when you remove the class.\n            window.getComputedStyle(this._$root.get(0)).getPropertyValue(\"top\");\n            this._$root.removeClass(\"popout offscreen\");\n        }\n\n        // If something *other* than an editor (like another modal bar) has focus, set the focus\n        // to the editor here, before opening up the new modal bar. This ensures that the old\n        // focused item has time to react and close before the new modal bar is opened.\n        // See bugs #4287 and #3424\n        MainViewManager.focusActivePane();\n\n        if (autoClose) {\n            this._autoClose = true;\n            this._$root.on(\"keydown\", this._handleKeydown);\n            window.document.body.addEventListener(\"focusin\", this._handleFocusChange, true);\n\n            // Set focus to the first input field, or the first button if there is no input field.\n            // TODO: remove this logic?\n            var $firstInput = $(\"input[type='text']\", this._$root).first();\n            if ($firstInput.length > 0) {\n                $firstInput.focus();\n            } else {\n                $(\"button\", this._$root).first().focus();\n            }\n        }\n\n        // Preserve scroll position of the current full editor across the editor refresh, adjusting for the\n        // height of the modal bar so the code doesn't appear to shift if possible.\n        MainViewManager.cacheScrollState(MainViewManager.ALL_PANES);\n        WorkspaceManager.recomputeLayout();  // changes available ht for editor area\n        MainViewManager.restoreAdjustedScrollState(MainViewManager.ALL_PANES, this.height());\n    }\n    EventDispatcher.makeEventDispatcher(ModalBar.prototype);\n\n    /**\n     * A jQuery object containing the root node of the ModalBar.\n     */\n    ModalBar.prototype._$root = null;\n\n    /**\n     * True if this ModalBar is set to autoclose.\n     */\n    ModalBar.prototype._autoClose = false;\n\n    /**\n     * Allows client code to block autoClose from closing the ModalBar: if set, this function is called whenever\n     * autoClose would normally close the ModalBar. Returning true prevents the close from occurring. Programmatically\n     * calling close() will still close the bar, however.\n     * @type {?function():boolean}\n     */\n    ModalBar.prototype.isLockedOpen = null;\n\n    ModalBar.CLOSE_ESCAPE = \"escape\";\n    ModalBar.CLOSE_BLUR = \"blur\";\n    ModalBar.CLOSE_API = \"api\";\n\n    /**\n     * @return {number} Height of the modal bar in pixels, if open.\n     */\n    ModalBar.prototype.height = function () {\n        return this._$root.outerHeight();\n    };\n\n    /**\n     * Prepares the ModalBar for closing by popping it out of the main flow and resizing/\n     * rescrolling the Editor to maintain its current apparent code position. Useful if\n     * you want to do that as a separate operation from actually animating the ModalBar\n     * closed and removing it (for example, if you need to switch full editors in between).\n     * If you don't call this explicitly, it will get called at the beginning of `close()`.\n     *\n     * @param {boolean=} restoreScrollPos If true (the default), adjust the scroll position\n     *     of the editor to account for the ModalBar disappearing. If not set, the caller\n     *     should do it immediately on return of this function (before the animation completes),\n     *     because the editor will already have been resized.\n     */\n    ModalBar.prototype.prepareClose = function (restoreScrollPos) {\n        if (restoreScrollPos === undefined) {\n            restoreScrollPos = true;\n        }\n\n        this._$root.addClass(\"popout\");\n\n        // Since the modal bar has now an absolute position relative to the editor holder,\n        // when there are html menus we need to adjust the top position\n\n        var top = $(\"#titlebar\").outerHeight();\n        this._$root.css(\"top\", top + \"px\");\n\n\n        // Preserve scroll position of all visible views\n        //  adjusting for the height of the modal bar so the code doesn't appear to shift if possible.\n        var barHeight = this.height();\n        if (restoreScrollPos) {\n            MainViewManager.cacheScrollState(MainViewManager.ALL_PANES);\n        }\n        WorkspaceManager.recomputeLayout();  // changes available ht for editor area\n        // restore scroll position of all views\n        if (restoreScrollPos) {\n            MainViewManager.restoreAdjustedScrollState(MainViewManager.ALL_PANES, -barHeight);\n        }\n    };\n\n    /**\n     * Closes the modal bar and returns focus to the active editor. Returns a promise that is\n     * resolved when the bar is fully closed and the container is removed from the DOM.\n     * @param {boolean=} restoreScrollPos If true (the default), adjust the scroll position\n     *     of the editor to account for the ModalBar disappearing. If not set, the caller\n     *     should do it immediately on return of this function (before the animation completes),\n     *     because the editor will already have been resized. Note that this is ignored if\n     *     `prepareClose()` was already called (you need to pass the parameter to that\n     *     function if you call it first).\n     * @param {boolean=} animate If true (the default), animate the closing of the ModalBar,\n     *     otherwise close it immediately.\n     * @param {string=} _reason For internal use only.\n     * @return {$.Promise} promise resolved when close is finished\n     */\n    ModalBar.prototype.close = function (restoreScrollPos, animate, _reason) {\n        var result = new $.Deferred(),\n            self = this;\n\n        if (restoreScrollPos === undefined) {\n            restoreScrollPos = true;\n        }\n        if (animate === undefined) {\n            animate = true;\n        }\n\n        // If someone hasn't already called `prepareClose()` to pop the ModalBar out of the flow\n        // and resize the editor, then do that here.\n        if (!this._$root.hasClass(\"popout\")) {\n            this.prepareClose(restoreScrollPos);\n        }\n\n        if (this._autoClose) {\n            window.document.body.removeEventListener(\"focusin\", this._handleFocusChange, true);\n        }\n\n        this.trigger(\"close\", _reason, result);\n\n        function doRemove() {\n            self._$root.remove();\n            result.resolve();\n        }\n\n        if (animate) {\n            AnimationUtils.animateUsingClass(this._$root.get(0), \"offscreen\")\n                .done(doRemove);\n        } else {\n            doRemove();\n        }\n\n        MainViewManager.focusActivePane();\n\n        return result.promise();\n    };\n\n    /**\n     * If autoClose is set, close the bar when Escape is pressed\n     */\n    ModalBar.prototype._handleKeydown = function (e) {\n        if (e.keyCode === KeyEvent.DOM_VK_ESCAPE) {\n            e.stopPropagation();\n            e.preventDefault();\n            this.close(undefined, undefined, ModalBar.CLOSE_ESCAPE);\n        }\n    };\n\n    /**\n     * If autoClose is set, detects when something other than the modal bar is getting focus and\n     * dismisses the modal bar. DOM nodes with \"attached-to\" jQuery metadata referencing an element\n     * within the ModalBar are allowed to take focus without closing it.\n     */\n    ModalBar.prototype._handleFocusChange = function (e) {\n        if (this.isLockedOpen && this.isLockedOpen()) {\n            return;\n        }\n\n        var effectiveElem = $(e.target).data(\"attached-to\") || e.target;\n\n        if (!$.contains(this._$root.get(0), effectiveElem)) {\n            this.close(undefined, undefined, ModalBar.CLOSE_BLUR);\n        }\n    };\n\n    /**\n     * @return {jQueryObject} A jQuery object representing the root of the ModalBar.\n     */\n    ModalBar.prototype.getRoot = function () {\n        return this._$root;\n    };\n\n    exports.ModalBar = ModalBar;\n});\n"],"file":"ModalBar.js"}
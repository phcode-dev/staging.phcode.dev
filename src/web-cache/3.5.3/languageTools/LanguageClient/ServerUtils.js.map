{"version":3,"sources":["languageTools/LanguageClient/ServerUtils.js"],"names":["protocol","require","cp","fs","CommunicationTypes","NodeIPC","type","flag","StandardIO","Pipe","Socket","CLIENT_PROCESS_ID_FLAG","addCommunicationArgs","communication","processArgs","isRuntime","options","stdio","args","push","pipeName","generateRandomPipeName","pipeflag","toString","socketFlag","port","clientProcessIdFlag","process","pid","_getEnvironment","env","Object","assign","result","_createReaderAndWriteByCommunicationType","resp","retval","stderr","on","data","global","LanguageClientInfo","preferences","showServerLogsInConsole","console","error","String","stdout","info","reader","IPCMessageReader","writer","IPCMessageWriter","StreamMessageReader","StreamMessageWriter","stdin","_createReaderAndWriter","_isServerProcessValid","serverProcess","_startServerAndGetTransports","Promise","resolve","reject","protocolTransport","processFunc","spawn","fork","primaryArg","createClientPipeTransport","createClientSocketTransport","then","transportObj","onConnected","protocolObj","catch","_handleOtherRuntime","serverOptions","_getArguments","sOptions","execArgv","concat","module","_getOptions","cwd","undefined","lstatSync","isDirectory","e","__dirname","runtime","_handleNodeRuntime","silent","_handleServerFunction","func","_handleModules","_handleExecutable","command","detached","startServerAndGetConnectionArgs","exports"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2019 - present Adobe. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*global exports, process, Promise, __dirname, global*/\n/*eslint no-console: 0*/\n/*eslint no-fallthrough: 0*/\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\n(function () {\n\n\n    var protocol = require(\"vscode-languageserver-protocol\"),\n        cp = require(\"child_process\"),\n        fs = require(\"fs\");\n\n    var CommunicationTypes = {\n            NodeIPC: {\n                type: \"ipc\",\n                flag: \"--node-ipc\"\n            },\n            StandardIO: {\n                type: \"stdio\",\n                flag: \"--stdio\"\n            },\n            Pipe: {\n                type: \"pipe\",\n                flag: \"--pipe\"\n            },\n            Socket: {\n                type: \"socket\",\n                flag: \"--socket\"\n            }\n        },\n        CLIENT_PROCESS_ID_FLAG = \"--clientProcessId\";\n\n    function addCommunicationArgs(communication, processArgs, isRuntime) {\n        switch (communication) {\n        case CommunicationTypes.NodeIPC.type:\n            {\n                if (isRuntime) {\n                    processArgs.options.stdio = [null, null, null, 'ipc'];\n                    processArgs.args.push(CommunicationTypes.NodeIPC.flag);\n                } else {\n                    processArgs.args.push(CommunicationTypes.NodeIPC.flag);\n                }\n                break;\n            }\n        case CommunicationTypes.StandardIO.type:\n            {\n                processArgs.args.push(CommunicationTypes.StandardIO.flag);\n                break;\n            }\n        case CommunicationTypes.Pipe.type:\n            {\n                var pipeName = protocol.generateRandomPipeName(),\n                    pipeflag = CommunicationTypes.Pipe.flag + \"=\" + pipeName.toString();\n\n                processArgs.args.push(pipeflag);\n                processArgs.pipeName = pipeName;\n                break;\n            }\n        default:\n            {\n                if (communication && communication.type === CommunicationTypes.Socket.type) {\n                    var socketFlag = CommunicationTypes.Socket.flag + \"=\" + communication.port.toString();\n                    processArgs.args.push(socketFlag);\n                }\n            }\n        }\n\n        var clientProcessIdFlag = CLIENT_PROCESS_ID_FLAG + \"=\" + process.pid.toString();\n        processArgs.args.push(clientProcessIdFlag);\n    }\n\n    function _getEnvironment(env) {\n        if (!env) {\n            return process.env;\n        }\n\n        //Combine env vars\n        var result = Object.assign({}, process.env, env);\n        return result;\n    }\n\n    function _createReaderAndWriteByCommunicationType(resp, type) {\n        var retval = null;\n\n        switch (type) {\n        case CommunicationTypes.NodeIPC.type:\n            {\n                if (resp.process) {\n                    resp.process.stderr.on('data', function (data) {\n                        if (global.LanguageClientInfo.preferences.showServerLogsInConsole) {\n                            console.error('[Server logs @ stderr] \"%s\"', String(data));\n                        }\n                    });\n\n                    resp.process.stdout.on('data', function (data) {\n                        if (global.LanguageClientInfo.preferences.showServerLogsInConsole) {\n                            console.info('[Server logs @ stdout] \"%s\"', String(data));\n                        }\n                    });\n\n                    retval = {\n                        reader: new protocol.IPCMessageReader(resp.process),\n                        writer: new protocol.IPCMessageWriter(resp.process)\n                    };\n                }\n                break;\n            }\n        case CommunicationTypes.StandardIO.type:\n            {\n                if (resp.process) {\n                    resp.process.stderr.on('data', function (data) {\n                        if (global.LanguageClientInfo.preferences.showServerLogsInConsole) {\n                            console.error('[Server logs @ stderr] \"%s\"', String(data));\n                        }\n                    });\n\n                    retval = {\n                        reader: new protocol.StreamMessageReader(resp.process.stdout),\n                        writer: new protocol.StreamMessageWriter(resp.process.stdin)\n                    };\n                }\n                break;\n            }\n        case CommunicationTypes.Pipe.type:\n        case CommunicationTypes.Socket.type:\n            {\n                if (resp.reader && resp.writer && resp.process) {\n                    resp.process.stderr.on('data', function (data) {\n                        if (global.LanguageClientInfo.preferences.showServerLogsInConsole) {\n                            console.error('[Server logs @ stderr] \"%s\"', String(data));\n                        }\n                    });\n\n                    resp.process.stdout.on('data', function (data) {\n                        if (global.LanguageClientInfo.preferences.showServerLogsInConsole) {\n                            console.info('[Server logs @ stdout] \"%s\"', String(data));\n                        }\n                    });\n\n                    retval = {\n                        reader: resp.reader,\n                        writer: resp.writer\n                    };\n                }\n            }\n        }\n\n        return retval;\n    }\n\n    function _createReaderAndWriter(resp) {\n        var retval = null;\n\n        if (!resp) {\n            return retval;\n        }\n\n        if (resp.reader && resp.writer) {\n            retval = {\n                reader: resp.reader,\n                writer: resp.writer\n            };\n        } else if (resp.process) {\n            retval = {\n                reader: new protocol.StreamMessageReader(resp.process.stdout),\n                writer: new protocol.StreamMessageWriter(resp.process.stdin)\n            };\n\n            resp.process.stderr.on('data', function (data) {\n                if (global.LanguageClientInfo.preferences.showServerLogsInConsole) {\n                    console.error('[Server logs @ stderr] \"%s\"', String(data));\n                }\n            });\n        }\n\n        return retval;\n    }\n\n    function _isServerProcessValid(serverProcess) {\n        if (!serverProcess || !serverProcess.pid) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function _startServerAndGetTransports(communication, processArgs, isRuntime) {\n        return new Promise(function (resolve, reject) {\n            var serverProcess = null,\n                result = null,\n                protocolTransport = null,\n                type = typeof communication === \"object\" ? communication.type : communication;\n\n            var processFunc = isRuntime ? cp.spawn : cp.fork;\n\n            switch (type) {\n            case CommunicationTypes.NodeIPC.type:\n            case CommunicationTypes.StandardIO.type:\n                {\n                    serverProcess = processFunc(processArgs.primaryArg, processArgs.args, processArgs.options);\n                    if (_isServerProcessValid(serverProcess)) {\n                        result = _createReaderAndWriteByCommunicationType({\n                            process: serverProcess\n                        }, type);\n\n                        resolve(result);\n                    } else {\n                        reject(null);\n                    }\n                    break;\n                }\n            case CommunicationTypes.Pipe.type:\n                {\n                    protocolTransport = protocol.createClientPipeTransport(processArgs.pipeName);\n                }\n            case CommunicationTypes.Socket.type:\n                {\n                    if (communication && communication.type === CommunicationTypes.Socket.type) {\n                        protocolTransport = protocol.createClientSocketTransport(communication.port);\n                    }\n\n                    if (!protocolTransport) {\n                        reject(\"Invalid Communications Object. Can't create connection with server\");\n                        return;\n                    }\n\n                    protocolTransport.then(function (transportObj) {\n                        serverProcess = processFunc(processArgs.primaryArg, processArgs.args, processArgs.options);\n                        if (_isServerProcessValid(serverProcess)) {\n                            transportObj.onConnected().then(function (protocolObj) {\n                                result = _createReaderAndWriteByCommunicationType({\n                                    process: serverProcess,\n                                    reader: protocolObj[0],\n                                    writer: protocolObj[1]\n                                }, type);\n\n                                resolve(result);\n                            }).catch(reject);\n                        }\n                    }).catch(reject);\n                }\n            }\n        });\n    }\n\n    function _handleOtherRuntime(serverOptions) {\n        function _getArguments(sOptions) {\n            var args = [];\n\n            if (sOptions.options && sOptions.options.execArgv) {\n                args = args.concat(sOptions.options.execArgv);\n            }\n\n            args.push(sOptions.module);\n            if (sOptions.args) {\n                args = args.concat(sOptions.args);\n            }\n\n            return args;\n        }\n\n        function _getOptions(sOptions) {\n            var cwd = undefined,\n                env = undefined;\n\n            if (sOptions.options) {\n                if (sOptions.options.cwd) {\n                    try {\n                        if (fs.lstatSync(sOptions.options.cwd).isDirectory(sOptions.options.cwd)) {\n                            cwd = sOptions.options.cwd;\n                        }\n                    } catch (e) {}\n                }\n\n                cwd = cwd || __dirname;\n                if (sOptions.options.env) {\n                    env = sOptions.options.env;\n                }\n            }\n\n            var options = {\n                cwd: cwd,\n                env: _getEnvironment(env)\n            };\n\n            return options;\n        }\n\n        var communication = serverOptions.communication || CommunicationTypes.StandardIO.type,\n            args = _getArguments(serverOptions),\n            options = _getOptions(serverOptions),\n            processArgs = {\n                args: args,\n                options: options,\n                primaryArg: serverOptions.runtime\n            };\n\n        addCommunicationArgs(communication, processArgs, true);\n        return _startServerAndGetTransports(communication, processArgs, true);\n    }\n\n    function _handleNodeRuntime(serverOptions) {\n        function _getArguments(sOptions) {\n            var args = [];\n\n            if (sOptions.args) {\n                args = args.concat(sOptions.args);\n            }\n\n            return args;\n        }\n\n        function _getOptions(sOptions) {\n            var cwd = undefined;\n\n            if (sOptions.options) {\n                if (sOptions.options.cwd) {\n                    try {\n                        if (fs.lstatSync(sOptions.options.cwd).isDirectory(sOptions.options.cwd)) {\n                            cwd = sOptions.options.cwd;\n                        }\n                    } catch (e) {}\n                }\n                cwd = cwd || __dirname;\n            }\n\n            var options = Object.assign({}, sOptions.options);\n            options.cwd = cwd,\n                options.execArgv = options.execArgv || [];\n            options.silent = true;\n\n            return options;\n        }\n\n        var communication = serverOptions.communication || CommunicationTypes.StandardIO.type,\n            args = _getArguments(serverOptions),\n            options = _getOptions(serverOptions),\n            processArgs = {\n                args: args,\n                options: options,\n                primaryArg: serverOptions.module\n            };\n\n        addCommunicationArgs(communication, processArgs, false);\n        return _startServerAndGetTransports(communication, processArgs, false);\n    }\n\n\n    function _handleServerFunction(func) {\n        return func().then(function (resp) {\n            var result = _createReaderAndWriter(resp);\n\n            return result;\n        });\n    }\n\n    function _handleModules(serverOptions) {\n        if (serverOptions.runtime) {\n            return _handleOtherRuntime(serverOptions);\n        }\n        return _handleNodeRuntime(serverOptions);\n\n    }\n\n    function _handleExecutable(serverOptions) {\n        return new Promise(function (resolve, reject) {\n            var command = serverOptions.command,\n                args = serverOptions.args,\n                options = Object.assign({}, serverOptions.options);\n\n            var serverProcess = cp.spawn(command, args, options);\n            if (!serverProcess || !serverProcess.pid) {\n                reject(\"Failed to launch server using command :\", command);\n            }\n\n            var result = _createReaderAndWriter({\n                process: serverProcess,\n                detached: !!options.detached\n            });\n\n            if (result) {\n                resolve(result);\n            } else {\n                reject(result);\n            }\n        });\n    }\n\n    function startServerAndGetConnectionArgs(serverOptions) {\n        if (typeof serverOptions === \"function\") {\n            return _handleServerFunction(serverOptions);\n        } else if (typeof serverOptions === \"object\") {\n            if (serverOptions.module) {\n                return _handleModules(serverOptions);\n            } else if (serverOptions.command) {\n                return _handleExecutable(serverOptions);\n            }\n        }\n\n        return Promise.reject(null);\n    }\n\n\n    exports.startServerAndGetConnectionArgs = startServerAndGetConnectionArgs;\n}());\n"],"file":"ServerUtils.js"}
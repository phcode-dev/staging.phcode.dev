{"version":3,"sources":["language/HTMLTokenizer.js"],"names":["define","require","exports","module","i","TEXT","BEFORE_TAG_NAME","IN_TAG_NAME","BEFORE_CLOSING_TAG_NAME","IN_CLOSING_TAG_NAME","AFTER_CLOSING_TAG_NAME","AFTER_SELFCLOSE_SLASH","BEFORE_ATTRIBUTE_NAME","AFTER_QUOTED_ATTRIBUTE_VALUE","IN_ATTRIBUTE_NAME","AFTER_ATTRIBUTE_NAME","BEFORE_ATTRIBUTE_VALUE","IN_ATTRIBUTE_VALUE_DOUBLE_QUOTES","IN_ATTRIBUTE_VALUE_SINGLE_QUOTES","IN_ATTRIBUTE_VALUE_NO_QUOTES","BEFORE_DECLARATION","IN_DECLARATION","IN_PROCESSING_INSTRUCTION","BEFORE_COMMENT","IN_COMMENT","AFTER_COMMENT_1","AFTER_COMMENT_2","BEFORE_CDATA_1","BEFORE_CDATA_2","BEFORE_CDATA_3","BEFORE_CDATA_4","BEFORE_CDATA_5","BEFORE_CDATA_6","IN_CDATA","AFTER_CDATA_1","AFTER_CDATA_2","BEFORE_SPECIAL","BEFORE_SPECIAL_END","BEFORE_SCRIPT_1","BEFORE_SCRIPT_2","BEFORE_SCRIPT_3","BEFORE_SCRIPT_4","BEFORE_SCRIPT_5","AFTER_SCRIPT_1","AFTER_SCRIPT_2","AFTER_SCRIPT_3","AFTER_SCRIPT_4","AFTER_SCRIPT_5","BEFORE_STYLE_1","BEFORE_STYLE_2","BEFORE_STYLE_3","BEFORE_STYLE_4","AFTER_STYLE_1","AFTER_STYLE_2","AFTER_STYLE_3","AFTER_STYLE_4","isWhitespace","c","isLegalInTagName","test","isLegalInAttributeName","isLegalInUnquotedAttributeValue","_clonePos","pos","offset","line","ch","Tokenizer","text","this","_state","_buffer","_sectionStart","_sectionStartPos","_index","_indexPos","_special","_token","_nextToken","prototype","nextToken","result","length","charAt","_emitTokenIfNonempty","_startSection","_emitSpecialToken","_emitToken","console","error","_setToken","type","index","indexPos","undefined","token","contents","substring","start","end","startPos","endPos"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// A simple HTML tokenizer, originally adapted from https://github.com/fb55/htmlparser2\n// (MIT-licensed), but with significant customizations for use in HTML live development.\n\n/*jslint continue: true */\n\n/*unittests: HTML Tokenizer*/\n\ndefine(function (require, exports, module) {\n\n\n    var i = 0,\n\n        TEXT = i++,\n        BEFORE_TAG_NAME = i++, //after <\n        IN_TAG_NAME = i++,\n        BEFORE_CLOSING_TAG_NAME = i++,\n        IN_CLOSING_TAG_NAME = i++,\n        AFTER_CLOSING_TAG_NAME = i++,\n        AFTER_SELFCLOSE_SLASH = i++,\n\n        //attributes\n        BEFORE_ATTRIBUTE_NAME = i++,\n        AFTER_QUOTED_ATTRIBUTE_VALUE = i++,\n        IN_ATTRIBUTE_NAME = i++,\n        AFTER_ATTRIBUTE_NAME = i++,\n        BEFORE_ATTRIBUTE_VALUE = i++,\n        IN_ATTRIBUTE_VALUE_DOUBLE_QUOTES = i++, // \"\n        IN_ATTRIBUTE_VALUE_SINGLE_QUOTES = i++, // '\n        IN_ATTRIBUTE_VALUE_NO_QUOTES = i++,\n\n        //declarations\n        BEFORE_DECLARATION = i++, // !\n        IN_DECLARATION = i++,\n\n        //processing instructions\n        IN_PROCESSING_INSTRUCTION = i++, // ?\n\n        //comments\n        BEFORE_COMMENT = i++,\n        IN_COMMENT = i++,\n        AFTER_COMMENT_1 = i++,\n        AFTER_COMMENT_2 = i++,\n\n        //cdata\n        BEFORE_CDATA_1 = i++, // [\n        BEFORE_CDATA_2 = i++, // C\n        BEFORE_CDATA_3 = i++, // D\n        BEFORE_CDATA_4 = i++, // A\n        BEFORE_CDATA_5 = i++, // T\n        BEFORE_CDATA_6 = i++, // A\n        IN_CDATA = i++, // [\n        AFTER_CDATA_1 = i++, // ]\n        AFTER_CDATA_2 = i++, // ]\n\n        //special tags\n        BEFORE_SPECIAL = i++, //S\n        BEFORE_SPECIAL_END = i++,   //S\n\n        BEFORE_SCRIPT_1 = i++, //C\n        BEFORE_SCRIPT_2 = i++, //R\n        BEFORE_SCRIPT_3 = i++, //I\n        BEFORE_SCRIPT_4 = i++, //P\n        BEFORE_SCRIPT_5 = i++, //T\n        AFTER_SCRIPT_1 = i++, //C\n        AFTER_SCRIPT_2 = i++, //R\n        AFTER_SCRIPT_3 = i++, //I\n        AFTER_SCRIPT_4 = i++, //P\n        AFTER_SCRIPT_5 = i++, //T\n\n        BEFORE_STYLE_1 = i++, //T\n        BEFORE_STYLE_2 = i++, //Y\n        BEFORE_STYLE_3 = i++, //L\n        BEFORE_STYLE_4 = i++, //E\n        AFTER_STYLE_1 = i++, //T\n        AFTER_STYLE_2 = i++, //Y\n        AFTER_STYLE_3 = i++, //L\n        AFTER_STYLE_4 = i++; //E\n\n    /**\n     * @private\n     * @param {string} c the character to test\n     * @return {boolean} true if c is whitespace\n     */\n    function isWhitespace(c) {\n        return c === \" \" || c === \"\\t\" || c === \"\\r\" || c === \"\\n\";\n    }\n\n    /**\n     * @private\n     * @param {string} c the character to test\n     * @return {boolean} true if c is legal in an HTML tag name\n     */\n    function isLegalInTagName(c) {\n        // We allow \"-\" in tag names since they're popular in Angular custom tag names\n        // and will be legal in the web components spec.\n        return (/[A-Za-z0-9\\-]/).test(c);\n    }\n\n    /**\n     * @private\n     * @param {string} c the character to test\n     * @return {boolean} true if c is legal in an HTML attribute name\n     */\n    function isLegalInAttributeName(c) {\n        return c !== '\"' && c !== \"'\" && c !== \"<\" && c !== \"=\";\n    }\n\n    /**\n     * @private\n     * @param {string} c the character to test\n     * @return {boolean} true if c is legal in an unquoted attribute value\n     */\n    function isLegalInUnquotedAttributeValue(c) {\n        return c !== \"<\" && c !== \"=\";\n    }\n\n    function _clonePos(pos, offset) {\n        return pos ? { line: pos.line, ch: pos.ch + (offset || 0)} : null;\n    }\n\n    /**\n     * A simple HTML tokenizer. See the description of nextToken() for usage details.\n     * @constructor\n     * @param {string} text The HTML document to tokenize.\n     */\n    function Tokenizer(text) {\n        this._state = TEXT;\n        this._buffer = text;\n        this._sectionStart = 0;\n        this._sectionStartPos = {line: 0, ch: 0};\n        this._index = 0;\n        this._indexPos = {line: 0, ch: 0};\n        this._special = 0; // 1 for script, 2 for style\n        this._token = null;\n        this._nextToken = null;\n    }\n\n    /**\n     * Returns the next token in the HTML document, or null if we're at the end of the document.\n     * @return {?{type: string, contents: string, start: number, end: number}} token The next token, with the following fields:\n     *    type: The type of token, one of:\n     *          \"error\" - invalid syntax was found, tokenization aborted. Calling nextToken() again will produce undefined results.\n     *          \"text\" - contents contains the text\n     *          \"opentagname\" - an open tag was started; contents contains the tag name\n     *          \"attribname\" - an attribute was encountered; contents contains the attribute name\n     *          \"attribvalue\" - the value for the previous attribname was encountered; contents contains the (unquoted) value\n     *              (Note that attributes like checked and disabled might not have values.)\n     *          \"opentagend\" - the end of an open tag was encountered; contents is unspecified\n     *          \"selfclosingtag\" - a \"/>\" was encountered indicating that a void element was self-closed; contents is unspecified\n     *              (Note that this is optional in HTML; void elements like <img> will end with \"opentagend\", not \"selfclosingtag\")\n     *          \"closetag\" - a close tag was encountered; contents contains the tag name\n     *          \"comment\" - a comment was encountered; contents contains the body of the comment\n     *          \"cdata\" - a CDATA block was encountered; contents contains the text inside the block\n     *    contents: the contents of the token, as specified above. Note that \"opentagend\" and \"selfclosingtag\" really specify positions,\n     *          not tokens, and so have no contents.\n     *    start: the start index of the token contents within the text, or -1 for \"opentagend\" and \"selfclosingtag\"\n     *    end: the end index of the token contents within the text, or the position of the boundary for \"opentagend\" and \"selfclosingtag\"\n     */\n    Tokenizer.prototype.nextToken = function () {\n        this._token = null;\n\n        if (this._nextToken) {\n            var result = this._nextToken;\n            this._nextToken = null;\n            return result;\n        }\n\n        while (this._index < this._buffer.length && !this._token) {\n            var c = this._buffer.charAt(this._index);\n            if (this._state === TEXT) {\n                if (c === \"<\") {\n                    this._emitTokenIfNonempty(\"text\");\n                    this._state = BEFORE_TAG_NAME;\n                    this._startSection();\n                }\n            } else if (this._state === BEFORE_TAG_NAME) {\n                if (c === \"/\") {\n                    this._state = BEFORE_CLOSING_TAG_NAME;\n                } else if (c === \">\" || this._special > 0) {\n                    this._state = TEXT;\n                } else {\n                    if (c === \"!\") {\n                        this._state = BEFORE_DECLARATION;\n                        this._startSection(1);\n                    } else if (c === \"?\") {\n                        this._state = IN_PROCESSING_INSTRUCTION;\n                        this._startSection(1);\n                    } else if (c === \"s\" || c === \"S\") {\n                        this._state = BEFORE_SPECIAL;\n                        this._startSection();\n                    } else if (!isLegalInTagName(c)) {\n                        this._emitSpecialToken(\"error\");\n                        break;\n                    } else if (!isWhitespace(c)) {\n                        this._state = IN_TAG_NAME;\n                        this._startSection();\n                    }\n                }\n            } else if (this._state === IN_TAG_NAME) {\n                if (c === \"/\") {\n                    this._emitToken(\"opentagname\");\n                    this._emitSpecialToken(\"selfclosingtag\", this._index + 2, _clonePos(this._indexPos, 2));\n                    this._state = AFTER_SELFCLOSE_SLASH;\n                } else if (c === \">\") {\n                    this._emitToken(\"opentagname\");\n                    this._emitSpecialToken(\"opentagend\", this._index + 1, _clonePos(this._indexPos, 1));\n                    this._state = TEXT;\n                    this._startSection(1);\n                } else if (isWhitespace(c)) {\n                    this._emitToken(\"opentagname\");\n                    this._state = BEFORE_ATTRIBUTE_NAME;\n                } else if (!isLegalInTagName(c)) {\n                    this._emitSpecialToken(\"error\");\n                    break;\n                }\n            } else if (this._state === BEFORE_CLOSING_TAG_NAME) {\n                if (c === \">\") {\n                    this._state = TEXT;\n                } else if (this._special > 0) {\n                    if (c === \"s\" || c === \"S\") {\n                        this._state = BEFORE_SPECIAL_END;\n                    } else {\n                        this._state = TEXT;\n                        continue;\n                    }\n                } else if (!isLegalInTagName(c)) {\n                    this._emitSpecialToken(\"error\");\n                    break;\n                } else if (!isWhitespace(c)) {\n                    this._state = IN_CLOSING_TAG_NAME;\n                    this._startSection();\n                }\n            } else if (this._state === IN_CLOSING_TAG_NAME) {\n                if (c === \">\") {\n                    this._emitToken(\"closetag\");\n                    this._state = TEXT;\n                    this._startSection(1);\n                    this._special = 0;\n                } else if (isWhitespace(c)) {\n                    this._emitToken(\"closetag\");\n                    this._state = AFTER_CLOSING_TAG_NAME;\n                    this._special = 0;\n                } else if (!isLegalInTagName(c)) {\n                    this._emitSpecialToken(\"error\");\n                    break;\n                }\n            } else if (this._state === AFTER_CLOSING_TAG_NAME) {\n                if (c === \">\") {\n                    this._state = TEXT;\n                    this._startSection(1);\n                } else if (!isWhitespace(c)) {\n                    // There must be only whitespace in the closing tag after the name until the \">\".\n                    this._emitSpecialToken(\"error\");\n                    break;\n                }\n            } else if (this._state === AFTER_SELFCLOSE_SLASH) {\n                // Nothing (even whitespace) can come between the / and > of a self-close.\n                if (c === \">\") {\n                    this._state = TEXT;\n                    this._startSection(1);\n                } else {\n                    this._emitSpecialToken(\"error\");\n                    break;\n                }\n\n            /*\n            *\tattributes\n            */\n            } else if (this._state === BEFORE_ATTRIBUTE_NAME) {\n                if (c === \">\") {\n                    this._state = TEXT;\n                    this._emitSpecialToken(\"opentagend\", this._index + 1, _clonePos(this._indexPos, 1));\n                    this._startSection(1);\n                } else if (c === \"/\") {\n                    this._emitSpecialToken(\"selfclosingtag\", this._index + 2, _clonePos(this._indexPos, 2));\n                    this._state = AFTER_SELFCLOSE_SLASH;\n                } else if (!isLegalInAttributeName(c)) {\n                    this._emitSpecialToken(\"error\");\n                    break;\n                } else if (!isWhitespace(c)) {\n                    this._state = IN_ATTRIBUTE_NAME;\n                    this._startSection();\n                }\n            } else if (this._state === IN_ATTRIBUTE_NAME) {\n                if (c === \"=\") {\n                    this._emitTokenIfNonempty(\"attribname\");\n                    this._state = BEFORE_ATTRIBUTE_VALUE;\n                } else if (isWhitespace(c)) {\n                    this._emitTokenIfNonempty(\"attribname\");\n                    this._state = AFTER_ATTRIBUTE_NAME;\n                } else if (c === \"/\" || c === \">\") {\n                    this._emitTokenIfNonempty(\"attribname\");\n                    this._state = BEFORE_ATTRIBUTE_NAME;\n                    continue;\n                } else if (!isLegalInAttributeName(c)) {\n                    this._emitSpecialToken(\"error\");\n                    break;\n                }\n            } else if (this._state === AFTER_ATTRIBUTE_NAME) {\n                if (c === \"=\") {\n                    this._state = BEFORE_ATTRIBUTE_VALUE;\n                } else if (c === \"/\" || c === \">\") {\n                    this._state = BEFORE_ATTRIBUTE_NAME;\n                    continue;\n                } else if (!isLegalInAttributeName(c)) {\n                    this._emitSpecialToken(\"error\");\n                    break;\n                } else if (!isWhitespace(c)) {\n                    this._state = IN_ATTRIBUTE_NAME;\n                    this._startSection();\n                }\n            } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {\n                if (c === \"\\\"\") {\n                    this._state = IN_ATTRIBUTE_VALUE_DOUBLE_QUOTES;\n                    this._startSection(1);\n                } else if (c === \"'\") {\n                    this._state = IN_ATTRIBUTE_VALUE_SINGLE_QUOTES;\n                    this._startSection(1);\n                } else if (!isLegalInUnquotedAttributeValue(c)) {\n                    this._emitSpecialToken(\"error\");\n                    break;\n                } else if (!isWhitespace(c)) {\n                    this._state = IN_ATTRIBUTE_VALUE_NO_QUOTES;\n                    this._startSection();\n                }\n            } else if (this._state === IN_ATTRIBUTE_VALUE_DOUBLE_QUOTES) {\n                if (c === \"\\\"\") {\n                    this._emitToken(\"attribvalue\");\n                    this._state = AFTER_QUOTED_ATTRIBUTE_VALUE;\n                }\n            } else if (this._state === IN_ATTRIBUTE_VALUE_SINGLE_QUOTES) {\n                if (c === \"'\") {\n                    this._state = AFTER_QUOTED_ATTRIBUTE_VALUE;\n                    this._emitToken(\"attribvalue\");\n                }\n            } else if (this._state === IN_ATTRIBUTE_VALUE_NO_QUOTES) {\n                if (c === \">\") {\n                    this._emitToken(\"attribvalue\");\n                    this._emitSpecialToken(\"opentagend\", this._index + 1, _clonePos(this._indexPos, 1));\n                    this._state = TEXT;\n                    this._startSection(1);\n                } else if (isWhitespace(c)) {\n                    this._emitToken(\"attribvalue\");\n                    this._state = BEFORE_ATTRIBUTE_NAME;\n                } else if (!isLegalInUnquotedAttributeValue(c)) {\n                    this._emitSpecialToken(\"error\");\n                    break;\n                }\n            } else if (this._state === AFTER_QUOTED_ATTRIBUTE_VALUE) {\n                // There must be at least one whitespace between the end of a quoted\n                // attribute value and the next attribute, if any.\n                if (c === \">\") {\n                    this._state = TEXT;\n                    this._emitSpecialToken(\"opentagend\", this._index + 1, _clonePos(this._indexPos, 1));\n                    this._startSection(1);\n                } else if (c === \"/\") {\n                    this._emitSpecialToken(\"selfclosingtag\", this._index + 2, _clonePos(this._indexPos, 2));\n                    this._state = AFTER_SELFCLOSE_SLASH;\n                } else if (isWhitespace(c)) {\n                    this._state = BEFORE_ATTRIBUTE_NAME;\n                } else {\n                    this._emitSpecialToken(\"error\");\n                    break;\n                }\n\n            /*\n            *\tdeclarations\n            */\n            } else if (this._state === BEFORE_DECLARATION) {\n                if (c === \"[\") {\n                    this._state = BEFORE_CDATA_1;\n                } else if (c === \"-\") {\n                    this._state = BEFORE_COMMENT;\n                } else {\n                    this._state = IN_DECLARATION;\n                }\n            } else if (this._state === IN_DECLARATION) {\n                if (c === \">\") {\n                    this._emitToken(\"declaration\");\n                    this._state = TEXT;\n                    this._startSection(1);\n                }\n\n\n            /*\n            *\tprocessing instructions\n            */\n            } else if (this._state === IN_PROCESSING_INSTRUCTION) {\n                if (c === \">\") {\n                    this._emitToken(\"processinginstruction\");\n                    this._state = TEXT;\n                    this._startSection(1);\n                }\n\n\n            /*\n            *\tcomments\n            */\n            } else if (this._state === BEFORE_COMMENT) {\n                if (c === \"-\") {\n                    this._state = IN_COMMENT;\n                    this._startSection(1);\n                } else {\n                    this._state = IN_DECLARATION;\n                }\n            } else if (this._state === IN_COMMENT) {\n                if (c === \"-\") {\n                    this._state = AFTER_COMMENT_1;\n                }\n            } else if (this._state === AFTER_COMMENT_1) {\n                if (c === \"-\") {\n                    this._state = AFTER_COMMENT_2;\n                } else {\n                    this._state = IN_COMMENT;\n                }\n            } else if (this._state === AFTER_COMMENT_2) {\n                if (c === \">\") {\n                    //remove 2 trailing chars\n                    // It should be okay to just decrement the char position by 2 because we know neither of the previous\n                    // characters is a newline.\n                    this._emitToken(\"comment\", this._index - 2, _clonePos(this._indexPos, -2));\n                    this._state = TEXT;\n                    this._startSection(1);\n                } else if (c !== \"-\") {\n                    this._state = IN_COMMENT;\n                }\n                // else: stay in AFTER_COMMENT_2 (`--->`)\n\n\n            /*\n            *\tcdata\n            */\n            } else if (this._state === BEFORE_CDATA_1) {\n                if (c === \"C\") {\n                    this._state = BEFORE_CDATA_2;\n                } else {\n                    this._state = IN_DECLARATION;\n                }\n            } else if (this._state === BEFORE_CDATA_2) {\n                if (c === \"D\") {\n                    this._state = BEFORE_CDATA_3;\n                } else {\n                    this._state = IN_DECLARATION;\n                }\n            } else if (this._state === BEFORE_CDATA_3) {\n                if (c === \"A\") {\n                    this._state = BEFORE_CDATA_4;\n                } else {\n                    this._state = IN_DECLARATION;\n                }\n            } else if (this._state === BEFORE_CDATA_4) {\n                if (c === \"T\") {\n                    this._state = BEFORE_CDATA_5;\n                } else {\n                    this._state = IN_DECLARATION;\n                }\n            } else if (this._state === BEFORE_CDATA_5) {\n                if (c === \"A\") {\n                    this._state = BEFORE_CDATA_6;\n                } else {\n                    this._state = IN_DECLARATION;\n                }\n            } else if (this._state === BEFORE_CDATA_6) {\n                if (c === \"[\") {\n                    this._state = IN_CDATA;\n                    this._startSection(1);\n                } else {\n                    this._state = IN_DECLARATION;\n                }\n            } else if (this._state === IN_CDATA) {\n                if (c === \"]\") {\n                    this._state = AFTER_CDATA_1;\n                }\n            } else if (this._state === AFTER_CDATA_1) {\n                if (c === \"]\") {\n                    this._state = AFTER_CDATA_2;\n                } else {\n                    this._state = IN_CDATA;\n                }\n            } else if (this._state === AFTER_CDATA_2) {\n                if (c === \">\") {\n                    //remove 2 trailing chars\n                    // It should be okay to just decrement the char position by 2 because we know neither of the previous\n                    // characters is a newline.\n                    this._emitToken(\"cdata\", this._index - 2, _clonePos(this._indexPos, -2));\n                    this._state = TEXT;\n                    this._startSection(1);\n                } else if (c !== \"]\") {\n                    this._state = IN_CDATA;\n                }\n                //else: stay in AFTER_CDATA_2 (`]]]>`)\n\n\n            /*\n            * special tags\n            */\n            } else if (this._state === BEFORE_SPECIAL) {\n                if (c === \"c\" || c === \"C\") {\n                    this._state = BEFORE_SCRIPT_1;\n                } else if (c === \"t\" || c === \"T\") {\n                    this._state = BEFORE_STYLE_1;\n                } else {\n                    this._state = IN_TAG_NAME;\n                    continue; //consume the token again\n                }\n            } else if (this._state === BEFORE_SPECIAL_END) {\n                if (this._special === 1 && (c === \"c\" || c === \"C\")) {\n                    this._state = AFTER_SCRIPT_1;\n                } else if (this._special === 2 && (c === \"t\" || c === \"T\")) {\n                    this._state = AFTER_STYLE_1;\n                } else {\n                    this._state = TEXT;\n                }\n\n\n            /*\n            * script\n            */\n            } else if (this._state === BEFORE_SCRIPT_1) {\n                if (c === \"r\" || c === \"R\") {\n                    this._state = BEFORE_SCRIPT_2;\n                } else {\n                    this._state = IN_TAG_NAME;\n                    continue; //consume the token again\n                }\n            } else if (this._state === BEFORE_SCRIPT_2) {\n                if (c === \"i\" || c === \"I\") {\n                    this._state = BEFORE_SCRIPT_3;\n                } else {\n                    this._state = IN_TAG_NAME;\n                    continue; //consume the token again\n                }\n            } else if (this._state === BEFORE_SCRIPT_3) {\n                if (c === \"p\" || c === \"P\") {\n                    this._state = BEFORE_SCRIPT_4;\n                } else {\n                    this._state = IN_TAG_NAME;\n                    continue; //consume the token again\n                }\n            } else if (this._state === BEFORE_SCRIPT_4) {\n                if (c === \"t\" || c === \"T\") {\n                    this._state = BEFORE_SCRIPT_5;\n                } else {\n                    this._state = IN_TAG_NAME;\n                    continue; //consume the token again\n                }\n            } else if (this._state === BEFORE_SCRIPT_5) {\n                if (c === \"/\" || c === \">\" || isWhitespace(c)) {\n                    this._special = 1;\n                }\n                this._state = IN_TAG_NAME;\n                continue; //consume the token again\n            } else if (this._state === AFTER_SCRIPT_1) {\n                if (c === \"r\" || c === \"R\") {\n                    this._state = AFTER_SCRIPT_2;\n                } else {\n                    this._state = TEXT;\n                }\n            } else if (this._state === AFTER_SCRIPT_2) {\n                if (c === \"i\" || c === \"I\") {\n                    this._state = AFTER_SCRIPT_3;\n                } else {\n                    this._state = TEXT;\n                }\n            } else if (this._state === AFTER_SCRIPT_3) {\n                if (c === \"p\" || c === \"P\") {\n                    this._state = AFTER_SCRIPT_4;\n                } else {\n                    this._state = TEXT;\n                }\n            } else if (this._state === AFTER_SCRIPT_4) {\n                if (c === \"t\" || c === \"T\") {\n                    this._state = AFTER_SCRIPT_5;\n                } else {\n                    this._state = TEXT;\n                }\n            } else if (this._state === AFTER_SCRIPT_5) {\n                if (c === \">\" || isWhitespace(c)) {\n                    this._state = IN_CLOSING_TAG_NAME;\n                    this._startSection(-6);\n                    continue; //reconsume the token\n                } else {\n                    this._state = TEXT;\n                }\n\n\n            /*\n            * style\n            */\n            } else if (this._state === BEFORE_STYLE_1) {\n                if (c === \"y\" || c === \"Y\") {\n                    this._state = BEFORE_STYLE_2;\n                } else {\n                    this._state = IN_TAG_NAME;\n                    continue; //consume the token again\n                }\n            } else if (this._state === BEFORE_STYLE_2) {\n                if (c === \"l\" || c === \"L\") {\n                    this._state = BEFORE_STYLE_3;\n                } else {\n                    this._state = IN_TAG_NAME;\n                    continue; //consume the token again\n                }\n            } else if (this._state === BEFORE_STYLE_3) {\n                if (c === \"e\" || c === \"E\") {\n                    this._state = BEFORE_STYLE_4;\n                } else {\n                    this._state = IN_TAG_NAME;\n                    continue; //consume the token again\n                }\n            } else if (this._state === BEFORE_STYLE_4) {\n                if (c === \"/\" || c === \">\" || isWhitespace(c)) {\n                    this._special = 2;\n                }\n                this._state = IN_TAG_NAME;\n                continue; //consume the token again\n            } else if (this._state === AFTER_STYLE_1) {\n                if (c === \"y\" || c === \"Y\") {\n                    this._state = AFTER_STYLE_2;\n                } else {\n                    this._state = TEXT;\n                }\n            } else if (this._state === AFTER_STYLE_2) {\n                if (c === \"l\" || c === \"L\") {\n                    this._state = AFTER_STYLE_3;\n                } else {\n                    this._state = TEXT;\n                }\n            } else if (this._state === AFTER_STYLE_3) {\n                if (c === \"e\" || c === \"E\") {\n                    this._state = AFTER_STYLE_4;\n                } else {\n                    this._state = TEXT;\n                }\n            } else if (this._state === AFTER_STYLE_4) {\n                if (c === \">\" || isWhitespace(c)) {\n                    this._state = IN_CLOSING_TAG_NAME;\n                    this._startSection(-5);\n                    continue; //reconsume the token\n                } else {\n                    this._state = TEXT;\n                }\n            } else {\n                console.error(\"HTMLTokenizer: Encountered unknown state\");\n                this._emitSpecialToken(\"error\");\n                break;\n            }\n\n            if (c === \"\\n\") {\n                this._indexPos.line++;\n                this._indexPos.ch = 0;\n            } else {\n                this._indexPos.ch++;\n            }\n            this._index++;\n        }\n\n        if (!this._token) {\n            if (this._state !== TEXT) {\n                // We hit EOF in the middle of processing something else.\n                this._emitSpecialToken(\"error\");\n            } else {\n                this._emitTokenIfNonempty(\"text\");\n                this._startSection();\n            }\n        }\n        return this._token;\n    };\n\n    Tokenizer.prototype._startSection = function (offset) {\n        offset = offset || 0;\n        this._sectionStart = this._index + offset;\n\n        // Normally it wouldn't be safe to assume that we can just add the offset to the\n        // character position, because there might be a newline, which would require us to\n        // move to the next line. However, in all the cases where this is called, we are\n        // adjusting for characters that we know are not newlines.\n        this._sectionStartPos = _clonePos(this._indexPos, offset);\n    };\n\n    /**\n     * @private\n     * Extract the portion of the buffer since _sectionStart and set it to be the next token we return\n     * from `nextToken()`. If there's already a _token, we stuff it in _nextToken instead.\n     * @param {string} type The token's type (see documentation for `nextToken()`)\n     * @param {number} index If specified, the index to use as the end of the token; uses this._index if not specified\n     */\n    Tokenizer.prototype._setToken = function (type, index, indexPos) {\n        if (index === undefined) {\n            index = this._index;\n        }\n        if (indexPos === undefined) {\n            indexPos = this._indexPos;\n        }\n        var token = {\n            type: type,\n            contents: this._sectionStart === -1 ? \"\" : this._buffer.substring(this._sectionStart, index),\n            start: this._sectionStart,\n            end: index,\n            startPos: _clonePos(this._sectionStartPos),\n            endPos: _clonePos(indexPos)\n        };\n        if (this._token) {\n            // Queue this token to be emitted next. In theory it would be more general to have\n            // an arbitrary-length queue, but currently we only ever emit at most two tokens in a\n            // single pass through the tokenization loop.\n            if (this._nextToken) {\n                console.error(\"HTMLTokenizer: Tried to emit more than two tokens in a single call\");\n            }\n            this._nextToken = token;\n        } else {\n            this._token = token;\n        }\n    };\n\n    /**\n     * @private\n     * Sets the token to be returned from `nextToken()` and resets the section start to an invalid value.\n     * this._sectionStart should be set to a valid value before the next call to one of the `_emit` methods.\n     * @param {string} type The token's type (see documentation for `nextToken()`)\n     * @param {number} index If specified, the index to use as the end of the token; uses this._index if not specified\n     */\n    Tokenizer.prototype._emitToken = function (type, index, indexPos) {\n        this._setToken(type, index, indexPos);\n        this._sectionStart = -1;\n        this._sectionStartPos = null;\n    };\n\n    /**\n     * @private\n     * Like `_emitToken()`, but used for special tokens that don't have real content (like opentagend and selfclosingtag).\n     * @param {string} type The token's type (see documentation for `nextToken()`)\n     * @param {number} index If specified, the index to use as the end of the token; uses this._index if not specified\n     */\n    Tokenizer.prototype._emitSpecialToken = function (type, index, indexPos) {\n        // Force the section start to be -1, since these tokens don't have meaningful content--they're\n        // just marking particular boundaries we care about (end of an open tag or a self-closing tag).\n        this._sectionStart = -1;\n        this._sectionStartPos = null;\n        this._emitToken(type, index, indexPos);\n    };\n\n    /**\n     * @private\n     * Like `_emitToken()`, but only emits a token if there is actually content in it. Note that this still\n     * resets this._sectionStart to an invalid value even if there is no content, so a new section must be\n     * started before the next `_emit`.\n     * @param {string} type The token's type (see documentation for `nextToken()`)\n     */\n    Tokenizer.prototype._emitTokenIfNonempty = function (type) {\n        if (this._index > this._sectionStart) {\n            this._setToken(type);\n        }\n        this._sectionStart = -1;\n        this._sectionStartPos = null;\n    };\n\n    exports.Tokenizer = Tokenizer;\n});\n"],"file":"HTMLTokenizer.js"}
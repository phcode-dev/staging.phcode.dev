{"version":3,"sources":["language/HTMLUtils.js"],"names":["define","require","exports","module","CodeMirror","TokenUtils","TAG_NAME","CLOSING_TAG","ATTR_NAME","ATTR_VALUE","tagPrefixedRegExp","_extractAttrVal","ctx","attrValue","token","string","startChar","charAt","endChar","length","offset","offsetInToken","foundEqualSign","match","val","substring","quoteChar","hasEndQuote","spaceIndex","indexOf","bracketIndex","upToIndex","_extractTagName","mode","editor","getMode","innerModeData","innerMode","state","type","tagName","getTagAttributes","pos","attrs","backwardCtx","getInitialContext","_codeMirror","forwardCtx","$","extend","getModeForSelection","test","movePrevToken","push","moveNextToken","createTagInfo","tokenType","attrName","valueAssigned","attr","name","value","position","_getTagInfoStartingFromAttrValue","attrInfo","attrVal","strLength","ch","end","firstChar","lastChar","moveSkippingWhitespace","_getTagInfoStartingFromAttrName","isPriorAttr","getTagInfo","constPos","isHtmlMode","tagInfo","testPos","line","testToken","getTokenAt","findBlocks","modeName","blocks","currentBlock","inBlock","outerMode","tokenModeName","previousMode","start","text","document","getRange","findStyleBlocks"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var CodeMirror = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        TokenUtils = require(\"utils/TokenUtils\");\n\n    // Constants\n    var TAG_NAME = \"tagName\",\n        CLOSING_TAG = \"closingTag\",\n        ATTR_NAME = \"attr.name\",\n        ATTR_VALUE = \"attr.value\";\n\n    // Regular expression for token types with \"tag\" prefixed\n    var tagPrefixedRegExp = /^tag/;\n\n   /**\n     * @private\n     * Sometimes as attr values are getting typed, if the quotes aren't balanced yet\n     * some extra 'non attribute value' text gets included in the token. This attempts\n     * to assure the attribute value we grab is always good\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @return { val:{string}, offset:{number}}\n     */\n    function _extractAttrVal(ctx) {\n        var attrValue = ctx.token.string,\n            startChar = attrValue.charAt(0),\n            endChar = attrValue.charAt(attrValue.length - 1),\n            offset = TokenUtils.offsetInToken(ctx),\n            foundEqualSign = false;\n\n        //If this is a fully quoted value, return the whole\n        //thing regardless of position\n        if (attrValue.length > 1 &&\n                (startChar === \"'\" || startChar === '\"') &&\n                endChar === startChar) {\n\n            // Find an equal sign before the end quote. If found,\n            // then the user may be entering an attribute value right before\n            // another attribute and we're getting a false balanced string.\n            // An example of this case is <link rel\" href=\"foo\"> where the\n            // cursor is right after the first double quote.\n            foundEqualSign = (attrValue.match(/\\=\\s*['\"]$/) !== null);\n\n            if (!foundEqualSign) {\n                //strip the quotes and return;\n                attrValue = attrValue.substring(1, attrValue.length - 1);\n                offset = offset - 1 > attrValue.length ? attrValue.length : offset - 1;\n                return {val: attrValue, offset: offset, quoteChar: startChar, hasEndQuote: true};\n            }\n        }\n\n        if (foundEqualSign) {\n            var spaceIndex = attrValue.indexOf(\" \"),\n                bracketIndex = attrValue.indexOf(\">\"),\n                upToIndex = (spaceIndex !== -1 && spaceIndex < bracketIndex) ? spaceIndex : bracketIndex;\n            attrValue = attrValue.substring(0, (upToIndex > offset) ? upToIndex : offset);\n        } else if (offset > 0 && (startChar === \"'\" || startChar === '\"')) {\n            //The att value is getting edit in progress. There is possible extra\n            //stuff in this token state since the quote isn't closed, so we assume\n            //the stuff from the quote to the current pos is definitely in the attribute\n            //value.\n            attrValue = attrValue.substring(0, offset);\n        }\n\n        //If the attrValue start with a quote, trim that now\n        startChar = attrValue.charAt(0);\n        if (startChar === \"'\" || startChar === '\"') {\n            attrValue = attrValue.substring(1);\n            offset--;\n        } else {\n            startChar = \"\";\n            // Make attr value empty and set offset to zero if it has the \">\"\n            // which is the closing of the tag.\n            if (endChar === \">\") {\n                attrValue = \"\";\n                offset = 0;\n            }\n        }\n\n        return {val: attrValue, offset: offset, quoteChar: startChar, hasEndQuote: false};\n    }\n\n    /**\n     * @private\n     * Gets the tagname from where ever you are in the currect state\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @return {string}\n     */\n    function _extractTagName(ctx) {\n        var mode = ctx.editor.getMode(),\n            innerModeData = CodeMirror.innerMode(mode, ctx.token.state);\n\n        if (ctx.token.type === \"tag bracket\") {\n            return innerModeData.state.tagName;\n        }\n\n        // If the ctx is inside the tag name of an end tag, innerModeData.state.tagName is\n        // undefined. So return token string as the tag name.\n        return innerModeData.state.tagName || ctx.token.string;\n    }\n\n    /**\n     * Compiles a list of used attributes for a given tag\n     * @param {CodeMirror} editor An instance of a CodeMirror editor\n     * @param {ch:{string}, line:{number}} pos A CodeMirror position\n     * @return {Array.<string>} A list of the used attributes inside the current tag\n     */\n    function getTagAttributes(editor, pos) {\n        var attrs       = [],\n            backwardCtx = TokenUtils.getInitialContext(editor._codeMirror, pos),\n            forwardCtx  = $.extend({}, backwardCtx);\n\n        if (editor.getModeForSelection() === \"html\") {\n            if (backwardCtx.token && !tagPrefixedRegExp.test(backwardCtx.token.type)) {\n                while (TokenUtils.movePrevToken(backwardCtx) && !tagPrefixedRegExp.test(backwardCtx.token.type)) {\n                    if (backwardCtx.token.type === \"error\" && backwardCtx.token.string.indexOf(\"<\") === 0) {\n                        break;\n                    }\n                    if (backwardCtx.token.type === \"attribute\") {\n                        attrs.push(backwardCtx.token.string);\n                    }\n                }\n\n                while (TokenUtils.moveNextToken(forwardCtx) && !tagPrefixedRegExp.test(forwardCtx.token.type)) {\n                    if (forwardCtx.token.type === \"attribute\") {\n                        // If the current tag is not closed, codemirror may return the next opening\n                        // tag as an attribute. Stop the search loop in that case.\n                        if (forwardCtx.token.string.indexOf(\"<\") === 0) {\n                            break;\n                        }\n                        attrs.push(forwardCtx.token.string);\n                    } else if (forwardCtx.token.type === \"error\") {\n                        if (forwardCtx.token.string.indexOf(\"<\") === 0 || forwardCtx.token.string.indexOf(\">\") === 0) {\n                            break;\n                        }\n                        // If we type the first letter of the next attribute, it comes as an error\n                        // token. We need to double check for possible invalidated attributes.\n                        if (/\\S/.test(forwardCtx.token.string) &&\n                                forwardCtx.token.string.indexOf(\"\\\"\") === -1 &&\n                                forwardCtx.token.string.indexOf(\"'\") === -1 &&\n                                forwardCtx.token.string.indexOf(\"=\") === -1) {\n                            attrs.push(forwardCtx.token.string);\n                        }\n                    }\n                }\n            }\n        }\n\n        return attrs;\n    }\n\n    /**\n     * Creates a tagInfo object and assures all the values are entered or are empty strings\n     * @param {string=} tokenType what is getting edited and should be hinted\n     * @param {number=} offset where the cursor is for the part getting hinted\n     * @param {string=} tagName The name of the tag\n     * @param {string=} attrName The name of the attribute\n     * @param {string=} attrValue The value of the attribute\n     * @return {{tagName:string,\n     *           attr:{name:string, value:string, valueAssigned:boolean, quoteChar:string, hasEndQuote:boolean},\n     *           position:{tokenType:string, offset:number}\n     *         }}\n     *         A tagInfo object with some context about the current tag hint.\n     */\n    function createTagInfo(tokenType, offset, tagName, attrName, attrValue, valueAssigned, quoteChar, hasEndQuote) {\n        return { tagName: tagName || \"\",\n            attr:\n            { name: attrName || \"\",\n                value: attrValue || \"\",\n                valueAssigned: valueAssigned || false,\n                quoteChar: quoteChar || \"\",\n                hasEndQuote: hasEndQuote || false },\n            position:\n            { tokenType: tokenType || \"\",\n                offset: offset || 0 } };\n    }\n\n    /**\n     * @private\n     * Gets the taginfo starting from the attribute value and moving backwards\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @return {string}\n     */\n    function _getTagInfoStartingFromAttrValue(ctx) {\n        // Assume we in the attr value\n        // and validate that by going backwards\n        var attrInfo = _extractAttrVal(ctx),\n            attrVal = attrInfo.val,\n            offset = attrInfo.offset,\n            quoteChar = attrInfo.quoteChar,\n            hasEndQuote = attrInfo.hasEndQuote,\n            strLength = ctx.token.string.length;\n\n        if ((ctx.token.type === \"string\" || ctx.token.type === \"error\") &&\n                ctx.pos.ch === ctx.token.end && strLength > 1) {\n            var firstChar = ctx.token.string[0],\n                lastChar = ctx.token.string[strLength - 1];\n\n            // We get here only when the cursor is immediately on the right of the end quote\n            // of an attribute value. So we want to return an empty tag info so that the caller\n            // can dismiss the code hint popup if it is still open.\n            if (firstChar === lastChar && (firstChar === \"'\" || firstChar === \"\\\"\")) {\n                return createTagInfo();\n            }\n        }\n\n        //Skip all the 'string' tokens backwards. Required to reach to the first line\n        //of multiline HTML attribute value.\n        while (TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx)) {\n            if (ctx.token.type !== \"string\") {\n                break;\n            }\n        }\n\n        //As we have skipped all the string tokens, make a forward navigation to move to the\n        //first 'string token so that in next backward navigation we can find '='.\n        TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx);\n\n        //Move to the prev token, and check if it's \"=\"\n        if (!TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx) || ctx.token.string !== \"=\") {\n            return createTagInfo();\n        }\n\n        //Move to the prev token, and check if it's an attribute\n        if (!TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx) || ctx.token.type !== \"attribute\") {\n            return createTagInfo();\n        }\n\n        var attrName = ctx.token.string;\n        var tagName = _extractTagName(ctx);\n\n        //We're good.\n        return createTagInfo(ATTR_VALUE, offset, tagName, attrName, attrVal, true, quoteChar, hasEndQuote);\n    }\n\n    /**\n     * @private\n     * Gets the taginfo starting from the attribute name and moving forwards\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\n     * @param {boolean} isPriorAttr indicates whether we're getting info for a prior attribute\n     * @return {string}\n     */\n    function _getTagInfoStartingFromAttrName(ctx, isPriorAttr) {\n        //Verify We're in the attribute name, move forward and try to extract the rest of\n        //the info. If the user it typing the attr the rest might not be here\n        if (isPriorAttr === false && ctx.token.type !== \"attribute\") {\n            return createTagInfo();\n        }\n\n        var tagName = _extractTagName(ctx);\n        var attrName = ctx.token.string;\n        var offset = TokenUtils.offsetInToken(ctx);\n\n        if (!TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx) || ctx.token.string !== \"=\") {\n            // If we're checking for a prior attribute and the next token we get is a tag or an html comment or\n            // an undefined token class, then we've already scanned past our original cursor location.\n            // So just return an empty tag info.\n            if (isPriorAttr &&\n                    (!ctx.token.type ||\n                    (ctx.token.type && ctx.token.type !== \"attribute\" &&\n                        ctx.token.type.indexOf(\"error\") === -1 &&\n                        ctx.token.string.indexOf(\"<\") !== -1))) {\n                return createTagInfo();\n            }\n            return createTagInfo(ATTR_NAME, offset, tagName, attrName);\n        }\n\n        if (!TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx)) {\n            return createTagInfo(ATTR_NAME, offset, tagName, attrName);\n        }\n        //this should be the attrvalue\n        var attrInfo = _extractAttrVal(ctx),\n            attrVal = attrInfo.val,\n            quoteChar = attrInfo.quoteChar,\n            hasEndQuote = attrInfo.hasEndQuote;\n\n        return createTagInfo(ATTR_NAME, offset, tagName, attrName, attrVal, true, quoteChar, hasEndQuote);\n    }\n\n    /**\n     * Figure out if we're in a tag, and if we are return info about it\n     * An example token stream for this tag is <span id=\"open-files-disclosure-arrow\"></span> :\n     *      className:tag       string:\"<span\"\n     *      className:          string:\" \"\n     *      className:attribute string:\"id\"\n     *      className:          string:\"=\"\n     *      className:string    string:\"\"open-files-disclosure-arrow\"\"\n     *      className:tag       string:\"></span>\"\n     * @param {Editor} editor An instance of a Brackets editor\n     * @param {{ch: number, line: number}} constPos  A CM pos (likely from editor.getCursorPos())\n     * @param {isHtmlMode:boolean} let the module know we are in html mode\n     * @return {{tagName:string,\n     *           attr:{name:string, value:string, valueAssigned:boolean, quoteChar:string, hasEndQuote:boolean},\n     *           position:{tokenType:string, offset:number}\n     *         }}\n     *         A tagInfo object with some context about the current tag hint.\n     */\n    function getTagInfo(editor, constPos, isHtmlMode) {\n        // We're going to be changing pos a lot, but we don't want to mess up\n        // the pos the caller passed in so we use extend to make a safe copy of it.\n        var pos = $.extend({}, constPos),\n            ctx = TokenUtils.getInitialContext(editor._codeMirror, pos),\n            offset = TokenUtils.offsetInToken(ctx),\n            tagInfo,\n            tokenType;\n\n        // Check if this is not known to be in html mode and inside a style block.\n        if (!isHtmlMode && editor.getModeForSelection() !== \"html\") {\n            return createTagInfo();\n        }\n\n        // Check and see where we are in the tag\n        if (ctx.token.string.length > 0 && !/\\S/.test(ctx.token.string)) {\n\n            // token at (i.e. before) pos is whitespace, so test token at next pos\n            //\n            // note: getTokenAt() does range checking for ch. If it detects that ch is past\n            // EOL, it uses EOL, same token is returned, and the following condition fails,\n            // so we don't need to worry about testPos being valid.\n            var testPos = {ch: ctx.pos.ch + 1, line: ctx.pos.line},\n                testToken = editor._codeMirror.getTokenAt(testPos, true);\n\n            if (testToken.string.length > 0 && /\\S/.test(testToken.string) &&\n                    testToken.string.charAt(0) !== \">\") {\n                // pos has whitespace before it and non-whitespace after it, so use token after\n                ctx.token = testToken;\n\n                // Check whether the token type is one of the types prefixed with \"tag\"\n                // (e.g. \"tag\", \"tag error\", \"tag brackets\")\n                if (tagPrefixedRegExp.test(ctx.token.type)) {\n                    // Check to see if the cursor is just before a \"<\" but not in any tag.\n                    if (ctx.token.string.charAt(0) === \"<\") {\n                        return createTagInfo();\n                    }\n                } else if (ctx.token.type === \"attribute\") {\n                    // Check to see if the user is going to add a new attr before an existing one\n                    return _getTagInfoStartingFromAttrName(ctx, false);\n                } else if (ctx.token.string === \"=\") {\n                    // We're between a whitespace and  \"=\", so return an empty tag info.\n                    return createTagInfo();\n                }\n            } else {\n                // We get here if \">\" or white spaces after testPos.\n                // Check if there is an equal sign after testPos by creating a new ctx\n                // with the original pos. We can't use the current ctx since we need to\n                // use it to scan backwards if we don't find an equal sign here.\n                // Comment out this block to fix issue #1510.\n//                if (testToken.string.length > 0 && testToken.string.charAt(0) !== \">\") {\n//                    tempCtx = TokenUtils.getInitialContext(editor._codeMirror, pos);\n//                    if (TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, tempCtx) && tempCtx.token.string === \"=\") {\n//                        // Return an empty tag info since we're between an atribute name and the equal sign.\n//                        return createTagInfo();\n//                    }\n//                }\n\n                // next, see what's before pos\n                if (!TokenUtils.movePrevToken(ctx)) {\n                    return createTagInfo();\n                }\n\n                if (ctx.token.type === \"comment\") {\n                    return createTagInfo();\n                } else if (!tagPrefixedRegExp.test(ctx.token.type) && ctx.token.string !== \"=\") {\n                    // If it wasn't the tag name, assume it was an attr value\n                    // Also we don't handle the \"=\" here.\n                    tagInfo = _getTagInfoStartingFromAttrValue(ctx);\n\n                    // Check to see if this is the closing of a tag (either the start or end)\n                    // or a comment tag.\n                    if (ctx.token.type === \"comment\" ||\n                            (tagPrefixedRegExp.test(ctx.token.type) &&\n                            (ctx.token.string === \">\" || ctx.token.string === \"/>\" ||\n                                ctx.token.string === \"</\"))) {\n                        return createTagInfo();\n                    }\n\n                    // If it wasn't an attr value, assume it was an empty attr (ie. attr with no value)\n                    if (!tagInfo.tagName) {\n                        tagInfo = _getTagInfoStartingFromAttrName(ctx, true);\n                    }\n\n                    // We don't want to give context for the previous attr\n                    // and we want it to look like the user is going to add a new attr\n                    if (tagInfo.tagName) {\n                        return createTagInfo(ATTR_NAME, 0, tagInfo.tagName);\n                    }\n                    return createTagInfo();\n                }\n\n                // We know the tag was here, so the user is adding an attr name\n                tokenType = ATTR_NAME;\n                offset = 0;\n            }\n        }\n\n        if (tagPrefixedRegExp.test(ctx.token.type)) {\n            if (ctx.token.type !== \"tag bracket\") {\n                // Check if the user just typed a white space after \"<\" that made an existing tag invalid.\n                if (TokenUtils.movePrevToken(ctx) && !/\\S/.test(ctx.token.string)) {\n                    return createTagInfo();\n                }\n\n                // Check to see if this is a closing tag\n                if (ctx.token.type === \"tag bracket\" && ctx.token.string === \"</\") {\n                    tokenType = CLOSING_TAG;\n                }\n\n                // Restore the original ctx by moving back to next context since we call\n                // movePrevToken above to detect \"<\" or \"</\".\n                TokenUtils.moveNextToken(ctx);\n            }\n\n            // Check to see if this is the closing of a start tag or a self closing tag\n            if (ctx.token.string === \">\" || ctx.token.string === \"/>\") {\n                return createTagInfo();\n            }\n\n            // Make sure the cursor is not after an equal sign or a quote before we report the context as a tag.\n            if (ctx.token.string !== \"=\" && ctx.token.string.match(/^[\"']/) === null) {\n                if (!tokenType) {\n                    tokenType = TAG_NAME;\n                    if (ctx.token.type === \"tag bracket\") {\n                        // Check to see if this is a closing tag\n                        if (ctx.token.string === \"</\") {\n                            tokenType = CLOSING_TAG;\n                            offset -= 2;\n                        } else {\n                            offset = 0;\n                        }\n                        // If the cursor is right after the \"<\" or \"</\", then\n                        // move context to next one so that _extractTagName\n                        // call below can get the tag name if there is one.\n                        if (offset === 0) {\n                            TokenUtils.moveNextToken(ctx);\n                        }\n                    }\n                }\n\n                // We're actually in the tag, just return that as we have no relevant\n                // info about what attr is selected\n                return createTagInfo(tokenType, offset, _extractTagName(ctx));\n            }\n        }\n\n        if (ctx.token.string === \"=\") {\n            // We could be between the attr and the value\n            // Step back and check\n            if (!TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx) || ctx.token.type !== \"attribute\") {\n                return createTagInfo();\n            }\n\n            // The \"=\" is added, time to hint for values\n            tokenType = ATTR_VALUE;\n            offset = 0;\n        }\n\n        if (ctx.token.type === \"attribute\") {\n            tagInfo = _getTagInfoStartingFromAttrName(ctx, false);\n\n            // If we're in attr value, then we may need to calculate the correct offset\n            // from the beginning of the attribute value. If the cursor position is to\n            // the left of attr value, then the offset is negative.\n            // e.g. if the cursor is just to the right of the \"=\" in <a rel= \"rtl\", then\n            // the offset will be -2.\n            if (tagInfo.attr.quoteChar) {\n                offset = constPos.ch - ctx.pos.ch;\n            } else if (tokenType === ATTR_VALUE && (constPos.ch + 1) < ctx.pos.ch) {\n                // The cursor may be right before an unquoted attribute or another attribute name.\n                // Since we can't distinguish between them, we will empty the value so that the\n                // caller can just insert a new attribute value.\n                tagInfo.attr.value = \"\";\n            }\n        } else {\n            // if we're not at a tag, \"=\", or attribute name, assume we're in the value\n            tagInfo = _getTagInfoStartingFromAttrValue(ctx);\n        }\n\n        if (tokenType && tagInfo.tagName) {\n            tagInfo.position.tokenType = tokenType;\n            tagInfo.position.offset = offset;\n        }\n\n        return tagInfo;\n    }\n\n\n\n    /**\n     * Returns an Array of info about all blocks whose token mode name matches that passed in,\n     * in the given Editor's HTML document (assumes the Editor contains HTML text).\n     * @param {!Editor} editor - the editor containing the HTML text\n     * @param {string} modeName - the mode name of the tokens to look for\n     * @return {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, text:string}>}\n     */\n    function findBlocks(editor, modeName) {\n        // Start scanning from beginning of file\n        var ctx = TokenUtils.getInitialContext(editor._codeMirror, {line: 0, ch: 0}),\n            blocks = [],\n            currentBlock = null,\n            inBlock = false,\n            outerMode = editor._codeMirror.getMode(),\n            tokenModeName,\n            previousMode;\n\n        while (TokenUtils.moveNextToken(ctx, false)) {\n            tokenModeName = CodeMirror.innerMode(outerMode, ctx.token.state).mode.name;\n            if (inBlock) {\n                if (!currentBlock.end) {\n                    // Handle empty blocks\n                    currentBlock.end = currentBlock.start;\n                }\n                // Check for end of this block\n                if (tokenModeName === previousMode) {\n                    // currentBlock.end is already set to pos of the last token by now\n                    currentBlock.text = editor.document.getRange(currentBlock.start, currentBlock.end);\n                    inBlock = false;\n                } else {\n                    currentBlock.end = { line: ctx.pos.line, ch: ctx.pos.ch };\n                }\n            } else {\n                // Check for start of a block\n                if (tokenModeName === modeName) {\n                    currentBlock = {\n                        start: { line: ctx.pos.line, ch: ctx.pos.ch }\n                    };\n                    blocks.push(currentBlock);\n                    inBlock = true;\n                } else {\n                    previousMode = tokenModeName;\n                }\n                // else, random token: ignore\n            }\n        }\n\n        return blocks;\n    }\n\n    /**\n     * Returns an Array of info about all <style> blocks in the given Editor's HTML document (assumes\n     * the Editor contains HTML text).\n     * @param {!Editor} editor\n     * @return {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, text:string}>}\n     */\n    function findStyleBlocks(editor) {\n        return findBlocks(editor, \"css\");\n    }\n\n\n    // Define public API\n    exports.TAG_NAME         = TAG_NAME;\n    exports.CLOSING_TAG      = CLOSING_TAG;\n    exports.ATTR_NAME        = ATTR_NAME;\n    exports.ATTR_VALUE       = ATTR_VALUE;\n\n    exports.getTagInfo       = getTagInfo;\n    exports.getTagAttributes = getTagAttributes;\n    //The createTagInfo is really only for the unit tests so they can make the same structure to\n    //compare results with\n    exports.createTagInfo   = createTagInfo;\n    exports.findStyleBlocks = findStyleBlocks;\n    exports.findBlocks      = findBlocks;\n});\n"],"file":"HTMLUtils.js"}
{"version":3,"sources":["node-loader.js"],"names":["nodeLoader","nodeLoadstartTime","Date","now","phcodeExecHandlerMap","nodeConnectorIDMap","pendingExecPromiseMap","currentCommandID","wssEndpoint","controlSocket","dataSocket","SOCKET_TYPE_DATA","SOCKET_TYPE_CONTROL","LARGE_DATA_THRESHOLD","MAX_RECONNECT_BACKOFF_TIME_MS","NODE_CONNECTOR_CREATE_TIMEOUT","MAX_QUEUE_LENGTH","pendingNodeConnectorExecMap","pendingNodeConnectorEventMap","isTimerRunningMap","WS_COMMAND","RESPONSE","EXEC","EVENT","LARGE_DATA_SOCKET_ANNOUNCE","CONTROL_SOCKET_ANNOUNCE","WS_ERR_CODES","NO_SUCH_FN","mergeMetadataAndArrayBuffer","metadata","bufferData","ArrayBuffer","hasBufferData","Error","metadataString","JSON","stringify","metadataUint8Array","TextEncoder","encode","metadataBuffer","buffer","sizePrefixLength","byteLength","concatenatedBuffer","concatenatedUint8Array","Uint8Array","DataView","setUint32","set","splitMetadataAndBuffer","buffer1Length","getUint32","buffer1","slice","parse","TextDecoder","decode","buffer2","MAX_PENDING_SEND_BUFFER","pendingSendBuffer","_drainPendingSendBuffer","copyPendingSendBuffer","commandObject","dataBuffer","_sendWithAppropriateSocket","_isSocketOpen","socket","readyState","WebSocket","OPEN","socketToUse","atleastOneSocketUsable","send","length","push","_sendCommand","commandCode","dataObjectToSend","commandID","command","data","_sendInitCommand","_sendExec","nodeConnectorID","execHandlerFnName","_sendExecResponse","defaultWS","response","originalCommand","error","_sendEvent","eventName","event","_sendError","err","defaultMessage","message","code","stack","_isObject","variable","_extractBuffer","result","_isJSONStringifiable","e","_errNClearQueue","pendingExecList","ws","_queueExec","setTimeout","_drainExecQueue","_execPhcodeConnectorFn","moduleExports","Promise","then","catch","_queueEvent","pendingEventList","_drainEventQueue","_triggerEvent","nodeConnector","trigger","processWSCommand","pendingExecPromise","cause","nodeStack","reject","resolve","console","createNodeConnector","newNodeConnector","execPeer","triggerPeer","window","EventDispatcher","makeEventDispatcher","_silentlyCloseSocket","autoReconnect","close","_wait","timeMS","async","_establishAndMaintainConnection","socketType","firstConnectCB","binaryType","resolved","wsClosePromiseResolve","wsClosePromise","isLargeDataWS","addEventListener","backoffTime","Math","min","setNodeWSEndpoint","websocketEndpoint","nodeSetupDonePromise","NODE_COMMANDS","COMMAND_RESPONSE_PREFIX","COMMAND_ERROR_PREFIX","child","pendingCommands","PHNODE_PREFERENCES_KEY","setInspectEnabled","enabled","prefs","localStorage","getItem","inspectEnabled","setItem","isInspectEnabled","getRandomNumber","max","floor","random","nodeTerminationResolve","nodeTerminationPromise","PhNodeEngine","isNodeReady","__TAURI__","path","resolveResource","Phoenix","platform","cliArgs","invoke","nodeSrcPath","dirname","inspectPort","isTestWindow","argsArray","shell","Command","sidecar","on","isNodeTerminated","log","signal","logger","reportError","stdout","line","startsWith","replace","jsonMsg","type","stderr","spawn","execNode","commandData","newCommandID","resolveP","rejectP","write","promise","terminateNode","getInspectPort","fs","phoenixFSURL","forceUseNodeWSEndpoint","phoenixNodeURL","_nodeLoadTime","debugMode","browser","isTauri"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global Phoenix, fs, logger*/\n\nfunction nodeLoader() {\n    const nodeLoadstartTime = Date.now();\n    const phcodeExecHandlerMap = {};\n    const nodeConnectorIDMap = {};\n    // This holds the list {resolve, reject} for all waiting exec functions executed with execPeer here.\n    const pendingExecPromiseMap = {};\n    let currentCommandID = 1; // should be greater than 0!\n    let wssEndpoint, controlSocket, dataSocket;\n    const SOCKET_TYPE_DATA = \"data\",\n        SOCKET_TYPE_CONTROL = \"control\";\n    const LARGE_DATA_THRESHOLD = 2*1024*1024; // 2MB\n    const MAX_RECONNECT_BACKOFF_TIME_MS = 1000;\n\n    // If a NodeConnector has been created on this end, we can promptly process events and exec messages. However,\n    // in cases where a NodeConnector hasn't been created yet on this end, we temporarily queue execs and event triggers\n    // for up to 10 seconds. This approach ensures that the other side remains unaware of the status of the\n    // NodeConnector at both ends, allowing them to initiate message transmission via the WebSocket as soon as they\n    // invoke the createNodeConnector API on their side.\n\n    // Timeout duration for NodeConnector creation (10 seconds)\n    const NODE_CONNECTOR_CREATE_TIMEOUT = 10000;\n    // Max number of messages to queue for a single node connector.\n    const MAX_QUEUE_LENGTH = 2000;\n\n    // These arrays hold queues of event and exec messages received from the other side while a NodeConnector\n    // was not yet created on this end. Messages are queued for up to 10 seconds.\n    const pendingNodeConnectorExecMap = {};\n    const pendingNodeConnectorEventMap = {};\n\n    // This timer clears the pending maps above if a NodeConnector is not created within 10 seconds.\n    const isTimerRunningMap = {};\n\n\n    const WS_COMMAND = {\n        RESPONSE: \"response\",\n        EXEC: \"exec\",\n        EVENT: \"event\",\n        LARGE_DATA_SOCKET_ANNOUNCE: \"largeDataSock\",\n        CONTROL_SOCKET_ANNOUNCE: \"controlSock\"\n    };\n\n    const WS_ERR_CODES = {\n        NO_SUCH_FN: \"NoSuchFn\"\n    };\n\n    /**\n     *\n     * @param metadata {Object} Max size can be 4GB\n     * @param bufferData {ArrayBuffer} [optional]\n     * @return {ArrayBuffer}\n     * @private\n     */\n    function mergeMetadataAndArrayBuffer(metadata, bufferData) {\n        if (bufferData instanceof ArrayBuffer) {\n            metadata.hasBufferData = true;\n        }\n        bufferData = bufferData || new ArrayBuffer(0);\n        if (typeof metadata !== 'object') {\n            throw new Error(\"metadata should be an object, but was \" + typeof metadata);\n        }\n        if (!(bufferData instanceof ArrayBuffer)) {\n            throw new Error(\"Expected bufferData to be an instance of ArrayBuffer, but was \" + typeof bufferData);\n        }\n\n        const metadataString = JSON.stringify(metadata);\n        const metadataUint8Array = new TextEncoder().encode(metadataString);\n        const metadataBuffer = metadataUint8Array.buffer;\n        const sizePrefixLength = 4; // 4 bytes for a 32-bit integer\n\n        if (metadataBuffer.byteLength > 4294000000) {\n            throw new Error(\"metadata too large. Should be below 4,294MB, but was \" + metadataBuffer.byteLength);\n        }\n\n        const concatenatedBuffer = new ArrayBuffer(sizePrefixLength + metadataBuffer.byteLength + bufferData.byteLength);\n        const concatenatedUint8Array = new Uint8Array(concatenatedBuffer);\n\n        // Write the length of metadataBuffer as a 32-bit integer\n        new DataView(concatenatedBuffer).setUint32(0, metadataBuffer.byteLength, true);\n\n        // Copy the metadataUint8Array and bufferData (if provided) to the concatenatedUint8Array\n        concatenatedUint8Array.set(metadataUint8Array, sizePrefixLength);\n        if (bufferData.byteLength > 0) {\n            concatenatedUint8Array.set(new Uint8Array(bufferData), sizePrefixLength + metadataBuffer.byteLength);\n        }\n\n        return concatenatedBuffer;\n    }\n\n    function splitMetadataAndBuffer(concatenatedBuffer) {\n        if(!(concatenatedBuffer instanceof ArrayBuffer)){\n            throw new Error(\"Expected ArrayBuffer message from websocket\");\n        }\n        const sizePrefixLength = 4;\n        const buffer1Length = new DataView(concatenatedBuffer).getUint32(0, true); // Little endian\n\n        const buffer1 = concatenatedBuffer.slice(sizePrefixLength, sizePrefixLength + buffer1Length);\n        const metadata = JSON.parse(new TextDecoder().decode(buffer1));\n        let buffer2;\n        if (concatenatedBuffer.byteLength > sizePrefixLength + buffer1Length) {\n            buffer2 = concatenatedBuffer.slice(sizePrefixLength + buffer1Length);\n        }\n        if(!buffer2 && metadata.hasBufferData) {\n            // This happens if the sender is sending 0 length buffer. So we have to create an empty buffer here\n            buffer2 = new ArrayBuffer(0);\n        }\n\n        return {\n            metadata,\n            bufferData: buffer2\n        };\n    }\n\n    const MAX_PENDING_SEND_BUFFER = 10000;\n    let pendingSendBuffer = [];\n\n    function _drainPendingSendBuffer() {\n        const copyPendingSendBuffer = pendingSendBuffer;\n        // empty to prevent race conditions\n        pendingSendBuffer = [];\n        // Using a for...of loop for better readability\n        for(let {commandObject, dataBuffer} of copyPendingSendBuffer) {\n            _sendWithAppropriateSocket(commandObject, dataBuffer);\n        }\n    }\n\n    function _isSocketOpen(socket) {\n        return socket && socket.readyState === WebSocket.OPEN;\n    }\n\n    function _sendWithAppropriateSocket(commandObject, dataBuffer) {\n        let socketToUse = controlSocket || dataSocket;\n        const atleastOneSocketUsable = _isSocketOpen(controlSocket) || _isSocketOpen(dataSocket);\n        if(!socketToUse || !atleastOneSocketUsable){\n            // We got a send event before a websocket connection is established by phcode. Queue it to send later.\n            if(pendingSendBuffer.length > MAX_PENDING_SEND_BUFFER){\n                throw new Error(\"Too many node ws messages queued before a node connection was established to phnode.\");\n            }\n            pendingSendBuffer.push({commandObject, dataBuffer});\n            return;\n        }\n        if(dataBuffer && dataBuffer.byteLength > LARGE_DATA_THRESHOLD && dataSocket && _isSocketOpen(dataSocket)) {\n            socketToUse = dataSocket;\n        }\n        socketToUse.send(mergeMetadataAndArrayBuffer(commandObject, dataBuffer));\n    }\n\n    function _sendCommand(commandCode, dataObjectToSend = null, dataBuffer = null) {\n        currentCommandID++;\n        const commandID = currentCommandID;\n        const command = {\n            commandCode: commandCode,\n            commandID: commandID,\n            data: dataObjectToSend\n        };\n        _sendWithAppropriateSocket(command, dataBuffer);\n        return commandID;\n    }\n\n    function _sendInitCommand(socket, commandCode) {\n        currentCommandID++;\n        const commandID = currentCommandID;\n        socket.send(mergeMetadataAndArrayBuffer({\n            commandCode: commandCode,\n            commandID: commandID,\n            data: null\n        }, null));\n    }\n\n    function _sendExec(nodeConnectorID, commandID, execHandlerFnName, dataObjectToSend = null, dataBuffer = null) {\n        const command = {\n            nodeConnectorID: nodeConnectorID,\n            commandID: commandID,\n            execHandlerFnName,\n            commandCode: WS_COMMAND.EXEC,\n            data: dataObjectToSend\n        };\n        _sendWithAppropriateSocket(command, dataBuffer);\n    }\n\n    /**\n     *\n     * @param defaultWS If specified, will use the given socket.\n     * @param metadata\n     * @param dataObjectToSend\n     * @param dataBuffer {ArrayBuffer}\n     * @private\n     */\n    function _sendExecResponse(defaultWS, metadata, dataObjectToSend = null, dataBuffer = null) {\n        const response = {\n            originalCommand: metadata.commandCode,\n            commandCode: WS_COMMAND.RESPONSE,\n            commandID: metadata.commandID,\n            error: metadata.error,\n            data: dataObjectToSend\n        };\n        let socketToUse = defaultWS || controlSocket;\n        if(dataBuffer && dataBuffer.byteLength > LARGE_DATA_THRESHOLD && dataSocket) {\n            socketToUse = dataSocket;\n        }\n        socketToUse.send(mergeMetadataAndArrayBuffer(response, dataBuffer));\n    }\n\n    function _sendEvent(nodeConnectorID, eventName, dataObjectToSend = null, dataBuffer = null) {\n        const event = {\n            nodeConnectorID,\n            eventName,\n            commandCode: WS_COMMAND.EVENT,\n            data: dataObjectToSend\n        };\n        _sendWithAppropriateSocket(event, dataBuffer);\n    }\n\n    function _sendError(defaultWS, metadata, err= { }, defaultMessage = \"Operation failed! \") {\n        metadata.error = {\n            message: err.message || defaultMessage,\n            code: err.code,\n            stack: err.stack\n        };\n        _sendExecResponse(defaultWS, metadata);\n    }\n\n    function _isObject(variable) {\n        return typeof variable === 'object' && variable !== null;\n    }\n\n    function _extractBuffer(result) {\n        if(_isObject(result) && result.buffer instanceof ArrayBuffer) {\n            const buffer = result.buffer;\n            delete result.buffer;\n            return buffer;\n        }\n        return null;\n    }\n\n    function _isJSONStringifiable(result) {\n        try {\n            JSON.stringify(result);\n            return true;\n        } catch (e){\n            return false;\n        }\n    }\n\n    function _errNClearQueue(nodeConnectorID) {\n        const pendingExecList = pendingNodeConnectorExecMap[nodeConnectorID];\n        pendingNodeConnectorExecMap[nodeConnectorID] = [];\n        for(const { ws, metadata } of pendingExecList) {\n            _sendError(\n                ws, metadata,\n                new Error(`NodeConnector ${nodeConnectorID} not found to exec function ${metadata.execHandlerFnName}`)\n            );\n        }\n    }\n\n    function _queueExec(nodeConnectorID, ws, metadata, bufferData) {\n        let pendingExecList = pendingNodeConnectorExecMap[nodeConnectorID];\n        if(!pendingExecList){\n            pendingExecList = [];\n            pendingNodeConnectorExecMap[nodeConnectorID] = pendingExecList;\n        }\n        if(pendingExecList.length > MAX_QUEUE_LENGTH) {\n            _sendError(ws, metadata,\n                new Error(`Too Many exec while waiting for NodeConnector ${nodeConnectorID} creation to exec fn ${metadata.execHandlerFnName}`));\n            return;\n        }\n        pendingExecList.push({ws, metadata, bufferData});\n        if(!isTimerRunningMap[nodeConnectorID]){\n            isTimerRunningMap[nodeConnectorID] = true;\n            setTimeout(() => {\n                // the node connector was not established\n                isTimerRunningMap[nodeConnectorID] = false;\n                _errNClearQueue(nodeConnectorID);\n            }, NODE_CONNECTOR_CREATE_TIMEOUT);\n        }\n    }\n\n    function _drainExecQueue(nodeConnectorID) {\n        let pendingExecList = pendingNodeConnectorExecMap[nodeConnectorID] || [];\n        pendingNodeConnectorExecMap[nodeConnectorID] = [];\n        for(const {ws, metadata, bufferData} of pendingExecList) {\n            _execPhcodeConnectorFn(ws, metadata, bufferData);\n        }\n    }\n\n    function _execPhcodeConnectorFn(ws, metadata, dataBuffer) {\n        const nodeConnectorID = metadata.nodeConnectorID;\n        const execHandlerFnName = metadata.execHandlerFnName;\n        const moduleExports = phcodeExecHandlerMap[nodeConnectorID];\n        if(!moduleExports){\n            // node connector not yet created. Queue it.\n            _queueExec(nodeConnectorID, ws, metadata, dataBuffer);\n            return;\n        }\n        try{\n            if(typeof moduleExports[execHandlerFnName] !== 'function'){\n                const err = new Error(\"execHandlerFnName: \" + execHandlerFnName\n                    + \" no such function in node connector module: \" + nodeConnectorID);\n                err.code = WS_ERR_CODES.NO_SUCH_FN;\n                throw err;\n            }\n            const response = moduleExports[execHandlerFnName](metadata.data, dataBuffer);\n            if(!(response instanceof Promise)) {\n                throw new Error(`execHandlerFnName: ${nodeConnectorID}::${execHandlerFnName} : `\n                    + \" is expected to return a promise that resolve to ({data, ?buffer})\");\n            }\n            response\n                .then((result)=>{\n                    const buffer = _extractBuffer(result);\n                    if(!_isJSONStringifiable(result)) {\n                        throw new Error(`execHandlerFnName: ${nodeConnectorID}::${execHandlerFnName} : `\n                            + \" is expected to return a promise that resolve to an object that can be JSON.stringify -ed. To pass an array buffer, use resolve({buffer:arrayBufferObj})\");\n                    }\n                    _sendExecResponse(ws, metadata, result, buffer);\n                }).catch(err =>{\n                _sendError(ws, metadata, err,\n                    `Error executing function in: ${nodeConnectorID}:${execHandlerFnName}`);\n            });\n        } catch (e) {\n            _sendError(ws, metadata, e, \"Phcode Could not execute function in: \" + nodeConnectorID);\n        }\n    }\n\n    function _queueEvent(nodeConnectorID, ws, metadata, bufferData) {\n        let pendingEventList = pendingNodeConnectorEventMap[nodeConnectorID];\n        if(!pendingEventList){\n            pendingEventList = [];\n            pendingNodeConnectorEventMap[nodeConnectorID] = pendingEventList;\n        }\n        if(pendingEventList.length > MAX_QUEUE_LENGTH) {\n            _sendError(ws, metadata,\n                new Error(`Too Many events: ${metadata.eventName} while waiting for NodeConnector ${nodeConnectorID} creation`));\n            return;\n        }\n        pendingEventList.push({ws, metadata, bufferData});\n        if(!isTimerRunningMap[nodeConnectorID]){\n            isTimerRunningMap[nodeConnectorID] = true;\n            setTimeout(() => {\n                // the node connector was not established\n                isTimerRunningMap[nodeConnectorID] = false;\n                _errNClearQueue(nodeConnectorID);\n            }, NODE_CONNECTOR_CREATE_TIMEOUT);\n        }\n    }\n\n    function _drainEventQueue(nodeConnectorID) {\n        let pendingEventList = pendingNodeConnectorEventMap[nodeConnectorID] || [];\n        pendingNodeConnectorEventMap[nodeConnectorID] = [];\n        for(const {ws, metadata, bufferData} of pendingEventList) {\n            _triggerEvent(ws, metadata, bufferData);\n        }\n    }\n\n    function _triggerEvent(ws, metadata, dataBuffer) {\n        const nodeConnectorID = metadata.nodeConnectorID;\n        const nodeConnector = nodeConnectorIDMap[nodeConnectorID];\n        if(!nodeConnector){\n            // node connector not yet created. Queue it.\n            _queueEvent(nodeConnectorID, ws, metadata, dataBuffer);\n            return;\n        }\n        nodeConnector.trigger(metadata.eventName, metadata.data, dataBuffer);\n    }\n\n    function processWSCommand(ws, metadata, dataBuffer) {\n        try{\n            switch (metadata.commandCode) {\n            case WS_COMMAND.EXEC:\n                _execPhcodeConnectorFn(ws, metadata, dataBuffer);\n                return;\n            case WS_COMMAND.EVENT:\n                _triggerEvent(ws, metadata, dataBuffer);\n                return;\n            case WS_COMMAND.RESPONSE:\n                const commandID = metadata.commandID;\n                const pendingExecPromise = pendingExecPromiseMap[commandID];\n                if(!pendingExecPromise){\n                    throw new Error(\"Unable to find response handler for \"+ JSON.stringify(metadata));\n                }\n                if(metadata.error) {\n                    const error = new Error(metadata.error.message, {cause: metadata.error.stack});\n                    error.code = metadata.error.code;\n                    error.nodeStack = metadata.error.stack;\n                    pendingExecPromise.reject(error);\n                } else {\n                    const result = metadata.data;\n                    if(dataBuffer instanceof ArrayBuffer) {\n                        result.buffer = dataBuffer;\n                    }\n                    pendingExecPromise.resolve(result);\n                }\n                delete pendingExecPromiseMap[commandID];\n                break;\n            default: console.error(\"unknown command: \"+ metadata);\n            }\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    function createNodeConnector(nodeConnectorID, moduleExports) {\n        if(nodeConnectorIDMap[nodeConnectorID]) {\n            throw new Error(\"A node connector of the name is already registered: \" + nodeConnectorID);\n        }\n        if(!_isObject(moduleExports) || !nodeConnectorID) {\n            throw new Error(\"Invalid Argument. Expected createNodeConnector(string, module/Object) for \" + nodeConnectorID);\n        }\n\n        phcodeExecHandlerMap[nodeConnectorID] = moduleExports;\n        const newNodeConnector = {\n            /**\n             * Executes a peer function with specified parameters. Most of the time you would use dataObjectToSend to send\n             * simple JSON serializable objects. But in the event you have to send a binary ArrayBuffer, you can use\n             * the optional `dataBuffer` field. Note that at this time, you can only send and receive a single binary buffer\n             *\n             * @param {string} execHandlerFnName - The name of the function to execute on the peer.\n             * @param {Object|string|null} dataObjectToSend - Optional data to send along with the function call.\n             * @param {ArrayBuffer|null} dataBuffer - Optional binary data to send along with the function call.\n             *\n             * @returns {Promise} - A promise that resolves or rejects based on the result of the function execution.\n             *\n             * @throws {Error} - If `dataBuffer` is provided and is not an instance of `ArrayBuffer`.\n             */\n            execPeer: function (execHandlerFnName, dataObjectToSend = null, dataBuffer = null) {\n                if ((dataBuffer && !(dataBuffer instanceof ArrayBuffer)) || dataObjectToSend instanceof ArrayBuffer) {\n                    throw new Error(\"execPeer should be called with exactly 3 arguments or less (FnName:string, data:Object|string, buffer:ArrayBuffer)\");\n                }\n                if (dataBuffer instanceof ArrayBuffer && !_isObject(dataObjectToSend)) {\n                    throw new Error(\"execPeer second argument should be an object if sending binary data (FnName:string, data:Object, buffer:ArrayBuffer)\");\n                }\n                return new Promise((resolve, reject) =>{\n                    currentCommandID ++;\n                    pendingExecPromiseMap[currentCommandID] = {resolve, reject};\n                    _sendExec(nodeConnectorID, currentCommandID, execHandlerFnName, dataObjectToSend, dataBuffer);\n                });\n            },\n            /**\n             * Triggers an event to be sent to a peer. Most of the time you would use dataObjectToSend to send\n             * simple JSON serializable objects. But in the event you have to send a binary ArrayBuffer, you can use\n             * the optional `dataBuffer` field. Note that at this time, you can only send and receive a single binary buffer\n             *\n             * @param {string} eventName - The name of the event to trigger.\n             * @param {Object|string|null} dataObjectToSend - Optional data associated with the event. Can be an object, string, or null.\n             * @param {ArrayBuffer|null} dataBuffer - Optional binary data associated with the event. Must be an ArrayBuffer or null.\n             *\n             * @throws {Error} Throws an error if dataBuffer is provided but is not an ArrayBuffer.\n             */\n            triggerPeer: function (eventName, dataObjectToSend = null, dataBuffer = null) {\n                if (dataBuffer && !(dataBuffer instanceof ArrayBuffer)) {\n                    throw new Error(\"triggerPeer should be called with exactly 3 arguments (eventName:string, data:Object|string, buffer:ArrayBuffer)\");\n                }\n                _sendEvent(nodeConnectorID, eventName, dataObjectToSend, dataBuffer);\n            }\n        };\n        window.EventDispatcher.makeEventDispatcher(newNodeConnector);\n        nodeConnectorIDMap[nodeConnectorID] = newNodeConnector;\n\n        // At this point, it's possible that a node connector has been created on the other end, and it might have sent\n        // us exec and trigger events that need to be processed. These events will be queued for execution, and we will\n        // handle them after the current event loop call.\n        // We use a setTimeout with a zero-millisecond delay to ensure that the event queues are drained during the\n        // next tick of the event loop.\n        setTimeout(() => {\n            _drainExecQueue(nodeConnectorID);\n            _drainEventQueue(nodeConnectorID);\n        }, 0);\n\n        // At this time, the node connector at the other side may not be created, but it is still safe to use this\n        // node connector now as the events will be queued at the other end for up to 10 seconds for a node connector\n        // to be created at the other end.\n        return newNodeConnector;\n    }\n\n    function _silentlyCloseSocket(socket) {\n        if(!socket) {\n            return;\n        }\n        try{\n            socket.autoReconnect = false;\n            socket.close();\n        } catch (e) {\n            console.error(\"node-loader: \", e);\n        }\n    }\n\n    function _wait(timeMS) {\n        return new Promise((resolve)=>{\n            setTimeout(resolve, timeMS);\n        });\n    }\n\n    async function _establishAndMaintainConnection(socketType, firstConnectCB) {\n        let ws = new WebSocket(wssEndpoint);\n        ws.binaryType = 'arraybuffer';\n        ws.autoReconnect = true;\n        const resolved = false;\n        while(ws.autoReconnect) {\n            let wsClosePromiseResolve;\n            const wsClosePromise = new Promise((resolve) => {wsClosePromiseResolve = resolve;});\n            if(socketType === SOCKET_TYPE_CONTROL) {\n                controlSocket = ws;\n            } else {\n                ws.isLargeDataWS = true;\n                dataSocket = ws;\n            }\n            // eslint-disable-next-line no-loop-func\n            ws.addEventListener(\"open\", () =>{\n                ws.backoffTime = 0;\n                if(!resolved) {\n                    firstConnectCB();\n                }\n                if(ws.isLargeDataWS){\n                    _sendInitCommand(ws, WS_COMMAND.LARGE_DATA_SOCKET_ANNOUNCE);\n                } else {\n                    _sendInitCommand(ws, WS_COMMAND.CONTROL_SOCKET_ANNOUNCE);\n                }\n                _drainPendingSendBuffer();\n            });\n\n            // eslint-disable-next-line no-loop-func\n            ws.addEventListener('message', function (event) {\n                const {metadata, bufferData} = splitMetadataAndBuffer(event.data);\n                processWSCommand(ws, metadata, bufferData);\n            });\n\n            ws.addEventListener('error', function (event) {\n                console.error(\"PhoenixFS websocket error event: \", event);\n            });\n\n            ws.addEventListener('close', function () {\n                wsClosePromiseResolve();\n            });\n            await wsClosePromise;\n            const backoffTime = Math.min(ws.backoffTime * 2, MAX_RECONNECT_BACKOFF_TIME_MS) || 1;\n            ws.backoffTime = backoffTime;\n            await _wait(backoffTime);\n            if(ws.autoReconnect) {\n                ws = new WebSocket(wssEndpoint);\n                ws.backoffTime = backoffTime;\n                ws.binaryType = 'arraybuffer';\n                ws.autoReconnect = true;\n            }\n        }\n    }\n\n    async function setNodeWSEndpoint(websocketEndpoint) {\n        return new Promise((resolve, reject)=>{\n            if(websocketEndpoint === wssEndpoint) {\n                reject(new Error(\"A connection on the same websocket address is in progress: \" + websocketEndpoint));\n            }\n            _silentlyCloseSocket(controlSocket);\n            controlSocket = null;\n            _silentlyCloseSocket(dataSocket);\n            dataSocket = null;\n            wssEndpoint = websocketEndpoint;\n            let resolved = false;\n            function firstConnectCB() {\n                if(!resolved){\n                    resolve();\n                    resolved = true;\n                }\n            }\n            _establishAndMaintainConnection(SOCKET_TYPE_CONTROL, firstConnectCB);\n            _establishAndMaintainConnection(SOCKET_TYPE_DATA, firstConnectCB);\n        });\n    }\n\n\n    window.nodeSetupDonePromise = new Promise((resolve, reject) =>{\n        const NODE_COMMANDS = {\n            TERMINATE: \"terminate\",\n            PING: \"ping\",\n            SET_DEBUG_MODE: \"setDebugMode\",\n            GET_ENDPOINTS: \"getEndpoints\"\n        };\n        const COMMAND_RESPONSE_PREFIX = 'phnodeResp_1!5$:'; // a string thats not likely to just start with in\n        const COMMAND_ERROR_PREFIX = 'phnodeErr_1!5$:';\n        let command, child;\n        let resolved = false;\n        let commandID = 0, pendingCommands = {};\n        const PHNODE_PREFERENCES_KEY = \"PhNode.Prefs\";\n        function setInspectEnabled(enabled) {\n            // cannot use PhStore instead of localStorage here as this is required at boot. Should be fine\n            // as this to use non-persistent local storage(due to safari ITP) here as this is a debug flag.\n            const prefs = JSON.parse(localStorage.getItem(PHNODE_PREFERENCES_KEY) || \"{}\");\n            prefs.inspectEnabled = enabled;\n            localStorage.setItem(PHNODE_PREFERENCES_KEY, JSON.stringify(prefs));\n        }\n        function isInspectEnabled() {\n            // cannot use PhStore instead of localStorage here as this is required at boot.\n            const prefs = JSON.parse(localStorage.getItem(PHNODE_PREFERENCES_KEY) || \"{}\");\n            return !!prefs.inspectEnabled;\n        }\n\n        function getRandomNumber(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        }\n\n        let nodeTerminationResolve;\n        const nodeTerminationPromise = new Promise((resolve) => { nodeTerminationResolve = resolve;});\n        window.nodeTerminationPromise = nodeTerminationPromise;\n\n        // createNodeConnector can me immediately used after this, no need to wait for node nodeSetupDonePromise\n        // All messages to be sent to node will be queued and sent when node comes online in its time.\n        window.PhNodeEngine = {\n            createNodeConnector,\n            setInspectEnabled,\n            isInspectEnabled\n        };\n        window.isNodeReady = false;\n\n        window.__TAURI__.path.resolveResource(\"src-node/index.js\")\n            .then(async nodeSrcPath=>{\n                if(Phoenix.platform === \"linux\") {\n                    // in linux installed distributions, src-node is present in the same dir as the executable.\n                    const cliArgs = await window.__TAURI__.invoke('_get_commandline_args');\n                    nodeSrcPath = `${window.path.dirname(cliArgs[0])}/src-node/index.js`;\n                }\n                // node is designed such that it is not required at boot time to lower startup time.\n                // Keep this so to increase boot speed.\n                const inspectPort = Phoenix.isTestWindow ? getRandomNumber(5000, 50000) : 9229;\n                const argsArray = isInspectEnabled() ? [`--inspect=${inspectPort}`, nodeSrcPath] : [nodeSrcPath, ''];\n                command = window.__TAURI__.shell.Command.sidecar('phnode', argsArray);\n                command.on('close', data => {\n                    window.isNodeTerminated = true;\n                    window.isNodeReady = false;\n                    nodeTerminationResolve();\n                    console.log(`PhNode: command finished with code ${data.code} and signal ${data.signal}`);\n                    if(!resolved) {\n                        reject(\"PhNode: closed - Terminated.\");\n                    }\n                });\n                command.on('error', error => {\n                    window.isNodeTerminated = true;\n                    window.isNodeReady = false;\n                    nodeTerminationResolve();\n                    console.error(`PhNode: command error: \"${error}\"`);\n                    if(!resolved) {\n                        logger.reportError(error, `PhNode failed to start!`);\n                        reject(\"PhNode: closed - Terminated.\");\n                    }\n                });\n                command.stdout.on('data', line => {\n                    if(line){\n                        if(line.startsWith(COMMAND_RESPONSE_PREFIX)){\n                            // its a js response object\n                            line = line.replace(COMMAND_RESPONSE_PREFIX, \"\");\n                            const jsonMsg = JSON.parse(line);\n                            pendingCommands[jsonMsg.commandID].resolve(jsonMsg.message);\n                            delete pendingCommands[jsonMsg.commandID];\n                        } else if(line.startsWith(COMMAND_ERROR_PREFIX)){\n                            // its a js response object\n                            line = line.replace(COMMAND_ERROR_PREFIX, \"\");\n                            const err = JSON.parse(line);\n                            logger.reportError(err, `PhNode ${err.type}:${err.code?err.code:''}`);\n                        } else {\n                            console.log(`PhNode: ${line}`);\n                        }\n                    }\n                });\n                command.stderr.on('data', line => console.error(`PhNode: ${line}`));\n                child = await command.spawn();\n\n                const execNode = function (commandCode, commandData) {\n                    if(window.isNodeTerminated){\n                        return Promise.reject(\"Node is terminated! Cannot execute: \" + commandCode);\n                    }\n                    const newCommandID = commandID ++;\n                    child.write(JSON.stringify({\n                        commandCode: commandCode, commandID: newCommandID, commandData\n                    }) + \"\\n\");\n                    let resolveP, rejectP;\n                    const promise = new Promise((resolve, reject) => { resolveP = resolve; rejectP=reject; });\n                    pendingCommands[newCommandID]= {resolve: resolveP, reject: rejectP};\n                    return promise;\n                };\n\n                window.PhNodeEngine.terminateNode = function () {\n                    if(!window.isNodeTerminated) {\n                        execNode(NODE_COMMANDS.TERMINATE);\n                    }\n                    return nodeTerminationPromise;\n                };\n                window.PhNodeEngine.getInspectPort = function () {\n                    return inspectPort;\n                };\n\n                execNode(NODE_COMMANDS.GET_ENDPOINTS)\n                    .then(message=>{\n                        fs.setNodeWSEndpoint(message.phoenixFSURL);\n                        fs.forceUseNodeWSEndpoint(true);\n                        setNodeWSEndpoint(message.phoenixNodeURL);\n                        window.isNodeReady = true;\n                        resolve(message);\n                        // node is designed such that it is not required at boot time to lower startup time.\n                        // Keep this so to increase boot speed.\n                        window.PhNodeEngine._nodeLoadTime = Date.now() - nodeLoadstartTime;\n                    });\n                execNode(NODE_COMMANDS.SET_DEBUG_MODE, window.debugMode);\n            });\n    });\n}\n\nif(Phoenix.browser.isTauri) {\n    nodeLoader();\n}\n"],"file":"node-loader.js"}
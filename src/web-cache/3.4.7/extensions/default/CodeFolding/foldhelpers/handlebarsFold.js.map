{"version":3,"sources":["extensions/default/CodeFolding/foldhelpers/handlebarsFold.js"],"names":["define","require","exports","module","CodeMirror","brackets","getModule","_","StringUtils","scanTextUntil","cm","startCh","startLine","condition","line","getLine","seen","characterIndex","currentLine","range","lastLine","length","concat","from","ch","to","string","lineSeparator","endHelperName","test","endsWith","readUntil","character","getRange","start","text","i","tagStack","braceStack","found","openTag","openPos","currentCharacter","openTagIndex","indexOf","substring","substr","push","tag","last","pop"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2016 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Fold range finder for handlebars/mustache template type files.\n * @author Patrick Oladimeji\n * @date 14/08/2016 22:04:21\n */\n\ndefine(function (require, exports, module) {\n\n    var CodeMirror  = brackets.getModule(\"thirdparty/CodeMirror/lib/codemirror\"),\n        _           = brackets.getModule(\"thirdparty/lodash\"),\n        StringUtils = brackets.getModule(\"utils/StringUtils\");\n\n    /**\n     * Utility function for scanning the text in a document until a certain condition is met\n     * @param {object}  cm  The code mirror object representing the document\n     * @param {string}  startCh  The start character position for the scan operation\n     * @param {number}  startLine The start line position for the scan operation\n     * @param {function (string): boolean} condition A predicate function that takes in the text seen so far and returns true if the scanning process should be halted\n     * @returns {{from:CodeMirror.Pos, to: CodeMirror.Pos, string: string}} An object representing the range of text scanned.\n     */\n    function scanTextUntil(cm, startCh, startLine, condition) {\n        var line = cm.getLine(startLine),\n            seen = \"\",\n            characterIndex = startCh,\n            currentLine = startLine,\n            range;\n        while (currentLine <= cm.lastLine()) {\n            if (line.length === 0) {\n                characterIndex = 0;\n                line = cm.getLine(++currentLine);\n            } else {\n                seen = seen.concat(line[characterIndex] || \"\");\n                if (condition(seen)) {\n                    range = {\n                        from: {ch: startCh, line: startLine},\n                        to: {ch: characterIndex, line: currentLine},\n                        string: seen\n                    };\n                    return range;\n                } else if (characterIndex >= line.length) {\n                    seen = seen.concat(cm.lineSeparator());\n                    if (condition(seen)) {\n                        range = {\n                            from: {ch: startCh, line: startLine},\n                            to: {ch: characterIndex, line: currentLine},\n                            string: seen\n                        };\n                        return range;\n                    }\n                    characterIndex = 0;\n                    line = cm.getLine(++currentLine);\n                } else {\n                    ++characterIndex;\n                }\n            }\n        }\n    }\n\n    /**\n     * Utility function used to detect the end of a helper name when scanning a series of text.\n     * The end of a helper name is signalled by a space character or the `}`\n     * @param   {string}  seen The string seen so far\n     * @returns {boolean} True when the end of a helper name has been detected.\n     */\n    function endHelperName(seen) {\n        return (/\\s$/).test(seen) || StringUtils.endsWith(seen, \"}\");\n    }\n\n    /**\n     * Returns a predicate function that returns true when a specific character is found\n     * @param   {string}   character the character to use in the match function\n     * @returns {function} A function that checks if the last character of the parameter string matches the parameter character\n     */\n    function readUntil(character) {\n        return function (seen) {\n            return seen[seen.length - 1] === character;\n        };\n    }\n\n    function getRange(cm, start) {\n        var currentLine = start.line,\n            text = cm.getLine(currentLine) || \"\",\n            i = 0,\n            tagStack = [],\n            braceStack = [],\n            found,\n            openTag,\n            openPos,\n            currentCharacter,\n            openTagIndex = text.indexOf(\"{{\"),\n            range;\n\n        if (openTagIndex < 0 || text[openTagIndex + 2] === \"/\") {\n            return;\n        }\n\n        found = scanTextUntil(cm, openTagIndex + 2, currentLine, endHelperName);\n        if (!found) {\n            return;\n        }\n\n        openPos = {\n            from: {line: currentLine, ch: openTagIndex},\n            to: found.to\n        };\n        openTag = found.string.substring(0, found.string.length - 1);\n        if (openTag[0] === \"#\" || openTag[0] === \"~\" || openTag[0] === \"^\") {\n            found = scanTextUntil(cm, openPos.to.ch, openPos.to.line, function (seen) {\n                return seen.length > 1 && seen.substr(-2) === \"}}\";\n            });\n            if (found) {\n                openPos.to = {line: found.to.line, ch: found.to.ch + 1};\n            }\n            tagStack.push(openTag.substr(1));\n        } else {\n            braceStack.push(\"{{\");\n        }\n\n        i = found.to.ch;\n        currentLine = found.to.line;\n\n        while (currentLine <= cm.lastLine()) {\n            text = cm.getLine(currentLine);\n            currentCharacter = (text && text[i]) || \"\";\n            switch (currentCharacter) {\n            case \"{\":\n                if (text[i + 1] === \"{\") {\n                    found = scanTextUntil(cm, i + 2, currentLine, endHelperName);\n                    if (found) {\n                        var tag = found.string.substring(0, found.string.length - 1);\n                        if (tag[0] === \"#\" || tag[0] === \"~\" || tag[0] === \"^\") {\n                            tagStack.push(tag.substr(1));\n                        } else if (tag[0] === \"/\" &&\n                                   (_.last(tagStack) === tag.substr(1) || _.last(tagStack) === \"*\" + tag.substr(1))) {\n                            tagStack.pop();\n                            if (tagStack.length === 0 && braceStack.length === 0) {\n                                range = {\n                                    from: openPos.to,\n                                    to: {ch: i, line: currentLine}\n                                };\n                                return range;\n                            }\n                        } else {\n                            braceStack.push(\"{{\");\n                        }\n                    }\n                }\n                break;\n            case \"}\":\n                if (text[i + 1] === \"}\") {\n                    braceStack.pop();\n                    if (braceStack.length === 0 && tagStack.length === 0) {\n                        range = {\n                            from: openPos.to,\n                            to: {ch: i, line: currentLine}\n                        };\n                        return range;\n                    }\n                }\n                break;\n            case \"\\\"\":\n            case \"'\":\n                found = scanTextUntil(cm, i + 1, currentLine, readUntil(text[i]));\n                if (found) {\n                    i = found.to.ch;\n                    currentLine = found.to.line;\n                }\n                break;\n            default:\n                break;\n            }\n\n            ++i;\n            if (i >= text.length) {\n                ++currentLine;\n                i = 0;\n            }\n        }\n    }\n\n    module.exports = getRange;\n});\n"],"file":"handlebarsFold.js"}
{"version":3,"sources":["features/BeautificationManager.js"],"names":["define","require","exports","module","Commands","Strings","StringUtils","AppInit","CommandManager","LanguageManager","Menus","EditorManager","DocumentManager","ProjectManager","PreferencesManager","ProviderRegistrationHandler","RegistrationHandler","PREFERENCES_BEAUTIFY_ON_SAVE","FAILED_EDITOR_TEXT_CHANGED","_providerRegistrationHandler","registerBeautificationProvider","registerProvider","bind","removeBeautificationProvider","removeProvider","beautifyCommand","beautifyOnSaveCommand","_getEnabledProviders","filepath","language","getLanguageForPath","getProvidersForLanguageId","getId","async","_getBeautifiedCodeDetails","editor","enabledProviders","document","file","fullPath","item","provider","beautifyEditorProvider","beautifyTextProvider","beautyObject","e","console","error","Error","_onActiveEditorChange","_evt","current","length","setEnabled","_replaceText","getText","originalText","ranges","replaceStart","line","ch","replaceEnd","getEndingCursorPos","getRange","changedText","hasSelection","setSelection","replaceSelection","cursor","getCursorPos","replaceRange","setCursorPos","beautifyEditor","Promise","resolve","reject","then","rejected","operation","catch","beautifyText","textToBeautify","filePathOrFileName","_beautifyCommand","result","$","Deferred","getActiveEditor","promise","busyMessage","format","BEAUTIFY_PROJECT_BUSY_MESSAGE","getFile","name","setProjectBusy","log","message","BEAUTIFY_ERROR_SELECTION","BEAUTIFY_ERROR","BEAUTIFY_ERROR_ORIGINAL_CHANGED","displayErrorMessageAtCursor","_beautifyOnSave","doc","_isBeautifyOnSaveEnabled","clearSelection","getViewState","_toggleBeautifyOnSave","beautifyOnSave","setViewState","setChecked","appReady","register","CMD_BEAUTIFY_CODE","EDIT_BEAUTIFY_CODE","CMD_BEAUTIFY_CODE_ON_SAVE","EDIT_BEAUTIFY_CODE_ON_SAVE","editMenu","getMenu","AppMenuBar","EDIT_MENU","editorContextMenu","addMenuItem","getContextMenu","ContextMenuIds","EDITOR_MENU","AFTER","EDIT_SELECT_ALL","on"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n// @INCLUDE_IN_API_DOCS\n\n/**\n * Beautification manager interacts with beautify extensions to determine what to do when user issues `beautify code`\n * command. Beautification providers can use this module to register new providers to beautify new languages.\n *\n * ## API\n * ### registerBeautificationProvider\n * Register a Beautification provider with this api.\n *\n * ```js\n * // syntax\n * BeautificationManager.registerBeautificationProvider(provider, supportedLanguages, priority);\n * ```\n * The API requires three parameters:\n * 1. `provider`: must implement a  `beautifyEditorProvider` and `beautifyTextProvider` function. See doc below:\n * 1. `supportedLanguages`: An array of languages that the provider supports. If `[\"all\"]` is supplied, then the\n *    provider will be invoked for all languages. Restrict to specific languages: Eg: `[\"javascript\", \"html\", \"php\"]`\n * 1. `priority`: Used to break ties among providers for a particular language. Providers with a higher number\n *     will be asked for beatified code before those with a lower priority value. Defaults to zero.\n *\n * ```js\n * // to register a provider that will be invoked for all languages. where provider is any object that implements\n * // a `beautifyEditorProvider` and `beautifyTextProvider` function\n * BeautificationManager.registerBeautificationProvider(provider, [\"all\"]);\n *\n * // to register a provider that will be invoked for specific languages\n * BeautificationManager.registerBeautificationProvider(provider, [\"javascript\", \"html\", \"php\"]);\n * ```\n *\n * ### removeBeautificationProvider\n * Removes a registered Beautification provider. The API takes the same arguments as `registerBeautificationProvider`.\n * ```js\n * // syntax\n * BeautificationManager.removeBeautificationProvider(provider, supportedLanguages);\n * // Example\n * BeautificationManager.removeBeautificationProvider(provider, [\"javascript\", \"html\"]);\n * ```\n *\n * ### provider.beautifyEditorProvider\n * Each provider must implement the `beautifyEditorProvider` function that returns a promise. The promise either resolves with\n * the beautified code details or rejects if there is nothing to beautify for the provider.\n * ```js\n * // function signature\n * provider.beautifyEditorProvider = function(editor) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 originalText: \"the original text sent to beautify\",\n *                 changedText: \"partial or full text that changed.\",\n *                 // Optional: If range is specified, only the given range will be replaced. else full text is replaced\n *                 ranges:{\n *                     replaceStart: {line,ch},\n *                     replaceEnd: {line,ch}\n *                 }\n *             });\n *         });\n *     };\n * ```\n *\n * #### The resolved promise object\n * The resolved promise should either be `null`(indicating that the extension itself has prettified the code and\n * doesn't want any further processing from BeautificationManager.) or contain the following details:\n * 1. `originalText` - string, the original text sent to beautify\n * 1. `changedText` - string, this should be the fully prettified text of the whole `originalText` or a fragment of\n *     pretty text in `originalText` if a range was selected. If a `fragment` is returned, then the\n *     `ranges` object must be specified.\n * 1. `ranges` - Optional object, set of 2 cursors that gives details on what range to replace with given changed text.\n *    If range is not specified, the full text in the editor will be replaced. range has 2 fields:\n *    1. `replaceStart{line,ch}` - the start of range to replace\n *    1. `replaceEnd{line,ch}` - the end of range to replace\n *\n * ### provider.beautifyTextProvider\n * Each provider must implement the `beautifyTextProvider` function that returns a promise.\n * The promise either resolves with the beautified code details(same as beautifyEditorProvider) or rejects if\n * there is nothing to beautify for the provider.\n * ```js\n * // function signature.\n * provider.beautifyTextProvider = function(textToBeautify, filePathOrFileName) {\n *         return new Promise((resolve, reject)=>{\n *             resolve({\n *                 originalText: \"the original text sent to beautify\",\n *                 changedText: \"partial or full text that changed.\",\n *                 // Optional: If range is specified, only the given range is assumed changed. else full text changed.\n *                 ranges:{\n *                     replaceStart: {line,ch},\n *                     replaceEnd: {line,ch}\n *                 }\n *             });\n *         });\n *     };\n * ```\n * #### Parameters\n * The `beautifyTextProvider` callback will receive the following arguments.\n * 1. textToBeautify - string\n * 1. filePathOrFileName - string. This will either be a valid file path, or a file name to deduce which language the\n *    beautifier is dealing with.\n * #### The resolved promise object\n *  The resolved object has the same structure as beautifyEditorProvider resolved promise object.\n * @module features/BeautificationManager\n */\ndefine(function (require, exports, module) {\n\n\n    const Commands = require(\"command/Commands\"),\n        Strings = require(\"strings\"),\n        StringUtils = require(\"utils/StringUtils\"),\n        AppInit = require(\"utils/AppInit\"),\n        CommandManager = require(\"command/CommandManager\"),\n        LanguageManager = require(\"language/LanguageManager\"),\n        Menus = require(\"command/Menus\"),\n        EditorManager = require(\"editor/EditorManager\"),\n        DocumentManager = require(\"document/DocumentManager\"),\n        ProjectManager = require(\"project/ProjectManager\"),\n        PreferencesManager = require(\"preferences/PreferencesManager\"),\n        ProviderRegistrationHandler = require(\"features/PriorityBasedRegistration\").RegistrationHandler;\n\n    const PREFERENCES_BEAUTIFY_ON_SAVE = \"BeautifyOnSave\",\n        FAILED_EDITOR_TEXT_CHANGED = \"Beautify failed- editorTextChanged\";\n\n    let _providerRegistrationHandler = new ProviderRegistrationHandler(),\n        registerBeautificationProvider = _providerRegistrationHandler\n            .registerProvider.bind(_providerRegistrationHandler),\n        removeBeautificationProvider = _providerRegistrationHandler\n            .removeProvider.bind(_providerRegistrationHandler),\n        beautifyCommand,\n        beautifyOnSaveCommand;\n\n    function _getEnabledProviders(filepath) {\n        let language = LanguageManager.getLanguageForPath(filepath);\n        return _providerRegistrationHandler.getProvidersForLanguageId(language.getId());\n    }\n\n    async function _getBeautifiedCodeDetails(editor) {\n        let enabledProviders = _getEnabledProviders(editor.document.file.fullPath);\n\n        for(let item of enabledProviders){\n            if(!item.provider.beautifyEditorProvider || !item.provider.beautifyTextProvider){\n                console.error(\n                    \"Beautify providers must implement `beautifyEditorProvider` and `beautifyTextProvider` function\",\n                    item);\n                continue;\n            }\n            try{\n                let beautyObject = await item.provider.beautifyEditorProvider(editor);\n                if(beautyObject){\n                    return beautyObject;\n                }\n            } catch (e) {\n                // providers reject if they didn't beautify the code. We do nothing in the case as expected failure.\n            }\n        }\n        throw new Error(\"No Providers beautified text\");\n    }\n\n    function _onActiveEditorChange(_evt, current) {\n        if(current && _getEnabledProviders(current.document.file.fullPath).length){\n            beautifyCommand.setEnabled(true);\n            return;\n        }\n        beautifyCommand.setEnabled(false);\n    }\n\n    function _replaceText(editor, beautyObject) {\n        if (editor.document.getText() !== beautyObject.originalText){\n            // editor text changed in between beautification. we cant apply changes\n            throw new Error(FAILED_EDITOR_TEXT_CHANGED);\n        }\n        let ranges = beautyObject.ranges || {\n            replaceStart: {line: 0, ch: 0},\n            replaceEnd: editor.getEndingCursorPos()\n        };\n        if(editor.document.getRange(ranges.replaceStart, ranges.replaceEnd) !== beautyObject.changedText) {\n            if(editor.hasSelection()){\n                editor.setSelection(ranges.replaceStart, ranges.replaceEnd);\n                editor.replaceSelection(beautyObject.changedText, 'around');\n            } else {\n                let cursor = editor.getCursorPos();\n                editor.replaceRange(beautyObject.changedText, ranges.replaceStart, ranges.replaceEnd);\n                editor.setCursorPos(cursor.line, cursor.ch);\n                // this cursor is not accurate. Trying to place this accurately is taking time,\n                // tried diff parsing which worked, but parser taking lots of time to complete, diff parsing line wise\n                // was giving better results but couldn't make it consistent.\n            }\n        }\n    }\n\n    /**\n     * Beautifies text in the given editor with available providers.\n     * @param editor\n     * @return {Promise} - A promise that will be resolved to null if the selected text is beautified or rejects\n     * if beautification failed.\n     * @type {function}\n     */\n    function beautifyEditor(editor){\n        return new Promise((resolve, reject)=>{\n            if(!editor){\n                reject();\n                return;\n            }\n            _getBeautifiedCodeDetails(editor).then(beautyObject => {\n                if(!beautyObject || !beautyObject.changedText){\n                    reject();\n                    return;\n                }\n                let rejected = false;\n                editor.operation(function () {\n                    try{\n                        _replaceText(editor, beautyObject);\n                    } catch (e) {\n                        rejected = true;\n                        reject(e);\n                    }\n                });\n                if(!rejected){\n                    resolve();\n                }\n            }).catch(e => {\n                reject(e);\n            });\n        });\n    }\n\n    /**\n     * Beautifies text in the given editor with available providers.\n     * @param {string} textToBeautify\n     * @param {string} filePathOrFileName Note that the file path may not actually exist on disk. It is just used to\n     * infer what language beautifier is to be applied.\n     * @return {Promise} - A promise that will be resolved to null if the selected text is beautified or rejects\n     * if beautification failed..\n     * #### The resolved promise object\n     * The resolved promise object contain the following details:\n     * 1. `originalText` - string, the original text sent to beautify\n     * 1. `changedText` - string, the prettified text.\n     * 1. `ranges` - Optional. if range object is returned, it means that only a part of the original text changed in\n     *    the original text `textToBeautify`. The part that changed is supplied by two cursor positions below:\n     *    1. `replaceStart{line,ch}` - the start of range to replace\n     *    1. `replaceEnd{line,ch}` - the end of range to replace\n     * @type {function}\n     */\n    async function beautifyText(textToBeautify, filePathOrFileName){\n        let enabledProviders = _getEnabledProviders(filePathOrFileName);\n        for(let item of enabledProviders){\n            if(!item.provider.beautifyEditorProvider || !item.provider.beautifyTextProvider){\n                console.error(\n                    \"Beautify providers must implement `beautifyEditorProvider` and `beautifyTextProvider` function\",\n                    item);\n                continue;\n            }\n            try{\n                let beautyObject = await item.provider.beautifyTextProvider(textToBeautify, filePathOrFileName);\n                if(beautyObject){\n                    return beautyObject;\n                }\n            } catch (e) {\n                // providers reject if they didn't beautify the code. We do nothing in the case as expected failure.\n            }\n        }\n        throw new Error(\"No Providers beautified text\");\n    }\n\n    function _beautifyCommand() {\n        let result = new $.Deferred();\n        let editor = EditorManager.getActiveEditor();\n        if(!editor){\n            result.reject();\n            return result.promise();\n        }\n        let busyMessage = StringUtils.format(Strings.BEAUTIFY_PROJECT_BUSY_MESSAGE, editor.getFile().name);\n        ProjectManager.setProjectBusy(true, busyMessage);\n        beautifyEditor(editor).then( () => {\n            ProjectManager.setProjectBusy(false, busyMessage);\n            console.log(\"Beautified\");\n            result.resolve();\n        }).catch(e=>{\n            let message = editor.hasSelection() ? Strings.BEAUTIFY_ERROR_SELECTION : Strings.BEAUTIFY_ERROR;\n            if(e.message === FAILED_EDITOR_TEXT_CHANGED){\n                message = Strings.BEAUTIFY_ERROR_ORIGINAL_CHANGED;\n            }\n\n            editor.displayErrorMessageAtCursor(message);\n            ProjectManager.setProjectBusy(false, busyMessage);\n            console.log(\"No beautify providers responded\", e);\n            result.reject();\n        });\n        return result.promise();\n    }\n\n    function _beautifyOnSave(_evt, doc) {\n        let editor = EditorManager.getActiveEditor();\n        if(!_isBeautifyOnSaveEnabled() || !editor || editor.document.file.fullPath !== doc.file.fullPath){\n            return;\n        }\n        editor.clearSelection();\n        _beautifyCommand();\n    }\n\n    function _isBeautifyOnSaveEnabled() {\n        return PreferencesManager.getViewState(PREFERENCES_BEAUTIFY_ON_SAVE) === \"true\";\n    }\n\n    function _toggleBeautifyOnSave() {\n        let beautifyOnSave = _isBeautifyOnSaveEnabled();\n\n        PreferencesManager.setViewState(PREFERENCES_BEAUTIFY_ON_SAVE, `${!beautifyOnSave}`);\n        beautifyOnSaveCommand.setChecked(!beautifyOnSave);\n    }\n\n    AppInit.appReady(function () {\n        beautifyCommand = CommandManager.register(Strings.CMD_BEAUTIFY_CODE,\n            Commands.EDIT_BEAUTIFY_CODE, ()=>{\n                _beautifyCommand();\n            });\n        beautifyOnSaveCommand = CommandManager.register(Strings.CMD_BEAUTIFY_CODE_ON_SAVE,\n            Commands.EDIT_BEAUTIFY_CODE_ON_SAVE, ()=>{\n                _toggleBeautifyOnSave();\n            });\n        let editMenu = Menus.getMenu(Menus.AppMenuBar.EDIT_MENU);\n        editMenu.addMenuItem(Commands.EDIT_BEAUTIFY_CODE, \"\");\n        editMenu.addMenuItem(Commands.EDIT_BEAUTIFY_CODE_ON_SAVE, \"\");\n\n        let editorContextMenu = Menus.getContextMenu(Menus.ContextMenuIds.EDITOR_MENU);\n        editorContextMenu.addMenuItem(Commands.EDIT_BEAUTIFY_CODE, \"\", Menus.AFTER, Commands.EDIT_SELECT_ALL);\n        beautifyOnSaveCommand.setChecked(_isBeautifyOnSaveEnabled());\n        EditorManager.on(\"activeEditorChange\", _onActiveEditorChange);\n        DocumentManager.on('documentSaved.beautificationManager', _beautifyOnSave);\n    });\n\n    exports.registerBeautificationProvider = registerBeautificationProvider;\n    exports.removeBeautificationProvider = removeBeautificationProvider;\n    exports.beautifyEditor = beautifyEditor;\n    exports.beautifyText = beautifyText;\n});\n"],"file":"BeautificationManager.js"}
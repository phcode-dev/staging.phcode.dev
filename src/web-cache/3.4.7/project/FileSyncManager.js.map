{"version":3,"sources":["project/FileSyncManager.js"],"names":["define","require","exports","module","ProjectManager","DocumentManager","MainViewManager","Async","Dialogs","DefaultDialogs","Strings","StringUtils","FileUtils","FileSystemError","_alreadyChecking","_restartPending","toReload","toClose","editConflicts","deleteConflicts","findExternalChanges","docs","checkDoc","doc","result","$","Deferred","isUntitled","resolve","file","donotWatch","stat","err","NOT_FOUND","keepChangesTime","isDirty","push","fileTime","console","log","fullPath","reject","mtime","getTime","diskTimestamp","promise","doInParallel","syncUnopenWorkingSet","unopenWorkingSetFiles","getWorkingSet","ALL_PANES","filter","wsFile","getOpenDocumentForPath","checkWorkingSetFile","notifyFileDeleted","reloadDoc","readAsText","done","text","readTimestamp","refreshText","fail","error","reloadChangedDocs","showReloadError","showModalDialog","DIALOG_ID_ERROR","ERROR_RELOADING_FILE_TITLE","format","ERROR_RELOADING_FILE","breakableUrl","getFileErrorString","closeDeletedDocs","forEach","presentConflicts","title","allConflicts","concat","presentConflict","docInfo","i","dialogId","message","buttons","length","DIALOG_ID_EXT_CHANGED","EXT_MODIFIED_MESSAGE","makeProjectRelativeIfPossible","className","DIALOG_BTN_CLASS_LEFT","id","DIALOG_BTN_DONTSAVE","RELOAD_FROM_DISK","DIALOG_BTN_CLASS_PRIMARY","DIALOG_BTN_CANCEL","KEEP_CHANGES_IN_EDITOR","DIALOG_ID_EXT_DELETED","EXT_DELETED_MESSAGE","CLOSE_DONT_SAVE","doSequentially","syncOpenDocuments","EXT_MODIFIED_TITLE","cancelModalDialogIfOpen","allDocs","getAllOpenDocuments","always","focusActivePane"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * FileSyncManager is a set of utilities to help track external modifications to the files and folders\n * in the currently open project.\n *\n * Currently, we detect external changes purely by checking file timestamps against the last-sync\n * timestamp recorded on Document. Brackets triggers this check whenever an external change was detected\n * by our native file watchers, and on window focus. We recheck all open Documents, but with file caching\n * the timestamp check is a fast no-op for everything other than files where a watcher change was just\n * notified. If watchers/caching are disabled, we'll essentially check only on window focus, and we'll hit\n * the disk to check every open Document's timestamp every time.\n *\n * FUTURE: Whenever we have a 'project file tree model,' we should manipulate that instead of notifying\n * DocumentManager directly. DocumentManager, the tree UI, etc. then all listen to that model for changes.\n */\ndefine(function (require, exports, module) {\n\n\n    // Load dependent modules\n    var ProjectManager  = require(\"project/ProjectManager\"),\n        DocumentManager = require(\"document/DocumentManager\"),\n        MainViewManager = require(\"view/MainViewManager\"),\n        Async           = require(\"utils/Async\"),\n        Dialogs         = require(\"widgets/Dialogs\"),\n        DefaultDialogs  = require(\"widgets/DefaultDialogs\"),\n        Strings         = require(\"strings\"),\n        StringUtils     = require(\"utils/StringUtils\"),\n        FileUtils       = require(\"file/FileUtils\"),\n        FileSystemError = require(\"filesystem/FileSystemError\");\n\n\n    /**\n     * Guard to spot re-entrancy while syncOpenDocuments() is still in progress\n     * @type {boolean}\n     */\n    var _alreadyChecking = false;\n\n    /**\n     * If true, we should bail from the syncOpenDocuments() process and then re-run it. See\n     * comments in syncOpenDocuments() for how this works.\n     * @type {boolean}\n     */\n    var _restartPending = false;\n\n    /**\n     * @type {Array.<Document>}\n     */\n    var toReload;\n\n    /**\n     * @type {Array.<Document>}\n     */\n    var toClose;\n\n    /**\n     * @type {Array.<{doc: Document, fileTime: number}>}\n     */\n    var editConflicts;\n\n    /**\n     * @type {Array.<{doc: Document, fileTime: number}>}\n     */\n    var deleteConflicts;\n\n\n    /**\n     * Scans all the given Documents for changes on disk, and sorts them into four buckets,\n     * populating the corresponding arrays:\n     *  toReload        - changed on disk; unchanged within Brackets\n     *  toClose         - deleted on disk; unchanged within Brackets\n     *  editConflicts   - changed on disk; also dirty in Brackets\n     *  deleteConflicts - deleted on disk; also dirty in Brackets\n     *\n     * @param {!Array.<Document>} docs\n     * @return {$.Promise}  Resolved when all scanning done, or rejected immediately if there's any\n     *      error while reading file timestamps. Errors are logged but no UI is shown.\n     */\n    function findExternalChanges(docs) {\n\n        toReload = [];\n        toClose = [];\n        editConflicts = [];\n        deleteConflicts = [];\n\n        function checkDoc(doc) {\n            var result = new $.Deferred();\n\n            // Check file timestamp / existence\n\n            if (doc.isUntitled()) {\n                result.resolve();\n            } else if (doc.file.donotWatch) { // Some file might not like to be watched!\n                result.resolve();\n            } else {\n                doc.file.stat(function (err, stat) {\n                    if (!err) {\n                        // Does file's timestamp differ from last sync time on the Document?\n                        var fileTime = stat.mtime.getTime();\n                        if (fileTime !== doc.diskTimestamp.getTime()) {\n                            // If the user has chosen to keep changes that conflict with the\n                            // current state of the file on disk, then do nothing. This means\n                            // that even if the user later undoes back to clean, we won't\n                            // automatically reload the file on window reactivation. We could\n                            // make it do that, but it seems better to be consistent with the\n                            // deletion case below, where it seems clear that you don't want\n                            // to auto-delete the file on window reactivation just because you\n                            // undid back to clean.\n                            if (doc.keepChangesTime !== fileTime) {\n                                if (doc.isDirty) {\n                                    editConflicts.push({doc: doc, fileTime: fileTime});\n                                } else {\n                                    toReload.push(doc);\n                                }\n                            }\n                        }\n                        result.resolve();\n                    } else {\n                        // File has been deleted externally\n                        if (err === FileSystemError.NOT_FOUND) {\n                            // If the user has chosen to keep changes previously, and the file\n                            // has been deleted, then do nothing. Like the case above, this\n                            // means that even if the user later undoes back to clean, we won't\n                            // then automatically delete the file on window reactivation.\n                            // (We use -1 as the \"mod time\" to indicate that the file didn't\n                            // exist, since there's no actual modification time to keep track of\n                            // and -1 isn't a valid mod time for a real file.)\n                            if (doc.keepChangesTime !== -1) {\n                                if (doc.isDirty) {\n                                    deleteConflicts.push({doc: doc, fileTime: -1});\n                                } else {\n                                    toClose.push(doc);\n                                }\n                            }\n                            result.resolve();\n                        } else {\n                            // Some other error fetching metadata: treat as a real error\n                            console.log(\"Error checking modification status of \" + doc.file.fullPath, err);\n                            result.reject();\n                        }\n                    }\n                });\n            }\n\n            return result.promise();\n        }\n\n        // Check all docs in parallel\n        // (fail fast b/c we won't continue syncing if there was any error fetching timestamps)\n        return Async.doInParallel(docs, checkDoc, true);\n    }\n\n    /**\n     * Scans all the files in the working set that do not have Documents (and thus were not scanned\n     * by findExternalChanges()). If any were deleted on disk, removes them from the working set.\n     */\n    function syncUnopenWorkingSet() {\n        // We only care about working set entries that have never been open (have no Document).\n        var unopenWorkingSetFiles = MainViewManager.getWorkingSet(MainViewManager.ALL_PANES).filter(function (wsFile) {\n            return !DocumentManager.getOpenDocumentForPath(wsFile.fullPath);\n        });\n\n        function checkWorkingSetFile(file) {\n            var result = new $.Deferred();\n\n            file.stat(function (err, stat) {\n                if (!err) {\n                    // File still exists\n                    result.resolve();\n                } else {\n                    // File has been deleted externally\n                    if (err === FileSystemError.NOT_FOUND) {\n                        DocumentManager.notifyFileDeleted(file);\n                        result.resolve();\n                    } else {\n                        // Some other error fetching metadata: treat as a real error\n                        console.log(\"Error checking for deletion of \" + file.fullPath, err);\n                        result.reject();\n                    }\n                }\n            });\n            return result.promise();\n        }\n\n        // Check all these files in parallel\n        return Async.doInParallel(unopenWorkingSetFiles, checkWorkingSetFile, false);\n    }\n\n\n    /**\n     * Reloads the Document's contents from disk, discarding any unsaved changes in the editor.\n     *\n     * @param {!Document} doc\n     * @return {$.Promise} Resolved after editor has been refreshed; rejected if unable to load the\n     *      file's new content. Errors are logged but no UI is shown.\n     */\n    function reloadDoc(doc) {\n\n        var promise = FileUtils.readAsText(doc.file);\n\n        promise.done(function (text, readTimestamp) {\n            doc.refreshText(text, readTimestamp);\n        });\n        promise.fail(function (error) {\n            console.log(\"Error reloading contents of \" + doc.file.fullPath, error);\n        });\n        return promise;\n    }\n\n    /**\n     * Reloads all the documents in \"toReload\" silently (no prompts). The operations are all run\n     * in parallel.\n     * @return {$.Promise} Resolved/rejected after all reloads done; will be rejected if any one\n     *      file's reload failed. Errors are logged (by reloadDoc()) but no UI is shown.\n     */\n    function reloadChangedDocs() {\n        // Reload each doc in turn, and once all are (async) done, signal that we're done\n        return Async.doInParallel(toReload, reloadDoc, false);\n    }\n\n    /**\n     * @param {FileError} error\n     * @param {!Document} doc\n     * @return {Dialog}\n     */\n    function showReloadError(error, doc) {\n        return Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_ERROR,\n            Strings.ERROR_RELOADING_FILE_TITLE,\n            StringUtils.format(\n                Strings.ERROR_RELOADING_FILE,\n                StringUtils.breakableUrl(doc.file.fullPath),\n                FileUtils.getFileErrorString(error)\n            )\n        );\n    }\n\n\n    /**\n     * Closes all the documents in \"toClose\" silently (no prompts). Completes synchronously.\n     */\n    function closeDeletedDocs() {\n        toClose.forEach(function (doc) {\n            DocumentManager.notifyFileDeleted(doc.file);\n        });\n    }\n\n\n    /**\n     * Walks through all the documents in \"editConflicts\" & \"deleteConflicts\" and prompts the user\n     * about each one. Processing is sequential: if the user chooses to reload a document, the next\n     * prompt is not shown until after the reload has completed.\n     *\n     * @param {string} title Title of the dialog.\n     * @return {$.Promise} Resolved/rejected after all documents have been prompted and (if\n     *      applicable) reloaded (and any resulting error UI has been dismissed). Rejected if any\n     *      one reload failed.\n     */\n    function presentConflicts(title) {\n\n        var allConflicts = editConflicts.concat(deleteConflicts);\n\n        function presentConflict(docInfo, i) {\n            var result = new $.Deferred(),\n                promise = result.promise(),\n                doc = docInfo.doc,\n                fileTime = docInfo.fileTime;\n\n            // If window has been re-focused, skip all remaining conflicts so the sync can bail & restart\n            if (_restartPending) {\n                result.resolve();\n                return promise;\n            }\n\n            var toClose;\n            var dialogId;\n            var message;\n            var buttons;\n\n            // Prompt UI varies depending on whether the file on disk was modified vs. deleted\n            if (i < editConflicts.length) {\n                toClose = false;\n                dialogId = DefaultDialogs.DIALOG_ID_EXT_CHANGED;\n                message = StringUtils.format(\n                    Strings.EXT_MODIFIED_MESSAGE,\n                    StringUtils.breakableUrl(\n                        ProjectManager.makeProjectRelativeIfPossible(doc.file.fullPath)\n                    )\n                );\n                buttons = [\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_LEFT,\n                        id: Dialogs.DIALOG_BTN_DONTSAVE,\n                        text: Strings.RELOAD_FROM_DISK\n                    },\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\n                        id: Dialogs.DIALOG_BTN_CANCEL,\n                        text: Strings.KEEP_CHANGES_IN_EDITOR\n                    }\n                ];\n\n            } else {\n                toClose = true;\n                dialogId = DefaultDialogs.DIALOG_ID_EXT_DELETED;\n                message = StringUtils.format(\n                    Strings.EXT_DELETED_MESSAGE,\n                    StringUtils.breakableUrl(\n                        ProjectManager.makeProjectRelativeIfPossible(doc.file.fullPath)\n                    )\n                );\n                buttons = [\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_LEFT,\n                        id: Dialogs.DIALOG_BTN_DONTSAVE,\n                        text: Strings.CLOSE_DONT_SAVE\n                    },\n                    {\n                        className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\n                        id: Dialogs.DIALOG_BTN_CANCEL,\n                        text: Strings.KEEP_CHANGES_IN_EDITOR\n                    }\n                ];\n            }\n\n            Dialogs.showModalDialog(dialogId, title, message, buttons)\n                .done(function (id) {\n                    if (id === Dialogs.DIALOG_BTN_DONTSAVE) {\n                        if (toClose) {\n                            // Discard - close all editors\n                            DocumentManager.notifyFileDeleted(doc.file);\n                            result.resolve();\n                        } else {\n                            // Discard - load changes from disk\n                            reloadDoc(doc)\n                                .done(function () {\n                                    result.resolve();\n                                })\n                                .fail(function (error) {\n                                    // Unable to load changed version from disk - show error UI\n                                    showReloadError(error, doc)\n                                        .done(function () {\n                                            // After user dismisses, move on to next conflict prompt\n                                            result.reject();\n                                        });\n                                });\n                        }\n\n                    } else {\n                        // Cancel - if user doesn't manually save or close, remember that they\n                        // chose to keep the changes in the editor and don't prompt again unless the\n                        // file changes again\n                        // OR programmatically canceled due to _resetPending - we'll skip all\n                        // remaining files in the conflicts list (see above)\n\n                        // If this wasn't programmatically cancelled, remember that the user\n                        // has accepted conflicting changes as of this file version.\n                        if (!_restartPending) {\n                            doc.keepChangesTime = fileTime;\n                        }\n\n                        result.resolve();\n                    }\n                });\n\n            return promise;\n        }\n\n        // Begin walking through the conflicts, one at a time\n        return Async.doSequentially(allConflicts, presentConflict, false);\n    }\n\n\n\n    /**\n     * Check to see whether any open files have been modified by an external app since the last time\n     * Brackets synced up with the copy on disk (either by loading or saving the file). For clean\n     * files, we silently upate the editor automatically. For files with unsaved changes, we prompt\n     * the user.\n     *\n     * @param {string} title Title to use for document. Default is \"External Changes\".\n     */\n    function syncOpenDocuments(title) {\n\n        title = title || Strings.EXT_MODIFIED_TITLE;\n\n        // We can become \"re-entrant\" if the user leaves & then returns to Brackets before we're\n        // done -- easy if a prompt dialog is left open. Since the user may have left Brackets to\n        // revert some of the disk changes, etc. we want to cancel the current sync and immediately\n        // begin a new one. We let the orig sync run until the user-visible dialog phase, then\n        // bail; if we're already there we programmatically close the dialog to bail right away.\n        if (_alreadyChecking) {\n            _restartPending = true;\n\n            // Close dialog if it was open. This will 'unblock' presentConflict(), which bails back\n            // to us immediately upon seeing _restartPending. We then restart the sync - see below\n            Dialogs.cancelModalDialogIfOpen(DefaultDialogs.DIALOG_ID_EXT_CHANGED);\n            Dialogs.cancelModalDialogIfOpen(DefaultDialogs.DIALOG_ID_EXT_DELETED);\n\n            return;\n        }\n\n        _alreadyChecking = true;\n\n\n        // Syncing proceeds in four phases:\n        //  1) Check all open files for external modifications\n        //  2) Check any other working set entries (that are not open) for deletion, and remove\n        //     from working set if deleted\n        //  3) Refresh all Documents that are clean (if file changed on disk)\n        //  4) Close all Documents that are clean (if file deleted on disk)\n        //  5) Prompt about any Documents that are dirty (if file changed/deleted on disk)\n        // Each phase fully completes (asynchronously) before the next one begins.\n\n\n        // 1) Check for external modifications\n        var allDocs = DocumentManager.getAllOpenDocuments();\n\n        findExternalChanges(allDocs)\n            .done(function () {\n                // 2) Check un-open working set entries for deletion (& \"close\" if needed)\n                syncUnopenWorkingSet()\n                    .always(function () {\n                        // If we were unable to check any un-open files for deletion, silently ignore\n                        // (after logging to console). This doesn't have any bearing on syncing truly\n                        // open Documents (which we've already successfully checked).\n\n                        // 3) Reload clean docs as needed\n                        reloadChangedDocs()\n                            .always(function () {\n                                // 4) Close clean docs as needed\n                                // This phase completes synchronously\n                                closeDeletedDocs();\n\n                                // 5) Prompt for dirty editors (conflicts)\n                                presentConflicts(title)\n                                    .always(function () {\n                                        if (_restartPending) {\n                                            // Restart the sync if needed\n                                            _restartPending = false;\n                                            _alreadyChecking = false;\n                                            syncOpenDocuments();\n                                        } else {\n                                            // We're really done!\n                                            _alreadyChecking = false;\n\n                                            // If we showed a dialog, restore focus to editor\n                                            if (editConflicts.length > 0 || deleteConflicts.length > 0) {\n                                                MainViewManager.focusActivePane();\n                                            }\n\n                                            // (Any errors that ocurred during presentConflicts() have already\n                                            // shown UI & been dismissed, so there's no fail() handler here)\n                                        }\n                                    });\n                            });\n                            // Note: if any auto-reloads failed, we silently ignore (after logging to console)\n                            // and we still continue onto phase 4 and try to process those files anyway.\n                            // (We'll retry the auto-reloads next time window is activated... and evenually\n                            // we'll also be double checking before each Save).\n                    });\n            }).fail(function () {\n                // Unable to fetch timestamps for some reason - silently ignore (after logging to console)\n                // (We'll retry next time window is activated... and evenually we'll also be double\n                // checking before each Save).\n\n                // We can't go on without knowing which files are dirty, so bail now\n                _alreadyChecking = false;\n            });\n\n    }\n\n\n    // Define public API\n    exports.syncOpenDocuments = syncOpenDocuments;\n});\n"],"file":"FileSyncManager.js"}
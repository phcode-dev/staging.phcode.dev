{"version":3,"sources":["widgets/InlineMenu.js"],"names":["define","require","exports","module","KeyBindingManager","Menus","KeyEvent","StringUtils","ValidationUtils","ViewUtils","PopUpManager","Mustache","MenuHTML","InlineMenu","editor","menuText","this","items","selectedIndex","opened","handleSelect","handleClose","$menu","$","append","hide","_keydownHook","bind","prototype","_setSelectedIndex","index","find","Math","max","min","length","removeClass","$item","$view","addClass","scrollElementIntoView","handleHover","id","_buildListView","self","view","_addItem","item","push","formattedItem","name","remove","some","$ul","$parent","parent","render","children","each","element","$element","data","on","e","stopPropagation","findIndex","currentTarget","_calcMenuLocation","cursor","_codeMirror","cursorCoords","posTop","bottom","posLeft","left","textHeight","getTextHeight","$window","window","$menuWindow","menuHeight","outerHeight","bottomOverhang","height","menuWidth","width","availableWidth","rightOverhang","top","isHandlingKeyCode","keyCodeOrEvent","keyCode","ctrlKey","DOM_VK_UP","DOM_VK_DOWN","DOM_VK_PAGE_UP","DOM_VK_PAGE_DOWN","DOM_VK_RETURN","DOM_VK_ESCAPE","event","_rotateSelection","distance","len","pos","_itemsPerPage","itemsPerPage","$items","itemHeight","floor","isOpen","type","stopImmediatePropagation","shiftKey","call","trigger","preventDefault","hasClass","open","closeAll","menuPos","css","addGlobalKeydownHook","openRemovedMenu","close","removePopUp","removeGlobalKeydownHook","onSelect","callback","onHover","onClose"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    // Load dependent modules\n    var KeyBindingManager = require(\"command/KeyBindingManager\"),\n        Menus             = require(\"command/Menus\"),\n        KeyEvent          = require(\"utils/KeyEvent\"),\n        StringUtils       = require(\"utils/StringUtils\"),\n        ValidationUtils   = require(\"utils/ValidationUtils\"),\n        ViewUtils         = require(\"utils/ViewUtils\"),\n        PopUpManager      = require(\"widgets/PopUpManager\"),\n        Mustache          = require(\"thirdparty/mustache/mustache\");\n\n    var MenuHTML  = require(\"text!htmlContent/inline-menu.html\");\n\n    /**\n     * Displays a popup list of items for a given editor context\n     *\n     * @constructor\n     * @param {Editor} editor\n     * @param {string} menuText\n     */\n    function InlineMenu(editor, menuText) {\n        /**\n         * The list of items to display\n         *\n         * @type {Array.<{id: number, name: string>}\n         */\n        this.items = [];\n\n        /**\n         * The selected position in the list; otherwise -1.\n         *\n         * @type {number}\n         */\n        this.selectedIndex = -1;\n\n\n        /**\n         * Is the list currently open?\n         *\n         * @type {boolean}\n         */\n        this.opened = false;\n\n\n        /**\n         * The editor context\n         *\n         * @type {Editor}\n         */\n        this.editor = editor;\n\n\n        /**\n         * The menu selection callback function\n         *\n         * @type {Function}\n         */\n        this.handleSelect = null;\n\n        /**\n         * The menu closure callback function\n         *\n         * @type {Function}\n         */\n        this.handleClose = null;\n\n        /**\n         * The menu object\n         *\n         * @type {jQuery.Object}\n         */\n        this.$menu =\n            $(\"<li class='dropdown inlinemenu-menu'></li>\")\n                .append($(\"<a href='#' class='dropdown-toggle' data-toggle='dropdown'></a>\")\n                        .hide())\n                .append(\"<ul class='dropdown-menu'>\" +\n                            \"<li class='inlinemenu-header'>\" +\n                                \"<a>\" + menuText + \"</a>\" +\n                            \"</li>\" +\n                         \"</ul>\");\n\n        this._keydownHook = this._keydownHook.bind(this);\n    }\n\n    /**\n     * Select the item in the menu at the specified index, or remove the\n     * selection if index < 0.\n     *\n     * @private\n     * @param {number} index\n     */\n    InlineMenu.prototype._setSelectedIndex = function (index) {\n        var items = this.$menu.find(\"li.inlinemenu-item\");\n\n        // Range check\n        index = Math.max(-1, Math.min(index, items.length - 1));\n\n        // Clear old highlight\n        if (this.selectedIndex !== -1) {\n            $(items[this.selectedIndex]).find(\"a\").removeClass(\"highlight\");\n        }\n\n        this.selectedIndex = index;\n\n        // Highlight the new selected item, if necessary\n        if (this.selectedIndex !== -1) {\n            var $item = $(items[this.selectedIndex]);\n            var $view = this.$menu.find(\"ul.dropdown-menu\");\n\n            $item.find(\"a\").addClass(\"highlight\");\n            ViewUtils.scrollElementIntoView($view, $item, false);\n        }\n\n        // Invoke handleHover callback if any\n        if (this.handleHover) {\n            this.handleHover(this.items[index].id);\n        }\n    };\n\n    /**\n     * Rebuilds the list items for the menu.\n     *\n     * @private\n     */\n    InlineMenu.prototype._buildListView = function (items) {\n        var self            = this,\n            view            = { items: [] },\n            _addItem;\n\n        this.items = items;\n\n        _addItem = function (item) {\n            view.items.push({ formattedItem: \"<span>\" + item.name + \"</span>\"});\n        };\n\n        // clear the list\n        this.$menu.find(\"li.inlinemenu-item\").remove();\n\n        // if there are no items then close the list; otherwise add them and\n        // set the selection\n        if (this.items.length === 0) {\n            if (this.handleClose) {\n                this.handleClose();\n            }\n        } else {\n            this.items.some(function (item, index) {\n                _addItem(item);\n            });\n\n            // render the menu list\n            var $ul = this.$menu.find(\"ul.dropdown-menu\"),\n                $parent = $ul.parent();\n\n            // remove list temporarily to save rendering time\n            $ul.remove().append(Mustache.render(MenuHTML, view));\n\n            $ul.children(\"li.inlinemenu-item\").each(function (index, element) {\n                var item      = self.items[index],\n                    $element    = $(element);\n\n                // store id of item in the element\n                $element.data(\"itemid\", item.id);\n            });\n\n            // delegate list item events to the top-level ul list element\n            $ul.on(\"click\", \"li.inlinemenu-item\", function (e) {\n                // Don't let the click propagate upward (otherwise it will\n                // hit the close handler in bootstrap-dropdown).\n                e.stopPropagation();\n                if (self.handleSelect) {\n                    self.handleSelect($(this).data(\"itemid\"));\n                }\n            });\n\n            $ul.on(\"mouseover\", \"li.inlinemenu-item\", function (e) {\n                e.stopPropagation();\n                // _setSelectedIndex sets the selected index and call handle hover\n                // callback funtion\n                self._setSelectedIndex(self.items.findIndex(function(element) {\n                    return element.id === $(e.currentTarget).data(\"itemid\");\n                }));\n            });\n\n            $parent.append($ul);\n\n            this._setSelectedIndex(0);\n        }\n    };\n\n    /**\n     * Computes top left location for menu so that the menu is not clipped by the window.\n     * Also computes the largest available width.\n     *\n     * @private\n     * @return {{left: number, top: number, width: number}}\n     */\n    InlineMenu.prototype._calcMenuLocation = function () {\n        var cursor      = this.editor._codeMirror.cursorCoords(),\n            posTop      = cursor.bottom,\n            posLeft     = cursor.left,\n            textHeight  = this.editor.getTextHeight(),\n            $window     = $(window),\n            $menuWindow = this.$menu.children(\"ul\"),\n            menuHeight  = $menuWindow.outerHeight();\n\n        // TODO Ty: factor out menu repositioning logic so inline menu and Context menus share code\n        // adjust positioning so menu is not clipped off bottom or right\n        var bottomOverhang = posTop + menuHeight - $window.height();\n        if (bottomOverhang > 0) {\n            posTop -= (textHeight + 2 + menuHeight);\n        }\n\n        posTop -= 30;   // shift top for hidden parent element\n\n        var menuWidth = $menuWindow.width();\n        var availableWidth = menuWidth;\n        var rightOverhang = posLeft + menuWidth - $window.width();\n        if (rightOverhang > 0) {\n            // Right overhang is negative\n            posLeft = Math.max(0, posLeft - rightOverhang);\n        }\n\n        return {left: posLeft, top: posTop, width: availableWidth};\n    };\n\n\n    /**\n     * Check whether Event is one of the keys that we handle or not.\n     *\n     * @param {KeyBoardEvent|keyBoardEvent.keyCode} keyEvent\n     */\n    InlineMenu.prototype.isHandlingKeyCode = function (keyCodeOrEvent) {\n        var keyCode = typeof keyCodeOrEvent === \"object\" ? keyCodeOrEvent.keyCode : keyCodeOrEvent;\n        var ctrlKey = typeof keyCodeOrEvent === \"object\" ? keyCodeOrEvent.ctrlKey : false;\n\n\n        return (keyCode === KeyEvent.DOM_VK_UP || keyCode === KeyEvent.DOM_VK_DOWN ||\n            keyCode === KeyEvent.DOM_VK_PAGE_UP || keyCode === KeyEvent.DOM_VK_PAGE_DOWN ||\n            keyCode === KeyEvent.DOM_VK_RETURN ||\n            keyCode === KeyEvent.DOM_VK_ESCAPE\n        );\n    };\n\n    /**\n     * Convert keydown events into hint list navigation actions.\n     *\n     * @param {KeyBoardEvent} keyEvent\n     */\n    InlineMenu.prototype._keydownHook = function (event) {\n        var keyCode,\n            self = this;\n\n        // positive distance rotates down; negative distance rotates up\n        function _rotateSelection(distance) {\n            var len = self.items.length,\n                pos;\n\n            if (self.selectedIndex < 0) {\n                // set the initial selection\n                pos = (distance > 0) ? distance - 1 : len - 1;\n\n            } else {\n                // adjust current selection\n                pos = self.selectedIndex;\n\n                // Don't \"rotate\" until all items have been shown\n                if (distance > 0) {\n                    if (pos === (len - 1)) {\n                        pos = 0;  // wrap\n                    } else {\n                        pos = Math.min(pos + distance, len - 1);\n                    }\n                } else {\n                    if (pos === 0) {\n                        pos = (len - 1);  // wrap\n                    } else {\n                        pos = Math.max(pos + distance, 0);\n                    }\n                }\n            }\n\n            self._setSelectedIndex(pos);\n        }\n\n        // Calculate the number of items per scroll page.\n        function _itemsPerPage() {\n            var itemsPerPage = 1,\n                $items = self.$menu.find(\"li.inlinemenu-item\"),\n                $view = self.$menu.find(\"ul.dropdown-menu\"),\n                itemHeight;\n\n            if ($items.length !== 0) {\n                itemHeight = $($items[0]).height();\n                if (itemHeight) {\n                    // round down to integer value\n                    itemsPerPage = Math.floor($view.height() / itemHeight);\n                    itemsPerPage = Math.max(1, Math.min(itemsPerPage, $items.length));\n                }\n            }\n\n            return itemsPerPage;\n        }\n\n        // If we're no longer visible, skip handling the key and end the session.\n        if (!this.isOpen()) {\n            this.handleClose();\n            return false;\n        }\n\n        // (page) up, (page) down, enter are handled by the list\n        if ((event.type === \"keydown\") && this.isHandlingKeyCode(event)) {\n            keyCode = event.keyCode;\n\n            if (event.keyCode === KeyEvent.DOM_VK_ESCAPE) {\n                event.stopImmediatePropagation();\n                this.handleClose();\n\n                return false;\n            } else if (event.shiftKey &&\n                    (event.keyCode === KeyEvent.DOM_VK_UP ||\n                     event.keyCode === KeyEvent.DOM_VK_DOWN ||\n                     event.keyCode === KeyEvent.DOM_VK_PAGE_UP ||\n                     event.keyCode === KeyEvent.DOM_VK_PAGE_DOWN)) {\n                this.handleClose();\n                // Let the event bubble.\n                return false;\n            } else if (keyCode === KeyEvent.DOM_VK_UP) {\n                _rotateSelection.call(this, -1);\n            } else if (keyCode === KeyEvent.DOM_VK_DOWN) {\n                _rotateSelection.call(this, 1);\n            } else if (keyCode === KeyEvent.DOM_VK_PAGE_UP) {\n                _rotateSelection.call(this, -_itemsPerPage());\n            } else if (keyCode === KeyEvent.DOM_VK_PAGE_DOWN) {\n                _rotateSelection.call(this, _itemsPerPage());\n            } else if (this.selectedIndex !== -1 &&\n                    (keyCode === KeyEvent.DOM_VK_RETURN)) {\n                // Trigger a click handler to commmit the selected item\n                $(this.$menu.find(\"li.inlinemenu-item\")[this.selectedIndex]).trigger(\"click\");\n            } else {\n                return false;\n            }\n\n            event.stopImmediatePropagation();\n            event.preventDefault();\n            return true;\n        }\n\n        return false;\n    };\n\n    /**\n     * Is the Inline menu open?\n     *\n     * @return {boolean}\n     */\n    InlineMenu.prototype.isOpen = function () {\n        // We don't get a notification when the dropdown closes. The best\n        // we can do is keep an \"opened\" flag and check to see if we\n        // still have the \"open\" class applied.\n        if (this.opened && !this.$menu.hasClass(\"open\")) {\n            this.opened = false;\n        }\n\n        return this.opened;\n    };\n\n    /**\n     * Displays the menu at the current cursor position\n     *\n     * @param {Array.<{id: number, name: string>} hints\n     */\n    InlineMenu.prototype.open = function (items) {\n        Menus.closeAll();\n\n        this._buildListView(items);\n\n        if (this.items.length) {\n            // Need to add the menu to the DOM before trying to calculate its ideal location.\n            $(\"#inlinemenu-menu-bar > ul\").append(this.$menu);\n\n            var menuPos = this._calcMenuLocation();\n\n            this.$menu.addClass(\"open\")\n                .css({\"left\": menuPos.left, \"top\": menuPos.top, \"width\": menuPos.width + \"px\"});\n            this.opened = true;\n\n            KeyBindingManager.addGlobalKeydownHook(this._keydownHook);\n        }\n    };\n\n    /**\n     * Displays the last menu which was closed due to Scrolling\n     */\n    InlineMenu.prototype.openRemovedMenu = function () {\n        if (this.opened === true) {\n            if (this.$menu && !this.$menu.hasClass(\"open\")) {\n                var menuPos = this._calcMenuLocation();\n                this.$menu.addClass(\"open\")\n                    .css({\"left\": menuPos.left, \"top\": menuPos.top, \"width\": menuPos.width + \"px\"});\n            }\n        }\n    };\n\n    /**\n     * Closes the menu\n     */\n    InlineMenu.prototype.close = function () {\n        this.opened = false;\n\n        if (this.$menu) {\n            this.$menu.removeClass(\"open\");\n            PopUpManager.removePopUp(this.$menu);\n            this.$menu.remove();\n        }\n\n        KeyBindingManager.removeGlobalKeydownHook(this._keydownHook);\n    };\n\n    /**\n     * Set the menu selection callback function\n     *\n     * @param {Function} callback\n     */\n    InlineMenu.prototype.onSelect = function (callback) {\n        this.handleSelect = callback;\n    };\n\n    /**\n     * Set the hover callback function\n     *\n     * @param {Function} callback\n     */\n    InlineMenu.prototype.onHover = function (callback) {\n        this.handleHover = callback;\n    };\n\n    /**\n     * Set the menu closure callback function\n     *\n     * @param {Function} callback\n     */\n    InlineMenu.prototype.onClose = function (callback) {\n        this.handleClose = callback;\n    };\n\n    // Define public API\n    exports.InlineMenu = InlineMenu;\n});\n"],"file":"InlineMenu.js"}
{"version":3,"sources":["command/Menus.js"],"names":["define","require","exports","module","_","Commands","EventDispatcher","KeyBindingManager","Keys","Strings","StringUtils","CommandManager","PopUpManager","ViewUtils","Metrics","MainViewManager","AppInit","DeprecationWarning","KEY","AppMenuBar","FILE_MENU","EDIT_MENU","FIND_MENU","VIEW_MENU","NAVIGATE_MENU","DEBUG_MENU","HELP_MENU","ContextMenuIds","EDITOR_MENU","INLINE_EDITOR_MENU","PROJECT_MENU","WORKING_SET_CONTEXT_MENU","WORKING_SET_CONFIG_MENU","SPLITVIEW_MENU","EVENT_BEFORE_CONTEXT_MENU_OPEN","EVENT_BEFORE_CONTEXT_MENU_CLOSE","EVENT_BEFORE_SUB_MENU_OPEN","EVENT_BEFORE_SUB_MENU_CLOSE","MenuSection","FILE_OPEN_CLOSE_COMMANDS","sectionMarker","FILE_NEW","FILE_SAVE_COMMANDS","FILE_SAVE","FILE_LIVE","FILE_LIVE_FILE_PREVIEW","FILE_SETTINGS","FILE_EXTENSION_MANAGER","EDIT_UNDO_REDO_COMMANDS","EDIT_UNDO","EDIT_TEXT_COMMANDS","EDIT_CUT","EDIT_SELECTION_COMMANDS","EDIT_SELECT_ALL","EDIT_MODIFY_SELECTION","EDIT_INDENT","EDIT_COMMENT_SELECTION","EDIT_LINE_COMMENT","EDIT_CODE_HINTS_COMMANDS","SHOW_CODE_HINTS","EDIT_TOGGLE_OPTIONS","TOGGLE_CLOSE_BRACKETS","FIND_FIND_COMMANDS","CMD_FIND","FIND_FIND_IN_COMMANDS","CMD_FIND_IN_FILES","FIND_REPLACE_COMMANDS","CMD_REPLACE","VIEW_HIDESHOW_COMMANDS","VIEW_HIDE_SIDEBAR","VIEW_FONTSIZE_COMMANDS","VIEW_ZOOM_SUBMENU","VIEW_TOGGLE_OPTIONS","TOGGLE_ACTIVE_LINE","NAVIGATE_GOTO_COMMANDS","NAVIGATE_QUICK_OPEN","NAVIGATE_DOCUMENTS_COMMANDS","NAVIGATE_NEXT_DOC","NAVIGATE_OS_COMMANDS","NAVIGATE_SHOW_IN_FILE_TREE","NAVIGATE_QUICK_EDIT_COMMANDS","TOGGLE_QUICK_EDIT","NAVIGATE_QUICK_DOCS_COMMANDS","TOGGLE_QUICK_DOCS","BEFORE","AFTER","FIRST","LAST","FIRST_IN_SECTION","LAST_IN_SECTION","DIVIDER","SUBMENU","menuMap","contextMenuMap","menuItemMap","subMenuItemMap","getMenu","id","getAllMenus","getContextMenu","removeMenuItemEventListeners","menuItem","_command","off","_enabledChanged","_checkedChanged","_nameChanged","_keyBindingAdded","_keyBindingRemoved","getMenuItem","_getHTMLMenu","$","jQueryIdEscape","get","_getHTMLMenuItem","_addKeyBindingToMenuItem","commandID","$menuItem","key","displayKey","$shortcut","find","length","html","canAssignBinding","append","data","text","formatKeyDescriptor","_addExistingKeyBinding","getCommand","getID","bindings","getKeyBindings","binding","_menuDividerIDCount","_getNextMenuItemDividerID","_insertInList","$list","$element","position","$relativeElement","inserted","prepend","after","before","MenuItem","command","options","this","isDivider","isNative","bind","_hideWhenCommandDisabled","hideWhenCommandDisabled","on","Menu","prototype","_getMenuItemId","commandId","_getMenuItemForCommand","foundMenuItem","closest","_getRelativeMenuItem","relativeID","hasOwnProperty","console","error","$sectionMarker","$listElem","prev","next","removeMenuItem","menuItemID","commandObj","parent","remove","removeMenuDivider","$HTMLMenuItem","addMenuItem","keyBindings","self","name","getName","log","keyboardIcon","KEYBOARD_SHORTCUT_CHANGE_TITLE","$menuAnchor","event","showShortcutSelectionDialog","preventDefault","stopPropagation","hasClass","countEvent","EVENT_TYPE","UI_MENU","logger","leaveTrail","focusActivePane","_options","eventSource","execute","SOURCE_UI_MENU_CLICK","sourceType","currentWidth","width","css","closeSubMenu","removeClass","addClass","dividerId","Array","isArray","addBinding","addMenuDivider","addSubMenu","menu","ContextMenu","parentMenuItem","e","openSubMenu","open","removeSubMenu","subMenuID","subMenu","forEach","value","startsWith","close","getParentMenu","parents","checked","getChecked","enabled","getEnabled","brackets","app","setMenuItemState","err","toggleClass","setMenuTitle","keyBinding","shortcutKey","setMenuItemShortcut","empty","lastOpenedMenuID","closeAll","$openDropdownMenuList","getOpenMenu","_closeAllSubMenus","Object","values","openMenu","getDropdownToggleMenuID","click","assignedShortcutsMenus","altKeyReleased","_addAltMenuShortcut","menuName","platform","shortCutKey","toUpperCase","push","newShortcutList","secondLetterShortCutKey","menuShortcutCommandID","register","menusIdsForShortcut","map","item","currentIndex","indexOf","menuToOpen","isMenuShortcut","addMenu","escape","$menubar","$toggle","$popUp","$dropdown","$newMenu","$this","is","focus","addPopUp","_switchMenus","$menuDropdownToggle","menuID","mainMenu","$dropdownToggles","index","nextIndex","ARROW_LEFT","$nextDropdownToggle","eq","_switchMenuItems","$dropdownMenu","$selected","first","$next","ARROW_DOWN","$nextLi","ARROW_UP","$prevLi","last","submenuID","submenu","_execMenuItem","menuKeyboardNavigationHandler","allowedKeys","ARROW_RIGHT","ESCAPE","ENTER","RETURN","includes","$focusedElement","isDescendantOfTitleBar","SPACE","removeMenu","apply","arguments","hide","listenToContextMenu","registerContextMenu","cmenu","window","document","body","addEventListener","ALT","create","constructor","parentClass","makeEventDispatcher","mouseOrLocation","$window","escapedId","$menuWindow","posTop","posLeft","children","trigger","$parentMenuItem","elementRect","top","offset","left","outerWidth","height","clip","getElementClipSize","bottom","Math","max","right","pageY","pageX","isOpen","assignContextMenuToSelector","selector","buttonOffset","buttonHeight","outerHeight","htmlReady","addGlobalKeydownHook","removeGlobalKeydownHook","deprecateConstant"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n/*global logger*/\n\ndefine(function (require, exports, module) {\n\n\n    let _ = require(\"thirdparty/lodash\");\n\n    // Load dependent modules\n    let Commands            = require(\"command/Commands\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        KeyBindingManager   = require(\"command/KeyBindingManager\"),\n        Keys       = require(\"command/Keys\"),\n        Strings    = require(\"strings\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        CommandManager      = require(\"command/CommandManager\"),\n        PopUpManager        = require(\"widgets/PopUpManager\"),\n        ViewUtils           = require(\"utils/ViewUtils\"),\n        Metrics             = require(\"utils/Metrics\"),\n        MainViewManager     = require(\"view/MainViewManager\"),\n        AppInit                 = require(\"utils/AppInit\"),\n        DeprecationWarning  = require(\"utils/DeprecationWarning\");\n\n    // make sure the global brackets letiable is loaded\n    require(\"utils/Global\");\n\n    const KEY = Keys.KEY;\n    /**\n     * Brackets Application Menu Constants\n     * @enum {string}\n     */\n    let AppMenuBar = {\n        FILE_MENU: \"file-menu\",\n        EDIT_MENU: \"edit-menu\",\n        FIND_MENU: \"find-menu\",\n        VIEW_MENU: \"view-menu\",\n        NAVIGATE_MENU: \"navigate-menu\",\n        DEBUG_MENU: \"debug-menu\",\n        HELP_MENU: \"help-menu\"\n    };\n\n    /**\n     * Brackets Context Menu Constants\n     * @enum {string}\n     */\n    let ContextMenuIds = {\n        EDITOR_MENU: \"editor-context-menu\",\n        INLINE_EDITOR_MENU: \"inline-editor-context-menu\",\n        PROJECT_MENU: \"project-context-menu\",\n        WORKING_SET_CONTEXT_MENU: \"workingset-context-menu\",\n        WORKING_SET_CONFIG_MENU: \"workingset-configuration-menu\",\n        SPLITVIEW_MENU: \"splitview-menu\"\n    };\n\n    const EVENT_BEFORE_CONTEXT_MENU_OPEN = \"beforeContextMenuOpen\",\n        EVENT_BEFORE_CONTEXT_MENU_CLOSE = \"beforeContextMenuClose\",\n        EVENT_BEFORE_SUB_MENU_OPEN = \"beforeSubMenuOpen\",\n        EVENT_BEFORE_SUB_MENU_CLOSE = \"beforeSubMenuClose\";\n\n    /**\n     * Brackets Application Menu Section Constants\n     * It is preferred that plug-ins specify the location of new MenuItems\n     * in terms of a menu section rather than a specific MenuItem. This provides\n     * looser coupling to Bracket's internal MenuItems and makes menu organization\n     * more semantic.\n     * Use these constants as the \"relativeID\" parameter when calling addMenuItem() and\n     * specify a position of FIRST_IN_SECTION or LAST_IN_SECTION.\n     *\n     * Menu sections are denoted by dividers or the beginning/end of a menu\n     */\n    let MenuSection = {\n        // Menu Section                     Command ID to mark the section\n        FILE_OPEN_CLOSE_COMMANDS: {sectionMarker: Commands.FILE_NEW},\n        FILE_SAVE_COMMANDS: {sectionMarker: Commands.FILE_SAVE},\n        FILE_LIVE: {sectionMarker: Commands.FILE_LIVE_FILE_PREVIEW},\n        FILE_SETTINGS: {sectionMarker: Commands.FILE_EXTENSION_MANAGER},\n        FILE_EXTENSION_MANAGER: {sectionMarker: Commands.FILE_EXTENSION_MANAGER}, // deprecated. here for legacy support\n\n        EDIT_UNDO_REDO_COMMANDS: {sectionMarker: Commands.EDIT_UNDO},\n        EDIT_TEXT_COMMANDS: {sectionMarker: Commands.EDIT_CUT},\n        EDIT_SELECTION_COMMANDS: {sectionMarker: Commands.EDIT_SELECT_ALL},\n        EDIT_MODIFY_SELECTION: {sectionMarker: Commands.EDIT_INDENT},\n        EDIT_COMMENT_SELECTION: {sectionMarker: Commands.EDIT_LINE_COMMENT},\n        EDIT_CODE_HINTS_COMMANDS: {sectionMarker: Commands.SHOW_CODE_HINTS},\n        EDIT_TOGGLE_OPTIONS: {sectionMarker: Commands.TOGGLE_CLOSE_BRACKETS},\n\n        FIND_FIND_COMMANDS: {sectionMarker: Commands.CMD_FIND},\n        FIND_FIND_IN_COMMANDS: {sectionMarker: Commands.CMD_FIND_IN_FILES},\n        FIND_REPLACE_COMMANDS: {sectionMarker: Commands.CMD_REPLACE},\n\n        VIEW_HIDESHOW_COMMANDS: {sectionMarker: Commands.VIEW_HIDE_SIDEBAR},\n        VIEW_FONTSIZE_COMMANDS: {sectionMarker: Commands.VIEW_ZOOM_SUBMENU},\n        VIEW_TOGGLE_OPTIONS: {sectionMarker: Commands.TOGGLE_ACTIVE_LINE},\n\n        NAVIGATE_GOTO_COMMANDS: {sectionMarker: Commands.NAVIGATE_QUICK_OPEN},\n        NAVIGATE_DOCUMENTS_COMMANDS: {sectionMarker: Commands.NAVIGATE_NEXT_DOC},\n        NAVIGATE_OS_COMMANDS: {sectionMarker: Commands.NAVIGATE_SHOW_IN_FILE_TREE},\n        NAVIGATE_QUICK_EDIT_COMMANDS: {sectionMarker: Commands.TOGGLE_QUICK_EDIT},\n        NAVIGATE_QUICK_DOCS_COMMANDS: {sectionMarker: Commands.TOGGLE_QUICK_DOCS}\n    };\n\n\n    /**\n     * Insertion position constants\n     * Used by addMenu(), addMenuItem(), and addSubMenu() to\n     * specify the relative position of a newly created menu object\n     * @enum {string}\n     */\n    let BEFORE           = \"before\",\n        AFTER            = \"after\",\n        FIRST            = \"first\",\n        LAST             = \"last\",\n        FIRST_IN_SECTION = \"firstInSection\",\n        LAST_IN_SECTION  = \"lastInSection\";\n\n    /**\n     * Other constants\n     */\n    let DIVIDER = \"---\";\n    let SUBMENU = \"SUBMENU\";\n\n    /**\n     * Maps menuID's to Menu objects\n     * @type {Object.<string, Menu>}\n     */\n    let menuMap = {};\n\n    /**\n     * Maps contextMenuID's to ContextMenu objects\n     * @type {Object.<string, ContextMenu>}\n     */\n    let contextMenuMap = {};\n\n    /**\n     * Maps menuItemID's to MenuItem objects\n     * @type {Object.<string, MenuItem>}\n     */\n    let menuItemMap = {};\n\n    /**\n     * Maps menuItemID's to ContextMenu objects\n     * @type {Object.<string, ContextMenu>}\n     */\n    let subMenuItemMap = {};\n\n    /**\n     * Retrieves the Menu object for the corresponding id.\n     * @param {string} id\n     * @return {Menu}\n     */\n    function getMenu(id) {\n        return menuMap[id];\n    }\n\n    /**\n     * Retrieves the map of all Menu objects.\n     * @return {Object.<string, Menu>}\n     */\n    function getAllMenus() {\n        return menuMap;\n    }\n\n    /**\n     * Retrieves the ContextMenu object for the corresponding id.\n     * @param {string} id\n     * @return {ContextMenu}\n     */\n    function getContextMenu(id) {\n        return contextMenuMap[id];\n    }\n\n    /**\n    * Removes the attached event listeners from the corresponding object.\n    * @param {ManuItem} menuItem\n    */\n    function removeMenuItemEventListeners(menuItem) {\n        menuItem._command\n            .off(\"enabledStateChange\", menuItem._enabledChanged)\n            .off(\"checkedStateChange\", menuItem._checkedChanged)\n            .off(\"nameChange\", menuItem._nameChanged)\n            .off(\"keyBindingAdded\", menuItem._keyBindingAdded)\n            .off(\"keyBindingRemoved\", menuItem._keyBindingRemoved);\n    }\n\n    /**\n     * Retrieves the MenuItem object for the corresponding id.\n     * @param {string} id\n     * @return {MenuItem}\n     */\n    function getMenuItem(id) {\n        return menuItemMap[id];\n    }\n\n    function _getHTMLMenu(id) {\n        return $(\"#\" + StringUtils.jQueryIdEscape(id)).get(0);\n    }\n\n    function _getHTMLMenuItem(id) {\n        return $(\"#\" + StringUtils.jQueryIdEscape(id)).get(0);\n    }\n\n    function _addKeyBindingToMenuItem(commandID, $menuItem, key, displayKey) {\n        let $shortcut = $menuItem.find(\".menu-shortcut\");\n\n        if ($shortcut.length === 0) {\n            const html = KeyBindingManager.canAssignBinding(commandID)?\n                \"<span class='menu-shortcut' />\" :\n                \"<span class='menu-shortcut fixed-shortcut' />\";\n            $shortcut = $(html);\n            $menuItem.append($shortcut);\n        }\n\n        $shortcut.data(\"key\", key);\n        $shortcut.text(KeyBindingManager.formatKeyDescriptor(displayKey));\n    }\n\n    function _addExistingKeyBinding(menuItem) {\n        const commandID = menuItem.getCommand().getID();\n        let bindings = KeyBindingManager.getKeyBindings(commandID),\n            binding = null;\n\n        if (bindings.length > 0) {\n            // add the latest key binding\n            binding = bindings[bindings.length - 1];\n            _addKeyBindingToMenuItem(commandID, $(_getHTMLMenuItem(menuItem.id)), binding.key, binding.displayKey);\n        }\n\n        return binding;\n    }\n\n    let _menuDividerIDCount = 1;\n    function _getNextMenuItemDividerID() {\n        return \"brackets-menuDivider-\" + _menuDividerIDCount++;\n    }\n\n    // Help function for inserting elements into a list\n    function _insertInList($list, $element, position, $relativeElement) {\n        // Determine where to insert. Default is LAST.\n        let inserted = false;\n        if (position) {\n\n            // Adjust relative position for menu section positions since $relativeElement\n            // has already been resolved by _getRelativeMenuItem() to a menuItem\n            if (position === FIRST_IN_SECTION) {\n                position = BEFORE;\n            } else if (position === LAST_IN_SECTION) {\n                position = AFTER;\n            }\n\n            if (position === FIRST) {\n                $list.prepend($element);\n                inserted = true;\n            } else if ($relativeElement && $relativeElement.length > 0) {\n                if (position === AFTER) {\n                    $relativeElement.after($element);\n                    inserted = true;\n                } else if (position === BEFORE) {\n                    $relativeElement.before($element);\n                    inserted = true;\n                }\n            }\n        }\n\n        // Default to LAST\n        if (!inserted) {\n            $list.append($element);\n        }\n    }\n\n    /**\n     * MenuItem represents a single menu item that executes a Command or a menu divider. MenuItems\n     * may have a sub-menu. A MenuItem may correspond to an HTML-based\n     * menu item or a native menu item if Brackets is running in a native application shell\n     *\n     * Since MenuItems may have a native implementation clients should create MenuItems through\n     * addMenuItem() and should NOT construct a MenuItem object directly.\n     * Clients should also not access HTML content of a menu directly and instead use\n     * the MenuItem API to query and modify menus items.\n     *\n     * MenuItems are views on to Command objects so modify the underlying Command to modify the\n     * name, enabled, and checked state of a MenuItem. The MenuItem will update automatically\n     *\n     * @constructor\n     * @private\n     *\n     * @param {string} id\n     * @param {string|Command} command - the Command this MenuItem will reflect.\n     *                                   Use DIVIDER to specify a menu divider\n     * @param [options]\n     * @param {boolean} options.hideWhenCommandDisabled will not show the menu item if command is disabled.\n     */\n    function MenuItem(id, command, options = {}) {\n        this.id = id;\n        this.isDivider = (command === DIVIDER);\n        this.isNative = false;\n\n        if (!this.isDivider && command !== SUBMENU) {\n            // Bind event handlers\n            this._enabledChanged = this._enabledChanged.bind(this);\n            this._checkedChanged = this._checkedChanged.bind(this);\n            this._nameChanged = this._nameChanged.bind(this);\n            this._keyBindingAdded = this._keyBindingAdded.bind(this);\n            this._keyBindingRemoved = this._keyBindingRemoved.bind(this);\n\n            this._command = command;\n            this._hideWhenCommandDisabled = options.hideWhenCommandDisabled;\n            this._command\n                .on(\"enabledStateChange\", this._enabledChanged)\n                .on(\"checkedStateChange\", this._checkedChanged)\n                .on(\"nameChange\", this._nameChanged)\n                .on(\"keyBindingAdded\", this._keyBindingAdded)\n                .on(\"keyBindingRemoved\", this._keyBindingRemoved);\n        }\n    }\n\n    /**\n     * Menu represents a top-level menu in the menu bar. A Menu may correspond to an HTML-based\n     * menu or a native menu if Brackets is running in a native application shell.\n     *\n     * Since menus may have a native implementation clients should create Menus through\n     * addMenu() and should NOT construct a Menu object directly.\n     * Clients should also not access HTML content of a menu directly and instead use\n     * the Menu API to query and modify menus.\n     *\n     * @constructor\n     * @private\n     *\n     * @param {string} id\n     */\n    function Menu(id) {\n        this.id = id;\n    }\n\n    Menu.prototype._getMenuItemId = function (commandId) {\n        return (this.id + \"-\" + commandId);\n    };\n\n    /**\n     * Determine MenuItem in this Menu, that has the specified command\n     *\n     * @param {Command} command - the command to search for.\n     * @return {?HTMLLIElement} menu item list element\n     */\n    Menu.prototype._getMenuItemForCommand = function (command) {\n        if (!command) {\n            return null;\n        }\n        let foundMenuItem = menuItemMap[this._getMenuItemId(command.getID())];\n        if (!foundMenuItem) {\n            return null;\n        }\n        return $(_getHTMLMenuItem(foundMenuItem.id)).closest(\"li\");\n    };\n\n    /**\n     * Determine relative MenuItem\n     *\n     * @param {?string} relativeID - id of command (future: sub-menu).\n     * @param {?string} position - only needed when relativeID is a MenuSection\n     * @return {?HTMLLIElement} menu item list element\n     */\n    Menu.prototype._getRelativeMenuItem = function (relativeID, position) {\n        let $relativeElement;\n\n        if (relativeID) {\n            if (position === FIRST_IN_SECTION || position === LAST_IN_SECTION) {\n                if (!relativeID.hasOwnProperty(\"sectionMarker\")) {\n                    console.error(\"Bad Parameter in _getRelativeMenuItem(): relativeID must be a MenuSection when position refers to a menu section\");\n                    return null;\n                }\n\n                // Determine the $relativeElement by traversing the sibling list and\n                // stop at the first divider found\n                // TODO: simplify using nextUntil()/prevUntil()\n                let $sectionMarker = this._getMenuItemForCommand(CommandManager.get(relativeID.sectionMarker));\n                if (!$sectionMarker) {\n                    console.error(\"_getRelativeMenuItem(): MenuSection \" + relativeID.sectionMarker +\n                                  \" not found in Menu \" + this.id);\n                    return null;\n                }\n                let $listElem = $sectionMarker;\n                $relativeElement = $listElem;\n                while (true) {\n                    $listElem = (position === FIRST_IN_SECTION ? $listElem.prev() : $listElem.next());\n                    if ($listElem.length === 0) {\n                        break;\n                    } else if ($listElem.find(\".divider\").length > 0) {\n                        break;\n                    } else {\n                        $relativeElement = $listElem;\n                    }\n                }\n\n            } else {\n                if (relativeID.hasOwnProperty(\"sectionMarker\")) {\n                    console.error(\"Bad Parameter in _getRelativeMenuItem(): if relativeID is a MenuSection, position must be FIRST_IN_SECTION or LAST_IN_SECTION\");\n                    return null;\n                }\n\n                // handle FIRST, LAST, BEFORE, & AFTER\n                let command = CommandManager.get(relativeID);\n                if (command) {\n                    // Lookup Command for this Command id\n                    // Find MenuItem that has this command\n                    $relativeElement = this._getMenuItemForCommand(command);\n                }\n                if (!$relativeElement) {\n                    console.error(\"_getRelativeMenuItem(): MenuItem with Command id \" + relativeID +\n                                  \" not found in Menu \" + this.id);\n                    return null;\n                }\n            }\n\n            return $relativeElement;\n\n        } else if (position && position !== FIRST && position !== LAST) {\n            console.error(\"Bad Parameter in _getRelativeMenuItem(): relative position specified with no relativeID\");\n            return null;\n        }\n\n        return $relativeElement;\n    };\n\n    /**\n     * Removes the specified menu item from this Menu. Key bindings are unaffected; use KeyBindingManager\n     * directly to remove key bindings if desired.\n     *\n     * @param {!string | Command} command - command the menu would execute if we weren't deleting it.\n     */\n    Menu.prototype.removeMenuItem = function (command) {\n        let menuItemID,\n            commandID;\n\n        if (!command) {\n            console.error(\"removeMenuItem(): missing required parameters: command\");\n            return;\n        }\n\n        if (typeof (command) === \"string\") {\n            let commandObj = CommandManager.get(command);\n            if (!commandObj) {\n                console.error(\"removeMenuItem(): command not found: \" + command);\n                return;\n            }\n            commandID = command;\n        } else {\n            commandID = command.getID();\n        }\n        menuItemID = this._getMenuItemId(commandID);\n\n        let menuItem = getMenuItem(menuItemID);\n        removeMenuItemEventListeners(menuItem);\n\n        $(_getHTMLMenuItem(menuItemID)).parent().remove();\n\n        delete menuItemMap[menuItemID];\n    };\n\n    /**\n     * Removes the specified menu divider from this Menu.\n     *\n     * @param {!string} menuItemID - the menu item id of the divider to remove.\n     */\n    Menu.prototype.removeMenuDivider = function (menuItemID) {\n        let menuItem,\n            $HTMLMenuItem;\n\n        if (!menuItemID) {\n            console.error(\"removeMenuDivider(): missing required parameters: menuItemID\");\n            return;\n        }\n\n        menuItem = getMenuItem(menuItemID);\n\n        if (!menuItem) {\n            console.error(\"removeMenuDivider(): parameter menuItemID: %s is not a valid menu item id\", menuItemID);\n            return;\n        }\n\n        if (!menuItem.isDivider) {\n            console.error(\"removeMenuDivider(): parameter menuItemID: %s is not a menu divider\", menuItemID);\n            return;\n        }\n\n        // Targeting parent to get the menu divider <hr> and the <li> that contains it\n        $HTMLMenuItem = $(_getHTMLMenuItem(menuItemID)).parent();\n        if ($HTMLMenuItem) {\n            $HTMLMenuItem.remove();\n        } else {\n            console.error(\"removeMenuDivider(): HTML menu divider not found: %s\", menuItemID);\n            return;\n        }\n\n        if (!menuItemMap[menuItemID]) {\n            console.error(\"removeMenuDivider(): menu divider not found in menuItemMap: %s\", menuItemID);\n            return;\n        }\n\n        delete menuItemMap[menuItemID];\n    };\n\n    /**\n     * Adds a new menu item with the specified id and display text. The insertion position is\n     * specified via the relativeID and position arguments which describe a position\n     * relative to another MenuItem or MenuGroup. It is preferred that plug-ins\n     * insert new  MenuItems relative to a menu section rather than a specific\n     * MenuItem (see Menu Section Constants).\n     *\n     * TODO: Sub-menus are not yet supported, but when they are implemented this API will\n     * allow adding new MenuItems to sub-menus as well.\n     *\n     * Note, keyBindings are bound to Command objects not MenuItems. The provided keyBindings\n     *      will be bound to the supplied Command object rather than the MenuItem.\n     *\n     * @param {!string | Command} command - the command the menu will execute.\n     *      Pass Menus.DIVIDER for a menu divider, or just call addMenuDivider() instead.\n     * @param {?string | Array.<{key: string, platform: string}>}  [keyBindings] - register one\n     *      one or more key bindings to associate with the supplied command.\n     * @param {?string} [position] - constant defining the position of new MenuItem relative to\n     *      other MenuItems. Values:\n     *          - With no relativeID, use Menus.FIRST or LAST (default is LAST)\n     *          - Relative to a command id, use BEFORE or AFTER (required)\n     *          - Relative to a MenuSection, use FIRST_IN_SECTION or LAST_IN_SECTION (required)\n     * @param {?string} [relativeID] - command id OR one of the MenuSection.* constants. Required\n     *      for all position constants except FIRST and LAST.\n     * @param [options]\n     * @param {boolean} options.hideWhenCommandDisabled will not show the menu item if command is disabled. Helps to\n     *   clear the clutter on greyed out menu items if not applicable to context.\n     *\n     * @return {MenuItem} the newly created MenuItem\n     */\n    Menu.prototype.addMenuItem = function (command, keyBindings, position, relativeID, options = {}) {\n        const self = this;\n        let id,\n            $menuItem,\n            menuItem,\n            name,\n            commandID;\n\n        if (!command) {\n            console.error(\"addMenuItem(): missing required parameters: command\");\n            return null;\n        }\n\n        if (typeof (command) === \"string\") {\n            if (command === DIVIDER) {\n                name = DIVIDER;\n                commandID = _getNextMenuItemDividerID();\n            } else {\n                commandID = command;\n                command = CommandManager.get(commandID);\n                if (!command) {\n                    console.error(\"addMenuItem(): commandID not found: \" + commandID);\n                    return null;\n                }\n                name = command.getName();\n            }\n        } else {\n            commandID = command.getID();\n            name = command.getName();\n        }\n\n        // Internal id is the a composite of the parent menu id and the command id.\n        id = self._getMenuItemId(commandID);\n\n        if (menuItemMap[id]) {\n            console.log(\"MenuItem added with same id of existing MenuItem: \" + id);\n            return null;\n        }\n\n        // create MenuItem\n        menuItem = new MenuItem(id, command, {\n            hideWhenCommandDisabled: options.hideWhenCommandDisabled\n        });\n        menuItemMap[id] = menuItem;\n\n\n        if (name === DIVIDER) {\n            $menuItem = $(\"<li><hr class='divider' id='\" + id + \"' /></li>\");\n        } else {\n            // Create the HTML Menu\n            let keyboardIcon = '';\n            if(KeyBindingManager.canAssignBinding(commandID)){\n                keyboardIcon = `<span class='keyboard-icon' title='${Strings.KEYBOARD_SHORTCUT_CHANGE_TITLE}'><i class=\"fa-regular fa-keyboard\"></i></span>`;\n            }\n            $menuItem = $(\"<li><a href='#' class='menuAnchor' id='\" + id + \"'> <span class='menu-name'></span>\" +\n                `<span class='right-pusher'></span>${keyboardIcon}`+\n                \"</a></li>\");\n            const $menuAnchor = $menuItem.find(\".menuAnchor\");\n\n            $menuItem.find(\".keyboard-icon\").on(\"click\", (event)=>{\n                KeyBindingManager.showShortcutSelectionDialog(command);\n                event.preventDefault();\n                event.stopPropagation();\n            });\n\n            $menuItem.on(\"click\", function (event) {\n                if($menuAnchor.hasClass('disabled')){\n                    event.preventDefault();\n                    event.stopPropagation();\n                    return true;\n                }\n                Metrics.countEvent(Metrics.EVENT_TYPE.UI_MENU, \"click\", menuItem._command.getID());\n                logger.leaveTrail(\"UI Menu Click: \" + menuItem._command.getID());\n                MainViewManager.focusActivePane();\n                if(menuItem._command._options.eventSource){\n                    menuItem._command.execute({\n                        eventSource: CommandManager.SOURCE_UI_MENU_CLICK,\n                        sourceType: self.id\n                    });\n                } else {\n                    menuItem._command.execute();\n                }\n            });\n\n            let self = this;\n            $menuItem.on(\"mouseenter\", function () {\n                // This is to prevent size jumps when the keyboard\n                // icon hides and shows as selection changes\n                const currentWidth = $(this).width(); // Get the current width\n                $(this).css('min-width', currentWidth + 'px');\n                self.closeSubMenu();\n                // now show selection\n                $menuItem.parent().find(\".menuAnchor\").removeClass(\"selected\");\n                if(!$menuAnchor.hasClass('disabled')){\n                    $menuAnchor.addClass(\"selected\");\n                }\n            });\n            $menuItem.on(\"mouseleave\", function () {\n                $(this).css('min-width', '');\n                self.closeSubMenu();\n                $menuItem.find(\".menuAnchor\").removeClass(\"selected\");\n            });\n        }\n\n        // Insert menu item\n        let $relativeElement = this._getRelativeMenuItem(relativeID, position);\n        _insertInList($(\"li#\" + StringUtils.jQueryIdEscape(this.id) + \" > ul.dropdown-menu\"),\n                      $menuItem, position, $relativeElement);\n\n\n        // Initialize MenuItem state\n        if (menuItem.isDivider) {\n            menuItem.dividerId = commandID;\n        } else {\n            if (keyBindings) {\n                // Add key bindings. The MenuItem listens to the Command object to update MenuItem DOM with shortcuts.\n                if (!Array.isArray(keyBindings)) {\n                    keyBindings = [keyBindings];\n                }\n            }\n\n            // Note that keyBindings passed during MenuItem creation take precedent over any existing key bindings\n            KeyBindingManager.addBinding(commandID, keyBindings);\n\n            // Look for existing key bindings\n            _addExistingKeyBinding(menuItem);\n\n            menuItem._checkedChanged();\n            menuItem._enabledChanged();\n            menuItem._nameChanged();\n        }\n\n        return menuItem;\n    };\n\n    /**\n     * Inserts divider item in menu.\n     * @param {?string} position - constant defining the position of new the divider relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants).\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      divider will be positioned relative to. Required for all position constants\n     *      except FIRST and LAST\n     *\n     * @return {MenuItem} the newly created divider\n     */\n    Menu.prototype.addMenuDivider = function (position, relativeID) {\n        return this.addMenuItem(DIVIDER, \"\", position, relativeID);\n    };\n\n    /**\n     * NOT IMPLEMENTED\n     * Alternative JSON based API to addMenuItem()\n     *\n     * All properties are required unless noted as optional.\n     *\n     * @param { Array.<{\n     *              id:         string,\n     *              command:    string | Command,\n     *              ?bindings:   string | Array.<{key: string, platform: string}>,\n     *          }>} jsonStr\n     *        }\n     * @param {?string} position - constant defining the position of new the MenuItem relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants).\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      menuItem will be positioned relative to. Required when position is\n     *      AFTER or BEFORE, ignored when position is FIRST or LAST.\n     *\n     * @return {MenuItem} the newly created MenuItem\n     */\n    // Menu.prototype.createMenuItemsFromJSON = function (jsonStr, position, relativeID) {\n    //     NOT IMPLEMENTED\n    // };\n\n\n    /**\n     * NOT IMPLEMENTED\n     * @param {!string} text displayed in menu item\n     * @param {!string} id\n     * @param {?string} position - constant defining the position of new the MenuItem relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants)\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      menuItem will be positioned relative to. Required when position is\n     *      AFTER or BEFORE, ignored when position is FIRST or LAST.\n     *\n     * @return {MenuItem} newly created menuItem for sub-menu\n     */\n    // MenuItem.prototype.createSubMenu = function (text, id, position, relativeID) {\n    //     NOT IMPLEMENTED\n    // };\n\n    /**\n     *\n     * Creates a new submenu and a menuItem and adds the menuItem of the submenu\n     * to the menu and returns the submenu.\n     *\n     * A submenu will have the same structure of a menu with a additional field\n     * parentMenuItem which has the reference of the submenu's parent menuItem.\n\n     * A submenu will raise the following events:\n     * - beforeSubMenuOpen\n     * - beforeSubMenuClose\n     *\n     * Note, This function will create only a context submenu.\n     *\n     * TODO: Make this function work for Menus\n     *\n     *\n     * @param {!string} name displayed in menu item of the submenu\n     * @param {!string} id\n     * @param {?string} position - constant defining the position of new MenuItem of the submenu relative to\n     *      other MenuItems. Values:\n     *          - With no relativeID, use Menus.FIRST or LAST (default is LAST)\n     *          - Relative to a command id, use BEFORE or AFTER (required)\n     *          - Relative to a MenuSection, use FIRST_IN_SECTION or LAST_IN_SECTION (required)\n     * @param {?string} relativeID - command id OR one of the MenuSection.* constants. Required\n     *      for all position constants except FIRST and LAST.\n     *\n     * @return {Menu} the newly created submenu\n     */\n    Menu.prototype.addSubMenu = function (name, id, position, relativeID) {\n\n        if (!name || !id) {\n            console.error(\"addSubMenu(): missing required parameters: name and id\");\n            return null;\n        }\n\n        // Guard against duplicate context menu ids\n        if (contextMenuMap[id]) {\n            console.log(\"Context menu added with id of existing Context Menu: \" + id);\n            return null;\n        }\n\n        let menu = new ContextMenu(id);\n        contextMenuMap[id] = menu;\n\n        let menuItemID = this.id + \"-\" + id;\n\n        if (menuItemMap[menuItemID]) {\n            console.log(\"MenuItem added with same id of existing MenuItem: \" + id);\n            return null;\n        }\n\n        // create MenuItem\n        let menuItem = new MenuItem(menuItemID, SUBMENU);\n        menuItemMap[menuItemID] = menuItem;\n        subMenuItemMap[menuItemID] = menu;\n\n        menu.parentMenuItem = menuItem;\n\n        // create MenuItem DOM\n        // Create the HTML MenuItem\n        let $menuItem = $(\"<li><a class='sub-menu-item menuAnchor' href='#' id='\" + menuItemID + \"'> \"   +\n                         \"<span class='menu-name'>\" + name + \"</span>\" +\n                         \"<span class='right-pusher'></span>\" +\n                         \"<span>&rtrif;</span>\"   +\n                         \"</a></li>\");\n\n        let self = this;\n        $menuItem.on(\"mouseenter\", function(e) {\n            const currentWidth = $(this).width(); // Get the current width\n            $(this).css('min-width', currentWidth + 'px'); // Set min-width to the current width\n            if (self.openSubMenu && self.openSubMenu.id === menu.id) {\n                return;\n            }\n            self.closeSubMenu();\n            self.openSubMenu = menu;\n            menu.open();\n            $menuItem.parent().find(\".menuAnchor\").removeClass(\"selected\");\n            $menuItem.find(\".menuAnchor\").addClass(\"selected\");\n        });\n\n        $menuItem.on(\"mouseleave\", function () {\n            $(this).css('min-width', '');\n            $menuItem.find(\".menuAnchor\").removeClass(\"selected\");\n        });\n\n        // Insert menu item\n        let $relativeElement = this._getRelativeMenuItem(relativeID, position);\n        _insertInList($(\"li#\" + StringUtils.jQueryIdEscape(this.id) + \" > ul.dropdown-menu\"),\n        $menuItem, position, $relativeElement);\n\n        return menu;\n    };\n\n\n    /**\n     * Removes the specified submenu from this Menu.\n     *\n     * Note, this function will only remove context submenus\n     *\n     * TODO: Make this function work for Menus\n     *\n     * @param {!string} subMenuID - the menu id of the submenu to remove.\n     */\n    Menu.prototype.removeSubMenu = function (subMenuID) {\n        let subMenu,\n            parentMenuItem,\n            commandID = \"\";\n\n        if (!subMenuID) {\n            console.error(\"removeSubMenu(): missing required parameters: subMenuID\");\n            return;\n        }\n\n        subMenu = getContextMenu(subMenuID);\n\n        if (!subMenu || !subMenu.parentMenuItem) {\n            console.error(\"removeSubMenu(): parameter subMenuID: %s is not a valid submenu id\", subMenuID);\n            return;\n        }\n\n        parentMenuItem = subMenu.parentMenuItem;\n\n\n        if (!menuItemMap[parentMenuItem.id]) {\n            console.error(\"removeSubMenu(): parent menuItem not found in menuItemMap: %s\", parentMenuItem.id);\n            return;\n        }\n\n        // Remove all of the menu items in the submenu\n        _.forEach(menuItemMap, function (value, key) {\n            if (_.startsWith(key, subMenuID)) {\n                if (value.isDivider) {\n                    subMenu.removeMenuDivider(key);\n                } else {\n                    commandID = value.getCommand();\n                    subMenu.removeMenuItem(commandID);\n                }\n            }\n        });\n\n        $(_getHTMLMenuItem(parentMenuItem.id)).parent().remove(); // remove the menu item\n        $(_getHTMLMenu(subMenuID)).remove(); // remove the menu\n\n\n        delete menuItemMap[parentMenuItem.id];\n        delete subMenuItemMap[parentMenuItem.id];\n        delete contextMenuMap[subMenuID];\n    };\n\n    /**\n     * Closes the submenu if the menu has a submenu open.\n     */\n    Menu.prototype.closeSubMenu = function() {\n        if (this.openSubMenu) {\n            this.openSubMenu.close();\n            this.openSubMenu = null;\n        }\n    };\n    /**\n     * Gets the Command associated with a MenuItem\n     * @return {Command}\n     */\n    MenuItem.prototype.getCommand = function () {\n        return this._command;\n    };\n\n    /**\n     * NOT IMPLEMENTED\n     * Returns the parent MenuItem if the menu item is a sub-menu, returns null otherwise.\n     * @return {MenuItem}\n     */\n    // MenuItem.prototype.getParentMenuItem = function () {\n    //     NOT IMPLEMENTED;\n    // };\n\n    /**\n     * Returns the parent Menu for this MenuItem\n     * @return {Menu}\n     */\n    MenuItem.prototype.getParentMenu = function () {\n        let parent = $(_getHTMLMenuItem(this.id)).parents(\".dropdown\").get(0);\n        if (!parent) {\n            return null;\n        }\n\n        return getMenu(parent.id);\n    };\n\n    /**\n     * Synchronizes MenuItem checked state with underlying Command checked state\n     */\n    MenuItem.prototype._checkedChanged = function () {\n        let checked = !!this._command.getChecked();\n        if (this.isNative) {\n            let enabled = !!this._command.getEnabled();\n            let command = this._command;\n            brackets.app.setMenuItemState(this._command.getID(), enabled, checked, function (err) {\n                if (err) {\n                    console.log(\"Error setting menu item checked state for \" + command + \": \" + err);\n                }\n            });\n        } else {\n            ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), \"checked\", checked);\n        }\n    };\n\n    /**\n     * Synchronizes MenuItem enabled state with underlying Command enabled state\n     */\n    MenuItem.prototype._enabledChanged = function () {\n        if (this.isNative) {\n            let enabled = !!this._command.getEnabled();\n            let checked = !!this._command.getChecked();\n            let command = this._command;\n            brackets.app.setMenuItemState(this._command.getID(), enabled, checked, function (err) {\n                if (err) {\n                    console.log(\"Error setting menu item enabled state for \" + command + \": \" + err);\n                }\n            });\n        } else {\n            ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), \"disabled\", !this._command.getEnabled());\n            if(this._hideWhenCommandDisabled){\n                ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), \"forced-hidden\", !this._command.getEnabled());\n            }\n        }\n    };\n\n    /**\n     * Synchronizes MenuItem name with underlying Command name\n     */\n    MenuItem.prototype._nameChanged = function () {\n        if (this.isNative) {\n            let command = this._command;\n            brackets.app.setMenuTitle(this._command.getID(), this._command.getName(), function (err) {\n                if (err) {\n                    console.log(\"Error setting menu title for \" + command + \": \" + err);\n                }\n            });\n        } else {\n            $(_getHTMLMenuItem(this.id)).find(\".menu-name\").text(this._command.getName());\n        }\n    };\n\n    /**\n     * @private\n     * Updates MenuItem DOM with a keyboard shortcut label\n     */\n    MenuItem.prototype._keyBindingAdded = function (event, keyBinding) {\n        if (this.isNative) {\n            let shortcutKey = keyBinding.displayKey || keyBinding.key,\n                command = this._command;\n            brackets.app.setMenuItemShortcut(this._command.getID(), shortcutKey, KeyBindingManager.formatKeyDescriptor(shortcutKey), function (err) {\n                if (err) {\n                    console.error(\"Error setting menu item shortcut key \" + shortcutKey + \", \" + command + \" : \" + err );\n                }\n            });\n        } else {\n            _addKeyBindingToMenuItem(this._command.getID(), $(_getHTMLMenuItem(this.id)), keyBinding.key, keyBinding.displayKey);\n        }\n    };\n\n    /**\n     * @private\n     * Updates MenuItem DOM to remove keyboard shortcut label\n     */\n    MenuItem.prototype._keyBindingRemoved = function (event, keyBinding) {\n        if (this.isNative) {\n            let shortcutKey = keyBinding.displayKey || keyBinding.key,\n                command = this._command;\n            brackets.app.setMenuItemShortcut(this._command.getID(), \"\", \"\", function (err) {\n                if (err) {\n                    console.error(\"Error setting menu item shortcut: \" + err, shortcutKey, command);\n                }\n            });\n        } else {\n            let $shortcut = $(_getHTMLMenuItem(this.id)).find(\".menu-shortcut\");\n\n            if ($shortcut.length > 0 && $shortcut.data(\"key\") === keyBinding.key) {\n                // check for any other bindings\n                if (_addExistingKeyBinding(this) === null) {\n                    $shortcut.empty();\n                }\n            }\n        }\n    };\n\n    let lastOpenedMenuID = 'file-menu';\n    /**\n     * Closes all menus that are open\n     */\n    function closeAll() {\n        const $openDropdownMenuList = $(\"#titlebar .dropdown.open\");\n        if($openDropdownMenuList.length){\n            // this means the title bar has focus on close, and we have to focus editor in this case.\n            MainViewManager.focusActivePane();\n        }\n        if(getOpenMenu()){\n            lastOpenedMenuID = getOpenMenu();\n        }\n        $(\".dropdown\").removeClass(\"open\");\n    }\n\n    function _closeAllSubMenus() {\n        for(let menu of Object.values(menuMap)){\n            menu.closeSubMenu();\n        }\n    }\n\n    function openMenu(id) {\n        if(!id){\n            id = lastOpenedMenuID;\n        }\n        if (!menuMap[id]) {\n            console.error(\"openMenu- no such menu: \" + id);\n            return null;\n        }\n        $(`#${getDropdownToggleMenuID(id)}`).click();\n    }\n\n    /**\n     * returns the currently open menu id if present or null\n     * @return {null|string}\n     */\n    function getOpenMenu() {\n        const $openDropdownMenuList = $(\"#titlebar .dropdown.open\");\n        if($openDropdownMenuList.length !== 1){\n            return null;\n        }\n        return $openDropdownMenuList[0].id;\n    }\n\n    function getDropdownToggleMenuID(id) {\n        return `${id}-dropdown-toggle`;\n    }\n\n    let assignedShortcutsMenus = {};\n    let altKeyReleased = true;\n    window.document.body.addEventListener(\n        \"keyup\",\n        (event)=>{\n            if(event.key === KEY.ALT){\n                altKeyReleased = true;\n            }\n        },\n        true\n    );\n    function _addAltMenuShortcut(menuName, id) {\n        if (brackets.platform === \"mac\") {\n            // Alt menu shortcuts are unavailable on macOS due to its UI conventions(Alt is reserved for AltGr\n            // international keyboard typing).\n            // On macOS, menus can be accessed by double-pressing the Command key instead.\n            return;\n        }\n        let shortCutKey = menuName[0].toUpperCase();\n        if(assignedShortcutsMenus[shortCutKey]){\n            assignedShortcutsMenus[shortCutKey].push({menuName, id});\n            // now the array may have second leter shortcut like Eg. for like letter i = [Find] sinse File is already\n            // registered with F. So when we try to insert a new menu item say `Inspect` which should ideally take\n            // precedence for the i key shortcut, we have to remove all second elemnts in array that doent start with\n            // the first letter shortcut.\n            const newShortcutList = [];\n            for(let menu of assignedShortcutsMenus[shortCutKey]){\n                if(menu.menuName.toUpperCase().startsWith(shortCutKey)){\n                    // remove all shortcuts that doesnt have the first letter as the shortcut\n                    newShortcutList.push(menu);\n                }\n            }\n            assignedShortcutsMenus[shortCutKey] = newShortcutList;\n            // the shortcut key is already registered, check if can use the second letter to register\n            // an alternate single letter shortcut\n            const secondLetterShortCutKey = menuName[1];\n            if(secondLetterShortCutKey && assignedShortcutsMenus[secondLetterShortCutKey]) {\n                // the second letter is taken too, we dont do anything in this case.\n                return;\n            }\n            shortCutKey = secondLetterShortCutKey;\n        }\n        assignedShortcutsMenus[shortCutKey] = [{menuName, id}];\n        const menuShortcutCommandID = `AltMenu-${shortCutKey}`;\n        console.log(`Registering 'Alt-${shortCutKey}' menu shortcut handler..`);\n        CommandManager.register(`Menu Shortcut For ${shortCutKey}`, menuShortcutCommandID, function () {\n            const menusIdsForShortcut = assignedShortcutsMenus[shortCutKey].map(item => item.id);\n            if(altKeyReleased){\n                // this happens if the user started a new session of pressing alt-followed by key to open menu.\n                // we have to open the first menu item in this case.\n                altKeyReleased = false;\n                openMenu(menusIdsForShortcut[0]);\n                return true;\n            }\n            // if we are here, then another manu is already open as user is trying switch between two menus with same\n            // shortcut. Eg. Alt-F -file menu is open, switch to find menu.\n            let currentIndex = menusIdsForShortcut.indexOf(lastOpenedMenuID);\n            let menuToOpen;\n            // Check if the current menu is the last in the array or if it's not found (-1)\n            if (currentIndex === -1 || currentIndex === menusIdsForShortcut.length - 1) {\n                // If so, circle back to the first menu\n                menuToOpen = menusIdsForShortcut[0];\n            } else {\n                // Otherwise, go to the next menu\n                menuToOpen = menusIdsForShortcut[currentIndex + 1];\n            }\n            openMenu(menuToOpen);\n            return true;\n        });\n        KeyBindingManager.addBinding(menuShortcutCommandID, `Alt-${shortCutKey}`, null, {isMenuShortcut: true});\n    }\n\n    /**\n     * Adds a top-level menu to the application menu bar which may be native or HTML-based.\n     *\n     * @param {!string} name - display text for menu\n     * @param {!string} id - unique identifier for a menu.\n     *      Core Menus in Brackets use a simple  title as an id, for example \"file-menu\".\n     *      Extensions should use the following format: \"author.myextension.mymenuname\".\n     * @param {?string} position - constant defining the position of new the Menu relative\n     *  to other Menus. Default is LAST (see Insertion position constants).\n     *\n     * @param {?string} relativeID - id of Menu the new Menu will be positioned relative to. Required\n     *      when position is AFTER or BEFORE, ignored when position is FIRST or LAST\n     *\n     * @return {?Menu} the newly created Menu\n     */\n    function addMenu(name, id, position, relativeID) {\n        name = _.escape(name);\n        let $menubar = $(\"#titlebar .nav\"),\n            menu;\n\n        if (!name || !id) {\n            console.error(\"call to addMenu() is missing required parameters\");\n            return null;\n        }\n\n        // Guard against duplicate menu ids\n        if (menuMap[id]) {\n            console.log(\"Menu added with same name and id of existing Menu: \" + id);\n            return null;\n        }\n\n        menu = new Menu(id);\n        menuMap[id] = menu;\n\n\n        let $toggle = $(`<a id=\"${getDropdownToggleMenuID(id)}\" href='#' class='dropdown-toggle' data-toggle='dropdown'>${name}</a>`),\n            $popUp = $(\"<ul class='dropdown-menu'></ul>\"),\n            $dropdown = $(\"<li class='dropdown' id='\" + id + \"'></li>\"),\n            $newMenu = $dropdown.append($toggle).append($popUp);\n\n        $toggle.on(\"mouseenter\", function() {\n            _closeAllSubMenus();\n            const $this = $(this); // Cache the jQuery object of the current element\n\n            // Check if '#titlebar' or any of its descendants has focus\n            if ($('#titlebar, #titlebar *').is(':focus')) {\n                // If '#titlebar' or a descendant has focus, add 'selected' class and focus the current element\n                $this.addClass('selected').focus();\n            } else {\n                // Otherwise, just add 'selected' class\n                $this.addClass('selected');\n            }\n        });\n\n        $toggle.on(\"mouseleave\", function() {\n            $(this).removeClass('selected');\n        });\n\n        // Insert menu\n        let $relativeElement = relativeID && $(_getHTMLMenu(relativeID));\n        _insertInList($menubar, $newMenu, position, $relativeElement);\n\n        // Install ESC key handling\n        PopUpManager.addPopUp($popUp, closeAll, false);\n\n        _addAltMenuShortcut(name, id);\n\n        return menu;\n    }\n\n    function _switchMenus($menuDropdownToggle, event) {\n        // remove the class 'open' from its parent element\n        $menuDropdownToggle.parent().removeClass('open');\n        const menuID = $menuDropdownToggle.parent().get(0).id;\n        const mainMenu = menuMap[menuID];\n        const $dropdownToggles = $('#titlebar .dropdown-toggle');\n        let currentIndex = $dropdownToggles.index($menuDropdownToggle);\n        currentIndex = event.key === KEY.ARROW_LEFT ? currentIndex - 1 : currentIndex + 1;\n        let nextIndex = currentIndex;\n        if(nextIndex < 0){\n            nextIndex = 0;\n        } else if (nextIndex >= $dropdownToggles.length){\n            nextIndex = $dropdownToggles.length - 1;\n        }\n        const $nextDropdownToggle = $dropdownToggles.eq(nextIndex);\n        $nextDropdownToggle.parent().addClass('open');\n        $nextDropdownToggle.focus();\n        lastOpenedMenuID = $nextDropdownToggle.parent()[0].id;\n        mainMenu && mainMenu.closeSubMenu();\n    }\n\n    function _switchMenuItems($menuDropdownToggle, event) {\n        // change code such that if event.key is KEY.ARROW_UP or KEY.ARROW_DOWN, the selection will move formward or back\n        const menuID = $menuDropdownToggle.parent().get(0).id;\n        const $dropdownMenu = $menuDropdownToggle.parent().find(\".dropdown-menu\");\n        const $selected = $dropdownMenu.find('li a.selected');\n        const currentWidth = $dropdownMenu.width();\n        $dropdownMenu.css('min-width', currentWidth + 'px'); // This is to prevent size jumps when the keyboard\n        // icon hides and shows as selection changes\n        if ($selected.length === 0) {\n            // If no selected class exists, add it to the first <a> tag\n            $dropdownMenu.find('li a').first().addClass('selected');\n        } else {\n            // Remove the class from the current item\n            $selected.removeClass('selected');\n\n            // Determine the next or previous item based on the arrow key pressed\n            let $next;\n            if (event.key === KEY.ARROW_DOWN) {\n                let $nextLi = $selected.closest('li').next('li');\n                $next = $nextLi.find('a');\n                while (($next.length === 0 || $next.hasClass('disabled') || !$next.is(':visible')) && $nextLi.length) {\n                    $nextLi = $nextLi.next('li');\n                    $next = $nextLi.find('a');\n                }\n                if($next.length === 0){\n                    $next = $dropdownMenu.find('li a').first();\n                }\n            } else if (event.key === KEY.ARROW_UP) {\n                let $prevLi = $selected.closest('li').prev('li');\n                $next = $prevLi.find('a');\n                while (($next.length === 0 || $next.hasClass('disabled') || !$next.is(':visible')) && $prevLi.length) {\n                    $prevLi = $prevLi.prev('li');\n                    $next = $prevLi.find('a');\n                }\n                if ($next.length === 0) {\n                    $next = $dropdownMenu.find('li a').last();\n                }\n            }\n\n            // Add the 'selected' class to the next item\n            $next.addClass('selected');\n            const mainMenu = menuMap[menuID];\n            if($next.hasClass(\"sub-menu-item\")){\n                const submenuID = $next.get(0).id;\n                const submenu = subMenuItemMap[submenuID];\n                if(submenu){\n                    mainMenu.closeSubMenu();\n                    mainMenu.openSubMenu = submenu;\n                    submenu.open();\n                }\n            } else {\n                mainMenu.closeSubMenu();\n            }\n        }\n    }\n    \n    function _execMenuItem($menuDropdownToggle, event) {\n        // change code such that if event.key is KEY.ARROW_UP or KEY.ARROW_DOWN, the selection will move formward or back\n        const $dropdownMenu = $menuDropdownToggle.parent().find(\".dropdown-menu\");\n        const $selected = $dropdownMenu.find('li a.selected');\n        if ($selected.length === 1 && $dropdownMenu.is(':visible')) {\n            // something is selected\n            MainViewManager.focusActivePane();\n            $selected.click();\n            event.preventDefault();\n            event.stopPropagation();\n            return true;\n        }\n    }\n\n    function menuKeyboardNavigationHandler(event) {\n        const allowedKeys = [KEY.ARROW_LEFT, KEY.ARROW_RIGHT, KEY.ARROW_UP, KEY.ARROW_DOWN,\n            KEY.ESCAPE, KEY.ENTER, KEY.RETURN];\n        if (!allowedKeys.includes(event.key)) {\n            return;\n        }\n        if ($('#titlebar, #titlebar *').is(':focus')) {\n            // If '#titlebar' or a descendant has focus, add 'selected' class and focus the current element\n            if(event.key === KEY.ESCAPE){\n                MainViewManager.focusActivePane();\n                event.preventDefault();\n                event.stopPropagation();\n                return;\n            }\n            const $focusedElement = $(':focus');\n            const isDescendantOfTitleBar = $focusedElement.closest('#titlebar').length > 0;\n            if(!isDescendantOfTitleBar){\n                return;\n            }\n            if($focusedElement.hasClass('dropdown-toggle')){\n                if(event.key === KEY.ARROW_LEFT || event.key === KEY.ARROW_RIGHT){\n                    // the main menu has focus, like file, edit etc..\n                    return _switchMenus($focusedElement, event);\n                } else if(event.key === KEY.ARROW_UP || event.key === KEY.ARROW_DOWN){\n                    return _switchMenuItems($focusedElement, event);\n                } else if(event.key === KEY.ENTER || event.key === KEY.RETURN || event.key === KEY.SPACE){\n                    return _execMenuItem($focusedElement, event);\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes a top-level menu from the application menu bar which may be native or HTML-based.\n     *\n     * @param {!string} id - unique identifier for a menu.\n     *      Core Menus in Brackets use a simple title as an id, for example \"file-menu\".\n     *      Extensions should use the following format: \"author.myextension.mymenuname\".\n     */\n    function removeMenu(id) {\n        let menu,\n            commandID = \"\";\n\n        if (!id) {\n            console.error(\"removeMenu(): missing required parameter: id\");\n            return;\n        }\n\n        if (!menuMap[id]) {\n            console.error(\"removeMenu(): menu id not found: %s\", id);\n            return;\n        }\n\n        // Remove all of the menu items in the menu\n        menu = getMenu(id);\n\n        _.forEach(menuItemMap, function (value, key) {\n            if (_.startsWith(key, id)) {\n                if (value.isDivider) {\n                    menu.removeMenuDivider(key);\n                } else {\n                    commandID = value.getCommand();\n                    menu.removeMenuItem(commandID);\n                }\n            }\n        });\n\n        $(_getHTMLMenu(id)).remove();\n\n        delete menuMap[id];\n    }\n\n    /**\n     * Represents a context menu that can open at a specific location in the UI.\n     *\n     * Clients should not create this object directly and should instead use registerContextMenu()\n     * to create new ContextMenu objects.\n     *\n     * Context menus in brackets may be HTML-based or native so clients should not reach into\n     * the HTML and should instead manipulate ContextMenus through the API.\n     *\n     * Events:\n     * - beforeContextMenuOpen\n     * - beforeContextMenuClose\n     *\n     * @constructor\n     * @extends {Menu}\n     */\n    function ContextMenu(id) {\n        Menu.apply(this, arguments);\n\n        let $newMenu = $(\"<li class='dropdown context-menu' id='\" + StringUtils.jQueryIdEscape(id) + \"'></li>\"),\n            $popUp = $(\"<ul class='dropdown-menu'></ul>\"),\n            $toggle = $(\"<a href='#' class='dropdown-toggle' data-toggle='dropdown'></a>\").hide();\n\n        // assemble the menu fragments\n        $newMenu.append($toggle).append($popUp);\n\n        // insert into DOM\n        $(\"#context-menu-bar > ul\").append($newMenu);\n\n        let self = this;\n        PopUpManager.addPopUp($popUp,\n            function () {\n                self.close();\n            },\n            false);\n\n        // Listen to ContextMenu's beforeContextMenuOpen event to first close other popups\n        PopUpManager.listenToContextMenu(this);\n    }\n    ContextMenu.prototype = Object.create(Menu.prototype);\n    ContextMenu.prototype.constructor = ContextMenu;\n    ContextMenu.prototype.parentClass = Menu.prototype;\n    EventDispatcher.makeEventDispatcher(ContextMenu.prototype);\n\n\n    /**\n     * Displays the ContextMenu at the specified location and dispatches the\n     * \"beforeContextMenuOpen\" event or \"beforeSubMenuOpen\" event (for submenus).\n     * The menu location may be adjusted to prevent clipping by the browser window.\n     * All other menus and ContextMenus will be closed before a new menu\n     * will be closed before a new menu is shown (if the new menu is not\n     * a submenu).\n     *\n     * In case of submenus, the parentMenu of the submenu will not be closed when the\n     * sub menu is open.\n     *\n     * @param {MouseEvent | {pageX:number, pageY:number}} mouseOrLocation - pass a MouseEvent\n     *      to display the menu near the mouse or pass in an object with page x/y coordinates\n     *      for a specific location.This paramter is not used for submenus. Submenus are always\n     *      displayed at a position relative to the parent menu.\n     */\n    ContextMenu.prototype.open = function (mouseOrLocation) {\n        Metrics.countEvent(Metrics.EVENT_TYPE.UI_MENU, \"contextMenuOpen\", this.id);\n        if (!this.parentMenuItem &&\n           (!mouseOrLocation || !mouseOrLocation.hasOwnProperty(\"pageX\") || !mouseOrLocation.hasOwnProperty(\"pageY\"))) {\n            console.error(\"ContextMenu open(): missing required parameter\");\n            return;\n        }\n\n        let $window = $(window),\n            escapedId = StringUtils.jQueryIdEscape(this.id),\n            $menuAnchor = $(\"#\" + escapedId),\n            $menuWindow = $(\"#\" + escapedId + \" > ul\"),\n            posTop,\n            posLeft;\n\n        // only show context menu if it has menu items\n        if ($menuWindow.children().length <= 0) {\n            return;\n        }\n\n\n        // adjust positioning so menu is not clipped off bottom or right\n        if (this.parentMenuItem) { // If context menu is a submenu\n\n            this.trigger(EVENT_BEFORE_SUB_MENU_OPEN);\n\n            let $parentMenuItem = $(_getHTMLMenuItem(this.parentMenuItem.id));\n\n            posTop = $parentMenuItem.offset().top;\n            posLeft = $parentMenuItem.offset().left + $parentMenuItem.outerWidth();\n\n            let elementRect = {\n                    top: posTop,\n                    left: posLeft,\n                    height: $menuWindow.height() + 25,\n                    width: $menuWindow.width()\n                },\n                clip = ViewUtils.getElementClipSize($window, elementRect);\n\n            if (clip.bottom > 0) {\n                posTop = Math.max(0, posTop + $parentMenuItem.height() - $menuWindow.height());\n            }\n\n            posTop -= 30;   // shift top for hidden parent element\n            posLeft += 3;\n\n            if (clip.right > 0) {\n                posLeft = Math.max(0, posLeft - $parentMenuItem.outerWidth() - $menuWindow.outerWidth());\n            }\n        } else {\n            this.trigger(EVENT_BEFORE_CONTEXT_MENU_OPEN);\n\n            // close all other dropdowns\n            closeAll();\n\n            posTop  = mouseOrLocation.pageY;\n            posLeft = mouseOrLocation.pageX;\n\n            let elementRect = {\n                    top: posTop,\n                    left: posLeft,\n                    height: $menuWindow.height() + 25,\n                    width: $menuWindow.width()\n                },\n                clip = ViewUtils.getElementClipSize($window, elementRect);\n\n            if (clip.bottom > 0) {\n                posTop = Math.max(0, posTop - clip.bottom);\n            }\n            posTop -= 30;   // shift top for hidden parent element\n            posLeft += 5;\n\n\n            if (clip.right > 0) {\n                posLeft = Math.max(0, posLeft - clip.right);\n            }\n        }\n\n        // open the context menu at final location\n        $menuAnchor.addClass(\"open\")\n                   .css({\"left\": posLeft, \"top\": posTop});\n    };\n\n\n    /**\n     * Closes the context menu.\n     */\n    ContextMenu.prototype.close = function () {\n        if (this.parentMenuItem) {\n            this.trigger(EVENT_BEFORE_SUB_MENU_CLOSE);\n        } else {\n            this.trigger(EVENT_BEFORE_CONTEXT_MENU_CLOSE);\n        }\n        this.closeSubMenu();\n        $(\"#\" + StringUtils.jQueryIdEscape(this.id)).removeClass(\"open\");\n    };\n\n    /**\n     * Detect if current context menu is already open\n     */\n    ContextMenu.prototype.isOpen = function () {\n        return $(\"#\" + StringUtils.jQueryIdEscape(this.id)).hasClass(\"open\");\n    };\n\n\n    /**\n     * Associate a context menu to a DOM element.\n     * This static function take care of registering event handlers for the click event\n     * listener and passing the right \"position\" object to the Context#open method\n     */\n    ContextMenu.assignContextMenuToSelector = function (selector, cmenu) {\n        $(selector).on(\"click\", function (e) {\n            let buttonOffset,\n                buttonHeight;\n\n            e.stopPropagation();\n\n            if (cmenu.isOpen()) {\n                cmenu.close();\n            } else {\n                buttonOffset = $(this).offset();\n                buttonHeight = $(this).outerHeight();\n                cmenu.open({\n                    pageX: buttonOffset.left,\n                    pageY: buttonOffset.top + buttonHeight\n                });\n            }\n        });\n    };\n\n\n    /**\n     * Registers new context menu with Brackets.\n\n     * Extensions should generally use the predefined context menus built into Brackets. Use this\n     * API to add a new context menu to UI that is specific to an extension.\n     *\n     * After registering  a new context menu clients should:\n     *      - use addMenuItem() to add items to the context menu\n     *      - call open() to show the context menu.\n     *      For example:\n     *      $(\"#my_ID\").contextmenu(function (e) {\n     *          if (e.which === 3) {\n     *              my_cmenu.open(e);\n     *          }\n     *      });\n     *\n     * To make menu items be contextual to things like selection, listen for the \"beforeContextMenuOpen\"\n     * to make changes to Command objects before the context menu is shown. MenuItems are views of\n     * Commands, which control a MenuItem's name, enabled state, and checked state.\n     *\n     * @param {string} id - unique identifier for context menu.\n     *      Core context menus in Brackets use a simple title as an id.\n     *      Extensions should use the following format: \"author.myextension.mycontextmenu name\"\n     * @return {?ContextMenu} the newly created context menu\n     */\n    function registerContextMenu(id) {\n        if (!id) {\n            console.error(\"call to registerContextMenu() is missing required parameters\");\n            return null;\n        }\n\n        // Guard against duplicate menu ids\n        if (contextMenuMap[id]) {\n            console.log(\"Context Menu added with same name and id of existing Context Menu: \" + id);\n            return null;\n        }\n\n        let cmenu = new ContextMenu(id);\n        contextMenuMap[id] = cmenu;\n        return cmenu;\n    }\n\n    AppInit.htmlReady(function () {\n        $('#titlebar').on('focusin', function() {\n            KeyBindingManager.addGlobalKeydownHook(menuKeyboardNavigationHandler);\n        });\n        $('#titlebar').on('focusout', function() {\n            KeyBindingManager.removeGlobalKeydownHook(menuKeyboardNavigationHandler);\n        });\n    });\n\n    // Deprecated menu ids\n    DeprecationWarning.deprecateConstant(ContextMenuIds, \"WORKING_SET_MENU\", \"WORKING_SET_CONTEXT_MENU\");\n    DeprecationWarning.deprecateConstant(ContextMenuIds, \"WORKING_SET_SETTINGS_MENU\", \"WORKING_SET_CONFIG_MENU\");\n\n    // Define public API\n    exports.AppMenuBar = AppMenuBar;\n    exports.ContextMenuIds = ContextMenuIds;\n    exports.MenuSection = MenuSection;\n    exports.BEFORE = BEFORE;\n    exports.AFTER = AFTER;\n    exports.LAST = LAST;\n    exports.FIRST = FIRST;\n    exports.FIRST_IN_SECTION = FIRST_IN_SECTION;\n    exports.LAST_IN_SECTION = LAST_IN_SECTION;\n    exports.DIVIDER = DIVIDER;\n    exports.getMenu = getMenu;\n    exports.getAllMenus = getAllMenus;\n    exports.getMenuItem = getMenuItem;\n    exports.getContextMenu = getContextMenu;\n    exports.addMenu = addMenu;\n    exports.removeMenu = removeMenu;\n    exports.openMenu = openMenu;\n    exports.getOpenMenu = getOpenMenu;\n    exports.registerContextMenu = registerContextMenu;\n    exports.closeAll = closeAll;\n    exports.Menu = Menu;\n    exports.MenuItem = MenuItem;\n    exports.ContextMenu = ContextMenu;\n    // public events\n    exports.EVENT_BEFORE_CONTEXT_MENU_OPEN = EVENT_BEFORE_CONTEXT_MENU_OPEN;\n    exports.EVENT_BEFORE_CONTEXT_MENU_CLOSE = EVENT_BEFORE_CONTEXT_MENU_CLOSE;\n    exports.EVENT_BEFORE_SUB_MENU_OPEN = EVENT_BEFORE_SUB_MENU_OPEN;\n    exports.EVENT_BEFORE_SUB_MENU_CLOSE = EVENT_BEFORE_SUB_MENU_CLOSE;\n});\n"],"file":"Menus.js"}
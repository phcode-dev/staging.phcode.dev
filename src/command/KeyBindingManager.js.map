{"version":3,"sources":["command/KeyBindingManager.js"],"names":["define","require","exports","module","AppInit","Commands","CommandManager","DefaultDialogs","EventDispatcher","FileSystem","FileSystemError","FileUtils","KeyEvent","Strings","StringUtils","UrlParams","_","KeyboardPrefs","JSON","parse","KEYMAP_FILENAME","_userKeyMapFilePath","path","normalize","brackets","app","getApplicationSupportDirectory","_keyMap","_defaultKeyMap","_customKeyMap","_customKeyMapCache","_commandMap","_allCommands","_displayKeyMap","up","down","left","right","-","_specialCommands","EDIT_UNDO","EDIT_REDO","EDIT_SELECT_ALL","EDIT_CUT","EDIT_COPY","EDIT_PASTE","_reservedShortcuts","_macReservedShortcuts","_keyNames","_showErrors","_enabled","_globalKeydownHooks","_loadUserKeyMap","CtrlDownStates","NOT_YET_DETECTED","DETECTED","DETECTED_AND_IGNORED","_ctrlDown","_altGrDown","_lastTimeStamp","_lastKeyIdentifier","MAX_INTERVAL_FOR_CTRL_ALT_KEYS","_onCtrlUp","_quitAltGrMode","$","window","off","_detectAltGrKeyDown","e","platform","key","altKey","ctrlKey","repeat","timeStamp","on","_reset","_buildKeyDescriptor","hasMacCtrl","hasCtrl","hasAlt","hasShift","console","log","keyDescriptor","push","unshift","join","normalizeKeyDescriptorString","origDescriptor","error","_compareModifierString","trim","toLowerCase","length","split","forEach","parseDescriptor","ele","i","arr","search","indexOf","test","capitalize","replace","match","p1","_mapKeycodeToKey","keycode","DOM_VK_0","DOM_VK_9","String","DOM_VK_NUMPAD0","DOM_VK_NUMPAD9","DOM_VK_SEMICOLON","DOM_VK_EQUALS","DOM_VK_COMMA","DOM_VK_SUBTRACT","DOM_VK_DASH","DOM_VK_ADD","DOM_VK_DECIMAL","DOM_VK_PERIOD","DOM_VK_DIVIDE","DOM_VK_SLASH","DOM_VK_BACK_QUOTE","DOM_VK_OPEN_BRACKET","DOM_VK_BACK_SLASH","DOM_VK_CLOSE_BRACKET","DOM_VK_QUOTE","_translateKeyboardEvent","event","fromCharCode","keyCode","ident","charAt","parseInt","substring","DOM_VK_DELETE","formatKeyDescriptor","descriptor","displayStr","KEYBOARD_CTRL","KEYBOARD_SHIFT","KEYBOARD_SPACE","KEYBOARD_PAGE_UP","KEYBOARD_PAGE_DOWN","KEYBOARD_HOME","KEYBOARD_END","KEYBOARD_INSERT","KEYBOARD_DELETE","_isKeyAssigned","undefined","removeBinding","normalizedKey","binding","command","get","commandID","bindings","filter","b","trigger","displayKey","_updateCommandAndKeyMaps","newBinding","cloneDeep","_addBinding","keyBinding","userBindings","result","normalized","normalizedDisplay","explicitPlatform","targetPlatform","bindingsToDelete","existing","existingBindings","isWindowsCompatible","isReplaceGeneric","ignoreGeneric","useWindowsCompatibleBindings","getKeymap","defaults","extend","_handleKey","execute","_sortByPlatform","a","a1","b1","addBinding","keyBindings","results","getID","Array","isArray","sort","addSingleBinding","keyBindingRequest","getKeyBindings","_handleCommandRegistered","commandId","addGlobalKeydownHook","hook","removeGlobalKeydownHook","index","splice","_handleKeyEvent","handled","stopPropagation","preventDefault","_showErrorsAndOpenKeyMap","err","message","Dialogs","errorMessage","ERROR_KEYMAP_CORRUPT","UNSUPPORTED_ENCODING","ERROR_LOADING_KEYMAP","showModalDialog","DIALOG_ID_ERROR","ERROR_KEYMAP_TITLE","done","FILE_OPEN_KEYMAP","_isSpecialCommand","_isReservedShortcuts","_getBulletList","list","info","_getDisplayKey","substr","_applyUserKeyBindings","remappedCommands","remappedKeys","restrictedCommands","restrictedKeys","invalidKeys","invalidCommands","multipleKeys","duplicateBindings","keybinding","format","ERROR_RESTRICTED_COMMANDS","ERROR_RESTRICTED_SHORTCUTS","ERROR_MULTIPLE_SHORTCUTS","ERROR_DUPLICATE_SHORTCUTS","ERROR_INVALID_SHORTCUTS","ERROR_NONEXISTENT_COMMANDS","_undoPriorUserKeyBindings","find","toArray","defaultCommand","_getUserKeyMapFilePath","isBracketsTestWindow","_readUserKeyMap","file","getFileForPath","Deferred","exists","doesExist","readAsText","text","keyMap","json","resolve","overrides","reject","fail","promise","_openUserKeyMap","userKeyMapPath","FILE_OPEN","fullPath","defaultContent","writeText","_initCommandAndKeyMaps","getAll","_setUserKeyMapFilePath","which","DOM_VK_CONTROL","htmlReady","document","body","addEventListener","debounce","then","on_duringInit","register","CMD_OPEN_KEYMAP","DocumentManager","checkKeyMapUpdates","doc","extensionsLoaded","params"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*globals path*/\n/*jslint regexp: true */\n/*unittests: KeyBindingManager */\n\n/**\n * Manages the mapping of keyboard inputs to commands.\n */\ndefine(function (require, exports, module) {\n\n\n    require(\"utils/Global\");\n\n    var AppInit             = require(\"utils/AppInit\"),\n        Commands            = require(\"command/Commands\"),\n        CommandManager      = require(\"command/CommandManager\"),\n        DefaultDialogs      = require(\"widgets/DefaultDialogs\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        FileSystemError     = require(\"filesystem/FileSystemError\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        KeyEvent            = require(\"utils/KeyEvent\"),\n        Strings             = require(\"strings\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        UrlParams           = require(\"utils/UrlParams\").UrlParams,\n        _                   = require(\"thirdparty/lodash\");\n\n    var KeyboardPrefs       = JSON.parse(require(\"text!base-config/keyboard.json\"));\n\n    var KEYMAP_FILENAME     = \"keymap.json\",\n        _userKeyMapFilePath = path.normalize(brackets.app.getApplicationSupportDirectory() + \"/\" + KEYMAP_FILENAME);\n\n    /**\n     * @private\n     * Maps normalized shortcut descriptor to key binding info.\n     * @type {!Object.<string, {commandID: string, key: string, displayKey: string}>}\n     */\n    var _keyMap            = {},    // For the actual key bindings including user specified ones\n        // For the default factory key bindings, cloned from _keyMap after all extensions are loaded.\n        _defaultKeyMap     = {};\n\n    /**\n     * @typedef {{shortcut: !string,\n     *            commandID: ?string}} UserKeyBinding\n     */\n\n    /**\n     * @private\n     * Maps shortcut descriptor to a command id.\n     * @type {UserKeyBinding}\n     */\n    var _customKeyMap      = {},\n        _customKeyMapCache = {};\n\n    /**\n     * @private\n     * Maps commandID to the list of shortcuts that are bound to it.\n     * @type {!Object.<string, Array.<{key: string, displayKey: string}>>}\n     */\n    var _commandMap  = {};\n\n    /**\n     * @private\n     * An array of command ID for all the available commands including the commands\n     * of installed extensions.\n     * @type {Array.<string>}\n     */\n    var _allCommands = [];\n\n    /**\n     * @private\n     * Maps key names to the corresponding unicode symols\n     * @type {{key: string, displayKey: string}}\n     */\n    var _displayKeyMap        = { \"up\": \"\\u2191\",\n        \"down\": \"\\u2193\",\n        \"left\": \"\\u2190\",\n        \"right\": \"\\u2192\",\n        \"-\": \"\\u2212\" };\n\n    var _specialCommands      = [Commands.EDIT_UNDO, Commands.EDIT_REDO, Commands.EDIT_SELECT_ALL,\n            Commands.EDIT_CUT, Commands.EDIT_COPY, Commands.EDIT_PASTE],\n        _reservedShortcuts    = [\"Ctrl-Z\", \"Ctrl-Y\", \"Ctrl-A\", \"Ctrl-X\", \"Ctrl-C\", \"Ctrl-V\"],\n        _macReservedShortcuts = [\"Cmd-,\", \"Cmd-H\", \"Cmd-Alt-H\", \"Cmd-M\", \"Cmd-Shift-Z\", \"Cmd-Q\"],\n        _keyNames             = [\"Up\", \"Down\", \"Left\", \"Right\", \"Backspace\", \"Enter\", \"Space\", \"Tab\",\n            \"PageUp\", \"PageDown\", \"Home\", \"End\", \"Insert\", \"Delete\"];\n\n    /**\n     * @private\n     * Flag to show key binding errors in the key map file. Default is true and\n     * it will be set to false when reloading without extensions. This flag is not\n     * used to suppress errors in loading or parsing the key map file. So if the key\n     * map file is corrupt, then the error dialog still shows up.\n     *\n     * @type {boolean}\n     */\n    var _showErrors = true;\n\n    /**\n     * @private\n     * Allow clients to toggle key binding\n     * @type {boolean}\n     */\n    var _enabled = true;\n\n    /**\n     * @private\n     * Stack of registered global keydown hooks.\n     * @type {Array.<function(Event): boolean>}\n     */\n    var _globalKeydownHooks = [];\n\n    /**\n     * @private\n     * Forward declaration for JSLint.\n     * @type {Function}\n     */\n    var _loadUserKeyMap;\n\n    /**\n     * @private\n     * States of Ctrl key down detection\n     * @enum {number}\n     */\n    var CtrlDownStates = {\n        \"NOT_YET_DETECTED\": 0,\n        \"DETECTED\": 1,\n        \"DETECTED_AND_IGNORED\": 2   // For consecutive ctrl keydown events while a Ctrl key is being hold down\n    };\n\n    /**\n     * @private\n     * Flags used to determine whether right Alt key is pressed. When it is pressed,\n     * the following two keydown events are triggered in that specific order.\n     *\n     *    1. _ctrlDown - flag used to record { ctrlKey: true, keyIdentifier: \"Control\", ... } keydown event\n     *    2. _altGrDown - flag used to record { ctrlKey: true, altKey: true, keyIdentifier: \"Alt\", ... } keydown event\n     *\n     * @type {CtrlDownStates|boolean}\n     */\n    var _ctrlDown = CtrlDownStates.NOT_YET_DETECTED,\n        _altGrDown = false;\n\n    /**\n     * @private\n     * Used to record the timeStamp property of the last keydown event.\n     * @type {number}\n     */\n    var _lastTimeStamp;\n\n    /**\n     * @private\n     * Used to record the keyIdentifier property of the last keydown event.\n     * @type {string}\n     */\n    var _lastKeyIdentifier;\n\n    /*\n     * @private\n     * Constant used for checking the interval between Control keydown event and Alt keydown event.\n     * If the right Alt key is down we get Control keydown followed by Alt keydown within 30 ms. if\n     * the user is pressing Control key and then Alt key, the interval will be larger than 30 ms.\n     * @type {number}\n     */\n    var MAX_INTERVAL_FOR_CTRL_ALT_KEYS = 30;\n\n    /**\n     * @private\n     * Forward declaration for JSLint.\n     * @type {Function}\n     */\n    var _onCtrlUp;\n\n    /**\n     * @private\n     * Resets all the flags and removes _onCtrlUp event listener.\n     *\n     */\n    function _quitAltGrMode() {\n        _enabled = true;\n        _ctrlDown = CtrlDownStates.NOT_YET_DETECTED;\n        _altGrDown = false;\n        _lastTimeStamp = null;\n        _lastKeyIdentifier = null;\n        $(window).off(\"keyup\", _onCtrlUp);\n    }\n\n    /**\n     * @private\n     * Detects the release of AltGr key by checking all keyup events\n     * until we receive one with ctrl key code. Once detected, reset\n     * all the flags and also remove this event listener.\n     *\n     * @param {!KeyboardEvent} e keyboard event object\n     */\n    _onCtrlUp = function (e) {\n        var key = e.keyCode || e.which;\n        if (_altGrDown && key === KeyEvent.DOM_VK_CONTROL) {\n            _quitAltGrMode();\n        }\n    };\n\n    /**\n     * @private\n     * Detects whether AltGr key is pressed. When it is pressed, the first keydown event has\n     * ctrlKey === true with keyIdentifier === \"Control\". The next keydown event with\n     * altKey === true, ctrlKey === true and keyIdentifier === \"Alt\" is sent within 30 ms. Then\n     * the next keydown event with altKey === true, ctrlKey === true and keyIdentifier === \"Control\"\n     * is sent. If the user keep holding AltGr key down, then the second and third\n     * keydown events are repeatedly sent out alternately. If the user is also holding down Ctrl\n     * key, then either keyIdentifier === \"Control\" or keyIdentifier === \"Alt\" is repeatedly sent\n     * but not alternately.\n     *\n     * Once we detect the AltGr key down, then disable KeyBindingManager and set up a keyup\n     * event listener to detect the release of the altGr key so that we can re-enable KeyBindingManager.\n     * When we detect the addition of Ctrl key besides AltGr key, we also quit AltGr mode and re-enable\n     * KeyBindingManager.\n     *\n     * @param {!KeyboardEvent} e keyboard event object\n     */\n    function _detectAltGrKeyDown(e) {\n        if (brackets.platform !== \"win\") {\n            return;\n        }\n\n        if (!_altGrDown) {\n            if (_ctrlDown !== CtrlDownStates.DETECTED_AND_IGNORED && e.ctrlKey && e.key === \"Control\") {\n                _ctrlDown = CtrlDownStates.DETECTED;\n            } else if (e.repeat && e.ctrlKey && e.key === \"Control\") {\n                // We get here if the user is holding down left/right Control key. Set it to false\n                // so that we don't misidentify the combination of Ctrl and Alt keys as AltGr key.\n                _ctrlDown = CtrlDownStates.DETECTED_AND_IGNORED;\n            } else if (_ctrlDown === CtrlDownStates.DETECTED && e.altKey && e.ctrlKey && e.key === \"Alt\" &&\n                        (e.timeStamp - _lastTimeStamp) < MAX_INTERVAL_FOR_CTRL_ALT_KEYS) {\n                _altGrDown = true;\n                _lastKeyIdentifier = \"Alt\";\n                _enabled = false;\n                $(window).on(\"keyup\", _onCtrlUp);\n            } else {\n                // Reset _ctrlDown so that we can start over in detecting the two key events\n                // required for AltGr key.\n                _ctrlDown = CtrlDownStates.NOT_YET_DETECTED;\n            }\n            _lastTimeStamp = e.timeStamp;\n        } else if (e.key === \"Control\" || e.key === \"Alt\") {\n            // If the user is NOT holding down AltGr key or is also pressing Ctrl key,\n            // then _lastKeyIdentifier will be the same as keyIdentifier in the current\n            // key event. So we need to quit AltGr mode to re-enable KBM.\n            if (e.altKey && e.ctrlKey && e.key === _lastKeyIdentifier) {\n                _quitAltGrMode();\n            } else {\n                _lastKeyIdentifier = e.key;\n            }\n        }\n    }\n\n    /**\n     * @private\n     */\n    function _reset() {\n        _keyMap = {};\n        _defaultKeyMap = {};\n        _customKeyMap = {};\n        _customKeyMapCache = {};\n        _commandMap = {};\n        _globalKeydownHooks = [];\n        _userKeyMapFilePath = path.normalize(brackets.app.getApplicationSupportDirectory() + \"/\" + KEYMAP_FILENAME);\n    }\n\n    /**\n     * @private\n     * Initialize an empty keymap as the current keymap. It overwrites the current keymap if there is one.\n     * builds the keyDescriptor string from the given parts\n     * @param {boolean} hasCtrl Is Ctrl key enabled\n     * @param {boolean} hasAlt Is Alt key enabled\n     * @param {boolean} hasShift Is Shift key enabled\n     * @param {string} key The key that's pressed\n     * @return {string} The normalized key descriptor\n     */\n    function _buildKeyDescriptor(hasMacCtrl, hasCtrl, hasAlt, hasShift, key) {\n        if (!key) {\n            console.log(\"KeyBindingManager _buildKeyDescriptor() - No key provided!\");\n            return \"\";\n        }\n\n        var keyDescriptor = [];\n\n        if (hasMacCtrl) {\n            keyDescriptor.push(\"Ctrl\");\n        }\n        if (hasAlt) {\n            keyDescriptor.push(\"Alt\");\n        }\n        if (hasShift) {\n            keyDescriptor.push(\"Shift\");\n        }\n\n        if (hasCtrl) {\n            // Windows display Ctrl first, Mac displays Command symbol last\n            if (brackets.platform === \"mac\") {\n                keyDescriptor.push(\"Cmd\");\n            } else {\n                keyDescriptor.unshift(\"Ctrl\");\n            }\n        }\n\n        keyDescriptor.push(key);\n\n        return keyDescriptor.join(\"-\");\n    }\n\n\n    /**\n     * normalizes the incoming key descriptor so the modifier keys are always specified in the correct order\n     * @param {string} The string for a key descriptor, can be in any order, the result will be Ctrl-Alt-Shift-<Key>\n     * @return {string} The normalized key descriptor or null if the descriptor invalid\n     */\n    function normalizeKeyDescriptorString(origDescriptor) {\n        var hasMacCtrl = false,\n            hasCtrl = false,\n            hasAlt = false,\n            hasShift = false,\n            key = \"\",\n            error = false;\n\n        function _compareModifierString(left, right) {\n            if (!left || !right) {\n                return false;\n            }\n            left = left.trim().toLowerCase();\n            right = right.trim().toLowerCase();\n\n            return (left.length > 0 && left === right);\n        }\n\n        origDescriptor.split(\"-\").forEach(function parseDescriptor(ele, i, arr) {\n            if (_compareModifierString(\"ctrl\", ele)) {\n                if (brackets.platform === \"mac\") {\n                    hasMacCtrl = true;\n                } else {\n                    hasCtrl = true;\n                }\n            } else if (_compareModifierString(\"cmd\", ele)) {\n                if (brackets.platform === \"mac\") {\n                    hasCtrl = true;\n                } else {\n                    error = true;\n                }\n            } else if (_compareModifierString(\"alt\", ele)) {\n                hasAlt = true;\n            } else if (_compareModifierString(\"opt\", ele)) {\n                if (brackets.platform === \"mac\") {\n                    hasAlt = true;\n                } else {\n                    error = true;\n                }\n            } else if (_compareModifierString(\"shift\", ele)) {\n                hasShift = true;\n            } else if (key.length > 0) {\n                console.log(\"KeyBindingManager normalizeKeyDescriptorString() - Multiple keys defined. Using key: \" + key + \" from: \" + origDescriptor);\n                error = true;\n            } else {\n                key = ele;\n            }\n        });\n\n        if (error) {\n            return null;\n        }\n\n        // Check to see if the binding is for \"-\".\n        if (key === \"\" && origDescriptor.search(/^.+--$/) !== -1) {\n            key = \"-\";\n        }\n\n        // Check if it is a shift key only press\n        if (key === \"\" && origDescriptor.toLowerCase() === 'shift-shift') {\n            key = \"Shift\";\n        }\n\n        // '+' char is valid if it's the only key. Keyboard shortcut strings should use\n        // unicode characters (unescaped). Keyboard shortcut display strings may use\n        // unicode escape sequences (e.g. \\u20AC euro sign)\n        if ((key.indexOf(\"+\")) >= 0 && (key.length > 1)) {\n            return null;\n        }\n\n        // Ensure that the first letter of the key name is in upper case and the rest are\n        // in lower case. i.e. 'a' => 'A' and 'up' => 'Up'\n        if (/^[a-z]/i.test(key)) {\n            key = _.capitalize(key.toLowerCase());\n        }\n\n        // Also make sure that the second word of PageUp/PageDown has the first letter in upper case.\n        if (/^Page/.test(key)) {\n            key = key.replace(/(up|down)$/, function (match, p1) {\n                return _.capitalize(p1);\n            });\n        }\n\n        // No restriction on single character key yet, but other key names are restricted to either\n        // Function keys or those listed in _keyNames array.\n        if (key.length > 1 && !/F\\d+/.test(key) &&\n                _keyNames.indexOf(key) === -1) {\n            return null;\n        }\n\n        return _buildKeyDescriptor(hasMacCtrl, hasCtrl, hasAlt, hasShift, key);\n    }\n\n    /**\n     * @private\n     * Looks for keycodes that have os-inconsistent keys and fixes them.\n     * @param {number} The keycode from the keyboard event.\n     * @param {string} The current best guess at what the key is.\n     * @return {string} If the key is OS-inconsistent, the correct key; otherwise, the original key.\n     **/\n    function _mapKeycodeToKey(keycode, key) {\n        // If keycode represents one of the digit keys (0-9), then return the corresponding digit\n        // by subtracting KeyEvent.DOM_VK_0 from keycode. ie. [48-57] --> [0-9]\n        if (keycode >= KeyEvent.DOM_VK_0 && keycode <= KeyEvent.DOM_VK_9) {\n            return String(keycode - KeyEvent.DOM_VK_0);\n        // Do the same with the numpad numbers\n        // by subtracting KeyEvent.DOM_VK_NUMPAD0 from keycode. ie. [96-105] --> [0-9]\n        } else if (keycode >= KeyEvent.DOM_VK_NUMPAD0 && keycode <= KeyEvent.DOM_VK_NUMPAD9) {\n            return String(keycode - KeyEvent.DOM_VK_NUMPAD0);\n        }\n\n\n        switch (keycode) {\n        case KeyEvent.DOM_VK_SEMICOLON:\n            return \";\";\n        case KeyEvent.DOM_VK_EQUALS:\n            return \"=\";\n        case KeyEvent.DOM_VK_COMMA:\n            return \",\";\n        case KeyEvent.DOM_VK_SUBTRACT:\n        case KeyEvent.DOM_VK_DASH:\n            return \"-\";\n        case KeyEvent.DOM_VK_ADD:\n            return \"+\";\n        case KeyEvent.DOM_VK_DECIMAL:\n        case KeyEvent.DOM_VK_PERIOD:\n            return \".\";\n        case KeyEvent.DOM_VK_DIVIDE:\n        case KeyEvent.DOM_VK_SLASH:\n            return \"/\";\n        case KeyEvent.DOM_VK_BACK_QUOTE:\n            return \"`\";\n        case KeyEvent.DOM_VK_OPEN_BRACKET:\n            return \"[\";\n        case KeyEvent.DOM_VK_BACK_SLASH:\n            return \"\\\\\";\n        case KeyEvent.DOM_VK_CLOSE_BRACKET:\n            return \"]\";\n        case KeyEvent.DOM_VK_QUOTE:\n            return \"'\";\n        default:\n            return key;\n        }\n    }\n\n    /**\n     * Takes a keyboard event and translates it into a key in a key map\n     */\n    function _translateKeyboardEvent(event) {\n        var hasMacCtrl = (brackets.platform === \"mac\") ? (event.ctrlKey) : false,\n            hasCtrl = (brackets.platform !== \"mac\") ? (event.ctrlKey) : (event.metaKey),\n            hasAlt = (event.altKey),\n            hasShift = (event.shiftKey),\n            key = String.fromCharCode(event.keyCode);\n\n        //From the W3C, if we can get the KeyboardEvent.key then look here\n        //As that will let us use keys like then function keys \"F5\" for commands. The\n        //full set of values we can use is here\n        // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n        var ident = event.key;\n        if (ident) {\n            if (ident.charAt(0) === \"U\" && ident.charAt(1) === \"+\") {\n                //This is a unicode code point like \"U+002A\", get the 002A and use that\n                key = String.fromCharCode(parseInt(ident.substring(2), 16));\n            } else {\n                //This is some non-character key, just use the raw identifier\n                key = ident;\n            }\n        }\n\n        // Translate some keys to their common names\n        if (key === \"\\t\") {\n            key = \"Tab\";\n        } else if (key === \" \") {\n            key = \"Space\";\n        } else if (key === \"\\b\") {\n            key = \"Backspace\";\n        } else if (key === \"Help\") {\n            key = \"Insert\";\n        } else if (event.keyCode === KeyEvent.DOM_VK_DELETE) {\n            key = \"Delete\";\n        } else if (key === \"ArrowUp\") {\n            key = \"Up\";\n        } else if (key === \"ArrowDown\") {\n            key = \"Down\";\n        } else if (key === \"ArrowLeft\") {\n            key = \"Left\";\n        } else if (key === \"ArrowRight\") {\n            key = \"Right\";\n        }\n        else {\n            key = _mapKeycodeToKey(event.keyCode, key);\n        }\n\n        return normalizeKeyDescriptorString(_buildKeyDescriptor(hasMacCtrl, hasCtrl, hasAlt, hasShift, key));\n    }\n\n    /**\n     * Convert normalized key representation to display appropriate for platform.\n     * @param {!string} descriptor Normalized key descriptor.\n     * @return {!string} Display/Operating system appropriate string\n     */\n    function formatKeyDescriptor(descriptor) {\n        var displayStr;\n\n        if (brackets.platform === \"mac\") {\n            displayStr = descriptor.replace(/-(?!$)/g, \"\");     // remove dashes\n            displayStr = displayStr.replace(\"Ctrl\", \"\\u2303\");  // Ctrl > control symbol\n            displayStr = displayStr.replace(\"Cmd\", \"\\u2318\");   // Cmd > command symbol\n            displayStr = displayStr.replace(\"Shift\", \"\\u21E7\"); // Shift > shift symbol\n            displayStr = displayStr.replace(\"Alt\", \"\\u2325\");   // Alt > option symbol\n        } else {\n            displayStr = descriptor.replace(\"Ctrl\", Strings.KEYBOARD_CTRL);\n            displayStr = displayStr.replace(\"Shift\", Strings.KEYBOARD_SHIFT);\n            displayStr = displayStr.replace(/-(?!$)/g, \"+\");\n        }\n\n        displayStr = displayStr.replace(\"Space\", Strings.KEYBOARD_SPACE);\n\n        displayStr = displayStr.replace(\"PageUp\", Strings.KEYBOARD_PAGE_UP);\n        displayStr = displayStr.replace(\"PageDown\", Strings.KEYBOARD_PAGE_DOWN);\n        displayStr = displayStr.replace(\"Home\", Strings.KEYBOARD_HOME);\n        displayStr = displayStr.replace(\"End\", Strings.KEYBOARD_END);\n\n        displayStr = displayStr.replace(\"Ins\", Strings.KEYBOARD_INSERT);\n        displayStr = displayStr.replace(\"Del\", Strings.KEYBOARD_DELETE);\n\n        return displayStr;\n    }\n\n    /**\n     * @private\n     * @param {string} A normalized key-description string.\n     * @return {boolean} true if the key is already assigned, false otherwise.\n     */\n    function _isKeyAssigned(key) {\n        return (_keyMap[key] !== undefined);\n    }\n\n    /**\n     * Remove a key binding from _keymap\n     *\n     * @param {!string} key - a key-description string that may or may not be normalized.\n     * @param {?string} platform - OS from which to remove the binding (all platforms if unspecified)\n     */\n    function removeBinding(key, platform) {\n        if (!key || ((platform !== null) && (platform !== undefined) && (platform !== brackets.platform))) {\n            return;\n        }\n\n        var normalizedKey = normalizeKeyDescriptorString(key);\n\n        if (!normalizedKey) {\n            console.log(\"Failed to normalize \" + key);\n        } else if (_isKeyAssigned(normalizedKey)) {\n            var binding = _keyMap[normalizedKey],\n                command = CommandManager.get(binding.commandID),\n                bindings = _commandMap[binding.commandID];\n\n            // delete key binding record\n            delete _keyMap[normalizedKey];\n\n            if (bindings) {\n                // delete mapping from command to key binding\n                _commandMap[binding.commandID] = bindings.filter(function (b) {\n                    return (b.key !== normalizedKey);\n                });\n\n                if (command) {\n                    command.trigger(\"keyBindingRemoved\", {key: normalizedKey, displayKey: binding.displayKey});\n                }\n            }\n        }\n    }\n\n    /**\n     * @private\n     *\n     * Updates _allCommands array and _defaultKeyMap with the new key binding\n     * if it is not yet in the _allCommands array. _allCommands array is initialized\n     * only in extensionsLoaded event. So any new commands or key bindings added after\n     * that will be updated here.\n     *\n     * @param {{commandID: string, key: string, displayKey:string, explicitPlatform: string}} newBinding\n     */\n    function _updateCommandAndKeyMaps(newBinding) {\n        if (_allCommands.length === 0) {\n            return;\n        }\n\n        if (newBinding && newBinding.commandID && _allCommands.indexOf(newBinding.commandID) === -1) {\n            _defaultKeyMap[newBinding.commandID] = _.cloneDeep(newBinding);\n\n            // Process user key map again to catch any reassignment to all new key bindings added from extensions.\n            _loadUserKeyMap();\n        }\n    }\n\n    /**\n     * @private\n     *\n     * @param {string} commandID\n     * @param {string|{{key: string, displayKey: string}}} keyBinding - a single shortcut.\n     * @param {?string} platform\n     *     - \"all\" indicates all platforms, not overridable\n     *     - undefined indicates all platforms, overridden by platform-specific binding\n     * @param {boolean=} userBindings true if adding a user key binding or undefined otherwise.\n     * @return {?{key: string, displayKey:String}} Returns a record for valid key bindings.\n     *     Returns null when key binding platform does not match, binding does not normalize,\n     *     or is already assigned.\n     */\n    function _addBinding(commandID, keyBinding, platform, userBindings) {\n        var key,\n            result = null,\n            normalized,\n            normalizedDisplay,\n            explicitPlatform = keyBinding.platform || platform,\n            targetPlatform,\n            command,\n            bindingsToDelete = [],\n            existing;\n\n        // For platform: \"all\", use explicit current platform\n        if (explicitPlatform && explicitPlatform !== \"all\") {\n            targetPlatform = explicitPlatform;\n        } else {\n            targetPlatform = brackets.platform;\n        }\n\n\n        // Skip if the key binding is not for this platform.\n        if (explicitPlatform === \"mac\" && brackets.platform !== \"mac\") {\n            return null;\n        }\n\n        // if the request does not specify an explicit platform, and we're\n        // currently on a mac, then replace Ctrl with Cmd.\n        key = (keyBinding.key) || keyBinding;\n        if (brackets.platform === \"mac\" && (explicitPlatform === undefined || explicitPlatform === \"all\")) {\n            key = key.replace(\"Ctrl\", \"Cmd\");\n            if (keyBinding.displayKey !== undefined) {\n                keyBinding.displayKey = keyBinding.displayKey.replace(\"Ctrl\", \"Cmd\");\n            }\n        }\n\n        normalized = normalizeKeyDescriptorString(key);\n\n        // skip if the key binding is invalid\n        if (!normalized) {\n            console.error(\"Unable to parse key binding \" + key + \". Permitted modifiers: Ctrl, Cmd, Alt, Opt, Shift; separated by '-' (not '+').\");\n            return null;\n        }\n\n        // check for duplicate key bindings\n        existing = _keyMap[normalized];\n\n        // for cross-platform compatibility\n        if (exports.useWindowsCompatibleBindings) {\n            // windows-only key bindings are used as the default binding\n            // only if a default binding wasn't already defined\n            if (explicitPlatform === \"win\") {\n                // search for a generic or platform-specific binding if it\n                // already exists\n                if (existing && (!existing.explicitPlatform ||\n                                 existing.explicitPlatform === brackets.platform ||\n                                 existing.explicitPlatform === \"all\")) {\n                    // do not clobber existing binding with windows-only binding\n                    return null;\n                }\n\n                // target this windows binding for the current platform\n                targetPlatform = brackets.platform;\n            }\n        }\n\n        // skip if this binding doesn't match the current platform\n        if (targetPlatform !== brackets.platform) {\n            return null;\n        }\n\n        // skip if the key is already assigned\n        if (existing) {\n            if (!existing.explicitPlatform && explicitPlatform) {\n                // remove the the generic binding to replace with this new platform-specific binding\n                removeBinding(normalized);\n                existing = false;\n            }\n        }\n\n        // delete existing bindings when\n        // (1) replacing a windows-compatible binding with a generic or\n        //     platform-specific binding\n        // (2) replacing a generic binding with a platform-specific binding\n        var existingBindings = _commandMap[commandID] || [],\n            isWindowsCompatible,\n            isReplaceGeneric,\n            ignoreGeneric;\n\n        existingBindings.forEach(function (binding) {\n            // remove windows-only bindings in _commandMap\n            isWindowsCompatible = exports.useWindowsCompatibleBindings &&\n                binding.explicitPlatform === \"win\";\n\n            // remove existing generic binding\n            isReplaceGeneric = !binding.explicitPlatform &&\n                explicitPlatform;\n\n            if (isWindowsCompatible || isReplaceGeneric) {\n                bindingsToDelete.push(binding);\n            } else {\n                // existing binding is platform-specific and the requested binding is generic\n                ignoreGeneric = binding.explicitPlatform && !explicitPlatform;\n            }\n        });\n\n        if (ignoreGeneric) {\n            // explicit command binding overrides this one\n            return null;\n        }\n\n        if (existing) {\n            // do not re-assign a key binding\n            console.error(\"Cannot assign \" + normalized + \" to \" + commandID + \". It is already assigned to \" + _keyMap[normalized].commandID);\n            return null;\n        }\n\n        // remove generic or windows-compatible bindings\n        bindingsToDelete.forEach(function (binding) {\n            removeBinding(binding.key);\n        });\n\n        // optional display-friendly string (e.g. CMD-+ instead of CMD-=)\n        normalizedDisplay = (keyBinding.displayKey) ? normalizeKeyDescriptorString(keyBinding.displayKey) : normalized;\n\n        // 1-to-many commandID mapping to key binding\n        if (!_commandMap[commandID]) {\n            _commandMap[commandID] = [];\n        }\n\n        result = {\n            key: normalized,\n            displayKey: normalizedDisplay,\n            explicitPlatform: explicitPlatform\n        };\n\n        _commandMap[commandID].push(result);\n\n        // 1-to-1 key binding to commandID\n        _keyMap[normalized] = {\n            commandID: commandID,\n            key: normalized,\n            displayKey: normalizedDisplay,\n            explicitPlatform: explicitPlatform\n        };\n\n        if (!userBindings) {\n            _updateCommandAndKeyMaps(_keyMap[normalized]);\n        }\n\n        // notify listeners\n        command = CommandManager.get(commandID);\n\n        if (command) {\n            command.trigger(\"keyBindingAdded\", result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns a copy of the current key map. If the optional 'defaults' parameter is true,\n     * then a copy of the default key map is returned.\n     * @param {boolean=} defaults true if the caller wants a copy of the default key map.\n     *                            Otherwise, the current active key map is returned.\n     * @return {!Object.<string, {commandID: string, key: string, displayKey: string}>}\n     */\n    function getKeymap(defaults) {\n        return $.extend({}, defaults ? _defaultKeyMap : _keyMap);\n    }\n\n    /**\n     * Process the keybinding for the current key.\n     *\n     * @param {string} A key-description string.\n     * @return {boolean} true if the key was processed, false otherwise\n     */\n    function _handleKey(key) {\n        if (_enabled && _keyMap[key]) {\n            CommandManager.execute(_keyMap[key].commandID);\n            // If there is a registered and enabled key event, we always mark the event as processed and return true.\n            // We don't want multiple behavior tied to the same key event. For Instance, in browser, if `ctrl-k`\n            // is not handled by quick edit, it will open browser url bar if we return false here(which is bad ux).\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @private\n     *\n     * Sort objects by platform property. Objects with a platform property come\n     * before objects without a platform property.\n     */\n    function _sortByPlatform(a, b) {\n        var a1 = (a.platform) ? 1 : 0,\n            b1 = (b.platform) ? 1 : 0;\n        return b1 - a1;\n    }\n\n    /**\n     * Add one or more key bindings to a particular Command.\n     *\n     * @param {!string | Command} command - A command ID or command object\n     * @param {?({key: string, displayKey: string}|Array.<{key: string, displayKey: string, platform: string}>)} keyBindings\n     *     A single key binding or an array of keybindings. Example:\n     *     \"Shift-Cmd-F\". Mac and Win key equivalents are automatically\n     *     mapped to each other. Use displayKey property to display a different\n     *     string (e.g. \"CMD+\" instead of \"CMD=\").\n     * @param {?string} platform The target OS of the keyBindings either\n     *     \"mac\", \"win\" or \"linux\". If undefined, all platforms not explicitly\n     *     defined will use the key binding.\n     *     NOTE: If platform is not specified, Ctrl will be replaced by Cmd for \"mac\" platform\n     * @return {{key: string, displayKey:String}|Array.<{key: string, displayKey:String}>}\n     *     Returns record(s) for valid key binding(s)\n     */\n    function addBinding(command, keyBindings, platform) {\n        var commandID = \"\",\n            results;\n\n        if (!command) {\n            console.error(\"addBinding(): missing required parameter: command\");\n            return;\n        }\n\n        if (!keyBindings) { return; }\n\n        if (typeof (command) === \"string\") {\n            commandID = command;\n        } else {\n            commandID = command.getID();\n        }\n\n        if (Array.isArray(keyBindings)) {\n            var keyBinding;\n            results = [];\n\n            // process platform-specific bindings first\n            keyBindings.sort(_sortByPlatform);\n\n            keyBindings.forEach(function addSingleBinding(keyBindingRequest) {\n                // attempt to add keybinding\n                keyBinding = _addBinding(commandID, keyBindingRequest, keyBindingRequest.platform);\n\n                if (keyBinding) {\n                    results.push(keyBinding);\n                }\n            });\n        } else {\n            results = _addBinding(commandID, keyBindings, platform);\n        }\n\n        return results;\n    }\n\n    /**\n     * Retrieve key bindings currently associated with a command\n     *\n     * @param {!string | Command} command - A command ID or command object\n     * @return {!Array.<{{key: string, displayKey: string}}>} An array of associated key bindings.\n     */\n    function getKeyBindings(command) {\n        var bindings    = [],\n            commandID   = \"\";\n\n        if (!command) {\n            console.error(\"getKeyBindings(): missing required parameter: command\");\n            return [];\n        }\n\n        if (typeof (command) === \"string\") {\n            commandID = command;\n        } else {\n            commandID = command.getID();\n        }\n\n        bindings = _commandMap[commandID];\n        return bindings || [];\n    }\n\n    /**\n     * Adds default key bindings when commands are registered to CommandManager\n     * @param {$.Event} event jQuery event\n     * @param {Command} command Newly registered command\n     */\n    function _handleCommandRegistered(event, command) {\n        var commandId   = command.getID(),\n            defaults    = KeyboardPrefs[commandId];\n\n        if (defaults) {\n            addBinding(commandId, defaults);\n        }\n    }\n\n    /**\n     * Adds a global keydown hook that gets first crack at keydown events\n     * before standard keybindings do. This is intended for use by modal or\n     * semi-modal UI elements like dialogs or the code hint list that should\n     * execute before normal command bindings are run.\n     *\n     * The hook is passed one parameter, the original keyboard event. If the\n     * hook handles the event (or wants to block other global hooks from\n     * handling the event), it should return true. Note that this will *only*\n     * stop other global hooks and KeyBindingManager from handling the\n     * event; to prevent further event propagation, you will need to call\n     * stopPropagation(), stopImmediatePropagation(), and/or preventDefault()\n     * as usual.\n     *\n     * Multiple keydown hooks can be registered, and are executed in order,\n     * most-recently-added first.\n     *\n     * (We have to have a special API for this because (1) handlers are normally\n     * called in least-recently-added order, and we want most-recently-added;\n     * (2) native DOM events don't have a way for us to find out if\n     * stopImmediatePropagation()/stopPropagation() has been called on the\n     * event, so we have to have some other way for one of the hooks to\n     * indicate that it wants to block the other hooks from running.)\n     *\n     * @param {function(Event): boolean} hook The global hook to add.\n     */\n    function addGlobalKeydownHook(hook) {\n        _globalKeydownHooks.push(hook);\n    }\n\n    /**\n     * Removes a global keydown hook added by `addGlobalKeydownHook`.\n     * Does not need to be the most recently added hook.\n     *\n     * @param {function(Event): boolean} hook The global hook to remove.\n     */\n    function removeGlobalKeydownHook(hook) {\n        var index = _globalKeydownHooks.indexOf(hook);\n        if (index !== -1) {\n            _globalKeydownHooks.splice(index, 1);\n        }\n    }\n\n    /**\n     * Handles a given keydown event, checking global hooks first before\n     * deciding to handle it ourselves.\n     * @param {Event} The keydown event to handle.\n     */\n    function _handleKeyEvent(event) {\n        var i, handled = false;\n        for (i = _globalKeydownHooks.length - 1; i >= 0; i--) {\n            if (_globalKeydownHooks[i](event)) {\n                handled = true;\n                break;\n            }\n        }\n        _detectAltGrKeyDown(event);\n        if (!handled && _handleKey(_translateKeyboardEvent(event))) {\n            event.stopPropagation();\n            event.preventDefault();\n        }\n    }\n\n    AppInit.htmlReady(function () {\n        // Install keydown event listener.\n        window.document.body.addEventListener(\n            \"keydown\",\n            _handleKeyEvent,\n            true\n        );\n\n        exports.useWindowsCompatibleBindings = (brackets.platform !== \"mac\") &&\n            (brackets.platform !== \"win\");\n    });\n\n    /**\n     * @private\n     * Displays an error dialog and also opens the user key map file for editing only if\n     * the error is not the loading file error.\n     *\n     * @param {?string} err Error type returned from JSON parser or open file operation\n     * @param {string=} message Error message to be displayed in the dialog\n     */\n    function _showErrorsAndOpenKeyMap(err, message) {\n        // Asynchronously loading Dialogs module to avoid the circular dependency\n        require([\"widgets/Dialogs\"], function (Dialogs) {\n            var errorMessage = Strings.ERROR_KEYMAP_CORRUPT;\n\n            if (err === FileSystemError.UNSUPPORTED_ENCODING) {\n                errorMessage = Strings.ERROR_LOADING_KEYMAP;\n            } else if (message) {\n                errorMessage = message;\n            }\n\n            Dialogs.showModalDialog(\n                DefaultDialogs.DIALOG_ID_ERROR,\n                Strings.ERROR_KEYMAP_TITLE,\n                errorMessage\n            )\n                .done(function () {\n                    if (err !== FileSystemError.UNSUPPORTED_ENCODING) {\n                        CommandManager.execute(Commands.FILE_OPEN_KEYMAP);\n                    }\n                });\n        });\n    }\n\n    /**\n     * @private\n     *\n     * Checks whether the given command ID is a special command that the user can't bind\n     * to another shortcut.\n     * @param {!string} commandID A string referring to a specific command\n     * @return {boolean} true if normalizedKey is a special command, false otherwise.\n     */\n    function _isSpecialCommand(commandID) {\n        if (brackets.platform === \"mac\" && commandID === \"file.quit\") {\n            return true;\n        }\n\n        return (_specialCommands.indexOf(commandID) > -1);\n    }\n\n    /**\n     * @private\n     *\n     * Checks whether the given key combination is a shortcut of a special command\n     * or a Mac system command that the user can't reassign to another command.\n     * @param {!string} normalizedKey A key combination string used for a keyboard shortcut\n     * @return {boolean} true if normalizedKey is a restricted shortcut, false otherwise.\n     */\n    function _isReservedShortcuts(normalizedKey) {\n        if (!normalizedKey) {\n            return false;\n        }\n\n        if (_reservedShortcuts.indexOf(normalizedKey) > -1 ||\n                _reservedShortcuts.indexOf(normalizedKey.replace(\"Cmd\", \"Ctrl\")) > -1) {\n            return true;\n        }\n\n        if (brackets.platform === \"mac\" && _macReservedShortcuts.indexOf(normalizedKey) > -1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @private\n     *\n     * Creates a bullet list item for any item in the given list.\n     * @param {Array.<string>} list An array of strings to be converted into a\n     * message string with a bullet list.\n     * @return {string} the html text version of the list\n     */\n    function _getBulletList(list) {\n        var message = \"<ul class='dialog-list'>\";\n        list.forEach(function (info) {\n            message += \"<li>\" + info + \"</li>\";\n        });\n        message += \"</ul>\";\n        return message;\n    }\n\n    /**\n     * @private\n     *\n     * Gets the corresponding unicode symbol of an arrow key for display in the menu.\n     * @param {string} key The non-modifier key used in the shortcut. It does not need to be normalized.\n     * @return {string} An empty string if key is not one of those we want to show with the unicode symbol.\n     *                  Otherwise, the corresponding unicode symbol is returned.\n     */\n    function _getDisplayKey(key) {\n        var displayKey = \"\",\n            match = key ? key.match(/(Up|Down|Left|Right|\\-)$/i) : null;\n        if (match && !/Page(Up|Down)/.test(key)) {\n            displayKey = key.substr(0, match.index) + _displayKeyMap[match[0].toLowerCase()];\n        }\n        return displayKey;\n    }\n\n    /**\n     * @private\n     *\n     * Applies each user key binding to all the affected commands and updates _keyMap.\n     * Shows errors in a dialog and then opens the user key map file if any of the following\n     * is detected while applying the user key bindings.\n     *     - A key binding is attempting to modify a special command.\n     *     - A key binding is attempting to assign a shortcut of a special command to another one.\n     *     - Multiple key bindings are specified for the same command ID.\n     *     - The same key combination is listed for multiple key bindings.\n     *     - A key binding has any invalid key syntax.\n     *     - A key binding is referring to a non-existent command ID.\n     */\n    function _applyUserKeyBindings() {\n        var remappedCommands   = [],\n            remappedKeys       = [],\n            restrictedCommands = [],\n            restrictedKeys     = [],\n            invalidKeys        = [],\n            invalidCommands    = [],\n            multipleKeys       = [],\n            duplicateBindings  = [],\n            errorMessage       = \"\";\n\n        _.forEach(_customKeyMap, function (commandID, key) {\n            var normalizedKey    = normalizeKeyDescriptorString(key),\n                existingBindings = _commandMap[commandID] || [];\n\n            // Skip this since we don't allow user to update key binding of a special\n            // command like cut, copy, paste, undo, redo and select all.\n            if (_isSpecialCommand(commandID)) {\n                restrictedCommands.push(commandID);\n                return;\n            }\n\n            // Skip this since we don't allow user to update a shortcut used in\n            // a special command or any Mac system command.\n            if (_isReservedShortcuts(normalizedKey)) {\n                restrictedKeys.push(key);\n                return;\n            }\n\n            // Skip this if the key is invalid.\n            if (!normalizedKey) {\n                invalidKeys.push(key);\n                return;\n            }\n\n            if (_isKeyAssigned(normalizedKey)) {\n                if (remappedKeys.indexOf(normalizedKey) !== -1) {\n                    // JSON parser already removed all the duplicates that have the exact\n                    // same case or order in their keys. So we're only detecting duplicate\n                    // bindings that have different orders or different cases used in the key.\n                    duplicateBindings.push(key);\n                    return;\n                }\n                // The same key binding already exists, so skip this.\n                if (_keyMap[normalizedKey].commandID === commandID) {\n                    // Still need to add it to the remappedCommands so that\n                    // we can detect any duplicate later on.\n                    remappedCommands.push(commandID);\n                    return;\n                }\n                removeBinding(normalizedKey);\n            }\n\n            if (remappedKeys.indexOf(normalizedKey) === -1) {\n                remappedKeys.push(normalizedKey);\n            }\n\n            // Remove another key binding if the new key binding is for a command\n            // that has a different key binding. e.g. \"Ctrl-W\": \"edit.selectLine\"\n            // requires us to remove \"Ctrl-W\" from \"file.close\" command, but we\n            // also need to remove \"Ctrl-L\" from \"edit.selectLine\".\n            if (existingBindings.length) {\n                existingBindings.forEach(function (binding) {\n                    removeBinding(binding.key);\n                });\n            }\n\n            if (commandID) {\n                if (_allCommands.indexOf(commandID) !== -1) {\n                    if (remappedCommands.indexOf(commandID) === -1) {\n                        var keybinding = { key: normalizedKey };\n\n                        keybinding.displayKey = _getDisplayKey(normalizedKey);\n                        _addBinding(commandID, keybinding.displayKey ? keybinding : normalizedKey, brackets.platform, true);\n                        remappedCommands.push(commandID);\n                    } else {\n                        multipleKeys.push(commandID);\n                    }\n                } else {\n                    invalidCommands.push(commandID);\n                }\n            }\n        });\n\n        if (restrictedCommands.length) {\n            errorMessage = StringUtils.format(Strings.ERROR_RESTRICTED_COMMANDS, _getBulletList(restrictedCommands));\n        }\n\n        if (restrictedKeys.length) {\n            errorMessage += StringUtils.format(Strings.ERROR_RESTRICTED_SHORTCUTS, _getBulletList(restrictedKeys));\n        }\n\n        if (multipleKeys.length) {\n            errorMessage += StringUtils.format(Strings.ERROR_MULTIPLE_SHORTCUTS, _getBulletList(multipleKeys));\n        }\n\n        if (duplicateBindings.length) {\n            errorMessage += StringUtils.format(Strings.ERROR_DUPLICATE_SHORTCUTS, _getBulletList(duplicateBindings));\n        }\n\n        if (invalidKeys.length) {\n            errorMessage += StringUtils.format(Strings.ERROR_INVALID_SHORTCUTS, _getBulletList(invalidKeys));\n        }\n\n        if (invalidCommands.length) {\n            errorMessage += StringUtils.format(Strings.ERROR_NONEXISTENT_COMMANDS, _getBulletList(invalidCommands));\n        }\n\n        if (_showErrors && errorMessage) {\n            _showErrorsAndOpenKeyMap(\"\", errorMessage);\n        }\n    }\n\n    /**\n     * @private\n     *\n     * Restores the default key bindings for all the commands that are modified by each key binding\n     * specified in _customKeyMapCache (old version) but no longer specified in _customKeyMap (new version).\n     */\n    function _undoPriorUserKeyBindings() {\n        _.forEach(_customKeyMapCache, function (commandID, key) {\n            var normalizedKey  = normalizeKeyDescriptorString(key),\n                defaults       = _.find(_.toArray(_defaultKeyMap), { \"commandID\": commandID }),\n                defaultCommand = _defaultKeyMap[normalizedKey];\n\n            // We didn't modified this before, so skip it.\n            if (_isSpecialCommand(commandID) ||\n                    _isReservedShortcuts(normalizedKey)) {\n                return;\n            }\n\n            if (_isKeyAssigned(normalizedKey) &&\n                    _customKeyMap[key] !== commandID && _customKeyMap[normalizedKey] !== commandID) {\n                // Unassign the key from any command. e.g. \"Cmd-W\": \"file.open\" in _customKeyMapCache\n                // will require us to remove Cmd-W shortcut from file.open command.\n                removeBinding(normalizedKey);\n            }\n\n            // Reassign the default key binding. e.g. \"Cmd-W\": \"file.open\" in _customKeyMapCache\n            // will require us to reassign Cmd-O shortcut to file.open command.\n            if (defaults) {\n                addBinding(commandID, defaults, brackets.platform);\n            }\n\n            // Reassign the default key binding of the previously modified command.\n            // e.g. \"Cmd-W\": \"file.open\" in _customKeyMapCache will require us to reassign Cmd-W\n            // shortcut to file.close command.\n            if (defaultCommand && defaultCommand.key) {\n                addBinding(defaultCommand.commandID, defaultCommand.key, brackets.platform);\n            }\n        });\n    }\n\n    /**\n     * @private\n     *\n     * Gets the full file path to the user key map file. In testing environment\n     * a different file path is returned so that running integration tests won't\n     * pop up the error dialog showing the errors from the actual user key map file.\n     *\n     * @return {string} full file path to the user key map file.\n     */\n    function _getUserKeyMapFilePath() {\n        if (window.isBracketsTestWindow) {\n            return path.normalize(brackets.app.getApplicationSupportDirectory() + \"/_test_/\" + KEYMAP_FILENAME);\n        }\n        return _userKeyMapFilePath;\n    }\n\n    /**\n     * @private\n     *\n     * Reads in the user key map file and parses its content into JSON.\n     * Returns the user key bindings if JSON has \"overrides\".\n     * Otherwise, returns an empty object or an error if the file\n     * cannot be parsed or loaded.\n     *\n     * @return {$.Promise} a jQuery promise that will be resolved with the JSON\n     * object if the user key map file has \"overrides\" property or an empty JSON.\n     * If the key map file cannot be read or cannot be parsed by the JSON parser,\n     * then the promise is rejected with an error.\n     */\n    function _readUserKeyMap() {\n        var file   = FileSystem.getFileForPath(_getUserKeyMapFilePath()),\n            result = new $.Deferred();\n\n        file.exists(function (err, doesExist) {\n            if (doesExist) {\n                FileUtils.readAsText(file)\n                    .done(function (text) {\n                        var keyMap = {};\n                        try {\n                            if (text) {\n                                var json = JSON.parse(text);\n                                // If no overrides, return an empty key map.\n                                result.resolve((json && json.overrides) || keyMap);\n                            } else {\n                                // The file is empty, so return an empty key map.\n                                result.resolve(keyMap);\n                            }\n                        } catch (err) {\n                            // Cannot parse the text read from the key map file.\n                            result.reject(err);\n                        }\n                    })\n                    .fail(function (err) {\n                        // Key map file cannot be loaded.\n                        result.reject(err);\n                    });\n            } else {\n                // Just resolve if no user key map file\n                result.resolve();\n            }\n        });\n        return result.promise();\n    }\n\n    /**\n     * @private\n     *\n     * Reads in the user key bindings and updates the key map with each user key\n     * binding by removing the existing one assigned to each key and adding\n     * new one for the specified command id. Shows errors and opens the user\n     * key map file if it cannot be parsed.\n     *\n     * This function is wrapped with debounce so that its execution is always delayed\n     * by 200 ms. The delay is required because when this function is called some\n     * extensions may still be adding some commands and their key bindings asychronously.\n     */\n    _loadUserKeyMap = _.debounce(function () {\n        _readUserKeyMap()\n            .then(function (keyMap) {\n                // Some extensions may add a new command without any key binding. So\n                // we always have to get all commands again to ensure that we also have\n                // those from any extensions installed during the current session.\n                _allCommands = CommandManager.getAll();\n\n                _customKeyMapCache = _.cloneDeep(_customKeyMap);\n                _customKeyMap = keyMap;\n                _undoPriorUserKeyBindings();\n                _applyUserKeyBindings();\n            }, function (err) {\n                _showErrorsAndOpenKeyMap(err);\n            });\n    }, 200);\n\n    /**\n     * @private\n     *\n     * Opens the existing key map file or creates a new one with default content\n     * if it does not exist.\n     */\n    function _openUserKeyMap() {\n        var userKeyMapPath = _getUserKeyMapFilePath(),\n            file = FileSystem.getFileForPath(userKeyMapPath);\n        file.exists(function (err, doesExist) {\n            if (doesExist) {\n                CommandManager.execute(Commands.FILE_OPEN, { fullPath: userKeyMapPath });\n            } else {\n                var defaultContent = \"{\\n    \\\"documentation\\\": \\\"https://github.com/adobe/brackets/wiki/User-Key-Bindings\\\",\" +\n                                     \"\\n    \\\"overrides\\\": {\" +\n                                     \"\\n        \\n    }\\n}\\n\";\n\n                FileUtils.writeText(file, defaultContent, true)\n                    .done(function () {\n                        CommandManager.execute(Commands.FILE_OPEN, { fullPath: userKeyMapPath });\n                    });\n            }\n        });\n    }\n\n    // Due to circular dependencies, not safe to call on() directly\n    EventDispatcher.on_duringInit(CommandManager, \"commandRegistered\", _handleCommandRegistered);\n    CommandManager.register(Strings.CMD_OPEN_KEYMAP, Commands.FILE_OPEN_KEYMAP, _openUserKeyMap);\n\n    // Asynchronously loading DocumentManager to avoid the circular dependency\n    require([\"document/DocumentManager\"], function (DocumentManager) {\n        DocumentManager.on(\"documentSaved\", function checkKeyMapUpdates(e, doc) {\n            if (doc && doc.file.fullPath === _userKeyMapFilePath) {\n                _loadUserKeyMap();\n            }\n        });\n    });\n\n    /**\n     * @private\n     *\n     * Initializes _allCommands array and _defaultKeyMap so that we can use them for\n     * detecting non-existent commands and restoring the original key binding.\n     */\n    function _initCommandAndKeyMaps() {\n        _allCommands = CommandManager.getAll();\n        // Keep a copy of the default key bindings before loading user key bindings.\n        _defaultKeyMap = _.cloneDeep(_keyMap);\n    }\n\n    /**\n     * @private\n     *\n     * Sets the full file path to the user key map file. Only used by unit tests\n     * to load a test file instead of the actual user key map file.\n     *\n     * @param {string} fullPath file path to the user key map file.\n     */\n    function _setUserKeyMapFilePath(fullPath) {\n        _userKeyMapFilePath = fullPath;\n    }\n\n    AppInit.extensionsLoaded(function () {\n        var params  = new UrlParams();\n        params.parse();\n        if (params.get(\"reloadWithoutUserExts\") === \"true\") {\n            _showErrors = false;\n        }\n\n        _initCommandAndKeyMaps();\n        _loadUserKeyMap();\n    });\n\n    // unit test only\n    exports._reset = _reset;\n    exports._setUserKeyMapFilePath = _setUserKeyMapFilePath;\n    exports._getDisplayKey = _getDisplayKey;\n    exports._loadUserKeyMap = _loadUserKeyMap;\n    exports._initCommandAndKeyMaps = _initCommandAndKeyMaps;\n    exports._onCtrlUp = _onCtrlUp;\n\n    // Define public API\n    exports.getKeymap = getKeymap;\n    exports.addBinding = addBinding;\n    exports.removeBinding = removeBinding;\n    exports.formatKeyDescriptor = formatKeyDescriptor;\n    exports.getKeyBindings = getKeyBindings;\n    exports.addGlobalKeydownHook = addGlobalKeydownHook;\n    exports.removeGlobalKeydownHook = removeGlobalKeydownHook;\n\n    /**\n     * Use windows-specific bindings if no other are found (e.g. Linux).\n     * Core Brackets modules that use key bindings should always define at\n     * least a generic keybinding that is applied for all platforms. This\n     * setting effectively creates a compatibility mode for third party\n     * extensions that define explicit key bindings for Windows and Mac, but\n     * not Linux.\n     */\n    exports.useWindowsCompatibleBindings = false;\n\n    // For unit testing only\n    exports._handleKey = _handleKey;\n    exports._handleKeyEvent = _handleKeyEvent;\n});\n"],"file":"KeyBindingManager.js"}
{"version":3,"sources":["command/CommandManager.js"],"names":["define","require","exports","module","EventDispatcher","EVENT_BEFORE_EXECUTE_COMMAND","SOURCE_KEYBOARD_SHORTCUT","SOURCE_UI_MENU_CLICK","SOURCE_OTHER","_commands","_commandsOriginal","Command","name","id","commandFn","options","this","_name","_id","_commandFn","_checked","undefined","_enabled","_options","register","console","log","error","command","trigger","registerInternal","_testReset","_testRestore","get","getAll","Object","keys","execute","err","args","Array","prototype","slice","call","arguments","eventSource","length","event","concat","apply","$","Deferred","reject","promise","makeEventDispatcher","getID","result","resolve","getEnabled","setEnabled","enabled","changed","setChecked","checked","getChecked","setName","getName"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n /**\n  * Manages global application commands that can be called from menu items, key bindings, or subparts\n  * of the application.\n  *\n  * This module dispatches these event(s):\n  *    - commandRegistered  -- when a new command is registered\n  *    - beforeExecuteCommand -- before dispatching a command\n  */\ndefine(function (require, exports, module) {\n\n\n    const EventDispatcher = require(\"utils/EventDispatcher\");\n\n    const EVENT_BEFORE_EXECUTE_COMMAND = \"beforeExecuteCommand\";\n    const SOURCE_KEYBOARD_SHORTCUT = \"keyboardShortcut\",\n        SOURCE_UI_MENU_CLICK = \"uiMenuClick\",\n        SOURCE_OTHER = \"otherExecAction\";\n\n\n    /**\n     * Map of all registered global commands\n     * @type {Object.<commandID: string, Command>}\n     */\n    let _commands = {};\n\n    /**\n     * Temporary copy of commands map for restoring after testing\n     * TODO (issue #1039): implement separate require contexts for unit tests\n     * @type {Object.<commandID: string, Command>}\n     */\n    let _commandsOriginal = {};\n\n    /**\n     * Events:\n     * - enabledStateChange\n     * - checkedStateChange\n     * - keyBindingAdded\n     * - keyBindingRemoved\n     *\n     * @constructor\n     * @private\n     * @param {string} name - text that will be displayed in the UI to represent command\n     * @param {string} id\n     * @param {function} commandFn - the function that is called when the command is executed.\n     *\n     * TODO: where should this be triggered, The Command or Exports?\n     * @param [options]\n     */\n    function Command(name, id, commandFn, options= {}) {\n        this._name = name;\n        this._id = id;\n        this._commandFn = commandFn;\n        this._checked = undefined;\n        this._enabled = true;\n        this._options = options;\n    }\n    EventDispatcher.makeEventDispatcher(Command.prototype);\n\n    /**\n     * Get command id\n     * @return {string}\n     */\n    Command.prototype.getID = function () {\n        return this._id;\n    };\n\n    /**\n     * Executes the command. Additional arguments are passed to the executing function\n     *\n     * @return {$.Promise} a jQuery promise that will be resolved when the command completes.\n     */\n    Command.prototype.execute = function () {\n        if (!this._enabled) {\n            return (new $.Deferred()).reject().promise();\n        }\n        let args = arguments;\n        if(this._options.eventSource) {\n            // This command has been registered with the optional source details set we have to ensure the event\n            // argument is inserted first. The event source may be already injected by the executor,\n            // if not we have to do it now.\n            if(!args.length || !(typeof args[0] === 'object' && args[0].eventSource)) {\n                const event = {eventSource: SOURCE_OTHER}; // default we don't know the source\n                args = [event].concat(args);\n            }\n        }\n        let result = this._commandFn.apply(this, args);\n        if (!result) {\n            // If command does not return a promise, assume that it handled the\n            // command and return a resolved promise\n            return (new $.Deferred()).resolve().promise();\n        }\n        return result;\n\n    };\n\n    /**\n     * Is command enabled?\n     * @return {boolean}\n     */\n    Command.prototype.getEnabled = function () {\n        return this._enabled;\n    };\n\n    /**\n     * Sets enabled state of Command and dispatches \"enabledStateChange\"\n     * when the enabled state changes.\n     * @param {boolean} enabled\n     */\n    Command.prototype.setEnabled = function (enabled) {\n        var changed = this._enabled !== enabled;\n        this._enabled = enabled;\n\n        if (changed) {\n            this.trigger(\"enabledStateChange\");\n        }\n    };\n\n    /**\n     * Sets enabled state of Command and dispatches \"checkedStateChange\"\n     * when the enabled state changes.\n     * @param {boolean} checked\n     */\n    Command.prototype.setChecked = function (checked) {\n        var changed = this._checked !== checked;\n        this._checked = checked;\n\n        if (changed) {\n            this.trigger(\"checkedStateChange\");\n        }\n    };\n\n    /**\n     * Is command checked?\n     * @return {boolean}\n     */\n    Command.prototype.getChecked = function () {\n        return this._checked;\n    };\n\n    /**\n     * Sets the name of the Command and dispatches \"nameChange\" so that\n     * UI that reflects the command name can update.\n     *\n     * Note, a Command name can appear in either HTML or native UI\n     * so HTML tags should not be used. To add a Unicode character,\n     * use \\uXXXX instead of an HTML entity.\n     *\n     * @param {string} name\n     */\n    Command.prototype.setName = function (name) {\n        var changed = this._name !== name;\n        this._name = name;\n\n        if (changed) {\n            this.trigger(\"nameChange\");\n        }\n    };\n\n    /**\n     * Get command name\n     * @return {string}\n     */\n    Command.prototype.getName = function () {\n        return this._name;\n    };\n\n\n\n    /**\n     * Registers a global command.\n     * @param {string} name - text that will be displayed in the UI to represent command\n     * @param {string} id - unique identifier for command.\n     *      Core commands in Brackets use a simple command title as an id, for example \"open.file\".\n     *      Extensions should use the following format: \"author.myextension.mycommandname\".\n     *      For example, \"lschmitt.csswizard.format.css\".\n     * @param {function(...)} commandFn - the function to call when the command is executed. Any arguments passed to\n     *     execute() (after the id) are passed as arguments to the function. If the function is asynchronous,\n     *     it must return a jQuery promise that is resolved when the command completes. Otherwise, the\n     *     CommandManager will assume it is synchronous, and return a promise that is already resolved.\n     * @param {Object} [options]\n     * @param {boolean} options.eventSource If set to true, the commandFn will be called with the first argument `event`\n     * with details about the source(invoker) as event.eventSource(one of the `CommandManager.SOURCE_*`) and\n     * event.sourceType(Eg. Ctrl-K) parameter.\n     * @return {?Command}\n     */\n    function register(name, id, commandFn, options={}) {\n        if (_commands[id]) {\n            console.log(\"Attempting to register an already-registered command: \" + id);\n            return null;\n        }\n        if (!name || !id || !commandFn) {\n            console.error(\"Attempting to register a command with a missing name, id, or command function:\" + name + \" \" + id);\n            return null;\n        }\n\n        var command = new Command(name, id, commandFn, options);\n        _commands[id] = command;\n\n        exports.trigger(\"commandRegistered\", command);\n\n        return command;\n    }\n\n    /**\n     * Registers a global internal only command.\n     * @param {string} id - unique identifier for command.\n     *      Core commands in Brackets use a simple command title as an id, for example \"app.abort_quit\".\n     *      Extensions should use the following format: \"author.myextension.mycommandname\".\n     *      For example, \"lschmitt.csswizard.format.css\".\n     * @param {function(...)} commandFn - the function to call when the command is executed. Any arguments passed to\n     *     execute() (after the id) are passed as arguments to the function. If the function is asynchronous,\n     *     it must return a jQuery promise that is resolved when the command completes. Otherwise, the\n     *     CommandManager will assume it is synchronous, and return a promise that is already resolved.\n     * @return {?Command}\n     */\n    function registerInternal(id, commandFn) {\n        if (_commands[id]) {\n            console.log(\"Attempting to register an already-registered command: \" + id);\n            return null;\n        }\n        if (!id || !commandFn) {\n            console.error(\"Attempting to register an internal command with a missing id, or command function: \" + id);\n            return null;\n        }\n\n        var command = new Command(null, id, commandFn);\n        _commands[id] = command;\n\n        exports.trigger(\"commandRegistered\", command);\n\n        return command;\n    }\n\n    /**\n     * Clear all commands for unit testing, but first make copy of commands so that\n     * they can be restored afterward\n     */\n    function _testReset() {\n        _commandsOriginal = _commands;\n        _commands = {};\n    }\n\n    /**\n     * Restore original commands after test and release copy\n     */\n    function _testRestore() {\n        _commands = _commandsOriginal;\n        _commandsOriginal = {};\n    }\n\n    /**\n     * Retrieves a Command object by id\n     * @param {string} id\n     * @return {Command}\n     */\n    function get(id) {\n        return _commands[id];\n    }\n\n    /**\n     * Returns the ids of all registered commands\n     * @return {Array.<string>}\n     */\n    function getAll() {\n        return Object.keys(_commands);\n    }\n\n    /**\n     * Looks up and runs a global command. Additional arguments are passed to the command.\n     *\n     * @param {string} id The ID of the command to run.\n     * @return {$.Promise} a jQuery promise that will be resolved when the command completes.\n     */\n    function execute(id) {\n        var command = _commands[id];\n\n        if (command) {\n            try {\n                exports.trigger(EVENT_BEFORE_EXECUTE_COMMAND, id);\n            } catch (err) {\n                console.error(err);\n            }\n            let args = Array.prototype.slice.call(arguments, 1); // remove id\n            if(command._options.eventSource) {\n                // This command has been registered with the optional source details set we have to ensure the event\n                // argument is inserted first. The event source may be already injected by the executor,\n                // if not we have to do it now.\n                if(!args.length || !(typeof args[0] === 'object' && args[0].eventSource)) {\n                    const event = {eventSource: SOURCE_OTHER}; // default we don't know the source\n                    args = [event].concat(args);\n                }\n            }\n\n            return command.execute.apply(command, args);\n        }\n        return (new $.Deferred()).reject().promise();\n\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // Define public API\n    exports.register            = register;\n    exports.registerInternal    = registerInternal;\n    exports.execute             = execute;\n    exports.get                 = get;\n    exports.getAll              = getAll;\n    exports._testReset          = _testReset;\n    exports._testRestore        = _testRestore;\n    exports.EVENT_BEFORE_EXECUTE_COMMAND = EVENT_BEFORE_EXECUTE_COMMAND;\n    exports.SOURCE_KEYBOARD_SHORTCUT = SOURCE_KEYBOARD_SHORTCUT;\n    exports.SOURCE_UI_MENU_CLICK = SOURCE_UI_MENU_CLICK;\n    exports.SOURCE_OTHER = SOURCE_OTHER;\n});\n"],"file":"CommandManager.js"}
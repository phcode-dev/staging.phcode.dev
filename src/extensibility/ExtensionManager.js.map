{"version":3,"sources":["extensibility/ExtensionManager.js"],"names":["define","require","exports","module","_","EventDispatcher","Package","AppInit","Async","ExtensionLoader","ExtensionUtils","FileSystem","FileUtils","PreferencesManager","Strings","StringUtils","ThemeManager","Metrics","EXTENSION_REGISTRY_LOCAL_STORAGE_KEY","Phoenix","isTestWindow","EXTENSION_REGISTRY_LOCAL_STORAGE_VERSION_KEY","semver","pendingDownloadRegistry","ENABLED","DISABLED","START_FAILED","LOCATION_DEFAULT","LOCATION_DEV","LOCATION_USER","LOCATION_UNKNOWN","FOLDER_AUTOINSTALL","extensions","_idsToRemove","_idsToUpdate","_idsToDisable","synchronizeEntry","id","entry","installInfo","registryInfo","owner","updateAvailable","updateCompatible","currentVersion","metadata","version","lt","lastCompatibleVersionInfo","findLast","versions","versionInfo","brackets","satisfies","apiVersion","lastCompatibleVersion","trigger","loadTheme","extension","theme","loadPackage","_setExtensions","newExtensions","Object","keys","forEach","_reset","_populateExtensions","registry","_shouldUpdateExtensionRegistry","Promise","resolve","reject","currentRegistryVersion","localStorage","getItem","countEvent","EVENT_TYPE","EXTENSIONS","$","ajax","url","config","extension_registry_version","dataType","cache","done","registryVersion","parseInt","registryJson","fail","err","console","error","downloadRegistry","force","promise","_updateRegistry","newVersion","extension_registry","setItem","JSON","stringify","alreadyResolvedFromCache","always","Deferred","setTimeout","parse","then","catch","_handleExtensionLoad","e","baseURL","setData","locationType","name","userExtensionPath","getUserExtensionPath","path","VFS","getPathForVirtualServingURL","title","indexOf","segments","split","parent","length","status","type","deduceMetadata","match","loadMetadata","disabled","getCompatibilityInfoForVersion","extVersion","requiredVersion","engines","result","isCompatible","compatibleVersion","charAt","requiresNewer","compareVersion","slice","getCompatibilityInfo","fallback","isLatestVersion","i","latestInfo","compatInfo","getExtensionURL","extension_url","remove","format","EXTENSION_NOT_INSTALLED","_enableOrDisable","enable","disable","update","packagePath","keepFile","installUpdate","getFileForPath","unlink","cleanupUpdates","installResult","filename","localPath","unmarkAllForRemoval","markForRemoval","mark","isMarkedForRemoval","hasExtensionsToRemove","markForDisabling","isMarkedForDisabling","hasExtensionsToDisable","unmarkAllForDisabling","updateFromDownload","installationResult","undefined","installationStatus","InstallationStatuses","ALREADY_INSTALLED","NEEDS_UPDATE","SAME_VERSION","OLDER_VERSION","removeUpdate","isMarkedForUpdate","hasExtensionsToUpdate","removeMarkedExtensions","doInParallel_aggregateErrors","disableMarkedExtensions","updateExtensions","getAvailableUpdates","extensionId","extensionInfo","push","installVersion","cleanAvailableUpdates","updates","reduce","arr","updateInfo","extDefinition","installedVersion","_getAutoInstallFiles","dirPath","autoExtensions","zipFiles","installZips","updateZips","deferred","getDirectoryForPath","getContents","contents","filter","dirItem","isFile","getFileExtension","fullPath","file","zipFilePromise","validate","requirePackageJSON","info","errors","formatError","zipArray","existingItem","extensionName","autoExtVersion","lte","some","zip","errorArray","errorObj","item","_autoInstallExtensions","getDirectoryPath","getNativeBracketsDirectoryPath","getViewState","installPromise","updatePromise","doSequentially","installFromPath","setViewState","stateManager","definePreference","description","SORT_EXTENSION_METHOD","appReady","_getNodeConnectionDeferred","on","EVENT_EXTENSION_LOADED","EVENT_EXTENSION_LOAD_FAILED","EVENT_EXTENSION_DISABLED","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n/*global Phoenix*/\n/*unittests: ExtensionManager*/\n\n/**\n * The ExtensionManager fetches/caches the extension registry and provides\n * information about the status of installed extensions. ExtensionManager raises the\n * following events:\n * - statusChange - indicates that an extension has been installed/uninstalled or\n *   its status has otherwise changed. Second parameter is the id of the\n *   extension.\n * - registryUpdate - indicates that an existing extension was synchronized\n *   with new data from the registry.\n */\ndefine(function (require, exports, module) {\n\n\n    const _                   = require(\"thirdparty/lodash\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        Package             = require(\"extensibility/Package\"),\n        AppInit             = require(\"utils/AppInit\"),\n        Async               = require(\"utils/Async\"),\n        ExtensionLoader     = require(\"utils/ExtensionLoader\"),\n        ExtensionUtils      = require(\"utils/ExtensionUtils\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        Strings             = require(\"strings\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        ThemeManager        = require(\"view/ThemeManager\"),\n        Metrics = require(\"utils/Metrics\");\n\n    const EXTENSION_REGISTRY_LOCAL_STORAGE_KEY = Phoenix.isTestWindow ?\n            \"test_extension_registry\" : \"extension_registry\",\n        EXTENSION_REGISTRY_LOCAL_STORAGE_VERSION_KEY = Phoenix.isTestWindow ?\n            \"test_extension_registry_version\" : \"extension_registry_version\";\n    // semver.browser is an AMD-compatible module\n    var semver = require(\"thirdparty/semver.browser\");\n\n    /**\n     * @private\n     * @type {$.Deferred} Keeps track of the current registry download so that if a request is already\n     * in progress and another request to download the registry comes in, we don't send yet another request.\n     * This is primarily used when multiple view models need to download the registry at the same time.\n     */\n    var pendingDownloadRegistry = null;\n\n    /**\n     * Extension status constants.\n     */\n    var ENABLED      = \"enabled\",\n        DISABLED     = \"disabled\",\n        START_FAILED = \"startFailed\";\n\n    /**\n     * Extension location constants.\n     */\n    var LOCATION_DEFAULT = \"default\",\n        LOCATION_DEV     = \"dev\",\n        LOCATION_USER    = \"user\",\n        LOCATION_UNKNOWN = \"unknown\";\n\n    /**\n     * Extension auto-install folder. Also used for preferences key.\n     */\n    var FOLDER_AUTOINSTALL = \"auto-install-extensions\";\n\n    /**\n     * @private\n     * @type {Object.<string, {metadata: Object, path: string, status: string}>}\n     * The set of all known extensions, both from the registry and locally installed.\n     * The keys are either \"name\" from package.json (for extensions that have package metadata)\n     * or the last segment of local file paths (for installed legacy extensions\n     * with no package metadata). The fields of each record are:\n     *     registryInfo: object containing the info for this id from the main registry (containing metadata, owner,\n     *         and versions). This will be null for legacy extensions.\n     *     installInfo: object containing the info for a locally-installed extension:\n     *         metadata: the package metadata loaded from the local package.json, or null if it's a legacy extension.\n     *             This will be different from registryInfo.metadata if there's a newer version in the registry.\n     *         path: the local path to the extension folder on disk\n     *         locationType: general type of installation; one of the LOCATION_* constants above\n     *         status: the current status, one of the status constants above\n     */\n    var extensions = {};\n\n    /**\n     * Requested changes to the installed extensions.\n     */\n    var _idsToRemove = {},\n        _idsToUpdate = {},\n        _idsToDisable = {};\n\n    PreferencesManager.stateManager.definePreference(FOLDER_AUTOINSTALL, \"object\", undefined);\n    PreferencesManager.definePreference(\"extensions.sort\", \"string\", \"downloadCount\", {\n        description: Strings.SORT_EXTENSION_METHOD\n    });\n\n    /**\n     * @private\n     * Synchronizes the information between the public registry and the installed\n     * extensions. Specifically, this makes the `owner` available in each and sets\n     * an `updateAvailable` flag.\n     *\n     * @param {string} id of the extension to synchronize\n     */\n    function synchronizeEntry(id) {\n        var entry = extensions[id];\n\n        // Do nothing if we only have one set of data\n        if (!entry || !entry.installInfo || !entry.registryInfo) {\n            return;\n        }\n\n        entry.installInfo.owner = entry.registryInfo.owner;\n\n        // Assume false\n        entry.installInfo.updateAvailable   = false;\n        entry.registryInfo.updateAvailable  = false;\n        entry.installInfo.updateCompatible  = false;\n        entry.registryInfo.updateCompatible = false;\n\n        var currentVersion = entry.installInfo.metadata ? entry.installInfo.metadata.version : null;\n        if (currentVersion && semver.lt(currentVersion, entry.registryInfo.metadata.version)) {\n            // Note: available update may still be incompatible; we check for this when rendering the Update button in ExtensionManagerView._renderItem()\n            entry.registryInfo.updateAvailable  = true;\n            entry.installInfo.updateAvailable   = true;\n            // Calculate updateCompatible to check if there's an update for current version of Brackets\n            var lastCompatibleVersionInfo = _.findLast(entry.registryInfo.versions, function (versionInfo) {\n                return !versionInfo.brackets || semver.satisfies(brackets.metadata.apiVersion, versionInfo.brackets);\n            });\n            if (lastCompatibleVersionInfo && lastCompatibleVersionInfo.version && semver.lt(currentVersion, lastCompatibleVersionInfo.version)) {\n                entry.installInfo.updateCompatible        = true;\n                entry.registryInfo.updateCompatible       = true;\n                entry.installInfo.lastCompatibleVersion   = lastCompatibleVersionInfo.version;\n                entry.registryInfo.lastCompatibleVersion  = lastCompatibleVersionInfo.version;\n            }\n        }\n\n        exports.trigger(\"registryUpdate\", id);\n    }\n\n\n    /**\n     * @private\n     * Verifies if an extension is a theme based on the presence of the field \"theme\"\n     * in the package.json.  If it is a theme, then the theme file is just loaded by the\n     * ThemeManager\n     *\n     * @param {string} id of the theme extension to load\n     */\n    function loadTheme(id) {\n        var extension = extensions[id];\n        if (extension.installInfo && extension.installInfo.metadata && extension.installInfo.metadata.theme) {\n            ThemeManager.loadPackage(extension.installInfo);\n        }\n    }\n\n\n    /**\n     * @private\n     * Sets our data. For unit testing only.\n     */\n    function _setExtensions(newExtensions) {\n        exports.extensions = extensions = newExtensions;\n        Object.keys(extensions).forEach(function (id) {\n            synchronizeEntry(id);\n        });\n    }\n\n    /**\n     * @private\n     * Clears out our existing data. For unit testing only.\n     */\n    function _reset() {\n        exports.extensions = extensions = {};\n        _idsToRemove = {};\n        _idsToUpdate = {};\n        _idsToDisable = {};\n    }\n\n    function _populateExtensions(registry) {\n        Object.keys(registry).forEach(function (id) {\n            if (!extensions[id]) {\n                extensions[id] = {};\n            }\n            extensions[id].registryInfo = registry[id];\n            synchronizeEntry(id);\n        });\n        exports.trigger(\"registryDownload\");\n    }\n\n    function _shouldUpdateExtensionRegistry() {\n        return new Promise((resolve, reject)=>{\n            const currentRegistryVersion = localStorage.getItem(EXTENSION_REGISTRY_LOCAL_STORAGE_VERSION_KEY) || \"1\";\n            Metrics.countEvent(Metrics.EVENT_TYPE.EXTENSIONS, \"registryVersion\",\n                `${currentRegistryVersion}`);\n            $.ajax({\n                url: brackets.config.extension_registry_version,\n                dataType: \"json\",\n                cache: false\n            })\n                .done(function (registryVersion) {\n                    if(registryVersion.version !== parseInt(currentRegistryVersion)){\n                        resolve(registryVersion.version);\n                    } else {\n                        const registryJson = localStorage.getItem(EXTENSION_REGISTRY_LOCAL_STORAGE_KEY);\n                        if(!registryJson) {\n                            resolve(registryVersion.version);\n                            // if we dont have anything, best to atlest try to fetch the registry now.\n                            return;\n                        }\n                        reject();\n                    }\n                })\n                .fail(function (err) {\n                    console.error(\"error Fetching Extension Registry version\", err);\n                    const registryJson = localStorage.getItem(EXTENSION_REGISTRY_LOCAL_STORAGE_KEY);\n                    if(!registryJson) {\n                        resolve(1); // if we dont have anything, best to atlest try to fetch the registry now.\n                        return;\n                    }\n                    reject();\n                });\n        });\n    }\n\n    /**\n     * Downloads the registry of Brackets extensions and stores the information in our\n     * extension info.\n     *\n     * @param {boolean} force - true to fetch registry from server fresh every time\n     * @return {$.Promise} a promise that's resolved with the registry JSON data\n     * or rejected if the server can't be reached.\n     */\n    function downloadRegistry(force) {\n        if (pendingDownloadRegistry) {\n            return pendingDownloadRegistry.promise();\n        }\n\n        pendingDownloadRegistry = new $.Deferred();\n\n        function _updateRegistry(newVersion) {\n            $.ajax({\n                url: brackets.config.extension_registry,\n                dataType: \"json\",\n                cache: false\n            })\n                .done(function (registry) {\n                    localStorage.setItem(EXTENSION_REGISTRY_LOCAL_STORAGE_VERSION_KEY, newVersion);\n                    localStorage.setItem(EXTENSION_REGISTRY_LOCAL_STORAGE_KEY, JSON.stringify(registry));\n                    if(!pendingDownloadRegistry.alreadyResolvedFromCache){\n                        _populateExtensions(registry);\n                        pendingDownloadRegistry.resolve();\n                    }\n                })\n                .fail(function (err) {\n                    console.error(\"error Fetching Extension Registry\", err);\n                    if(!pendingDownloadRegistry.alreadyResolvedFromCache){\n                        pendingDownloadRegistry.reject();\n                    }\n                })\n                .always(function () {\n                    // Make sure to clean up the pending registry so that new requests can be made.\n                    pendingDownloadRegistry = null;\n                });\n        }\n\n        if(force){\n            _updateRegistry();\n            return pendingDownloadRegistry.promise();\n        }\n\n        const registryJson = localStorage.getItem(EXTENSION_REGISTRY_LOCAL_STORAGE_KEY);\n        if(registryJson) {\n            // we always immediately but after the promise chain is setup after function return (some bug sigh)\n            // resolve for ui responsiveness and then check for updates.\n            setTimeout(()=>{\n                Metrics.countEvent(Metrics.EVENT_TYPE.EXTENSIONS, \"registry\", \"cachedUse\");\n                _populateExtensions(JSON.parse(registryJson));\n                pendingDownloadRegistry.resolve();\n            }, 0);\n            pendingDownloadRegistry.alreadyResolvedFromCache = true;\n        }\n        // check for latest updates even if we have cache\n        _shouldUpdateExtensionRegistry()\n            .then(_updateRegistry)\n            .catch(()=>{\n                pendingDownloadRegistry = null;\n            });\n\n        return pendingDownloadRegistry.promise();\n    }\n\n\n    /**\n     * @private\n     * When an extension is loaded, fetches the package.json and stores the extension in our map.\n     * @param {$.Event} e The event object\n     * @param {string} baseURL The http base url from which the extension is loaded\n     */\n    function _handleExtensionLoad(e, baseURL) {\n        function setData(metadata) {\n            let locationType,\n                id = metadata.name,\n                userExtensionPath = ExtensionLoader.getUserExtensionPath(),\n                path = baseURL;\n            if(Phoenix.VFS.getPathForVirtualServingURL(baseURL)){\n                path = Phoenix.VFS.getPathForVirtualServingURL(baseURL);\n            }\n            metadata.title = metadata.title || metadata.name;\n            if (path.indexOf(userExtensionPath) === 0) {\n                locationType = LOCATION_USER;\n            } else {\n                var segments = path.split(\"/\"), parent;\n                if (segments.length > 2) {\n                    parent = segments[segments.length - 2];\n                }\n                if (parent === \"dev\") {\n                    locationType = LOCATION_DEV;\n                } else if (parent === \"default\") {\n                    locationType = LOCATION_DEFAULT;\n                } else if (parent === \"user\") {\n                    locationType = LOCATION_USER;\n                } else {\n                    locationType = LOCATION_UNKNOWN;\n                }\n            }\n            if (!extensions[id]) {\n                extensions[id] = {};\n            }\n            extensions[id].installInfo = {\n                metadata: metadata,\n                path: baseURL,\n                locationType: locationType,\n                status: (e.type === \"loadFailed\" ? START_FAILED : (e.type === \"disabled\" ? DISABLED : ENABLED))\n            };\n\n            synchronizeEntry(id);\n            loadTheme(id);\n            exports.trigger(\"statusChange\", id);\n        }\n\n        function deduceMetadata() {\n            const match = baseURL.match(/\\/([^\\/]+)$/),\n                name = (match && match[1]) || baseURL,\n                metadata = { name: name, title: name };\n            return metadata;\n        }\n\n        ExtensionUtils.loadMetadata(baseURL)\n            .done(function (metadata) {\n                setData(metadata);\n            })\n            .fail(function (disabled) {\n                // If there's no package.json, this is a legacy extension. It was successfully loaded,\n                // but we don't have an official ID or metadata for it, so we just create an id and\n                // \"title\" for it (which is the last segment of its pathname)\n                // and record that it's enabled.\n                var metadata = deduceMetadata();\n                metadata.disabled = disabled;\n                setData(metadata);\n            });\n    }\n\n    /**\n     * Determines if the given versions[] entry is compatible with the given Brackets API version, and if not\n     * specifies why.\n     * @param {Object} extVersion\n     * @param {string} apiVersion\n     * @return {{isCompatible: boolean, requiresNewer: ?boolean, compatibleVersion: ?string}}\n     */\n    function getCompatibilityInfoForVersion(extVersion, apiVersion) {\n        var requiredVersion = (extVersion.brackets || (extVersion.engines && extVersion.engines.brackets)),\n            result = {};\n        result.isCompatible = !requiredVersion || semver.satisfies(apiVersion, requiredVersion);\n        if (result.isCompatible) {\n            result.compatibleVersion = extVersion.version;\n        } else {\n            // Find out reason for incompatibility\n            if (requiredVersion.charAt(0) === '<') {\n                result.requiresNewer = false;\n            } else if (requiredVersion.charAt(0) === '>') {\n                result.requiresNewer = true;\n            } else if (requiredVersion.charAt(0) === \"~\") {\n                var compareVersion = requiredVersion.slice(1);\n                // Need to add .0s to this style of range in order to compare (since valid version\n                // numbers must have major/minor/patch).\n                if (compareVersion.match(/^[0-9]+$/)) {\n                    compareVersion += \".0.0\";\n                } else if (compareVersion.match(/^[0-9]+\\.[0-9]+$/)) {\n                    compareVersion += \".0\";\n                }\n                result.requiresNewer = semver.lt(apiVersion, compareVersion);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Finds the newest version of the entry that is compatible with the given Brackets API version, if any.\n     * @param {Object} entry The registry entry to check.\n     * @param {string} apiVersion The Brackets API version to check against.\n     * @return {{isCompatible: boolean, requiresNewer: ?boolean, compatibleVersion: ?string, isLatestVersion: boolean}}\n     *      Result contains an \"isCompatible\" member saying whether it's compatible. If compatible, \"compatibleVersion\"\n     *      specifies the newest version that is compatible and \"isLatestVersion\" indicates if this is the absolute\n     *      latest version of the extension or not. If !isCompatible or !isLatestVersion, \"requiresNewer\" says whether\n     *      the latest version is incompatible due to requiring a newer (vs. older) version of Brackets.\n     */\n    function getCompatibilityInfo(entry, apiVersion) {\n        if (!entry.versions) {\n            var fallback = getCompatibilityInfoForVersion(entry.metadata, apiVersion);\n            if (fallback.isCompatible) {\n                fallback.isLatestVersion = true;\n            }\n            return fallback;\n        }\n\n        var i = entry.versions.length - 1,\n            latestInfo = getCompatibilityInfoForVersion(entry.versions[i], apiVersion);\n\n        if (latestInfo.isCompatible) {\n            latestInfo.isLatestVersion = true;\n            return latestInfo;\n        }\n            // Look at earlier versions (skipping very latest version since we already checked it)\n        for (i--; i >= 0; i--) {\n            var compatInfo = getCompatibilityInfoForVersion(entry.versions[i], apiVersion);\n            if (compatInfo.isCompatible) {\n                compatInfo.isLatestVersion = false;\n                compatInfo.requiresNewer = latestInfo.requiresNewer;\n                return compatInfo;\n            }\n        }\n\n            // No version is compatible, so just return info for the latest version\n        return latestInfo;\n\n    }\n\n    /**\n     * Given an extension id and version number, returns the URL for downloading that extension from\n     * the repository. Does not guarantee that the extension exists at that URL.\n     * @param {string} id The extension's name from the metadata.\n     * @param {string} version The version to download.\n     * @return {string} The URL to download the extension from.\n     */\n    function getExtensionURL(id, version) {\n        return `${brackets.config.extension_url}${id}-${version}.zip`;\n    }\n\n    /**\n     * Removes the installed extension with the given id.\n     * @param {string} id The id of the extension to remove.\n     * @return {$.Promise} A promise that's resolved when the extension is removed or\n     *     rejected with an error if there's a problem with the removal.\n     */\n    function remove(id) {\n        var result = new $.Deferred();\n        if (extensions[id] && extensions[id].installInfo) {\n            Package.remove(extensions[id].installInfo.path)\n                .done(function () {\n                    extensions[id].installInfo = null;\n                    result.resolve();\n                    exports.trigger(\"statusChange\", id);\n                })\n                .fail(function (err) {\n                    result.reject(err);\n                });\n        } else {\n            result.reject(StringUtils.format(Strings.EXTENSION_NOT_INSTALLED, id));\n        }\n        return result.promise();\n    }\n\n    /**\n     * @private\n     *\n     * Disables or enables the installed extensions.\n     *\n     * @param {string} id The id of the extension to disable or enable.\n     * @param {boolean} enable A boolean indicating whether to enable or disable.\n     * @return {$.Promise} A promise that's resolved when the extension action is\n     *      completed or rejected with an error that prevents the action from completion.\n     */\n    function _enableOrDisable(id, enable) {\n        var result = new $.Deferred(),\n            extension = extensions[id];\n        if (extension && extension.installInfo) {\n            Package[(enable ? \"enable\" : \"disable\")](extension.installInfo.path)\n                .done(function () {\n                    extension.installInfo.status = enable ? ENABLED : DISABLED;\n                    extension.installInfo.metadata.disabled = !enable;\n                    result.resolve();\n                    exports.trigger(\"statusChange\", id);\n                })\n                .fail(function (err) {\n                    result.reject(err);\n                });\n        } else {\n            result.reject(StringUtils.format(Strings.EXTENSION_NOT_INSTALLED, id));\n        }\n        return result.promise();\n    }\n\n    /**\n     * Disables the installed extension with the given id.\n     *\n     * @param {string} id The id of the extension to disable.\n     * @return {$.Promise} A promise that's resolved when the extenion is disabled or\n     *      rejected with an error that prevented the disabling.\n     */\n    function disable(id) {\n        return _enableOrDisable(id, false);\n    }\n\n    /**\n     * Enables the installed extension with the given id.\n     *\n     * @param {string} id The id of the extension to enable.\n     * @return {$.Promise} A promise that's resolved when the extenion is enabled or\n     *      rejected with an error that prevented the enabling.\n     */\n    function enable(id) {\n        return _enableOrDisable(id, true);\n    }\n\n    /**\n     * Updates an installed extension with the given package file.\n     * @param {string} id of the extension\n     * @param {string} packagePath path to the package file\n     * @param {boolean=} keepFile Flag to keep extension package file, default=false\n     * @return {$.Promise} A promise that's resolved when the extension is updated or\n     *     rejected with an error if there's a problem with the update.\n     */\n    function update(id, packagePath, keepFile) {\n        return Package.installUpdate(packagePath, id).done(function () {\n            if (!keepFile) {\n                FileSystem.getFileForPath(packagePath).unlink();\n            }\n        });\n    }\n\n    /**\n     * Deletes any temporary files left behind by extensions that\n     * were marked for update.\n     */\n    function cleanupUpdates() {\n        Object.keys(_idsToUpdate).forEach(function (id) {\n            var installResult = _idsToUpdate[id],\n                keepFile = installResult.keepFile,\n                filename = installResult.localPath;\n\n            if (filename && !keepFile) {\n                FileSystem.getFileForPath(filename).unlink();\n            }\n        });\n        _idsToUpdate = {};\n    }\n\n    /**\n     * Unmarks all extensions marked for removal.\n     */\n    function unmarkAllForRemoval() {\n        _idsToRemove = {};\n    }\n\n    /**\n     * Marks an extension for later removal, or unmarks an extension previously marked.\n     * @param {string} id The id of the extension to mark for removal.\n     * @param {boolean} mark Whether to mark or unmark it.\n     */\n    function markForRemoval(id, mark) {\n        if (mark) {\n            _idsToRemove[id] = true;\n        } else {\n            delete _idsToRemove[id];\n        }\n        exports.trigger(\"statusChange\", id);\n    }\n\n    /**\n     * Returns true if an extension is marked for removal.\n     * @param {string} id The id of the extension to check.\n     * @return {boolean} true if it's been marked for removal, false otherwise.\n     */\n    function isMarkedForRemoval(id) {\n        return !!(_idsToRemove[id]);\n    }\n\n    /**\n     * Returns true if there are any extensions marked for removal.\n     * @return {boolean} true if there are extensions to remove\n     */\n    function hasExtensionsToRemove() {\n        return Object.keys(_idsToRemove).length > 0;\n    }\n\n    /**\n     * Marks an extension for disabling later, or unmarks an extension previously marked.\n     *\n     * @param {string} id The id of the extension\n     * @param {boolean} mark Whether to mark or unmark the extension.\n     */\n    function markForDisabling(id, mark) {\n        if (mark) {\n            _idsToDisable[id] = true;\n        } else {\n            delete _idsToDisable[id];\n        }\n        exports.trigger(\"statusChange\", id);\n    }\n\n    /**\n     * Returns true if an extension is mark for disabling.\n     *\n     * @param {string} id The id of the extension to check.\n     * @return {boolean} true if it's been mark for disabling, false otherwise.\n     */\n    function isMarkedForDisabling(id) {\n        return !!(_idsToDisable[id]);\n    }\n\n    /**\n     * Returns true if there are any extensions marked for disabling.\n     * @return {boolean} true if there are extensions to disable\n     */\n    function hasExtensionsToDisable() {\n        return Object.keys(_idsToDisable).length > 0;\n    }\n\n    /**\n     * Unmarks all the extensions that have been marked for disabling.\n     */\n    function unmarkAllForDisabling() {\n        _idsToDisable = {};\n    }\n\n    /**\n     * If a downloaded package appears to be an update, mark the extension for update.\n     * If an extension was previously marked for removal, marking for update will\n     * turn off the removal mark.\n     * @param {Object} installationResult info about the install provided by the Package.download function\n     */\n    function updateFromDownload(installationResult) {\n        if (installationResult.keepFile === undefined) {\n            installationResult.keepFile = false;\n        }\n\n        var installationStatus = installationResult.installationStatus;\n        if (installationStatus === Package.InstallationStatuses.ALREADY_INSTALLED ||\n                installationStatus === Package.InstallationStatuses.NEEDS_UPDATE ||\n                installationStatus === Package.InstallationStatuses.SAME_VERSION ||\n                installationStatus === Package.InstallationStatuses.OLDER_VERSION) {\n            var id = installationResult.name;\n            delete _idsToRemove[id];\n            _idsToUpdate[id] = installationResult;\n            exports.trigger(\"statusChange\", id);\n        }\n    }\n\n    /**\n     * Removes the mark for an extension to be updated on restart. Also deletes the\n     * downloaded package file.\n     * @param {string} id The id of the extension for which the update is being removed\n     */\n    function removeUpdate(id) {\n        var installationResult = _idsToUpdate[id];\n        if (!installationResult) {\n            return;\n        }\n        if (installationResult.localPath && !installationResult.keepFile) {\n            FileSystem.getFileForPath(installationResult.localPath).unlink();\n        }\n        delete _idsToUpdate[id];\n        exports.trigger(\"statusChange\", id);\n    }\n\n    /**\n     * Returns true if an extension is marked for update.\n     * @param {string} id The id of the extension to check.\n     * @return {boolean} true if it's been marked for update, false otherwise.\n     */\n    function isMarkedForUpdate(id) {\n        return !!(_idsToUpdate[id]);\n    }\n\n    /**\n     * Returns true if there are any extensions marked for update.\n     * @return {boolean} true if there are extensions to update\n     */\n    function hasExtensionsToUpdate() {\n        return Object.keys(_idsToUpdate).length > 0;\n    }\n\n    /**\n     * Removes extensions previously marked for removal.\n     * @return {$.Promise} A promise that's resolved when all extensions are removed, or rejected\n     *     if one or more extensions can't be removed. When rejected, the argument will be an\n     *     array of error objects, each of which contains an \"item\" property with the id of the\n     *     failed extension and an \"error\" property with the actual error.\n     */\n    function removeMarkedExtensions() {\n        return Async.doInParallel_aggregateErrors(\n            Object.keys(_idsToRemove),\n            function (id) {\n                return remove(id);\n            }\n        );\n    }\n\n    /**\n     * Disables extensions marked for disabling.\n     *\n     * If the return promise is rejected, the argument will contain an array of objects. Each\n     * element is an object identifying the extension failed with \"item\" property set to the\n     * extension id which has failed to be disabled and \"error\" property set to the error.\n     *\n     * @return {$.Promise} A promise that's resolved when all extensions marked for disabling are\n     *      disabled or rejected if one or more extensions can't be disabled.\n     */\n    function disableMarkedExtensions() {\n        return Async.doInParallel_aggregateErrors(\n            Object.keys(_idsToDisable),\n            function (id) {\n                return disable(id);\n            }\n        );\n    }\n\n    /**\n     * Updates extensions previously marked for update.\n     * @return {$.Promise} A promise that's resolved when all extensions are updated, or rejected\n     *     if one or more extensions can't be updated. When rejected, the argument will be an\n     *     array of error objects, each of which contains an \"item\" property with the id of the\n     *     failed extension and an \"error\" property with the actual error.\n     */\n    function updateExtensions() {\n        return Async.doInParallel_aggregateErrors(\n            Object.keys(_idsToUpdate),\n            function (id) {\n                var installationResult = _idsToUpdate[id];\n                return update(installationResult.name, installationResult.localPath, installationResult.keepFile);\n            }\n        );\n    }\n\n    /**\n     * Gets an array of extensions that are currently installed and can be updated to a new version\n     * @return {Array.<{id: string, installVersion: string, registryVersion: string}>}\n     *     where id = extensionId\n     *     installVersion = currently installed version of extension\n     *     registryVersion = latest version compatible with current Brackets\n     */\n    function getAvailableUpdates() {\n        var result = [];\n        Object.keys(extensions).forEach(function (extensionId) {\n            var extensionInfo = extensions[extensionId];\n            // skip extensions that are not installed or are not in the registry\n            if (!extensionInfo.installInfo || !extensionInfo.registryInfo) {\n                return;\n            }\n            if (extensionInfo.registryInfo.updateCompatible) {\n                result.push({\n                    id: extensionId,\n                    installVersion: extensionInfo.installInfo.metadata.version,\n                    registryVersion: extensionInfo.registryInfo.lastCompatibleVersion\n                });\n            }\n        });\n        return result;\n    }\n\n    /**\n     * Takes the array returned from getAvailableUpdates() as an input and removes those entries\n     * that are no longer current - when currently installed version of an extension\n     * is equal or newer than registryVersion returned by getAvailableUpdates().\n     * This function is designed to work without the necessity to download extension registry\n     * @param {Array.<{id: string, installVersion: string, registryVersion: string}>} updates\n     *     previous output of getAvailableUpdates()\n     * @return {Array.<{id: string, installVersion: string, registryVersion: string}>}\n     *     filtered input as function description\n     */\n    function cleanAvailableUpdates(updates) {\n        return updates.reduce(function (arr, updateInfo) {\n            var extDefinition = extensions[updateInfo.id];\n            if (!extDefinition || !extDefinition.installInfo) {\n                // extension has been uninstalled in the meantime\n                return arr;\n            }\n\n            var installedVersion = extDefinition.installInfo.metadata.version;\n            if (semver.lt(installedVersion, updateInfo.registryVersion)) {\n                arr.push(updateInfo);\n            }\n\n            return arr;\n        }, []);\n    }\n\n    /**\n     * @private\n     * Find valid extensions in specified path\n     * @param {string} dirPath Directory with extensions\n     * @param {Object} autoExtensions Object that maps names of previously auto-installed\n     *      extensions {string} to installed version {string}.\n     * @return {$.Promise} Promise that resolves with arrays for extensions to update and install\n     */\n    function _getAutoInstallFiles(dirPath, autoExtensions) {\n        var zipFiles    = [],\n            installZips = [],\n            updateZips  = [],\n            deferred    = new $.Deferred();\n\n        FileSystem.getDirectoryForPath(dirPath).getContents(function (err, contents) {\n            if (!err) {\n                zipFiles = contents.filter(function (dirItem) {\n                    return (dirItem.isFile && FileUtils.getFileExtension(dirItem.fullPath) === \"zip\");\n                });\n            }\n\n            // Parse zip files and separate new installs vs. updates\n            Async.doInParallel_aggregateErrors(zipFiles, function (file) {\n                var zipFilePromise = new $.Deferred();\n\n                // Call validate() so that we open the local zip file and parse the\n                // package.json. We need the name to detect if this zip will be a\n                // new install or an update.\n                Package.validate(file.fullPath, { requirePackageJSON: true }).done(function (info) {\n                    if (info.errors.length) {\n                        zipFilePromise.reject(Package.formatError(info.errors));\n                        return;\n                    }\n\n                    var extensionInfo, installedVersion, zipArray, existingItem,\n                        extensionName   = info.metadata.name,\n                        autoExtVersion  = autoExtensions[extensionName];\n\n                    // Verify extension has not already been auto-installed/updated\n                    if (autoExtVersion && semver.lte(info.metadata.version, autoExtVersion)) {\n                        // Have already auto installed/updated version >= version of this extension\n                        zipFilePromise.reject();\n                        return;\n                    }\n\n                    // Verify extension has not already been installed/updated by some other means\n                    extensionInfo = extensions[extensionName];\n                    installedVersion = extensionInfo && extensionInfo.installInfo && extensionInfo.installInfo.metadata.version;\n                    if (installedVersion && semver.lte(info.metadata.version, installedVersion)) {\n                        // Have already manually installed/updated version >= version of this extension\n                        zipFilePromise.reject();\n                        return;\n                    }\n\n                    // Update appropriate zip array. There could be multiple zip files for an\n                    // extension, so make sure only the latest is stored\n                    zipArray = (installedVersion) ? updateZips : installZips;\n                    zipArray.some(function (zip) {\n                        if (zip.info.metadata.name === extensionName) {\n                            existingItem = zip;\n                            return true;\n                        }\n                        return false;\n                    });\n                    if (existingItem) {\n                        if (semver.lt(existingItem.info.metadata.version, info.metadata.version)) {\n                            existingItem.file = file;\n                            existingItem.info = info;\n                        }\n                    } else {\n                        zipArray.push({ file: file, info: info });\n                    }\n\n                    zipFilePromise.resolve();\n                }).fail(function (err) {\n                    zipFilePromise.reject(Package.formatError(err));\n                });\n\n                return zipFilePromise.promise();\n            }).fail(function (errorArray) {\n                // Async.doInParallel() fails if some are successful, so write errors\n                // to console and always resolve\n                errorArray.forEach(function (errorObj) {\n                    // If we rejected without an error argument, it means it was no problem\n                    // (e.g. same version of extension is already installed)\n                    if (errorObj.error) {\n                        if (errorObj.error.forEach) {\n                            console.error(\"Errors for\", errorObj.item);\n                            errorObj.error.forEach(function (error) {\n                                console.error(Package.formatError(error));\n                            });\n                        } else {\n                            console.error(\"Error for\", errorObj.item, errorObj);\n                        }\n                    }\n                });\n            }).always(function () {\n                deferred.resolve({\n                    installZips: installZips,\n                    updateZips: updateZips\n                });\n            });\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * @private\n     * Auto-install extensions bundled with installer\n     * @return {$.Promise} Promise that resolves when finished\n     */\n    function _autoInstallExtensions() {\n        var dirPath        = FileUtils.getDirectoryPath(FileUtils.getNativeBracketsDirectoryPath()) + FOLDER_AUTOINSTALL + \"/\",\n            autoExtensions = PreferencesManager.getViewState(FOLDER_AUTOINSTALL) || {},\n            deferred       = new $.Deferred();\n\n        _getAutoInstallFiles(dirPath, autoExtensions).done(function (result) {\n            var installPromise = Async.doSequentially(result.installZips, function (zip) {\n                autoExtensions[zip.info.metadata.name] = zip.info.metadata.version;\n                return Package.installFromPath(zip.file.fullPath);\n            });\n\n            var updatePromise = installPromise.always(function () {\n                return Async.doSequentially(result.updateZips, function (zip) {\n                    autoExtensions[zip.info.metadata.name] = zip.info.metadata.version;\n                    return Package.installUpdate(zip.file.fullPath);\n                });\n            });\n\n            // Always resolve the outer promise\n            updatePromise.always(function () {\n                // Keep track of auto-installed extensions so we only install an extension once\n                PreferencesManager.setViewState(FOLDER_AUTOINSTALL, autoExtensions);\n\n                deferred.resolve();\n            });\n        });\n\n        return deferred.promise();\n    }\n\n    AppInit.appReady(function () {\n        Package._getNodeConnectionDeferred().done(function () {\n            _autoInstallExtensions();\n        });\n    });\n\n    // Listen to extension load and loadFailed events\n    ExtensionLoader\n        .on(ExtensionLoader.EVENT_EXTENSION_LOADED, _handleExtensionLoad)\n        .on(ExtensionLoader.EVENT_EXTENSION_LOAD_FAILED, _handleExtensionLoad)\n        .on(ExtensionLoader.EVENT_EXTENSION_DISABLED, _handleExtensionLoad);\n\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // Public exports\n    exports.downloadRegistry        = downloadRegistry;\n    exports.getCompatibilityInfo    = getCompatibilityInfo;\n    exports.getExtensionURL         = getExtensionURL;\n    exports.remove                  = remove;\n    exports.update                  = update;\n    exports.disable                 = disable;\n    exports.enable                  = enable;\n    exports.extensions              = extensions;\n    exports.cleanupUpdates          = cleanupUpdates;\n    exports.markForRemoval          = markForRemoval;\n    exports.isMarkedForRemoval      = isMarkedForRemoval;\n    exports.unmarkAllForRemoval     = unmarkAllForRemoval;\n    exports.hasExtensionsToRemove   = hasExtensionsToRemove;\n    exports.markForDisabling        = markForDisabling;\n    exports.isMarkedForDisabling    = isMarkedForDisabling;\n    exports.unmarkAllForDisabling   = unmarkAllForDisabling;\n    exports.hasExtensionsToDisable  = hasExtensionsToDisable;\n    exports.updateFromDownload      = updateFromDownload;\n    exports.removeUpdate            = removeUpdate;\n    exports.isMarkedForUpdate       = isMarkedForUpdate;\n    exports.hasExtensionsToUpdate   = hasExtensionsToUpdate;\n    exports.removeMarkedExtensions  = removeMarkedExtensions;\n    exports.disableMarkedExtensions = disableMarkedExtensions;\n    exports.updateExtensions        = updateExtensions;\n    exports.getAvailableUpdates     = getAvailableUpdates;\n    exports.cleanAvailableUpdates   = cleanAvailableUpdates;\n\n    exports.ENABLED       = ENABLED;\n    exports.DISABLED      = DISABLED;\n    exports.START_FAILED  = START_FAILED;\n\n    exports.LOCATION_DEFAULT  = LOCATION_DEFAULT;\n    exports.LOCATION_DEV      = LOCATION_DEV;\n    exports.LOCATION_USER     = LOCATION_USER;\n    exports.LOCATION_UNKNOWN  = LOCATION_UNKNOWN;\n\n    // For unit testing only\n    exports._getAutoInstallFiles    = _getAutoInstallFiles;\n    exports._reset                  = _reset;\n    exports._setExtensions          = _setExtensions;\n    if(Phoenix.isTestWindow){\n        exports.EXTENSION_REGISTRY_LOCAL_STORAGE_KEY = EXTENSION_REGISTRY_LOCAL_STORAGE_KEY;\n    }\n});\n"],"file":"ExtensionManager.js"}
{"version":3,"sources":["extensibility/ExtensionManager.js"],"names":["define","require","exports","module","_","EventDispatcher","Package","AppInit","Async","ExtensionLoader","ExtensionUtils","FileSystem","FileUtils","PreferencesManager","Strings","StringUtils","ThemeManager","semver","pendingDownloadRegistry","ENABLED","DISABLED","START_FAILED","LOCATION_DEFAULT","LOCATION_DEV","LOCATION_USER","LOCATION_UNKNOWN","FOLDER_AUTOINSTALL","extensions","_idsToRemove","_idsToUpdate","_idsToDisable","synchronizeEntry","id","entry","installInfo","registryInfo","owner","updateAvailable","updateCompatible","currentVersion","metadata","version","lt","lastCompatibleVersionInfo","findLast","versions","versionInfo","brackets","satisfies","apiVersion","lastCompatibleVersion","trigger","loadTheme","extension","theme","loadPackage","_setExtensions","newExtensions","Object","keys","forEach","_reset","downloadRegistry","promise","$","Deferred","ajax","url","config","extension_registry","dataType","cache","done","data","hasDownloadedRegistry","resolve","fail","reject","always","_handleExtensionLoad","e","path","setData","locationType","name","userExtensionPath","getUserExtensionPath","title","indexOf","segments","split","parent","length","status","type","deduceMetadata","match","loadMetadata","disabled","getCompatibilityInfoForVersion","extVersion","requiredVersion","engines","result","isCompatible","compatibleVersion","charAt","requiresNewer","compareVersion","slice","getCompatibilityInfo","fallback","isLatestVersion","i","latestInfo","compatInfo","getExtensionURL","format","extension_url","remove","err","EXTENSION_NOT_INSTALLED","_enableOrDisable","enable","disable","update","packagePath","keepFile","installUpdate","getFileForPath","unlink","cleanupUpdates","installResult","filename","localPath","unmarkAllForRemoval","markForRemoval","mark","isMarkedForRemoval","hasExtensionsToRemove","markForDisabling","isMarkedForDisabling","hasExtensionsToDisable","unmarkAllForDisabling","updateFromDownload","installationResult","undefined","installationStatus","InstallationStatuses","ALREADY_INSTALLED","NEEDS_UPDATE","SAME_VERSION","OLDER_VERSION","removeUpdate","isMarkedForUpdate","hasExtensionsToUpdate","removeMarkedExtensions","doInParallel_aggregateErrors","disableMarkedExtensions","updateExtensions","getAvailableUpdates","extensionId","extensionInfo","push","installVersion","registryVersion","cleanAvailableUpdates","updates","reduce","arr","updateInfo","extDefinition","installedVersion","_getAutoInstallFiles","dirPath","autoExtensions","zipFiles","installZips","updateZips","deferred","getDirectoryForPath","getContents","contents","filter","dirItem","isFile","getFileExtension","fullPath","file","zipFilePromise","validate","requirePackageJSON","info","errors","formatError","zipArray","existingItem","extensionName","autoExtVersion","lte","some","zip","errorArray","errorObj","error","console","item","_autoInstallExtensions","getDirectoryPath","getNativeBracketsDirectoryPath","getViewState","installPromise","updatePromise","doSequentially","installFromPath","setViewState","stateManager","definePreference","description","SORT_EXTENSION_METHOD","appReady","_getNodeConnectionDeferred","on","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n/*unittests: ExtensionManager*/\n\n/**\n * The ExtensionManager fetches/caches the extension registry and provides\n * information about the status of installed extensions. ExtensionManager raises the\n * following events:\n * - statusChange - indicates that an extension has been installed/uninstalled or\n *   its status has otherwise changed. Second parameter is the id of the\n *   extension.\n * - registryUpdate - indicates that an existing extension was synchronized\n *   with new data from the registry.\n */\ndefine(function (require, exports, module) {\n\n\n    var _                   = require(\"thirdparty/lodash\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        Package             = require(\"extensibility/Package\"),\n        AppInit             = require(\"utils/AppInit\"),\n        Async               = require(\"utils/Async\"),\n        ExtensionLoader     = require(\"utils/ExtensionLoader\"),\n        ExtensionUtils      = require(\"utils/ExtensionUtils\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        Strings             = require(\"strings\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        ThemeManager        = require(\"view/ThemeManager\");\n\n    // semver.browser is an AMD-compatible module\n    var semver = require(\"thirdparty/semver.browser\");\n\n    /**\n     * @private\n     * @type {$.Deferred} Keeps track of the current registry download so that if a request is already\n     * in progress and another request to download the registry comes in, we don't send yet another request.\n     * This is primarily used when multiple view models need to download the registry at the same time.\n     */\n    var pendingDownloadRegistry = null;\n\n    /**\n     * Extension status constants.\n     */\n    var ENABLED      = \"enabled\",\n        DISABLED     = \"disabled\",\n        START_FAILED = \"startFailed\";\n\n    /**\n     * Extension location constants.\n     */\n    var LOCATION_DEFAULT = \"default\",\n        LOCATION_DEV     = \"dev\",\n        LOCATION_USER    = \"user\",\n        LOCATION_UNKNOWN = \"unknown\";\n\n    /**\n     * Extension auto-install folder. Also used for preferences key.\n     */\n    var FOLDER_AUTOINSTALL = \"auto-install-extensions\";\n\n    /**\n     * @private\n     * @type {Object.<string, {metadata: Object, path: string, status: string}>}\n     * The set of all known extensions, both from the registry and locally installed.\n     * The keys are either \"name\" from package.json (for extensions that have package metadata)\n     * or the last segment of local file paths (for installed legacy extensions\n     * with no package metadata). The fields of each record are:\n     *     registryInfo: object containing the info for this id from the main registry (containing metadata, owner,\n     *         and versions). This will be null for legacy extensions.\n     *     installInfo: object containing the info for a locally-installed extension:\n     *         metadata: the package metadata loaded from the local package.json, or null if it's a legacy extension.\n     *             This will be different from registryInfo.metadata if there's a newer version in the registry.\n     *         path: the local path to the extension folder on disk\n     *         locationType: general type of installation; one of the LOCATION_* constants above\n     *         status: the current status, one of the status constants above\n     */\n    var extensions = {};\n\n    /**\n     * Requested changes to the installed extensions.\n     */\n    var _idsToRemove = {},\n        _idsToUpdate = {},\n        _idsToDisable = {};\n\n    PreferencesManager.stateManager.definePreference(FOLDER_AUTOINSTALL, \"object\", undefined);\n    PreferencesManager.definePreference(\"extensions.sort\", \"string\", \"publishedDate\", {\n        description: Strings.SORT_EXTENSION_METHOD\n    });\n\n    /**\n     * @private\n     * Synchronizes the information between the public registry and the installed\n     * extensions. Specifically, this makes the `owner` available in each and sets\n     * an `updateAvailable` flag.\n     *\n     * @param {string} id of the extension to synchronize\n     */\n    function synchronizeEntry(id) {\n        var entry = extensions[id];\n\n        // Do nothing if we only have one set of data\n        if (!entry || !entry.installInfo || !entry.registryInfo) {\n            return;\n        }\n\n        entry.installInfo.owner = entry.registryInfo.owner;\n\n        // Assume false\n        entry.installInfo.updateAvailable   = false;\n        entry.registryInfo.updateAvailable  = false;\n        entry.installInfo.updateCompatible  = false;\n        entry.registryInfo.updateCompatible = false;\n\n        var currentVersion = entry.installInfo.metadata ? entry.installInfo.metadata.version : null;\n        if (currentVersion && semver.lt(currentVersion, entry.registryInfo.metadata.version)) {\n            // Note: available update may still be incompatible; we check for this when rendering the Update button in ExtensionManagerView._renderItem()\n            entry.registryInfo.updateAvailable  = true;\n            entry.installInfo.updateAvailable   = true;\n            // Calculate updateCompatible to check if there's an update for current version of Brackets\n            var lastCompatibleVersionInfo = _.findLast(entry.registryInfo.versions, function (versionInfo) {\n                return !versionInfo.brackets || semver.satisfies(brackets.metadata.apiVersion, versionInfo.brackets);\n            });\n            if (lastCompatibleVersionInfo && lastCompatibleVersionInfo.version && semver.lt(currentVersion, lastCompatibleVersionInfo.version)) {\n                entry.installInfo.updateCompatible        = true;\n                entry.registryInfo.updateCompatible       = true;\n                entry.installInfo.lastCompatibleVersion   = lastCompatibleVersionInfo.version;\n                entry.registryInfo.lastCompatibleVersion  = lastCompatibleVersionInfo.version;\n            }\n        }\n\n        exports.trigger(\"registryUpdate\", id);\n    }\n\n\n    /**\n     * @private\n     * Verifies if an extension is a theme based on the presence of the field \"theme\"\n     * in the package.json.  If it is a theme, then the theme file is just loaded by the\n     * ThemeManager\n     *\n     * @param {string} id of the theme extension to load\n     */\n    function loadTheme(id) {\n        var extension = extensions[id];\n        if (extension.installInfo && extension.installInfo.metadata && extension.installInfo.metadata.theme) {\n            ThemeManager.loadPackage(extension.installInfo);\n        }\n    }\n\n\n    /**\n     * @private\n     * Sets our data. For unit testing only.\n     */\n    function _setExtensions(newExtensions) {\n        exports.extensions = extensions = newExtensions;\n        Object.keys(extensions).forEach(function (id) {\n            synchronizeEntry(id);\n        });\n    }\n\n    /**\n     * @private\n     * Clears out our existing data. For unit testing only.\n     */\n    function _reset() {\n        exports.extensions = extensions = {};\n        _idsToRemove = {};\n        _idsToUpdate = {};\n        _idsToDisable = {};\n    }\n\n    /**\n     * Downloads the registry of Brackets extensions and stores the information in our\n     * extension info.\n     *\n     * @return {$.Promise} a promise that's resolved with the registry JSON data\n     * or rejected if the server can't be reached.\n     */\n    function downloadRegistry() {\n        if (pendingDownloadRegistry) {\n            return pendingDownloadRegistry.promise();\n        }\n\n        pendingDownloadRegistry = new $.Deferred();\n\n        $.ajax({\n            url: brackets.config.extension_registry,\n            dataType: \"json\",\n            cache: false\n        })\n            .done(function (data) {\n                exports.hasDownloadedRegistry = true;\n                Object.keys(data).forEach(function (id) {\n                    if (!extensions[id]) {\n                        extensions[id] = {};\n                    }\n                    extensions[id].registryInfo = data[id];\n                    synchronizeEntry(id);\n                });\n                exports.trigger(\"registryDownload\");\n                pendingDownloadRegistry.resolve();\n            })\n            .fail(function () {\n                pendingDownloadRegistry.reject();\n            })\n            .always(function () {\n                // Make sure to clean up the pending registry so that new requests can be made.\n                pendingDownloadRegistry = null;\n            });\n\n        return pendingDownloadRegistry.promise();\n    }\n\n\n    /**\n     * @private\n     * When an extension is loaded, fetches the package.json and stores the extension in our map.\n     * @param {$.Event} e The event object\n     * @param {string} path The local path of the loaded extension's folder.\n     */\n    function _handleExtensionLoad(e, path) {\n        function setData(metadata) {\n            let locationType,\n                id = metadata.name,\n                userExtensionPath = ExtensionLoader.getUserExtensionPath();\n            metadata.title = metadata.title || metadata.name;\n            if (path.indexOf(userExtensionPath) === 0) {\n                locationType = LOCATION_USER;\n            } else {\n                var segments = path.split(\"/\"), parent;\n                if (segments.length > 2) {\n                    parent = segments[segments.length - 2];\n                }\n                if (parent === \"dev\") {\n                    locationType = LOCATION_DEV;\n                } else if (parent === \"default\") {\n                    locationType = LOCATION_DEFAULT;\n                } else {\n                    locationType = LOCATION_UNKNOWN;\n                }\n            }\n            if (!extensions[id]) {\n                extensions[id] = {};\n            }\n            extensions[id].installInfo = {\n                metadata: metadata,\n                path: path,\n                locationType: locationType,\n                status: (e.type === \"loadFailed\" ? START_FAILED : (e.type === \"disabled\" ? DISABLED : ENABLED))\n            };\n\n            synchronizeEntry(id);\n            loadTheme(id);\n            exports.trigger(\"statusChange\", id);\n        }\n\n        function deduceMetadata() {\n            var match = path.match(/\\/([^\\/]+)$/),\n                name = (match && match[1]) || path,\n                metadata = { name: name, title: name };\n            return metadata;\n        }\n\n        ExtensionUtils.loadMetadata(path)\n            .done(function (metadata) {\n                setData(metadata);\n            })\n            .fail(function (disabled) {\n                // If there's no package.json, this is a legacy extension. It was successfully loaded,\n                // but we don't have an official ID or metadata for it, so we just create an id and\n                // \"title\" for it (which is the last segment of its pathname)\n                // and record that it's enabled.\n                var metadata = deduceMetadata();\n                metadata.disabled = disabled;\n                setData(metadata);\n            });\n    }\n\n    /**\n     * Determines if the given versions[] entry is compatible with the given Brackets API version, and if not\n     * specifies why.\n     * @param {Object} extVersion\n     * @param {string} apiVersion\n     * @return {{isCompatible: boolean, requiresNewer: ?boolean, compatibleVersion: ?string}}\n     */\n    function getCompatibilityInfoForVersion(extVersion, apiVersion) {\n        var requiredVersion = (extVersion.brackets || (extVersion.engines && extVersion.engines.brackets)),\n            result = {};\n        result.isCompatible = !requiredVersion || semver.satisfies(apiVersion, requiredVersion);\n        if (result.isCompatible) {\n            result.compatibleVersion = extVersion.version;\n        } else {\n            // Find out reason for incompatibility\n            if (requiredVersion.charAt(0) === '<') {\n                result.requiresNewer = false;\n            } else if (requiredVersion.charAt(0) === '>') {\n                result.requiresNewer = true;\n            } else if (requiredVersion.charAt(0) === \"~\") {\n                var compareVersion = requiredVersion.slice(1);\n                // Need to add .0s to this style of range in order to compare (since valid version\n                // numbers must have major/minor/patch).\n                if (compareVersion.match(/^[0-9]+$/)) {\n                    compareVersion += \".0.0\";\n                } else if (compareVersion.match(/^[0-9]+\\.[0-9]+$/)) {\n                    compareVersion += \".0\";\n                }\n                result.requiresNewer = semver.lt(apiVersion, compareVersion);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Finds the newest version of the entry that is compatible with the given Brackets API version, if any.\n     * @param {Object} entry The registry entry to check.\n     * @param {string} apiVersion The Brackets API version to check against.\n     * @return {{isCompatible: boolean, requiresNewer: ?boolean, compatibleVersion: ?string, isLatestVersion: boolean}}\n     *      Result contains an \"isCompatible\" member saying whether it's compatible. If compatible, \"compatibleVersion\"\n     *      specifies the newest version that is compatible and \"isLatestVersion\" indicates if this is the absolute\n     *      latest version of the extension or not. If !isCompatible or !isLatestVersion, \"requiresNewer\" says whether\n     *      the latest version is incompatible due to requiring a newer (vs. older) version of Brackets.\n     */\n    function getCompatibilityInfo(entry, apiVersion) {\n        if (!entry.versions) {\n            var fallback = getCompatibilityInfoForVersion(entry.metadata, apiVersion);\n            if (fallback.isCompatible) {\n                fallback.isLatestVersion = true;\n            }\n            return fallback;\n        }\n\n        var i = entry.versions.length - 1,\n            latestInfo = getCompatibilityInfoForVersion(entry.versions[i], apiVersion);\n\n        if (latestInfo.isCompatible) {\n            latestInfo.isLatestVersion = true;\n            return latestInfo;\n        }\n            // Look at earlier versions (skipping very latest version since we already checked it)\n        for (i--; i >= 0; i--) {\n            var compatInfo = getCompatibilityInfoForVersion(entry.versions[i], apiVersion);\n            if (compatInfo.isCompatible) {\n                compatInfo.isLatestVersion = false;\n                compatInfo.requiresNewer = latestInfo.requiresNewer;\n                return compatInfo;\n            }\n        }\n\n            // No version is compatible, so just return info for the latest version\n        return latestInfo;\n\n    }\n\n    /**\n     * Given an extension id and version number, returns the URL for downloading that extension from\n     * the repository. Does not guarantee that the extension exists at that URL.\n     * @param {string} id The extension's name from the metadata.\n     * @param {string} version The version to download.\n     * @return {string} The URL to download the extension from.\n     */\n    function getExtensionURL(id, version) {\n        return StringUtils.format(brackets.config.extension_url, id, version);\n    }\n\n    /**\n     * Removes the installed extension with the given id.\n     * @param {string} id The id of the extension to remove.\n     * @return {$.Promise} A promise that's resolved when the extension is removed or\n     *     rejected with an error if there's a problem with the removal.\n     */\n    function remove(id) {\n        var result = new $.Deferred();\n        if (extensions[id] && extensions[id].installInfo) {\n            Package.remove(extensions[id].installInfo.path)\n                .done(function () {\n                    extensions[id].installInfo = null;\n                    result.resolve();\n                    exports.trigger(\"statusChange\", id);\n                })\n                .fail(function (err) {\n                    result.reject(err);\n                });\n        } else {\n            result.reject(StringUtils.format(Strings.EXTENSION_NOT_INSTALLED, id));\n        }\n        return result.promise();\n    }\n\n    /**\n     * @private\n     *\n     * Disables or enables the installed extensions.\n     *\n     * @param {string} id The id of the extension to disable or enable.\n     * @param {boolean} enable A boolean indicating whether to enable or disable.\n     * @return {$.Promise} A promise that's resolved when the extension action is\n     *      completed or rejected with an error that prevents the action from completion.\n     */\n    function _enableOrDisable(id, enable) {\n        var result = new $.Deferred(),\n            extension = extensions[id];\n        if (extension && extension.installInfo) {\n            Package[(enable ? \"enable\" : \"disable\")](extension.installInfo.path)\n                .done(function () {\n                    extension.installInfo.status = enable ? ENABLED : DISABLED;\n                    extension.installInfo.metadata.disabled = !enable;\n                    result.resolve();\n                    exports.trigger(\"statusChange\", id);\n                })\n                .fail(function (err) {\n                    result.reject(err);\n                });\n        } else {\n            result.reject(StringUtils.format(Strings.EXTENSION_NOT_INSTALLED, id));\n        }\n        return result.promise();\n    }\n\n    /**\n     * Disables the installed extension with the given id.\n     *\n     * @param {string} id The id of the extension to disable.\n     * @return {$.Promise} A promise that's resolved when the extenion is disabled or\n     *      rejected with an error that prevented the disabling.\n     */\n    function disable(id) {\n        return _enableOrDisable(id, false);\n    }\n\n    /**\n     * Enables the installed extension with the given id.\n     *\n     * @param {string} id The id of the extension to enable.\n     * @return {$.Promise} A promise that's resolved when the extenion is enabled or\n     *      rejected with an error that prevented the enabling.\n     */\n    function enable(id) {\n        return _enableOrDisable(id, true);\n    }\n\n    /**\n     * Updates an installed extension with the given package file.\n     * @param {string} id of the extension\n     * @param {string} packagePath path to the package file\n     * @param {boolean=} keepFile Flag to keep extension package file, default=false\n     * @return {$.Promise} A promise that's resolved when the extension is updated or\n     *     rejected with an error if there's a problem with the update.\n     */\n    function update(id, packagePath, keepFile) {\n        return Package.installUpdate(packagePath, id).done(function () {\n            if (!keepFile) {\n                FileSystem.getFileForPath(packagePath).unlink();\n            }\n        });\n    }\n\n    /**\n     * Deletes any temporary files left behind by extensions that\n     * were marked for update.\n     */\n    function cleanupUpdates() {\n        Object.keys(_idsToUpdate).forEach(function (id) {\n            var installResult = _idsToUpdate[id],\n                keepFile = installResult.keepFile,\n                filename = installResult.localPath;\n\n            if (filename && !keepFile) {\n                FileSystem.getFileForPath(filename).unlink();\n            }\n        });\n        _idsToUpdate = {};\n    }\n\n    /**\n     * Unmarks all extensions marked for removal.\n     */\n    function unmarkAllForRemoval() {\n        _idsToRemove = {};\n    }\n\n    /**\n     * Marks an extension for later removal, or unmarks an extension previously marked.\n     * @param {string} id The id of the extension to mark for removal.\n     * @param {boolean} mark Whether to mark or unmark it.\n     */\n    function markForRemoval(id, mark) {\n        if (mark) {\n            _idsToRemove[id] = true;\n        } else {\n            delete _idsToRemove[id];\n        }\n        exports.trigger(\"statusChange\", id);\n    }\n\n    /**\n     * Returns true if an extension is marked for removal.\n     * @param {string} id The id of the extension to check.\n     * @return {boolean} true if it's been marked for removal, false otherwise.\n     */\n    function isMarkedForRemoval(id) {\n        return !!(_idsToRemove[id]);\n    }\n\n    /**\n     * Returns true if there are any extensions marked for removal.\n     * @return {boolean} true if there are extensions to remove\n     */\n    function hasExtensionsToRemove() {\n        return Object.keys(_idsToRemove).length > 0;\n    }\n\n    /**\n     * Marks an extension for disabling later, or unmarks an extension previously marked.\n     *\n     * @param {string} id The id of the extension\n     * @param {boolean} mark Whether to mark or unmark the extension.\n     */\n    function markForDisabling(id, mark) {\n        if (mark) {\n            _idsToDisable[id] = true;\n        } else {\n            delete _idsToDisable[id];\n        }\n        exports.trigger(\"statusChange\", id);\n    }\n\n    /**\n     * Returns true if an extension is mark for disabling.\n     *\n     * @param {string} id The id of the extension to check.\n     * @return {boolean} true if it's been mark for disabling, false otherwise.\n     */\n    function isMarkedForDisabling(id) {\n        return !!(_idsToDisable[id]);\n    }\n\n    /**\n     * Returns true if there are any extensions marked for disabling.\n     * @return {boolean} true if there are extensions to disable\n     */\n    function hasExtensionsToDisable() {\n        return Object.keys(_idsToDisable).length > 0;\n    }\n\n    /**\n     * Unmarks all the extensions that have been marked for disabling.\n     */\n    function unmarkAllForDisabling() {\n        _idsToDisable = {};\n    }\n\n    /**\n     * If a downloaded package appears to be an update, mark the extension for update.\n     * If an extension was previously marked for removal, marking for update will\n     * turn off the removal mark.\n     * @param {Object} installationResult info about the install provided by the Package.download function\n     */\n    function updateFromDownload(installationResult) {\n        if (installationResult.keepFile === undefined) {\n            installationResult.keepFile = false;\n        }\n\n        var installationStatus = installationResult.installationStatus;\n        if (installationStatus === Package.InstallationStatuses.ALREADY_INSTALLED ||\n                installationStatus === Package.InstallationStatuses.NEEDS_UPDATE ||\n                installationStatus === Package.InstallationStatuses.SAME_VERSION ||\n                installationStatus === Package.InstallationStatuses.OLDER_VERSION) {\n            var id = installationResult.name;\n            delete _idsToRemove[id];\n            _idsToUpdate[id] = installationResult;\n            exports.trigger(\"statusChange\", id);\n        }\n    }\n\n    /**\n     * Removes the mark for an extension to be updated on restart. Also deletes the\n     * downloaded package file.\n     * @param {string} id The id of the extension for which the update is being removed\n     */\n    function removeUpdate(id) {\n        var installationResult = _idsToUpdate[id];\n        if (!installationResult) {\n            return;\n        }\n        if (installationResult.localPath && !installationResult.keepFile) {\n            FileSystem.getFileForPath(installationResult.localPath).unlink();\n        }\n        delete _idsToUpdate[id];\n        exports.trigger(\"statusChange\", id);\n    }\n\n    /**\n     * Returns true if an extension is marked for update.\n     * @param {string} id The id of the extension to check.\n     * @return {boolean} true if it's been marked for update, false otherwise.\n     */\n    function isMarkedForUpdate(id) {\n        return !!(_idsToUpdate[id]);\n    }\n\n    /**\n     * Returns true if there are any extensions marked for update.\n     * @return {boolean} true if there are extensions to update\n     */\n    function hasExtensionsToUpdate() {\n        return Object.keys(_idsToUpdate).length > 0;\n    }\n\n    /**\n     * Removes extensions previously marked for removal.\n     * @return {$.Promise} A promise that's resolved when all extensions are removed, or rejected\n     *     if one or more extensions can't be removed. When rejected, the argument will be an\n     *     array of error objects, each of which contains an \"item\" property with the id of the\n     *     failed extension and an \"error\" property with the actual error.\n     */\n    function removeMarkedExtensions() {\n        return Async.doInParallel_aggregateErrors(\n            Object.keys(_idsToRemove),\n            function (id) {\n                return remove(id);\n            }\n        );\n    }\n\n    /**\n     * Disables extensions marked for disabling.\n     *\n     * If the return promise is rejected, the argument will contain an array of objects. Each\n     * element is an object identifying the extension failed with \"item\" property set to the\n     * extension id which has failed to be disabled and \"error\" property set to the error.\n     *\n     * @return {$.Promise} A promise that's resolved when all extensions marked for disabling are\n     *      disabled or rejected if one or more extensions can't be disabled.\n     */\n    function disableMarkedExtensions() {\n        return Async.doInParallel_aggregateErrors(\n            Object.keys(_idsToDisable),\n            function (id) {\n                return disable(id);\n            }\n        );\n    }\n\n    /**\n     * Updates extensions previously marked for update.\n     * @return {$.Promise} A promise that's resolved when all extensions are updated, or rejected\n     *     if one or more extensions can't be updated. When rejected, the argument will be an\n     *     array of error objects, each of which contains an \"item\" property with the id of the\n     *     failed extension and an \"error\" property with the actual error.\n     */\n    function updateExtensions() {\n        return Async.doInParallel_aggregateErrors(\n            Object.keys(_idsToUpdate),\n            function (id) {\n                var installationResult = _idsToUpdate[id];\n                return update(installationResult.name, installationResult.localPath, installationResult.keepFile);\n            }\n        );\n    }\n\n    /**\n     * Gets an array of extensions that are currently installed and can be updated to a new version\n     * @return {Array.<{id: string, installVersion: string, registryVersion: string}>}\n     *     where id = extensionId\n     *     installVersion = currently installed version of extension\n     *     registryVersion = latest version compatible with current Brackets\n     */\n    function getAvailableUpdates() {\n        var result = [];\n        Object.keys(extensions).forEach(function (extensionId) {\n            var extensionInfo = extensions[extensionId];\n            // skip extensions that are not installed or are not in the registry\n            if (!extensionInfo.installInfo || !extensionInfo.registryInfo) {\n                return;\n            }\n            if (extensionInfo.registryInfo.updateCompatible) {\n                result.push({\n                    id: extensionId,\n                    installVersion: extensionInfo.installInfo.metadata.version,\n                    registryVersion: extensionInfo.registryInfo.lastCompatibleVersion\n                });\n            }\n        });\n        return result;\n    }\n\n    /**\n     * Takes the array returned from getAvailableUpdates() as an input and removes those entries\n     * that are no longer current - when currently installed version of an extension\n     * is equal or newer than registryVersion returned by getAvailableUpdates().\n     * This function is designed to work without the necessity to download extension registry\n     * @param {Array.<{id: string, installVersion: string, registryVersion: string}>} updates\n     *     previous output of getAvailableUpdates()\n     * @return {Array.<{id: string, installVersion: string, registryVersion: string}>}\n     *     filtered input as function description\n     */\n    function cleanAvailableUpdates(updates) {\n        return updates.reduce(function (arr, updateInfo) {\n            var extDefinition = extensions[updateInfo.id];\n            if (!extDefinition || !extDefinition.installInfo) {\n                // extension has been uninstalled in the meantime\n                return arr;\n            }\n\n            var installedVersion = extDefinition.installInfo.metadata.version;\n            if (semver.lt(installedVersion, updateInfo.registryVersion)) {\n                arr.push(updateInfo);\n            }\n\n            return arr;\n        }, []);\n    }\n\n    /**\n     * @private\n     * Find valid extensions in specified path\n     * @param {string} dirPath Directory with extensions\n     * @param {Object} autoExtensions Object that maps names of previously auto-installed\n     *      extensions {string} to installed version {string}.\n     * @return {$.Promise} Promise that resolves with arrays for extensions to update and install\n     */\n    function _getAutoInstallFiles(dirPath, autoExtensions) {\n        var zipFiles    = [],\n            installZips = [],\n            updateZips  = [],\n            deferred    = new $.Deferred();\n\n        FileSystem.getDirectoryForPath(dirPath).getContents(function (err, contents) {\n            if (!err) {\n                zipFiles = contents.filter(function (dirItem) {\n                    return (dirItem.isFile && FileUtils.getFileExtension(dirItem.fullPath) === \"zip\");\n                });\n            }\n\n            // Parse zip files and separate new installs vs. updates\n            Async.doInParallel_aggregateErrors(zipFiles, function (file) {\n                var zipFilePromise = new $.Deferred();\n\n                // Call validate() so that we open the local zip file and parse the\n                // package.json. We need the name to detect if this zip will be a\n                // new install or an update.\n                Package.validate(file.fullPath, { requirePackageJSON: true }).done(function (info) {\n                    if (info.errors.length) {\n                        zipFilePromise.reject(Package.formatError(info.errors));\n                        return;\n                    }\n\n                    var extensionInfo, installedVersion, zipArray, existingItem,\n                        extensionName   = info.metadata.name,\n                        autoExtVersion  = autoExtensions[extensionName];\n\n                    // Verify extension has not already been auto-installed/updated\n                    if (autoExtVersion && semver.lte(info.metadata.version, autoExtVersion)) {\n                        // Have already auto installed/updated version >= version of this extension\n                        zipFilePromise.reject();\n                        return;\n                    }\n\n                    // Verify extension has not already been installed/updated by some other means\n                    extensionInfo = extensions[extensionName];\n                    installedVersion = extensionInfo && extensionInfo.installInfo && extensionInfo.installInfo.metadata.version;\n                    if (installedVersion && semver.lte(info.metadata.version, installedVersion)) {\n                        // Have already manually installed/updated version >= version of this extension\n                        zipFilePromise.reject();\n                        return;\n                    }\n\n                    // Update appropriate zip array. There could be multiple zip files for an\n                    // extension, so make sure only the latest is stored\n                    zipArray = (installedVersion) ? updateZips : installZips;\n                    zipArray.some(function (zip) {\n                        if (zip.info.metadata.name === extensionName) {\n                            existingItem = zip;\n                            return true;\n                        }\n                        return false;\n                    });\n                    if (existingItem) {\n                        if (semver.lt(existingItem.info.metadata.version, info.metadata.version)) {\n                            existingItem.file = file;\n                            existingItem.info = info;\n                        }\n                    } else {\n                        zipArray.push({ file: file, info: info });\n                    }\n\n                    zipFilePromise.resolve();\n                }).fail(function (err) {\n                    zipFilePromise.reject(Package.formatError(err));\n                });\n\n                return zipFilePromise.promise();\n            }).fail(function (errorArray) {\n                // Async.doInParallel() fails if some are successful, so write errors\n                // to console and always resolve\n                errorArray.forEach(function (errorObj) {\n                    // If we rejected without an error argument, it means it was no problem\n                    // (e.g. same version of extension is already installed)\n                    if (errorObj.error) {\n                        if (errorObj.error.forEach) {\n                            console.error(\"Errors for\", errorObj.item);\n                            errorObj.error.forEach(function (error) {\n                                console.error(Package.formatError(error));\n                            });\n                        } else {\n                            console.error(\"Error for\", errorObj.item, errorObj);\n                        }\n                    }\n                });\n            }).always(function () {\n                deferred.resolve({\n                    installZips: installZips,\n                    updateZips: updateZips\n                });\n            });\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * @private\n     * Auto-install extensions bundled with installer\n     * @return {$.Promise} Promise that resolves when finished\n     */\n    function _autoInstallExtensions() {\n        var dirPath        = FileUtils.getDirectoryPath(FileUtils.getNativeBracketsDirectoryPath()) + FOLDER_AUTOINSTALL + \"/\",\n            autoExtensions = PreferencesManager.getViewState(FOLDER_AUTOINSTALL) || {},\n            deferred       = new $.Deferred();\n\n        _getAutoInstallFiles(dirPath, autoExtensions).done(function (result) {\n            var installPromise = Async.doSequentially(result.installZips, function (zip) {\n                autoExtensions[zip.info.metadata.name] = zip.info.metadata.version;\n                return Package.installFromPath(zip.file.fullPath);\n            });\n\n            var updatePromise = installPromise.always(function () {\n                return Async.doSequentially(result.updateZips, function (zip) {\n                    autoExtensions[zip.info.metadata.name] = zip.info.metadata.version;\n                    return Package.installUpdate(zip.file.fullPath);\n                });\n            });\n\n            // Always resolve the outer promise\n            updatePromise.always(function () {\n                // Keep track of auto-installed extensions so we only install an extension once\n                PreferencesManager.setViewState(FOLDER_AUTOINSTALL, autoExtensions);\n\n                deferred.resolve();\n            });\n        });\n\n        return deferred.promise();\n    }\n\n    AppInit.appReady(function () {\n        Package._getNodeConnectionDeferred().done(function () {\n            _autoInstallExtensions();\n        });\n    });\n\n    // Listen to extension load and loadFailed events\n    ExtensionLoader\n        .on(\"load\", _handleExtensionLoad)\n        .on(\"loadFailed\", _handleExtensionLoad)\n        .on(\"disabled\", _handleExtensionLoad);\n\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // Public exports\n    exports.downloadRegistry        = downloadRegistry;\n    exports.getCompatibilityInfo    = getCompatibilityInfo;\n    exports.getExtensionURL         = getExtensionURL;\n    exports.remove                  = remove;\n    exports.update                  = update;\n    exports.disable                 = disable;\n    exports.enable                  = enable;\n    exports.extensions              = extensions;\n    exports.cleanupUpdates          = cleanupUpdates;\n    exports.markForRemoval          = markForRemoval;\n    exports.isMarkedForRemoval      = isMarkedForRemoval;\n    exports.unmarkAllForRemoval     = unmarkAllForRemoval;\n    exports.hasExtensionsToRemove   = hasExtensionsToRemove;\n    exports.markForDisabling        = markForDisabling;\n    exports.isMarkedForDisabling    = isMarkedForDisabling;\n    exports.unmarkAllForDisabling   = unmarkAllForDisabling;\n    exports.hasExtensionsToDisable  = hasExtensionsToDisable;\n    exports.updateFromDownload      = updateFromDownload;\n    exports.removeUpdate            = removeUpdate;\n    exports.isMarkedForUpdate       = isMarkedForUpdate;\n    exports.hasExtensionsToUpdate   = hasExtensionsToUpdate;\n    exports.removeMarkedExtensions  = removeMarkedExtensions;\n    exports.disableMarkedExtensions = disableMarkedExtensions;\n    exports.updateExtensions        = updateExtensions;\n    exports.getAvailableUpdates     = getAvailableUpdates;\n    exports.cleanAvailableUpdates   = cleanAvailableUpdates;\n\n    exports.hasDownloadedRegistry   = false;\n\n    exports.ENABLED       = ENABLED;\n    exports.DISABLED      = DISABLED;\n    exports.START_FAILED  = START_FAILED;\n\n    exports.LOCATION_DEFAULT  = LOCATION_DEFAULT;\n    exports.LOCATION_DEV      = LOCATION_DEV;\n    exports.LOCATION_USER     = LOCATION_USER;\n    exports.LOCATION_UNKNOWN  = LOCATION_UNKNOWN;\n\n    // For unit testing only\n    exports._getAutoInstallFiles    = _getAutoInstallFiles;\n    exports._reset                  = _reset;\n    exports._setExtensions          = _setExtensions;\n});\n"],"file":"ExtensionManager.js"}
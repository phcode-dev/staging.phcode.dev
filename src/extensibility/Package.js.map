{"version":3,"sources":["extensibility/Package.js"],"names":["define","require","exports","module","AppInit","FileSystem","FileUtils","StringUtils","Strings","ExtensionLoader","NodeConnection","PreferencesManager","PathUtils","ExtensionDownloader","definePreference","undefined","description","DESCRIPTION_PROXY","DISABLED_EXTENSIONS_KEY","Errors","ERROR_LOADING","MALFORMED_URL","UNSUPPORTED_PROTOCOL","InstallationStatuses","FAILED","INSTALLED","ALREADY_INSTALLED","SAME_VERSION","OLDER_VERSION","NEEDS_UPDATE","DISABLED","_nodeConnection","_nodeConnectionDeferred","$","Deferred","_uniqueId","_extensionManagerCall","callback","domains","extensionManager","reject","promise","validate","path","options","d","proxy","get","done","result","resolve","errors","metadata","fail","error","install","nameHint","_doUpdate","destinationDirectory","getUserExtensionPath","disabledDirectory","replace","systemDirectory","getNativeBracketsDirectoryPath","operation","systemExtensionDirectory","apiVersion","brackets","installationStatus","loadExtension","name","baseUrl","window","fsServerUrl","slice","installedTo","then","githubURLFilter","urlInfo","parsed","hostname","match","exec","pathname","url","filenameHint","_download","downloadId","parseUrl","protocol","filename","r","downloadFile","localPath","convertWindowsPathToUnixPath","err","cancelDownload","abortDownload","installFromPath","length","disabledReason","installFromURL","STATE_DOWNLOADING","STATE_INSTALLING","STATE_SUCCEEDED","STATE_FAILED","state","downloadResult","getFileForPath","unlink","startsWith","config","extension_url","logger","reportError","cancel","formatError","localize","key","console","log","UNKNOWN_ERROR","Array","isArray","format","apply","remove","_toggleDisabledExtension","enabled","arr","JSON","parse","localStorage","getItem","io","indexOf","splice","push","setItem","stringify","disable","enable","getBaseName","installUpdate","_getNodeConnectionDeferred","appReady","connect","domainPath","getNativeModuleDirectoryPath","loadDomains","arguments","DEFAULT_DISABLED_EXTENSIONS_KEY"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n/*global logger*/\n\n/**\n * Functions for working with extension packages\n */\ndefine(function (require, exports, module) {\n\n\n    var AppInit              = require(\"utils/AppInit\"),\n        FileSystem           = require(\"filesystem/FileSystem\"),\n        FileUtils            = require(\"file/FileUtils\"),\n        StringUtils          = require(\"utils/StringUtils\"),\n        Strings              = require(\"strings\"),\n        ExtensionLoader      = require(\"utils/ExtensionLoader\"),\n        NodeConnection       = require(\"utils/NodeConnection\"),\n        PreferencesManager   = require(\"preferences/PreferencesManager\"),\n        PathUtils            = require(\"thirdparty/path-utils/path-utils\"),\n        ExtensionDownloader  = require(\"extensibility/ExtensionDownloader\");\n\n    PreferencesManager.definePreference(\"proxy\", \"string\", undefined, {\n        description: Strings.DESCRIPTION_PROXY\n    });\n\n    const DISABLED_EXTENSIONS_KEY = \"extensions.disabled\";\n\n    var Errors = {\n        ERROR_LOADING: \"ERROR_LOADING\",\n        MALFORMED_URL: \"MALFORMED_URL\",\n        UNSUPPORTED_PROTOCOL: \"UNSUPPORTED_PROTOCOL\"\n    };\n\n    var InstallationStatuses = {\n        FAILED: \"FAILED\",\n        INSTALLED: \"INSTALLED\",\n        ALREADY_INSTALLED: \"ALREADY_INSTALLED\",\n        SAME_VERSION: \"SAME_VERSION\",\n        OLDER_VERSION: \"OLDER_VERSION\",\n        NEEDS_UPDATE: \"NEEDS_UPDATE\",\n        DISABLED: \"DISABLED\"\n    };\n\n    /**\n     * @private\n     * @type {NodeConnection}\n     * Connects to ExtensionManagerDomain\n     */\n    var _nodeConnection;\n\n    /**\n     * @private\n     * @type {jQuery.Deferred.<NodeConnection>}\n     * A deferred which is resolved with a NodeConnection or rejected if\n     * we are unable to connect to Node.\n     */\n    var _nodeConnectionDeferred = $.Deferred();\n\n    /**\n     * @type {number} Used to generate unique download ids\n     */\n    var _uniqueId = 0;\n\n    function _extensionManagerCall(callback) {\n        if (_nodeConnection.domains.extensionManager) {\n            return callback(_nodeConnection.domains.extensionManager);\n        }\n        return new $.Deferred().reject(\"extensionManager domain is undefined\").promise();\n\n    }\n\n    /**\n     * TODO: can this go away now that we never call it directly?\n     *\n     * Validates the package at the given path. The actual validation is\n     * handled by the Node server.\n     *\n     * The promise is resolved with an object:\n     * { errors: Array.<{string}>, metadata: { name:string, version:string, ... } }\n     * metadata is pulled straight from package.json and will be undefined\n     * if there are errors or null if the extension did not include package.json.\n     *\n     * @param {string} Absolute path to the package zip file\n     * @param {{requirePackageJSON: ?boolean}} validation options\n     * @return {$.Promise} A promise that is resolved with information about the package\n     */\n    function validate(path, options) {\n        return _extensionManagerCall(function (extensionManager) {\n            var d = new $.Deferred();\n\n            // make sure proxy is attached to options before calling validate\n            // so npm can use it in the domain\n            options = options || {};\n            options.proxy = PreferencesManager.get(\"proxy\");\n\n            extensionManager.validate(path, options)\n                .done(function (result) {\n                    d.resolve({\n                        errors: result.errors,\n                        metadata: result.metadata\n                    });\n                })\n                .fail(function (error) {\n                    d.reject(error);\n                });\n\n            return d.promise();\n        });\n    }\n\n    /**\n     * Validates and installs the package at the given path. Validation and\n     * installation is handled by the Node process.\n     *\n     * The extension will be installed into the user's extensions directory.\n     * If the user already has the extension installed, it will instead go\n     * into their disabled extensions directory.\n     *\n     * The promise is resolved with an object:\n     * { errors: Array.<{string}>, metadata: { name:string, version:string, ... },\n     * disabledReason:string, installedTo:string, commonPrefix:string }\n     * metadata is pulled straight from package.json and is likely to be undefined\n     * if there are errors. It is null if there was no package.json.\n     *\n     * disabledReason is either null or the reason the extension was installed disabled.\n     *\n     * @param {string} path Absolute path to the package zip file\n     * @param {?string} nameHint Hint for the extension folder's name (used in favor of\n     *          path's filename if present, and if no package metadata present).\n     * @param {?boolean} _doUpdate private argument used to signal an update\n     * @return {$.Promise} A promise that is resolved with information about the package\n     *          (which may include errors, in which case the extension was disabled), or\n     *          rejected with an error object.\n     */\n    function install(path, nameHint, _doUpdate) {\n        const d                       = new $.Deferred(),\n            destinationDirectory    = ExtensionLoader.getUserExtensionPath(),\n            disabledDirectory       = destinationDirectory.replace(/\\/user$/, \"/disabled\"),\n            systemDirectory         = FileUtils.getNativeBracketsDirectoryPath() + \"/extensions/default/\";\n\n        const operation = _doUpdate ? \"update\" : \"install\";\n        ExtensionDownloader[operation](path, destinationDirectory, {\n            disabledDirectory: disabledDirectory,\n            systemExtensionDirectory: systemDirectory,\n            apiVersion: brackets.metadata.apiVersion,\n            nameHint: nameHint,\n            proxy: PreferencesManager.get(\"proxy\")\n        })\n            .done(function (result) {\n\n                if (result.installationStatus !== InstallationStatuses.INSTALLED || _doUpdate) {\n                    d.resolve(result);\n                } else {\n                    // This was a new extension and everything looked fine.\n                    // We load it into Brackets right away.\n                    ExtensionLoader.loadExtension(result.name, {\n                        // On Windows, it looks like Node converts Unix-y paths to backslashy paths.\n                        // We need to convert them back.\n                        baseUrl: window.fsServerUrl.slice(0, -1) + result.installedTo\n                    }, \"main\").then(function () {\n                        d.resolve(result);\n                    }, function () {\n                        d.reject(Errors.ERROR_LOADING);\n                    });\n                }\n            })\n            .fail(function (error) {\n                d.reject(error);\n            });\n\n        return d.promise();\n    }\n\n\n\n    /**\n     * Special case handling to make the common case of downloading from GitHub easier; modifies 'urlInfo' as\n     * needed. Converts a bare GitHub repo URL to the corresponding master ZIP URL; or if given a direct\n     * master ZIP URL already, sets a nicer download filename (both cases use the repo name).\n     *\n     * @param {{url:string, parsed:Array.<string>, filenameHint:string}} urlInfo\n     */\n    function githubURLFilter(urlInfo) {\n        if (urlInfo.parsed.hostname === \"github.com\" || urlInfo.parsed.hostname === \"www.github.com\") {\n            // Is it a URL to the root of a repo? (/user/repo)\n            var match = /^\\/[^\\/?]+\\/([^\\/?]+)(\\/?)$/.exec(urlInfo.parsed.pathname);\n            if (match) {\n                if (!match[2]) {\n                    urlInfo.url += \"/\";\n                }\n                urlInfo.url += \"archive/master.zip\";\n                urlInfo.filenameHint = match[1] + \".zip\";\n\n            } else {\n                // Is it a URL directly to the repo's 'master.zip'? (/user/repo/archive/master.zip)\n                match = /^\\/[^\\/?]+\\/([^\\/?]+)\\/archive\\/master.zip$/.exec(urlInfo.parsed.pathname);\n                if (match) {\n                    urlInfo.filenameHint = match[1] + \".zip\";\n                }\n            }\n        }\n    }\n\n    /**\n     * Downloads from the given URL to a temporary location. On success, resolves with the path of the\n     * downloaded file (typically in a temp folder) and a hint for the real filename. On failure, rejects\n     * with an error object.\n     *\n     * @param {string} url URL of the file to be downloaded\n     * @param {number} downloadId Unique number to identify this request\n     * @param {string} destinationDirectory Optional path to download extension to. Defaults to user extension folder\n     * @return {$.Promise}\n     */\n    function _download(url, downloadId, destinationDirectory) {\n        const d = new $.Deferred();\n\n        // Validate URL\n        // TODO: PathUtils fails to parse URLs that are missing the protocol part (e.g. starts immediately with \"www...\")\n        const parsed = PathUtils.parseUrl(url);\n        if (!parsed.hostname) {  // means PathUtils failed to parse at all\n            d.reject(Errors.MALFORMED_URL);\n            return d.promise();\n        }\n        if (parsed.protocol !== \"http:\" && parsed.protocol !== \"https:\") {\n            d.reject(Errors.UNSUPPORTED_PROTOCOL);\n            return d.promise();\n        }\n\n        const urlInfo = { url: url, parsed: parsed, filenameHint: parsed.filename, destinationDirectory };\n        githubURLFilter(urlInfo);\n\n        // Decide download destination\n        let filename = urlInfo.filenameHint;\n        filename = filename.replace(/[^a-zA-Z0-9_\\- \\(\\)\\.]/g, \"_\"); // make sure it's a valid filename\n        if (!filename) {  // in case of URL ending in \"/\"\n            filename = \"extension.zip\";\n        }\n\n        // Download the bits (using Node since brackets-shell doesn't support binary file IO)\n        const r = ExtensionDownloader.downloadFile(downloadId, urlInfo, PreferencesManager.get(\"proxy\"));\n        r.done(function (result) {\n            d.resolve({\n                localPath: FileUtils.convertWindowsPathToUnixPath(result),\n                filenameHint: urlInfo.filenameHint });\n        }).fail(function (err) {\n            d.reject(err);\n        });\n\n        return d.promise();\n    }\n\n    /**\n     * Attempts to synchronously cancel the given pending download. This may not be possible, e.g.\n     * if the download has already finished.\n     *\n     * @param {number} downloadId Identifier previously passed to download()\n     */\n    function cancelDownload(downloadId) {\n        ExtensionDownloader.abortDownload(downloadId);\n    }\n\n    /**\n     * On success, resolves with an extension metadata object; at that point, the extension has already\n     * started running in Brackets. On failure (including validation errors), rejects with an error object.\n     *\n     * An error object consists of either a string error code OR an array where the first entry is the error\n     * code and the remaining entries are further info. The error code string is one of either\n     * ExtensionsDomain.Errors or Package.Errors. Use formatError() to convert an error object to a friendly,\n     * localized error message.\n     *\n     * @param {string} path Absolute path to the package zip file\n     * @param {?string} filenameHint Hint for the extension folder's name (used in favor of\n     *          path's filename if present, and if no package metadata present).\n     * @return {$.Promise} A promise that is rejected if there are errors during\n     *          install or the extension is disabled.\n     */\n    function installFromPath(path, filenameHint) {\n        const d = new $.Deferred();\n\n        install(path, filenameHint)\n            .done(function (result) {\n\n                let installationStatus = result.installationStatus;\n                if (installationStatus === InstallationStatuses.ALREADY_INSTALLED ||\n                        installationStatus === InstallationStatuses.NEEDS_UPDATE ||\n                        installationStatus === InstallationStatuses.SAME_VERSION ||\n                        installationStatus === InstallationStatuses.OLDER_VERSION) {\n                    d.resolve(result);\n                } else {\n                    if (result.errors && result.errors.length > 0) {\n                        // Validation errors - for now, only return the first one\n                        d.reject(result.errors[0]);\n                    } else if (result.disabledReason) {\n                        // Extension valid but left disabled (wrong API version, extension name collision, etc.)\n                        d.reject(result.disabledReason);\n                    } else {\n                        // Success! Extension is now running in Brackets\n                        d.resolve(result);\n                    }\n                }\n            })\n            .fail(function (err) {\n                d.reject(err);\n            });\n\n        return d.promise();\n    }\n\n    /**\n     * On success, resolves with an extension metadata object; at that point, the extension has already\n     * started running in Brackets. On failure (including validation errors), rejects with an error object.\n     *\n     * An error object consists of either a string error code OR an array where the first entry is the error\n     * code and the remaining entries are further info. The error code string is one of either\n     * ExtensionsDomain.Errors or Package.Errors. Use formatError() to convert an error object to a friendly,\n     * localized error message.\n     *\n     * The returned cancel() function will *attempt* to cancel installation, but it is not guaranteed to\n     * succeed. If cancel() succeeds, the Promise is rejected with a CANCELED error code. If we're unable\n     * to cancel, the Promise is resolved or rejected normally, as if cancel() had never been called.\n     *\n     * @return {{promise: $.Promise, cancel: function():boolean}}\n     */\n    function installFromURL(url, destinationDirectory) {\n        const STATE_DOWNLOADING = 1,\n            STATE_INSTALLING = 2,\n            STATE_SUCCEEDED = 3,\n            STATE_FAILED = 4;\n\n        const d = new $.Deferred();\n        let state = STATE_DOWNLOADING;\n\n        var downloadId = (_uniqueId++);\n        _download(url, downloadId, destinationDirectory)\n            .done(function (downloadResult) {\n                state = STATE_INSTALLING;\n\n                installFromPath(downloadResult.localPath, downloadResult.filenameHint)\n                    .done(function (result) {\n                        state = STATE_SUCCEEDED;\n                        result.localPath = downloadResult.localPath;\n                        d.resolve(result);\n                    })\n                    .fail(function (err) {\n                        // File IO errors, internal error in install()/validate(), or extension startup crashed\n                        state = STATE_FAILED;\n                        FileSystem.getFileForPath(downloadResult.localPath).unlink();\n                        if(!url || url.startsWith(brackets.config.extension_url)) {\n                            // privacy, log error for extensions in registry\n                            logger.reportError(err, \"Failed to install \" + url);\n                        }\n                        d.reject(err);\n                    });\n            })\n            .fail(function (err) {\n                // Download error (the Node-side download code cleans up any partial ZIP file)\n                state = STATE_FAILED;\n                d.reject(err);\n            });\n\n        return {\n            promise: d.promise(),\n            cancel: function () {\n                if (state === STATE_DOWNLOADING) {\n                    // This will trigger download()'s fail() handler with CANCELED as the err code\n                    cancelDownload(downloadId);\n                }\n                // Else it's too late to cancel; we'll continue on through the done() chain and emit\n                // a success result (calling done() handlers) if all else goes well.\n            }\n        };\n    }\n\n    /**\n     * Converts an error object as returned by install(), installFromPath() or\n     * installFromURL() into a flattened, localized string.\n     *\n     * @param {string|Array.<string>} error\n     * @return {string}\n     */\n    function formatError(error) {\n        function localize(key) {\n            if (Strings[key]) {\n                return Strings[key];\n            }\n            console.log(\"Unknown installation error\", key);\n            return Strings.UNKNOWN_ERROR;\n        }\n\n        if (Array.isArray(error)) {\n            error[0] = localize(error[0]);\n            return StringUtils.format.apply(window, error);\n        }\n        return localize(error);\n\n    }\n\n    /**\n     * Removes the extension at the given path.\n     *\n     * @param {string} path The absolute path to the extension to remove.\n     * @return {$.Promise} A promise that's resolved when the extension is removed, or\n     *     rejected if there was an error.\n     */\n    function remove(path) {\n        return ExtensionDownloader.remove(path);\n    }\n\n    /**\n     * function manages state weather an extension is enabled or disabled\n     */\n    function _toggleDisabledExtension(path, enabled) {\n        let arr = JSON.parse(localStorage.getItem(DISABLED_EXTENSIONS_KEY) || \"[]\");\n        const io = arr.indexOf(path);\n        if (enabled === true && io !== -1) {\n            arr.splice(io, 1);\n        } else if (enabled === false && io === -1) {\n            arr.push(path);\n        }\n        localStorage.setItem(DISABLED_EXTENSIONS_KEY, JSON.stringify(arr));\n    }\n\n    /**\n     * Disables the extension at the given path.\n     *\n     * @param {string} path The absolute path to the extension to disable.\n     * @return {$.Promise} A promise that's resolved when the extenion is disabled, or\n     *      rejected if there was an error.\n     */\n    function disable(path) {\n        const result = new $.Deferred();\n        _toggleDisabledExtension(path, false);\n        result.resolve();\n        return result.promise();\n    }\n\n    /**\n     * Enables the extension at the given path.\n     *\n     * @param {string} path The absolute path to the extension to enable.\n     * @return {$.Promise} A promise that's resolved when the extenion is enable, or\n     *      rejected if there was an error.\n     */\n    function enable(path) {\n        const result = new $.Deferred();\n        _toggleDisabledExtension(path, true);\n        ExtensionLoader.loadExtension(FileUtils.getBaseName(path), { baseUrl: path }, \"main\")\n            .done(result.resolve)\n            .fail(result.reject);\n        return result.promise();\n    }\n\n    /**\n     * Install an extension update located at path.\n     * This assumes that the installation was previously attempted\n     * and an installationStatus of \"ALREADY_INSTALLED\", \"NEEDS_UPDATE\", \"SAME_VERSION\",\n     * or \"OLDER_VERSION\" was the result.\n     *\n     * This workflow ensures that there should not generally be validation errors\n     * because the first pass at installation the extension looked at the metadata\n     * and installed packages.\n     *\n     * @param {string} path to package file\n     * @param {?string} nameHint Hint for the extension folder's name (used in favor of\n     *          path's filename if present, and if no package metadata present).\n     * @return {$.Promise} A promise that is resolved when the extension is successfully\n     *      installed or rejected if there is a problem.\n     */\n    function installUpdate(path, nameHint) {\n        const d = new $.Deferred();\n        install(path, nameHint, true)\n            .done(function (result) {\n                if (result.installationStatus !== InstallationStatuses.INSTALLED) {\n                    d.reject(result.errors);\n                } else {\n                    d.resolve(result);\n                }\n            })\n            .fail(function (error) {\n                d.reject(error);\n            });\n        return d.promise();\n    }\n\n    /**\n     * Allows access to the deferred that manages the node connection. This\n     * is *only* for unit tests. Messing with this not in testing will\n     * potentially break everything.\n     *\n     * @private\n     * @return {jQuery.Deferred} The deferred that manages the node connection\n     */\n    function _getNodeConnectionDeferred() {\n        return _nodeConnectionDeferred;\n    }\n\n    // Initializes node connection\n    // TODO: duplicates code from StaticServer\n    // TODO: can this be done lazily?\n    AppInit.appReady(function () {\n        _nodeConnection = new NodeConnection();\n        _nodeConnection.connect(true).then(function () {\n            var domainPath = FileUtils.getNativeBracketsDirectoryPath() + \"/\" + FileUtils.getNativeModuleDirectoryPath(module) + \"/node/ExtensionManagerDomain\";\n\n            _nodeConnection.loadDomains(domainPath, true)\n                .then(\n                    function () {\n                        _nodeConnectionDeferred.resolve();\n                    },\n                    function () { // Failed to connect\n                        console.error(\"[Extensions] Failed to connect to node\", arguments);\n                        _nodeConnectionDeferred.reject();\n                    }\n                );\n        });\n    });\n\n    // For unit tests only\n    exports._getNodeConnectionDeferred = _getNodeConnectionDeferred;\n\n    exports.installFromURL          = installFromURL;\n    exports.installFromPath         = installFromPath;\n    exports.validate                = validate;\n    exports.install                 = install;\n    exports.remove                  = remove;\n    exports.disable                 = disable;\n    exports.enable                  = enable;\n    exports.installUpdate           = installUpdate;\n    exports.formatError             = formatError;\n    exports.InstallationStatuses    = InstallationStatuses;\n    exports.DEFAULT_DISABLED_EXTENSIONS_KEY = DISABLED_EXTENSIONS_KEY;\n});\n"],"file":"Package.js"}
{"version":3,"sources":["utils/Async.js"],"names":["define","require","exports","module","doInParallel","items","beginProcessItem","failFast","promises","masterDeferred","$","Deferred","length","resolve","numCompleted","hasFailed","forEach","item","i","itemPromise","push","fail","reject","always","promise","doSequentially","failAndStopFast","doItem","done","doSequentiallyInBackground","fnProcessItem","maxBlockingTime","idleTime","sliceStartTime","Date","getTime","result","window","setTimeout","firstSequentially","doInParallel_aggregateErrors","errors","parallelResult","itemResult","error","ERROR_TIMEOUT","withTimeout","timeout","resolveTimeout","wrapper","timer","clearTimeout","then","waitForAll","failOnReject","results","count","sawRejects","undefined","err","chain","functions","args","deferred","chainHelper","index","resolveWith","nextFunction","responseOrPromise","apply","hasOwnProperty","arguments","rejectWith","e","promisify","obj","method","Array","prototype","slice","call","PromiseQueue","this","_queue","_curPromise","Object","defineProperties","get","set","Error","add","op","_doNext","removeAll","self","shift"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * Utilities for working with Deferred, Promise, and other asynchronous processes.\n */\ndefine(function (require, exports, module) {\n\n\n    // Further ideas for Async utilities...\n    //  - Utilities for blocking UI until a Promise completes?\n    //  - A \"SuperDeferred\" could feature some very useful enhancements:\n    //     - API for cancellation (non guaranteed, best attempt)\n    //     - Easier way to add a timeout clause (withTimeout() wrapper below is more verbose)\n    //     - Encapsulate the task kickoff code so you can start it later, e.g. superDeferred.start()\n    //  - Deferred/Promise are unable to do anything akin to a 'finally' block. It'd be nice if we\n    //    could harvest exceptions across all steps of an async process and pipe them to a handler,\n    //    so that we don't leave UI-blocking overlays up forever, etc. But this is hard: we'd have\n    //    wrap every async callback (including low-level native ones that don't use [Super]Deferred)\n    //    to catch exceptions, and then understand which Deferred(s) the code *would* have resolved/\n    //    rejected had it run to completion.\n\n\n    /**\n     * Executes a series of tasks in parallel, returning a \"master\" Promise that is resolved once\n     * all the tasks have resolved. If one or more tasks fail, behavior depends on the failFast\n     * flag:\n     *   - If true, the master Promise is rejected as soon as the first task fails. The remaining\n     *     tasks continue to completion in the background.\n     *   - If false, the master Promise is rejected after all tasks have completed.\n     *\n     * If nothing fails:          (M = master promise; 1-4 = tasks; d = done; F = fail)\n     *  M  ------------d\n     *  1 >---d        .\n     *  2 >------d     .\n     *  3 >---------d  .\n     *  4 >------------d\n     *\n     * With failFast = false:\n     *  M  ------------F\n     *  1 >---d     .  .\n     *  2 >------d  .  .\n     *  3 >---------F  .\n     *  4 >------------d\n     *\n     * With failFast = true: -- equivalent to $.when()\n     *  M  ---------F\n     *  1 >---d     .\n     *  2 >------d  .\n     *  3 >---------F\n     *  4 >------------d   (#4 continues even though master Promise has failed)\n     * (Note: if tasks finish synchronously, the behavior is more like failFast=false because you\n     * won't get a chance to respond to the master Promise until after all items have been processed)\n     *\n     * To perform task-specific work after an individual task completes, attach handlers to each\n     * Promise before beginProcessItem() returns it.\n     *\n     * Note: don't use this if individual tasks (or their done/fail handlers) could ever show a user-\n     * visible dialog: because they run in parallel, you could show multiple dialogs atop each other.\n     *\n     * @param {!Array.<*>} items\n     * @param {!function(*, number):Promise} beginProcessItem\n     * @param {!boolean} failFast\n     * @return {$.Promise}\n     */\n    function doInParallel(items, beginProcessItem, failFast) {\n        var promises = [];\n        var masterDeferred = new $.Deferred();\n\n        if (items.length === 0) {\n            masterDeferred.resolve();\n\n        } else {\n            var numCompleted = 0;\n            var hasFailed = false;\n\n            items.forEach(function (item, i) {\n                var itemPromise = beginProcessItem(item, i);\n                promises.push(itemPromise);\n\n                itemPromise.fail(function () {\n                    if (failFast) {\n                        masterDeferred.reject();\n                    } else {\n                        hasFailed = true;\n                    }\n                });\n                itemPromise.always(function () {\n                    numCompleted++;\n                    if (numCompleted === items.length) {\n                        if (hasFailed) {\n                            masterDeferred.reject();\n                        } else {\n                            masterDeferred.resolve();\n                        }\n                    }\n                });\n            });\n\n        }\n\n        return masterDeferred.promise();\n    }\n\n    /**\n     * Executes a series of tasks in serial (task N does not begin until task N-1 has completed).\n     * Returns a \"master\" Promise that is resolved once all the tasks have resolved. If one or more\n     * tasks fail, behavior depends on the failAndStopFast flag:\n     *   - If true, the master Promise is rejected as soon as the first task fails. The remaining\n     *     tasks are never started (the serial sequence is stopped).\n     *   - If false, the master Promise is rejected after all tasks have completed.\n     *\n     * If nothing fails:\n     *  M  ------------d\n     *  1 >---d        .\n     *  2     >--d     .\n     *  3        >--d  .\n     *  4           >--d\n     *\n     * With failAndStopFast = false:\n     *  M  ------------F\n     *  1 >---d     .  .\n     *  2     >--d  .  .\n     *  3        >--F  .\n     *  4           >--d\n     *\n     * With failAndStopFast = true:\n     *  M  ---------F\n     *  1 >---d     .\n     *  2     >--d  .\n     *  3        >--F\n     *  4          (#4 never runs)\n     *\n     * To perform task-specific work after an individual task completes, attach handlers to each\n     * Promise before beginProcessItem() returns it.\n     *\n     * @param {!Array.<*>} items\n     * @param {!function(*, number):Promise} beginProcessItem\n     * @param {!boolean} failAndStopFast\n     * @return {$.Promise}\n     */\n    function doSequentially(items, beginProcessItem, failAndStopFast) {\n\n        var masterDeferred = new $.Deferred(),\n            hasFailed = false;\n\n        function doItem(i) {\n            if (i >= items.length) {\n                if (hasFailed) {\n                    masterDeferred.reject();\n                } else {\n                    masterDeferred.resolve();\n                }\n                return;\n            }\n\n            var itemPromise = beginProcessItem(items[i], i);\n\n            itemPromise.done(function () {\n                doItem(i + 1);\n            });\n            itemPromise.fail(function () {\n                if (failAndStopFast) {\n                    masterDeferred.reject();\n                    // note: we do NOT process any further items in this case\n                } else {\n                    hasFailed = true;\n                    doItem(i + 1);\n                }\n            });\n        }\n\n        doItem(0);\n\n        return masterDeferred.promise();\n    }\n\n    /**\n     * Executes a series of synchronous tasks sequentially spread over time-slices less than maxBlockingTime.\n     * Processing yields by idleTime between time-slices.\n     *\n     * @param {!Array.<*>} items\n     * @param {!function(*, number)} fnProcessItem  Function that synchronously processes one item\n     * @param {number=} maxBlockingTime\n     * @param {number=} idleTime\n     * @return {$.Promise}\n     */\n    function doSequentiallyInBackground(items, fnProcessItem, maxBlockingTime, idleTime) {\n\n        maxBlockingTime = maxBlockingTime || 15;\n        idleTime = idleTime || 30;\n\n        var sliceStartTime = (new Date()).getTime();\n\n        return doSequentially(items, function (item, i) {\n            var result = new $.Deferred();\n\n            // process the next item\n            fnProcessItem(item, i);\n\n            // if we've exhausted our maxBlockingTime\n            if ((new Date()).getTime() - sliceStartTime >= maxBlockingTime) {\n                //yield\n                window.setTimeout(function () {\n                    sliceStartTime = (new Date()).getTime();\n                    result.resolve();\n                }, idleTime);\n            } else {\n                //continue processing\n                result.resolve();\n            }\n\n            return result;\n        }, false);\n    }\n\n    /**\n     * Executes a series of tasks in serial (task N does not begin until task N-1 has completed).\n     * Returns a \"master\" Promise that is resolved when the first task has resolved. If all tasks\n     * fail, the master Promise is rejected.\n     *\n     * @param {!Array.<*>} items\n     * @param {!function(*, number):Promise} beginProcessItem\n     * @return {$.Promise}\n     */\n    function firstSequentially(items, beginProcessItem) {\n\n        var masterDeferred = new $.Deferred();\n\n        function doItem(i) {\n            if (i >= items.length) {\n                masterDeferred.reject();\n                return;\n            }\n\n            beginProcessItem(items[i], i)\n                .fail(function () {\n                    doItem(i + 1);\n                })\n                .done(function () {\n                    masterDeferred.resolve(items[i]);\n                });\n        }\n\n        doItem(0);\n        return masterDeferred.promise();\n    }\n\n    /**\n     * Executes a series of tasks in parallel, saving up error info from any that fail along the way.\n     * Returns a Promise that is only resolved/rejected once all tasks are complete. This is\n     * essentially a wrapper around doInParallel(..., false).\n     *\n     * If one or more tasks failed, the entire \"master\" promise is rejected at the end - with one\n     * argument: an array objects, one per failed task. Each error object contains:\n     *  - item -- the entry in items whose task failed\n     *  - error -- the first argument passed to the fail() handler when the task failed\n     *\n     * @param {!Array.<*>} items\n     * @param {!function(*, number):Promise} beginProcessItem\n     * @return {$.Promise}\n     */\n    function doInParallel_aggregateErrors(items, beginProcessItem) {\n        var errors = [];\n\n        var masterDeferred = new $.Deferred();\n\n        var parallelResult = doInParallel(\n            items,\n            function (item, i) {\n                var itemResult = beginProcessItem(item, i);\n                itemResult.fail(function (error) {\n                    errors.push({ item: item, error: error });\n                });\n                return itemResult;\n            },\n            false\n        );\n\n        parallelResult\n            .done(function () {\n                masterDeferred.resolve();\n            })\n            .fail(function () {\n                masterDeferred.reject(errors);\n            });\n\n        return masterDeferred.promise();\n    }\n\n    /** Value passed to fail() handlers that have been triggered due to withTimeout()'s timeout */\n    var ERROR_TIMEOUT = {};\n\n    /**\n     * Adds timeout-driven termination to a Promise: returns a new Promise that is resolved/rejected when\n     * the given original Promise is resolved/rejected, OR is resolved/rejected after the given delay -\n     * whichever happens first.\n     *\n     * If the original Promise is resolved/rejected first, done()/fail() handlers receive arguments\n     * piped from the original Promise. If the timeout occurs first instead, then resolve() or\n     * fail() (with Async.ERROR_TIMEOUT) is called based on value of resolveTimeout.\n     *\n     * @param {$.Promise} promise\n     * @param {number} timeout\n     * @param {boolean=} resolveTimeout If true, then resolve deferred on timeout, otherwise reject. Default is false.\n     * @return {$.Promise}\n     */\n    function withTimeout(promise, timeout, resolveTimeout) {\n        var wrapper = new $.Deferred();\n\n        var timer = window.setTimeout(function () {\n            if (resolveTimeout) {\n                wrapper.resolve();\n            } else {\n                wrapper.reject(ERROR_TIMEOUT);\n            }\n        }, timeout);\n        promise.always(function () {\n            window.clearTimeout(timer);\n        });\n\n        // If the wrapper was already rejected due to timeout, the Promise's calls to resolve/reject\n        // won't do anything\n        promise.then(wrapper.resolve, wrapper.reject);\n\n        return wrapper.promise();\n    }\n\n    /**\n     * Allows waiting for all the promises to be either resolved or rejected.\n     * Unlike $.when(), it does not call .fail() or .always() handlers on first\n     * reject. The caller should take all the precaution to make sure all the\n     * promises passed to this function are completed to avoid blocking.\n     *\n     * If failOnReject is set to true, promise returned by the function will be\n     * rejected if at least one of the promises was rejected. The default value\n     * is false, which will cause the call to this function to be always\n     * successfully resolved.\n     *\n     * If timeout is specified, the promise will be rejected on timeout as per\n     * Async.withTimeout.\n     *\n     * @param {!Array.<$.Promise>} promises Array of promises to wait for\n     * @param {boolean=} failOnReject       Whether to reject or not if one of the promises has been rejected.\n     * @param {number=} timeout             Number of milliseconds to wait until rejecting the promise\n     *\n     * @return {$.Promise} A Promise which will be resolved once all dependent promises are resolved.\n     *                     It is resolved with an array of results from the successfully resolved dependent promises.\n     *                     The resulting array may not be in the same order or contain as many items as there were\n     *                     promises to wait on and it will contain 'undefined' entries for those promises that resolve\n     *                     without a result.\n     *\n     */\n    function waitForAll(promises, failOnReject, timeout) {\n        var masterDeferred = new $.Deferred(),\n            results = [],\n            count = 0,\n            sawRejects = false;\n\n        if (!promises || promises.length === 0) {\n            masterDeferred.resolve();\n            return masterDeferred.promise();\n        }\n\n        // set defaults if needed\n        failOnReject = (failOnReject === undefined) ? false : true;\n\n        if (timeout !== undefined) {\n            withTimeout(masterDeferred, timeout);\n        }\n\n        promises.forEach(function (promise) {\n            promise\n                .fail(function (err) {\n                    sawRejects = true;\n                })\n                .done(function (result) {\n                    results.push(result);\n                })\n                .always(function () {\n                    count++;\n                    if (count === promises.length) {\n                        if (failOnReject && sawRejects) {\n                            masterDeferred.reject();\n                        } else {\n                            masterDeferred.resolve(results);\n                        }\n                    }\n                });\n        });\n\n        return masterDeferred.promise();\n    }\n\n    /**\n     * Chains a series of synchronous and asynchronous (jQuery promise-returning) functions\n     * together, using the result of each successive function as the argument(s) to the next.\n     * A promise is returned that resolves with the result of the final call if all calls\n     * resolve or return normally. Otherwise, if any of the functions reject or throw, the\n     * computation is halted immediately and the promise is rejected with this halting error.\n     *\n     * @param {Array.<function(*)>} functions Functions to be chained\n     * @param {?Array} args Arguments to call the first function with\n     * @return {jQuery.Promise} A promise that resolves with the result of the final call, or\n     *      rejects with the first error.\n     */\n    function chain(functions, args) {\n        var deferred = $.Deferred();\n\n        function chainHelper(index, args) {\n            if (functions.length === index) {\n                deferred.resolveWith(null, args);\n            } else {\n                var nextFunction = functions[index++];\n                try {\n                    var responseOrPromise = nextFunction.apply(null, args);\n                    if (responseOrPromise.hasOwnProperty(\"done\") &&\n                            responseOrPromise.hasOwnProperty(\"fail\")) {\n                        responseOrPromise.done(function () {\n                            chainHelper(index, arguments);\n                        });\n                        responseOrPromise.fail(function () {\n                            deferred.rejectWith(null, arguments);\n                        });\n                    } else {\n                        chainHelper(index, [responseOrPromise]);\n                    }\n                } catch (e) {\n                    deferred.reject(e);\n                }\n            }\n        }\n\n        chainHelper(0, args || []);\n\n        return deferred.promise();\n    }\n\n    /**\n     * Utility for converting a method that takes (error, callback) to one that returns a promise;\n     * useful for using FileSystem methods (or other Node-style API methods) in a promise-oriented\n     * workflow. For example, instead of\n     *\n     *      var deferred = new $.Deferred();\n     *      file.read(function (err, contents) {\n     *          if (err) {\n     *              deferred.reject(err);\n     *          } else {\n     *              // ...process the contents...\n     *              deferred.resolve();\n     *          }\n     *      }\n     *      return deferred.promise();\n     *\n     * you can just do\n     *\n     *      return Async.promisify(file, \"read\").then(function (contents) {\n     *          // ...process the contents...\n     *      });\n     *\n     * The object/method are passed as an object/string pair so that we can\n     * properly call the method without the caller having to deal with \"bind\" all the time.\n     *\n     * @param {Object} obj The object to call the method on.\n     * @param {string} method The name of the method. The method should expect the errback\n     *      as its last parameter.\n     * @param {...Object} varargs The arguments you would have normally passed to the method\n     *      (excluding the errback itself).\n     * @return {$.Promise} A promise that is resolved with the arguments that were passed to the\n     *      errback (not including the err argument) if err is null, or rejected with the err if\n     *      non-null.\n     */\n    function promisify(obj, method) {\n        var result = new $.Deferred(),\n            args = Array.prototype.slice.call(arguments, 2);\n        args.push(function (err) {\n            if (err) {\n                result.reject(err);\n            } else {\n                result.resolve.apply(result, Array.prototype.slice.call(arguments, 1));\n            }\n        });\n        obj[method].apply(obj, args);\n        return result.promise();\n    }\n\n    /**\n     * Creates a queue of async operations that will be executed sequentially. Operations can be added to the\n     * queue at any time. If the queue is empty and nothing is currently executing when an operation is added,\n     * it will execute immediately. Otherwise, it will execute when the last operation currently in the queue\n     * has finished.\n     * @constructor\n     */\n    function PromiseQueue() {\n        this._queue = [];\n    }\n\n    /**\n     * @private\n     * @type {Array.<function(): $.Promise>}\n     * The queue of operations to execute sequentially. Note that even if this array is empty, there might\n     * still be an operation we need to wait on; that operation's promise is stored in _curPromise.\n     */\n    PromiseQueue.prototype._queue = null;\n\n    /**\n     * @private\n     * @type {$.Promise}\n     * The promise we're currently waiting on, or null if there's nothing currently executing.\n     */\n    PromiseQueue.prototype._curPromise = null;\n\n    /**\n     * @type {number} The number of queued promises.\n     */\n    Object.defineProperties(PromiseQueue.prototype, {\n        \"length\": {\n            get: function () { return this._queue.length; },\n            set: function () { throw new Error(\"Cannot set length\"); }\n        }\n    });\n\n    /**\n     * Adds an operation to the queue. If nothing is currently executing, it will execute immediately (and\n     * the next operation added to the queue will wait for it to complete). Otherwise, it will wait until\n     * the last operation in the queue (or the currently executing operation if nothing is in the queue) is\n     * finished. The operation must return a promise that will be resolved or rejected when it's finished;\n     * the queue will continue with the next operation regardless of whether the current operation's promise\n     * is resolved or rejected.\n     * @param {function(): $.Promise} op The operation to add to the queue.\n     */\n    PromiseQueue.prototype.add = function (op) {\n        this._queue.push(op);\n\n        // If something is currently executing, then _doNext() will get called when it's done. If nothing\n        // is executing (in which case the queue should have been empty), we need to call _doNext() to kickstart\n        // the queue.\n        if (!this._curPromise) {\n            this._doNext();\n        }\n    };\n\n    /**\n     * Removes all pending promises from the queue.\n     */\n    PromiseQueue.prototype.removeAll = function () {\n        this._queue = [];\n    };\n\n    /**\n     * @private\n     * Pulls the next operation off the queue and executes it.\n     */\n    PromiseQueue.prototype._doNext = function () {\n        var self = this;\n        if (this._queue.length) {\n            var op = this._queue.shift();\n            this._curPromise = op();\n            this._curPromise.always(function () {\n                self._curPromise = null;\n                self._doNext();\n            });\n        }\n    };\n\n    // Define public API\n    exports.doInParallel        = doInParallel;\n    exports.doSequentially      = doSequentially;\n    exports.doSequentiallyInBackground   = doSequentiallyInBackground;\n    exports.doInParallel_aggregateErrors = doInParallel_aggregateErrors;\n    exports.firstSequentially   = firstSequentially;\n    exports.withTimeout         = withTimeout;\n    exports.waitForAll          = waitForAll;\n    exports.ERROR_TIMEOUT       = ERROR_TIMEOUT;\n    exports.chain               = chain;\n    exports.promisify           = promisify;\n    exports.PromiseQueue        = PromiseQueue;\n});\n"],"file":"Async.js"}
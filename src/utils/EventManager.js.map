{"version":3,"sources":["utils/EventManager.js"],"names":["define","require","exports","module","_eventHandlerMap","registerEventHandler","handlerName","eventDispatcher","console","error","isExistsEventHandler","undefined","triggerEvent","eventName","eventParams","handler","trigger","window","onmessage","event","Phoenix","TRUSTED_ORIGINS","origin","Object","keys","data"],"mappings":"AAmDAA,OAAO,SAAUC,QAASC,QAASC,QAE/B,MAAMC,iBAAmB,GAsBzB,SAASC,qBAAqBC,YAAaC,iBACpCH,iBAAiBE,cAChBE,QAAQC,MAAM,6EAA8EH,aAEhGF,iBAAiBE,aAAeC,gBASpC,SAASG,qBAAqBJ,aAC1B,YAAyCK,IAAlCP,iBAAiBE,aAgB5B,SAASM,aAAaN,YAAaO,aAAcC,aAC7C,IAAIC,QAAUX,iBAAiBE,aAC3BS,SAAYF,UAIhBE,QAAQC,QAAQH,aAAcC,aAH1BN,QAAQC,uCAAuCH,0BAA0BO,oBAAoBC,eAmDrGG,OAAOC,UAAY,SAASC,OACxB,IAAIC,QAAQC,gBAAgBF,MAAMG,QAI9B,OAHAd,QAAQC,MAAM,6DACLc,OAAOC,KAAKJ,QAAQC,8BAA+BF,YAC5DX,QAAQC,MAAM,mFAGlB,MAAMH,YAAca,MAAMM,KAAKnB,YAAaO,UAAYM,MAAMM,KAAKZ,UAC/DP,aAGJM,aAAaN,YAAaO,UAAWM,QAIzCjB,QAAQG,qBAAuBA,qBAC/BH,QAAQQ,qBAAuBA,qBAC/BR,QAAQU,aAAeA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global less, Phoenix */\n// jshint ignore: start\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * The global EventManager can be used to register named EventDispatchers so that events\n * can be triggered from anywhere without using require context. This should also be used to handle custom\n * `window.onmessage` handlers.\n *\n * A global `window.EventManager` object is made available in phoenix that can be called anytime after AppStart.\n *\n * ## Usage\n * For Eg. Let's say we have an extension `drawImage` installed that wants to expose custom functionality to phoenix.\n * The Extension will first register named EventHandler like this:\n * ```js\n * // in drawImage/someExtensionModule.js module within the extension, do the following:\n * const EventDispatcher = brackets.getModule(\"utils/EventDispatcher\"),\n * EventManager = brackets.getModule(\"utils/EventManager\");\n * EventDispatcher.makeEventDispatcher(exports);\n *\n * EventManager.registerEventHandler(\"drawImage-Handler\", exports);\n * ```\n * Once the event handler is registered, we can trigger events on the named handler anywhere in phoenix\n * (inside or outside the extension) by using:\n *\n * ```js\n * EventManager.triggerEvent(\"drawImage-Handler\", \"someEventName\", \"param1\", \"param2\", ...);\n * ```\n * @module utils/EventManager\n */\ndefine(function (require, exports, module) {\n\n    const _eventHandlerMap = {};\n    /**\n     * Registers a named EventHandler. Event handlers are created using the call:\n     * `EventDispatcher.makeEventDispatcher(Command.prototype);`\n     *\n     * @example <caption>To register a close dialogue event handler in an extension:</caption>\n     * // in close-dialogue.js module winthin the extension, do the following:\n     * const EventDispatcher = brackets.getModule(\"utils/EventDispatcher\"),\n     * EventDispatcher.makeEventDispatcher(exports);\n     * const EventManager = brackets.getModule(\"utils/EventManager\");\n     *\n     * // Note: for event handler names, please change the <extensionName> to your extension name\n     * // to prevent collisions. EventHandlers starting with `ph-` and `br-` are reserved as system handlers\n     * // and not available for use in extensions.\n     * EventManager.registerEventHandler(\"<extensionName>-closeDialogueHandler\", exports);\n     * // Once the event handler is registered, see triggerEvent API on how to raise events\n     *\n     * @param {string} handlerName a unique name of the handler.\n     * @param {object} eventDispatcher An EventDispatcher that will be used to trigger events.\n     * @return {boolean}\n     * @type {function}\n     */\n    function registerEventHandler(handlerName, eventDispatcher) {\n        if(_eventHandlerMap[handlerName]){\n            console.error(\"Duplicate EventManager registration for event, overwriting event handler: \", handlerName);\n        }\n        _eventHandlerMap[handlerName] = eventDispatcher;\n    }\n\n    /**\n     * Returns true is an EventHandler of the given name exists.\n     * @param {string} handlerName\n     * @return {boolean}\n     * @type {function}\n     */\n    function isExistsEventHandler(handlerName) {\n        return _eventHandlerMap[handlerName] !== undefined;\n    }\n\n    /**\n     * Triggers an event on the named event handler.\n     *\n     * @example <caption>To trigger an event to the `closeDialogue` event handler registered above</caption>\n     * // anywhere in code, do the following:\n     * const EventManager = brackets.getModule(\"utils/EventManager\");\n     * EventManager.triggerEvent(\"closeDialogueHandler\", \"someEvent\", \"param1\", \"param2\", ...);\n     *\n     * @param {string} handlerName\n     * @param eventName the event name as recognised by the handler. this is usually a string.\n     * @param eventParams Can be a comma seperated list of args or a single argument.\n     * @type {function}\n     */\n    function triggerEvent(handlerName, eventName, ...eventParams) {\n        let handler = _eventHandlerMap[handlerName];\n        if(!handler || !eventName){\n            console.error(`Could not locate handler for: ${handlerName} eventName: ${eventName} event: ${eventParams}`);\n            return;\n        }\n        handler.trigger(eventName, ...eventParams);\n    }\n\n    /**\n     * This function acts as a secure event handler for all 'message' events targeted at the window object.\n     * This is useful if you have to send/receive messaged from an embedded cross-domain iframe inside phoenix.\n     * https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n     * Instead of directly overriding window.onmessage, extensions or other elements that need to\n     * listen to these events should register their named eventHandler with `EventManager`.\n     *\n     * By default, only origins part of `window.Phoenix.TRUSTED_ORIGINS` are whitelisted. If your extension is\n     * bringing in a cross-origin ifrmame say `http://mydomain.com`, you should add it to the whitelist by setting\n     * `window.Phoenix.TRUSTED_ORIGINS[\"http://mydomain.com\"]=true;`\n     *\n     * @function\n     * @global\n     * @listens window#message\n     *\n     * @param {MessageEvent} event - The 'message' event targeted at the window object. The event's\n     *   'data' property should have a 'handlerName' and `eventName` property that will be triggered in phcode.\n     *\n     * @example\n     * // We will try to communicate within an embedded iframe and an extension\n     *\n     * // In your extension in phoenix, register a handlerName to process a new kind of event.\n     * const EventDispatcher = brackets.getModule(\"utils/EventDispatcher\"),\n     * EventDispatcher.makeEventDispatcher(exports);\n     * const EventManager = brackets.getModule(\"utils/EventManager\");\n     * // Note: for event handler names, please change the <extensionName> to your extension name\n     * // to prevent collisions. EventHandlers starting with `ph-` and `br-` are reserved as system handlers\n     * // and not available for use in extensions.\n     * window.Phoenix.TRUSTED_ORIGINS[\"http://mydomain.com\"]=true;\n     * EventManager.registerEventHandler(\"<extensionName>-iframeMessageHandler\", exports);\n     * exports.on(\"iframeHelloEvent\", function(_ev, event){\n     *    console.log(event.data.message);\n     * });\n     *\n     * // Now from your iframe, send a message to the above event handler using:\n     * window.top.postMessage({\n     *     handlerName: \"<extensionName>-iframeMessageHandler\",\n     *     eventName: \"iframeHelloEvent\",\n     *     message: \"hello world\"\n     * }, '*');\n     * // `you should replace * with the trusted domains list in production for security.` See how this can be\n     * // done securely with this example: https://github.com/phcode-dev/phcode.live/blob/6d64386fbb9d671cdb64622bc48ffe5f71959bff/docs/virtual-server-loader.js#L43\n     * // Abstract is that, pass in the parentOrigin as a query string parameter in iframe, and validate it against\n     * // a trusted domains list in your iframe.\n     */\n    window.onmessage = function(event) {\n        if(!Phoenix.TRUSTED_ORIGINS[event.origin]){\n            console.error(`Ignoring event from untrusted origin (should be one of `\n                + `${Object.keys(Phoenix.TRUSTED_ORIGINS)}) but got: `, event);\n            console.error('Forgot to set window.Phoenix.TRUSTED_ORIGINS[\"http://<yourdomain.com>\"]=true; ?');\n            return;\n        }\n        const handlerName = event.data.handlerName, eventName = event.data.eventName;\n        if(!handlerName) {\n            return;\n        }\n        triggerEvent(handlerName, eventName, event);\n    };\n\n    // Public API\n    exports.registerEventHandler = registerEventHandler;\n    exports.isExistsEventHandler = isExistsEventHandler;\n    exports.triggerEvent = triggerEvent;\n});\n"],"file":"EventManager.js"}
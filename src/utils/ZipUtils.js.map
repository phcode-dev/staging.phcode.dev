{"version":3,"sources":["utils/ZipUtils.js"],"names":["define","require","exports","module","ignoredFolders","async","_ensureExistsAsync","path","Promise","resolve","reject","Phoenix","VFS","ensureExistsDir","err","_copyZippedItemToFS","item","destProjectDir","flattenFirstLevel","zipControl","destPath","newPath","substr","indexOf","console","log","dir","window","dirname","then","data","continueExtraction","fs","writeFile","Filer","Buffer","from","writeErr","catch","error","e","_isNestedContentDir","zip","keys","Object","files","rootEntries","filePath","endsWith","slice","includes","baseName","split","length","unzipBinDataToLocation","zipData","projectDir","progressControlCallback","JSZip","loadAsync","extractBatchSize","isNestedContent","totalCount","doneCount","extractPromises","extractPromise","push","all","unzipURLToLocation","url","JSZipUtils","getBinaryContent"],"mappings":"AAsBAA,OAAO,SAAUC,QAASC,QAASC,QAE/B,MAAMC,eAAiB,CAAE,YAEzBC,eAAeC,mBAAmBC,MAC9B,OAAO,IAAIC,QAAQ,CAACC,QAASC,UACzBC,QAAQC,IAAIC,gBAAgBN,KAAOO,MAC5BA,IACCJ,OAAOI,KAEPL,cAMhB,SAASM,oBAAoBR,KAAMS,KAAMC,eAAgBC,kBAAmBC,YACxE,OAAO,IAAIX,QAAQH,MAAOI,QAASC,UAC/B,IACI,IAAIU,YAAcH,iBAAiBV,OACnC,GAAGW,kBAAkB,CAEjB,IAAIG,QAAUd,KAAKe,OAAOf,KAAKgB,QAAQ,KAAO,GAC9CH,YAAcH,iBAAiBI,UAC/BG,QAAQC,IAAIL,UAEbJ,KAAKU,WACEpB,mBAAmBc,UACzBX,QAAQW,kBAEFd,mBAAmBqB,OAAOpB,KAAKqB,QAAQR,WAC7CJ,KAAKX,MAAM,cAAcwB,KAAK,SAAUC,OACjCX,YAAeA,WAAWY,mBAI7BJ,OAAOK,GAAGC,UAAUb,SAAUc,MAAMC,OAAOC,KAAKN,MAAOO,WAChDA,SACC3B,OAAO2B,UAEP5B,QAAQW,YAPZV,WAUL4B,MAAMC,QACL7B,OAAO6B,UAGjB,MAAOC,GACL9B,OAAO8B,MAKnB,SAASC,oBAAoBC,KACzB,IAAIC,KAAOC,OAAOD,KAAKD,IAAIG,OACvBC,YAAc,GAClB,IAAI,IAAIvC,QAAQoC,KAAK,CACjB,IAAII,SAAWxC,KAAKyC,SAAS,KAAOzC,KAAK0C,MAAM,GAAI,GAAK1C,KACpDS,KACJ,IADW0B,IAAIG,MAAMtC,MACZmB,MAAQqB,SAASG,SAAS,KAC/B,OAAO,EAEX,IAAIC,SAAWJ,SAASK,MAAM,KAAK,GAC/BhD,eAAe8C,SAASC,YACxBL,YAAYK,WAAY,GAGhC,OAAuC,IAApCP,OAAOD,KAAKG,aAAaO,OAsBhC,SAASC,uBAAuBC,QAASC,WAAYtC,mBAAoB,EAAOuC,yBAI5E,OAHID,WAAWR,SAAS,OACpBQ,YAA0B,KAEvB,IAAIhD,QAAQ,CAACC,QAASC,UACzBgD,MAAMC,UAAUJ,SAAS1B,KAAKxB,eAAgBqC,KAC1C,IAAIC,KAAOC,OAAOD,KAAKD,IAAIG,OAC3B,IACI,MAAMe,iBAAmB,IACnBC,gBAAkBpB,oBAAoBC,KAC5C,IAAIoB,WAAanB,KAAKU,OAClBU,UAAY,EACZC,gBAAkB,GAClB7C,WAAa,CACTY,oBAAoB,GAE5B,IAAI,IAAIxB,QAAQoC,KAAK,CAEjB,IAAIsB,eAAiBlD,oBAAoBR,KAAMmC,IAAIG,MAAMtC,MAAOiD,WAC5DK,iBAAmB3C,kBAAmBC,YAc1C,GAZA8C,eAAepC,KAAK,KAChBkC,YACGN,0BACCtC,WAAWY,mBAAqBZ,WAAWY,oBACpC0B,wBAAwBM,UAAWD,eAGlDE,gBAAgBE,KAAKD,gBAClBD,gBAAgBX,SAAWO,yBACpBpD,QAAQ2D,IAAIH,iBAClBA,gBAAkB,KAEe,IAAlC7C,WAAWY,mBAEV,YADArB,OAAO,+CAIZsD,gBAAgBX,cACT7C,QAAQ2D,IAAIH,iBAEtBxC,QAAQC,IAAI,mBAAoB+B,YAChC/C,UACF,MAAOK,KACLU,QAAQe,MAAM,eAAgBzB,KAC9BJ,OAAOI,UAiBvB,SAASsD,mBAAmBC,IAAKb,WAAYtC,mBAAoB,GAC7D,OAAO,IAAIV,QAAQ,CAACC,QAASC,UACzBiB,OAAO2C,WAAWC,iBAAiBF,IAAKhE,eAAeS,IAAKgB,MACrDhB,KACCU,QAAQe,sCAAsC8B,SAAUvD,KACxDJ,UAEA4C,uBAAuBxB,KAAM0B,WAAYtC,mBACpCW,KAAKpB,SACL6B,MAAM5B,YAK3BR,QAAQoD,uBAAyBA,uBACjCpD,QAAQkE,mBAAqBA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*globals Phoenix, JSZip, Filer*/\n\ndefine(function (require, exports, module) {\n\n    const ignoredFolders = [ \"__MACOSX\" ];\n\n    async function _ensureExistsAsync(path) {\n        return new Promise((resolve, reject)=>{\n            Phoenix.VFS.ensureExistsDir(path, (err)=>{\n                if(err){\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n\n    function _copyZippedItemToFS(path, item, destProjectDir, flattenFirstLevel, zipControl) {\n        return new Promise(async (resolve, reject) =>{ // eslint-disable-line\n            try {\n                let destPath = `${destProjectDir}${path}`;\n                if(flattenFirstLevel){\n                    // contents/index.html to index.html\n                    let newPath = path.substr(path.indexOf(\"/\") + 1);\n                    destPath = `${destProjectDir}${newPath}`;\n                    console.log(destPath);\n                }\n                if(item.dir){\n                    await _ensureExistsAsync(destPath);\n                    resolve(destPath);\n                } else {\n                    await _ensureExistsAsync(window.path.dirname(destPath));\n                    item.async(\"uint8array\").then(function (data) {\n                        if(zipControl && !zipControl.continueExtraction){\n                            reject();\n                            return;\n                        }\n                        window.fs.writeFile(destPath, Filer.Buffer.from(data), writeErr=>{\n                            if(writeErr){\n                                reject(writeErr);\n                            } else {\n                                resolve(destPath);\n                            }\n                        });\n                    }).catch(error=>{\n                        reject(error);\n                    });\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    function _isNestedContentDir(zip) {\n        let keys = Object.keys(zip.files);\n        let rootEntries = {};\n        for(let path of keys){\n            let filePath = path.endsWith(\"/\") ? path.slice(0, -1) : path; // trim last slah if present\n            let item = zip.files[path];\n            if(!item.dir && !filePath.includes(\"/\")) { // file in root folder means not nested zip\n                return false;\n            }\n            let baseName = filePath.split(\"/\")[0];\n            if(!ignoredFolders.includes(baseName)){\n                rootEntries[baseName] = true;\n            }\n        }\n        if(Object.keys(rootEntries).length === 1) {\n            // lone content folder\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * extracts a given binary zip data array to given location\n     * @param zipData binary UInt8Array zip data\n     * @param projectDir To extract to\n     * @param flattenFirstLevel if set to true, then if zip contents are nested inside a directory, the nexted dir will\n     * be removed in the path structure in destination. For Eg. some Zip may contain a `contents` folder inside the zip\n     * which has all the contents. If we blindly extract the zio, all the contents will be placed inside a `contents`\n     * folder in root and not the root dir itself.\n     * See a sample zip file here: https://api.github.com/repos/StartBootstrap/startbootstrap-grayscales/zipball\n     * @param {function(doneCount: number, totalCount: number)} [progressControlCallback] A function that can be used\n     * to view the progress and stop further extraction. The function will be invoked with (doneCount, totalCount).\n     * The function should return `false` if further extraction needs to be stopped. If nothing or `true` is returned,\n     * it will continue extraction.\n     * @returns {Promise}\n     */\n    function unzipBinDataToLocation(zipData, projectDir, flattenFirstLevel = false, progressControlCallback) {\n        if(!projectDir.endsWith('/')){\n            projectDir = projectDir + \"/\";\n        }\n        return new Promise((resolve, reject)=>{\n            JSZip.loadAsync(zipData).then(async function (zip) {\n                let keys = Object.keys(zip.files);\n                try{\n                    const extractBatchSize = 500;\n                    const isNestedContent = _isNestedContentDir(zip);\n                    let totalCount = keys.length,\n                        doneCount = 0,\n                        extractPromises = [],\n                        zipControl = {\n                            continueExtraction: true\n                        };\n                    for(let path of keys){\n                        // This is intentionally batched as fs access api hangs on large number of file access\n                        let extractPromise = _copyZippedItemToFS(path, zip.files[path], projectDir,\n                            isNestedContent && flattenFirstLevel, zipControl);\n                        // eslint-disable-next-line no-loop-func\n                        extractPromise.then(()=>{\n                            doneCount ++;\n                            if(progressControlCallback){\n                                zipControl.continueExtraction = zipControl.continueExtraction\n                                    && progressControlCallback(doneCount, totalCount);\n                            }\n                        });\n                        extractPromises.push(extractPromise);\n                        if(extractPromises.length === extractBatchSize){\n                            await Promise.all(extractPromises);\n                            extractPromises = [];\n                        }\n                        if(zipControl.continueExtraction === false){\n                            reject(`Extraction cancelled by progress controller`);\n                            return;\n                        }\n                    }\n                    if(extractPromises.length) {\n                        await Promise.all(extractPromises);\n                    }\n                    console.log(\"Unzip complete: \", projectDir);\n                    resolve();\n                } catch (err) {\n                    console.error('unzip failed', err);\n                    reject(err);\n                }\n            });\n        });\n    }\n\n    /**\n     *\n     * @param url the zip fle URL\n     * @param projectDir To extract to\n     * @param flattenFirstLevel if set to true, then if zip contents are nested inside a directory, the nexted dir will\n     * be removed in the path structure in destination. For Eg. some Zip may contain a `contents` folder inside the zip\n     * which has all the contents. If we blindly extract the zio, all the contents will be placed inside a `contents`\n     * folder in root and not the root dir itself.\n     * See a sample zip file here: https://api.github.com/repos/StartBootstrap/startbootstrap-grayscales/zipball\n     * @returns {Promise}\n     */\n    function unzipURLToLocation(url, projectDir, flattenFirstLevel = false) {\n        return new Promise((resolve, reject)=>{\n            window.JSZipUtils.getBinaryContent(url, async function(err, data) {\n                if(err) {\n                    console.error(`could not load zip from URL: ${url}\\n `, err);\n                    reject();\n                } else {\n                    unzipBinDataToLocation(data, projectDir, flattenFirstLevel)\n                        .then(resolve)\n                        .catch(reject);\n                }\n            });\n        });\n    }\n    exports.unzipBinDataToLocation = unzipBinDataToLocation;\n    exports.unzipURLToLocation = unzipURLToLocation;\n});\n"],"file":"ZipUtils.js"}
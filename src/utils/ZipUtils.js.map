{"version":3,"sources":["utils/ZipUtils.js"],"names":["define","require","exports","module","FileSystem","ignoredFolders","async","_ensureExistsAsync","path","Promise","resolve","reject","Phoenix","VFS","ensureExistsDir","err","_copyZippedItemToFS","item","destProjectDir","flattenFirstLevel","zipControl","destPath","newPath","substr","indexOf","console","log","dir","window","dirname","then","data","continueExtraction","fs","writeFile","Filer","Buffer","from","writeErr","catch","error","e","_isNestedContentDir","zip","keys","Object","files","rootEntries","filePath","endsWith","slice","includes","baseName","split","length","unzipBinDataToLocation","zipData","projectDir","progressControlCallback","JSZip","loadAsync","extractBatchSize","isNestedContent","extractError","totalCount","doneCount","extractPromises","_unzipProgress","_extractFailed","extractPromise","push","allSettled","readContent","fileEntry","read","encoding","BYTE_ARRAY_ENCODING","content","stat","blob","Blob","type","zipFolder","fullPath","directory","getDirectoryForPath","getAllDirectoryContents","entry","contents","relativePath","relative","isDirectory","folder","file","unzipURLToLocation","url","JSZipUtils","getBinaryContent"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*globals Phoenix, JSZip, Filer, path*/\n\ndefine(function (require, exports, module) {\n    const FileSystem = require(\"filesystem/FileSystem\");\n\n    const ignoredFolders = [ \"__MACOSX\" ];\n\n    async function _ensureExistsAsync(path) {\n        return new Promise((resolve, reject)=>{\n            Phoenix.VFS.ensureExistsDir(path, (err)=>{\n                if(err){\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n\n    function _copyZippedItemToFS(path, item, destProjectDir, flattenFirstLevel, zipControl) {\n        return new Promise(async (resolve, reject) =>{ // eslint-disable-line\n            try {\n                let destPath = `${destProjectDir}${path}`;\n                if(flattenFirstLevel){\n                    // contents/index.html to index.html\n                    let newPath = path.substr(path.indexOf(\"/\") + 1);\n                    destPath = `${destProjectDir}${newPath}`;\n                    console.log(destPath);\n                }\n                if(item.dir){\n                    await _ensureExistsAsync(destPath);\n                    resolve(destPath);\n                } else {\n                    await _ensureExistsAsync(window.path.dirname(destPath));\n                    item.async(\"uint8array\").then(function (data) {\n                        if(zipControl && !zipControl.continueExtraction){\n                            reject(\"aborted\");\n                            return;\n                        }\n                        window.fs.writeFile(destPath, Filer.Buffer.from(data), writeErr=>{\n                            if(writeErr){\n                                reject(writeErr);\n                            } else {\n                                resolve(destPath);\n                            }\n                        });\n                    }).catch(error=>{\n                        reject(error);\n                    });\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    function _isNestedContentDir(zip) {\n        let keys = Object.keys(zip.files);\n        let rootEntries = {};\n        for(let path of keys){\n            let filePath = path.endsWith(\"/\") ? path.slice(0, -1) : path; // trim last slah if present\n            let item = zip.files[path];\n            if(!item.dir && !filePath.includes(\"/\")) { // file in root folder means not nested zip\n                return false;\n            }\n            let baseName = filePath.split(\"/\")[0];\n            if(!ignoredFolders.includes(baseName)){\n                rootEntries[baseName] = true;\n            }\n        }\n        if(Object.keys(rootEntries).length === 1) {\n            // lone content folder\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * extracts a given binary zip data array to given location\n     * @param zipData binary UInt8Array zip data\n     * @param projectDir To extract to\n     * @param flattenFirstLevel if set to true, then if zip contents are nested inside a directory, the nexted dir will\n     * be removed in the path structure in destination. For Eg. some Zip may contain a `contents` folder inside the zip\n     * which has all the contents. If we blindly extract the zio, all the contents will be placed inside a `contents`\n     * folder in root and not the root dir itself.\n     * See a sample zip file here: https://api.github.com/repos/StartBootstrap/startbootstrap-grayscales/zipball\n     * @param {function(doneCount: number, totalCount: number)} [progressControlCallback] A function that can be used\n     * to view the progress and stop further extraction. The function will be invoked with (doneCount, totalCount).\n     * The function should return `false` if further extraction needs to be stopped. If nothing or `true` is returned,\n     * it will continue extraction.\n     * @returns {Promise}\n     */\n    function unzipBinDataToLocation(zipData, projectDir, flattenFirstLevel = false, progressControlCallback) {\n        if(!projectDir.endsWith('/')){\n            projectDir = projectDir + \"/\";\n        }\n        return new Promise((resolve, reject)=>{\n            JSZip.loadAsync(zipData).then(async function (zip) {\n                let keys = Object.keys(zip.files);\n                try{\n                    const extractBatchSize = 500;\n                    const isNestedContent = _isNestedContentDir(zip);\n                    let extractError;\n                    let totalCount = keys.length,\n                        doneCount = 0,\n                        extractPromises = [],\n                        zipControl = {\n                            continueExtraction: true\n                        };\n                    function _unzipProgress() {\n                        doneCount ++;\n                        if(progressControlCallback){\n                            zipControl.continueExtraction = zipControl.continueExtraction\n                                && progressControlCallback(doneCount, totalCount);\n                        }\n                    }\n                    function _extractFailed(err) {\n                        extractError = err || \"extract failed\";\n                    }\n                    for(let path of keys){\n                        // This is intentionally batched as fs access api hangs on large number of file access\n                        let extractPromise = _copyZippedItemToFS(path, zip.files[path], projectDir,\n                            isNestedContent && flattenFirstLevel, zipControl);\n                        // eslint-disable-next-line no-loop-func\n                        extractPromise.then(_unzipProgress)\n                            .catch(_extractFailed);\n                        extractPromises.push(extractPromise);\n                        if(extractPromises.length === extractBatchSize){\n                            await Promise.allSettled(extractPromises);\n                            extractPromises = [];\n                        }\n                        if(zipControl.continueExtraction === false){\n                            reject(`Extraction cancelled by progress controller`);\n                            return;\n                        }\n                        if(extractError){\n                            reject(extractError);\n                            return;\n                        }\n                    }\n                    if(extractPromises.length) {\n                        await Promise.allSettled(extractPromises);\n                    }\n                    if(extractError){\n                        reject(extractError);\n                        return;\n                    }\n                    console.log(\"Unzip complete: \", projectDir);\n                    resolve();\n                } catch (err) {\n                    console.error('unzip failed', err);\n                    reject(err);\n                }\n            });\n        });\n    }\n\n    function readContent(fileEntry) {\n        return new Promise((resolve, reject)=>{\n            fileEntry.read({encoding: window.fs.BYTE_ARRAY_ENCODING}, function (err, content, encoding, stat) {\n                if (err){\n                    reject(err);\n                    return;\n                }\n                let blob = new Blob([content], {type:\"application/octet-stream\"});\n                resolve(blob);\n            });\n        });\n    }\n\n    /**\n     * Zips a given folder located at path to a jsZip object.\n     * @param {string} fullPath to zip\n     * @return {Promise<JSZip>} zip object\n     */\n    function zipFolder(fullPath) {\n        return new Promise((resolve, reject)=>{\n            const zip = new JSZip();\n            let directory = FileSystem.getDirectoryForPath(fullPath);\n            FileSystem.getAllDirectoryContents(directory).then(async contents => {\n                for(let entry of contents){\n                    let relativePath = path.relative(fullPath, entry.fullPath);\n                    if(entry.isDirectory){\n                        zip.folder(relativePath);\n                    } else {\n                        let blob = await readContent(entry);\n                        zip.file(relativePath, blob);\n                    }\n                }\n                resolve(zip);\n            }).catch(reject);\n        });\n    }\n\n    /**\n     *\n     * @param url the zip fle URL\n     * @param projectDir To extract to\n     * @param flattenFirstLevel if set to true, then if zip contents are nested inside a directory, the nexted dir will\n     * be removed in the path structure in destination. For Eg. some Zip may contain a `contents` folder inside the zip\n     * which has all the contents. If we blindly extract the zio, all the contents will be placed inside a `contents`\n     * folder in root and not the root dir itself.\n     * See a sample zip file here: https://api.github.com/repos/StartBootstrap/startbootstrap-grayscales/zipball\n     * @returns {Promise}\n     */\n    function unzipURLToLocation(url, projectDir, flattenFirstLevel = false) {\n        return new Promise((resolve, reject)=>{\n            window.JSZipUtils.getBinaryContent(url, async function(err, data) {\n                if(err) {\n                    console.error(`could not load zip from URL: ${url}\\n `, err);\n                    reject();\n                } else {\n                    unzipBinDataToLocation(data, projectDir, flattenFirstLevel)\n                        .then(resolve)\n                        .catch(reject);\n                }\n            });\n        });\n    }\n    exports.unzipBinDataToLocation = unzipBinDataToLocation;\n    exports.unzipURLToLocation = unzipURLToLocation;\n    exports.zipFolder = zipFolder;\n});\n"],"file":"ZipUtils.js"}
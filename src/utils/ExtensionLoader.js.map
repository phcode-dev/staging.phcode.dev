{"version":3,"sources":["utils/ExtensionLoader.js"],"names":["define","require","exports","module","_","EventDispatcher","FileSystem","FileUtils","Async","ExtensionUtils","UrlParams","PathUtils","EXTENSION_LOAD_TIMOUT_SECONDS","INIT_EXTENSION_TIMEOUT","_init","_extensions","_initExtensionTimeout","srcPath","getNativeBracketsDirectoryPath","contexts","pathLib","Phoenix","VFS","path","replace","globalPaths","brackets","_getGlobalRequireJSConfig","paths","getDefaultExtensionPath","normalize","_getExtensionPath","app","getExtensionDirectory","getDevExtensionPath","getUserExtensionPath","getApplicationSupportDirectory","getRequireContextForExtension","name","_getInitExtensionTimeout","_setInitExtensionTimeout","value","_mergeConfigFromURL","baseConfig","deferred","$","Deferred","extensionConfigFile","baseUrl","get","done","extensionConfig","extend","omit","resolve","err","reject","fail","promise","_mergeConfig","startsWith","getFileForPath","readAsText","text","JSON","parse","loadExtensionModule","config","entryPoint","context","locale","getLocale","waitSeconds","isDefaultExtensionModule","location","href","then","mergedConfig","extensionRequire","libRequire","extensionRequireDeferred","initPromise","initExtension","withTimeout","console","error","logger","reportError","errorMessage","ERROR_TIMEOUT","errback","additionalInfo","String","requireType","originalError","target","src","log","stack","loadExtension","loadMetadata","always","metadata","theme","disabled","trigger","_testExtensionByURL","result","e","testExtension","extensionPath","entry","isFile","_loadAll","directory","processExtension","getDirectoryForPath","getContents","contents","i","extensions","length","isDirectory","push","doInParallel","item","extConfig","window","fsServerUrl","loadAllDefaultExtensions","substring","lastIndexOf","extensionsToLoadURL","extensionNames","extensionName","leaveTrail","loadAllExtensionsInNativeDirectory","testAllExtensionsInNativeDirectory","virtualServerURL","extensionsDir","perf","spec","loadResult","basePath","testAllDefaultExtensions","bracketsPath","srcBaseUrl","URL","init","params","create","disabledExtensionPath","extPath","Object","keys","forEach","key","makePathAbsolute","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n/**\n * ExtensionLoader searches the filesystem for extensions, then creates a new context for each one and loads it.\n * This module dispatches the following events:\n *      \"load\" - when an extension is successfully loaded. The second argument is the file path to the\n *          extension root.\n *      \"loadFailed\" - when an extension load is unsuccessful. The second argument is the file path to the\n *          extension root.\n */\n// jshint ignore: start\n/*global logger, Phoenix*/\n/*eslint-env es6*/\n/*eslint no-console: 0*/\n/*eslint strict: [\"error\", \"global\"]*/\n\ndefine(function (require, exports, module) {\n\n\n    require(\"utils/Global\");\n\n    var _              = require(\"thirdparty/lodash\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        FileSystem     = require(\"filesystem/FileSystem\"),\n        FileUtils      = require(\"file/FileUtils\"),\n        Async          = require(\"utils/Async\"),\n        ExtensionUtils = require(\"utils/ExtensionUtils\"),\n        UrlParams      = require(\"utils/UrlParams\").UrlParams,\n        PathUtils      = require(\"thirdparty/path-utils/path-utils\");\n\n    // default async initExtension timeout\n    var EXTENSION_LOAD_TIMOUT_SECONDS = 60,\n        INIT_EXTENSION_TIMEOUT = EXTENSION_LOAD_TIMOUT_SECONDS * 1000;\n\n    var _init       = false,\n        _extensions = {},\n        _initExtensionTimeout = INIT_EXTENSION_TIMEOUT,\n        srcPath     = FileUtils.getNativeBracketsDirectoryPath();\n\n    /**\n     * Stores require.js contexts of extensions\n     * @type {Object.<string, Object>}\n     */\n    var contexts    = {};\n\n    var pathLib =  Phoenix.VFS.path;\n\n    // The native directory path ends with either \"test\" or \"src\". We need \"src\" to\n    // load the text and i18n modules.\n    srcPath = srcPath.replace(/\\/test$/, \"/src\"); // convert from \"test\" to \"src\"\n\n\n    // Retrieve the global paths\n    var globalPaths = brackets._getGlobalRequireJSConfig().paths;\n\n    // Convert the relative paths to absolute\n    Object.keys(globalPaths).forEach(function (key) {\n        globalPaths[key] = PathUtils.makePathAbsolute(srcPath + \"/\" + globalPaths[key]);\n    });\n\n    /**\n     * Returns the path to the default extensions directory relative to Phoenix base URL\n     */\n    function getDefaultExtensionPath() {\n        return pathLib.normalize(\"/extensions/default\");\n    }\n\n    /**\n     * Returns the full path to the development extensions directory.\n     */\n    function _getExtensionPath() {\n        return pathLib.normalize(brackets.app.getExtensionDirectory());\n    }\n\n    /**\n     * Returns the full path to the development extensions directory.\n     */\n    function getDevExtensionPath() {\n        return _getExtensionPath() + \"/dev\";\n    }\n\n    /**\n     * Returns the full path of the default user extensions directory. This is in the users\n     * application support directory, which is typically\n     * /Users/<user>/Application Support/Brackets/extensions/user on the mac, and\n     * C:\\Users\\<user>\\AppData\\Roaming\\Brackets\\extensions\\user on windows.\n     */\n    function getUserExtensionPath() {\n        if (brackets.app.getApplicationSupportDirectory) {\n            return _getExtensionPath()+ \"/user\";\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the require.js require context used to load an extension\n     *\n     * @param {!string} name, used to identify the extension\n     * @return {!Object} A require.js require object used to load the extension, or undefined if\n     * there is no require object with that name\n     */\n    function getRequireContextForExtension(name) {\n        return contexts[name];\n    }\n\n    /**\n     * @private\n     * Get timeout value for rejecting an extension's async initExtension promise.\n     * @return {number} Timeout in milliseconds\n     */\n    function _getInitExtensionTimeout() {\n        return _initExtensionTimeout;\n    }\n\n    /**\n     * @private\n     * Set timeout for rejecting an extension's async initExtension promise.\n     * @param {number} value Timeout in milliseconds\n     */\n    function _setInitExtensionTimeout(value) {\n        _initExtensionTimeout = value;\n    }\n\n    /**\n     * @private\n     * Loads optional requirejs-config.json file for an extension\n     * @param {Object} baseConfig\n     * @return {$.Promise}\n     */\n    function _mergeConfigFromURL(baseConfig) {\n        var deferred = new $.Deferred(),\n            extensionConfigFile = baseConfig.baseUrl + \"/requirejs-config.json\";\n\n        // Optional JSON config for require.js\n        $.get(extensionConfigFile).done(function (extensionConfig) {\n            if(!extensionConfig){\n                extensionConfig = {};\n            }\n            try {\n                if(!extensionConfig.paths){\n                    extensionConfig.paths = {};\n                }\n                // baseConfig.paths properties will override any extension config paths\n                _.extend(extensionConfig.paths, baseConfig.paths);\n\n                // Overwrite baseUrl, context, locale (paths is already merged above)\n                _.extend(extensionConfig, _.omit(baseConfig, \"paths\"));\n\n                deferred.resolve(extensionConfig);\n            } catch (err) {\n                // Failed to parse requirejs-config.json\n                deferred.reject(\"failed to parse requirejs-config.json\");\n            }\n        }).fail(function () {\n            // If requirejs-config.json isn't specified, resolve with the baseConfig only\n            deferred.resolve(baseConfig);\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * @private\n     * Loads optional requirejs-config.json file for an extension\n     * @param {Object} baseConfig\n     * @return {$.Promise}\n     */\n    function _mergeConfig(baseConfig) {\n        if(baseConfig.baseUrl.startsWith(\"http://\") || baseConfig.baseUrl.startsWith(\"https://\")) {\n            return _mergeConfigFromURL(baseConfig);\n        }\n        var deferred = new $.Deferred(),\n            extensionConfigFile = FileSystem.getFileForPath(baseConfig.baseUrl + \"/requirejs-config.json\");\n\n        // Optional JSON config for require.js\n        FileUtils.readAsText(extensionConfigFile).done(function (text) {\n            try {\n                var extensionConfig = JSON.parse(text);\n                if(!extensionConfig.paths){\n                    extensionConfig.paths = {};\n                }\n\n                // baseConfig.paths properties will override any extension config paths\n                _.extend(extensionConfig.paths, baseConfig.paths);\n\n                // Overwrite baseUrl, context, locale (paths is already merged above)\n                _.extend(extensionConfig, _.omit(baseConfig, \"paths\"));\n\n                deferred.resolve(extensionConfig);\n            } catch (err) {\n                // Failed to parse requirejs-config.json\n                deferred.reject(\"failed to parse requirejs-config.json\");\n            }\n        }).fail(function () {\n            // If requirejs-config.json isn't specified, resolve with the baseConfig only\n            deferred.resolve(baseConfig);\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * Loads the extension module that lives at baseUrl into its own Require.js context\n     *\n     * @param {!string} name, used to identify the extension\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension\n     * @param {!string} entryPoint, name of the main js file to load\n     * @return {!$.Promise} A promise object that is resolved when the extension is loaded, or rejected\n     *              if the extension fails to load or throws an exception immediately when loaded.\n     *              (Note: if extension contains a JS syntax error, promise is resolved not rejected).\n     */\n    function loadExtensionModule(name, config, entryPoint) {\n        let extensionConfig = {\n            context: name,\n            baseUrl: config.baseUrl,\n            paths: globalPaths,\n            locale: brackets.getLocale(),\n            waitSeconds: EXTENSION_LOAD_TIMOUT_SECONDS\n        };\n        const isDefaultExtensionModule =( extensionConfig.baseUrl\n            && extensionConfig.baseUrl.startsWith(`${location.href}extensions/default/`));\n        // Read optional requirejs-config.json\n        return _mergeConfig(extensionConfig).then(function (mergedConfig) {\n            // Create new RequireJS context and load extension entry point\n            var extensionRequire = brackets.libRequire.config(mergedConfig),\n                extensionRequireDeferred = new $.Deferred();\n\n            contexts[name] = extensionRequire;\n            extensionRequire([entryPoint], extensionRequireDeferred.resolve, extensionRequireDeferred.reject);\n\n            return extensionRequireDeferred.promise();\n        }).then(function (module) {\n            // Extension loaded normally\n            var initPromise;\n\n            _extensions[name] = module;\n\n            // Optional sync/async initExtension\n            if (module && module.initExtension && (typeof module.initExtension === \"function\")) {\n                // optional async extension init\n                try {\n                    initPromise = Async.withTimeout(module.initExtension(), _getInitExtensionTimeout());\n                } catch (err) {\n                    // Synchronous error while initializing extension\n                    console.error(\"[Extension] Error -- error thrown during initExtension for \" + name + \": \" + err);\n                    logger.reportError(err);\n                    return new $.Deferred().reject(err).promise();\n                }\n\n                // initExtension may be synchronous and may not return a promise\n                if (initPromise) {\n                    // WARNING: These calls to initPromise.fail() and initPromise.then(),\n                    // could also result in a runtime error if initPromise is not a valid\n                    // promise. Currently, the promise is wrapped via Async.withTimeout(),\n                    // so the call is safe as-is.\n                    initPromise.fail(function (err) {\n                        let errorMessage = \"[Extension] Error -- timeout during initExtension for \" + name;\n                        if (err === Async.ERROR_TIMEOUT) {\n                            console.error(errorMessage);\n                        } else {\n                            errorMessage = \"[Extension] Error -- failed initExtension for \" + name;\n                            console.error(errorMessage + (err ? \": \" + err : \"\"));\n                        }\n                        if(isDefaultExtensionModule){\n                            logger.reportError(err, errorMessage);\n                        }\n                    });\n\n                    return initPromise;\n                }\n            }\n        }, function errback(err) {\n            // Extension failed to load during the initial require() call\n            var additionalInfo = String(err);\n            if (err.requireType === \"scripterror\" && err.originalError) {\n                // This type has a misleading error message - replace it with something clearer (URL of require() call that got a 404 result)\n                additionalInfo = \"Module does not exist: \" + err.originalError.target.src;\n            }\n            console.error(\"[Extension] failed to load \" + config.baseUrl + \" - \" + additionalInfo);\n            if(isDefaultExtensionModule){\n                logger.reportError(err, \"[Extension] failed to load \" + config.baseUrl + \" - \" + additionalInfo);\n            }\n\n            if (err.requireType === \"define\") {\n                // This type has a useful stack (exception thrown by ext code or info on bad getModule() call)\n                console.log(err.stack);\n            }\n        });\n    }\n\n    /**\n     * Loads the extension that lives at baseUrl into its own Require.js context\n     *\n     * @param {!string} name, used to identify the extension\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension\n     * @param {!string} entryPoint, name of the main js file to load\n     * @return {!$.Promise} A promise object that is resolved when the extension is loaded, or rejected\n     *              if the extension fails to load or throws an exception immediately when loaded.\n     *              (Note: if extension contains a JS syntax error, promise is resolved not rejected).\n     */\n    function loadExtension(name, config, entryPoint) {\n        var promise = new $.Deferred();\n\n        // Try to load the package.json to figure out if we are loading a theme.\n        ExtensionUtils.loadMetadata(config.baseUrl, name).always(promise.resolve);\n\n        return promise\n            .then(function (metadata) {\n                // No special handling for themes... Let the promise propagate into the ExtensionManager\n                if (metadata && metadata.theme) {\n                    return;\n                }\n\n                if (!metadata.disabled) {\n                    return loadExtensionModule(name, config, entryPoint);\n                }\n                return new $.Deferred().reject(\"disabled\").promise();\n\n            })\n            .then(function () {\n                exports.trigger(\"load\", config.baseUrl);\n            }, function (err) {\n                if (err === \"disabled\") {\n                    exports.trigger(\"disabled\", config.baseUrl);\n                } else {\n                    exports.trigger(\"loadFailed\", config.baseUrl);\n                }\n            });\n    }\n\n    /**\n     * Runs unit tests for the extension that lives at baseUrl into its own Require.js context\n     *\n     * @param {!string} name, used to identify the extension\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension\n     * @param {!string} entryPoint, name of the main js file to load\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function _testExtensionByURL(name, config, entryPoint) {\n        var result = new $.Deferred();\n\n        try{\n            var extensionRequire = brackets.libRequire.config({\n                context: name,\n                baseUrl: config.baseUrl,\n                paths: $.extend({}, config.paths, globalPaths),\n                waitSeconds: EXTENSION_LOAD_TIMOUT_SECONDS\n            });\n\n            extensionRequire([entryPoint], function () {\n                console.log(\"Test extension loaded: \", name);\n                result.resolve();\n            }, function (err) {\n                // Something went wrong while loading extension\n                console.log(\"Unit tests not found for:\", name, err);\n                result.reject();\n            });\n        } catch (e) {\n            console.error(\"Test extension load failed: \", name, e);\n            result.resolve();\n        }\n\n        return result.promise();\n    }\n\n    /**\n     * Runs unit tests for the extension that lives at baseUrl into its own Require.js context\n     *\n     * @param {!string} name, used to identify the extension\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension\n     * @param {!string} entryPoint, name of the main js file to load\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function testExtension(name, config, entryPoint) {\n        var result = new $.Deferred(),\n            extensionPath = config.baseUrl + \"/\" + entryPoint + \".js\";\n        if(extensionPath.startsWith(\"http://\") || extensionPath.startsWith(\"https://\")) {\n            return _testExtensionByURL(name, config, entryPoint);\n        }\n\n        FileSystem.resolve(extensionPath, function (err, entry) {\n            if (!err && entry.isFile) {\n                // unit test file exists\n                var extensionRequire = brackets.libRequire.config({\n                    context: name,\n                    baseUrl: config.baseUrl,\n                    paths: $.extend({}, config.paths, globalPaths)\n                });\n\n                extensionRequire([entryPoint], function () {\n                    result.resolve();\n                });\n            } else {\n                result.reject();\n            }\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * @private\n     * Loads a file entryPoint from each extension folder within the baseUrl into its own Require.js context\n     *\n     * @param {!string} directory, an absolute native path that contains a directory of extensions.\n     *                  each subdirectory is interpreted as an independent extension\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension folder\n     * @param {!string} entryPoint Module name to load (without .js suffix)\n     * @param {function} processExtension\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function _loadAll(directory, config, entryPoint, processExtension) {\n        var result = new $.Deferred();\n\n        FileSystem.getDirectoryForPath(directory).getContents(function (err, contents) {\n            if (!err) {\n                var i,\n                    extensions = [];\n\n                for (i = 0; i < contents.length; i++) {\n                    if (contents[i].isDirectory) {\n                        // FUTURE (JRB): read package.json instead of just using the entrypoint \"main\".\n                        // Also, load sub-extensions defined in package.json.\n                        extensions.push(contents[i].name);\n                    }\n                }\n\n                if (extensions.length === 0) {\n                    result.resolve();\n                    return;\n                }\n\n                Async.doInParallel(extensions, function (item) {\n                    var extConfig = {\n                        // we load extensions in virtual file system from our virtual server URL\n                        baseUrl: window.fsServerUrl + config.baseUrl + \"/\" + item,\n                        paths: config.paths\n                    };\n                    console.log(\"Loading Extension from virtual fs: \", extConfig);\n                    return processExtension(item, extConfig, entryPoint);\n                }).always(function () {\n                    // Always resolve the promise even if some extensions had errors\n                    result.resolve();\n                });\n            } else {\n                console.error(\"[Extension] Error -- could not read native directory: \" + directory);\n                result.reject();\n            }\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Loads All brackets default extensions from brackets base https URL.\n     *\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function loadAllDefaultExtensions() {\n        const extensionPath = getDefaultExtensionPath();\n        const href = window.location.href;\n        const baseUrl = href.substring(0, href.lastIndexOf(\"/\"));\n        const extensionsToLoadURL = baseUrl + extensionPath + \"/DefaultExtensions.json\";\n        var result = new $.Deferred();\n\n        $.get(extensionsToLoadURL).done(function (extensionNames) {\n            Async.doInParallel(extensionNames, function (extensionName) {\n                logger.leaveTrail(\"loading default extension: \" + extensionName);\n                var extConfig = {\n                    baseUrl: baseUrl + extensionPath + \"/\" + extensionName\n                };\n                return loadExtension(extensionName, extConfig, 'main');\n            }).always(function () {\n                // Always resolve the promise even if some extensions had errors\n                result.resolve();\n            });\n\n        })\n            .fail(function (err) {\n                console.error(\"[Extension] Error -- could not read default extension list from\" + extensionsToLoadURL);\n                result.reject();\n            });\n\n        return result.promise();\n\n    }\n\n    /**\n     * Loads the extension that lives at baseUrl into its own Require.js context\n     *\n     * @param {!string} directory, an absolute native path that contains a directory of extensions.\n     *                  each subdirectory is interpreted as an independent extension\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function loadAllExtensionsInNativeDirectory(directory) {\n        return _loadAll(directory, {baseUrl: directory}, \"main\", loadExtension);\n    }\n\n    /**\n     * Runs unit test for the extension that lives at baseUrl into its own Require.js context\n     *\n     * @param {!string} directory, an absolute native path that contains a directory of extensions.\n     *                  each subdirectory is interpreted as an independent extension\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function testAllExtensionsInNativeDirectory(directory) {\n        var result = new $.Deferred();\n        var virtualServerURL = window.fsServerUrl,\n            extensionsDir = _getExtensionPath() + \"/\" + directory,\n            config = {\n                baseUrl: virtualServerURL + extensionsDir\n            };\n\n        config.paths = {\n            \"perf\": virtualServerURL + \"/test/perf\",\n            \"spec\": virtualServerURL + \"/test/spec\"\n        };\n\n        FileSystem.getDirectoryForPath(extensionsDir).getContents(function (err, contents) {\n            if (!err) {\n                var i,\n                    extensions = [];\n\n                for (i = 0; i < contents.length; i++) {\n                    if (contents[i].isDirectory) {\n                        // FUTURE (JRB): read package.json instead of just using the entrypoint \"main\".\n                        // Also, load sub-extensions defined in package.json.\n                        extensions.push(contents[i].name);\n                    }\n                }\n\n                if (extensions.length === 0) {\n                    result.resolve();\n                    return;\n                }\n\n                Async.doInParallel(extensions, function (extensionName) {\n                    let loadResult = new $.Deferred();\n                    var extConfig = {\n                        // we load extensions in virtual file system from our virtual server URL\n                        basePath: 'extensions/default',\n                        baseUrl: config.baseUrl + \"/\" + extensionName,\n                        paths: config.paths\n                    };\n                    console.log(\"Loading Extension Test from virtual fs: \", extConfig);\n                    _testExtensionByURL(extensionName, extConfig, 'unittests').always(function () {\n                        // Always resolve the promise even if some extensions had errors\n                        console.log(\"lc\", extensionName);\n                        loadResult.resolve();\n                    });\n                    return loadResult.promise();\n                }).always(function () {\n                    // Always resolve the promise even if some extensions had errors\n                    result.resolve();\n                });\n            } else {\n                console.error(\"[Extension Load Test] Error -- could not read native directory: \" + directory);\n                result.reject();\n            }\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Runs unit test for the extension that lives at baseUrl into its own Require.js context\n     *\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function testAllDefaultExtensions() {\n        const extensionPath = getDefaultExtensionPath();\n        const bracketsPath = FileUtils.getNativeBracketsDirectoryPath();\n        const href = window.location.href;\n        const baseUrl = href.substring(0, href.lastIndexOf(\"/\"));\n        const srcBaseUrl = new URL(baseUrl + '/../src').href;\n        const extensionsToLoadURL = srcBaseUrl + extensionPath + \"/DefaultExtensions.json\";\n        var result = new $.Deferred();\n\n        $.get(extensionsToLoadURL).done(function (extensionNames) {\n            for (let extensionName of extensionNames){\n                console.log(\"Testing default extension: \", extensionName);\n                var extConfig = {\n                    basePath: 'extensions/default',\n                    baseUrl: new URL(srcBaseUrl + extensionPath + \"/\" + extensionName).href,\n                    paths: {\n                        \"perf\": bracketsPath + \"/perf\",\n                        \"spec\": bracketsPath + \"/spec\"\n                    }\n                };\n                _testExtensionByURL(extensionName, extConfig, 'unittests');\n            }\n            result.resolve();\n        })\n            .fail(function (err) {\n                console.error(\"[Extension Load Test] Error -- could not read default extension list from\"\n                    + extensionsToLoadURL);\n                result.reject();\n            });\n\n        return result.promise();\n    }\n\n    /**\n     * Load extensions.\n     *\n     * @param {?Array.<string>} A list containing references to extension source\n     *      location. A source location may be either (a) a folder name inside\n     *      src/extensions or (b) an absolute path.\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\n     */\n    function init(paths) {\n        var params = new UrlParams();\n\n        if (_init) {\n            // Only init once. Return a resolved promise.\n            return new $.Deferred().resolve().promise();\n        }\n\n        if (!paths) {\n            params.parse();\n\n            if (params.get(\"reloadWithoutUserExts\") !== \"true\") {\n                paths = [\n                    getUserExtensionPath(),\n                    getDevExtensionPath(),\n                    \"default\"\n                ];\n            } else {\n                paths = [];\n            }\n        }\n\n        // Load extensions before restoring the project\n\n        // Get a Directory for the user extension directory and create it if it doesn't exist.\n        // Note that this is an async call and there are no success or failure functions passed\n        // in. If the directory *doesn't* exist, it will be created. Extension loading may happen\n        // before the directory is finished being created, but that is okay, since the extension\n        // loading will work correctly without this directory.\n        // If the directory *does* exist, nothing else needs to be done. It will be scanned normally\n        // during extension loading.\n        var extensionPath = getUserExtensionPath();\n        FileSystem.getDirectoryForPath(extensionPath).create();\n        FileSystem.getDirectoryForPath(getDevExtensionPath()).create();\n\n        // Create the extensions/disabled directory, too.\n        var disabledExtensionPath = extensionPath.replace(/\\/user$/, \"/disabled\");\n        FileSystem.getDirectoryForPath(disabledExtensionPath).create();\n\n        var promise = Async.doInParallel(paths, function (extPath) {\n            if(extPath === \"default\"){\n                return loadAllDefaultExtensions();\n            } else {\n                return loadAllExtensionsInNativeDirectory(extPath);\n            }\n        }, false);\n\n        promise.always(function () {\n            _init = true;\n        });\n\n        return promise;\n    }\n\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // unit tests\n    exports._setInitExtensionTimeout = _setInitExtensionTimeout;\n    exports._getInitExtensionTimeout = _getInitExtensionTimeout;\n\n    // public API\n    exports.init = init;\n    exports.getDefaultExtensionPath = getDefaultExtensionPath;\n    exports.getUserExtensionPath = getUserExtensionPath;\n    exports.getRequireContextForExtension = getRequireContextForExtension;\n    exports.loadExtension = loadExtension;\n    exports.testExtension = testExtension;\n    exports.loadAllExtensionsInNativeDirectory = loadAllExtensionsInNativeDirectory;\n    exports.testAllExtensionsInNativeDirectory = testAllExtensionsInNativeDirectory;\n    exports.testAllDefaultExtensions = testAllDefaultExtensions;\n});\n"],"file":"ExtensionLoader.js"}
{"version":3,"sources":["utils/StringUtils.js"],"names":["define","require","exports","module","_","format","str","args","slice","call","arguments","replace","match","num","regexEscape","jQueryIdEscape","getLines","text","split","offsetToLineNum","textOrLines","offset","Array","isArray","lines","total","line","length","substr","startsWith","prefix","endsWith","suffix","indexOf","urlSort","a","b","a2","b2","isFile","s","lastIndexOf","brackets","platform","toLowerCase","breakableUrl","url","escUrl","escape","RegExp","prettyPrintBytes","bytes","precision","kilobyte","megabyte","gigabyte","terabyte","returnVal","toFixed","truncate","len","lastSpaceChar","hashCode","hash","i","chr","charCodeAt"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* The hash code routne is taken from http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n   @CC wiki attribution: esmiralha\n*/\n\n/*eslint no-bitwise: off */\n/*jslint bitwise: true */\n\n/**\n *  Utilities functions related to string manipulation\n *\n */\ndefine(function (require, exports, module) {\n\n\n    var _ = require(\"thirdparty/lodash\");\n\n    /**\n     * Format a string by replacing placeholder symbols with passed in arguments.\n     *\n     * Example: var formatted = StringUtils.format(\"Hello {0}\", \"World\");\n     *\n     * @param {string} str The base string\n     * @param {...} Arguments to be substituted into the string\n     *\n     * @return {string} Formatted string\n     */\n    function format(str) {\n        // arguments[0] is the base string, so we need to adjust index values here\n        var args = [].slice.call(arguments, 1);\n        return str.replace(/\\{(\\d+)\\}/g, function (match, num) {\n            return typeof args[num] !== \"undefined\" ? args[num] : match;\n        });\n    }\n\n    function regexEscape(str) {\n        return str.replace(/([.?*+\\^$\\[\\]\\\\(){}|\\-])/g, \"\\\\$1\");\n    }\n\n    // Periods (aka \"dots\") are allowed in HTML identifiers, but jQuery interprets\n    // them as the start of a class selector, so they need to be escaped\n    function jQueryIdEscape(str) {\n        return str.replace(/\\./g, \"\\\\.\");\n    }\n\n    /**\n     * Splits the text by new line characters and returns an array of lines\n     * @param {string} text\n     * @return {Array.<string>} lines\n     */\n    function getLines(text) {\n        return text.split(\"\\n\");\n    }\n\n    /**\n     * Returns a line number corresponding to an offset in some text. The text can\n     * be specified as a single string or as an array of strings that correspond to\n     * the lines of the string.\n     *\n     * Specify the text in lines when repeatedly calling the function on the same\n     * text in a loop. Use getLines() to divide the text into lines, then repeatedly call\n     * this function to compute a line number from the offset.\n     *\n     * @param {string | Array.<string>} textOrLines - string or array of lines from which\n     *      to compute the line number from the offset\n     * @param {number} offset\n     * @return {number} line number\n     */\n    function offsetToLineNum(textOrLines, offset) {\n        if (Array.isArray(textOrLines)) {\n            var lines = textOrLines,\n                total = 0,\n                line;\n            for (line = 0; line < lines.length; line++) {\n                if (total < offset) {\n                    // add 1 per line since /n were removed by splitting, but they needed to\n                    // contribute to the total offset count\n                    total += lines[line].length + 1;\n                } else if (total === offset) {\n                    return line;\n                } else {\n                    return line - 1;\n                }\n            }\n\n            // if offset is NOT over the total then offset is in the last line\n            if (offset <= total) {\n                return line - 1;\n            }\n            return undefined;\n\n        }\n        return textOrLines.substr(0, offset).split(\"\\n\").length - 1;\n\n    }\n\n    /**\n     * Returns true if the given string starts with the given prefix.\n     * @param   {String} str\n     * @param   {String} prefix\n     * @return {Boolean}\n     */\n    function startsWith(str, prefix) {\n        return str.slice(0, prefix.length) === prefix;\n    }\n\n    /**\n     * Returns true if the given string ends with the given suffix.\n     *\n     * @param {string} str\n     * @param {string} suffix\n     */\n    function endsWith(str, suffix) {\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    }\n\n    function urlSort(a, b) {\n        var a2, b2;\n        function isFile(s) {\n            return ((s.lastIndexOf(\"/\") + 1) < s.length);\n        }\n\n        if (brackets.platform === \"win\") {\n            // Windows: prepend folder names with a '0' and file names with a '1' so folders are listed first\n            a2 = ((isFile(a)) ? \"1\" : \"0\") + a.toLowerCase();\n            b2 = ((isFile(b)) ? \"1\" : \"0\") + b.toLowerCase();\n        } else {\n            a2 = a.toLowerCase();\n            b2 = b.toLowerCase();\n        }\n\n        if (a2 === b2) {\n            return 0;\n        }\n        return (a2 > b2) ? 1 : -1;\n\n    }\n\n    /**\n     * Return an escaped path or URL string that can be broken near path separators.\n     * @param {string} url the path or URL to format\n     * @return {string} the formatted path or URL\n     */\n    function breakableUrl(url) {\n        // This is for displaying in UI, so always want it escaped\n        var escUrl = _.escape(url);\n\n        // Inject zero-width space character (U+200B) near path separators (/) to allow line breaking there\n        return escUrl.replace(\n            new RegExp(regexEscape(\"/\"), \"g\"),\n            \"/\" + \"&#8203;\"\n        );\n    }\n\n    /**\n     * Converts number of bytes into human readable format.\n     * If param bytes is negative it returns the number without any changes.\n     *\n     * @param {number} bytes     Number of bytes to convert\n     * @param {number} precision Number of digits after the decimal separator\n     * @return {string}\n     */\n    function prettyPrintBytes(bytes, precision) {\n        var kilobyte = 1024,\n            megabyte = kilobyte * 1024,\n            gigabyte = megabyte * 1024,\n            terabyte = gigabyte * 1024,\n            returnVal = bytes;\n\n        if ((bytes >= 0) && (bytes < kilobyte)) {\n            returnVal = bytes + \" B\";\n        } else if (bytes < megabyte) {\n            returnVal = (bytes / kilobyte).toFixed(precision) + \" KB\";\n        } else if (bytes < gigabyte) {\n            returnVal = (bytes / megabyte).toFixed(precision) + \" MB\";\n        } else if (bytes < terabyte) {\n            returnVal = (bytes / gigabyte).toFixed(precision) + \" GB\";\n        } else if (bytes >= terabyte) {\n            return (bytes / terabyte).toFixed(precision) + \" TB\";\n        }\n\n        return returnVal;\n    }\n\n    /**\n     * Truncate text to specified length.\n     * @param {string} str Text to be truncated.\n     * @param {number} len Length to which text should be truncated\n     * @return {?string} Returns truncated text only if it was changed\n     */\n    function truncate(str, len) {\n        // Truncate text to specified length\n        if (str.length > len) {\n            str = str.substr(0, len);\n\n            // To prevent awkwardly truncating in the middle of a word,\n            // attempt to truncate at the end of the last whole word\n            var lastSpaceChar = str.lastIndexOf(\" \");\n            if (lastSpaceChar < len && lastSpaceChar > -1) {\n                str = str.substr(0, lastSpaceChar);\n            }\n            return str;\n        }\n    }\n\n    /**\n     * Computes a 32bit hash from the given string\n     * Taken from http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n     * @CC wiki attribution: esmiralha\n     * @param   {string}   str The string for which hash is to be computed\n     * @return {number} The 32-bit hash\n     */\n    function hashCode(str) {\n        var hash = 0, i, chr, len;\n        if (str.length === 0) {\n            return hash;\n        }\n        for (i = 0, len = str.length; i < len; i++) {\n            chr   = str.charCodeAt(i);\n            hash  = ((hash << 5) - hash) + chr;\n            hash |= 0; // Convert to 32bit integer\n        }\n        return hash;\n    }\n\n    // Define public API\n    exports.format              = format;\n    exports.regexEscape         = regexEscape;\n    exports.jQueryIdEscape      = jQueryIdEscape;\n    exports.getLines            = getLines;\n    exports.offsetToLineNum     = offsetToLineNum;\n    exports.urlSort             = urlSort;\n    exports.breakableUrl        = breakableUrl;\n    exports.startsWith          = startsWith;\n    exports.endsWith            = endsWith;\n    exports.prettyPrintBytes    = prettyPrintBytes;\n    exports.truncate            = truncate;\n    exports.hashCode            = hashCode;\n});\n"],"file":"StringUtils.js"}
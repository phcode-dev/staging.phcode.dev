{"version":3,"sources":["utils/NodeConnection.js"],"names":["define","require","exports","module","EventDispatcher","CONNECTION_ATTEMPTS","CONNECTION_TIMEOUT","RETRY_DELAY","MAX_COUNTER_VALUE","setDeferredTimeout","deferred","delay","timer","setTimeout","reject","always","clearTimeout","attemptSingleConnect","$","Deferred","port","ws","brackets","app","getNodeState","err","nodePort","state","WebSocket","binaryType","onclose","onopen","resolveWith","promise","NodeConnection","this","domains","_registeredModules","_pendingInterfaceRefreshDeferreds","_pendingCommandDeferreds","makeEventDispatcher","prototype","_ws","_port","_commandCount","_autoReconnect","_getNextCommandID","nextID","_cleanup","readyState","CLOSED","close","e","failedDeferreds","concat","forEach","d","connect","autoReconnect","self","attemptCount","attemptTimestamp","registerHandlersAndDomains","success","$promise","trigger","resolve","fail","onmessage","_receive","bind","_refreshInterface","then","length","loadDomains","doConnect","Date","now","Math","max","connected","OPEN","disconnect","paths","autoReload","pathArray","Array","isArray","push","apply","base","loadDomainModulesFromPaths","reason","_send","m","messageString","JSON","stringify","stringifyError","console","error","message","send","sendError","responseDeferred","data","ArrayBuffer","byteLength","header","slice","body","headerView","id","type","Uint32Array","response","parse","domain","event","triggerWithArray","parameters","notifyWith","rejectWith","stack","pendingDeferreds","refreshInterfaceCallback","spec","makeCommandFunction","domainName","commandSpec","call","arguments","command","name","domainEvents","domainSpec","commands","events","eventSpec","getJSON","done","_getConnectionTimeout"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var EventDispatcher = require(\"utils/EventDispatcher\");\n\n\n    /**\n     * Connection attempts to make before failing\n     * @type {number}\n     */\n    var CONNECTION_ATTEMPTS = 10;\n\n    /**\n     * Milliseconds to wait before a particular connection attempt is considered failed.\n     * NOTE: It's okay for the connection timeout to be long because the\n     * expected behavior of WebSockets is to send a \"close\" event as soon\n     * as they realize they can't connect. So, we should rarely hit the\n     * connection timeout even if we try to connect to a port that isn't open.\n     * @type {number}\n     */\n    var CONNECTION_TIMEOUT  = 10000; // 10 seconds\n\n    /**\n     * Milliseconds to wait before retrying connecting\n     * @type {number}\n     */\n    var RETRY_DELAY         = 500;   // 1/2 second\n\n    /**\n     * Maximum value of the command ID counter\n     * @type  {number}\n     */\n    var MAX_COUNTER_VALUE = 4294967295; // 2^32 - 1\n\n    /**\n     * @private\n     * Helper function to auto-reject a deferred after a given amount of time.\n     * If the deferred is resolved/rejected manually, then the timeout is\n     * automatically cleared.\n     */\n    function setDeferredTimeout(deferred, delay) {\n        var timer = setTimeout(function () {\n            deferred.reject(\"timeout\");\n        }, delay);\n        deferred.always(function () { clearTimeout(timer); });\n    }\n\n    /**\n     * @private\n     * Helper function to attempt a single connection to the node server\n     */\n    function attemptSingleConnect() {\n        var deferred = $.Deferred();\n        var port = null;\n        var ws = null;\n        setDeferredTimeout(deferred, CONNECTION_TIMEOUT);\n\n        brackets.app.getNodeState(function (err, nodePort) {\n            if (!err && nodePort && deferred.state() !== \"rejected\") {\n                port = nodePort;\n                ws = new WebSocket(\"ws://localhost:\" + port);\n\n                // Expect ArrayBuffer objects from Node when receiving binary\n                // data instead of DOM Blobs, which are the default.\n                ws.binaryType = \"arraybuffer\";\n\n                // If the server port isn't open, we get a close event\n                // at some point in the future (and will not get an onopen\n                // event)\n                ws.onclose = function () {\n                    deferred.reject(\"WebSocket closed\");\n                };\n\n                ws.onopen = function () {\n                    // If we successfully opened, remove the old onclose\n                    // handler (which was present to detect failure to\n                    // connect at all).\n                    ws.onclose = null;\n                    deferred.resolveWith(null, [ws, port]);\n                };\n            } else {\n                deferred.reject(\"brackets.app.getNodeState error: \" + err);\n            }\n        });\n\n        return deferred.promise();\n    }\n\n    /**\n     * Provides an interface for interacting with the node server.\n     * @constructor\n     */\n    function NodeConnection() {\n        this.domains = {};\n        this._registeredModules = [];\n        this._pendingInterfaceRefreshDeferreds = [];\n        this._pendingCommandDeferreds = [];\n    }\n    EventDispatcher.makeEventDispatcher(NodeConnection.prototype);\n\n    /**\n     * @type {Object}\n     * Exposes the domains registered with the server. This object will\n     * have a property for each registered domain. Each of those properties\n     * will be an object containing properties for all the commands in that\n     * domain. So, myConnection.base.enableDebugger would point to the function\n     * to call to enable the debugger.\n     *\n     * This object is automatically replaced every time the API changes (based\n     * on the base:newDomains event from the server). Therefore, code that\n     * uses this object should not keep their own pointer to the domain property.\n     */\n    NodeConnection.prototype.domains = null;\n\n    /**\n     * @private\n     * @type {Array.<string>}\n     * List of module pathnames that should be re-registered if there is\n     * a disconnection/connection (i.e. if the server died).\n     */\n    NodeConnection.prototype._registeredModules = null;\n\n    /**\n     * @private\n     * @type {WebSocket}\n     * The connection to the server\n     */\n    NodeConnection.prototype._ws = null;\n\n    /**\n     * @private\n     * @type {?number}\n     * The port the WebSocket is currently connected to\n     */\n    NodeConnection.prototype._port = null;\n\n    /**\n     * @private\n     * @type {number}\n     * Unique ID for commands\n     */\n    NodeConnection.prototype._commandCount = 1;\n\n    /**\n     * @private\n     * @type {boolean}\n     * Whether to attempt reconnection if connection fails\n     */\n    NodeConnection.prototype._autoReconnect = false;\n\n    /**\n     * @private\n     * @type {Array.<jQuery.Deferred>}\n     * List of deferred objects that should be resolved pending\n     * a successful refresh of the API\n     */\n    NodeConnection.prototype._pendingInterfaceRefreshDeferreds = null;\n\n    /**\n     * @private\n     * @type {Array.<jQuery.Deferred>}\n     * Array (indexed on command ID) of deferred objects that should be\n     * resolved/rejected with the response of commands.\n     */\n    NodeConnection.prototype._pendingCommandDeferreds = null;\n\n    /**\n     * @private\n     * @return {number} The next command ID to use. Always representable as an\n     * unsigned 32-bit integer.\n     */\n    NodeConnection.prototype._getNextCommandID = function () {\n        var nextID;\n\n        if (this._commandCount > MAX_COUNTER_VALUE) {\n            nextID = this._commandCount = 0;\n        } else {\n            nextID = this._commandCount++;\n        }\n\n        return nextID;\n    };\n\n    /**\n     * @private\n     * Helper function to do cleanup work when a connection fails\n     */\n    NodeConnection.prototype._cleanup = function () {\n        // clear out the domains, since we may get different ones\n        // on the next connection\n        this.domains = {};\n\n        // shut down the old connection if there is one\n        if (this._ws && this._ws.readyState !== WebSocket.CLOSED) {\n            try {\n                this._ws.close();\n            } catch (e) { }\n        }\n        var failedDeferreds = this._pendingInterfaceRefreshDeferreds\n            .concat(this._pendingCommandDeferreds);\n        failedDeferreds.forEach(function (d) {\n            d.reject(\"cleanup\");\n        });\n        this._pendingInterfaceRefreshDeferreds = [];\n        this._pendingCommandDeferreds = [];\n\n        this._ws = null;\n        this._port = null;\n    };\n\n    /**\n     * Connect to the node server. After connecting, the NodeConnection\n     * object will trigger a \"close\" event when the underlying socket\n     * is closed. If the connection is set to autoReconnect, then the\n     * event will also include a jQuery promise for the connection.\n     *\n     * @param {boolean} autoReconnect Whether to automatically try to\n     *    reconnect to the server if the connection succeeds and then\n     *    later disconnects. Note if this connection fails initially, the\n     *    autoReconnect flag is set to false. Future calls to connect()\n     *    can reset it to true\n     * @return {jQuery.Promise} Promise that resolves/rejects when the\n     *    connection succeeds/fails\n     */\n    NodeConnection.prototype.connect = function (autoReconnect) {\n        var self = this;\n        self._autoReconnect = autoReconnect;\n        var deferred = $.Deferred();\n        var attemptCount = 0;\n        var attemptTimestamp = null;\n\n        // Called after a successful connection to do final setup steps\n        function registerHandlersAndDomains(ws, port) {\n            // Called if we succeed at the final setup\n            function success() {\n                self._ws.onclose = function () {\n                    if (self._autoReconnect) {\n                        var $promise = self.connect(true);\n                        self.trigger(\"close\", $promise);\n                    } else {\n                        self._cleanup();\n                        self.trigger(\"close\");\n                    }\n                };\n                deferred.resolve();\n            }\n            // Called if we fail at the final setup\n            function fail(err) {\n                self._cleanup();\n                deferred.reject(err);\n            }\n\n            self._ws = ws;\n            self._port = port;\n            self._ws.onmessage = self._receive.bind(self);\n\n            // refresh the current domains, then re-register any\n            // \"autoregister\" modules\n            self._refreshInterface().then(\n                function () {\n                    if (self._registeredModules.length > 0) {\n                        self.loadDomains(self._registeredModules, false).then(\n                            success,\n                            fail\n                        );\n                    } else {\n                        success();\n                    }\n                },\n                fail\n            );\n        }\n\n        // Repeatedly tries to connect until we succeed or until we've\n        // failed CONNECTION_ATTEMPT times. After each attempt, waits\n        // at least RETRY_DELAY before trying again.\n        function doConnect() {\n            attemptCount++;\n            attemptTimestamp = new Date();\n            attemptSingleConnect().then(\n                registerHandlersAndDomains, // succeded\n                function () { // failed this attempt, possibly try again\n                    if (attemptCount < CONNECTION_ATTEMPTS) { //try again\n                        // Calculate how long we should wait before trying again\n                        var now = new Date();\n                        var delay = Math.max(\n                            RETRY_DELAY - (now - attemptTimestamp),\n                            1\n                        );\n                        setTimeout(doConnect, delay);\n                    } else { // too many attempts, give up\n                        deferred.reject(\"Max connection attempts reached\");\n                    }\n                }\n            );\n        }\n\n        // Start the connection process\n        self._cleanup();\n        doConnect();\n\n        return deferred.promise();\n    };\n\n    /**\n     * Determines whether the NodeConnection is currently connected\n     * @return {boolean} Whether the NodeConnection is connected.\n     */\n    NodeConnection.prototype.connected = function () {\n        return !!(this._ws && this._ws.readyState === WebSocket.OPEN);\n    };\n\n    /**\n     * Explicitly disconnects from the server. Note that even if\n     * autoReconnect was set to true at connection time, the connection\n     * will not reconnect after this call. Reconnection can be manually done\n     * by calling connect() again.\n     */\n    NodeConnection.prototype.disconnect = function () {\n        this._autoReconnect = false;\n        this._cleanup();\n    };\n\n    /**\n     * Load domains into the server by path\n     * @param {Array.<string>} List of absolute paths to load\n     * @param {boolean} autoReload Whether to auto-reload the domains if the server\n     *    fails and restarts. Note that the reload is initiated by the\n     *    client, so it will only happen after the client reconnects.\n     * @return {jQuery.Promise} Promise that resolves after the load has\n     *    succeeded and the new API is availale at NodeConnection.domains,\n     *    or that rejects on failure.\n     */\n    NodeConnection.prototype.loadDomains = function (paths, autoReload) {\n        var deferred = $.Deferred();\n        setDeferredTimeout(deferred, CONNECTION_TIMEOUT);\n        var pathArray = paths;\n        if (!Array.isArray(paths)) {\n            pathArray = [paths];\n        }\n\n        if (autoReload) {\n            Array.prototype.push.apply(this._registeredModules, pathArray);\n        }\n\n        if (this.domains.base && this.domains.base.loadDomainModulesFromPaths) {\n            this.domains.base.loadDomainModulesFromPaths(pathArray).then(\n                function (success) { // command call succeeded\n                    if (!success) {\n                        // response from commmand call was \"false\" so we know\n                        // the actual load failed.\n                        deferred.reject(\"loadDomainModulesFromPaths failed\");\n                    }\n                    // if the load succeeded, we wait for the API refresh to\n                    // resolve the deferred.\n                },\n                function (reason) { // command call failed\n                    deferred.reject(\"Unable to load one of the modules: \" + pathArray + (reason ? \", reason: \" + reason : \"\"));\n                }\n            );\n\n            this._pendingInterfaceRefreshDeferreds.push(deferred);\n        } else {\n            deferred.reject(\"this.domains.base is undefined\");\n        }\n\n        return deferred.promise();\n    };\n\n    /**\n     * @private\n     * Sends a message over the WebSocket. Automatically JSON.stringifys\n     * the message if necessary.\n     * @param {Object|string} m Object to send. Must be JSON.stringify-able.\n     */\n    NodeConnection.prototype._send = function (m) {\n        if (this.connected()) {\n\n            // Convert the message to a string\n            var messageString = null;\n            if (typeof m === \"string\") {\n                messageString = m;\n            } else {\n                try {\n                    messageString = JSON.stringify(m);\n                } catch (stringifyError) {\n                    console.error(\"[NodeConnection] Unable to stringify message in order to send: \" + stringifyError.message);\n                }\n            }\n\n            // If we succeded in making a string, try to send it\n            if (messageString) {\n                try {\n                    this._ws.send(messageString);\n                } catch (sendError) {\n                    console.error(\"[NodeConnection] Error sending message: \" + sendError.message);\n                }\n            }\n        } else {\n            console.error(\"[NodeConnection] Not connected to node, unable to send.\");\n        }\n    };\n\n    /**\n     * @private\n     * Handler for receiving events on the WebSocket. Parses the message\n     * and dispatches it appropriately.\n     * @param {WebSocket.Message} message Message object from WebSocket\n     */\n    NodeConnection.prototype._receive = function (message) {\n        var responseDeferred = null;\n        var data = message.data;\n        var m;\n\n        if (message.data instanceof ArrayBuffer) {\n            // The first four bytes encode the command ID as an unsigned 32-bit integer\n            if (data.byteLength < 4) {\n                console.error(\"[NodeConnection] received malformed binary message\");\n                return;\n            }\n\n            var header = data.slice(0, 4),\n                body = data.slice(4),\n                headerView = new Uint32Array(header),\n                id = headerView[0];\n\n            // Unpack the binary message into a commandResponse\n            m = {\n                type: \"commandResponse\",\n                message: {\n                    id: id,\n                    response: body\n                }\n            };\n        } else {\n            try {\n                m = JSON.parse(data);\n            } catch (e) {\n                console.error(\"[NodeConnection] received malformed message\", message, e.message);\n                return;\n            }\n        }\n\n        switch (m.type) {\n        case \"event\":\n            if (m.message.domain === \"base\" && m.message.event === \"newDomains\") {\n                this._refreshInterface();\n            }\n\n            // Event type \"domain:event\"\n            EventDispatcher.triggerWithArray(this, m.message.domain + \":\" + m.message.event,\n                                             m.message.parameters);\n            break;\n        case \"commandResponse\":\n            responseDeferred = this._pendingCommandDeferreds[m.message.id];\n            if (responseDeferred) {\n                responseDeferred.resolveWith(this, [m.message.response]);\n                delete this._pendingCommandDeferreds[m.message.id];\n            }\n            break;\n        case \"commandProgress\":\n            responseDeferred = this._pendingCommandDeferreds[m.message.id];\n            if (responseDeferred) {\n                responseDeferred.notifyWith(this, [m.message.message]);\n            }\n            break;\n        case \"commandError\":\n            responseDeferred = this._pendingCommandDeferreds[m.message.id];\n            if (responseDeferred) {\n                responseDeferred.rejectWith(\n                    this,\n                    [m.message.message, m.message.stack]\n                );\n                delete this._pendingCommandDeferreds[m.message.id];\n            }\n            break;\n        case \"error\":\n            console.error(\"[NodeConnection] received error: \" +\n                            m.message.message);\n            break;\n        default:\n            console.error(\"[NodeConnection] unknown event type: \" + m.type);\n        }\n    };\n\n    /**\n     * @private\n     * Helper function for refreshing the interface in the \"domain\" property.\n     * Automatically called when the connection receives a base:newDomains\n     * event from the server, and also called at connection time.\n     */\n    NodeConnection.prototype._refreshInterface = function () {\n        var deferred = $.Deferred();\n        var self = this;\n\n        var pendingDeferreds = this._pendingInterfaceRefreshDeferreds;\n        this._pendingInterfaceRefreshDeferreds = [];\n        deferred.then(\n            function () {\n                pendingDeferreds.forEach(function (d) { d.resolve(); });\n            },\n            function (err) {\n                pendingDeferreds.forEach(function (d) { d.reject(err); });\n            }\n        );\n\n        function refreshInterfaceCallback(spec) {\n            function makeCommandFunction(domainName, commandSpec) {\n                return function () {\n                    var deferred = $.Deferred();\n                    var parameters = Array.prototype.slice.call(arguments, 0);\n                    var id = self._getNextCommandID();\n                    self._pendingCommandDeferreds[id] = deferred;\n                    self._send({id: id,\n                        domain: domainName,\n                        command: commandSpec.name,\n                        parameters: parameters\n                    });\n                    return deferred;\n                };\n            }\n\n            // TODO: Don't replace the domain object every time. Instead, merge.\n            self.domains = {};\n            self.domainEvents = {};\n            spec.forEach(function (domainSpec) {\n                self.domains[domainSpec.domain] = {};\n                domainSpec.commands.forEach(function (commandSpec) {\n                    self.domains[domainSpec.domain][commandSpec.name] =\n                        makeCommandFunction(domainSpec.domain, commandSpec);\n                });\n                self.domainEvents[domainSpec.domain] = {};\n                domainSpec.events.forEach(function (eventSpec) {\n                    var parameters = eventSpec.parameters;\n                    self.domainEvents[domainSpec.domain][eventSpec.name] = parameters;\n                });\n            });\n            deferred.resolve();\n        }\n\n        if (this.connected()) {\n            $.getJSON(\"http://localhost:\" + this._port + \"/api\")\n                .done(refreshInterfaceCallback)\n                .fail(function (err) { deferred.reject(err); });\n        } else {\n            deferred.reject(\"Attempted to call _refreshInterface when not connected.\");\n        }\n\n        return deferred.promise();\n    };\n\n    /**\n     * @private\n     * Get the default timeout value\n     * @return {number} Timeout value in milliseconds\n     */\n    NodeConnection._getConnectionTimeout = function () {\n        return CONNECTION_TIMEOUT;\n    };\n\n    module.exports = NodeConnection;\n\n});\n"],"file":"NodeConnection.js"}
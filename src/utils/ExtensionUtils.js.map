{"version":3,"sources":["utils/ExtensionUtils.js"],"names":["define","require","exports","module","Async","FileSystem","FileUtils","PathUtils","PreferencesManager","addEmbeddedStyleSheet","css","$","text","appendTo","addLinkedStyleSheet","url","deferred","attributes","type","rel","href","$link","attr","on","resolve","reject","isAbsolutePathOrUrl","pathOrUrl","brackets","platform","isAbsoluteUrl","isAbsolutePath","parseLessCode","code","result","Deferred","options","dir","slice","lastIndexOf","filename","rootpath","currentFileInfo","currentDirectory","entryPath","rootFilename","less","render","onParse","err","tree","promise","getModulePath","path","modulePath","uri","substr","getModuleUrl","encodeURI","loadFile","get","done","content","fail","loadStyleSheet","URL","this","link","error","textStatus","httpError","undefined","readyState","console","_loadLocalMetadata","folder","packageJSONFile","getFileForPath","disabledFile","baseName","getBaseName","jsonPromise","disabledPromise","json","disabled","readAsText","then","JSON","parse","e","exists","defaultDisabled","Array","isArray","indexOf","warn","waitForAll","always","name","_loadDefaultExtensionMetadata","baseExtensionUrl","extensionName","loadMetadata","startsWith"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global less */\n// jshint ignore: start\n\n/**\n * ExtensionUtils defines utility methods for implementing extensions.\n */\ndefine(function (require, exports, module) {\n\n\n    var Async              = require(\"utils/Async\"),\n        FileSystem         = require(\"filesystem/FileSystem\"),\n        FileUtils          = require(\"file/FileUtils\"),\n        PathUtils          = require(\"thirdparty/path-utils/path-utils\"),\n        PreferencesManager = require(\"preferences/PreferencesManager\");\n\n    /**\n     * Appends a <style> tag to the document's head.\n     *\n     * @param {!string} css CSS code to use as the tag's content\n     * @return {!HTMLStyleElement} The generated HTML node\n     **/\n    function addEmbeddedStyleSheet(css) {\n        return $(\"<style>\").text(css).appendTo(\"head\")[0];\n    }\n\n    /**\n     * Appends a <link> tag to the document's head.\n     *\n     * @param {!string} url URL to a style sheet\n     * @param {$.Deferred=} deferred Optionally check for load and error events\n     * @return {!HTMLLinkElement} The generated HTML node\n     **/\n    function addLinkedStyleSheet(url, deferred) {\n        var attributes = {\n            type: \"text/css\",\n            rel: \"stylesheet\",\n            href: url\n        };\n\n        var $link = $(\"<link/>\").attr(attributes);\n\n        if (deferred) {\n            $link.on('load', deferred.resolve).on('error', deferred.reject);\n        }\n\n        $link.appendTo(\"head\");\n\n        return $link[0];\n    }\n\n    /**\n     * getModuleUrl returns different urls for win platform\n     * so that's why we need a different check here\n     * @see #getModuleUrl\n     * @param {!string} pathOrUrl that should be checked if it's absolute\n     * @return {!boolean} returns true if pathOrUrl is absolute url on win platform\n     *                    or when it's absolute path on other platforms\n     */\n    function isAbsolutePathOrUrl(pathOrUrl) {\n        return brackets.platform === \"win\" ? PathUtils.isAbsoluteUrl(pathOrUrl) : FileSystem.isAbsolutePath(pathOrUrl);\n    }\n\n    /**\n     * Parses LESS code and returns a promise that resolves with plain CSS code.\n     *\n     * Pass the {@link url} argument to resolve relative URLs contained in the code.\n     * Make sure URLs in the code are wrapped in quotes, like so:\n     *     background-image: url(\"image.png\");\n     *\n     * @param {!string} code LESS code to parse\n     * @param {?string} url URL to the file containing the code\n     * @return {!$.Promise} A promise object that is resolved with CSS code if the LESS code can be parsed\n     */\n    function parseLessCode(code, url) {\n        var result = new $.Deferred(),\n            options;\n\n        if (url) {\n            var dir = url.slice(0, url.lastIndexOf(\"/\") + 1);\n\n            options = {\n                filename: url,\n                rootpath: dir\n            };\n\n            if (isAbsolutePathOrUrl(url)) {\n                options.currentFileInfo = {\n                    currentDirectory: dir,\n                    entryPath: dir,\n                    filename: url,\n                    rootFilename: url,\n                    rootpath: dir\n                };\n            }\n        }\n\n        less.render(code, options, function onParse(err, tree) {\n            if (err) {\n                result.reject(err);\n            } else {\n                result.resolve(tree.css);\n            }\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Returns a path to an extension module.\n     *\n     * @param {!module} module Module provided by RequireJS\n     * @param {?string} path Relative path from the extension folder to a file\n     * @return {!string} The path to the module's folder\n     **/\n    function getModulePath(module, path) {\n        var modulePath = module.uri.substr(0, module.uri.lastIndexOf(\"/\") + 1);\n        if (path) {\n            modulePath += path;\n        }\n\n        return modulePath;\n    }\n\n    /**\n     * Returns a URL to an extension module.\n     *\n     * @param {!module} module Module provided by RequireJS\n     * @param {?string} path Relative path from the extension folder to a file\n     * @return {!string} The URL to the module's folder\n     **/\n    function getModuleUrl(module, path) {\n        return encodeURI(getModulePath(module, path));\n    }\n\n    /**\n     * Performs a GET request using a path relative to an extension module.\n     *\n     * The resulting URL can be retrieved in the resolve callback by accessing\n     *\n     * @param {!module} module Module provided by RequireJS\n     * @param {!string} path Relative path from the extension folder to a file\n     * @return {!$.Promise} A promise object that is resolved with the contents of the requested file\n     **/\n    function loadFile(module, path) {\n        var url     = PathUtils.isAbsoluteUrl(path) ? path : getModuleUrl(module, path);\n        let result = new $.Deferred();\n\n        $.get(url)\n            .done(function (content) {\n                result.resolve(content, url);\n            })\n            .fail(result.reject);\n\n        return result;\n    }\n\n    /**\n     * Loads a style sheet (CSS or LESS) relative to the extension module.\n     *\n     * @param {!module} module Module provided by RequireJS\n     * @param {!string} path Relative path from the extension folder to a CSS or LESS file\n     * @return {!$.Promise} A promise object that is resolved with an HTML node if the file can be loaded.\n     */\n    function loadStyleSheet(module, path) {\n        var result = new $.Deferred();\n\n        loadFile(module, path)\n            .done(function (content, URL) {\n                var url = URL || this.url;\n\n                if (url.slice(-5) === \".less\") {\n                    parseLessCode(content, url)\n                        .done(function (css) {\n                            result.resolve(addEmbeddedStyleSheet(css));\n                        })\n                        .fail(result.reject);\n                } else {\n                    // fix css load\n                    var deferred = new $.Deferred(),\n                        link = addLinkedStyleSheet(url, deferred);\n\n                    deferred\n                        .done(function () {\n                            result.resolve(link);\n                        })\n                        .fail(result.reject);\n                }\n            })\n            .fail(result.reject);\n\n        // Summarize error info to console for easier debugging\n        result.fail(function (error, textStatus, httpError) {\n            if (error.readyState !== undefined) {\n                // If first arg is a jQXHR object, the real error info is in the next two args\n                console.error(\"[Extension] Unable to read stylesheet \" + path + \":\", textStatus, httpError);\n            } else {\n                console.error(\"[Extension] Unable to process stylesheet \" + path, error);\n            }\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Loads the package.json file in the given extension folder as well as any additional\n     * metadata.\n     *\n     * If there's a .disabled file in the extension directory, then the content of package.json\n     * will be augmented with disabled property set to true. It will override whatever value of\n     * disabled might be set.\n     *\n     * @param {string} folder The extension folder.\n     * @return {$.Promise} A promise object that is resolved with the parsed contents of the package.json file,\n     *     or rejected if there is no package.json with the boolean indicating whether .disabled file exists.\n     */\n    function _loadLocalMetadata(folder) {\n        var packageJSONFile = FileSystem.getFileForPath(folder + \"/package.json\"),\n            disabledFile = FileSystem.getFileForPath(folder + \"/.disabled\"),\n            baseName = FileUtils.getBaseName(folder),\n            result = new $.Deferred(),\n            jsonPromise = new $.Deferred(),\n            disabledPromise = new $.Deferred(),\n            json,\n            disabled;\n        FileUtils.readAsText(packageJSONFile)\n            .then(function (text) {\n                try {\n                    json = JSON.parse(text);\n                    jsonPromise.resolve();\n                } catch (e) {\n                    jsonPromise.reject();\n                }\n            })\n            .fail(jsonPromise.reject);\n        disabledFile.exists(function (err, exists) {\n            if (err) {\n                disabled = false;\n            } else {\n                disabled = exists;\n            }\n\n            var defaultDisabled = PreferencesManager.get(\"extensions.default.disabled\");\n            if (Array.isArray(defaultDisabled) && defaultDisabled.indexOf(folder) !== -1) {\n                console.warn(\"Default extension has been disabled on startup: \" + baseName);\n                disabled = true;\n            }\n\n            disabledPromise.resolve();\n        });\n        Async.waitForAll([jsonPromise, disabledPromise])\n            .always(function () {\n                if (!json) {\n                    // if we don't have any metadata for the extension\n                    // we should still create an empty one, so we can attach\n                    // disabled property on it in case it's disabled\n                    json = {\n                        name: baseName\n                    };\n                }\n                json.disabled = disabled;\n                result.resolve(json);\n            });\n        return result.promise();\n    }\n    /**\n     * Loads the package.json file in the given extension folder as well as any additional\n     * metadata.\n     *\n     * @param {string} baseExtensionUrl The extension folder.\n     * @param {?string} extensionName optional extension name\n     * @return {$.Promise} A promise object that is resolved with the parsed contents of the package.json file,\n     *     or rejected if there is no package.json with the boolean indicating whether .disabled file exists.\n     */\n    function _loadDefaultExtensionMetadata(baseExtensionUrl, extensionName) {\n        var packageJSONFile = baseExtensionUrl + \"/package.json\";\n        var result = new $.Deferred();\n        var json = {\n            name: extensionName\n        };\n        $.get(packageJSONFile)\n            .then(function (result) {\n                json = result;\n            }).always(function () {\n            // if we don't have any metadata for the extension\n            // we should still create an empty one, so we can attach\n            // disabled property on it in case it's disabled\n            var disabled;\n            var defaultDisabled = PreferencesManager.get(\"extensions.default.disabled\");\n            if (Array.isArray(defaultDisabled) && defaultDisabled.indexOf(extensionName) !== -1) {\n                console.warn(\"Default extension has been disabled on startup: \" + baseExtensionUrl);\n                disabled = true;\n            }\n            json.disabled = disabled;\n            result.resolve(json);\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * Loads the package.json file in the given extension folder as well as any additional\n     * metadata for default extensions in the source directory.\n     *\n     * If there's a .disabled file in the extension directory, then the content of package.json\n     * will be augmented with disabled property set to true. It will override whatever value of\n     * disabled might be set.\n     *\n     * @param {string} folder The extension folder/base url for default extensions.\n     * @return {$.Promise} A promise object that is resolved with the parsed contents of the package.json file,\n     *     or rejected if there is no package.json with the boolean indicating whether .disabled file exists.\n     */\n    function loadMetadata(folder, extensionName) {\n        if(folder.startsWith(\"http://\") || folder.startsWith(\"https://\")) {\n            return _loadDefaultExtensionMetadata(folder, extensionName);\n        }\n        return _loadLocalMetadata(folder);\n    }\n\n\n\n    exports.addEmbeddedStyleSheet = addEmbeddedStyleSheet;\n    exports.addLinkedStyleSheet   = addLinkedStyleSheet;\n    exports.parseLessCode         = parseLessCode;\n    exports.getModulePath         = getModulePath;\n    exports.getModuleUrl          = getModuleUrl;\n    exports.loadFile              = loadFile;\n    exports.loadStyleSheet        = loadStyleSheet;\n    exports.loadMetadata          = loadMetadata;\n});\n"],"file":"ExtensionUtils.js"}
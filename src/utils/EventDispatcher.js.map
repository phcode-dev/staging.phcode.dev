{"version":3,"sources":["utils/EventDispatcher.js"],"names":["globalObject","window","self","global","EventDispatcher","LEAK_WARNING_THRESHOLD","eventSpecificThreshold","splitNs","eventStr","dot","indexOf","eventName","substring","ns","setLeakThresholdForEvent","threshold","currentThreshold","on","events","fn","eventsList","split","map","i","Error","this","_deprecatedEvents","length","deprecation","message","console","warn","stack","_eventHandlers","handler","push","leakThreshold","error","off","removeAllMatches","eventRec","handlerList","k","_eventOnceWrapper","splice","bind","doRemove","one","event","target","type","apply","arguments","trigger","slice","applyArgs","Array","prototype","call","unshift","err","String","makeEventDispatcher","obj","_EventDispatcher","triggerWithArray","dispatcher","argsArray","triggerArgs","concat","on_duringInit","futureDispatcher","markDeprecated","insteadStr","define","require","exports","module"],"mappings":"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","sourcesContent":["/*\n *  Copyright (c) 2021 - present core.ai . All rights reserved.\n *  Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * Implements a jQuery-like event dispatch pattern for non-DOM objects (works in web workers as well):\n *  - Listeners are attached via on()/one() & detached via off()\n *  - Listeners can use namespaces for easy removal\n *  - Listeners can attach to multiple events at once via a space-separated list\n *  - Events are fired via trigger()\n *  - The same listener can be attached twice, and will be called twice; but off() will detach all\n *    duplicate copies at once ('duplicate' means '===' equality - see http://jsfiddle.net/bf4p29g5/1/)\n *\n * But it has some important differences from jQuery's non-DOM event mechanism:\n *  - More robust to listeners that throw exceptions (other listeners will still be called, and\n *    trigger() will still return control to its caller).\n *  - Events can be marked deprecated, causing on() to issue warnings\n *  - Easier to debug, since the dispatch code is much simpler\n *  - Faster, for the same reason\n *  - Uses less memory, since $(nonDOMObj).on() leaks memory in jQuery\n *  - API is simplified:\n *      - Event handlers do not have 'this' set to the event dispatcher object\n *      - Event object passed to handlers only has 'type' and 'target' fields\n *      - trigger() uses a simpler argument-list signature (like Promise APIs), rather than requiring\n *        an Array arg and ignoring additional args\n *      - trigger() does not support namespaces\n *      - For simplicity, on() does not accept a map of multiple events -> multiple handlers, nor a\n *        missing arg standing in for a bare 'return false' handler.\n *\n * For now, Brackets uses a jQuery patch to ensure $(obj).on() and obj.on() (etc.) are identical\n * for any obj that has the EventDispatcher pattern. In the future, this may be deprecated.\n *\n * To add EventDispatcher methods to any object, call EventDispatcher.makeEventDispatcher(obj).\n *\n * ## Usage\n * ### Importing from an extension\n * ```js\n * const EventDispatcher = brackets.getModule(\"utils/EventDispatcher\");\n * ```\n * ### Using the global object\n * The EventDispatcher Object is available within the global context, be it phoenix or phoenix core web workers.\n * ```js\n * window.EventDispatcher.trigger(\"someEvent\"); // within phoenix\n * self.EventDispatcher.trigger(\"someEvent\"); // within web worker\n * ```\n *\n * If you wish to import event dispatcher to your custom web worker, use the following\n * ```js\n * importScripts('<relative path from your extension>/utils/EventDispatcher');\n * // this will add the global EventDispatcher to your web-worker. Note that the EventDispatcher in the web worker\n * // is a separate domain and cannot raise or listen to events in phoenix/other workers\n * self.EventDispatcher.trigger(\"someEvent\"); // within web worker\n * ```\n * ### Sample Usage within extension\n * ```js\n * // in your extension js file.\n * define(function (require, exports, module) {\n *     const EventDispatcher     = brackets.getModule(\"utils/EventDispatcher\");\n *     EventDispatcher.makeEventDispatcher(exports); // This extension triggers some events\n *     let eventHandler = function (event, paramObject, paramVal) {\n *         console.log(event, paramObject, paramVal);\n *     };\n *     exports.on(\"sampleEvent\", eventHandler); // listen to our own event for demo\n *     exports.trigger(\"sampleEvent\", { // trigger a sample event. This will activate the above listener 'on' function.\n *             param: 1,\n *             param2: \"sample\"\n *     }, \"value\");\n *     // If needed, the event listener can be removed with `off`. But it is not a requirement at shutdown.\n *     exports.off(\"sampleEvent\", eventHandler);\n * }\n * ```\n *\n * @module utils/EventDispatcher\n */\n\n\n(function () {\n\n    let globalObject = {};\n    if(typeof window !== 'undefined'){\n        globalObject = window; // browser\n    } else if(typeof self !== 'undefined'){\n        globalObject = self; // web worker\n    } else if(typeof global !== 'undefined'){\n        globalObject = global; //nodejs\n    }\n\n    if(globalObject.EventDispatcher){\n        // already created\n        return;\n    }\n\n    let LEAK_WARNING_THRESHOLD = 15,\n        eventSpecificThreshold = {};\n\n\n    /**\n     * Split \"event.namespace\" string into its two parts; both parts are optional.\n     * @param {string} eventName Event name and/or trailing \".namespace\"\n     * @return {!{event:string, ns:string}} Uses \"\" for missing parts.\n     * @type {function}\n     */\n    function splitNs(eventStr) {\n        var dot = eventStr.indexOf(\".\");\n        if (dot === -1) {\n            return { eventName: eventStr };\n        }\n        return { eventName: eventStr.substring(0, dot), ns: eventStr.substring(dot) };\n\n    }\n\n    /**\n     * By default, we consider any events having more than 15 listeners to be leaky. But sometimes there may be\n     * genuine use cases where an event can have a large number of listeners. For those events, it is recommended\n     * to increase the leaky warning threshold individually with this API.\n     * @param {string} eventName\n     * @param {number} threshold - The new threshold to set. Will only be set if the new threshold is greater than\n     * the current threshold.\n     * @type {function}\n     */\n    function setLeakThresholdForEvent(eventName, threshold) {\n        let currentThreshold = eventSpecificThreshold[eventName] || LEAK_WARNING_THRESHOLD;\n        if(threshold > currentThreshold){\n            eventSpecificThreshold[eventName] = threshold;\n        }\n    }\n\n\n    // These functions are added as mixins to any object by makeEventDispatcher()\n\n    /**\n     * Adds the given handler function to 'events': a space-separated list of one or more event names, each\n     * with an optional \".namespace\" (used by off() - see below). If the handler is already listening to this\n     * event, a duplicate copy is added.\n     * @param {string} events\n     * @param {!function(!{type:string, target:!Object}, ...)} fn\n     * @type {function}\n     */\n    var on = function (events, fn) {\n        var eventsList = events.split(/\\s+/).map(splitNs),\n            i;\n\n        if (!fn) {\n            throw new Error(\"EventListener.on() called with no listener fn for event '\" + events + \"'\");\n        }\n\n        // Check for deprecation warnings\n        if (this._deprecatedEvents) {\n            for (i = 0; i < eventsList.length; i++) {\n                var deprecation = this._deprecatedEvents[eventsList[i].eventName];\n                if (deprecation) {\n                    var message = \"Registering for deprecated event '\" + eventsList[i].eventName + \"'.\";\n                    if (typeof deprecation === \"string\") {\n                        message += \" Instead, use \" + deprecation + \".\";\n                    }\n                    console.warn(message, new Error().stack);\n                }\n            }\n        }\n\n        // Attach listener for each event clause\n        for (i = 0; i < eventsList.length; i++) {\n            var eventName = eventsList[i].eventName;\n            if (!this._eventHandlers) {\n                this._eventHandlers = {};\n            }\n            if (!this._eventHandlers[eventName]) {\n                this._eventHandlers[eventName] = [];\n            }\n            eventsList[i].handler = fn;\n            this._eventHandlers[eventName].push(eventsList[i]);\n\n            // Check for suspicious number of listeners being added to one object-event pair\n            let leakThreshold = eventSpecificThreshold[eventName] || LEAK_WARNING_THRESHOLD;\n            if (this._eventHandlers[eventName].length > leakThreshold) {\n                console.error(\"Possible memory leak: \" +\n                    this._eventHandlers[eventName].length + \" '\" + eventName + \"' listeners attached to\", this);\n            }\n        }\n\n        return this;  // for chaining\n    };\n\n    /**\n     * Removes one or more handler functions based on the space-separated 'events' list. Each item in\n     * 'events' can be: bare event name, bare .namespace, or event.namespace pair. This yields a set of\n     * matching handlers. If 'fn' is omitted, all these handlers are removed. If 'fn' is provided,\n     * only handlers exactly equal to 'fn' are removed (there may still be >1, if duplicates were added).\n     * @param {string} events\n     * @param {?function(!{type:string, target:!Object}, ...)} fn\n     * @type {function}\n     */\n    var off = function (events, fn) {\n        if (!this._eventHandlers) {\n            return this;\n        }\n\n        var eventsList = events.split(/\\s+/).map(splitNs),\n            i;\n\n        var removeAllMatches = function (eventRec, eventName) {\n            var handlerList = this._eventHandlers[eventName],\n                k;\n            if (!handlerList) {\n                return;\n            }\n\n            // Walk backwards so it's easy to remove items\n            for (k = handlerList.length - 1; k >= 0; k--) {\n                // Look at ns & fn only - doRemove() has already taken care of eventName\n                if (!eventRec.ns || eventRec.ns === handlerList[k].ns) {\n                    var handler = handlerList[k].handler;\n                    if (!fn || fn === handler || fn._eventOnceWrapper === handler) {\n                        handlerList.splice(k, 1);\n                    }\n                }\n            }\n            if (!handlerList.length) {\n                delete this._eventHandlers[eventName];\n            }\n        }.bind(this);\n\n        var doRemove = function (eventRec) {\n            if (eventRec.eventName) {\n                // If arg calls out an event name, look at that handler list only\n                removeAllMatches(eventRec, eventRec.eventName);\n            } else {\n                // If arg only gives a namespace, look at handler lists for all events\n                for (let eventName in this._eventHandlers) {\n                    removeAllMatches(eventRec, eventName);\n                }\n            }\n        }.bind(this);\n\n        // Detach listener for each event clause\n        // Each clause may be: bare eventname, bare .namespace, full eventname.namespace\n        for (i = 0; i < eventsList.length; i++) {\n            doRemove(eventsList[i]);\n        }\n\n        return this;  // for chaining\n    };\n\n    /**\n     * Attaches a handler so it's only called once (per event in the 'events' list).\n     * @param {string} events\n     * @param {?function(!{type:string, target:!Object}, ...)} fn\n     * @type {function}\n     */\n    var one = function (events, fn) {\n        // Wrap fn in a self-detaching handler; saved on the original fn so off() can detect it later\n        if (!fn._eventOnceWrapper) {\n            fn._eventOnceWrapper = function (event) {\n                // Note: this wrapper is reused for all attachments of the same fn, so it shouldn't reference\n                // anything from the outer closure other than 'fn'\n                event.target.off(event.type, fn._eventOnceWrapper);\n                fn.apply(this, arguments);\n            };\n        }\n        return this.on(events, fn._eventOnceWrapper);\n    };\n\n    /**\n     * Invokes all handlers for the given event (in the order they were added).\n     * @param {string} eventName\n     * @param {*} ... Any additional args are passed to the event handler after the event object\n     * @type {function}\n     */\n    var trigger = function (eventName) {\n        var event = { type: eventName, target: this },\n            handlerList = this._eventHandlers && this._eventHandlers[eventName],\n            i;\n\n        if (!handlerList) {\n            return;\n        }\n\n        // Use a clone of the list in case handlers call on()/off() while we're still in the loop\n        handlerList = handlerList.slice();\n\n        // Pass 'event' object followed by any additional args trigger() was given\n        var applyArgs = Array.prototype.slice.call(arguments, 1);\n        applyArgs.unshift(event);\n\n        for (i = 0; i < handlerList.length; i++) {\n            try {\n                // Call one handler\n                handlerList[i].handler.apply(null, applyArgs);\n            } catch (err) {\n                console.error(\"Exception in '\" + eventName + \"' listener on\", this, String(err), err.stack);\n            }\n        }\n    };\n\n\n    /**\n     * Adds the EventDispatcher APIs to the given object: on(), one(), off(), and trigger(). May also be\n     * called on a prototype object - each instance will still behave independently.\n     * @param {!Object} obj Object to add event-dispatch methods to\n     * @type {function}\n     */\n    function makeEventDispatcher(obj) {\n        obj.on = on;\n        obj.off= off;\n        obj.one= one;\n        obj.trigger= trigger;\n        obj._EventDispatcher= true;\n        // Later, on() may add _eventHandlers: Object.<string, Array.<{event:string, namespace:?string,\n        //   handler:!function(!{type:string, target:!Object}, ...)}>> - map from eventName to an array\n        //   of handler records\n        // Later, markDeprecated() may add _deprecatedEvents: Object.<string, string|boolean> - map from\n        //   eventName to deprecation warning info\n    }\n\n    /**\n     * Utility for calling on() with an array of arguments to pass to event handlers (rather than a varargs\n     * list). makeEventDispatcher() must have previously been called on 'dispatcher'.\n     * @param {!Object} dispatcher\n     * @param {string} eventName\n     * @param {!Array.<*>} argsArray\n     * @type {function}\n     */\n    function triggerWithArray(dispatcher, eventName, argsArray) {\n        var triggerArgs = [eventName].concat(argsArray);\n        dispatcher.trigger.apply(dispatcher, triggerArgs);\n    }\n\n    /**\n     * Utility for attaching an event handler to an object that has not YET had makeEventDispatcher() called\n     * on it, but will in the future. Once 'futureDispatcher' becomes a real event dispatcher, any handlers\n     * attached here will be retained.\n     *\n     * Useful with core modules that have circular dependencies (one module initially gets an empty copy of the\n     * other, with no on() API present yet). Unlike other strategies like waiting for htmlReady(), this helper\n     * guarantees you won't miss any future events, regardless of how soon the other module finishes init and\n     * starts calling trigger().\n     *\n     * @param {!Object} futureDispatcher\n     * @param {string} events\n     * @param {?function(!{type:string, target:!Object}, ...)} fn\n     * @type {function}\n     */\n    function on_duringInit(futureDispatcher, events, fn) {\n        on.call(futureDispatcher, events, fn);\n    }\n\n    /**\n     * Mark a given event name as deprecated, such that on() will emit warnings when called with it.\n     * May be called before makeEventDispatcher(). May be called on a prototype where makeEventDispatcher()\n     * is called separately per instance (i.e. in the constructor). Should be called before clients have\n     * a chance to start calling on().\n     * @param {!Object} obj Event dispatcher object\n     * @param {string} eventName Name of deprecated event\n     * @param {string=} insteadStr Suggested thing to use instead\n     * @type {function}\n     */\n    function markDeprecated(obj, eventName, insteadStr) {\n        // Mark event as deprecated - on() will emit warnings when called with this event\n        if (!obj._deprecatedEvents) {\n            obj._deprecatedEvents = {};\n        }\n        obj._deprecatedEvents[eventName] = insteadStr || true;\n    }\n\n\n    globalObject.EventDispatcher = {\n        makeEventDispatcher,\n        triggerWithArray,\n        on_duringInit,\n        markDeprecated,\n        setLeakThresholdForEvent\n    };\n\n    if(globalObject.define){\n        // for requirejs support\n        define(function (require, exports, module) {\n            exports.makeEventDispatcher = globalObject.EventDispatcher.makeEventDispatcher;\n            exports.triggerWithArray    = globalObject.EventDispatcher.triggerWithArray;\n            exports.on_duringInit       = globalObject.EventDispatcher.on_duringInit;\n            exports.markDeprecated      = globalObject.EventDispatcher.markDeprecated;\n            exports.setLeakThresholdForEvent = globalObject.EventDispatcher.setLeakThresholdForEvent;\n        });\n    }\n}());\n\n"],"file":"EventDispatcher.js"}
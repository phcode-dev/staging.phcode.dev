{"version":3,"sources":["LiveDevelopment/BrowserScripts/ServiceWorkerTransportRemote.js"],"names":["global","WebSocketTransport","_channelOpen","_clientID","Math","round","random","_broadcastMessageChannel","_debugLog","args","window","LIVE_PREVIEW_DEBIG_ENABLED","console","log","_callbacks","setCallbacks","callbacks","this","connect","self","BroadcastChannel","LIVE_PREVIEW_BROADCAST_CHANNEL_ID","postMessage","type","url","location","href","clientID","onmessage","event","JSON","stringify","data","message","clientIDs","includes","length","close","error","addEventListener","send","msgStr","enable","_Brackets_LiveDev_Transport"],"mappings":"CA0BC,SAAUA,QAEP,MAAMC,mBAAqB,CACvBC,cAAc,EACdC,UAAW,GAAKC,KAAKC,MAAqB,IAAdD,KAAKE,UAEjCC,yBAA0B,KAE1BC,UAAW,YAAaC,MACjBC,OAAOC,4BACNC,QAAQC,OAAOJ,OASvBK,WAAY,KAWZC,aAAc,SAAUC,WACpBC,KAAKH,WAAaE,WAMtBE,QAAS,WACL,MAAMC,KAAOF,KAGbE,KAAKZ,yBAA2B,IAAIa,iBAAiBV,OAAOW,mCAC5DF,KAAKZ,yBAAyBe,YAAY,CACtCC,KAAM,kBACNC,IAAKxB,OAAOyB,SAASC,KACrBC,SAAUR,KAAKhB,YAInBgB,KAAKZ,yBAAyBqB,UAAY,CAACC,QAEvCV,KAAKX,UAAU,sDAAuDsB,KAAKC,UAAUF,MAAMG,OAC3F,MAAMT,KAAOM,MAAMG,KAAKT,KACxB,OAAQA,MACR,IAAK,kBACL,IAAK,kBACL,IAAK,gBAAiB,MACtB,IAAK,uBACD,GAAIJ,KAAKL,YAAcK,KAAKL,WAAWmB,QAAS,CAC5C,MAAMC,UAAYL,MAAMG,KAAKvB,KAAK,GAC9BwB,QAAUJ,MAAMG,KAAKvB,KAAK,IAC3ByB,UAAUC,SAAShB,KAAKhB,YAAmC,IAArB+B,UAAUE,SAE/CjB,KAAKL,WAAWmB,QAAQA,SAGhC,MACJ,IAAK,gBACDd,KAAKjB,cAAe,EACpBiB,KAAKZ,yBAAyB8B,QAC1BlB,KAAKL,YAAcK,KAAKL,WAAWuB,OACnClB,KAAKL,WAAWuB,QAEpB,MACJ,QAASzB,QAAQ0B,MAAM,+BAAgCT,UAI3DV,KAAKjB,cAAe,EAChBiB,KAAKL,YAAcK,KAAKL,WAAWI,SACnCC,KAAKL,WAAWI,UAKpBqB,iBAAkB,eAAgB,WAC3BpB,KAAKjB,eACJiB,KAAKjB,cAAe,EACpBiB,KAAKZ,yBAAyBe,YAAY,CACtCC,KAAM,gBACNI,SAAUR,KAAKhB,gBAU/BqC,KAAM,SAAUC,QACZ,MAAMtB,KAAOF,KAAAA,KACRV,yBAAyBe,YAAY,CACtCC,KAAM,kBACNI,SAHSV,KAGMd,UACf8B,QAASQ,UAOjBC,OAAQ,WACJzB,KAAKC,YAGblB,OAAO2C,4BAA8B1C,mBApHzC,CAqHEgB","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// This is a transport injected into the browser via a script that handles the low\n// level communication between the live development protocol handlers on both sides.\n// This transport provides a web socket mechanism. It's injected separately from the\n// protocol handler so that the transport can be changed separately.\n\n(function (global) {\n\n    const WebSocketTransport = {\n        _channelOpen: false,\n        _clientID: \"\" + Math.round( Math.random()*1000000000),\n        // message channel used to communicate with service worker\n        _broadcastMessageChannel: null,\n\n        _debugLog: function (...args) {\n            if(window.LIVE_PREVIEW_DEBIG_ENABLED) {\n                console.log(...args);\n            }\n        },\n\n        /**\n         * @private\n         * An object that contains callbacks to handle various transport events. See `setCallbacks()`.\n         * @type {?{connect: ?function, message: ?function(string), close: ?function}}\n         */\n        _callbacks: null,\n\n        /**\n         * Sets the callbacks that should be called when various transport events occur. All callbacks\n         * are optional, but you should at least implement \"message\" or nothing interesting will happen :)\n         * @param {?{connect: ?function, message: ?function(string), close: ?function}} callbacks\n         *      The callbacks to set.\n         *      connect - called when a connection is established to Brackets\n         *      message(msgStr) - called with a string message sent from Brackets\n         *      close - called when Brackets closes the connection\n         */\n        setCallbacks: function (callbacks) {\n            this._callbacks = callbacks;\n        },\n\n        /**\n         * Connects to the ServiceWorkerTransport in Brackets at the given WebSocket URL.\n         */\n        connect: function () {\n            const self = this;\n            // message channel to phoenix connect on load itself. The channel id is injected from phoenix\n            // via ServiceWorkerTransport.js while serving the instrumented html file\n            self._broadcastMessageChannel = new BroadcastChannel(window.LIVE_PREVIEW_BROADCAST_CHANNEL_ID);\n            self._broadcastMessageChannel.postMessage({\n                type: 'BROWSER_CONNECT',\n                url: global.location.href,\n                clientID: self._clientID\n            });\n\n            // Listen to the response\n            self._broadcastMessageChannel.onmessage = (event) => {\n                // Print the result\n                self._debugLog(\"Live Preview: Browser received event from Phoenix: \", JSON.stringify(event.data));\n                const type = event.data.type;\n                switch (type) {\n                case 'BROWSER_CONNECT': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_MESSAGE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_CLOSE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'MESSAGE_FROM_PHOENIX':\n                    if (self._callbacks && self._callbacks.message) {\n                        const clientIDs = event.data.args[0],\n                            message = event.data.args[1];\n                        if(clientIDs.includes(self._clientID) || clientIDs.length === 0){\n                            // clientIDs.length = 0 if the message is intended for all clients\n                            self._callbacks.message(message);\n                        }\n                    }\n                    break;\n                case 'PHOENIX_CLOSE':\n                    self._channelOpen = false;\n                    self._broadcastMessageChannel.close();\n                    if (self._callbacks && self._callbacks.close) {\n                        self._callbacks.close();\n                    }\n                    break;\n                default: console.error(\"Unknown event type for event\", event);\n                }\n            };\n\n            self._channelOpen = true;\n            if (self._callbacks && self._callbacks.connect) {\n                self._callbacks.connect();\n            }\n\n            // attach to browser tab/window closing event so that we send a cleanup request\n            // to the service worker for the comm ports\n            addEventListener( 'beforeunload', function() {\n                if(self._channelOpen){\n                    self._channelOpen = false;\n                    self._broadcastMessageChannel.postMessage({\n                        type: 'BROWSER_CLOSE',\n                        clientID: self._clientID\n                    });\n                }\n            });\n        },\n\n        /**\n         * Sends a message over the transport.\n         * @param {string} msgStr The message to send.\n         */\n        send: function (msgStr) {\n            const self = this;\n            self._broadcastMessageChannel.postMessage({\n                type: 'BROWSER_MESSAGE',\n                clientID: self._clientID,\n                message: msgStr\n            });\n        },\n\n        /**\n         * Establish web socket connection.\n         */\n        enable: function () {\n            this.connect();\n        }\n    };\n    global._Brackets_LiveDev_Transport = WebSocketTransport;\n}(this));\n"],"file":"ServiceWorkerTransportRemote.js"}
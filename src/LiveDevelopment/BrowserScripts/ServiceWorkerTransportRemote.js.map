{"version":3,"sources":["LiveDevelopment/BrowserScripts/ServiceWorkerTransportRemote.js"],"names":["global","_debugLog","args","window","LIVE_PREVIEW_DEBUG_ENABLED","console","log","clientID","Math","round","random","LIVE_PREVIEW_NAVIGATOR_CHANNEL_ID","PHOENIX_INSTANCE_ID","worker","Worker","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","onmessage","event","type","data","document","getElementById","src","URL","location","href","error","postMessage","broadcastChannel","WebSocketTransport","_channelOpen","_broadcastMessageChannel","_callbacks","setCallbacks","callbacks","this","connect","self","BroadcastChannel","LIVE_PREVIEW_BROADCAST_CHANNEL_ID","url","JSON","stringify","message","clientIDs","includes","length","close","addEventListener","send","msgStr","enable","_Brackets_LiveDev_Transport"],"mappings":"CA0BC,SAAUA,QAEP,SAASC,aAAaC,MACfC,OAAOC,4BACNC,QAAQC,OAAOJ,MAIvB,MAAMK,SAAW,GAAKC,KAAKC,MAAqB,IAAdD,KAAKE,UACjCC,qCAAuCR,OAAOS,uCAE9CC,OAAS,IAAIC,OAAOX,OAAOY,0CACjCF,OAAOG,UAAY,CAACC,QAChB,MAAMC,KAAOD,MAAME,KAAKD,KACxB,OAAQA,MACR,IAAK,yBAA0BE,SAASC,eAAe,gBAAgBC,IAAML,MAAME,KAAKI,IAAK,MAC7F,IAAK,gBAAiBC,SAASC,KAAOR,MAAME,KAAKI,IAAK,MACtD,QAASlB,QAAQqB,MAAM,kEAAmET,UAG9FJ,OAAOc,YAAY,CACfT,KAAM,iBACNU,iBAAkBjB,kCAClBJ,SAAAA,WAEJ,MAAMsB,mBAAqB,CACvBC,cAAc,EAEdC,yBAA0B,KAO1BC,WAAY,KAWZC,aAAc,SAAUC,WACpBC,KAAKH,WAAaE,WAMtBE,QAAS,WACL,MAAMC,KAAOF,KAGbE,KAAKN,yBAA2B,IAAIO,iBAAiBnC,OAAOoC,mCAC5DF,KAAKN,yBAAyBJ,YAAY,CACtCT,KAAM,kBACNsB,IAAKxC,OAAOwB,SAASC,KACrBlB,SAAUA,WAId8B,KAAKN,yBAAyBf,UAAY,CAACC,QAEvChB,UAAU,sDAAuDwC,KAAKC,UAAUzB,MAAME,OACtF,MAAMD,KAAOD,MAAME,KAAKD,KACxB,OAAQA,MACR,IAAK,kBACL,IAAK,kBACL,IAAK,gBAAiB,MACtB,IAAK,uBACD,GAAImB,KAAKL,YAAcK,KAAKL,WAAWW,QAAS,CAC5C,MAAMC,UAAY3B,MAAME,KAAKyB,UACzBD,QAAU1B,MAAME,KAAKwB,SACtBC,UAAUC,SAAStC,WAAkC,IAArBqC,UAAUE,SAEzCT,KAAKL,WAAWW,QAAQA,SAGhC,MACJ,IAAK,gBACDN,KAAKP,cAAe,EACpBO,KAAKN,yBAAyBgB,QAC1BV,KAAKL,YAAcK,KAAKL,WAAWe,OACnCV,KAAKL,WAAWe,QAEpB,MACJ,QAAS1C,QAAQqB,MAAM,+BAAgCT,UAI3DoB,KAAKP,cAAe,EAChBO,KAAKL,YAAcK,KAAKL,WAAWI,SACnCC,KAAKL,WAAWI,UAKpBY,iBAAkB,eAAgB,WAC3BX,KAAKP,eACJO,KAAKP,cAAe,EACpBO,KAAKN,yBAAyBJ,YAAY,CACtCT,KAAM,gBACNX,SAAUA,eAU1B0C,KAAM,SAAUC,QACZ,MAAMb,KAAOF,KAAAA,KACRJ,yBAAyBJ,YAAY,CACtCT,KAAM,kBACNX,SAAUA,SACVoC,QAASO,UAOjBC,OAAQ,WACJhB,KAAKC,YAGbpC,OAAOoD,4BAA8BvB,mBApIzC,CAqIEM","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// This is a transport injected into the browser via a script that handles the low\n// level communication between the live development protocol handlers on both sides.\n// This transport provides a web socket mechanism. It's injected separately from the\n// protocol handler so that the transport can be changed separately.\n\n(function (global) {\n\n    function _debugLog(...args) {\n        if(window.LIVE_PREVIEW_DEBUG_ENABLED) {\n            console.log(...args);\n        }\n    }\n\n    const clientID = \"\" + Math.round( Math.random()*1000000000);\n    const LIVE_PREVIEW_NAVIGATOR_CHANNEL_ID = `${window.PHOENIX_INSTANCE_ID}-nav-live-preview`;\n\n    const worker = new Worker(window.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME);\n    worker.onmessage = (event) => {\n        const type = event.data.type;\n        switch (type) {\n        case 'REDIRECT_CONTENT_FRAME': document.getElementById(\"contentFrame\").src = event.data.URL; break;\n        case 'REDIRECT_PAGE': location.href = event.data.URL; break;\n        default: console.error(\"Live Preview page loader: received unknown message from worker:\", event);\n        }\n    };\n    worker.postMessage({\n        type: \"setupBroadcast\",\n        broadcastChannel: LIVE_PREVIEW_NAVIGATOR_CHANNEL_ID,\n        clientID});\n\n    const WebSocketTransport = {\n        _channelOpen: false,\n        // message channel used to communicate with service worker\n        _broadcastMessageChannel: null,\n\n        /**\n         * @private\n         * An object that contains callbacks to handle various transport events. See `setCallbacks()`.\n         * @type {?{connect: ?function, message: ?function(string), close: ?function}}\n         */\n        _callbacks: null,\n\n        /**\n         * Sets the callbacks that should be called when various transport events occur. All callbacks\n         * are optional, but you should at least implement \"message\" or nothing interesting will happen :)\n         * @param {?{connect: ?function, message: ?function(string), close: ?function}} callbacks\n         *      The callbacks to set.\n         *      connect - called when a connection is established to Brackets\n         *      message(msgStr) - called with a string message sent from Brackets\n         *      close - called when Brackets closes the connection\n         */\n        setCallbacks: function (callbacks) {\n            this._callbacks = callbacks;\n        },\n\n        /**\n         * Connects to the ServiceWorkerTransport in Brackets at the given WebSocket URL.\n         */\n        connect: function () {\n            const self = this;\n            // message channel to phoenix connect on load itself. The channel id is injected from phoenix\n            // via ServiceWorkerTransport.js while serving the instrumented html file\n            self._broadcastMessageChannel = new BroadcastChannel(window.LIVE_PREVIEW_BROADCAST_CHANNEL_ID);\n            self._broadcastMessageChannel.postMessage({\n                type: 'BROWSER_CONNECT',\n                url: global.location.href,\n                clientID: clientID\n            });\n\n            // Listen to the response\n            self._broadcastMessageChannel.onmessage = (event) => {\n                // Print the result\n                _debugLog(\"Live Preview: Browser received event from Phoenix: \", JSON.stringify(event.data));\n                const type = event.data.type;\n                switch (type) {\n                case 'BROWSER_CONNECT': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_MESSAGE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_CLOSE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'MESSAGE_FROM_PHOENIX':\n                    if (self._callbacks && self._callbacks.message) {\n                        const clientIDs = event.data.clientIDs,\n                            message = event.data.message;\n                        if(clientIDs.includes(clientID) || clientIDs.length === 0){\n                            // clientIDs.length = 0 if the message is intended for all clients\n                            self._callbacks.message(message);\n                        }\n                    }\n                    break;\n                case 'PHOENIX_CLOSE':\n                    self._channelOpen = false;\n                    self._broadcastMessageChannel.close();\n                    if (self._callbacks && self._callbacks.close) {\n                        self._callbacks.close();\n                    }\n                    break;\n                default: console.error(\"Unknown event type for event\", event);\n                }\n            };\n\n            self._channelOpen = true;\n            if (self._callbacks && self._callbacks.connect) {\n                self._callbacks.connect();\n            }\n\n            // attach to browser tab/window closing event so that we send a cleanup request\n            // to the service worker for the comm ports\n            addEventListener( 'beforeunload', function() {\n                if(self._channelOpen){\n                    self._channelOpen = false;\n                    self._broadcastMessageChannel.postMessage({\n                        type: 'BROWSER_CLOSE',\n                        clientID: clientID\n                    });\n                }\n            });\n        },\n\n        /**\n         * Sends a message over the transport.\n         * @param {string} msgStr The message to send.\n         */\n        send: function (msgStr) {\n            const self = this;\n            self._broadcastMessageChannel.postMessage({\n                type: 'BROWSER_MESSAGE',\n                clientID: clientID,\n                message: msgStr\n            });\n        },\n\n        /**\n         * Establish web socket connection.\n         */\n        enable: function () {\n            this.connect();\n        }\n    };\n    global._Brackets_LiveDev_Transport = WebSocketTransport;\n}(this));\n"],"file":"ServiceWorkerTransportRemote.js"}
{"version":3,"sources":["LiveDevelopment/BrowserScripts/DocumentObserver.js"],"names":["global","ProtocolManager","_Brackets_LiveDev_ProtocolManager","_document","_transport","inIframe","window","self","top","e","scrollToLastPosition","saved","JSON","parse","sessionStorage","getItem","location","href","scrollTo","left","scrollX","scrollY","behavior","related","rel","scripts","stylesheets","i","s","j","length","src","traverseRules","_traverseRules","sheet","base","cssRules","name","undefined","push","styleSheet","document","styleSheets","savePageCtrlSDisabledByPhoenix","addEventListener","key","navigator","platform","match","metaKey","ctrlKey","preventDefault","setItem","stringify","Utils","isExternalStylesheet","node","nodeName","toUpperCase","isExternalScript","CSS","loadTimers","checkForStylesheetLoaded","this","clearInterval","currentPollTime","maxPollTime","pollInterval","setInterval","notifyStylesheetAdded","onStylesheetRemoved","url","getElementById","parentNode","removeChild","added","current","newStatus","Object","keys","forEach","v","send","method","roots","notifyStylesheetRemoved","_dontUpdateStylesheets","removed","_onNodesAdded","nodes","_onNodesRemoved","_enableListeners","MutationObserver","WebKitMutationObserver","MozMutationObserver","observer","mutations","mutation","addedNodes","removedNodes","observe","childList","subtree","niLstnr","target","nrLstnr","start","transport","stop","DocumentObserver","setDocumentObserver"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global setInterval, clearInterval */\n\n(function (global) {\n\n\n    var ProtocolManager = global._Brackets_LiveDev_ProtocolManager;\n\n    var _document = null;\n    var _transport;\n\n    function inIframe () {\n        try {\n            return window.self !== window.top;\n        } catch (e) {\n            return true;\n        }\n    }\n\n    if(inIframe()) {\n        // inside iframes, we disable ctrl-s browser save page workflow as it may be inside the phoenix window\n        // It will confuse the use seeing the browser save dialog inside phoenix.\n        document.savePageCtrlSDisabledByPhoenix = true;\n        document.addEventListener(\"keydown\", function(e) {\n            if (e.key === 's' && (navigator.platform.match(\"Mac\") ? e.metaKey : e.ctrlKey)) {\n                e.preventDefault();\n            }\n        }, false);\n    }\n\n    window.addEventListener('scroll', function () {\n        // save scroll position\n        sessionStorage.setItem(\"saved-scroll-\" + location.href, JSON.stringify({\n            scrollX: window.scrollX,\n            scrollY: window.scrollY\n        }));\n    });\n    function scrollToLastPosition() {\n        let saved = JSON.parse(sessionStorage.getItem(\"saved-scroll-\" + location.href));\n        if(saved){\n            window.scrollTo({\n                left: saved.scrollX,\n                top: saved.scrollY,\n                behavior: \"instant\"\n            });\n        }\n    }\n    window.addEventListener(\"load\", scrollToLastPosition);\n\n    /**\n     * Retrieves related documents (external CSS and JS files)\n     *\n     * @return {{scripts: object, stylesheets: object}} Related scripts and stylesheets\n     */\n    function related() {\n\n        var rel = {\n            scripts: {},\n            stylesheets: {}\n        };\n        var i;\n        // iterate on document scripts (HTMLCollection doesn't provide forEach iterator).\n        for (i = 0; i < _document.scripts.length; i++) {\n            // add only external scripts\n            if (_document.scripts[i].src) {\n                rel.scripts[_document.scripts[i].src] = true;\n            }\n        }\n\n        var s, j;\n        //traverse @import rules\n        var traverseRules = function _traverseRules(sheet, base) {\n            var i,\n                href = sheet.href,\n                cssRules;\n\n            // Deal with Firefox's SecurityError when accessing sheets\n            // from other domains. Chrome will safely return `undefined`.\n            try {\n                cssRules = sheet.cssRules;\n            } catch (e) {\n                if (e.name !== \"SecurityError\") {\n                    throw e;\n                }\n            }\n\n            if (href && cssRules) {\n                if (rel.stylesheets[href] === undefined) {\n                    rel.stylesheets[href] = [];\n                }\n                rel.stylesheets[href].push(base);\n\n                for (i = 0; i < cssRules.length; i++) {\n                    if (cssRules[i].href) {\n                        traverseRules(cssRules[i].styleSheet, base);\n                    }\n                }\n            }\n        };\n        //iterate on document.stylesheets (StyleSheetList doesn't provide forEach iterator).\n        for (j = 0; j < window.document.styleSheets.length; j++) {\n            s = window.document.styleSheets[j];\n            traverseRules(s, s.href);\n        }\n        return rel;\n    }\n\n    /**\n     * Common functions.\n     */\n    var Utils = {\n\n        isExternalStylesheet: function (node) {\n            return (node.nodeName.toUpperCase() === \"LINK\" && node.rel === \"stylesheet\" && node.href);\n        },\n        isExternalScript: function (node) {\n            return (node.nodeName.toUpperCase() === \"SCRIPT\" && node.src);\n        }\n    };\n\n    /**\n     * CSS related commands and notifications\n     */\n    var CSS = {\n\n        /**\n        * Maintains a map of stylesheets loaded thorugh @import rules and their parents.\n        * Populated by extractImports, consumed by notifyImportsAdded / notifyImportsRemoved.\n        * @type {\n        */\n        stylesheets: {},\n        loadTimers: {},\n\n        /**\n         * Check the stylesheet that was just added be really loaded\n         * to be able to extract potential import-ed stylesheets.\n         * It invokes notifyStylesheetAdded once the sheet is loaded.\n         * @param  {string} href Absolute URL of the stylesheet.\n         */\n        checkForStylesheetLoaded : function (href) {\n            const self = this;\n            if(!href){\n                return;\n            }\n            if(self.loadTimers[href]){\n                clearInterval(self.loadTimers[href]); // we dont want two timers on the same thing\n                delete self.loadTimers[href];\n            }\n\n            // Inspect CSSRules for @imports:\n            // styleSheet obejct is required to scan CSSImportRules but\n            // browsers differ on the implementation of MutationObserver interface.\n            // Webkit triggers notifications before stylesheets are loaded,\n            // Firefox does it after loading.\n            // There are also differences on when 'load' event is triggered for\n            // the 'link' nodes. Webkit triggers it before stylesheet is loaded.\n            // Some references to check:\n            //      http://www.phpied.com/when-is-a-stylesheet-really-loaded/\n            //      http://stackoverflow.com/questions/17747616/webkit-dynamically-created-stylesheet-when-does-it-really-load\n            //        http://stackoverflow.com/questions/11425209/are-dom-mutation-observers-slower-than-dom-mutation-events\n            //\n            // TODO: This is just a temporary 'cross-browser' solution, it needs optimization.\n            let currentPollTime = 0, maxPollTime = 20000, pollInterval = 50;\n            self.loadTimers[href] = setInterval(function () {\n                let i;\n                if(currentPollTime > maxPollTime) {\n                    clearInterval(self.loadTimers[href]);\n                    delete self.loadTimers[href];\n                    return;\n                }\n                for (i = 0; i < window.document.styleSheets.length; i++) {\n                    if (window.document.styleSheets[i].href === href) {\n                        //clear interval\n                        clearInterval(self.loadTimers[href]);\n                        delete self.loadTimers[href];\n                        // notify stylesheets added\n                        self.notifyStylesheetAdded();\n                        break;\n                    }\n                }\n                currentPollTime = currentPollTime + pollInterval;\n            }, pollInterval);\n        },\n\n        onStylesheetRemoved : function (url) {\n            // get style node created when setting new text for stylesheet.\n            var s = window.document.getElementById(url);\n            // remove\n            if (s && s.parentNode && s.parentNode.removeChild) {\n                s.parentNode.removeChild(s);\n            }\n        },\n\n        /**\n         * Send a notification for the stylesheet added and\n         * its import-ed styleshets based on document.stylesheets diff\n         * from previous status. It also updates stylesheets status.\n         */\n        notifyStylesheetAdded : function () {\n            var added = {},\n                current,\n                newStatus;\n\n            current = this.stylesheets;\n            newStatus = related().stylesheets;\n\n            Object.keys(newStatus).forEach(function (v, i) {\n                if (!current[v]) {\n                    added[v] = newStatus[v];\n                }\n            });\n\n            Object.keys(added).forEach(function (v, i) {\n                _transport.send(JSON.stringify({\n                    method: \"StylesheetAdded\",\n                    href: v,\n                    roots: [added[v]]\n                }));\n            });\n\n            self.stylesheets = newStatus;\n        },\n\n        /**\n         * Send a notification for the removed stylesheet and\n         * its import-ed styleshets based on document.stylesheets diff\n         * from previous status. It also updates stylesheets status.\n         */\n        notifyStylesheetRemoved : function (_dontUpdateStylesheets) {\n\n            var self = this;\n            var removed = {},\n                newStatus,\n                current;\n\n            current = self.stylesheets;\n            newStatus = related().stylesheets;\n\n            Object.keys(current).forEach(function (v, i) {\n                if (!newStatus[v]) {\n                    removed[v] = current[v];\n                    // remove node created by setStylesheetText if any\n                    self.onStylesheetRemoved(current[v]);\n                }\n            });\n\n            Object.keys(removed).forEach(function (v, i) {\n                _transport.send(JSON.stringify({\n                    method: \"StylesheetRemoved\",\n                    href: v,\n                    roots: [removed[v]]\n                }));\n            });\n\n            if(!_dontUpdateStylesheets){\n                self.stylesheets = newStatus;\n            }\n        }\n    };\n\n\n    /* process related docs added */\n    function _onNodesAdded(nodes) {\n        var i;\n        for (i = 0; i < nodes.length; i++) {\n            //check for Javascript files\n            if (Utils.isExternalScript(nodes[i])) {\n                _transport.send(JSON.stringify({\n                    method: 'ScriptAdded',\n                    src: nodes[i].src\n                }));\n            }\n            //check for stylesheets\n            if (Utils.isExternalStylesheet(nodes[i])) {\n                CSS.checkForStylesheetLoaded(nodes[i].href);\n            }\n        }\n    }\n    /* process related docs removed */\n    function _onNodesRemoved(nodes) {\n        var i;\n        //iterate on removed nodes\n        for (i = 0; i < nodes.length; i++) {\n\n            // check for external JS files\n            if (Utils.isExternalScript(nodes[i])) {\n                _transport.send(JSON.stringify({\n                    method: 'ScriptRemoved',\n                    src: nodes[i].src\n                }));\n            }\n            //check for external StyleSheets\n            if (Utils.isExternalStylesheet(nodes[i])) {\n                CSS.notifyStylesheetRemoved();\n            }\n        }\n    }\n\n    function _enableListeners() {\n        // enable MutationOberver if it's supported\n        var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n        if (MutationObserver) {\n            var observer = new MutationObserver(function (mutations) {\n                mutations.forEach(function (mutation) {\n                    if (mutation.addedNodes.length > 0) {\n                        _onNodesAdded(mutation.addedNodes);\n                    }\n                    if (mutation.removedNodes.length > 0) {\n                        _onNodesRemoved(mutation.removedNodes);\n                    }\n                });\n            });\n            observer.observe(_document, {\n                childList: true,\n                subtree: true\n            });\n        } else {\n            // use MutationEvents as fallback\n            window.document.addEventListener('DOMNodeInserted', function niLstnr(e) {\n                _onNodesAdded([e.target]);\n            });\n            window.document.addEventListener('DOMNodeRemoved', function nrLstnr(e) {\n                _onNodesRemoved([e.target]);\n            });\n        }\n    }\n\n\n    /**\n     * Start listening for events and send initial related documents message.\n     *\n     * @param {HTMLDocument} document\n     * @param {object} transport Live development transport connection\n     */\n    function start(document, transport) {\n        _transport = transport;\n        _document = document;\n        // start listening to node changes\n        _enableListeners();\n\n        var rel = related();\n\n        // send the current status of related docs.\n        _transport.send(JSON.stringify({\n            method: \"DocumentRelated\",\n            related: rel\n        }));\n        // initialize stylesheets with current status for further notifications.\n        CSS.stylesheets = rel.stylesheets;\n    }\n\n    /**\n     * Stop listening.\n     * TODO currently a no-op.\n     */\n    function stop() {\n\n    }\n\n    var DocumentObserver = {\n        start: start,\n        stop: stop,\n        related: related\n    };\n\n    ProtocolManager.setDocumentObserver(DocumentObserver);\n\n}(this));\n"],"file":"DocumentObserver.js"}
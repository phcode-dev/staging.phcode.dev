{"version":3,"sources":["LiveDevelopment/BrowserScripts/DocumentObserver.js"],"names":["global","ProtocolManager","_Brackets_LiveDev_ProtocolManager","_document","_transport","related","rel","scripts","stylesheets","i","s","j","length","src","traverseRules","_traverseRules","sheet","base","href","cssRules","e","name","undefined","push","styleSheet","window","document","styleSheets","Utils","isExternalStylesheet","node","nodeName","toUpperCase","isExternalScript","CSS","loadTimers","checkForStylesheetLoaded","self","this","clearInterval","currentPollTime","maxPollTime","pollInterval","setInterval","notifyStylesheetAdded","onStylesheetRemoved","url","getElementById","parentNode","removeChild","added","current","newStatus","Object","keys","forEach","v","send","JSON","stringify","method","roots","notifyStylesheetRemoved","_dontUpdateStylesheets","removed","_onNodesAdded","nodes","_onNodesRemoved","_enableListeners","MutationObserver","WebKitMutationObserver","MozMutationObserver","observer","mutations","mutation","addedNodes","removedNodes","observe","childList","subtree","addEventListener","niLstnr","target","nrLstnr","start","transport","stop","DocumentObserver","setDocumentObserver"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global setInterval, clearInterval */\n\n(function (global) {\n\n\n    var ProtocolManager = global._Brackets_LiveDev_ProtocolManager;\n\n    var _document = null;\n    var _transport;\n\n\n    /**\n     * Retrieves related documents (external CSS and JS files)\n     *\n     * @return {{scripts: object, stylesheets: object}} Related scripts and stylesheets\n     */\n    function related() {\n\n        var rel = {\n            scripts: {},\n            stylesheets: {}\n        };\n        var i;\n        // iterate on document scripts (HTMLCollection doesn't provide forEach iterator).\n        for (i = 0; i < _document.scripts.length; i++) {\n            // add only external scripts\n            if (_document.scripts[i].src) {\n                rel.scripts[_document.scripts[i].src] = true;\n            }\n        }\n\n        var s, j;\n        //traverse @import rules\n        var traverseRules = function _traverseRules(sheet, base) {\n            var i,\n                href = sheet.href,\n                cssRules;\n\n            // Deal with Firefox's SecurityError when accessing sheets\n            // from other domains. Chrome will safely return `undefined`.\n            try {\n                cssRules = sheet.cssRules;\n            } catch (e) {\n                if (e.name !== \"SecurityError\") {\n                    throw e;\n                }\n            }\n\n            if (href && cssRules) {\n                if (rel.stylesheets[href] === undefined) {\n                    rel.stylesheets[href] = [];\n                }\n                rel.stylesheets[href].push(base);\n\n                for (i = 0; i < cssRules.length; i++) {\n                    if (cssRules[i].href) {\n                        traverseRules(cssRules[i].styleSheet, base);\n                    }\n                }\n            }\n        };\n        //iterate on document.stylesheets (StyleSheetList doesn't provide forEach iterator).\n        for (j = 0; j < window.document.styleSheets.length; j++) {\n            s = window.document.styleSheets[j];\n            traverseRules(s, s.href);\n        }\n        return rel;\n    }\n\n    /**\n     * Common functions.\n     */\n    var Utils = {\n\n        isExternalStylesheet: function (node) {\n            return (node.nodeName.toUpperCase() === \"LINK\" && node.rel === \"stylesheet\" && node.href);\n        },\n        isExternalScript: function (node) {\n            return (node.nodeName.toUpperCase() === \"SCRIPT\" && node.src);\n        }\n    };\n\n    /**\n     * CSS related commands and notifications\n     */\n    var CSS = {\n\n        /**\n        * Maintains a map of stylesheets loaded thorugh @import rules and their parents.\n        * Populated by extractImports, consumed by notifyImportsAdded / notifyImportsRemoved.\n        * @type {\n        */\n        stylesheets: {},\n        loadTimers: {},\n\n        /**\n         * Check the stylesheet that was just added be really loaded\n         * to be able to extract potential import-ed stylesheets.\n         * It invokes notifyStylesheetAdded once the sheet is loaded.\n         * @param  {string} href Absolute URL of the stylesheet.\n         */\n        checkForStylesheetLoaded : function (href) {\n            const self = this;\n            if(!href){\n                return;\n            }\n            if(self.loadTimers[href]){\n                clearInterval(self.loadTimers[href]); // we dont want two timers on the same thing\n                delete self.loadTimers[href];\n            }\n\n            // Inspect CSSRules for @imports:\n            // styleSheet obejct is required to scan CSSImportRules but\n            // browsers differ on the implementation of MutationObserver interface.\n            // Webkit triggers notifications before stylesheets are loaded,\n            // Firefox does it after loading.\n            // There are also differences on when 'load' event is triggered for\n            // the 'link' nodes. Webkit triggers it before stylesheet is loaded.\n            // Some references to check:\n            //      http://www.phpied.com/when-is-a-stylesheet-really-loaded/\n            //      http://stackoverflow.com/questions/17747616/webkit-dynamically-created-stylesheet-when-does-it-really-load\n            //        http://stackoverflow.com/questions/11425209/are-dom-mutation-observers-slower-than-dom-mutation-events\n            //\n            // TODO: This is just a temporary 'cross-browser' solution, it needs optimization.\n            let currentPollTime = 0, maxPollTime = 20000, pollInterval = 50;\n            self.loadTimers[href] = setInterval(function () {\n                let i;\n                if(currentPollTime > maxPollTime) {\n                    clearInterval(self.loadTimers[href]);\n                    delete self.loadTimers[href];\n                    return;\n                }\n                for (i = 0; i < window.document.styleSheets.length; i++) {\n                    if (window.document.styleSheets[i].href === href) {\n                        //clear interval\n                        clearInterval(self.loadTimers[href]);\n                        delete self.loadTimers[href];\n                        // notify stylesheets added\n                        self.notifyStylesheetAdded();\n                        break;\n                    }\n                }\n                currentPollTime = currentPollTime + pollInterval;\n            }, pollInterval);\n        },\n\n        onStylesheetRemoved : function (url) {\n            // get style node created when setting new text for stylesheet.\n            var s = window.document.getElementById(url);\n            // remove\n            if (s && s.parentNode && s.parentNode.removeChild) {\n                s.parentNode.removeChild(s);\n            }\n        },\n\n        /**\n         * Send a notification for the stylesheet added and\n         * its import-ed styleshets based on document.stylesheets diff\n         * from previous status. It also updates stylesheets status.\n         */\n        notifyStylesheetAdded : function () {\n            var added = {},\n                current,\n                newStatus;\n\n            current = this.stylesheets;\n            newStatus = related().stylesheets;\n\n            Object.keys(newStatus).forEach(function (v, i) {\n                if (!current[v]) {\n                    added[v] = newStatus[v];\n                }\n            });\n\n            Object.keys(added).forEach(function (v, i) {\n                _transport.send(JSON.stringify({\n                    method: \"StylesheetAdded\",\n                    href: v,\n                    roots: [added[v]]\n                }));\n            });\n\n            self.stylesheets = newStatus;\n        },\n\n        /**\n         * Send a notification for the removed stylesheet and\n         * its import-ed styleshets based on document.stylesheets diff\n         * from previous status. It also updates stylesheets status.\n         */\n        notifyStylesheetRemoved : function (_dontUpdateStylesheets) {\n\n            var self = this;\n            var removed = {},\n                newStatus,\n                current;\n\n            current = self.stylesheets;\n            newStatus = related().stylesheets;\n\n            Object.keys(current).forEach(function (v, i) {\n                if (!newStatus[v]) {\n                    removed[v] = current[v];\n                    // remove node created by setStylesheetText if any\n                    self.onStylesheetRemoved(current[v]);\n                }\n            });\n\n            Object.keys(removed).forEach(function (v, i) {\n                _transport.send(JSON.stringify({\n                    method: \"StylesheetRemoved\",\n                    href: v,\n                    roots: [removed[v]]\n                }));\n            });\n\n            if(!_dontUpdateStylesheets){\n                self.stylesheets = newStatus;\n            }\n        }\n    };\n\n\n    /* process related docs added */\n    function _onNodesAdded(nodes) {\n        var i;\n        for (i = 0; i < nodes.length; i++) {\n            //check for Javascript files\n            if (Utils.isExternalScript(nodes[i])) {\n                _transport.send(JSON.stringify({\n                    method: 'ScriptAdded',\n                    src: nodes[i].src\n                }));\n            }\n            //check for stylesheets\n            if (Utils.isExternalStylesheet(nodes[i])) {\n                CSS.checkForStylesheetLoaded(nodes[i].href);\n            }\n        }\n    }\n    /* process related docs removed */\n    function _onNodesRemoved(nodes) {\n        var i;\n        //iterate on removed nodes\n        for (i = 0; i < nodes.length; i++) {\n\n            // check for external JS files\n            if (Utils.isExternalScript(nodes[i])) {\n                _transport.send(JSON.stringify({\n                    method: 'ScriptRemoved',\n                    src: nodes[i].src\n                }));\n            }\n            //check for external StyleSheets\n            if (Utils.isExternalStylesheet(nodes[i])) {\n                CSS.notifyStylesheetRemoved();\n            }\n        }\n    }\n\n    function _enableListeners() {\n        // enable MutationOberver if it's supported\n        var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n        if (MutationObserver) {\n            var observer = new MutationObserver(function (mutations) {\n                mutations.forEach(function (mutation) {\n                    if (mutation.addedNodes.length > 0) {\n                        _onNodesAdded(mutation.addedNodes);\n                    }\n                    if (mutation.removedNodes.length > 0) {\n                        _onNodesRemoved(mutation.removedNodes);\n                    }\n                });\n            });\n            observer.observe(_document, {\n                childList: true,\n                subtree: true\n            });\n        } else {\n            // use MutationEvents as fallback\n            window.document.addEventListener('DOMNodeInserted', function niLstnr(e) {\n                _onNodesAdded([e.target]);\n            });\n            window.document.addEventListener('DOMNodeRemoved', function nrLstnr(e) {\n                _onNodesRemoved([e.target]);\n            });\n        }\n    }\n\n\n    /**\n     * Start listening for events and send initial related documents message.\n     *\n     * @param {HTMLDocument} document\n     * @param {object} transport Live development transport connection\n     */\n    function start(document, transport) {\n        _transport = transport;\n        _document = document;\n        // start listening to node changes\n        _enableListeners();\n\n        var rel = related();\n\n        // send the current status of related docs.\n        _transport.send(JSON.stringify({\n            method: \"DocumentRelated\",\n            related: rel\n        }));\n        // initialize stylesheets with current status for further notifications.\n        CSS.stylesheets = rel.stylesheets;\n    }\n\n    /**\n     * Stop listening.\n     * TODO currently a no-op.\n     */\n    function stop() {\n\n    }\n\n    var DocumentObserver = {\n        start: start,\n        stop: stop,\n        related: related\n    };\n\n    ProtocolManager.setDocumentObserver(DocumentObserver);\n\n}(this));\n"],"file":"DocumentObserver.js"}
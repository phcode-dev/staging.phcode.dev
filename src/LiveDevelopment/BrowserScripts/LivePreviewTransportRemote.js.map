{"version":3,"sources":["LiveDevelopment/BrowserScripts/LivePreviewTransportRemote.js"],"names":["global","TRANSPORT_CONFIG","_debugLog","args","window","LIVE_PREVIEW_DEBUG_ENABLED","console","log","clientID","Math","round","random","worker","Worker","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","_workerMessageProcessor","sentTitle","sentFavIconURL","_postLivePreviewMessage","message","postMessage","type","convertImgToBase64","url","callback","canvas","document","createElement","ctx","getContext","img","Image","crossOrigin","onload","height","width","drawImage","dataURL","toDataURL","src","getAbsoluteUrl","test","absoluteUrl","URL","location","href","onmessage","event","data","error","livePreviewDebugModeEnabled","broadcastChannel","LIVE_PREVIEW_BROADCAST_CHANNEL_ID","websocketChannelURL","LIVE_PREVIEW_WEBSOCKET_CHANNEL_URL","setInterval","favIcon","querySelector","faviconUrl","base64","faviconBase64","title","_Brackets_LiveDev_Transport","_channelOpen","_callbacks","setCallbacks","callbacks","this","connect","self","JSON","stringify","clientIDs","includes","length","close","addEventListener","send","msgStr","enable","targetElement","target","tagName","parentElement","__PHOENIX_EMBED_INFO","isTauri","getAttribute","parent","handlerName","eventName","stopImmediatePropagation","preventDefault","activeElement","body","focus","key","TRUSTED_ORIGINS_EMBED","origin"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// This is a transport injected into the browser via a script that handles the low\n// level communication between the live development protocol handlers on both sides.\n// The actual communication to phoenix is done via the loaded web worker below. We just post/receive all\n// messages that should be sent/received by live preview to the worker. The worker will use broadcast\n// channels in browser and web sockets in desktop builds to rely on the message to phoenix.\n/**\n * Communication Architecture in PHCode.dev Browser Environment\n * ------------------------------------------------------------\n *\n * First of all I like to apologize for this complexity, it is how it is due to the browser standards security\n * policy, intelligent tracking prevention in browsers and the inherent multiprocess communication problem.\n * The dining philosophers can however take rest as the mechanism is fully lockless thanks to how js handles events.\n *\n * Overview:\n * PHCode.dev operates with a multi-iframe setup to facilitate communication between different components\n * within the same domain(phcode.dev) and cross domain(phcode.dev<>phcode.live). Live previews have to be domain\n * isolated to phcode.live domain so that malicious project live previews doesn't steal phcode.dev cookies and\n * take control of the users account by just opening a live preview.\n * This setup includes a preview page(phcode.dev/live-preview-loader.html), a server iframe (phcode.live), and an actual\n * preview iframe where the user's code is rendered(phcode.live/user/projoject/live/preview.html).\n *\n * Components:\n * 1. Preview Page (phcode.dev):\n *    - Serves as the primary interface for the user. The actual tab.\n *    - Hosts two iframes: the server iframe and the actual preview iframe.\n *\n * 2. Server Iframe (phcode.live):\n *    - Responsible for installing a service worker for virtual server, sandboxed to its specific tab.\n *    - Acts as an intermediary in the communication chain.\n *\n * 3. Actual Preview Iframe: (phcode.live/user/projoject/live/preview.html)\n *    - Renders the user's code.\n *    - Utilizes a broadcast channel within the web worker to send messages. We use a web worker so\n *      that live preview tab hearbeat messages are sent to the editor even if the user is debugging\n *      the page causing js execution to halt in the debugging thread but not the worker thread.\n *\n * Communication Flow:\n * 1. Messages originate from the Actual Preview Iframe, where the user's script is loaded.\n * 2. These messages are sent to the Live Preview Server Iframe via a broadcast channel in the service worker.\n * 3. The Server Iframe then relays these messages to the parent PHCode.dev frame.\n * 4. Finally, the PHCode.dev frame forwards these messages to the PHCode.dev editor page.\n *    - This step occurs if the editor page is loaded in a different tab and not as an in-editor live preview panel.\n *\n * Note on Communication Constraints and Solutions:\n * ------------------------------------------------\n *  Cross-Domain Communication Limitations:\n *  - The default security model of web browsers restricts cross-domain communication as a measure to preserve security.\n *  - This means that iframes from different domains cannot freely communicate with each other due to\n *    browser-enforced sandboxing.\n *\n *  Use of Broadcast Channels within the Same Domain:\n *  - To circumvent these cross-domain communication restrictions, PHCode.dev employs broadcast channels within\n *    the same domain.\n *\n *  Solution for Cross-Domain Communication:\n *  - The architecture is designed to avoid direct cross-domain communication, which is restricted by\n *    the browser's security model.\n *  - Instead, a 'hoola hoop' method is used where the server Iframe (phcode.live) relays broadcast channel\n *    messages in phcode.live to its cross domain parent window phcode.dev through window post message apis.\n *  - The parent PHCode.dev frame further communicates with the PHCode.dev editor page, if its in a different tab.\n *\n *  Working within Browser Security Framework:\n *  - This approach allows the system to operate within the browser's security constraints.\n *  - It eliminates the need for server-side assistance, thus enabling instant live preview\n *    feedback in a purely client-side setting.\n **/\n\n\n(function (global) {\n\n    // The below line will be replaced with the transport scripts provided by the static server at\n    // LivePreviewTransport.js:getRemoteScript() This is so that the actual live preview page doesnt get hold of\n    // any phoenix web socket or broadcast channel ids from this closure programatically for security.\n\n    //Replace dynamic section start\n    const TRANSPORT_CONFIG={};\n    //Replace dynamic section end\n\n    function _debugLog(...args) {\n        if(window.LIVE_PREVIEW_DEBUG_ENABLED) {\n            console.log(...args);\n        }\n    }\n\n    const clientID = \"\" + Math.round( Math.random()*1000000000);\n\n    const worker = new Worker(TRANSPORT_CONFIG.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME);\n    let _workerMessageProcessor;\n    worker.onmessage = (event) => {\n        const type = event.data.type;\n        switch (type) {\n        case 'REDIRECT_PAGE': location.href = event.data.URL; break;\n        default:\n            if(_workerMessageProcessor){\n                return _workerMessageProcessor(event);\n            }\n            console.error(\"Live Preview page loader: received unknown message from worker:\", event);\n        }\n    };\n    // message channel to phoenix connect on load itself. The channel id is injected from phoenix\n    // via LivePreviewTransport.js while serving the instrumented html file\n    worker.postMessage({\n        type: \"setupPhoenixComm\",\n        livePreviewDebugModeEnabled: TRANSPORT_CONFIG.LIVE_PREVIEW_DEBUG_ENABLED,\n        broadcastChannel: TRANSPORT_CONFIG.LIVE_PREVIEW_BROADCAST_CHANNEL_ID, // in browser this will be present, but not in tauri\n        websocketChannelURL: TRANSPORT_CONFIG.LIVE_PREVIEW_WEBSOCKET_CHANNEL_URL, // in tauri this will be present. not in browser\n        clientID\n    });\n    function _postLivePreviewMessage(message) {\n        worker.postMessage({type: \"livePreview\", message});\n    }\n    let sentTitle, sentFavIconURL;\n\n    function convertImgToBase64(url, callback) {\n        if(!url){\n            callback(null);\n            return;\n        }\n        let canvas = document.createElement('CANVAS');\n        const ctx = canvas.getContext('2d');\n        const img = new Image();\n        img.crossOrigin = 'Anonymous';\n        img.onload = function() {\n            canvas.height = img.height;\n            canvas.width = img.width;\n            ctx.drawImage(img, 0, 0);\n            const dataURL = canvas.toDataURL();\n            callback(dataURL);\n            canvas = null;\n        };\n        img.src = url;\n    }\n\n    setInterval(()=>{\n        const favIcon = document.querySelector(\"link[rel~='icon']\");\n        const faviconUrl = favIcon && favIcon.href;\n        if(sentFavIconURL !== faviconUrl){\n            sentFavIconURL = faviconUrl;\n            convertImgToBase64(faviconUrl, function(base64) {\n                if(!base64){\n                    base64 = \"favicon.ico\";\n                }\n                worker.postMessage({\n                    type: \"updateTitleIcon\",\n                    faviconBase64: base64\n                });\n            });\n        }\n\n        if(sentTitle!== document.title) {\n            sentTitle = document.title;\n            worker.postMessage({\n                type: \"updateTitleIcon\",\n                title: document.title\n            });\n        }\n    }, 1000);\n\n    global._Brackets_LiveDev_Transport = {\n        _channelOpen: false,\n\n        /**\n         * @private\n         * An object that contains callbacks to handle various transport events. See `setCallbacks()`.\n         * @type {?{connect: ?function, message: ?function(string), close: ?function}}\n         */\n        _callbacks: null,\n\n        /**\n         * Sets the callbacks that should be called when various transport events occur. All callbacks\n         * are optional, but you should at least implement \"message\" or nothing interesting will happen :)\n         * @param {?{connect: ?function, message: ?function(string), close: ?function}} callbacks\n         *      The callbacks to set.\n         *      connect - called when a connection is established to Brackets\n         *      message(msgStr) - called with a string message sent from Brackets\n         *      close - called when Brackets closes the connection\n         */\n        setCallbacks: function (callbacks) {\n            this._callbacks = callbacks;\n        },\n\n        /**\n         * Connects to the LivePreviewTransport in Brackets.\n         */\n        connect: function () {\n            const self = this;\n\n            // Listen to the response\n            _workerMessageProcessor = (event) => {\n                // Print the result\n                _debugLog(\"Live Preview: Browser received event from Phoenix: \", JSON.stringify(event.data));\n                const type = event.data.type;\n                switch (type) {\n                case 'BROWSER_CONNECT': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_MESSAGE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'BROWSER_CLOSE': break; // do nothing. This is a loopback message from another live preview tab\n                case 'MESSAGE_FROM_PHOENIX':\n                    if (self._callbacks && self._callbacks.message) {\n                        const clientIDs = event.data.clientIDs,\n                            message = event.data.message;\n                        if(clientIDs.includes(clientID) || clientIDs.length === 0){\n                            // clientIDs.length = 0 if the message is intended for all clients\n                            self._callbacks.message(message);\n                        }\n                    }\n                    break;\n                case 'PHOENIX_CLOSE':\n                    self._channelOpen = false;\n                    if (self._callbacks && self._callbacks.close) {\n                        self._callbacks.close();\n                    }\n                    break;\n                }\n            };\n            _postLivePreviewMessage({\n                type: 'BROWSER_CONNECT',\n                url: global.location.href,\n                clientID: clientID\n            });\n            self._channelOpen = true;\n            if (self._callbacks && self._callbacks.connect) {\n                self._callbacks.connect();\n            }\n\n            // attach to browser tab/window closing event so that we send a cleanup request\n            // to the service worker for the comm ports\n            addEventListener( 'beforeunload', function() {\n                if(self._channelOpen){\n                    self._channelOpen = false;\n                    _postLivePreviewMessage({\n                        type: 'BROWSER_CLOSE',\n                        clientID: clientID\n                    });\n                }\n            });\n        },\n\n        /**\n         * Sends a message over the transport.\n         * @param {string} msgStr The message to send.\n         */\n        send: function (msgStr) {\n            _postLivePreviewMessage({\n                type: 'BROWSER_MESSAGE',\n                clientID: clientID,\n                message: msgStr\n            });\n        },\n\n        /**\n         * Establish web socket connection.\n         */\n        enable: function () {\n            this.connect();\n        }\n    };\n\n    function getAbsoluteUrl(url) {\n        // Check if the URL is already absolute\n        if (/^(?:[a-z]+:)?\\/\\//i.test(url)) {\n            return url; // The URL is already absolute\n        }\n\n        // If not, create an absolute URL using the current page's location as the base\n        const absoluteUrl = new URL(url, window.location.href);\n        return absoluteUrl.href;\n    }\n\n    // This is only for tauri builds where the live preview is embedded in the phoenix editor iframe. on clicking\n    // any urls that needs to be open in a browser window, we execute this. In browser, this is no-op as there is\n    // no corresponding listener attached in phoenix browser server.\n    document.addEventListener('click', function(event) {\n        let targetElement = event.target;\n        // Traverse one level up the DOM to find an anchor element if the target is not the anchor itself\n        // eg when image inside anchor elements etc..: <a><img></img></a>\n        if (targetElement !== null && targetElement.tagName !== 'A') {\n            targetElement = targetElement.parentElement;\n        }\n\n        if (window.__PHOENIX_EMBED_INFO && window.__PHOENIX_EMBED_INFO.isTauri &&\n            targetElement && targetElement.tagName === 'A' && (targetElement.target === '_blank')) {\n            // in desktop phoenix builds, tauri will not open anchor tags in browser if it is in\n            // an iframe(except for the intel mac bug)\n            // in normal browsers, we dont need to do this and the borwser will do its thing.\n            const href = getAbsoluteUrl(targetElement.getAttribute('href'));\n            window.parent.postMessage({\n                handlerName: \"ph-liveServer\",\n                eventName: 'embeddedIframeHrefClick',\n                href: href\n            }, \"*\");\n            // in intel mac desktop, tauri seems to open in browser\n            // causing 2 tabs to open. in m1 macs its not there. so we prevent default behavior.\n            event.stopImmediatePropagation();\n            event.preventDefault();\n        }\n    }, true);\n    document.addEventListener('contextmenu', function(event) {\n        (document.activeElement || document.body).focus();\n    });\n    document.addEventListener('keydown', function(event) {\n        if (window.__PHOENIX_EMBED_INFO &&\n            (event.key === 'Escape' || event.key === 'Esc')) { // Check for Escape key\n            // Perform the desired action for the Escape key only if its within iframe inside phoenix\n            window.parent.postMessage({\n                handlerName: \"ph-liveServer\",\n                eventName: 'embeddedEscapeKeyPressed'\n            }, \"*\");\n        }\n    });\n\n    // this is for managing who am i context in iframes embedded in phoenix to have special handling.\n    window.addEventListener('message', function(event) {\n        if (!TRANSPORT_CONFIG.TRUSTED_ORIGINS_EMBED[event.origin]) {\n            return; // Ignore messages from unexpected origins\n        }\n\n        window.__PHOENIX_EMBED_INFO = {\n            isTauri: event.data.isTauri\n        };\n    });\n    if(window.self !== window.parent){\n        // in an iframe\n        window.parent.postMessage({\n            handlerName: \"ph-liveServer\",\n            eventName: 'whoAmIframePhoenix',\n            href: location.href\n        }, \"*\");\n    }\n}(this));\n"],"file":"LivePreviewTransportRemote.js"}
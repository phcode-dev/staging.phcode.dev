{"version":3,"sources":["LiveDevelopment/Agents/DOMHelpers.js"],"names":["define","DOMHelpersModule","require","exports","module","_isQuote","c","escape","quote","undefined","_removeQuotes","src","length","q","substr","replace","_find","match","skip","quotes","comments","i","activeQuote","isComment","search","_findEach","callback","from","to","_findTag","inc","toLowerCase","_extractAttributes","content","index","key","value","attributes","each","item","trim","extractPayload","payload","nodeType","nodeValue","nodeName","exec","toUpperCase","closing","closed","eachNode","text","range","test","sourceOffset","sourceLength"],"mappings":"AA0BAA,OAAO,SAASC,iBAAiBC,QAASC,QAASC,QAQ/C,SAASC,SAASC,EAAGC,OAAQC,OACzB,MAAe,OAAXD,cAGUE,IAAVD,MACOF,IAAME,MAEJ,MAANF,GAAoB,MAANA,GAMzB,SAASI,cAAcC,KACnB,GAAIN,SAASM,IAAI,KAAOA,IAAIA,IAAIC,OAAS,KAAOD,IAAI,GAAI,CACpD,IAAIE,EAAIF,IAAI,GAEZA,KADAA,IAAMA,IAAIG,OAAO,EAAGH,IAAIC,OAAS,IACvBG,QAAQ,KAAOF,EAAGA,GAEhC,OAAOF,IAUX,SAASK,MAAML,IAAKM,MAAOC,KAAMC,OAAQC,UAChB,iBAAVH,QACPA,MAAQ,CAACA,MAAOA,MAAML,cAEbH,IAATS,OACAA,KAAO,GAEX,IAAIG,EAAGC,YAAaC,WAAY,EAChC,IAAKF,EAAIH,KAAMG,EAAIV,IAAIC,OAAQS,IAC3B,GAAIF,QAAUd,SAASM,IAAIU,GAAIV,IAAIU,EAAI,GAAIC,aAEvCA,YAAcA,iBAAcb,EAAYE,IAAIU,QACzC,IAAKC,YACR,GAAIF,WAAaG,WAAaZ,IAAIG,OAAOO,EAAGD,SAAS,GAAGR,UAAYQ,SAAS,GAEzEG,WAAY,EACZF,GAAKD,SAAS,GAAGR,OAAS,OACvB,GAAIW,UAEHZ,IAAIG,OAAOO,EAAGD,SAAS,GAAGR,UAAYQ,SAAS,KAC/CG,WAAY,EACZF,GAAKD,SAAS,GAAGR,OAAS,QAE3B,GAAiD,IAA7CD,IAAIG,OAAOO,EAAGJ,MAAM,IAAIO,OAAOP,MAAM,IAE5C,OAAOI,EAInB,OAAQ,EAIZ,SAASI,UAAUd,IAAKM,MAAOE,OAAQC,SAAUM,UAG7C,IAFA,IAAIC,KAAO,EACPC,GACGD,KAAOhB,IAAIC,SACdgB,GAAKZ,MAAML,IAAKM,MAAOU,KAAMR,OAAQC,WAC5B,IACLQ,GAAKjB,IAAIC,QAEbc,SAASf,IAAIG,OAAOa,KAAMC,GAAKD,OAC/BA,KAAOC,GAAK,EAQpB,SAASC,SAASlB,IAAKO,MACnB,IAAIS,KAAMC,GAAIE,IAEd,OADAH,KAAOX,MAAML,IAAK,CAAC,aAAc,GAAIO,OAC1B,EACA,MAEiB,YAAxBP,IAAIG,OAAOa,KAAM,IAEjBC,GAAKZ,MAAML,IAAK,SAAOgB,KAAO,GAC9BG,IAAM,GACuC,YAAtCnB,IAAIG,OAAOa,KAAM,GAAGI,eAE3BH,GAAKZ,MAAML,IAAIoB,cAAe,aAAaJ,KAAO,GAClDG,IAAM,GACuC,WAAtCnB,IAAIG,OAAOa,KAAM,GAAGI,eAE3BH,GAAKZ,MAAML,IAAIoB,cAAe,WAAYJ,KAAO,GACjDG,IAAM,IAENF,GAAKZ,MAAML,IAAK,IAAKgB,KAAO,GAAG,GAC/BG,IAAM,GAENF,GAAK,EACE,KAEJ,CAACD,KAAMA,KAAMf,OAAQgB,GAAKE,IAAMH,OAM3C,SAASK,mBAAmBC,SAKxB,GAAuB,KADvBA,SADAA,QAAUA,QAAQlB,QAAQ,WAAY,KACpBA,QAAQ,WAAY,KAC1BH,OAAZ,CAKA,IAAIsB,MAAOC,IAAKC,MACZC,WAAa,GAmBjB,OAlBAZ,UAAUQ,QAAS,CAAC,KAAM,IAAI,OAAMxB,EAAW,SAAS6B,KAAKC,OACzDL,MAAQK,KAAKf,OAAO,MACR,GAMO,KADnBW,IAAMI,KAAKzB,OAAO,EAAGoB,OAAOM,QACpB5B,SAMRwB,MAAQ1B,cADR0B,MAAQG,KAAKzB,OAAOoB,MAAQ,GAAGM,QAE/BH,WAAWF,KAAOC,SAGfC,YAMX,SAASI,eAAeR,SACpB,IAAIS,QAAU,GAoCd,MAlCmB,MAAfT,QAAQ,IAERS,QAAQC,SAAW,EACnBD,QAAQE,UAAYX,SACY,YAAzBA,QAAQnB,OAAO,EAAG,IAEzB4B,QAAQC,SAAW,EACnBD,QAAQE,UAAYX,QAAQnB,OAAO,EAAGmB,QAAQrB,OAAS,IACjC,MAAfqB,QAAQ,GAEfS,QAAQC,SAAW,IAGnBD,QAAQC,SAAW,EACnBD,QAAQG,SAAW,cAAcC,KAAKb,SAAS,GAAGc,cAClDL,QAAQL,WAAaL,mBAAmBC,SAGZ,MAAxBS,QAAQG,SAAS,KACjBH,QAAQG,SAAWH,QAAQG,SAAS/B,OAAO,GAC3C4B,QAAQM,SAAU,GAIc,MAAhCf,QAAQA,QAAQrB,OAAS,KACzB8B,QAAQO,QAAS,GAKI,WAArBP,QAAQG,UAA8C,UAArBH,QAAQG,WACzCH,QAAQO,QAAS,IAGlBP,QAQX,SAASQ,SAASvC,IAAKe,UAGnB,IAFA,IAAIQ,MAAQ,EACRiB,KAAMC,MAAOxC,OAAQ8B,QAClBR,MAAQvB,IAAIC,SAGfwC,MAAQvB,SAASlB,IAAKuB,UAElBkB,MAAQ,CAAEzB,KAAMhB,IAAIC,OAAQA,OAAQ,KAIxCA,OAASwC,MAAMzB,KAAOO,OACT,IACTiB,KAAOxC,IAAIG,OAAOoB,MAAOtB,QACrB,KAAKyC,KAAKF,SACVT,QAAUD,eAAeU,OACjBG,aAAepB,MACvBQ,QAAQa,aAAe3C,OACvBc,SAASgB,WAKbU,MAAMxC,OAAS,KACf8B,QAAUD,eAAe9B,IAAIG,OAAOsC,MAAMzB,KAAMyB,MAAMxC,UAC9C0C,aAAeF,MAAMzB,KAC7Be,QAAQa,aAAeH,MAAMxC,OAC7Bc,SAASgB,UAIbR,MAAQkB,MAAMzB,KAAOyB,MAAMxC,OAKnCT,QAAQsC,eAAiBA,eACzBtC,QAAQ+C,SAAWA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\n/**\n * DOMHelpers is a collection of functions used by the DOMAgent exports `eachNode(src, callback)`\n */\ndefine(function DOMHelpersModule(require, exports, module) {\n\n\n    /** Test if the given character is a quote character\n     * {char} source character\n     * {char} escape (previous) character\n     * {char} quote character\n     */\n    function _isQuote(c, escape, quote) {\n        if (escape === \"\\\\\") {\n            return false;\n        }\n        if (quote !== undefined) {\n            return c === quote;\n        }\n        return c === \"\\\"\" || c === \"'\";\n    }\n\n    /** Remove quotes from the string and adjust escaped quotes\n     * @param {string} source string\n     */\n    function _removeQuotes(src) {\n        if (_isQuote(src[0]) && src[src.length - 1] === src[0]) {\n            var q = src[0];\n            src = src.substr(1, src.length - 2);\n            src = src.replace(\"\\\\\" + q, q);\n        }\n        return src;\n    }\n\n    /** Find the next match using several constraints\n     * @param {string} source string\n     * @param {string} or [{regex}, {length}] the match definition\n     * @param {integer} ignore characters before this offset\n     * @param {boolean} watch for quotes\n     * @param [{string},{string}] watch for comments\n     */\n    function _find(src, match, skip, quotes, comments) {\n        if (typeof match === \"string\") {\n            match = [match, match.length];\n        }\n        if (skip === undefined) {\n            skip = 0;\n        }\n        var i, activeQuote, isComment = false;\n        for (i = skip; i < src.length; i++) {\n            if (quotes && _isQuote(src[i], src[i - 1], activeQuote)) {\n                // starting quote\n                activeQuote = activeQuote ? undefined : src[i];\n            } else if (!activeQuote) {\n                if (comments && !isComment && src.substr(i, comments[0].length) === comments[0]) {\n                    // opening comment\n                    isComment = true;\n                    i += comments[0].length - 1;\n                } else if (isComment) {\n                    // we are commented\n                    if (src.substr(i, comments[1].length) === comments[1]) {\n                        isComment = false;\n                        i += comments[1].length - 1;\n                    }\n                } else if (src.substr(i, match[1]).search(match[0]) === 0) {\n                    // match\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /** Callback iterator using `_find` */\n    function _findEach(src, match, quotes, comments, callback) {\n        var from = 0;\n        var to;\n        while (from < src.length) {\n            to = _find(src, match, from, quotes, comments);\n            if (to < 0) {\n                to = src.length;\n            }\n            callback(src.substr(from, to - from));\n            from = to + 1;\n        }\n    }\n\n    /** Find the next tag\n     * @param {string} source string\n     * @param {integer} ignore characters before this offset\n     */\n    function _findTag(src, skip) {\n        var from, to, inc;\n        from = _find(src, [/<[a-z!\\/]/i, 2], skip);\n        if (from < 0) {\n            return null;\n        }\n        if (src.substr(from, 4) === \"<!--\") {\n            // html comments\n            to = _find(src, \"-->\", from + 4);\n            inc = 3;\n        } else if (src.substr(from, 7).toLowerCase() === \"<script\") {\n            // script tag\n            to = _find(src.toLowerCase(), \"</script>\", from + 7);\n            inc = 9;\n        } else if (src.substr(from, 6).toLowerCase() === \"<style\") {\n            // style tag\n            to = _find(src.toLowerCase(), \"</style>\", from + 6);\n            inc = 8;\n        } else {\n            to = _find(src, \">\", from + 1, true);\n            inc = 1;\n        }\n        if (to < 0) {\n            return null;\n        }\n        return {from: from, length: to + inc - from};\n    }\n\n    /** Extract tag attributes from the given source of a single tag\n     * @param {string} source content\n     */\n    function _extractAttributes(content) {\n\n        // remove the node name and the closing bracket and optional slash\n        content = content.replace(/^<\\S+\\s*/, \"\");\n        content = content.replace(/\\s*\\/?>$/, \"\");\n        if (content.length === 0) {\n            return;\n        }\n\n        // go through the items and identify key value pairs split by =\n        var index, key, value;\n        var attributes = {};\n        _findEach(content, [/\\s/, 1], true, undefined, function each(item) {\n            index = item.search(\"=\");\n            if (index < 0) {\n                return;\n            }\n\n            // get the key\n            key = item.substr(0, index).trim();\n            if (key.length === 0) {\n                return;\n            }\n\n            // get the value\n            value = item.substr(index + 1).trim();\n            value = _removeQuotes(value);\n            attributes[key] = value;\n        });\n\n        return attributes;\n    }\n\n    /** Extract the node payload\n     * @param {string} source content\n     */\n    function extractPayload(content) {\n        var payload = {};\n\n        if (content[0] !== \"<\") {\n            // text\n            payload.nodeType = 3;\n            payload.nodeValue = content;\n        } else if (content.substr(0, 4) === \"<!--\") {\n            // comment\n            payload.nodeType = 8;\n            payload.nodeValue = content.substr(4, content.length - 7);\n        } else if (content[1] === \"!\") {\n            // doctype\n            payload.nodeType = 10;\n        } else {\n            // regular element\n            payload.nodeType = 1;\n            payload.nodeName = /^<([^>\\s]+)/.exec(content)[1].toUpperCase();\n            payload.attributes = _extractAttributes(content);\n\n            // closing node (/ at the beginning)\n            if (payload.nodeName[0] === \"/\") {\n                payload.nodeName = payload.nodeName.substr(1);\n                payload.closing = true;\n            }\n\n            // closed node (/ at the end)\n            if (content[content.length - 2] === \"/\") {\n                payload.closed = true;\n            }\n\n            // Special handling for script/style tag since we've already collected\n            // everything up to the end tag.\n            if (payload.nodeName === \"SCRIPT\" || payload.nodeName === \"STYLE\") {\n                payload.closed = true;\n            }\n        }\n        return payload;\n    }\n\n    /** Split the source string into payloads representing individual nodes\n     * @param {string} source\n     * @param {function(payload)} callback\n     */\n    // split a string into individual node contents\n    function eachNode(src, callback) {\n        var index = 0;\n        var text, range, length, payload;\n        while (index < src.length) {\n\n            // find the next tag\n            range = _findTag(src, index);\n            if (!range) {\n                range = { from: src.length, length: 0 };\n            }\n\n            // add the text before the tag\n            length = range.from - index;\n            if (length > 0) {\n                text = src.substr(index, length);\n                if (/\\S/.test(text)) {\n                    payload = extractPayload(text);\n                    payload.sourceOffset = index;\n                    payload.sourceLength = length;\n                    callback(payload);\n                }\n            }\n\n            // add the tag\n            if (range.length > 0) {\n                payload = extractPayload(src.substr(range.from, range.length));\n                payload.sourceOffset = range.from;\n                payload.sourceLength = range.length;\n                callback(payload);\n            }\n\n            // advance\n            index = range.from + range.length;\n        }\n    }\n\n    // Export public functions\n    exports.extractPayload = extractPayload;\n    exports.eachNode = eachNode;\n});\n"],"file":"DOMHelpers.js"}
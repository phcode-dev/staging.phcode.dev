{"version":3,"sources":["LiveDevelopment/LiveDevMultiBrowser.js"],"names":["define","require","exports","module","STATUS_INACTIVE","STATUS_CONNECTING","STATUS_ACTIVE","STATUS_OUT_OF_SYNC","STATUS_SYNC_ERROR","STATUS_RELOADING","STATUS_RESTARTING","EVENT_OPEN_PREVIEW_URL","EVENT_CONNECTION_CLOSE","EVENT_STATUS_CHANGE","Dialogs","DefaultDialogs","DocumentManager","EditorManager","EventDispatcher","FileUtils","MainViewManager","PreferencesDialogs","ProjectManager","Strings","_","LiveDevelopmentUtils","LiveDevServerManager","LivePreviewTransport","LiveDevProtocol","Metrics","PageLoaderWorkerScript","LiveCSSDocument","LiveHTMLDocument","_liveDocument","livePreviewUrlPinned","_relatedDocuments","_protocol","_server","_classForDocument","doc","getLanguage","getId","isHtmlFileExt","file","fullPath","isActive","status","getLiveDocForPath","path","get","_closeDocument","liveDocument","off","close","_handleRelatedDocumentDeleted","url","liveDoc","remove","_setStatus","closeReason","reason","trigger","_closeDocuments","undefined","Object","keys","forEach","clear","_resolveUrl","pathToUrl","_createLiveDocument","editor","roots","DocClass","on","event","hasErrors","_docIsOutOfSync","isLiveEditingEnabled","isDirty","_styleSheetAdded","urlToPath","alreadyAdded","docPromise","getDocumentForPath","done","_masterEditor","add","_updateBrowser","_getInitialDocFromCurrent","getCurrentDocument","refPath","i","isStaticHtmlFileExt","isServerHtmlFileExt","$","Deferred","resolve","result","baseUrl","getBaseUrl","hasOwnServerForLiveDevelopment","length","getAllFiles","allFiles","projectRoot","getProjectRoot","containingFolder","indexFileFound","stillInProjectTree","getDirectoryPath","filteredFiltered","filter","item","parent","getParentPath","indexOf","filterIndexFile","fileInfo","getFilenameWithoutExtension","name","findIndex","then","promise","_close","doCloseWindow","closeAllConnections","stop","_showLiveDevServerNotReadyError","showModalDialog","DIALOG_ID_ERROR","LIVE_DEVELOPMENT_ERROR_TITLE","LIVE_DEV_SERVER_NOT_READY_MESSAGE","_createLiveDocumentForFrame","_ensureMasterEditor","addVirtualContentAtPath","parentPath","LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME","getRemoteScriptContents","LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME","_launch","_open","navigate","msg","getConnectionIds","URL","urlString","origin","pathname","countEvent","EVENT_TYPE","LIVE_PREVIEW","clientId","window","logger","livePreview","log","relatedDocs","related","docs","stylesheets","href","EVENT_LIVE_PREVIEW_CLICKED","EVENT_LIVE_PREVIEW_RELOAD","clients","console","error","_doLaunchAfterServerReady","initialDoc","start","_prepareServer","deferred","showBaseUrlPrompt","getServer","showProjectPreferencesDialog","LIVE_DEV_NEED_BASEURL_MESSAGE","id","DIALOG_BTN_OK","reject","readyPromise","readyToServe","_onFileChange","docUrl","isViewable","canServe","open","prepareServerPromise","fail","_onDocumentSaved","absolutePath","liveEditingEnabled","isRelated","reload","_onDirtyFlagChange","setTransport","transport","init","config","getLiveDocForEditor","document","showHighlight","getActiveEditor","updateHighlight","hideHighlight","evaluate","redrawHighlight","reconnect","setLivePreviewPinned","urlPinned","getCurrentProjectServerConfig","pathResolver","makeProjectRelativeIfPossible","root","getServerBaseUrl","getCurrentLiveDoc","getLivePreviewDetails","getLivePreviewBaseURL","getStaticServerBaseURLs","projectBaseURL","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * LiveDevelopment allows Brackets to launch a browser with a \"live preview\" that's\n * connected to the current editor.\n *\n * # STARTING\n *\n * To start a session call `open`. This will read the currentDocument from brackets,\n * launch it in the default browser, and connect to it for live editing.\n *\n * # STOPPING\n *\n * To stop a session call `close`. This will close the connection to the browser\n * (but will not close the browser tab).\n *\n * # STATUS\n *\n * Status updates are dispatched as `statusChange` jQuery events. The status\n * is passed as the first parameter and the reason for the change as the second\n * parameter. Currently only the \"Inactive\" status supports the reason parameter.\n * The status codes are:\n *\n *  0: Inactive\n *  1: Connecting (waiting for a browser connection)\n *  2: Active\n *  3: Out of sync\n *  4: Sync error\n *  5: Reloading (after saving JS changes)\n *  6: Restarting (switching context to a new HTML live doc)\n *\n * The reason codes are:\n * - null (Unknown reason)\n * - \"explicit_close\" (LiveDevelopment.close() was called)\n * - \"navigated_away\" (The browser changed to a location outside of the project)\n * - \"detached_target_closed\" (The tab or window was closed)\n */\ndefine(function (require, exports, module) {\n\n\n    // Status Codes\n    const STATUS_INACTIVE      = exports.STATUS_INACTIVE       =  0;\n    const STATUS_CONNECTING    = exports.STATUS_CONNECTING     =  1;\n    const STATUS_ACTIVE        = exports.STATUS_ACTIVE         =  2;\n    const STATUS_OUT_OF_SYNC   = exports.STATUS_OUT_OF_SYNC    =  3;\n    const STATUS_SYNC_ERROR    = exports.STATUS_SYNC_ERROR     =  4;\n    const STATUS_RELOADING     = exports.STATUS_RELOADING      =  5;\n    const STATUS_RESTARTING    = exports.STATUS_RESTARTING     =  6;\n\n    // events\n    const EVENT_OPEN_PREVIEW_URL = \"openPreviewURL\",\n        EVENT_CONNECTION_CLOSE = \"ConnectionClose\",\n        EVENT_STATUS_CHANGE = \"statusChange\";\n\n    const Dialogs              = require(\"widgets/Dialogs\"),\n        DefaultDialogs       = require(\"widgets/DefaultDialogs\"),\n        DocumentManager      = require(\"document/DocumentManager\"),\n        EditorManager        = require(\"editor/EditorManager\"),\n        EventDispatcher      = require(\"utils/EventDispatcher\"),\n        FileUtils            = require(\"file/FileUtils\"),\n        MainViewManager      = require(\"view/MainViewManager\"),\n        PreferencesDialogs   = require(\"preferences/PreferencesDialogs\"),\n        ProjectManager       = require(\"project/ProjectManager\"),\n        Strings              = require(\"strings\"),\n        _                    = require(\"thirdparty/lodash\"),\n        LiveDevelopmentUtils = require(\"LiveDevelopment/LiveDevelopmentUtils\"),\n        LiveDevServerManager = require(\"LiveDevelopment/LiveDevServerManager\"),\n        LivePreviewTransport  = require(\"LiveDevelopment/MultiBrowserImpl/transports/LivePreviewTransport\"),\n        LiveDevProtocol      = require(\"LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol\"),\n        Metrics              = require(\"utils/Metrics\"),\n        PageLoaderWorkerScript = require(\"text!LiveDevelopment/BrowserScripts/pageLoaderWorker.js\");\n\n    // Documents\n    const LiveCSSDocument      = require(\"LiveDevelopment/MultiBrowserImpl/documents/LiveCSSDocument\"),\n        LiveHTMLDocument     = require(\"LiveDevelopment/MultiBrowserImpl/documents/LiveHTMLDocument\");\n\n    /**\n     * @private\n     * The live HTML document for the currently active preview.\n     * @type {LiveHTMLDocument}\n     */\n    var _liveDocument;\n\n    /**\n     * Live preview only tracks the pinned document.\n     * @type {boolean}\n     */\n    let livePreviewUrlPinned = false;\n\n    /**\n     * @private\n     * Live documents related to the active HTML document - for example, CSS files\n     * that are used by the document.\n     * @type {Object.<string: {LiveHTMLDocument|LiveCSSDocument}>}\n     */\n    var _relatedDocuments = {};\n\n    /**\n     * @private\n     * Protocol handler that provides the actual live development API on top of the current transport.\n     */\n    var _protocol = LiveDevProtocol;\n\n    /**\n     * @private\n     * Current live preview server\n     * @type {BaseServer}\n     */\n    var _server;\n\n    /**\n     * @private\n     * Determine which live document class should be used for a given document\n     * @param {Document} document The document we want to create a live document for.\n     * @return {function} The constructor for the live document class; will be a subclass of LiveDocument.\n     */\n    function _classForDocument(doc) {\n        if (doc.getLanguage().getId() === \"css\") {\n            return LiveCSSDocument;\n        }\n\n        if (LiveDevelopmentUtils.isHtmlFileExt(doc.file.fullPath)) {\n            return LiveHTMLDocument;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns true if the global Live Development mode is on (might be in the middle of connecting).\n     * @return {boolean}\n     */\n    function isActive() {\n        return exports.status > STATUS_INACTIVE;\n    }\n\n    /**\n     * Returns the live document for a given path, or null if there is no live document for it.\n     * @param {string} path\n     * @return {?LiveDocument}\n     */\n    function getLiveDocForPath(path) {\n        if (!_server) {\n            return null;\n        }\n\n        return _server.get(path);\n    }\n\n    /**\n     * @private\n     * Close a live document.\n     * @param {LiveDocument}\n     */\n    function _closeDocument(liveDocument) {\n        liveDocument.off(\".livedev\");\n        _protocol.off(\".livedev\");\n        liveDocument.close();\n    }\n\n    /**\n     * Removes the given CSS/JSDocument from _relatedDocuments. Signals that the\n     * given file is no longer associated with the HTML document that is live (e.g.\n     * if the related file has been deleted on disk).\n     * @param {string} url Absolute URL of the related document\n     */\n    function _handleRelatedDocumentDeleted(url) {\n        var liveDoc = _relatedDocuments[url];\n        if (liveDoc) {\n            delete _relatedDocuments[url];\n        }\n\n        if (_server) {\n            _server.remove(liveDoc);\n        }\n        _closeDocument(liveDoc);\n    }\n\n    /**\n     * Update the status. Triggers a statusChange event.\n     * @param {number} status new status\n     * @param {?string} closeReason Optional string key suffix to display to\n     *     user when closing the live development connection (see LIVE_DEV_* keys)\n     */\n    function _setStatus(status, closeReason) {\n        // Don't send a notification when the status didn't actually change\n        if (status === exports.status) {\n            return;\n        }\n\n        exports.status = status;\n\n        var reason = status === STATUS_INACTIVE ? closeReason : null;\n        exports.trigger(EVENT_STATUS_CHANGE, status, reason);\n    }\n\n    /**\n     * @private\n     * Close all live documents.\n     */\n    function _closeDocuments() {\n        if (_liveDocument) {\n            _closeDocument(_liveDocument);\n            _liveDocument = undefined;\n        }\n\n        Object.keys(_relatedDocuments).forEach(function (url) {\n            _closeDocument(_relatedDocuments[url]);\n            delete _relatedDocuments[url];\n        });\n\n        // Clear all documents from request filtering\n        if (_server) {\n            _server.clear();\n        }\n    }\n\n    /**\n     * @private\n     * Returns the URL that we would serve the given path at.\n     * @param {string} path\n     * @return {string}\n     */\n    function _resolveUrl(path) {\n        return _server && _server.pathToUrl(path);\n    }\n\n    /**\n     * @private\n     * Create a LiveDocument for a Brackets editor/document to manage communication between the\n     * editor and the browser.\n     * @param {Document} doc\n     * @param {Editor} editor\n     * @param {roots} roots\n     * @return {?LiveDocument} The live document, or null if this type of file doesn't support live editing.\n     */\n    function _createLiveDocument(doc, editor, roots) {\n        var DocClass = _classForDocument(doc),\n            liveDocument;\n\n        if (!DocClass) {\n            return null;\n        }\n\n        liveDocument = new DocClass(_protocol, _resolveUrl, doc, editor, roots);\n\n        liveDocument.on(\"errorStatusChanged.livedev\", function (event, hasErrors) {\n            if (isActive()) {\n                _setStatus(hasErrors ? STATUS_SYNC_ERROR : STATUS_ACTIVE);\n            }\n        });\n\n        return liveDocument;\n    }\n\n    /**\n     * Documents are considered to be out-of-sync if they are dirty and\n     * do not have \"update while editing\" support\n     * @param {Document} doc\n     * @return {boolean}\n     */\n    function _docIsOutOfSync(doc) {\n        var liveDoc = _server && _server.get(doc.file.fullPath),\n            isLiveEditingEnabled = liveDoc && liveDoc.isLiveEditingEnabled();\n\n        return doc.isDirty && !isLiveEditingEnabled;\n    }\n\n    /**\n     * Handles a notification from the browser that a stylesheet was loaded into\n     * the live HTML document. If the stylesheet maps to a file in the project, then\n     * creates a live document for the stylesheet and adds it to _relatedDocuments.\n     * @param {$.Event} event\n     * @param {string} url The URL of the stylesheet that was added.\n     * @param {array} roots The URLs of the roots of the stylesheet (the css files loaded through <link>)\n     */\n    function _styleSheetAdded(event, url, roots) {\n        var path = _server && _server.urlToPath(url),\n            alreadyAdded = !!_relatedDocuments[url];\n\n        // path may be null if loading an external stylesheet.\n        // Also, the stylesheet may already exist and be reported as added twice\n        // due to Chrome reporting added/removed events after incremental changes\n        // are pushed to the browser\n        if (!path || alreadyAdded) {\n            return;\n        }\n\n        var docPromise = DocumentManager.getDocumentForPath(path);\n\n        docPromise.done(function (doc) {\n            if ((_classForDocument(doc) === LiveCSSDocument) &&\n                    (!_liveDocument || (doc !== _liveDocument.doc))) {\n                var liveDoc = _createLiveDocument(doc, doc._masterEditor, roots);\n                if (liveDoc) {\n                    _server.add(liveDoc);\n                    _relatedDocuments[doc.url] = liveDoc;\n                    liveDoc.on(\"updateDoc\", function (event, url) {\n                        var path = _server.urlToPath(url),\n                            doc = getLiveDocForPath(path);\n                        doc._updateBrowser();\n                    });\n                }\n            }\n        });\n    }\n\n    /**\n     * @private\n     * Determine an index file that can be used to start Live Development.\n     * This function will inspect all files in a project to find the closest index file\n     * available for currently opened document. We are searching for these files:\n     *  - index.html\n     *  - index.htm\n     *\n     * If the project is configured with a custom base url for live development, then\n     * the list of possible index files is extended to contain these index files too:\n     *  - index.php\n     *  - index.php3\n     *  - index.php4\n     *  - index.php5\n     *  - index.phtm\n     *  - index.phtml\n     *  - index.cfm\n     *  - index.cfml\n     *  - index.asp\n     *  - index.aspx\n     *  - index.jsp\n     *  - index.jspx\n     *  - index.shm\n     *  - index.shml\n     *\n     * If a file was found, the promise will be resolved with the full path to this file. If no file\n     * was found in the whole project tree, the promise will be resolved with null.\n     *\n     * @return {jQuery.Promise} A promise that is resolved with a full path\n     * to a file if one could been determined, or null if there was no suitable index\n     * file.\n     */\n    function _getInitialDocFromCurrent() {\n        var doc = DocumentManager.getCurrentDocument(),\n            refPath,\n            i;\n\n        // Is the currently opened document already a file we can use for Live Development?\n        if (doc) {\n            refPath = doc.file.fullPath;\n            if (LiveDevelopmentUtils.isStaticHtmlFileExt(refPath) || LiveDevelopmentUtils.isServerHtmlFileExt(refPath)) {\n                return new $.Deferred().resolve(doc);\n            }\n        }\n\n        var result = new $.Deferred();\n\n        var baseUrl = ProjectManager.getBaseUrl(),\n            hasOwnServerForLiveDevelopment = (baseUrl && baseUrl.length);\n\n        ProjectManager.getAllFiles().done(function (allFiles) {\n            var projectRoot = ProjectManager.getProjectRoot().fullPath,\n                containingFolder,\n                indexFileFound = false,\n                stillInProjectTree = true;\n\n            if (refPath) {\n                containingFolder = FileUtils.getDirectoryPath(refPath);\n            } else {\n                containingFolder = projectRoot;\n            }\n\n            var filteredFiltered = allFiles.filter(function (item) {\n                var parent = FileUtils.getParentPath(item.fullPath);\n\n                return (containingFolder.indexOf(parent) === 0);\n            });\n\n            var filterIndexFile = function (fileInfo) {\n                if (fileInfo.fullPath.indexOf(containingFolder) === 0) {\n                    if (FileUtils.getFilenameWithoutExtension(fileInfo.name) === \"index\") {\n                        if (hasOwnServerForLiveDevelopment) {\n                            if ((LiveDevelopmentUtils.isServerHtmlFileExt(fileInfo.name)) ||\n                                    (LiveDevelopmentUtils.isStaticHtmlFileExt(fileInfo.name))) {\n                                return true;\n                            }\n                        } else if (LiveDevelopmentUtils.isStaticHtmlFileExt(fileInfo.name)) {\n                            return true;\n                        }\n                    } else {\n                        return false;\n                    }\n                }\n            };\n\n            while (!indexFileFound && stillInProjectTree) {\n                i = _.findIndex(filteredFiltered, filterIndexFile);\n\n                // We found no good match\n                if (i === -1) {\n                    // traverse the directory tree up one level\n                    containingFolder = FileUtils.getParentPath(containingFolder);\n                    // Are we still inside the project?\n                    if (containingFolder.indexOf(projectRoot) === -1) {\n                        stillInProjectTree = false;\n                    }\n                } else {\n                    indexFileFound = true;\n                }\n            }\n\n            if (i !== -1) {\n                DocumentManager.getDocumentForPath(filteredFiltered[i].fullPath).then(result.resolve, result.resolve);\n                return;\n            }\n\n            result.resolve(null);\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * @private\n     * Close the connection and the associated window\n     * @param {boolean} doCloseWindow Use true to close the window/tab in the browser\n     * @param {?string} reason Optional string key suffix to display to user (see LIVE_DEV_* keys)\n     */\n    function _close(doCloseWindow, reason) {\n        if (exports.status !== STATUS_INACTIVE) {\n            // Close live documents\n            _closeDocuments();\n            // Close all active connections\n            _protocol.closeAllConnections();\n\n            if (_server) {\n                // Stop listening for requests when disconnected\n                _server.stop();\n\n                // Dispose server\n                _server = null;\n            }\n        }\n    //TODO: implement closeWindow together with launchers.\n//        if (doCloseWindow) {\n//\n//        }\n        _setStatus(STATUS_INACTIVE, reason || \"explicit_close\");\n    }\n\n    /**\n     * Closes all active connections.\n     * Returns a resolved promise for API compatibility.\n     * @return {$.Promise} A resolved promise\n     */\n    function close() {\n        _close(true);\n        return new $.Deferred().resolve().promise();\n    }\n\n    /**\n     * @private\n     * Displays an error when the server for live development files can't be started.\n     */\n    function _showLiveDevServerNotReadyError() {\n        Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_ERROR,\n            Strings.LIVE_DEVELOPMENT_ERROR_TITLE,\n            Strings.LIVE_DEV_SERVER_NOT_READY_MESSAGE\n        );\n    }\n\n    /**\n     * @private\n     * Creates the main live document for a given HTML document and notifies the server it exists.\n     * TODO: we should really maintain the list of live documents, not the server.\n     * @param {Document} doc\n     */\n    function _createLiveDocumentForFrame(doc) {\n        // create live document\n        doc._ensureMasterEditor();\n        _liveDocument = _createLiveDocument(doc, doc._masterEditor);\n        _server.add(_liveDocument);\n        _server.addVirtualContentAtPath(\n            `${_liveDocument.doc.file.parentPath}${LiveDevProtocol.LIVE_DEV_REMOTE_SCRIPTS_FILE_NAME}`,\n            _protocol.getRemoteScriptContents());\n        _server.addVirtualContentAtPath(\n            `${_liveDocument.doc.file.parentPath}${LiveDevProtocol.LIVE_DEV_REMOTE_WORKER_SCRIPTS_FILE_NAME}`,\n            PageLoaderWorkerScript);\n    }\n\n\n     /**\n     * Launches the given URL in the default browser.\n     * @param {string} url\n      * @param {string} fullPath\n     * TODO: launchers for multiple browsers\n     */\n    function _launch(url, fullPath) {\n        exports.trigger(EVENT_OPEN_PREVIEW_URL, {\n            url,\n            fullPath\n        });\n    }\n\n    /**\n     * @private\n     * Launches the given document in the browser, given that a live document has already\n     * been created for it.\n     * @param {Document} doc\n     */\n    function _open(doc) {\n        if (doc && _liveDocument && doc === _liveDocument.doc) {\n            if (_server) {\n                // Launch the URL in the browser. If it's the first one to connect back to us,\n                // our status will transition to ACTIVE once it does so.\n                if (exports.status < STATUS_ACTIVE) {\n                    _launch(_resolveUrl(doc.file.fullPath), doc.file.fullPath);\n                }\n                if (exports.status === STATUS_RESTARTING) {\n                    // change page in browser\n                    _protocol.navigate(_resolveUrl(doc.file.fullPath));\n                }\n\n                _protocol\n                    // TODO: timeout if we don't get a connection within a certain time\n                    .on(\"ConnectionConnect.livedev\", function (event, msg) {\n                        if (_protocol.getConnectionIds().length >= 1) {\n                            // check the page that connection comes from matches the current live document session\n                            const url = new URL(msg.url);\n                            const urlString = `${url.origin}${url.pathname}`;\n                            if (_liveDocument &&  urlString === _resolveUrl(_liveDocument.doc.file.fullPath)) {\n                                _setStatus(STATUS_ACTIVE);\n                            }\n                        }\n                        Metrics.countEvent(Metrics.EVENT_TYPE.LIVE_PREVIEW, \"connect\",\n                            `${_protocol.getConnectionIds().length}-preview`);\n                    })\n                    .on(\"ConnectionClose.livedev\", function (event, {clientId}) {\n                        exports.trigger(EVENT_CONNECTION_CLOSE, {clientId});\n                        window.logger.livePreview.log(\n                            \"Live Preview: Phoenix received ConnectionClose, live preview left: \",\n                            _protocol.getConnectionIds().length, clientId);\n                    })\n                    // extract stylesheets and create related LiveCSSDocument instances\n                    .on(\"DocumentRelated.livedev\", function (event, msg) {\n                        var relatedDocs = msg.related;\n                        var docs = Object.keys(relatedDocs.stylesheets);\n                        docs.forEach(function (url) {\n                            _styleSheetAdded(null, url, relatedDocs.stylesheets[url]);\n                        });\n                    })\n                    // create new LiveCSSDocument if a new stylesheet is added\n                    .on(\"StylesheetAdded.livedev\", function (event, msg) {\n                        _styleSheetAdded(null, msg.href, msg.roots);\n                    })\n                    // remove LiveCSSDocument instance when stylesheet is removed\n                    .on(\"StylesheetRemoved.livedev\", function (event, msg) {\n                        _handleRelatedDocumentDeleted(msg.href);\n                    })\n                    .on(LiveDevProtocol.EVENT_LIVE_PREVIEW_CLICKED + \".livedev\", function (event, msg) {\n                        exports.trigger(LiveDevProtocol.EVENT_LIVE_PREVIEW_CLICKED, msg);\n                    })\n                    .on(LiveDevProtocol.EVENT_LIVE_PREVIEW_RELOAD + \".livedev\", function (event, clients) {\n                        exports.trigger(LiveDevProtocol.EVENT_LIVE_PREVIEW_RELOAD, clients);\n                    });\n            } else {\n                console.error(\"LiveDevelopment._open(): No server active\");\n            }\n        } else {\n            // Unlikely that we would get to this state where\n            // a connection is in process but there is no current\n            // document\n            close();\n        }\n    }\n\n    /**\n     * @private\n     * Creates the live document in preparation for launching the\n     * preview of the given document, then launches it. (The live document\n     * must already exist before we launch it so that the server can\n     * ask it for the instrumented version of the document when the browser\n     * requests it.)\n     * TODO: could probably just consolidate this with _open()\n     * @param {Document} doc\n     */\n    function _doLaunchAfterServerReady(initialDoc) {\n\n        _createLiveDocumentForFrame(initialDoc);\n\n        // start listening for requests\n        _server.start()\n            .then(()=>{\n                // open browser to the url\n                _open(initialDoc);\n            });\n\n    }\n\n    /**\n     * @private\n     * Create the server in preparation for opening a live preview.\n     * @param {Document} doc The document we want the server for. Different servers handle\n     * different types of project (a static server for when no app server is configured,\n     * vs. a user server when there is an app server set in File > Project Settings).\n     */\n    function _prepareServer(doc) {\n        var deferred = new $.Deferred(),\n            showBaseUrlPrompt = false;\n\n        _server = LiveDevServerManager.getServer(doc.file.fullPath);\n\n        // Optionally prompt for a base URL if no server was found but the\n        // file is a known server file extension\n        showBaseUrlPrompt = !_server && LiveDevelopmentUtils.isServerHtmlFileExt(doc.file.fullPath);\n\n        if (showBaseUrlPrompt) {\n            // Prompt for a base URL\n            PreferencesDialogs.showProjectPreferencesDialog(\"\", Strings.LIVE_DEV_NEED_BASEURL_MESSAGE)\n                .done(function (id) {\n                    if (id === Dialogs.DIALOG_BTN_OK && ProjectManager.getBaseUrl()) {\n                        // If base url is specifed, then re-invoke _prepareServer() to continue\n                        _prepareServer(doc).then(deferred.resolve, deferred.reject);\n                    } else {\n                        deferred.reject();\n                    }\n                });\n        } else if (_server) {\n            // Startup the server\n            var readyPromise = _server.readyToServe();\n            if (!readyPromise) {\n                _showLiveDevServerNotReadyError();\n                deferred.reject();\n            } else {\n                readyPromise.then(deferred.resolve, function () {\n                    _showLiveDevServerNotReadyError();\n                    deferred.reject();\n                });\n            }\n        } else {\n            // No server found\n            deferred.reject();\n        }\n\n        return deferred.promise();\n    }\n\n    /**\n     * @private\n     * MainViewManager.currentFileChange event handler.\n     * When switching documents, close the current preview and open a new one.\n     */\n    function _onFileChange() {\n        let doc = DocumentManager.getCurrentDocument();\n        if (!isActive() || !doc || livePreviewUrlPinned) {\n            return;\n        }\n\n        // close the current session and begin a new session\n        let docUrl = _resolveUrl(doc.file.fullPath),\n            isViewable = _server && _server.canServe(doc.file.fullPath);\n\n        if (_liveDocument.doc.url !== docUrl && isViewable) {\n            // clear live doc and related docs\n            _closeDocuments();\n            // create new live doc\n            _createLiveDocumentForFrame(doc);\n            _setStatus(STATUS_RESTARTING);\n            _open(doc);\n\n        }\n    }\n\n\n    /**\n     * Open a live preview on the current docuemnt.\n     */\n    function open() {\n        // TODO: need to run _onDocumentChange() after load if doc != currentDocument here? Maybe not, since activeEditorChange\n        // doesn't trigger it, while inline editors can still cause edits in doc other than currentDoc...\n        _getInitialDocFromCurrent().done(function (doc) {\n            var prepareServerPromise = (doc && _prepareServer(doc)) || new $.Deferred().reject();\n\n            // wait for server (StaticServer, Base URL or file:)\n            prepareServerPromise\n                .done(function () {\n                    _setStatus(STATUS_CONNECTING);\n                    _doLaunchAfterServerReady(doc);\n                })\n                .fail(function () {\n                    console.log(\"Live preview: no document to preview.\");\n                });\n        });\n    }\n\n    /**\n     * For files that don't support as-you-type live editing, but are loaded by live HTML documents\n     * (e.g. JS files), we want to reload the full document when they're saved.\n     * @param {$.Event} event\n     * @param {Document} doc\n     */\n    function _onDocumentSaved(event, doc) {\n        if (!isActive() || !_server) {\n            return;\n        }\n\n        var absolutePath            = doc.file.fullPath,\n            liveDocument            = absolutePath && _server.get(absolutePath),\n            liveEditingEnabled      = liveDocument && liveDocument.isLiveEditingEnabled  && liveDocument.isLiveEditingEnabled();\n\n        // Skip reload if the saved document has live editing enabled\n        if (liveEditingEnabled) {\n            return;\n        }\n\n        // reload the page if the given document is a JS file related\n        // to the current live document.\n        if (_liveDocument.isRelated(absolutePath)) {\n            if (doc.getLanguage().getId() === \"javascript\") {\n                _setStatus(STATUS_RELOADING);\n                _protocol.reload();\n            }\n        }\n    }\n\n    /**\n     * For files that don't support as-you-type live editing, but are loaded by live HTML documents\n     * (e.g. JS files), we want to show a dirty indicator on the live development icon when they\n     * have unsaved changes, so the user knows s/he needs to save in order to have the page reload.\n     * @param {$.Event} event\n     * @param {Document} doc\n     */\n    function _onDirtyFlagChange(event, doc) {\n        if (!isActive() || !_server) {\n            return;\n        }\n\n        var absolutePath = doc.file.fullPath;\n\n        if (_liveDocument.isRelated(absolutePath)) {\n            // Set status to out of sync if dirty. Otherwise, set it to active status.\n            _setStatus(_docIsOutOfSync(doc) ? STATUS_OUT_OF_SYNC : STATUS_ACTIVE);\n        }\n    }\n\n    /**\n     * Sets the current transport mechanism to be used by the live development protocol\n     * (e.g. socket server, iframe postMessage, etc.)\n     * The low-level transport. Must provide the following methods:\n     *\n     * - start(): Initiates transport (eg. creates Web Socket server).\n     * - send(idOrArray, string): Dispatches the given protocol message (provided as a JSON string) to the given client ID\n     *   or array of client IDs. (See the \"connect\" message for an explanation of client IDs.)\n     * - close(id): Closes the connection to the given client ID.\n     * - getRemoteScript(): Returns a script that should be injected into the page's HTML in order to handle the remote side\n     *   of the transport. Should include the \"<script>\" tags. Should return null if no injection is necessary.\n     *\n     * It must also dispatch the following jQuery events:\n     *\n     * - \"connect\": When a target browser connects back to the transport. Must provide two parameters:\n     *   - clientID - a unique number representing this connection\n     *   - url - the URL of the page in the target browser that's connecting to us\n     * - \"message\": When a message is received by the transport. Must provide two parameters:\n     *   - clientID - the ID of the client sending the message\n     *   - message - the text of the message as a JSON string\n     * - \"close\": When the remote browser closes the connection. Must provide one parameter:\n     *   - clientID - the ID of the client closing the connection\n     *\n     * @param {{launch: function(string), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}} transport\n     */\n    function setTransport(transport) {\n        _protocol.setTransport(transport);\n    }\n\n    /**\n     * Initialize the LiveDevelopment module.\n     */\n    function init(config) {\n        exports.config = config;\n        MainViewManager\n            .on(\"currentFileChange\", _onFileChange);\n        DocumentManager\n            .on(\"documentSaved\", _onDocumentSaved)\n            .on(\"dirtyFlagChange\", _onDirtyFlagChange);\n        ProjectManager\n            .on(\"beforeProjectClose beforeAppClose\", close);\n\n        // Default transport for live connection messages - can be changed\n        setTransport(LivePreviewTransport);\n\n        // Initialize exports.status\n        _setStatus(STATUS_INACTIVE);\n    }\n\n    function getLiveDocForEditor(editor) {\n        if (!editor) {\n            return null;\n        }\n        return getLiveDocForPath(editor.document.file.fullPath);\n    }\n\n    /**\n     *  Enable highlighting\n     */\n    function showHighlight() {\n        var doc = getLiveDocForEditor(EditorManager.getActiveEditor());\n\n        if (doc && doc.updateHighlight) {\n            doc.updateHighlight();\n        }\n    }\n\n    /**\n     * Hide any active highlighting\n     */\n    function hideHighlight() {\n        if (_protocol) {\n            _protocol.evaluate(\"_LD.hideHighlight()\");\n        }\n    }\n\n    /**\n     * Redraw highlights\n     */\n    function redrawHighlight() {\n        if (_protocol) {\n            _protocol.evaluate(\"_LD.redrawHighlights()\");\n        }\n    }\n\n    /**\n     * Originally unload and reload agents. It doesn't apply for this new implementation.\n     * @return {jQuery.Promise} Already resolved promise.\n     */\n    function reconnect() {\n        return $.Deferred().resolve();\n    }\n\n    /**\n     * Reload current page in all connected browsers.\n     */\n    function reload() {\n        if (_protocol) {\n            _protocol.reload();\n        }\n    }\n\n    /**\n     * @param urlPinned {boolean}\n     */\n    function setLivePreviewPinned(urlPinned) {\n        livePreviewUrlPinned = urlPinned;\n    }\n\n    /**\n     * Returns current project server config. Copied from original LiveDevelopment.\n     */\n    function getCurrentProjectServerConfig() {\n        return {\n            baseUrl: ProjectManager.getBaseUrl(),\n            pathResolver: ProjectManager.makeProjectRelativeIfPossible,\n            root: ProjectManager.getProjectRoot().fullPath\n        };\n    }\n\n    /**\n     * @private\n     * Returns the base URL of the current server serving the active live document, or null if\n     * there is no active live document.\n     * @return {?string}\n     */\n    function getServerBaseUrl() {\n        return _server && _server.getBaseUrl();\n    }\n\n    // for unit testing only\n    function getCurrentLiveDoc() {\n        return _liveDocument;\n    }\n\n    /**\n     * Returns an array of the client IDs that are being managed by this live document.\n     * @return {Array.<number>}\n     */\n    function getConnectionIds() {\n        return _protocol.getConnectionIds();\n    }\n\n    function getLivePreviewDetails() {\n        return {\n            liveDocument: _liveDocument,\n            URL: _liveDocument ? _resolveUrl(_liveDocument.doc.file.fullPath) : null\n        };\n    }\n\n    function getLivePreviewBaseURL() {\n        return LiveDevServerManager.getStaticServerBaseURLs().projectBaseURL;\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // For unit testing\n    exports._server                   = _server;\n    exports._getInitialDocFromCurrent = _getInitialDocFromCurrent;\n\n    // Events\n    exports.EVENT_OPEN_PREVIEW_URL = EVENT_OPEN_PREVIEW_URL;\n    exports.EVENT_CONNECTION_CLOSE = EVENT_CONNECTION_CLOSE;\n    exports.EVENT_STATUS_CHANGE = EVENT_STATUS_CHANGE;\n    exports.EVENT_LIVE_PREVIEW_CLICKED = LiveDevProtocol.EVENT_LIVE_PREVIEW_CLICKED;\n    exports.EVENT_LIVE_PREVIEW_RELOAD = LiveDevProtocol.EVENT_LIVE_PREVIEW_RELOAD;\n\n    // Export public functions\n    exports.open                = open;\n    exports.close               = close;\n    exports.reconnect           = reconnect;\n    exports.reload              = reload;\n    exports.getLiveDocForPath   = getLiveDocForPath;\n    exports.showHighlight       = showHighlight;\n    exports.hideHighlight       = hideHighlight;\n    exports.redrawHighlight     = redrawHighlight;\n    exports.init                = init;\n    exports.isActive            = isActive;\n    exports.setLivePreviewPinned= setLivePreviewPinned;\n    exports.getServerBaseUrl    = getServerBaseUrl;\n    exports.getCurrentLiveDoc   = getCurrentLiveDoc;\n    exports.getLivePreviewDetails = getLivePreviewDetails;\n    exports.getLivePreviewBaseURL = getLivePreviewBaseURL;\n    exports.getCurrentProjectServerConfig = getCurrentProjectServerConfig;\n    exports.getConnectionIds = getConnectionIds;\n    exports.setTransport        = setTransport;\n});\n"],"file":"LiveDevMultiBrowser.js"}
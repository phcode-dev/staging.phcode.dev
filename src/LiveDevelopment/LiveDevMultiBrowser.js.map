{"version":3,"sources":["LiveDevelopment/LiveDevMultiBrowser.js"],"names":["define","require","exports","module","STATUS_INACTIVE","STATUS_CONNECTING","STATUS_ACTIVE","STATUS_OUT_OF_SYNC","STATUS_SYNC_ERROR","STATUS_RELOADING","STATUS_RESTARTING","EVENT_OPEN_PREVIEW_URL","EVENT_CONNECTION_CLOSE","EVENT_STATUS_CHANGE","CommandManager","Commands","Dialogs","DefaultDialogs","DocumentManager","EditorManager","EventDispatcher","FileUtils","MainViewManager","PreferencesDialogs","ProjectManager","Strings","_","LiveDevelopmentUtils","LiveDevServerManager","ServiceWorkerTransport","LiveDevProtocol","Metrics","LiveCSSDocument","LiveHTMLDocument","_liveDocument","livePreviewUrlPinned","_relatedDocuments","_protocol","_server","_classForDocument","doc","getLanguage","getId","isHtmlFileExt","file","fullPath","isActive","status","getLiveDocForPath","path","get","_closeDocument","liveDocument","off","close","_handleRelatedDocumentDeleted","url","liveDoc","remove","_setStatus","closeReason","reason","trigger","_closeDocuments","undefined","Object","keys","forEach","clear","_resolveUrl","pathToUrl","_createLiveDocument","editor","roots","DocClass","on","event","hasErrors","_docIsOutOfSync","isLiveEditingEnabled","isDirty","_styleSheetAdded","urlToPath","alreadyAdded","docPromise","getDocumentForPath","done","_masterEditor","add","_updateBrowser","_getInitialDocFromCurrent","getCurrentDocument","refPath","i","isStaticHtmlFileExt","isServerHtmlFileExt","$","Deferred","resolve","result","baseUrl","getBaseUrl","hasOwnServerForLiveDevelopment","length","getAllFiles","allFiles","projectRoot","getProjectRoot","containingFolder","indexFileFound","stillInProjectTree","getDirectoryPath","filteredFiltered","filter","item","parent","getParentPath","indexOf","filterIndexFile","fileInfo","getFilenameWithoutExtension","name","findIndex","then","promise","_close","doCloseWindow","closeAllConnections","stop","_showLiveDevServerNotReadyError","showModalDialog","DIALOG_ID_ERROR","LIVE_DEVELOPMENT_ERROR_TITLE","LIVE_DEV_SERVER_NOT_READY_MESSAGE","_createLiveDocumentForFrame","_ensureMasterEditor","_launch","_open","navigate","msg","getConnectionIds","urlWithoutQueryParams","split","countEvent","EVENT_TYPE","LIVE_PREVIEW","clientId","window","loggingOptions","livePreview","log","relatedDocs","related","docs","stylesheets","href","console","error","_doLaunchAfterServerReady","initialDoc","start","_prepareServer","deferred","showBaseUrlPrompt","getServer","showProjectPreferencesDialog","LIVE_DEV_NEED_BASEURL_MESSAGE","id","DIALOG_BTN_OK","reject","readyPromise","readyToServe","_onFileChange","docUrl","isViewable","canServe","open","prepareServerPromise","otherDocumentsInWorkingFiles","getWorkingSetSize","ALL_PANES","addToWorkingSet","ACTIVE_PANE","execute","CMD_OPEN","fail","_onDocumentSaved","absolutePath","liveEditingEnabled","isRelated","reload","_onDirtyFlagChange","setTransport","transport","init","config","getLiveDocForEditor","document","showHighlight","getActiveEditor","updateHighlight","hideHighlight","evaluate","redrawHighlight","reconnect","setLivePreviewPinned","urlPinned","getCurrentProjectServerConfig","pathResolver","makeProjectRelativeIfPossible","root","getServerBaseUrl","getCurrentLiveDoc","makeEventDispatcher"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * LiveDevelopment allows Brackets to launch a browser with a \"live preview\" that's\n * connected to the current editor.\n *\n * # STARTING\n *\n * To start a session call `open`. This will read the currentDocument from brackets,\n * launch it in the default browser, and connect to it for live editing.\n *\n * # STOPPING\n *\n * To stop a session call `close`. This will close the connection to the browser\n * (but will not close the browser tab).\n *\n * # STATUS\n *\n * Status updates are dispatched as `statusChange` jQuery events. The status\n * is passed as the first parameter and the reason for the change as the second\n * parameter. Currently only the \"Inactive\" status supports the reason parameter.\n * The status codes are:\n *\n *  0: Inactive\n *  1: Connecting (waiting for a browser connection)\n *  2: Active\n *  3: Out of sync\n *  4: Sync error\n *  5: Reloading (after saving JS changes)\n *  6: Restarting (switching context to a new HTML live doc)\n *\n * The reason codes are:\n * - null (Unknown reason)\n * - \"explicit_close\" (LiveDevelopment.close() was called)\n * - \"navigated_away\" (The browser changed to a location outside of the project)\n * - \"detached_target_closed\" (The tab or window was closed)\n */\ndefine(function (require, exports, module) {\n\n\n    // Status Codes\n    const STATUS_INACTIVE      = exports.STATUS_INACTIVE       =  0;\n    const STATUS_CONNECTING    = exports.STATUS_CONNECTING     =  1;\n    const STATUS_ACTIVE        = exports.STATUS_ACTIVE         =  2;\n    const STATUS_OUT_OF_SYNC   = exports.STATUS_OUT_OF_SYNC    =  3;\n    const STATUS_SYNC_ERROR    = exports.STATUS_SYNC_ERROR     =  4;\n    const STATUS_RELOADING     = exports.STATUS_RELOADING      =  5;\n    const STATUS_RESTARTING    = exports.STATUS_RESTARTING     =  6;\n\n    // events\n    const EVENT_OPEN_PREVIEW_URL = \"openPreviewURL\",\n        EVENT_CONNECTION_CLOSE = \"ConnectionClose\",\n        EVENT_STATUS_CHANGE = \"statusChange\";\n\n    const CommandManager       = require(\"command/CommandManager\"),\n        Commands             = require(\"command/Commands\"),\n        Dialogs              = require(\"widgets/Dialogs\"),\n        DefaultDialogs       = require(\"widgets/DefaultDialogs\"),\n        DocumentManager      = require(\"document/DocumentManager\"),\n        EditorManager        = require(\"editor/EditorManager\"),\n        EventDispatcher      = require(\"utils/EventDispatcher\"),\n        FileUtils            = require(\"file/FileUtils\"),\n        MainViewManager      = require(\"view/MainViewManager\"),\n        PreferencesDialogs   = require(\"preferences/PreferencesDialogs\"),\n        ProjectManager       = require(\"project/ProjectManager\"),\n        Strings              = require(\"strings\"),\n        _                    = require(\"thirdparty/lodash\"),\n        LiveDevelopmentUtils = require(\"LiveDevelopment/LiveDevelopmentUtils\"),\n        LiveDevServerManager = require(\"LiveDevelopment/LiveDevServerManager\"),\n        ServiceWorkerTransport  = require(\"LiveDevelopment/MultiBrowserImpl/transports/ServiceWorkerTransport\"),\n        LiveDevProtocol      = require(\"LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol\"),\n        Metrics              = require(\"utils/Metrics\");\n\n    // Documents\n    const LiveCSSDocument      = require(\"LiveDevelopment/MultiBrowserImpl/documents/LiveCSSDocument\"),\n        LiveHTMLDocument     = require(\"LiveDevelopment/MultiBrowserImpl/documents/LiveHTMLDocument\");\n\n    /**\n     * @private\n     * The live HTML document for the currently active preview.\n     * @type {LiveHTMLDocument}\n     */\n    var _liveDocument;\n\n    /**\n     * Live preview only tracks the pinned document.\n     * @type {boolean}\n     */\n    let livePreviewUrlPinned = false;\n\n    /**\n     * @private\n     * Live documents related to the active HTML document - for example, CSS files\n     * that are used by the document.\n     * @type {Object.<string: {LiveHTMLDocument|LiveCSSDocument}>}\n     */\n    var _relatedDocuments = {};\n\n    /**\n     * @private\n     * Protocol handler that provides the actual live development API on top of the current transport.\n     */\n    var _protocol = LiveDevProtocol;\n\n    /**\n     * @private\n     * Current live preview server\n     * @type {BaseServer}\n     */\n    var _server;\n\n    /**\n     * @private\n     * Determine which live document class should be used for a given document\n     * @param {Document} document The document we want to create a live document for.\n     * @return {function} The constructor for the live document class; will be a subclass of LiveDocument.\n     */\n    function _classForDocument(doc) {\n        if (doc.getLanguage().getId() === \"css\") {\n            return LiveCSSDocument;\n        }\n\n        if (LiveDevelopmentUtils.isHtmlFileExt(doc.file.fullPath)) {\n            return LiveHTMLDocument;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns true if the global Live Development mode is on (might be in the middle of connecting).\n     * @return {boolean}\n     */\n    function isActive() {\n        return exports.status > STATUS_INACTIVE;\n    }\n\n    /**\n     * Returns the live document for a given path, or null if there is no live document for it.\n     * @param {string} path\n     * @return {?LiveDocument}\n     */\n    function getLiveDocForPath(path) {\n        if (!_server) {\n            return null;\n        }\n\n        return _server.get(path);\n    }\n\n    /**\n     * @private\n     * Close a live document.\n     * @param {LiveDocument}\n     */\n    function _closeDocument(liveDocument) {\n        liveDocument.off(\".livedev\");\n        _protocol.off(\".livedev\");\n        liveDocument.close();\n    }\n\n    /**\n     * Removes the given CSS/JSDocument from _relatedDocuments. Signals that the\n     * given file is no longer associated with the HTML document that is live (e.g.\n     * if the related file has been deleted on disk).\n     * @param {string} url Absolute URL of the related document\n     */\n    function _handleRelatedDocumentDeleted(url) {\n        var liveDoc = _relatedDocuments[url];\n        if (liveDoc) {\n            delete _relatedDocuments[url];\n        }\n\n        if (_server) {\n            _server.remove(liveDoc);\n        }\n        _closeDocument(liveDoc);\n    }\n\n    /**\n     * Update the status. Triggers a statusChange event.\n     * @param {number} status new status\n     * @param {?string} closeReason Optional string key suffix to display to\n     *     user when closing the live development connection (see LIVE_DEV_* keys)\n     */\n    function _setStatus(status, closeReason) {\n        // Don't send a notification when the status didn't actually change\n        if (status === exports.status) {\n            return;\n        }\n\n        exports.status = status;\n\n        var reason = status === STATUS_INACTIVE ? closeReason : null;\n        exports.trigger(EVENT_STATUS_CHANGE, status, reason);\n    }\n\n    /**\n     * @private\n     * Close all live documents.\n     */\n    function _closeDocuments() {\n        if (_liveDocument) {\n            _closeDocument(_liveDocument);\n            _liveDocument = undefined;\n        }\n\n        Object.keys(_relatedDocuments).forEach(function (url) {\n            _closeDocument(_relatedDocuments[url]);\n            delete _relatedDocuments[url];\n        });\n\n        // Clear all documents from request filtering\n        if (_server) {\n            _server.clear();\n        }\n    }\n\n    /**\n     * @private\n     * Returns the URL that we would serve the given path at.\n     * @param {string} path\n     * @return {string}\n     */\n    function _resolveUrl(path) {\n        return _server && _server.pathToUrl(path);\n    }\n\n    /**\n     * @private\n     * Create a LiveDocument for a Brackets editor/document to manage communication between the\n     * editor and the browser.\n     * @param {Document} doc\n     * @param {Editor} editor\n     * @param {roots} roots\n     * @return {?LiveDocument} The live document, or null if this type of file doesn't support live editing.\n     */\n    function _createLiveDocument(doc, editor, roots) {\n        var DocClass = _classForDocument(doc),\n            liveDocument;\n\n        if (!DocClass) {\n            return null;\n        }\n\n        liveDocument = new DocClass(_protocol, _resolveUrl, doc, editor, roots);\n\n        liveDocument.on(\"errorStatusChanged.livedev\", function (event, hasErrors) {\n            if (isActive()) {\n                _setStatus(hasErrors ? STATUS_SYNC_ERROR : STATUS_ACTIVE);\n            }\n        });\n\n        return liveDocument;\n    }\n\n    /**\n     * Documents are considered to be out-of-sync if they are dirty and\n     * do not have \"update while editing\" support\n     * @param {Document} doc\n     * @return {boolean}\n     */\n    function _docIsOutOfSync(doc) {\n        var liveDoc = _server && _server.get(doc.file.fullPath),\n            isLiveEditingEnabled = liveDoc && liveDoc.isLiveEditingEnabled();\n\n        return doc.isDirty && !isLiveEditingEnabled;\n    }\n\n    /**\n     * Handles a notification from the browser that a stylesheet was loaded into\n     * the live HTML document. If the stylesheet maps to a file in the project, then\n     * creates a live document for the stylesheet and adds it to _relatedDocuments.\n     * @param {$.Event} event\n     * @param {string} url The URL of the stylesheet that was added.\n     * @param {array} roots The URLs of the roots of the stylesheet (the css files loaded through <link>)\n     */\n    function _styleSheetAdded(event, url, roots) {\n        var path = _server && _server.urlToPath(url),\n            alreadyAdded = !!_relatedDocuments[url];\n\n        // path may be null if loading an external stylesheet.\n        // Also, the stylesheet may already exist and be reported as added twice\n        // due to Chrome reporting added/removed events after incremental changes\n        // are pushed to the browser\n        if (!path || alreadyAdded) {\n            return;\n        }\n\n        var docPromise = DocumentManager.getDocumentForPath(path);\n\n        docPromise.done(function (doc) {\n            if ((_classForDocument(doc) === LiveCSSDocument) &&\n                    (!_liveDocument || (doc !== _liveDocument.doc))) {\n                var liveDoc = _createLiveDocument(doc, doc._masterEditor, roots);\n                if (liveDoc) {\n                    _server.add(liveDoc);\n                    _relatedDocuments[doc.url] = liveDoc;\n                    liveDoc.on(\"updateDoc\", function (event, url) {\n                        var path = _server.urlToPath(url),\n                            doc = getLiveDocForPath(path);\n                        doc._updateBrowser();\n                    });\n                }\n            }\n        });\n    }\n\n    /**\n     * @private\n     * Determine an index file that can be used to start Live Development.\n     * This function will inspect all files in a project to find the closest index file\n     * available for currently opened document. We are searching for these files:\n     *  - index.html\n     *  - index.htm\n     *\n     * If the project is configured with a custom base url for live development, then\n     * the list of possible index files is extended to contain these index files too:\n     *  - index.php\n     *  - index.php3\n     *  - index.php4\n     *  - index.php5\n     *  - index.phtm\n     *  - index.phtml\n     *  - index.cfm\n     *  - index.cfml\n     *  - index.asp\n     *  - index.aspx\n     *  - index.jsp\n     *  - index.jspx\n     *  - index.shm\n     *  - index.shml\n     *\n     * If a file was found, the promise will be resolved with the full path to this file. If no file\n     * was found in the whole project tree, the promise will be resolved with null.\n     *\n     * @return {jQuery.Promise} A promise that is resolved with a full path\n     * to a file if one could been determined, or null if there was no suitable index\n     * file.\n     */\n    function _getInitialDocFromCurrent() {\n        var doc = DocumentManager.getCurrentDocument(),\n            refPath,\n            i;\n\n        // Is the currently opened document already a file we can use for Live Development?\n        if (doc) {\n            refPath = doc.file.fullPath;\n            if (LiveDevelopmentUtils.isStaticHtmlFileExt(refPath) || LiveDevelopmentUtils.isServerHtmlFileExt(refPath)) {\n                return new $.Deferred().resolve(doc);\n            }\n        }\n\n        var result = new $.Deferred();\n\n        var baseUrl = ProjectManager.getBaseUrl(),\n            hasOwnServerForLiveDevelopment = (baseUrl && baseUrl.length);\n\n        ProjectManager.getAllFiles().done(function (allFiles) {\n            var projectRoot = ProjectManager.getProjectRoot().fullPath,\n                containingFolder,\n                indexFileFound = false,\n                stillInProjectTree = true;\n\n            if (refPath) {\n                containingFolder = FileUtils.getDirectoryPath(refPath);\n            } else {\n                containingFolder = projectRoot;\n            }\n\n            var filteredFiltered = allFiles.filter(function (item) {\n                var parent = FileUtils.getParentPath(item.fullPath);\n\n                return (containingFolder.indexOf(parent) === 0);\n            });\n\n            var filterIndexFile = function (fileInfo) {\n                if (fileInfo.fullPath.indexOf(containingFolder) === 0) {\n                    if (FileUtils.getFilenameWithoutExtension(fileInfo.name) === \"index\") {\n                        if (hasOwnServerForLiveDevelopment) {\n                            if ((LiveDevelopmentUtils.isServerHtmlFileExt(fileInfo.name)) ||\n                                    (LiveDevelopmentUtils.isStaticHtmlFileExt(fileInfo.name))) {\n                                return true;\n                            }\n                        } else if (LiveDevelopmentUtils.isStaticHtmlFileExt(fileInfo.name)) {\n                            return true;\n                        }\n                    } else {\n                        return false;\n                    }\n                }\n            };\n\n            while (!indexFileFound && stillInProjectTree) {\n                i = _.findIndex(filteredFiltered, filterIndexFile);\n\n                // We found no good match\n                if (i === -1) {\n                    // traverse the directory tree up one level\n                    containingFolder = FileUtils.getParentPath(containingFolder);\n                    // Are we still inside the project?\n                    if (containingFolder.indexOf(projectRoot) === -1) {\n                        stillInProjectTree = false;\n                    }\n                } else {\n                    indexFileFound = true;\n                }\n            }\n\n            if (i !== -1) {\n                DocumentManager.getDocumentForPath(filteredFiltered[i].fullPath).then(result.resolve, result.resolve);\n                return;\n            }\n\n            result.resolve(null);\n        });\n\n        return result.promise();\n    }\n\n    /**\n     * @private\n     * Close the connection and the associated window\n     * @param {boolean} doCloseWindow Use true to close the window/tab in the browser\n     * @param {?string} reason Optional string key suffix to display to user (see LIVE_DEV_* keys)\n     */\n    function _close(doCloseWindow, reason) {\n        if (exports.status !== STATUS_INACTIVE) {\n            // Close live documents\n            _closeDocuments();\n            // Close all active connections\n            _protocol.closeAllConnections();\n\n            if (_server) {\n                // Stop listening for requests when disconnected\n                _server.stop();\n\n                // Dispose server\n                _server = null;\n            }\n        }\n    //TODO: implement closeWindow together with launchers.\n//        if (doCloseWindow) {\n//\n//        }\n        _setStatus(STATUS_INACTIVE, reason || \"explicit_close\");\n    }\n\n    /**\n     * Closes all active connections.\n     * Returns a resolved promise for API compatibility.\n     * @return {$.Promise} A resolved promise\n     */\n    function close() {\n        _close(true);\n        return new $.Deferred().resolve().promise();\n    }\n\n    /**\n     * @private\n     * Displays an error when the server for live development files can't be started.\n     */\n    function _showLiveDevServerNotReadyError() {\n        Dialogs.showModalDialog(\n            DefaultDialogs.DIALOG_ID_ERROR,\n            Strings.LIVE_DEVELOPMENT_ERROR_TITLE,\n            Strings.LIVE_DEV_SERVER_NOT_READY_MESSAGE\n        );\n    }\n\n    /**\n     * @private\n     * Creates the main live document for a given HTML document and notifies the server it exists.\n     * TODO: we should really maintain the list of live documents, not the server.\n     * @param {Document} doc\n     */\n    function _createLiveDocumentForFrame(doc) {\n        // create live document\n        doc._ensureMasterEditor();\n        _liveDocument = _createLiveDocument(doc, doc._masterEditor);\n        _server.add(_liveDocument);\n    }\n\n\n     /**\n     * Launches the given URL in the default browser.\n     * @param {string} url\n      * @param {string} fullPath\n     * TODO: launchers for multiple browsers\n     */\n    function _launch(url, fullPath) {\n        exports.trigger(EVENT_OPEN_PREVIEW_URL, {\n            url,\n            fullPath\n        });\n    }\n\n    /**\n     * @private\n     * Launches the given document in the browser, given that a live document has already\n     * been created for it.\n     * @param {Document} doc\n     */\n    function _open(doc) {\n        if (doc && _liveDocument && doc === _liveDocument.doc) {\n            if (_server) {\n                // Launch the URL in the browser. If it's the first one to connect back to us,\n                // our status will transition to ACTIVE once it does so.\n                if (exports.status < STATUS_ACTIVE) {\n                    _launch(_server.pathToUrl(doc.file.fullPath), doc.file.fullPath);\n                }\n                if (exports.status === STATUS_RESTARTING) {\n                    // change page in browser\n                    _protocol.navigate(_server.pathToUrl(doc.file.fullPath));\n                }\n\n                _protocol\n                    // TODO: timeout if we don't get a connection within a certain time\n                    .on(\"ConnectionConnect.livedev\", function (event, msg) {\n                        // check for the first connection\n                        if (_protocol.getConnectionIds().length === 1) {\n                            // check the page that connection comes from matches the current live document session\n                            const urlWithoutQueryParams = msg.url.split(\"?\")[0].split(\"#\")[0];\n                            if (_liveDocument &&\n                                (urlWithoutQueryParams === _resolveUrl(_liveDocument.doc.file.fullPath))) {\n                                _setStatus(STATUS_ACTIVE);\n                            }\n                        }\n                        Metrics.countEvent(Metrics.EVENT_TYPE.LIVE_PREVIEW, \"connect\",\n                            `${_protocol.getConnectionIds().length}-preview`);\n                    })\n                    .on(\"ConnectionClose.livedev\", function (event, {clientId}) {\n                        exports.trigger(EVENT_CONNECTION_CLOSE, {clientId});\n                        window.loggingOptions.livePreview.log(\n                            \"Live Preview: Phoenix received ConnectionClose, live preview left: \",\n                            _protocol.getConnectionIds().length, clientId);\n                    })\n                    // extract stylesheets and create related LiveCSSDocument instances\n                    .on(\"DocumentRelated.livedev\", function (event, msg) {\n                        var relatedDocs = msg.related;\n                        var docs = Object.keys(relatedDocs.stylesheets);\n                        docs.forEach(function (url) {\n                            _styleSheetAdded(null, url, relatedDocs.stylesheets[url]);\n                        });\n                    })\n                    // create new LiveCSSDocument if a new stylesheet is added\n                    .on(\"StylesheetAdded.livedev\", function (event, msg) {\n                        _styleSheetAdded(null, msg.href, msg.roots);\n                    })\n                    // remove LiveCSSDocument instance when stylesheet is removed\n                    .on(\"StylesheetRemoved.livedev\", function (event, msg) {\n                        _handleRelatedDocumentDeleted(msg.href);\n                    });\n            } else {\n                console.error(\"LiveDevelopment._open(): No server active\");\n            }\n        } else {\n            // Unlikely that we would get to this state where\n            // a connection is in process but there is no current\n            // document\n            close();\n        }\n    }\n\n    /**\n     * @private\n     * Creates the live document in preparation for launching the\n     * preview of the given document, then launches it. (The live document\n     * must already exist before we launch it so that the server can\n     * ask it for the instrumented version of the document when the browser\n     * requests it.)\n     * TODO: could probably just consolidate this with _open()\n     * @param {Document} doc\n     */\n    function _doLaunchAfterServerReady(initialDoc) {\n\n        _createLiveDocumentForFrame(initialDoc);\n\n        // start listening for requests\n        _server.start();\n\n        // open browser to the url\n        _open(initialDoc);\n    }\n\n    /**\n     * @private\n     * Create the server in preparation for opening a live preview.\n     * @param {Document} doc The document we want the server for. Different servers handle\n     * different types of project (a static server for when no app server is configured,\n     * vs. a user server when there is an app server set in File > Project Settings).\n     */\n    function _prepareServer(doc) {\n        var deferred = new $.Deferred(),\n            showBaseUrlPrompt = false;\n\n        _server = LiveDevServerManager.getServer(doc.file.fullPath);\n\n        // Optionally prompt for a base URL if no server was found but the\n        // file is a known server file extension\n        showBaseUrlPrompt = !_server && LiveDevelopmentUtils.isServerHtmlFileExt(doc.file.fullPath);\n\n        if (showBaseUrlPrompt) {\n            // Prompt for a base URL\n            PreferencesDialogs.showProjectPreferencesDialog(\"\", Strings.LIVE_DEV_NEED_BASEURL_MESSAGE)\n                .done(function (id) {\n                    if (id === Dialogs.DIALOG_BTN_OK && ProjectManager.getBaseUrl()) {\n                        // If base url is specifed, then re-invoke _prepareServer() to continue\n                        _prepareServer(doc).then(deferred.resolve, deferred.reject);\n                    } else {\n                        deferred.reject();\n                    }\n                });\n        } else if (_server) {\n            // Startup the server\n            var readyPromise = _server.readyToServe();\n            if (!readyPromise) {\n                _showLiveDevServerNotReadyError();\n                deferred.reject();\n            } else {\n                readyPromise.then(deferred.resolve, function () {\n                    _showLiveDevServerNotReadyError();\n                    deferred.reject();\n                });\n            }\n        } else {\n            // No server found\n            deferred.reject();\n        }\n\n        return deferred.promise();\n    }\n\n    /**\n     * @private\n     * MainViewManager.currentFileChange event handler.\n     * When switching documents, close the current preview and open a new one.\n     */\n    function _onFileChange() {\n        var doc = DocumentManager.getCurrentDocument();\n        if (!isActive() || !doc || livePreviewUrlPinned) {\n            return;\n        }\n\n        // close the current session and begin a new session\n        var docUrl = _server && _server.pathToUrl(doc.file.fullPath),\n            isViewable = _server && _server.canServe(doc.file.fullPath);\n\n        if (_liveDocument.doc.url !== docUrl && isViewable) {\n            // clear live doc and related docs\n            _closeDocuments();\n            // create new live doc\n            _createLiveDocumentForFrame(doc);\n            _setStatus(STATUS_RESTARTING);\n            _open(doc);\n\n        }\n    }\n\n\n    /**\n     * Open a live preview on the current docuemnt.\n     */\n    function open() {\n        // TODO: need to run _onDocumentChange() after load if doc != currentDocument here? Maybe not, since activeEditorChange\n        // doesn't trigger it, while inline editors can still cause edits in doc other than currentDoc...\n        _getInitialDocFromCurrent().done(function (doc) {\n            var prepareServerPromise = (doc && _prepareServer(doc)) || new $.Deferred().reject(),\n                otherDocumentsInWorkingFiles;\n\n            if (doc && !doc._masterEditor) {\n                otherDocumentsInWorkingFiles = MainViewManager.getWorkingSetSize(MainViewManager.ALL_PANES);\n                MainViewManager.addToWorkingSet(MainViewManager.ACTIVE_PANE, doc.file);\n\n                if (!otherDocumentsInWorkingFiles) {\n                    CommandManager.execute(Commands.CMD_OPEN, { fullPath: doc.file.fullPath });\n                }\n            }\n\n            // wait for server (StaticServer, Base URL or file:)\n            prepareServerPromise\n                .done(function () {\n                    _setStatus(STATUS_CONNECTING);\n                    _doLaunchAfterServerReady(doc);\n                })\n                .fail(function () {\n                    console.log(\"Live preview: no document to preview.\");\n                });\n        });\n    }\n\n    /**\n     * For files that don't support as-you-type live editing, but are loaded by live HTML documents\n     * (e.g. JS files), we want to reload the full document when they're saved.\n     * @param {$.Event} event\n     * @param {Document} doc\n     */\n    function _onDocumentSaved(event, doc) {\n        if (!isActive() || !_server) {\n            return;\n        }\n\n        var absolutePath            = doc.file.fullPath,\n            liveDocument            = absolutePath && _server.get(absolutePath),\n            liveEditingEnabled      = liveDocument && liveDocument.isLiveEditingEnabled  && liveDocument.isLiveEditingEnabled();\n\n        // Skip reload if the saved document has live editing enabled\n        if (liveEditingEnabled) {\n            return;\n        }\n\n        // reload the page if the given document is a JS file related\n        // to the current live document.\n        if (_liveDocument.isRelated(absolutePath)) {\n            if (doc.getLanguage().getId() === \"javascript\") {\n                _setStatus(STATUS_RELOADING);\n                _protocol.reload();\n            }\n        }\n    }\n\n    /**\n     * For files that don't support as-you-type live editing, but are loaded by live HTML documents\n     * (e.g. JS files), we want to show a dirty indicator on the live development icon when they\n     * have unsaved changes, so the user knows s/he needs to save in order to have the page reload.\n     * @param {$.Event} event\n     * @param {Document} doc\n     */\n    function _onDirtyFlagChange(event, doc) {\n        if (!isActive() || !_server) {\n            return;\n        }\n\n        var absolutePath = doc.file.fullPath;\n\n        if (_liveDocument.isRelated(absolutePath)) {\n            // Set status to out of sync if dirty. Otherwise, set it to active status.\n            _setStatus(_docIsOutOfSync(doc) ? STATUS_OUT_OF_SYNC : STATUS_ACTIVE);\n        }\n    }\n\n    /**\n     * Sets the current transport mechanism to be used by the live development protocol\n     * (e.g. socket server, iframe postMessage, etc.)\n     * The low-level transport. Must provide the following methods:\n     *\n     * - start(): Initiates transport (eg. creates Web Socket server).\n     * - send(idOrArray, string): Dispatches the given protocol message (provided as a JSON string) to the given client ID\n     *   or array of client IDs. (See the \"connect\" message for an explanation of client IDs.)\n     * - close(id): Closes the connection to the given client ID.\n     * - getRemoteScript(): Returns a script that should be injected into the page's HTML in order to handle the remote side\n     *   of the transport. Should include the \"<script>\" tags. Should return null if no injection is necessary.\n     *\n     * It must also dispatch the following jQuery events:\n     *\n     * - \"connect\": When a target browser connects back to the transport. Must provide two parameters:\n     *   - clientID - a unique number representing this connection\n     *   - url - the URL of the page in the target browser that's connecting to us\n     * - \"message\": When a message is received by the transport. Must provide two parameters:\n     *   - clientID - the ID of the client sending the message\n     *   - message - the text of the message as a JSON string\n     * - \"close\": When the remote browser closes the connection. Must provide one parameter:\n     *   - clientID - the ID of the client closing the connection\n     *\n     * @param {{launch: function(string), send: function(number|Array.<number>, string), close: function(number), getRemoteScript: function(): ?string}} transport\n     */\n    function setTransport(transport) {\n        _protocol.setTransport(transport);\n    }\n\n    /**\n     * Initialize the LiveDevelopment module.\n     */\n    function init(config) {\n        exports.config = config;\n        MainViewManager\n            .on(\"currentFileChange\", _onFileChange);\n        DocumentManager\n            .on(\"documentSaved\", _onDocumentSaved)\n            .on(\"dirtyFlagChange\", _onDirtyFlagChange);\n        ProjectManager\n            .on(\"beforeProjectClose beforeAppClose\", close);\n\n        // Default transport for live connection messages - can be changed\n        setTransport(ServiceWorkerTransport);\n\n        // Initialize exports.status\n        _setStatus(STATUS_INACTIVE);\n    }\n\n    function getLiveDocForEditor(editor) {\n        if (!editor) {\n            return null;\n        }\n        return getLiveDocForPath(editor.document.file.fullPath);\n    }\n\n    /**\n     *  Enable highlighting\n     */\n    function showHighlight() {\n        var doc = getLiveDocForEditor(EditorManager.getActiveEditor());\n\n        if (doc && doc.updateHighlight) {\n            doc.updateHighlight();\n        }\n    }\n\n    /**\n     * Hide any active highlighting\n     */\n    function hideHighlight() {\n        if (_protocol) {\n            _protocol.evaluate(\"_LD.hideHighlight()\");\n        }\n    }\n\n    /**\n     * Redraw highlights\n     */\n    function redrawHighlight() {\n        if (_protocol) {\n            _protocol.evaluate(\"_LD.redrawHighlights()\");\n        }\n    }\n\n    /**\n     * Originally unload and reload agents. It doesn't apply for this new implementation.\n     * @return {jQuery.Promise} Already resolved promise.\n     */\n    function reconnect() {\n        return $.Deferred().resolve();\n    }\n\n    /**\n     * Reload current page in all connected browsers.\n     */\n    function reload() {\n        if (_protocol) {\n            _protocol.reload();\n        }\n    }\n\n    /**\n     * @param urlPinned {boolean}\n     */\n    function setLivePreviewPinned(urlPinned) {\n        livePreviewUrlPinned = urlPinned;\n    }\n\n    /**\n     * Returns current project server config. Copied from original LiveDevelopment.\n     */\n    function getCurrentProjectServerConfig() {\n        return {\n            baseUrl: ProjectManager.getBaseUrl(),\n            pathResolver: ProjectManager.makeProjectRelativeIfPossible,\n            root: ProjectManager.getProjectRoot().fullPath\n        };\n    }\n\n    /**\n     * @private\n     * Returns the base URL of the current server serving the active live document, or null if\n     * there is no active live document.\n     * @return {?string}\n     */\n    function getServerBaseUrl() {\n        return _server && _server.getBaseUrl();\n    }\n\n    // for unit testing only\n    function getCurrentLiveDoc() {\n        return _liveDocument;\n    }\n\n    /**\n     * Returns an array of the client IDs that are being managed by this live document.\n     * @return {Array.<number>}\n     */\n    function getConnectionIds() {\n        return _protocol.getConnectionIds();\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // For unit testing\n    exports._server                   = _server;\n    exports._getInitialDocFromCurrent = _getInitialDocFromCurrent;\n\n    // Events\n    exports.EVENT_OPEN_PREVIEW_URL = EVENT_OPEN_PREVIEW_URL;\n    exports.EVENT_CONNECTION_CLOSE = EVENT_CONNECTION_CLOSE;\n    exports.EVENT_STATUS_CHANGE = EVENT_STATUS_CHANGE;\n\n    // Export public functions\n    exports.open                = open;\n    exports.close               = close;\n    exports.reconnect           = reconnect;\n    exports.reload              = reload;\n    exports.getLiveDocForPath   = getLiveDocForPath;\n    exports.showHighlight       = showHighlight;\n    exports.hideHighlight       = hideHighlight;\n    exports.redrawHighlight     = redrawHighlight;\n    exports.init                = init;\n    exports.isActive            = isActive;\n    exports.setLivePreviewPinned= setLivePreviewPinned;\n    exports.getServerBaseUrl    = getServerBaseUrl;\n    exports.getCurrentLiveDoc   = getCurrentLiveDoc;\n    exports.getCurrentProjectServerConfig = getCurrentProjectServerConfig;\n    exports.getConnectionIds = getConnectionIds;\n    exports.setTransport        = setTransport;\n});\n"],"file":"LiveDevMultiBrowser.js"}
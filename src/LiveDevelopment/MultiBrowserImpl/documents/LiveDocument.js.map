{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/documents/LiveDocument.js"],"names":["define","require","exports","module","EditorManager","EventDispatcher","PreferencesManager","_","SYNC_ERROR_CLASS","LiveDocument","protocol","urlResolver","doc","editor","roots","this","_onActiveEditorChange","bind","_onCursorActivity","_onHighlightPrefChange","on","stateManager","getPreference","$","window","focus","_attachToEditor","makeEventDispatcher","prototype","close","_clearErrorDisplay","_detachFromEditor","off","isLiveEditingEnabled","setInstrumentationEnabled","enabled","getResponseData","body","getText","isHighlightEnabled","updateHighlight","hideHighlight","event","newActive","oldActive","document","_updateErrorDisplay","self","startLine","endLine","i","lineHandle","_codeMirror","operation","_errorLineHandles","errors","forEach","error","startPos","line","endPos","addLineClass","push","trigger","length","pop","removeLineClass","getViewState","temporary","_lastHighlight","evaluate","highlightRule","name","JSON","stringify","highlightDomElement","ids","selector","Array","isArray","each","id","redrawHighlights"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var EditorManager       = require(\"editor/EditorManager\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        _                   = require(\"thirdparty/lodash\");\n\n    /**\n     * @const\n     * CSS class to use for live preview errors.\n     * @type {string}\n     */\n    var SYNC_ERROR_CLASS = \"live-preview-sync-error\";\n\n    /**\n     * @constructor\n     * Base class for managing the connection between a live editor and the browser. Provides functions\n     * for subclasses to highlight relevant nodes in the browser, and to mark errors in the editor.\n     *\n     * Raises these events:\n     *     \"connect\" - when a browser connects from the URL that maps to this live document. Passes the\n     *          URL as a parameter.\n     *     \"errorStatusChanged\" - when the status of errors that might prevent live edits from\n     *          working (e.g. HTML syntax errors) has changed. Passes a boolean that's true if there\n     *          are errors, false otherwise.\n     *\n     * @param {LiveDevProtocol} protocol The protocol to use for communicating with the browser.\n     * @param {function(string): string} urlResolver A function that, given a path on disk, should return\n     *     the URL that Live Development serves that path at.\n     * @param {Document} doc The Brackets document that this live document is connected to.\n     * @param {?Editor} editor If specified, a particular editor that this live document is managing.\n     *     If not specified initially, the LiveDocument will connect to the editor for the given document\n     *     when it next becomes the active editor.\n     */\n    function LiveDocument(protocol, urlResolver, doc, editor, roots) {\n        this.protocol = protocol;\n        this.urlResolver = urlResolver;\n        this.doc = doc;\n        this.roots = roots || [];\n\n        this._onActiveEditorChange = this._onActiveEditorChange.bind(this);\n        this._onCursorActivity = this._onCursorActivity.bind(this);\n        this._onHighlightPrefChange = this._onHighlightPrefChange.bind(this);\n\n        EditorManager.on(\"activeEditorChange\", this._onActiveEditorChange);\n\n        PreferencesManager.stateManager.getPreference(\"livedev.highlight\")\n            .on(\"change\", this._onHighlightPrefChange);\n\n        // Redraw highlights when window gets focus. This ensures that the highlights\n        // will be in sync with any DOM changes that may have occurred.\n        $(window).focus(this._onHighlightPrefChange);\n\n        if (editor) {\n            // Attach now\n            this._attachToEditor(editor);\n        }\n    }\n\n    EventDispatcher.makeEventDispatcher(LiveDocument.prototype);\n\n    /**\n     * Closes the live document, terminating its connection to the browser.\n     */\n    LiveDocument.prototype.close = function () {\n\n        this._clearErrorDisplay();\n        this._detachFromEditor();\n        EditorManager.off(\"activeEditorChange\", this._onActiveEditorChange);\n        PreferencesManager.stateManager.getPreference(\"livedev.highlight\")\n            .off(\"change\", this._onHighlightPrefChange);\n    };\n\n    /**\n     * Returns true if document edits appear live in the connected browser.\n     * Should be overridden by subclasses.\n     * @return {boolean}\n     */\n    LiveDocument.prototype.isLiveEditingEnabled = function () {\n        return false;\n    };\n\n    /**\n     * Called to turn instrumentation on or off for this file. Triggered by being\n     * requested from the browser. Should be implemented by subclasses if instrumentation\n     * is necessary for the subclass's document type.\n     * TODO: this doesn't seem necessary...if we're a live document, we should\n     * always have instrumentation on anyway.\n     * @param {boolean} enabled\n     */\n    LiveDocument.prototype.setInstrumentationEnabled = function (enabled) {\n        // Does nothing in base class.\n    };\n\n    /**\n     * Returns the instrumented version of the file. By default, just returns\n     * the document text. Should be overridden by subclasses for cases if instrumentation\n     * is necessary for the subclass's document type.\n     * @return {{body: string}} document body\n     */\n    LiveDocument.prototype.getResponseData = function (enabled) {\n        return {\n            body: this.doc.getText()\n        };\n    };\n\n    /**\n     * @private\n     * Handles changes to the \"Live Highlight\" preference, switching it on/off in the browser as appropriate.\n     */\n    LiveDocument.prototype._onHighlightPrefChange = function () {\n        if (this.isHighlightEnabled()) {\n            this.updateHighlight();\n        } else {\n            this.hideHighlight();\n        }\n    };\n\n    /**\n     * @private\n     * Handles when the active editor changes, attaching to the new editor if it's for the current document.\n     * @param {$.Event} event\n     * @param {?Editor} newActive\n     * @param {?Editor} oldActive\n     */\n    LiveDocument.prototype._onActiveEditorChange = function (event, newActive, oldActive) {\n\n        //FIXME: #7 prevents the page to be reloaded when editing JS files.\n        //       Temporarily disabling this code to make JS editing work.\n//      this._detachFromEditor();\n\n        if (newActive && newActive.document === this.doc) {\n            this._attachToEditor(newActive);\n        }\n    };\n\n    /**\n     * @private\n     * Attaches to an editor for our associated document when it becomes active.\n     * @param {Editor} editor\n     */\n    LiveDocument.prototype._attachToEditor = function (editor) {\n        this.editor = editor;\n\n        if (this.editor) {\n            this.editor.on(\"cursorActivity\", this._onCursorActivity);\n            this.updateHighlight();\n        }\n    };\n\n    /**\n     * @private\n     * Detaches from the current editor.\n     */\n    LiveDocument.prototype._detachFromEditor = function () {\n        if (this.editor) {\n            this.hideHighlight();\n            this.editor.off(\"cursorActivity\", this._onCursorActivity);\n            this.editor = null;\n        }\n    };\n\n    /**\n     * @private\n     * Handles a cursor change in our attached editor. Updates the highlight in the browser.\n     * @param {$.Event} event\n     * @param {Editor} editor\n     */\n    LiveDocument.prototype._onCursorActivity = function (event, editor) {\n        if (!this.editor) {\n            return;\n        }\n        this.updateHighlight();\n    };\n\n    /**\n     * @private\n     * Update errors shown by the live document in the editor. Should be called by subclasses\n     * when the list of errors changes.\n     */\n    LiveDocument.prototype._updateErrorDisplay = function () {\n        var self = this,\n            startLine,\n            endLine,\n            i,\n            lineHandle;\n\n        if (!this.editor) {\n            return;\n        }\n\n        // Buffer addLineClass DOM changes in a CodeMirror operation\n        this.editor._codeMirror.operation(function () {\n            // Remove existing errors before marking new ones\n            self._clearErrorDisplay();\n\n            self._errorLineHandles = self._errorLineHandles || [];\n\n            self.errors.forEach(function (error) {\n                startLine = error.startPos.line;\n                endLine = error.endPos.line;\n\n                for (i = startLine; i < endLine + 1; i++) {\n                    lineHandle = self.editor._codeMirror.addLineClass(i, \"wrap\", SYNC_ERROR_CLASS);\n                    self._errorLineHandles.push(lineHandle);\n                }\n            });\n        });\n\n        this.trigger(\"errorStatusChanged\", !!this.errors.length);\n    };\n\n    /**\n     * @private\n     * Clears the errors shown in the attached editor.\n     */\n    LiveDocument.prototype._clearErrorDisplay = function () {\n        var self = this,\n            lineHandle;\n\n        if (!this.editor ||\n                !this._errorLineHandles ||\n                !this._errorLineHandles.length) {\n            return;\n        }\n\n        this.editor._codeMirror.operation(function () {\n            while (true) {\n                // Iterate over all lines that were previously marked with an error\n                lineHandle = self._errorLineHandles.pop();\n\n                if (!lineHandle) {\n                    break;\n                }\n\n                self.editor._codeMirror.removeLineClass(lineHandle, \"wrap\", SYNC_ERROR_CLASS);\n            }\n        });\n    };\n\n    /**\n     * Returns true if we should be highlighting.\n     * @return {boolean}\n     */\n    LiveDocument.prototype.isHighlightEnabled = function () {\n        return PreferencesManager.getViewState(\"livedev.highlight\");\n    };\n\n    /**\n     * Called when the highlight in the browser should be updated because the user has\n     * changed the selection. Does nothing in base class, should be implemented by subclasses\n     * that implement highlighting functionality.\n     */\n    LiveDocument.prototype.updateHighlight = function () {\n        // Does nothing in base class\n    };\n\n    /**\n     * Hides the current highlight in the browser.\n     * @param {boolean=} temporary If true, this isn't a change of state - we're just about\n     *     to re-highlight.\n     */\n    LiveDocument.prototype.hideHighlight = function (temporary) {\n        if (!temporary) {\n            this._lastHighlight = null;\n        }\n        this.protocol.evaluate(\"_LD.hideHighlight()\");\n    };\n\n    /**\n     * Highlight all nodes affected by a CSS rule. Should be called by subclass implementations of\n     * `updateHighlight()`.\n     * @param {string} name The selector whose matched nodes should be highlighted.\n     */\n    LiveDocument.prototype.highlightRule = function (name) {\n        if (this._lastHighlight === name) {\n            return;\n        }\n        this._lastHighlight = name;\n        this.protocol.evaluate(\"_LD.highlightRule(\" + JSON.stringify(name) + \")\");\n    };\n\n    /**\n     * Highlight all nodes with 'data-brackets-id' value\n     * that matches id, or if id is an array, matches any of the given ids.\n     * Should be called by subclass implementations of\n     * `updateHighlight()`.\n     * @param {string|Array.<string>} value of the 'data-brackets-id' to match,\n     * or an array of such.\n     */\n    LiveDocument.prototype.highlightDomElement = function (ids) {\n        var selector = \"\";\n        if (!Array.isArray(ids)) {\n            ids = [ids];\n        }\n        _.each(ids, function (id) {\n            if (selector !== \"\") {\n                selector += \",\";\n            }\n            selector += \"[data-brackets-id='\" + id + \"']\";\n        });\n        this.highlightRule(selector);\n    };\n\n    /**\n     * Redraw active highlights.\n     */\n    LiveDocument.prototype.redrawHighlights = function () {\n        if (this.isHighlightEnabled()) {\n            this.protocol.evaluate(\"_LD.redrawHighlights()\");\n        }\n    };\n\n    module.exports = LiveDocument;\n});\n"],"file":"LiveDocument.js"}
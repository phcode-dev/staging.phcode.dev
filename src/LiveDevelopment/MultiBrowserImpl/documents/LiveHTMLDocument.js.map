{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/documents/LiveHTMLDocument.js"],"names":["define","require","exports","module","EventDispatcher","PerfUtils","_","LiveDocument","HTMLInstrumentation","LiveHTMLDocument","protocol","urlResolver","doc","editor","apply","this","arguments","_instrumentationEnabled","_relatedDocuments","stylesheets","scripts","_onChange","bind","on","_onRelated","_onStylesheetAdded","_onStylesheetRemoved","_onScriptAdded","_onScriptRemoved","prototype","Object","create","constructor","parentClass","makeEventDispatcher","isLiveEditingEnabled","setInstrumentationEnabled","enabled","scanDocument","_markText","getResponseData","body","generateInstrumentedHTML","getRemoteScript","getText","close","off","call","updateHighlight","isHighlightEnabled","ids","each","getSelections","sel","tagID","_getTagIDAtDocumentPos","reversed","end","start","push","length","highlightDomElement","hideHighlight","_compareWithBrowser","change","event","perfTimerName","isNestedTimer","isActive","markStart","self","result","getUnappliedEditList","applyEditsPromise","edits","evaluate","JSON","stringify","always","addMeasurement","errors","_updateErrorDisplay","_debug","console","log","done","msg","related","href","src","isRelated","fullPath","getRelated"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * LiveHTMLDocument manages a single HTML source document. Edits to the HTML are applied live in\n * the browser, and the DOM node corresponding to the selection is highlighted.\n *\n * LiveHTMLDocument relies on HTMLInstrumentation in order to map tags in the HTML source text\n * to DOM nodes in the browser, so edits can be incrementally applied.\n */\ndefine(function (require, exports, module) {\n\n\n    var EventDispatcher     = require(\"utils/EventDispatcher\"),\n        PerfUtils           = require(\"utils/PerfUtils\"),\n        _                   = require(\"thirdparty/lodash\"),\n        LiveDocument        = require(\"LiveDevelopment/MultiBrowserImpl/documents/LiveDocument\"),\n        HTMLInstrumentation = require(\"LiveDevelopment/MultiBrowserImpl/language/HTMLInstrumentation\");\n\n\n    /**\n     * @constructor\n     * @see LiveDocument\n     * @param {LiveDevProtocol} protocol The protocol to use for communicating with the browser.\n     * @param {function(string): string} urlResolver A function that, given a path on disk, should return\n     *     the URL that Live Development serves that path at.\n     * @param {Document} doc The Brackets document that this live document is connected to.\n     * @param {?Editor} editor If specified, a particular editor that this live document is managing.\n     *     If not specified initially, the LiveDocument will connect to the editor for the given document\n     *     when it next becomes the active editor.\n     */\n    function LiveHTMLDocument(protocol, urlResolver, doc, editor) {\n        LiveDocument.apply(this, arguments);\n\n        this._instrumentationEnabled = false;\n        this._relatedDocuments = {\n            stylesheets: {},\n            scripts: {}\n        };\n\n        this._onChange = this._onChange.bind(this);\n        this.doc.on(\"change\", this._onChange);\n\n        this._onRelated = this._onRelated.bind(this);\n        this.protocol.on(\"DocumentRelated\", this._onRelated);\n\n        this._onStylesheetAdded = this._onStylesheetAdded.bind(this);\n        this.protocol.on(\"StylesheetAdded\", this._onStylesheetAdded);\n\n        this._onStylesheetRemoved = this._onStylesheetRemoved.bind(this);\n        this.protocol.on(\"StylesheetRemoved\", this._onStylesheetRemoved);\n\n        this._onScriptAdded = this._onScriptAdded.bind(this);\n        this.protocol.on(\"ScriptAdded\", this._onScriptAdded);\n\n        this._onScriptRemoved = this._onScriptRemoved.bind(this);\n        this.protocol.on(\"ScriptRemoved\", this._onScriptRemoved);\n\n    }\n\n    LiveHTMLDocument.prototype = Object.create(LiveDocument.prototype);\n    LiveHTMLDocument.prototype.constructor = LiveHTMLDocument;\n    LiveHTMLDocument.prototype.parentClass = LiveDocument.prototype;\n\n    EventDispatcher.makeEventDispatcher(LiveHTMLDocument.prototype);\n\n    /**\n     * @override\n     * Returns true if document edits appear live in the connected browser.\n     * @return {boolean}\n     */\n    LiveHTMLDocument.prototype.isLiveEditingEnabled = function () {\n        return this._instrumentationEnabled;\n    };\n\n    /**\n     * @override\n     * Called to turn instrumentation on or off for this file. Triggered by being\n     * requested from the browser.\n     * TODO: this doesn't seem necessary...if we're a live document, we should\n     * always have instrumentation on anyway.\n     * @param {boolean} enabled\n     */\n    LiveHTMLDocument.prototype.setInstrumentationEnabled = function (enabled) {\n        if (!this.editor) {\n            // TODO: error\n            return;\n        }\n        if (enabled && !this._instrumentationEnabled) {\n            // TODO: not clear why we do this here instead of waiting for the next time we want to\n            // generate the instrumented HTML. This won't work if the dom offsets are out of date.\n            HTMLInstrumentation.scanDocument(this.doc);\n            HTMLInstrumentation._markText(this.editor);\n        }\n\n        this._instrumentationEnabled = enabled;\n    };\n\n    /**\n     * Returns the instrumented version of the file.\n     * @return {{body: string}} instrumented doc\n     */\n    LiveHTMLDocument.prototype.getResponseData = function (enabled) {\n        var body;\n        if (this._instrumentationEnabled) {\n            body = HTMLInstrumentation.generateInstrumentedHTML(this.editor, this.protocol.getRemoteScript());\n        }\n\n        return {\n            body: body || this.doc.getText()\n        };\n    };\n\n    /**\n     * @override\n     * Closes the live document, terminating its connection to the browser.\n     */\n    LiveHTMLDocument.prototype.close = function () {\n        this.doc.off(\"change\", this._onChange);\n        this.parentClass.close.call(this);\n    };\n\n    /**\n     * @override\n     * Update the highlights in the browser based on the cursor position.\n     */\n    LiveHTMLDocument.prototype.updateHighlight = function () {\n        if (!this.editor || !this.isHighlightEnabled()) {\n            return;\n        }\n        var editor = this.editor,\n            ids = [];\n        _.each(this.editor.getSelections(), function (sel) {\n            var tagID = HTMLInstrumentation._getTagIDAtDocumentPos(\n                editor,\n                sel.reversed ? sel.end : sel.start\n            );\n            if (tagID !== -1) {\n                ids.push(tagID);\n            }\n        });\n\n        if (!ids.length) {\n            this.hideHighlight();\n        } else {\n            this.highlightDomElement(ids);\n        }\n    };\n\n    /**\n     * @private\n     * For the given editor change, compare the resulting browser DOM with the\n     * in-editor DOM. If there are any diffs, a warning is logged to the\n     * console along with each diff.\n     * @param {Object} change CodeMirror editor change data\n     */\n    LiveHTMLDocument.prototype._compareWithBrowser = function (change) {\n        // TODO: Not implemented.\n    };\n\n    /**\n     * @private\n     * Handles edits to the document. Determines what's changed in the source and sends DOM diffs to the browser.\n     * @param {$.Event} event\n     * @param {Document} doc\n     * @param {Object} change\n     */\n    LiveHTMLDocument.prototype._onChange = function (event, doc, change) {\n        // Make sure LiveHTML is turned on\n        if (!this._instrumentationEnabled) {\n            return;\n        }\n\n        // Apply DOM edits is async, so previous PerfUtils timer may still be\n        // running. PerfUtils does not support running multiple timers with same\n        // name, so do not start another timer in this case.\n        var perfTimerName   = \"LiveHTMLDocument applyDOMEdits\",\n            isNestedTimer   = PerfUtils.isActive(perfTimerName);\n        if (!isNestedTimer) {\n            PerfUtils.markStart(perfTimerName);\n        }\n\n        var self                = this,\n            result              = HTMLInstrumentation.getUnappliedEditList(this.editor, change),\n            applyEditsPromise;\n\n        if (result.edits) {\n            applyEditsPromise = this.protocol.evaluate(\"_LD.applyDOMEdits(\" + JSON.stringify(result.edits) + \")\");\n\n            applyEditsPromise.always(function () {\n                if (!isNestedTimer) {\n                    PerfUtils.addMeasurement(perfTimerName);\n                }\n            });\n        }\n\n        this.errors = result.errors || [];\n        this._updateErrorDisplay();\n\n        // Debug-only: compare in-memory vs. in-browser DOM\n        // edit this file or set a conditional breakpoint at the top of this function:\n        //     \"this._debug = true, false\"\n        if (this._debug) {\n            console.log(\"Edits applied to browser were:\");\n            console.log(JSON.stringify(result.edits, null, 2));\n            applyEditsPromise.done(function () {\n                self._compareWithBrowser(change);\n            });\n        }\n    };\n\n\n    /**\n     * @private\n     * Handles message DocumentRelated from the browser.\n     * @param {$.Event} event\n     * @param {Object} msg\n     */\n    LiveHTMLDocument.prototype._onRelated = function (event, msg) {\n        this._relatedDocuments = msg.related;\n        return;\n    };\n\n    /**\n     * @private\n     * Handles message Stylesheet.Added from the browser.\n     * @param {$.Event} event\n     * @param {Object} msg\n     */\n    LiveHTMLDocument.prototype._onStylesheetAdded = function (event, msg) {\n        this._relatedDocuments.stylesheets[msg.href] = true;\n        return;\n    };\n\n    /**\n     * @private\n     * Handles message Stylesheet.Removed from the browser.\n     * @param {$.Event} event\n     * @param {Object} msg\n     */\n    LiveHTMLDocument.prototype._onStylesheetRemoved = function (event, msg) {\n        delete (this._relatedDocuments.stylesheets[msg.href]);\n        return;\n    };\n\n    /**\n     * @private\n     * Handles message Script.Added from the browser.\n     * @param {$.Event} event\n     * @param {Object} msg\n     */\n    LiveHTMLDocument.prototype._onScriptAdded = function (event, msg) {\n        this._relatedDocuments.scripts[msg.src] = true;\n        return;\n    };\n\n     /**\n     * @private\n     * Handles message Script.Removed from the browser.\n     * @param {$.Event} event\n     * @param {Object} msg\n     */\n    LiveHTMLDocument.prototype._onScriptRemoved = function (event, msg) {\n        delete (this._relatedDocuments.scripts[msg.src]);\n        return;\n    };\n\n     /**\n     * For the given path, check if the document is related to the live HTML document.\n     * Related means that is an external Javascript or CSS file that is included as part of the DOM.\n     * @param {String} fullPath.\n     * @return {boolean} - is related or not.\n     */\n    LiveHTMLDocument.prototype.isRelated = function (fullPath) {\n        return (this._relatedDocuments.scripts[this.urlResolver(fullPath)] || this._relatedDocuments.stylesheets[this.urlResolver(fullPath)]);\n    };\n\n    LiveHTMLDocument.prototype.getRelated = function () {\n        return this._relatedDocuments;\n    };\n    // Export the class\n    module.exports = LiveHTMLDocument;\n});\n"],"file":"LiveHTMLDocument.js"}
{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/documents/LiveHTMLDocument.js"],"names":["define","require","exports","module","EventDispatcher","PerfUtils","_","LiveDocument","HTMLInstrumentation","LiveHTMLDocument","protocol","urlResolver","doc","editor","apply","this","arguments","addRef","_instrumentationEnabled","_relatedDocuments","stylesheets","scripts","_onChange","bind","on","_onRelated","_onStylesheetAdded","_onStylesheetRemoved","_onScriptAdded","_onScriptRemoved","prototype","Object","create","constructor","parentClass","makeEventDispatcher","isLiveEditingEnabled","setInstrumentationEnabled","enabled","force","scanDocument","_markText","getResponseData","body","generateInstrumentedHTML","getRemoteScript","getText","close","releaseRef","off","call","updateHighlight","isHighlightEnabled","ids","each","getSelections","sel","tagID","_getTagIDAtDocumentPos","reversed","end","start","push","length","highlightDomElement","hideHighlight","_compareWithBrowser","change","event","perfTimerName","isNestedTimer","isActive","markStart","self","result","getUnappliedEditList","applyEditsPromise","edits","evaluate","JSON","stringify","always","addMeasurement","errors","_updateErrorDisplay","_debug","console","log","done","msg","related","href","src","isRelated","fullPath","getRelated"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * LiveHTMLDocument manages a single HTML source document. Edits to the HTML are applied live in\n * the browser, and the DOM node corresponding to the selection is highlighted.\n *\n * LiveHTMLDocument relies on HTMLInstrumentation in order to map tags in the HTML source text\n * to DOM nodes in the browser, so edits can be incrementally applied.\n */\ndefine(function (require, exports, module) {\n\n\n    var EventDispatcher     = require(\"utils/EventDispatcher\"),\n        PerfUtils           = require(\"utils/PerfUtils\"),\n        _                   = require(\"thirdparty/lodash\"),\n        LiveDocument        = require(\"LiveDevelopment/MultiBrowserImpl/documents/LiveDocument\"),\n        HTMLInstrumentation = require(\"LiveDevelopment/MultiBrowserImpl/language/HTMLInstrumentation\");\n\n\n    /**\n     * @constructor\n     * @see LiveDocument\n     * @param {LiveDevProtocol} protocol The protocol to use for communicating with the browser.\n     * @param {function(string): string} urlResolver A function that, given a path on disk, should return\n     *     the URL that Live Development serves that path at.\n     * @param {Document} doc The Brackets document that this live document is connected to.\n     * @param {?Editor} editor If specified, a particular editor that this live document is managing.\n     *     If not specified initially, the LiveDocument will connect to the editor for the given document\n     *     when it next becomes the active editor.\n     */\n    function LiveHTMLDocument(protocol, urlResolver, doc, editor) {\n        LiveDocument.apply(this, arguments);\n        this.doc.addRef();\n\n        this._instrumentationEnabled = false;\n        this._relatedDocuments = {\n            stylesheets: {},\n            scripts: {}\n        };\n\n        this._onChange = this._onChange.bind(this);\n        this.doc.on(\"change\", this._onChange);\n\n        this._onRelated = this._onRelated.bind(this);\n        this.protocol.on(\"DocumentRelated\", this._onRelated);\n\n        this._onStylesheetAdded = this._onStylesheetAdded.bind(this);\n        this.protocol.on(\"StylesheetAdded\", this._onStylesheetAdded);\n\n        this._onStylesheetRemoved = this._onStylesheetRemoved.bind(this);\n        this.protocol.on(\"StylesheetRemoved\", this._onStylesheetRemoved);\n\n        this._onScriptAdded = this._onScriptAdded.bind(this);\n        this.protocol.on(\"ScriptAdded\", this._onScriptAdded);\n\n        this._onScriptRemoved = this._onScriptRemoved.bind(this);\n        this.protocol.on(\"ScriptRemoved\", this._onScriptRemoved);\n\n    }\n\n    LiveHTMLDocument.prototype = Object.create(LiveDocument.prototype);\n    LiveHTMLDocument.prototype.constructor = LiveHTMLDocument;\n    LiveHTMLDocument.prototype.parentClass = LiveDocument.prototype;\n\n    EventDispatcher.makeEventDispatcher(LiveHTMLDocument.prototype);\n\n    /**\n     * @override\n     * Returns true if document edits appear live in the connected browser.\n     * @return {boolean}\n     */\n    LiveHTMLDocument.prototype.isLiveEditingEnabled = function () {\n        return this._instrumentationEnabled;\n    };\n\n    /**\n     * @override\n     * Called to turn instrumentation on or off for this file. Triggered by being\n     * requested from the browser.\n     * TODO: this doesn't seem necessary...if we're a live document, we should\n     * always have instrumentation on anyway.\n     * @param {boolean} enabled\n     * @param {boolean} [force]\n     */\n    LiveHTMLDocument.prototype.setInstrumentationEnabled = function (enabled, force) {\n        if (!this.editor) {\n            // TODO: error\n            return;\n        }\n        if (enabled && (force || !this._instrumentationEnabled)) {\n            // TODO: not clear why we do this here instead of waiting for the next time we want to\n            // generate the instrumented HTML. This won't work if the dom offsets are out of date.\n            HTMLInstrumentation.scanDocument(this.doc);\n            HTMLInstrumentation._markText(this.editor);\n        }\n\n        this._instrumentationEnabled = enabled;\n    };\n\n    /**\n     * Returns the instrumented version of the file.\n     * @return {{body: string}} instrumented doc\n     */\n    LiveHTMLDocument.prototype.getResponseData = function (enabled) {\n        var body;\n        if (this._instrumentationEnabled) {\n            body = HTMLInstrumentation.generateInstrumentedHTML(this.editor, this.protocol.getRemoteScript());\n        }\n\n        return {\n            body: body || this.doc.getText()\n        };\n    };\n\n    /**\n     * @override\n     * Closes the live document, terminating its connection to the browser.\n     */\n    LiveHTMLDocument.prototype.close = function () {\n        this.doc.releaseRef();\n        this.doc.off(\"change\", this._onChange);\n        this.protocol.off(\"DocumentRelated\", this._onRelated);\n        this.protocol.off(\"StylesheetAdded\", this._onStylesheetAdded);\n        this.protocol.off(\"StylesheetRemoved\", this._onStylesheetRemoved);\n        this.protocol.off(\"ScriptAdded\", this._onScriptAdded);\n        this.protocol.off(\"ScriptRemoved\", this._onScriptRemoved);\n\n        this.parentClass.close.call(this);\n    };\n\n    /**\n     * @override\n     * Update the highlights in the browser based on the cursor position.\n     */\n    LiveHTMLDocument.prototype.updateHighlight = function () {\n        if (!this.editor || !this.isHighlightEnabled()) {\n            return;\n        }\n        var editor = this.editor,\n            ids = [];\n        _.each(this.editor.getSelections(), function (sel) {\n            var tagID = HTMLInstrumentation._getTagIDAtDocumentPos(\n                editor,\n                sel.reversed ? sel.end : sel.start\n            );\n            if (tagID !== -1) {\n                ids.push(tagID);\n            }\n        });\n\n        if (!ids.length) {\n            this.hideHighlight();\n        } else {\n            this.highlightDomElement(ids);\n        }\n    };\n\n    /**\n     * @private\n     * For the given editor change, compare the resulting browser DOM with the\n     * in-editor DOM. If there are any diffs, a warning is logged to the\n     * console along with each diff.\n     * @param {Object} change CodeMirror editor change data\n     */\n    LiveHTMLDocument.prototype._compareWithBrowser = function (change) {\n        // TODO: Not implemented.\n    };\n\n    /**\n     * @private\n     * Handles edits to the document. Determines what's changed in the source and sends DOM diffs to the browser.\n     * @param {$.Event} event\n     * @param {Document} doc\n     * @param {Object} change\n     */\n    LiveHTMLDocument.prototype._onChange = function (event, doc, change) {\n        // Make sure LiveHTML is turned on\n        if (!this._instrumentationEnabled) {\n            return;\n        }\n\n        // Apply DOM edits is async, so previous PerfUtils timer may still be\n        // running. PerfUtils does not support running multiple timers with same\n        // name, so do not start another timer in this case.\n        var perfTimerName   = \"LiveHTMLDocument applyDOMEdits\",\n            isNestedTimer   = PerfUtils.isActive(perfTimerName);\n        if (!isNestedTimer) {\n            PerfUtils.markStart(perfTimerName);\n        }\n\n        var self                = this,\n            result              = HTMLInstrumentation.getUnappliedEditList(this.editor, change),\n            applyEditsPromise;\n\n        if (result.edits) {\n            applyEditsPromise = this.protocol.evaluate(\"_LD.applyDOMEdits(\" + JSON.stringify(result.edits) + \")\");\n\n            applyEditsPromise.always(function () {\n                if (!isNestedTimer) {\n                    PerfUtils.addMeasurement(perfTimerName);\n                }\n            });\n        }\n\n        this.errors = result.errors || [];\n        this._updateErrorDisplay();\n\n        // Debug-only: compare in-memory vs. in-browser DOM\n        // edit this file or set a conditional breakpoint at the top of this function:\n        //     \"this._debug = true, false\"\n        if (this._debug) {\n            console.log(\"Edits applied to browser were:\");\n            console.log(JSON.stringify(result.edits, null, 2));\n            applyEditsPromise.done(function () {\n                self._compareWithBrowser(change);\n            });\n        }\n    };\n\n\n    /**\n     * @private\n     * Handles message DocumentRelated from the browser.\n     * @param {$.Event} event\n     * @param {Object} msg\n     */\n    LiveHTMLDocument.prototype._onRelated = function (event, msg) {\n        this._relatedDocuments = msg.related;\n        return;\n    };\n\n    /**\n     * @private\n     * Handles message Stylesheet.Added from the browser.\n     * @param {$.Event} event\n     * @param {Object} msg\n     */\n    LiveHTMLDocument.prototype._onStylesheetAdded = function (event, msg) {\n        this._relatedDocuments.stylesheets[msg.href] = true;\n        return;\n    };\n\n    /**\n     * @private\n     * Handles message Stylesheet.Removed from the browser.\n     * @param {$.Event} event\n     * @param {Object} msg\n     */\n    LiveHTMLDocument.prototype._onStylesheetRemoved = function (event, msg) {\n        delete (this._relatedDocuments.stylesheets[msg.href]);\n        return;\n    };\n\n    /**\n     * @private\n     * Handles message Script.Added from the browser.\n     * @param {$.Event} event\n     * @param {Object} msg\n     */\n    LiveHTMLDocument.prototype._onScriptAdded = function (event, msg) {\n        this._relatedDocuments.scripts[msg.src] = true;\n        return;\n    };\n\n     /**\n     * @private\n     * Handles message Script.Removed from the browser.\n     * @param {$.Event} event\n     * @param {Object} msg\n     */\n    LiveHTMLDocument.prototype._onScriptRemoved = function (event, msg) {\n        delete (this._relatedDocuments.scripts[msg.src]);\n        return;\n    };\n\n     /**\n     * For the given path, check if the document is related to the live HTML document.\n     * Related means that is an external Javascript or CSS file that is included as part of the DOM.\n     * @param {String} fullPath.\n     * @return {boolean} - is related or not.\n     */\n    LiveHTMLDocument.prototype.isRelated = function (fullPath) {\n        return (this._relatedDocuments.scripts[this.urlResolver(fullPath)] || this._relatedDocuments.stylesheets[this.urlResolver(fullPath)]);\n    };\n\n    LiveHTMLDocument.prototype.getRelated = function () {\n        return this._relatedDocuments;\n    };\n    // Export the class\n    module.exports = LiveHTMLDocument;\n});\n"],"file":"LiveHTMLDocument.js"}
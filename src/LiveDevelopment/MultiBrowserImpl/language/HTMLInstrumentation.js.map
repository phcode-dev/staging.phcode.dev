{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/language/HTMLInstrumentation.js"],"names":["define","require","exports","module","DocumentManager","HTMLDOMDiff","HTMLSimpleDOM","allowIncremental","_cachedValues","_removeDocFromCache","evt","document","hasOwnProperty","file","fullPath","off","_posEq","pos1","pos2","line","ch","_getSortedTagMarks","marks","markCache","filter","mark","tagID","map","range","find","sort","mark1","mark2","from","_getMarkerAtDocumentPos","editor","pos","preferParent","match","_codeMirror","findMarksAt","length","to","_getTagIDAtDocumentPos","_markTags","cm","node","children","forEach","childNode","isElement","markText","startPos","endPos","_markTextFromDOM","dom","getAllMarks","operation","clear","DOMUpdater","previousDOM","changeList","text","startOffset","startOffsetPos","isDangerousEdit","test","this","isIncremental","change","removed","startMark","getRange","changedTagID","indexFromPos","getText","Builder","call","_hasAncestorWithID","id","ancestor","parent","_updateDOM","undefined","updater","result","update","errors","edits","domdiff","oldSubtree","newSubtree","newDOM","nodeMap","_wasIncremental","getUnappliedEditList","cachedValue","invalid","timestamp","diskTimestamp","dirty","fullBuild","_processBrowserSimpleDOM","browserRoot","editorRootTagID","root","_processElement","elem","attributes","child","isText","getTextNodeID","_getBrowserDiff","browserSimpleDOM","editorRoot","diff","browser","scanDocument","doc","build","generateInstrumentedHTML","remoteScript","orig","gen","lastIndex","remoteScriptInserted","walk","tag","attrText","start","console","warn","insertIndex","substr","openEnd","_markText","cache","error","_resetCache","prototype","Object","create","getID","newTag","currentTagID","_offsetPos","getNewID","oldNode","_updateMarkedRanges","updateIDs","keys","markInfo","splice","indexOf","String","Number","_buildNodeMap","_handleDeletions","oldSubtreeMap","newSubtreeMap","deletedIDs","key","push","childIndex","$","extend","curParent","on","_allowIncremental"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: HTML Instrumentation*/\n\n/**\n * HTMLInstrumentation\n *\n * This module contains functions for \"instrumenting\" html code so that we can track\n * the relationship of source code to DOM nodes in the browser. This functionality is\n * used by both live highlighting and live HTML editing.\n *\n * During live HTML development, the HTML source code is parsed to identify tag boundaries.\n * Each tag is assigned an ID which is stored in markers that are inserted into the editor.\n * These IDs are also included in \"data-brackets-id\" attributes that are inserted in the\n * HTML code that's served to the browser via the Live Development server.\n *\n * The primary function for that functionality is generateInstrumentedHTML(). This does just\n * what it says - it will read the HTML content in the doc and generate instrumented code by\n * injecting \"data-brackets-id\" attributes. Additionally, it caches the parsed DOM for use\n * by future updates.\n *\n * As the user makes edits in the editor, we determine how the DOM structure should change\n * based on the edits to the source code; those edits are generated by getUnappliedEditList().\n * HTMLDocument (in LiveDevelopment) takes those edits and sends them to the browser (via\n * RemoteFunctions) so that the DOM structure in the live preview can be updated accordingly.\n *\n * There are also helper functions for returning the tagID associated with a specified\n * position in the document--this is used in live highlighting.\n */\ndefine(function (require, exports, module) {\n\n\n    var DocumentManager = require(\"document/DocumentManager\"),\n        HTMLDOMDiff     = require(\"language/HTMLDOMDiff\"),\n        HTMLSimpleDOM   = require(\"LiveDevelopment/MultiBrowserImpl/language/HTMLSimpleDOM\");\n\n    var allowIncremental = true;\n\n    // Hash of scanned documents. Key is the full path of the doc. Value is an object\n    // with two properties: timestamp and dom. Timestamp is the document timestamp,\n    // dom is the root node of a simple DOM tree.\n    var _cachedValues = {};\n\n    /**\n     * @private\n     * Removes the cached information (DOM, timestamp, etc.) used by HTMLInstrumentation\n     * for the given document.\n     * @param {$.Event} event (unused)\n     * @param {Document} document The document to clear from the cache.\n     */\n    function _removeDocFromCache(evt, document) {\n        if (_cachedValues.hasOwnProperty(document.file.fullPath)) {\n            delete _cachedValues[document.file.fullPath];\n            document.off(\".htmlInstrumentation\");\n        }\n    }\n\n    /**\n     * @private\n     * Checks if two CodeMirror-style {line, ch} positions are equal.\n     * @param {{line: number, ch: number}} pos1\n     * @param {{line: number, ch: number}} pos2\n     * @return {boolean} true if pos1 and pos2 are equal. Fails if either of them is falsy.\n     */\n    function _posEq(pos1, pos2) {\n        return pos1 && pos2 && pos1.line === pos2.line && pos1.ch === pos2.ch;\n    }\n\n    /**\n     * @private\n     * Filters the given marks to find the ones that correspond to instrumented tags,\n     * sorts them by their starting position, and looks up and/or stores their ranges\n     * in the given markCache.\n     * @param {Array} marks An array of mark objects returned by CodeMirror.\n     * @param {Object} markCache An object that maps tag IDs to {mark, range} objects.\n     *     If a mark in the marks array is already in the cache, we use the cached range info,\n     *     otherwise we look up its range in CodeMirror and store it in the cache.\n     * @return {Array.<{mark: Object, range: {line: number, ch: number}}>} The filtered and\n     *     sorted array of mark info objects (each of which contains the mark and its range,\n     *     so the range doesn't need to be looked up again).\n     */\n    function _getSortedTagMarks(marks, markCache) {\n        marks = marks.filter(function (mark) {\n            return !!mark.tagID;\n        }).map(function (mark) {\n            // All marks should exist since we just got them from CodeMirror.\n            if (!markCache[mark.tagID]) {\n                markCache[mark.tagID] = {mark: mark, range: mark.find()};\n            }\n            return markCache[mark.tagID];\n        });\n        marks.sort(function (mark1, mark2) {\n            return (mark1.range.from.line === mark2.range.from.line ?\n                    mark1.range.from.ch - mark2.range.from.ch :\n                    mark1.range.from.line - mark2.range.from.line);\n        });\n\n        return marks;\n    }\n\n    /**\n     * @private\n     * Finds the mark for the DOM node at the given position in the editor.\n     * @param {Editor} editor The editor containing the instrumented document.\n     * @param {{line: number, ch: number}} pos The position to find the DOM marker for.\n     * @param {boolean} preferParent If true, and the pos is at one or the other edge of the\n     *     innermost marked range, return the immediately enclosing mark instead.\n     * @param {Object=} markCache An optional cache to look up positions of existing\n     *     markers. (This avoids calling the find() operation on marks multiple times,\n     *     which is expensive.)\n     * @return {Object} The CodeMirror mark object that represents the DOM node at the\n     *     given position.\n     */\n    function _getMarkerAtDocumentPos(editor, pos, preferParent, markCache) {\n        var marks, match;\n\n        markCache = markCache || {};\n        marks = _getSortedTagMarks(editor._codeMirror.findMarksAt(pos), markCache);\n        if (!marks.length) {\n            return null;\n        }\n\n        // The mark with the latest start is the innermost one.\n        match = marks[marks.length - 1];\n        if (preferParent) {\n            // If the match is exactly at the edge of the range and preferParent is set,\n            // we want to pop upwards.\n            if (_posEq(match.range.from, pos) || _posEq(match.range.to, pos)) {\n                if (marks.length > 1) {\n                    match = marks[marks.length - 2];\n                } else {\n                    // We must be outside the root, so there's no containing tag.\n                    match = null;\n                }\n            }\n        }\n\n        return match.mark;\n    }\n\n    /**\n     * Get the instrumented tagID at the specified position. Returns -1 if\n     * there are no instrumented tags at the location.\n     * The _markText() function must be called before calling this function.\n     *\n     * NOTE: This function is \"private\" for now (has a leading underscore), since\n     * the API is likely to change in the future.\n     *\n     * @param {Editor} editor The editor to scan.\n     * @param {{line: number, ch: number}} pos The position to find the DOM marker for.\n     * @param {Object=} markCache An optional cache to look up positions of existing\n     *     markers. (This avoids calling the find() operation on marks multiple times,\n     *     which is expensive.)\n     * @return {number} tagID at the specified position, or -1 if there is no tag\n     */\n    function _getTagIDAtDocumentPos(editor, pos, markCache) {\n        var match = _getMarkerAtDocumentPos(editor, pos, false, markCache);\n\n        return (match) ? match.tagID : -1;\n    }\n\n    /**\n     * Recursively walks the SimpleDOM starting at node and marking\n     * all tags in the CodeMirror instance. The more useful interface\n     * is the _markTextFromDOM function which clears existing marks\n     * before calling this function to create new ones.\n     *\n     * @param {CodeMirror} cm CodeMirror instance in which to mark tags\n     * @param {Object} node SimpleDOM node to use as the root for marking\n     */\n    function _markTags(cm, node) {\n        node.children.forEach(function (childNode) {\n            if (childNode.isElement()) {\n                _markTags(cm, childNode);\n            }\n        });\n        var mark = cm.markText(node.startPos, node.endPos);\n        mark.tagID = node.tagID;\n    }\n\n    /**\n     * Clears the marks from the document and creates new ones.\n     *\n     * @param {Editor} editor Editor object holding this document\n     * @param {Object} dom SimpleDOM root object that contains the parsed structure\n     */\n    function _markTextFromDOM(editor, dom) {\n        var cm = editor._codeMirror;\n\n        // Remove existing marks\n        var marks = cm.getAllMarks();\n        cm.operation(function () {\n            marks.forEach(function (mark) {\n                if (mark.hasOwnProperty(\"tagID\")) {\n                    mark.clear();\n                }\n            });\n        });\n\n        // Mark\n        _markTags(cm, dom);\n    }\n\n    /**\n     * @constructor\n     * Subclass of HTMLSimpleDOM.Builder that builds an updated DOM after changes have been made,\n     * and maps nodes from the new DOM to the old DOM by tag ID. For non-structural edits, avoids reparsing\n     * the whole editor. Also updates marks in the editor based on the new DOM state.\n     *\n     * @param {Object} previousDOM The root of the HTMLSimpleDOM tree representing a previous state of the DOM.\n     * @param {Editor} editor The editor containing the instrumented HTML.\n     * @param {Array=} changeList An optional array of CodeMirror change records representing the\n     *     edits the user made in the editor since previousDOM was built. If provided, and the\n     *     edits are not structural, DOMUpdater will do a fast incremental reparse. If not provided,\n     *     or if one of the edits changes the DOM structure, DOMUpdater will reparse the whole DOM.\n     */\n    function DOMUpdater(previousDOM, editor, changeList) {\n        var text, startOffset = 0, startOffsetPos;\n\n        this.isIncremental = false;\n\n        function isDangerousEdit(text) {\n            // We don't consider & dangerous since entities only affect text content, not\n            // overall DOM structure.\n            return (/[<>\\/=\\\"\\']/).test(text);\n        }\n\n        // If there's more than one change, be conservative and assume we have to do a full reparse.\n        if (changeList && changeList.length === 1) {\n            // If the inserted or removed text doesn't have any characters that could change the\n            // structure of the DOM (e.g. by adding or removing a tag boundary), then we can do\n            // an incremental reparse of just the parent tag containing the edit. This should just\n            // be the marked range that contains the beginning of the edit range, since that position\n            // isn't changed by the edit.\n            var change = changeList[0];\n            if (!isDangerousEdit(change.text) && !isDangerousEdit(change.removed)) {\n                // If the edit is right at the beginning or end of a tag, we want to be conservative\n                // and use the parent as the edit range.\n                var startMark = _getMarkerAtDocumentPos(editor, change.from, true);\n                if (startMark) {\n                    var range = startMark.find();\n                    if (range) {\n                        text = editor._codeMirror.getRange(range.from, range.to);\n                        this.changedTagID = startMark.tagID;\n                        startOffsetPos = range.from;\n                        startOffset = editor._codeMirror.indexFromPos(startOffsetPos);\n                        this.isIncremental = true;\n                    }\n                }\n            }\n        }\n\n        if (!this.changedTagID) {\n            // We weren't able to incrementally update, so just rebuild and diff everything.\n            text = editor.document.getText();\n        }\n\n        HTMLSimpleDOM.Builder.call(this, text, startOffset, startOffsetPos);\n        this.editor = editor;\n        this.cm = editor._codeMirror;\n        this.previousDOM = previousDOM;\n    }\n\n    DOMUpdater.prototype = Object.create(HTMLSimpleDOM.Builder.prototype);\n\n    /**\n     * @private\n     * Returns true if the given node has an ancestor whose tagID is the given ID.\n     * @param {Object} node A node from an HTMLSimpleDOM structure.\n     * @param {number} id The ID of the tag to check for.\n     * @return {boolean} true if the node has an ancestor with that ID.\n     */\n    function _hasAncestorWithID(node, id) {\n        var ancestor = node.parent;\n        while (ancestor && ancestor.tagID !== id) {\n            ancestor = ancestor.parent;\n        }\n        return !!ancestor;\n    }\n\n    /**\n     * Overrides the `getID` method to return the tag ID from the document. If a viable tag\n     * ID cannot be found in the document marks, then a new ID is returned. This will also\n     * assign a new ID if the tag changed between the previous and current versions of this\n     * node.\n     *\n     * @param {Object} newTag tag object for the current element\n     * @return {int} best ID\n     */\n    DOMUpdater.prototype.getID = function (newTag, markCache) {\n        // Get the mark at the start of the tagname (not before the beginning of the tag, because that's\n        // actually inside the parent).\n        var currentTagID = _getTagIDAtDocumentPos(this.editor, HTMLSimpleDOM._offsetPos(newTag.startPos, 1), markCache);\n\n        // If the new tag is in an unmarked range, or the marked range actually corresponds to an\n        // ancestor tag, then this must be a newly inserted tag, so give it a new tag ID.\n        if (currentTagID === -1 || _hasAncestorWithID(newTag, currentTagID)) {\n            currentTagID = this.getNewID();\n        } else {\n            // If the tag has changed between the previous DOM and the new one, we assign a new ID\n            // so that the old tag will be deleted and the new one inserted.\n            var oldNode = this.previousDOM.nodeMap[currentTagID];\n            if (!oldNode || oldNode.tag !== newTag.tag) {\n                currentTagID = this.getNewID();\n            }\n        }\n        return currentTagID;\n    };\n\n    /**\n     * Updates the CodeMirror marks in the editor to reflect the new bounds of nodes in\n     * the given nodeMap.\n     * @param {Object} nodeMap The node map from the new DOM.\n     * @param {Object} markCache The cache of existing mark ranges built during the latest parse.\n     */\n    DOMUpdater.prototype._updateMarkedRanges = function (nodeMap, markCache) {\n        // FUTURE: this is somewhat inefficient (getting all the marks involves passing linearly through\n        // the document once), but it doesn't seem to be a hotspot right now.\n        var updateIDs = Object.keys(nodeMap),\n            cm = this.cm,\n            marks = cm.getAllMarks();\n\n        cm.operation(function () {\n            marks.forEach(function (mark) {\n                if (mark.hasOwnProperty(\"tagID\") && nodeMap[mark.tagID]) {\n                    var node = nodeMap[mark.tagID],\n                        markInfo = markCache[mark.tagID];\n                    // If the mark's bounds already match, avoid destroying and recreating the mark,\n                    // since that incurs some overhead.\n                    if (!(markInfo && _posEq(markInfo.range.from, node.startPos) && _posEq(markInfo.range.to, node.endPos))) {\n                        mark.clear();\n                        mark = cm.markText(node.startPos, node.endPos);\n                        mark.tagID = node.tagID;\n                    }\n                    updateIDs.splice(updateIDs.indexOf(String(node.tagID)), 1);\n                }\n            });\n\n            // Any remaining updateIDs are new.\n            updateIDs.forEach(function (id) {\n                var node = nodeMap[id], mark;\n                if (node.isElement()) {\n                    mark = cm.markText(node.startPos, node.endPos);\n                    mark.tagID = Number(id);\n                }\n            });\n        });\n    };\n\n    /**\n     * @private\n     * Creates a map from tagIDs to nodes in the given HTMLSimpleDOM subtree and\n     * stores it on the root.\n     * @param {Object} root The root of an HTMLSimpleDOM tree.\n     */\n    DOMUpdater.prototype._buildNodeMap = function (root) {\n        var nodeMap = {};\n\n        function walk(node) {\n            if (node.tagID) {\n                nodeMap[node.tagID] = node;\n            }\n            if (node.isElement()) {\n                node.children.forEach(walk);\n            }\n        }\n\n        walk(root);\n        root.nodeMap = nodeMap;\n    };\n\n    /**\n     * @private\n     * Removes all nodes deleted between the oldSubtree and the newSubtree from the given nodeMap,\n     * and clears marks associated with those nodes.\n     * @param {Object} nodeMap The nodeMap to update to remove deleted items.\n     * @param {Object} oldSubtreeMap The nodeMap for the original subtree (which should be a subset of the\n     *     first nodeMap).\n     * @param {Object} newSubtreeMap The nodeMap for the new subtree.\n     */\n    DOMUpdater.prototype._handleDeletions = function (nodeMap, oldSubtreeMap, newSubtreeMap) {\n        var deletedIDs = [];\n        Object.keys(oldSubtreeMap).forEach(function (key) {\n            if (!newSubtreeMap.hasOwnProperty(key)) {\n                deletedIDs.push(key);\n                delete nodeMap[key];\n            }\n        });\n\n        if (deletedIDs.length) {\n            // FUTURE: would be better to cache the mark for each node. Also, could\n            // conceivably combine this with _updateMarkedRanges().\n            var marks = this.cm.getAllMarks();\n            marks.forEach(function (mark) {\n                if (mark.hasOwnProperty(\"tagID\") && deletedIDs.indexOf(mark.tagID) !== -1) {\n                    mark.clear();\n                }\n            });\n        }\n    };\n\n    /**\n     * Reparses the document (or a portion of it if we can do it incrementally).\n     * Note that in an incremental update, the old DOM is actually mutated (the new\n     * subtree is swapped in for the old subtree).\n     * @return {?{newDOM: Object, oldSubtree: Object, newSubtree: Object}} newDOM is\n     *      the full new DOM. For a full update, oldSubtree is the full old DOM\n     *      and newSubtree is the same as newDOM; for an incremental update,\n     *      oldSubtree is the portion of the old tree that was reparsed,\n     *      newSubtree is the updated version, and newDOM is actually the same\n     *      as the original DOM (with newSubtree swapped in for oldSubtree).\n     *      If the document can't be parsed due to invalid HTML, returns null.\n     */\n    DOMUpdater.prototype.update = function () {\n        var markCache = {},\n            newSubtree = this.build(true, markCache),\n            result = {\n                // default result if we didn't identify a changed portion\n                newDOM: newSubtree,\n                oldSubtree: this.previousDOM,\n                newSubtree: newSubtree\n            };\n\n        if (!newSubtree) {\n            return null;\n        }\n\n        if (this.changedTagID) {\n            // Find the old subtree that's going to get swapped out.\n            var oldSubtree = this.previousDOM.nodeMap[this.changedTagID],\n                parent = oldSubtree.parent;\n\n            // If we didn't have a parent, then the whole tree changed anyway, so\n            // we'll just return the default result.\n            if (parent) {\n                var childIndex = parent.children.indexOf(oldSubtree);\n                if (childIndex === -1) {\n                    // This should never happen...\n                    console.error(\"DOMUpdater.update(): couldn't locate old subtree in tree\");\n                } else {\n                    // Swap the new subtree in place of the old subtree.\n                    oldSubtree.parent = null;\n                    newSubtree.parent = parent;\n                    parent.children[childIndex] = newSubtree;\n\n                    // Overwrite any node mappings in the parent DOM with the\n                    // mappings for the new subtree. We keep the nodeMap around\n                    // on the new subtree so that the differ can use it later.\n                    $.extend(this.previousDOM.nodeMap, newSubtree.nodeMap);\n\n                    // Update marked ranges for all items in the new subtree.\n                    this._updateMarkedRanges(newSubtree.nodeMap, markCache);\n\n                    // Build a local nodeMap for the old subtree so the differ can\n                    // use it.\n                    this._buildNodeMap(oldSubtree);\n\n                    // Clean up the info for any deleted nodes that are no longer in\n                    // the new tree.\n                    this._handleDeletions(this.previousDOM.nodeMap, oldSubtree.nodeMap, newSubtree.nodeMap);\n\n                    // Update the signatures for all parents of the new subtree.\n                    var curParent = parent;\n                    while (curParent) {\n                        curParent.update();\n                        curParent = curParent.parent;\n                    }\n\n                    result.newDOM = this.previousDOM;\n                    result.oldSubtree = oldSubtree;\n                }\n            }\n        } else {\n            _markTextFromDOM(this.editor, result.newDOM);\n        }\n\n        return result;\n    };\n\n    /**\n     * @private\n     * Builds a new DOM for the current state of the editor, diffs it against the\n     * previous DOM, and generates a DOM edit list that can be used to replay the\n     * diffs in the browser.\n     * @param {Object} previousDOM The HTMLSimpleDOM corresponding to the previous state of the editor.\n     *     Note that in the case of an incremental edit, this will be mutated to create the new DOM\n     *     (by swapping out the subtree corresponding to the changed portion).\n     * @param {Editor} editor The editor containing the instrumented HTML.\n     * @param {Array=} changeList If specified, a CodeMirror changelist reflecting all the\n     *     text changes in the editor since previousDOM was built. If specified, we will\n     *     attempt to do an incremental update (although we might fall back to a full update\n     *     in various cases). If not specified, we will always do a full update.\n     * @return {{dom: Object, edits: Array}} The new DOM representing the current state of the\n     *     editor, and an array of edits that can be applied to update the browser (see\n     *     HTMLDOMDiff for more information on the edit format).\n     */\n    function _updateDOM(previousDOM, editor, changeList) {\n        if (!allowIncremental) {\n            changeList = undefined;\n        }\n        var updater = new DOMUpdater(previousDOM, editor, changeList);\n        var result = updater.update();\n        if (!result) {\n            return { errors: updater.errors };\n        }\n\n        var edits = HTMLDOMDiff.domdiff(result.oldSubtree, result.newSubtree);\n\n        // We're done with the nodeMap that was added to the subtree by the updater.\n        if (result.newSubtree !== result.newDOM) {\n            delete result.newSubtree.nodeMap;\n        }\n\n        return {\n            dom: result.newDOM,\n            edits: edits,\n            _wasIncremental: updater.isIncremental // for unit tests only\n        };\n    }\n\n    /**\n     * Calculates the DOM edits that are needed to update the browser from the state the\n     * editor was in the last time that scanDocument(), getInstrumentedHTML(), or\n     * getUnappliedEditList() was called (whichever is most recent). Caches this state so\n     * it can be used as the base state for the next getUnappliedEditList().\n     *\n     * For simple text edits, this update is done quickly and incrementally. For structural\n     * edits (edits that change the DOM structure or add/remove attributes), the update\n     * requires a full reparse.\n     *\n     * If the document currently contains invalid HTML, no edits will be generated until\n     * getUnappliedEditList() is called when the document is valid, at which point the edits\n     * will reflect all the changes needed to catch the browser up with all the edits\n     * made while the document was invalid.\n     *\n     * @param {Editor} editor The editor containing the instrumented HTML\n     * @param {Array} changeList A CodeMirror change list describing the text changes made\n     *     in the editor since the last update. If specified, we will attempt to do an\n     *     incremental update.\n     * @return {Array} edits A list of edits to apply in the browser. See HTMLDOMDiff for\n     *     more information on the format of these edits.\n     */\n    function getUnappliedEditList(editor, changeList) {\n        var cachedValue = _cachedValues[editor.document.file.fullPath];\n\n        // We might not have a previous DOM if the document was empty before this edit.\n        if (!cachedValue || !cachedValue.dom || _cachedValues[editor.document.file.fullPath].invalid) {\n            // We were in an invalid state, so do a full rebuild.\n            changeList = null;\n        }\n\n        var result = _updateDOM(cachedValue && cachedValue.dom, editor, changeList);\n\n        if (!result.errors) {\n            _cachedValues[editor.document.file.fullPath] = {\n                timestamp: editor.document.diskTimestamp,\n                dom: result.dom,\n                dirty: false\n            };\n            // Since this was an incremental update, we can't rely on the node start/end offsets\n            // in the dom (because nodes after the updated portion didn't have their offsets\n            // updated); the marks in the editor are more accurate.\n            // TODO: should we consider ripping through the dom and fixing up other offsets?\n            result.dom.fullBuild = false;\n            return { edits: result.edits };\n        }\n        if (cachedValue) {\n            cachedValue.invalid = true;\n        }\n        return { errors: result.errors };\n\n    }\n\n    /**\n     * @private\n     * Add SimpleDOMBuilder metadata to browser DOM tree JSON representation\n     * @param {Object} root\n     */\n    function _processBrowserSimpleDOM(browserRoot, editorRootTagID) {\n        var nodeMap         = {},\n            root;\n\n        function _processElement(elem) {\n            elem.tagID = elem.attributes[\"data-brackets-id\"];\n\n            // remove data-brackets-id attribute for diff\n            delete elem.attributes[\"data-brackets-id\"];\n\n            elem.children.forEach(function (child) {\n                // set parent\n                child.parent = elem;\n\n                if (child.isElement()) {\n                    _processElement(child);\n                } else if (child.isText()) {\n                    child.update();\n                    child.tagID = HTMLSimpleDOM.getTextNodeID(child);\n\n                    nodeMap[child.tagID] = child;\n                }\n            });\n\n            elem.update();\n\n            nodeMap[elem.tagID] = elem;\n\n            // Choose the root element based on the root tag in the editor.\n            // The browser may insert html, head and body elements if missing.\n            if (elem.tagID === editorRootTagID) {\n                root = elem;\n            }\n        }\n\n        _processElement(browserRoot);\n\n        root = root || browserRoot;\n        root.nodeMap = nodeMap;\n\n        return root;\n    }\n\n    /**\n     * @private\n     * Diff the browser DOM with the in-editor DOM\n     * @param {Editor} editor\n     * @param {Object} browserSimpleDOM\n     */\n    function _getBrowserDiff(editor, browserSimpleDOM) {\n        var cachedValue = _cachedValues[editor.document.file.fullPath],\n            editorRoot  = cachedValue.dom,\n            browserRoot;\n\n        browserRoot = _processBrowserSimpleDOM(browserSimpleDOM, editorRoot.tagID);\n\n        return {\n            diff: HTMLDOMDiff.domdiff(editorRoot, browserRoot),\n            browser: browserRoot,\n            editor: editorRoot\n        };\n    }\n\n    DocumentManager.on(\"beforeDocumentDelete\", _removeDocFromCache);\n\n    /**\n     * Parses the document, returning an HTMLSimpleDOM structure and caching it as the\n     * initial state of the document. Will return a cached copy of the DOM if the\n     * document hasn't changed since the last time scanDocument was called.\n     *\n     * This is called by generateInstrumentedHTML(), but it can be useful to call it\n     * ahead of time so the DOM is cached and doesn't need to be rescanned when the\n     * instrumented HTML is requested by the browser.\n     *\n     * @param {Document} doc The doc to scan.\n     * @return {Object} Root DOM node of the document.\n     */\n    function scanDocument(doc) {\n        if (!_cachedValues.hasOwnProperty(doc.file.fullPath)) {\n            // TODO: this doesn't seem to be correct any more. The DOM should never be \"dirty\" (i.e., out of sync\n            // with the editor) unless the doc is invalid.\n//            $(doc).on(\"change.htmlInstrumentation\", function () {\n//                if (_cachedValues[doc.file.fullPath]) {\n//                    _cachedValues[doc.file.fullPath].dirty = true;\n//                }\n//            });\n\n            // Assign to cache, but don't set a value yet\n            _cachedValues[doc.file.fullPath] = null;\n        }\n\n        var cachedValue = _cachedValues[doc.file.fullPath];\n        // TODO: No longer look at doc or cached value \"dirty\" settings, because even if the doc is dirty, the dom\n        // should generally be up to date unless the HTML is invalid. (However, the node offsets will be dirty of\n        // the dom was incrementally updated - we should note that somewhere.)\n        if (cachedValue && !cachedValue.invalid && cachedValue.timestamp === doc.diskTimestamp) {\n            return cachedValue.dom;\n        }\n\n        var text = doc.getText(),\n            dom = HTMLSimpleDOM.build(text);\n\n        if (dom) {\n            // Cache results\n            _cachedValues[doc.file.fullPath] = {\n                timestamp: doc.diskTimestamp,\n                dom: dom,\n                dirty: false\n            };\n            // Note that this was a full build, so we know that we can trust the node start/end offsets.\n            dom.fullBuild = true;\n        }\n\n        return dom;\n    }\n\n    /**\n     * Generate instrumented HTML for the specified editor's document, and mark the associated tag\n     * ranges in the editor. Each tag has a \"data-brackets-id\" attribute with a unique ID for its\n     * value. For example, \"<div>\" becomes something like \"<div data-brackets-id='45'>\". The attribute\n     * value is just a number that is guaranteed to be unique.\n     *\n     * Also stores marks in the given editor that correspond to the tag ranges. These marks are used\n     * to track the DOM structure for in-browser highlighting and live HTML updating.\n     *\n     * This only needs to be done once on load of a document. As the document is edited in memory,\n     * the instrumentation is kept up to date via the diffs and edits that are generated on change\n     * events. Call this again only if you want to do a full re-sync of the editor's DOM state.\n     *\n     * @param {Editor} editor The editor whose document we're instrumenting, and which we should\n     *     mark ranges in.\n     * @return {string} instrumented html content\n     */\n    function generateInstrumentedHTML(editor, remoteScript) {\n        var doc = editor.document,\n            dom = scanDocument(doc),\n            orig = doc.getText(),\n            gen = \"\",\n            lastIndex = 0,\n            remoteScriptInserted = false,\n            markCache;\n\n        if (!dom) {\n            return null;\n        }\n\n        // Ensure that the marks in the editor are up to date with respect to the given DOM.\n        // (But only do this if the dom we got back from scanDocument() was a full rebuild. Otherwise,\n        // rely on the marks in the editor.)\n        if (dom.fullBuild) {\n            _markTextFromDOM(editor, dom);\n        } else {\n            markCache = {};\n            editor._codeMirror.getAllMarks().forEach(function (mark) {\n                if (mark.tagID) {\n                    markCache[mark.tagID] = { mark: mark, range: mark.find() };\n                }\n            });\n        }\n\n        // Walk through the dom nodes and insert the 'data-brackets-id' attribute at the\n        // end of the open tag\n        function walk(node) {\n            if (node.tag) {\n                var attrText = \" data-brackets-id='\" + node.tagID + \"'\";\n\n                // If the dom was fully rebuilt, use its offsets. Otherwise, use the marks in the\n                // associated editor, since they'll be more up to date.\n                var startOffset;\n                if (dom.fullBuild) {\n                    startOffset = node.start;\n                } else {\n                    var mark = markCache[node.tagID];\n                    if (mark) {\n                        startOffset = editor._codeMirror.indexFromPos(mark.range.from);\n                    } else {\n                        console.warn(\"generateInstrumentedHTML(): couldn't find existing mark for tagID \" + node.tagID);\n                        startOffset = node.start;\n                    }\n                }\n\n                // Insert the attribute as the first attribute in the tag.\n                var insertIndex = startOffset + node.tag.length + 1;\n                gen += orig.substr(lastIndex, insertIndex - lastIndex) + attrText;\n                lastIndex = insertIndex;\n\n                // If we have a script to inject and this is the head tag, inject it immediately\n                // after the open tag.\n                if (remoteScript && !remoteScriptInserted && node.tag === \"head\") {\n                    insertIndex = node.openEnd;\n                    gen += orig.substr(lastIndex, insertIndex - lastIndex) + remoteScript;\n                    lastIndex = insertIndex;\n                    remoteScriptInserted = true;\n                }\n            }\n\n            if (node.isElement()) {\n                node.children.forEach(walk);\n            }\n        }\n\n        walk(dom);\n        gen += orig.substr(lastIndex);\n\n        if (remoteScript && !remoteScriptInserted) {\n            // if the remote script couldn't be injected before (e.g. due to missing \"head\" tag),\n            // append it at the end\n            gen += remoteScript;\n        }\n\n        return gen;\n    }\n\n    /**\n     * Mark the text for the specified editor. Either scanDocument() or\n     * generateInstrumentedHTML() must be called before this function\n     * is called.\n     *\n     * NOTE: This function is \"private\" for now (has a leading underscore), since\n     * the API is likely to change in the future.\n     *\n     * @param {Editor} editor The editor whose text should be marked.\n     * @return none\n     */\n    function _markText(editor) {\n        var cache = _cachedValues[editor.document.file.fullPath],\n            dom = cache && cache.dom;\n\n        if (!dom) {\n            console.error(\"Couldn't find the dom for \" + editor.document.file.fullPath);\n            return;\n        } else if (!dom.fullBuild) {\n            console.error(\"Tried to mark text from a stale DOM for \" + editor.document.file.fullPath);\n            return;\n        }\n\n        _markTextFromDOM(editor, dom);\n    }\n\n    /**\n     * @private\n     * Clear the DOM cache. For unit testing only.\n     */\n    function _resetCache() {\n        _cachedValues = {};\n    }\n\n    // private methods\n    exports._markText                   = _markText;\n    exports._getMarkerAtDocumentPos     = _getMarkerAtDocumentPos;\n    exports._getTagIDAtDocumentPos      = _getTagIDAtDocumentPos;\n    exports._markTextFromDOM            = _markTextFromDOM;\n    exports._updateDOM                  = _updateDOM;\n    exports._allowIncremental           = allowIncremental;\n    exports._getBrowserDiff             = _getBrowserDiff;\n    exports._resetCache                 = _resetCache;\n\n    // public API\n    exports.scanDocument                = scanDocument;\n    exports.generateInstrumentedHTML    = generateInstrumentedHTML;\n    exports.getUnappliedEditList        = getUnappliedEditList;\n});\n"],"file":"HTMLInstrumentation.js"}
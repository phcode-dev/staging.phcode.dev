{"version":3,"sources":["LiveDevelopment/MultiBrowserImpl/language/HTMLSimpleDOM.js"],"names":["define","require","exports","module","Tokenizer","MurmurHash3","PerfUtils","seed","Math","floor","random","tagID","openImpliesClose","li","dt","dd","address","p","article","aside","blockquote","dir","div","dl","fieldset","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","main","menu","nav","ol","pre","section","table","ul","rt","rp","optgroup","option","tbody","thead","tfoot","tr","th","td","body","head","link","script","voidElements","area","base","basefont","br","col","command","embed","frame","img","input","isindex","keygen","menuitem","meta","param","source","track","wbr","SimpleNode","properties","$","extend","this","getTextNodeID","textNode","childIndex","parent","children","indexOf","_addPos","pos1","pos2","line","ch","_offsetPos","pos","offset","Builder","text","startOffset","startOffsetPos","stack","t","currentTag","build","strict","builder","_dumpDOM","root","result","indent","walk","node","tag","JSON","stringify","attributes","content","isElement","forEach","slice","prototype","update","i","subtreeHashes","childHashes","child","length","String","attributeSignature","subtreeSignature","textSignature","childSignature","hashString","updateAttributeSignature","attributeString","isText","_logError","token","error","startPos","endPos","errors","push","markCache","self","lastClosedTag","lastTextNode","attributeName","nodeMap","timerBuildFull","timerBuildPart","closeTag","endIndex","pop","end","markStart","nextToken","type","finalizeMeasurement","addMeasurement","newTagName","contents","toLowerCase","newTag","hasOwnProperty","closable","start","getID","getNewID","openEnd","closeTagName","newNode","lines","split","lastPos","dom","_getTextNodeID","_seed"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*unittests: HTML Instrumentation*/\n\ndefine(function (require, exports, module) {\n\n\n    var Tokenizer       = require(\"language/HTMLTokenizer\").Tokenizer,\n        MurmurHash3     = require(\"thirdparty/murmurhash3_gc\"),\n        PerfUtils       = require(\"utils/PerfUtils\");\n\n    var seed = Math.floor(Math.random() * 65535);\n\n    var tagID = 1;\n\n    /**\n     * A list of tags whose start causes any of a given set of immediate parent\n     * tags to close. This mostly comes from the HTML5 spec section on omitted close tags:\n     * http://www.w3.org/html/wg/drafts/html/master/syntax.html#optional-tags\n     * This doesn't handle general content model violations.\n     */\n    var openImpliesClose = {\n        li: { li: true },\n        dt: { dd: true, dt: true },\n        dd: { dd: true, dt: true },\n        address: { p: true },\n        article: { p: true },\n        aside: { p: true },\n        blockquote: { p: true },\n        dir: { p: true },\n        div: { p: true },\n        dl: { p: true },\n        fieldset: { p: true },\n        footer: { p: true },\n        form: { p: true },\n        h1: { p: true },\n        h2: { p: true },\n        h3: { p: true },\n        h4: { p: true },\n        h5: { p: true },\n        h6: { p: true },\n        header: { p: true },\n        hgroup: { p: true },\n        hr: { p: true },\n        main: { p: true },\n        menu: { p: true },\n        nav: { p: true },\n        ol: { p: true },\n        p: { p: true },\n        pre: { p: true },\n        section: { p: true },\n        table: { p: true },\n        ul: { p: true },\n        rt: { rp: true, rt: true },\n        rp: { rp: true, rt: true },\n        optgroup: { optgroup: true, option: true },\n        option: { option: true },\n        tbody: { thead: true, tbody: true, tfoot: true },\n        tfoot: { tbody: true },\n        tr: { tr: true, th: true, td: true },\n        th: { th: true, td: true },\n        td: { thead: true, th: true, td: true },\n        body: { head: true, link: true, script: true }\n    };\n\n    /**\n     * A list of tags that are self-closing (do not contain other elements).\n     * Mostly taken from http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n     */\n    var voidElements = {\n        area: true,\n        base: true,\n        basefont: true,\n        br: true,\n        col: true,\n        command: true,\n        embed: true,\n        frame: true,\n        hr: true,\n        img: true,\n        input: true,\n        isindex: true,\n        keygen: true,\n        link: true,\n        menuitem: true,\n        meta: true,\n        param: true,\n        source: true,\n        track: true,\n        wbr: true\n    };\n\n    /**\n     * @constructor\n     *\n     * A SimpleNode represents one node in a SimpleDOM tree. Each node can have\n     * any set of properties on it, though there are a couple of assumptions made.\n     * Elements will have `children` and `attributes` properties. Text nodes will have a `content`\n     * property. All Elements will have a `tagID` and text nodes *can* have one.\n     *\n     * @param {Object} properties the properties provided will be set on the new object.\n     */\n    function SimpleNode(properties) {\n        $.extend(this, properties);\n    }\n\n    SimpleNode.prototype = {\n\n        /**\n         * Updates signatures used to optimize the number of comparisons done during\n         * diffing. This is important to call if you change:\n         *\n         * * children\n         * * child node attributes\n         * * text content of a text node\n         * * child node text\n         */\n        update: function () {\n            if (this.isElement()) {\n                var i,\n                    subtreeHashes = \"\",\n                    childHashes = \"\",\n                    child;\n                for (i = 0; i < this.children.length; i++) {\n                    child = this.children[i];\n                    if (child.isElement()) {\n                        childHashes += String(child.tagID);\n                        subtreeHashes += String(child.tagID) + child.attributeSignature + child.subtreeSignature;\n                    } else {\n                        childHashes += child.textSignature;\n                        subtreeHashes += child.textSignature;\n                    }\n                }\n                this.childSignature = MurmurHash3.hashString(childHashes, childHashes.length, seed);\n                this.subtreeSignature = MurmurHash3.hashString(subtreeHashes, subtreeHashes.length, seed);\n            } else {\n                this.textSignature = MurmurHash3.hashString(this.content, this.content.length, seed);\n            }\n        },\n\n        /**\n         * Updates the signature of this node's attributes. Call this after making attribute changes.\n         */\n        updateAttributeSignature: function () {\n            var attributeString = JSON.stringify(this.attributes);\n            this.attributeSignature = MurmurHash3.hashString(attributeString, attributeString.length, seed);\n        },\n\n        /**\n         * Is this node an element node?\n         *\n         * @return {bool} true if it is an element\n         */\n        isElement: function () {\n            return !!this.children;\n        },\n\n        /**\n         * Is this node a text node?\n         *\n         * @return {bool} true if it is text\n         */\n        isText: function () {\n            return !this.children;\n        }\n    };\n\n    /**\n     * @private\n     *\n     * Generates a synthetic ID for text nodes. These IDs are only used\n     * for convenience when reading a SimpleDOM that is dumped to the console.\n     *\n     * @param {Object} textNode new node for which we are generating an ID\n     * @return {string} ID for the node\n     */\n    function getTextNodeID(textNode) {\n        var childIndex = textNode.parent.children.indexOf(textNode);\n        if (childIndex === 0) {\n            return textNode.parent.tagID + \".0\";\n        }\n        return textNode.parent.children[childIndex - 1].tagID + \"t\";\n    }\n\n    /**\n     * @private\n     *\n     * Adds two {line, ch}-style positions, returning a new pos.\n     */\n    function _addPos(pos1, pos2) {\n        return {line: pos1.line + pos2.line, ch: (pos2.line === 0 ? pos1.ch + pos2.ch : pos2.ch)};\n    }\n\n    /**\n     * @private\n     *\n     * Offsets the character offset of the given {line, ch} pos by the given amount and returns a new\n     * pos. Not for general purpose use as it does not account for line boundaries.\n     */\n    function _offsetPos(pos, offset) {\n        return {line: pos.line, ch: pos.ch + offset};\n    }\n\n    /**\n     * @constructor\n     *\n     * A Builder creates a SimpleDOM tree of SimpleNode objects representing the\n     * \"important\" contents of an HTML document. It does not include things like comments.\n     * The nodes include information about their position in the text provided.\n     *\n     * @param {string} text The text to parse\n     * @param {?int} startOffset starting offset in the text\n     * @param {?{line: int, ch: int}} startOffsetPos line/ch position in the text\n     */\n    function Builder(text, startOffset, startOffsetPos) {\n        this.stack = [];\n        this.text = text;\n        this.t = new Tokenizer(text);\n        this.currentTag = null;\n        this.startOffset = startOffset || 0;\n        this.startOffsetPos = startOffsetPos || {line: 0, ch: 0};\n    }\n\n    Builder.prototype._logError = function (token) {\n        var error       = { token: token },\n            startPos    = token ? (token.startPos || token.endPos) : this.startOffsetPos,\n            endPos      = token ? token.endPos : this.startOffsetPos;\n\n        error.startPos = _addPos(this.startOffsetPos, startPos);\n        error.endPos = _addPos(this.startOffsetPos, endPos);\n\n        if (!this.errors) {\n            this.errors = [];\n        }\n\n        this.errors.push(error);\n    };\n\n    /**\n     * Builds the SimpleDOM.\n     *\n     * @param {?bool} strict if errors are detected, halt and return null\n     * @param {?Object} markCache a cache that can be used in ID generation (is passed to `getID`)\n     * @return {SimpleNode} root of tree or null if parsing failed\n     */\n    Builder.prototype.build = function (strict, markCache) {\n        var self = this;\n        var token, lastClosedTag, lastTextNode;\n        var stack = this.stack;\n        var attributeName = null;\n        var nodeMap = {};\n\n        markCache = markCache || {};\n\n        // Start timers for building full and partial DOMs.\n        // Appropriate timer is used, and the other is discarded.\n        var timerBuildFull = \"HTMLInstr. Build DOM Full\";\n        var timerBuildPart = \"HTMLInstr. Build DOM Partial\";\n        PerfUtils.markStart([timerBuildFull, timerBuildPart]);\n\n        function closeTag(endIndex, endPos) {\n            lastClosedTag = stack[stack.length - 1];\n            stack.pop();\n            lastClosedTag.update();\n\n            lastClosedTag.end = self.startOffset + endIndex;\n            lastClosedTag.endPos = _addPos(self.startOffsetPos, endPos);\n        }\n\n        while ((token = this.t.nextToken()) !== null) {\n            // lastTextNode is used to glue text nodes together\n            // If the last node we saw was text but this one is not, then we're done gluing.\n            // If this node is a comment, we might still encounter more text.\n            if (token.type !== \"text\" && token.type !== \"comment\" && lastTextNode) {\n                lastTextNode = null;\n            }\n\n            if (token.type === \"error\") {\n                PerfUtils.finalizeMeasurement(timerBuildFull);  // discard\n                PerfUtils.addMeasurement(timerBuildPart);       // use\n                this._logError(token);\n                return null;\n            } else if (token.type === \"opentagname\") {\n                var newTagName = token.contents.toLowerCase(),\n                    newTag;\n\n                if (openImpliesClose.hasOwnProperty(newTagName)) {\n                    var closable = openImpliesClose[newTagName];\n                    while (stack.length > 0 && closable.hasOwnProperty(stack[stack.length - 1].tag)) {\n                        // Close the previous tag at the start of this tag.\n                        // Adjust backwards for the < before the tag name.\n                        closeTag(token.start - 1, _offsetPos(token.startPos, -1));\n                    }\n                }\n\n                newTag = new SimpleNode({\n                    tag: token.contents.toLowerCase(),\n                    children: [],\n                    attributes: {},\n                    parent: (stack.length ? stack[stack.length - 1] : null),\n                    start: this.startOffset + token.start - 1,\n                    startPos: _addPos(this.startOffsetPos, _offsetPos(token.startPos, -1)) // ok because we know the previous char was a \"<\"\n                });\n                newTag.tagID = this.getID(newTag, markCache);\n\n                // During undo in particular, it's possible that tag IDs may be reused and\n                // the marks in the document may be misleading. If a tag ID has been reused,\n                // we apply a new tag ID to ensure that our edits come out correctly.\n                if (nodeMap[newTag.tagID]) {\n                    newTag.tagID = this.getNewID();\n                }\n\n                nodeMap[newTag.tagID] = newTag;\n                if (newTag.parent) {\n                    newTag.parent.children.push(newTag);\n                }\n                this.currentTag = newTag;\n\n                if (voidElements.hasOwnProperty(newTag.tag)) {\n                    // This is a self-closing element.\n                    newTag.update();\n                } else {\n                    stack.push(newTag);\n                }\n            } else if (token.type === \"opentagend\" || token.type === \"selfclosingtag\") {\n                // TODO: disallow <p/>?\n                if (this.currentTag) {\n                    if (token.type === \"selfclosingtag\" && stack.length && stack[stack.length - 1] === this.currentTag) {\n                        // This must have been a self-closing tag that we didn't identify as a void element\n                        // (e.g. an SVG tag). Pop it off the stack as if we had encountered its close tag.\n                        closeTag(token.end, token.endPos);\n                    } else {\n                        // We're ending an open tag. Record the end of the open tag as the end of the\n                        // range. (If we later find a close tag for this tag, the end will get overwritten\n                        // with the end of the close tag. In the case of a self-closing tag, we should never\n                        // encounter that.)\n                        // Note that we don't need to update the signature here because the signature only\n                        // relies on the tag name and ID, and isn't affected by the tag's attributes, so\n                        // the signature we calculated when creating the tag is still the same. If we later\n                        // find a close tag for this tag, we'll update the signature to account for its\n                        // children at that point (in the next \"else\" case).\n                        this.currentTag.openEnd = this.currentTag.end = this.startOffset + token.end;\n                        this.currentTag.endPos = _addPos(this.startOffsetPos, token.endPos);\n                        lastClosedTag = this.currentTag;\n                        this.currentTag.updateAttributeSignature();\n                        this.currentTag = null;\n                    }\n                }\n            } else if (token.type === \"closetag\") {\n                // If this is a self-closing element, ignore the close tag.\n                var closeTagName = token.contents.toLowerCase();\n                if (!voidElements.hasOwnProperty(closeTagName)) {\n                    // Find the topmost item on the stack that matches. If we can't find one, assume\n                    // this is just a dangling closing tag and ignore it.\n                    var i;\n                    for (i = stack.length - 1; i >= 0; i--) {\n                        if (stack[i].tag === closeTagName) {\n                            break;\n                        }\n                    }\n                    if (strict && i !== stack.length - 1) {\n                        // If we're in strict mode, treat unbalanced tags as invalid.\n                        PerfUtils.finalizeMeasurement(timerBuildFull);\n                        PerfUtils.addMeasurement(timerBuildPart);\n                        this._logError(token);\n                        return null;\n                    }\n                    if (i >= 0) {\n                        do {\n                            // For all tags we're implicitly closing (before we hit the matching tag), we want the\n                            // implied end to be the beginning of the close tag (which is two characters, \"</\", before\n                            // the start of the tagname). For the actual tag we're explicitly closing, we want the\n                            // implied end to be the end of the close tag (which is one character, \">\", after the end of\n                            // the tagname).\n                            if (stack.length === i + 1) {\n                                closeTag(token.end + 1, _offsetPos(token.endPos, 1));\n                            } else {\n                                closeTag(token.start - 2, _offsetPos(token.startPos, -2));\n                            }\n                        } while (stack.length > i);\n                    } else {\n                        // If we're in strict mode, treat unmatched close tags as invalid. Otherwise\n                        // we just silently ignore them.\n                        if (strict) {\n                            PerfUtils.finalizeMeasurement(timerBuildFull);\n                            PerfUtils.addMeasurement(timerBuildPart);\n                            this._logError(token);\n                            return null;\n                        }\n                    }\n                }\n            } else if (token.type === \"attribname\") {\n                attributeName = token.contents.toLowerCase();\n                // Set the value to the empty string in case this is an empty attribute. If it's not,\n                // it will get overwritten by the attribvalue later.\n                this.currentTag.attributes[attributeName] = \"\";\n            } else if (token.type === \"attribvalue\" && attributeName !== null) {\n                this.currentTag.attributes[attributeName] = token.contents;\n                attributeName = null;\n            } else if (token.type === \"text\") {\n                if (stack.length) {\n                    var parent = stack[stack.length - 1];\n                    var newNode;\n\n                    // Check to see if we're continuing a previous text.\n                    if (lastTextNode) {\n                        newNode = lastTextNode;\n                        newNode.content += token.contents;\n                    } else {\n                        newNode = new SimpleNode({\n                            parent: stack[stack.length - 1],\n                            content: token.contents\n                        });\n                        parent.children.push(newNode);\n                        newNode.tagID = getTextNodeID(newNode);\n                        nodeMap[newNode.tagID] = newNode;\n                        lastTextNode = newNode;\n                    }\n\n                    newNode.update();\n                }\n            }\n        }\n\n        // If we have any tags hanging open (e.g. html or body), fail the parse if we're in strict mode,\n        // otherwise close them at the end of the document.\n        if (stack.length) {\n            if (strict) {\n                PerfUtils.finalizeMeasurement(timerBuildFull);\n                PerfUtils.addMeasurement(timerBuildPart);\n                this._logError(token);\n                return null;\n            }\n                // Manually compute the position of the end of the text (we can't rely on the\n                // tokenizer for this since it may not get to the very end)\n                // TODO: should probably make the tokenizer get to the end...\n            var lines = this.text.split(\"\\n\"),\n                lastPos = {line: lines.length - 1, ch: lines[lines.length - 1].length};\n            while (stack.length) {\n                closeTag(this.text.length, lastPos);\n            }\n\n        }\n\n        var dom = lastClosedTag;\n        if (!dom) {\n            // This can happen if the document has no nontrivial content, or if the user tries to\n            // have something at the root other than the HTML tag. In all such cases, we treat the\n            // document as invalid.\n            this._logError(token);\n            return null;\n        }\n\n        dom.nodeMap = nodeMap;\n        PerfUtils.addMeasurement(timerBuildFull);       // use\n        PerfUtils.finalizeMeasurement(timerBuildPart);  // discard\n\n        return dom;\n    };\n\n    /**\n     * Returns a new tag ID.\n     *\n     * @return {int} unique tag ID\n     */\n    Builder.prototype.getNewID = function () {\n        return tagID++;\n    };\n\n    /**\n     * Returns the best tag ID for the new tag object given.\n     * The default implementation just calls `getNewID`\n     * and returns a unique ID.\n     *\n     * @param {Object} newTag tag object to potentially inspect to choose an ID\n     * @return {int} unique tag ID\n     */\n    Builder.prototype.getID = Builder.prototype.getNewID;\n\n    /**\n     * Builds a SimpleDOM from the text provided. If `strict` mode is true, parsing\n     * will halt as soon as any error is seen and null will be returned.\n     *\n     * @param {string} text Text of document to parse\n     * @param {bool} strict True for strict parsing\n     * @return {SimpleNode} root of tree or null if strict failed\n     */\n    function build(text, strict) {\n        var builder = new Builder(text);\n        return builder.build(strict);\n    }\n\n    /**\n     * @private\n     *\n     * Generates a string version of a SimpleDOM for debugging purposes.\n     *\n     * @param {SimpleNode} root root of the tree\n     * @return {string} Text version of the tree.\n     */\n    function _dumpDOM(root) {\n        var result = \"\",\n            indent = \"\";\n\n        function walk(node) {\n            if (node.tag) {\n                result += indent + \"TAG \" + node.tagID + \" \" + node.tag + \" \" + JSON.stringify(node.attributes) + \"\\n\";\n            } else {\n                result += indent + \"TEXT \" + (node.tagID || \"- \") + node.content + \"\\n\";\n            }\n            if (node.isElement()) {\n                indent += \"  \";\n                node.children.forEach(walk);\n                indent = indent.slice(2);\n            }\n        }\n        walk(root);\n\n        return result;\n    }\n\n    // Public API\n    exports.build                       = build;\n    exports.Builder                     = Builder;\n    exports.SimpleNode                  = SimpleNode;\n\n    // Private API\n    exports._dumpDOM                    = _dumpDOM;\n    exports._offsetPos                  = _offsetPos;\n    exports._getTextNodeID              = getTextNodeID;\n    exports._seed                       = seed;\n});\n"],"file":"HTMLSimpleDOM.js"}
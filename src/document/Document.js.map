{"version":3,"sources":["document/Document.js"],"names":["define","require","exports","module","EditorManager","EventDispatcher","FileUtils","InMemoryFile","PerfUtils","LanguageManager","CodeMirror","_","Document","file","initialTimestamp","rawText","this","editable","readOnly","_updateLanguage","refreshText","_associatedFullEditors","oneOrEach","itemOrArr","cb","Array","isArray","each","makeEventDispatcher","prototype","_refCount","language","isDirty","isSaving","diskTimestamp","keepChangesTime","_refreshInProgress","_text","_masterEditor","_lineEndings","addRef","trigger","releaseRef","console","error","_makeEditable","masterEditor","on","_handleEditorChange","bind","_makeNonEditable","getText","splice","indexOf","length","_toggleMasterEditor","document","_checkAssociatedEditorForPane","paneId","editorCount","editorForPane","_paneId","_disassociateEditor","editor","_associateEditor","push","_ensureMasterEditor","_createUnattachedMasterEditor","useOriginalLineEndings","codeMirrorText","_codeMirror","getValue","LINE_ENDINGS_CRLF","replace","normalizeText","text","setText","setValue","_notifyDocumentChange","changeList","newTimestamp","initial","perfTimerName","markStart","fullPath","_resetText","split","_updateTimestamp","_markClean","sniffLineEndings","getPlatformLineEndings","addMeasurement","replaceRange","start","end","origin","getRange","getLine","lineNum","batchOperation","doOperation","self","operation","event","wasDirty","isClean","markClean","timestamp","notifySaved","log","thisDoc","stat","err","mtime","adjustPosForChange","pos","textLines","change","from","to","cmpPos","changeEnd","line","ch","doMultipleEdits","edits","sort","editDesc1","editDesc2","edit1","edit","edit2","result","cloneDeep","pluck","editDesc","index","prevEditGroup","prevEdit","Error","selections","selIndex","sel","isBeforeEdit","chain","filter","item","undefined","flatten","sel1","sel2","value","toString","dirtyInfo","editorInfo","refInfo","getLanguage","oldLanguage","getLanguageForPath","_notifyFilePathChanged","isUntitled","reload","$deferred","$","Deferred","readAsText","done","readTimestamp","resolve","fail","reject","promise"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var EditorManager       = require(\"editor/EditorManager\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        InMemoryFile        = require(\"document/InMemoryFile\"),\n        PerfUtils           = require(\"utils/PerfUtils\"),\n        LanguageManager     = require(\"language/LanguageManager\"),\n        CodeMirror          = require(\"thirdparty/CodeMirror/lib/codemirror\"),\n        _                   = require(\"thirdparty/lodash\");\n\n    /**\n     * Model for the contents of a single file and its current modification state.\n     * See DocumentManager documentation for important usage notes.\n     *\n     * Document dispatches these events:\n     *\n     * __change__ -- When the text of the editor changes (including due to undo/redo).\n     *\n     * Passes ({Document}, {ChangeList}), where ChangeList is an array\n     * of change record objects. Each change record looks like:\n     *\n     *     { from: start of change, expressed as {line: <line number>, ch: <character offset>},\n     *       to: end of change, expressed as {line: <line number>, ch: <chracter offset>},\n     *       text: array of lines of text to replace existing text }\n     *\n     * The line and ch offsets are both 0-based.\n     *\n     * The ch offset in \"from\" is inclusive, but the ch offset in \"to\" is exclusive. For example,\n     * an insertion of new content (without replacing existing content) is expressed by a range\n     * where from and to are the same.\n     *\n     * If \"from\" and \"to\" are undefined, then this is a replacement of the entire text content.\n     *\n     * IMPORTANT: If you listen for the \"change\" event, you MUST also addRef() the document\n     * (and releaseRef() it whenever you stop listening). You should also listen to the \"deleted\"\n     * event.\n     *\n     * __deleted__ -- When the file for this document has been deleted. All views onto the document should\n     * be closed. The document will no longer be editable or dispatch \"change\" events.\n     *\n     * __languageChanged__ -- When the value of getLanguage() has changed. 2nd argument is the old value,\n     * 3rd argument is the new value.\n     *\n     * @constructor\n     * @param {!File} file  Need not lie within the project.\n     * @param {!Date} initialTimestamp  File's timestamp when we read it off disk.\n     * @param {!string} rawText  Text content of the file.\n     */\n    function Document(file, initialTimestamp, rawText) {\n        this.file = file;\n        this.editable = !file.readOnly;\n        this._updateLanguage();\n        this.refreshText(rawText, initialTimestamp, true);\n        // List of full editors which are initialized as master editors for this doc.\n        this._associatedFullEditors = [];\n    }\n\n    EventDispatcher.makeEventDispatcher(Document.prototype);\n\n    /**\n     * Number of clients who want this Document to stay alive. The Document is listed in\n     * DocumentManager._openDocuments whenever refCount > 0.\n     */\n    Document.prototype._refCount = 0;\n\n    /**\n     * The File for this document. Need not lie within the project.\n     * If Document is untitled, this is an InMemoryFile object.\n     * @type {!File}\n     */\n    Document.prototype.file = null;\n\n    /**\n     * The Language for this document. Will be resolved by file extension in the constructor\n     * @type {!Language}\n     */\n    Document.prototype.language = null;\n\n    /**\n     * Whether this document has unsaved changes or not.\n     * When this changes on any Document, DocumentManager dispatches a \"dirtyFlagChange\" event.\n     * @type {boolean}\n     */\n    Document.prototype.isDirty = false;\n\n    /**\n     * Whether this document is currently being saved.\n     * @type {boolean}\n     */\n    Document.prototype.isSaving = false;\n\n    /**\n     * What we expect the file's timestamp to be on disk. If the timestamp differs from this, then\n     * it means the file was modified by an app other than Brackets.\n     * @type {!Date}\n     */\n    Document.prototype.diskTimestamp = null;\n\n    /**\n     * The timestamp of the document at the point where the user last said to keep changes that conflict\n     * with the current disk version. Can also be -1, indicating that the file was deleted on disk at the\n     * last point when the user said to keep changes, or null, indicating that the user has not said to\n     * keep changes.\n     * Note that this is a time as returned by Date.getTime(), not a Date object.\n     * @type {?Number}\n     */\n    Document.prototype.keepChangesTime = null;\n\n    /**\n     * True while refreshText() is in progress and change notifications shouldn't trip the dirty flag.\n     * @type {boolean}\n     */\n    Document.prototype._refreshInProgress = false;\n\n    /**\n     * The text contents of the file, or null if our backing model is _masterEditor.\n     * @type {?string}\n     */\n    Document.prototype._text = null;\n\n    /**\n     * Editor object representing the full-size editor UI for this document. May be null if Document\n     * has not yet been modified or been the currentDocument; in that case, our backing model is the\n     * string _text.\n     * @type {?Editor}\n     */\n    Document.prototype._masterEditor = null;\n\n    /**\n     * The content's line-endings style. If a Document is created on empty text, or text with\n     * inconsistent line endings, defaults to the current platform's standard endings.\n     * @type {FileUtils.LINE_ENDINGS_CRLF|FileUtils.LINE_ENDINGS_LF}\n     */\n    Document.prototype._lineEndings = null;\n\n    /** Add a ref to keep this Document alive */\n    Document.prototype.addRef = function () {\n        //console.log(\"+++REF+++ \"+this);\n\n        if (this._refCount === 0) {\n            //console.log(\"+++ adding to open list\");\n            if (exports.trigger(\"_afterDocumentCreate\", this)) {\n                return;\n            }\n        }\n        this._refCount++;\n    };\n    /** Remove a ref that was keeping this Document alive */\n    Document.prototype.releaseRef = function () {\n        //console.log(\"---REF--- \"+this);\n\n        this._refCount--;\n        if (this._refCount < 0) {\n            console.error(\"Document ref count has fallen below zero!\");\n            return;\n        }\n        if (this._refCount === 0) {\n            //console.log(\"--- removing from open list\");\n            if (exports.trigger(\"_beforeDocumentDelete\", this)) {\n                return;\n            }\n        }\n    };\n\n    /**\n     * Attach a backing Editor to the Document, enabling setText() to be called. Assumes Editor has\n     * already been initialized with the value of getText(). ONLY Editor should call this (and only\n     * when EditorManager has told it to act as the master editor).\n     * @param {!Editor} masterEditor\n     */\n    Document.prototype._makeEditable = function (masterEditor) {\n\n        this._text = null;\n        this._masterEditor = masterEditor;\n\n        masterEditor.on(\"change\", this._handleEditorChange.bind(this));\n    };\n\n    /**\n     * Detach the backing Editor from the Document, disallowing setText(). The text content is\n     * stored back onto _text so other Document clients continue to have read-only access. ONLY\n     * Editor.destroy() should call this.\n     */\n    Document.prototype._makeNonEditable = function () {\n        if (!this._masterEditor) {\n            console.error(\"Document is already non-editable\");\n        } else {\n            // _text represents the raw text, so fetch without normalized line endings\n            this._text = this.getText(true);\n            this._associatedFullEditors.splice(this._associatedFullEditors.indexOf(this._masterEditor), 1);\n\n            // Identify the most recently created full editor before this and set that as new master editor\n            if (this._associatedFullEditors.length > 0) {\n                this._masterEditor = this._associatedFullEditors[this._associatedFullEditors.length - 1];\n            } else {\n                this._masterEditor = null;\n            }\n        }\n    };\n\n    /**\n     * Toggles the master editor which has gained focus from a pool of full editors\n     * To be used internally by Editor only\n     */\n    Document.prototype._toggleMasterEditor = function (masterEditor) {\n        // Do a check before processing the request to ensure inline editors are not being set as master editor\n        if (this.file === masterEditor.document.file && this._associatedFullEditors.indexOf(masterEditor) >= 0) {\n            this._masterEditor = masterEditor;\n        }\n    };\n\n\n    /**\n     * Checks and returns if a full editor exists for the provided pane attached to this document\n     * @param {String} paneId\n     * @return {Editor} Attached editor bound to the provided pane id\n     */\n    Document.prototype._checkAssociatedEditorForPane = function (paneId) {\n        var editorCount, editorForPane;\n        for (editorCount = 0; editorCount < this._associatedFullEditors.length; ++editorCount) {\n            if (this._associatedFullEditors[editorCount]._paneId === paneId) {\n                editorForPane = this._associatedFullEditors[editorCount];\n                break;\n            }\n        }\n\n        return editorForPane;\n    };\n\n    /**\n     * Disassociates an editor from this document if present in the associated editor list\n     * To be used internally by Editor only when destroyed and not the current master editor for the document\n     */\n    Document.prototype._disassociateEditor = function (editor) {\n        // Do a check before processing the request to ensure inline editors are not being handled\n        if (this._associatedFullEditors.indexOf(editor) >= 0) {\n            this._associatedFullEditors.splice(this._associatedFullEditors.indexOf(editor), 1);\n        }\n    };\n\n    /**\n     * Aassociates a full editor to this document\n     * To be used internally by Editor only when pane marking happens\n     */\n    Document.prototype._associateEditor = function (editor) {\n        // Do a check before processing the request to ensure inline editors are not being handled\n        if (this._associatedFullEditors.indexOf(editor) === -1) {\n            this._associatedFullEditors.push(editor);\n        }\n    };\n\n    /**\n     * Guarantees that _masterEditor is non-null. If needed, asks EditorManager to create a new master\n     * editor bound to this Document (which in turn causes Document._makeEditable() to be called).\n     * Should ONLY be called by Editor and Document.\n     */\n    Document.prototype._ensureMasterEditor = function () {\n        if (!this._masterEditor) {\n            EditorManager._createUnattachedMasterEditor(this);\n        }\n    };\n\n    /**\n     * Returns the document's current contents; may not be saved to disk yet. Whenever this\n     * value changes, the Document dispatches a \"change\" event.\n     *\n     * @param {boolean=} useOriginalLineEndings If true, line endings in the result depend on the\n     *      Document's line endings setting (based on OS & the original text loaded from disk).\n     *      If false, line endings are always \\n (like all the other Document text getter methods).\n     * @return {string}\n     */\n    Document.prototype.getText = function (useOriginalLineEndings) {\n        if (this._masterEditor) {\n            // CodeMirror.getValue() always returns text with LF line endings; fix up to match line\n            // endings preferred by the document, if necessary\n            var codeMirrorText = this._masterEditor._codeMirror.getValue();\n            if (useOriginalLineEndings) {\n                if (this._lineEndings === FileUtils.LINE_ENDINGS_CRLF) {\n                    return codeMirrorText.replace(/\\n/g, \"\\r\\n\");\n                }\n            }\n            return codeMirrorText;\n\n        }\n            // Optimized path that doesn't require creating master editor\n        if (useOriginalLineEndings) {\n            return this._text;\n        }\n        return Document.normalizeText(this._text);\n\n\n    };\n\n    /** Normalizes line endings the same way CodeMirror would */\n    Document.normalizeText = function (text) {\n        return text.replace(/\\r\\n/g, \"\\n\");\n    };\n\n    /**\n     * Sets the contents of the document. Treated as an edit. Line endings will be rewritten to\n     * match the document's current line-ending style.\n     * @param {!string} text The text to replace the contents of the document with.\n     */\n    Document.prototype.setText = function (text) {\n        this._ensureMasterEditor();\n        this._masterEditor._codeMirror.setValue(text);\n        // _handleEditorChange() triggers \"change\" event\n    };\n\n    /**\n     * @private\n     * Triggers the appropriate events when a change occurs: \"change\" on the Document instance\n     * and \"documentChange\" on the Document module.\n     * @param {Object} changeList Changelist in CodeMirror format\n     */\n    Document.prototype._notifyDocumentChange = function (changeList) {\n        this.trigger(\"change\", this, changeList);\n        exports.trigger(\"documentChange\", this, changeList);\n    };\n\n    /**\n     * Sets the contents of the document. Treated as reloading the document from disk: the document\n     * will be marked clean with a new timestamp, the undo/redo history is cleared, and we re-check\n     * the text's line-ending style. CAN be called even if there is no backing editor.\n     * @param {!string} text The text to replace the contents of the document with.\n     * @param {!Date} newTimestamp Timestamp of file at the time we read its new contents from disk.\n     * @param {boolean} initial True if this is the initial load of the document. In that case,\n     *      we don't send change events.\n     */\n    Document.prototype.refreshText = function (text, newTimestamp, initial) {\n        var perfTimerName = PerfUtils.markStart(\"refreshText:\\t\" + (!this.file || this.file.fullPath));\n\n        // If clean, don't transiently mark dirty during refresh\n        // (we'll still send change events though, of course)\n        this._refreshInProgress = true;\n\n        if (this._masterEditor) {\n            this._masterEditor._resetText(text);  // clears undo history too\n            // _handleEditorChange() triggers \"change\" event for us\n        } else {\n            this._text = text;\n\n            if (!initial) {\n                // We fake a change record here that looks like CodeMirror's text change records, but\n                // omits \"from\" and \"to\", by which we mean the entire text has changed.\n                // TODO: Dumb to split it here just to join it again in the change handler, but this is\n                // the CodeMirror change format. Should we document our change format to allow this to\n                // either be an array of lines or a single string?\n                this._notifyDocumentChange([{text: text.split(/\\r?\\n/)}]);\n            }\n        }\n        this._updateTimestamp(newTimestamp);\n\n        // If Doc was dirty before refresh, reset it to clean now (don't always call, to avoid no-op dirtyFlagChange events) Since\n        // _resetText() above already ensures Editor state is clean, it's safe to skip _markClean() as long as our own state is already clean too.\n        if (this.isDirty) {\n            this._markClean();\n        }\n        this._refreshInProgress = false;\n\n        // Sniff line-ending style\n        this._lineEndings = FileUtils.sniffLineEndings(text);\n        if (!this._lineEndings) {\n            this._lineEndings = FileUtils.getPlatformLineEndings();\n        }\n\n        exports.trigger(\"_documentRefreshed\", this);\n\n        PerfUtils.addMeasurement(perfTimerName);\n    };\n\n    /**\n     * Adds, replaces, or removes text. If a range is given, the text at that range is replaced with the\n     * given new text; if text == \"\", then the entire range is effectively deleted. If 'end' is omitted,\n     * then the new text is inserted at that point and all existing text is preserved. Line endings will\n     * be rewritten to match the document's current line-ending style.\n     *\n     * IMPORTANT NOTE: Because of #1688, do not use this in cases where you might be\n     * operating on a linked document (like the main document for an inline editor)\n     * during an outer CodeMirror operation (like a key event that's handled by the\n     * editor itself). A common case of this is code hints in inline editors. In\n     * such cases, use `editor._codeMirror.replaceRange()` instead. This should be\n     * fixed when we migrate to use CodeMirror's native document-linking functionality.\n     *\n     * @param {!string} text  Text to insert or replace the range with\n     * @param {!{line:number, ch:number}} start  Start of range, inclusive (if 'to' specified) or insertion point (if not)\n     * @param {?{line:number, ch:number}} end  End of range, exclusive; optional\n     * @param {?string} origin  Optional string used to batch consecutive edits for undo.\n     *     If origin starts with \"+\", then consecutive edits with the same origin will be batched for undo if\n     *     they are close enough together in time.\n     *     If origin starts with \"*\", then all consecutive edit with the same origin will be batched for\n     *     undo.\n     *     Edits with origins starting with other characters will not be batched.\n     *     (Note that this is a higher level of batching than batchOperation(), which already batches all\n     *     edits within it for undo. Origin batching works across operations.)\n     */\n    Document.prototype.replaceRange = function (text, start, end, origin) {\n        this._ensureMasterEditor();\n        this._masterEditor._codeMirror.replaceRange(text, start, end, origin);\n        // _handleEditorChange() triggers \"change\" event\n    };\n\n    /**\n     * Returns the characters in the given range. Line endings are normalized to '\\n'.\n     * @param {!{line:number, ch:number}} start  Start of range, inclusive\n     * @param {!{line:number, ch:number}} end  End of range, exclusive\n     * @return {!string}\n     */\n    Document.prototype.getRange = function (start, end) {\n        this._ensureMasterEditor();\n        return this._masterEditor._codeMirror.getRange(start, end);\n    };\n\n    /**\n     * Returns the text of the given line (excluding any line ending characters)\n     * @param {number} Zero-based line number\n     * @return {!string}\n     */\n    Document.prototype.getLine = function (lineNum) {\n        this._ensureMasterEditor();\n        return this._masterEditor._codeMirror.getLine(lineNum);\n    };\n\n    /**\n     * Batches a series of related Document changes. Repeated calls to replaceRange() should be wrapped in a\n     * batch for efficiency. Begins the batch, calls doOperation(), ends the batch, and then returns.\n     * @param {function()} doOperation\n     */\n    Document.prototype.batchOperation = function (doOperation) {\n        this._ensureMasterEditor();\n\n        var self = this;\n        self._masterEditor._codeMirror.operation(doOperation);\n    };\n\n    /**\n     * Handles changes from the master backing Editor. Changes are triggered either by direct edits\n     * to that Editor's UI, OR by our setText()/refreshText() methods.\n     * @private\n     */\n    Document.prototype._handleEditorChange = function (event, editor, changeList) {\n        // Handle editor change event only when it is originated from the master editor for this doc\n        if (this._masterEditor !== editor) {\n            return;\n        }\n\n        // TODO: This needs to be kept in sync with SpecRunnerUtils.createMockActiveDocument(). In the\n        // future, we should fix things so that we either don't need mock documents or that this\n        // is factored so it will just run in both.\n        if (!this._refreshInProgress) {\n            // Sync isDirty from CodeMirror state\n            var wasDirty = this.isDirty;\n            this.isDirty = !editor._codeMirror.isClean();\n\n            // Notify if isDirty just changed (this also auto-adds us to working set if needed)\n            if (wasDirty !== this.isDirty) {\n                exports.trigger(\"_dirtyFlagChange\", this);\n            }\n        }\n\n        // Notify that Document's text has changed\n        this._notifyDocumentChange(changeList);\n    };\n\n    /**\n     * @private\n     */\n    Document.prototype._markClean = function () {\n        this.isDirty = false;\n        if (this._masterEditor) {\n            this._masterEditor._codeMirror.markClean();\n        }\n        exports.trigger(\"_dirtyFlagChange\", this);\n    };\n\n    /**\n     * @private\n     */\n    Document.prototype._updateTimestamp = function (timestamp) {\n        this.diskTimestamp = timestamp;\n        // Clear the \"keep changes\" timestamp since it's no longer relevant.\n        this.keepChangesTime = null;\n    };\n\n    /**\n     * Called when the document is saved (which currently happens in DocumentCommandHandlers). Marks the\n     * document not dirty and notifies listeners of the save.\n     */\n    Document.prototype.notifySaved = function () {\n        if (!this._masterEditor) {\n            console.log(\"### Warning: saving a Document that is not modifiable!\");\n        }\n\n        this._markClean();\n\n        // TODO: (issue #295) fetching timestamp async creates race conditions (albeit unlikely ones)\n        var thisDoc = this;\n        this.file.stat(function (err, stat) {\n            if (!err) {\n                thisDoc._updateTimestamp(stat.mtime);\n            } else {\n                console.log(\"Error updating timestamp after saving file: \" + thisDoc.file.fullPath);\n            }\n            exports.trigger(\"_documentSaved\", thisDoc);\n        });\n    };\n\n    /**\n     * Adjusts a given position taking a given replaceRange-type edit into account.\n     * If the position is within the original edit range (start and end inclusive),\n     * it gets pushed to the end of the content that replaced the range. Otherwise,\n     * if it's after the edit, it gets adjusted so it refers to the same character\n     * it did before the edit.\n     * @param {!{line:number, ch: number}} pos The position to adjust.\n     * @param {!Array.<string>} textLines The text of the change, split into an array of lines.\n     * @param {!{line: number, ch: number}} start The start of the edit.\n     * @param {!{line: number, ch: number}} end The end of the edit.\n     * @return {{line: number, ch: number}} The adjusted position.\n     */\n    Document.prototype.adjustPosForChange = function (pos, textLines, start, end) {\n        // Same as CodeMirror.adjustForChange(), but that's a private function\n        // and Marijn would rather not expose it publicly.\n        var change = { text: textLines, from: start, to: end };\n\n        if (CodeMirror.cmpPos(pos, start) < 0) {\n            return pos;\n        }\n        if (CodeMirror.cmpPos(pos, end) <= 0) {\n            return CodeMirror.changeEnd(change);\n        }\n\n        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,\n            ch = pos.ch;\n        if (pos.line === change.to.line) {\n            ch += CodeMirror.changeEnd(change).ch - change.to.ch;\n        }\n        return {line: line, ch: ch};\n    };\n\n    /**\n     * Like _.each(), but if given a single item not in an array, acts as\n     * if it were an array containing just that item.\n     */\n    function oneOrEach(itemOrArr, cb) {\n        if (Array.isArray(itemOrArr)) {\n            _.each(itemOrArr, cb);\n        } else {\n            cb(itemOrArr, 0);\n        }\n    }\n\n    /**\n     * Helper function for edit operations that operate on multiple selections. Takes an \"edit list\"\n     * that specifies a list of replaceRanges that should occur, but where all the positions are with\n     * respect to the document state before all the edits (i.e., you don't have to figure out how to fix\n     * up the selections after each sub-edit). Edits must be non-overlapping (in original-document terms).\n     * All the edits are done in a single batch.\n     *\n     * If your edits are structured in such a way that each individual edit would cause its associated\n     * selection to be properly updated, then all you need to specify are the edits themselves, and the\n     * selections will automatically be updated as the edits are performed. However, for some\n     * kinds of edits, you need to fix up the selection afterwards. In that case, you can specify one\n     * or more selections to be associated with each edit. Those selections are assumed to be in terms\n     * of the document state after the edit, *as if* that edit were the only one being performed (i.e.,\n     * you don't have to worry about adjusting for the effect of other edits). If you supply these selections,\n     * then this function will adjust them as necessary for the effects of other edits, and then return a\n     * flat list of all the selections, suitable for passing to `setSelections()`.\n     *\n     * @param {!Array.<{edit: {text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}\n     *                        | Array.<{text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}>,\n     *                  selection: ?{start:{line:number, ch:number}, end:{line:number, ch:number},\n     *                              primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}\n     *                        | ?Array.<{start:{line:number, ch:number}, end:{line:number, ch:number},\n     *                                  primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}>} edits\n     *     Specifies the list of edits to perform in a manner similar to CodeMirror's `replaceRange`. This array\n     *     will be mutated.\n     *\n     *     `edit` is the edit to perform:\n     *         `text` will replace the current contents of the range between `start` and `end`.\n     *         If `end` is unspecified, the text is inserted at `start`.\n     *         `start` and `end` should be positions relative to the document *ignoring* all other edit descriptions\n     *         (i.e., as if you were only performing this one edit on the document).\n     *     If any of the edits overlap, an error will be thrown.\n     *\n     *     If `selection` is specified, it should be a selection associated with this edit.\n     *          If `isBeforeEdit` is set on the selection, the selection will be fixed up for this edit.\n     *          If not, it won't be fixed up for this edit, meaning it should be expressed in terms of\n     *          the document state after this individual edit is performed (ignoring any other edits).\n     *          Note that if you were planning on just specifying `isBeforeEdit` for every selection, you can\n     *          accomplish the same thing by simply not passing any selections and letting the editor update\n     *          the existing selections automatically.\n     *\n     *     Note that `edit` and `selection` can each be either an individual edit/selection, or a group of\n     *     edits/selections to apply in order. This can be useful if you need to perform multiple edits in a row\n     *     and then specify a resulting selection that shouldn't be fixed up for any of those edits (but should be\n     *     fixed up for edits related to other selections). It can also be useful if you have several selections\n     *     that should ignore the effects of a given edit because you've fixed them up already (this commonly happens\n     *     with line-oriented edits where multiple cursors on the same line should be ignored, but still tracked).\n     *     Within an edit group, edit positions must be specified relative to previous edits within that group. Also,\n     *     the total bounds of edit groups must not overlap (e.g. edits in one group can't surround an edit from another group).\n     *\n     * @param {?string} origin An optional edit origin that's passed through to each replaceRange().\n     * @return {Array<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean}>}\n     *     The list of passed selections adjusted for the performed edits, if any.\n     */\n    Document.prototype.doMultipleEdits = function (edits, origin) {\n        var self = this;\n\n        // Sort the edits backwards, so we don't have to adjust the edit positions as we go along\n        // (though we do have to adjust the selection positions).\n        edits.sort(function (editDesc1, editDesc2) {\n            var edit1 = (Array.isArray(editDesc1.edit) ? editDesc1.edit[0] : editDesc1.edit),\n                edit2 = (Array.isArray(editDesc2.edit) ? editDesc2.edit[0] : editDesc2.edit);\n            // Treat all no-op edits as if they should happen before all other edits (the order\n            // doesn't really matter, as long as they sort out of the way of the real edits).\n            if (!edit1) {\n                return -1;\n            } else if (!edit2) {\n                return 1;\n            }\n            return CodeMirror.cmpPos(edit2.start, edit1.start);\n\n        });\n\n        // Pull out the selections, in the same order as the edits.\n        var result = _.cloneDeep(_.pluck(edits, \"selection\"));\n\n        // Preflight the edits to specify \"end\" if unspecified and make sure they don't overlap.\n        // (We don't want to do it during the actual edits, since we don't want to apply some of\n        // the edits before we find out.)\n        _.each(edits, function (editDesc, index) {\n            oneOrEach(editDesc.edit, function (edit) {\n                if (edit) {\n                    if (!edit.end) {\n                        edit.end = edit.start;\n                    }\n                    if (index > 0) {\n                        var prevEditGroup = edits[index - 1].edit;\n                        // The edits are in reverse order, so we want to make sure this edit ends\n                        // before any of the previous ones start.\n                        oneOrEach(prevEditGroup, function (prevEdit) {\n                            if (CodeMirror.cmpPos(edit.end, prevEdit.start) > 0) {\n                                throw new Error(\"Document.doMultipleEdits(): Overlapping edits specified\");\n                            }\n                        });\n                    }\n                }\n            });\n        });\n\n        // Perform the edits.\n        this.batchOperation(function () {\n            _.each(edits, function (editDesc, index) {\n                // Perform this group of edits. The edit positions are guaranteed to be okay\n                // since all the previous edits we've done have been later in the document. However,\n                // we have to fix up any selections that overlap or come after the edit.\n                oneOrEach(editDesc.edit, function (edit) {\n                    if (edit) {\n                        self.replaceRange(edit.text, edit.start, edit.end, origin);\n\n                        // Fix up all the selections *except* the one(s) related to this edit list that\n                        // are not \"before-edit\" selections.\n                        var textLines = edit.text.split(\"\\n\");\n                        _.each(result, function (selections, selIndex) {\n                            if (selections) {\n                                oneOrEach(selections, function (sel) {\n                                    if (sel.isBeforeEdit || selIndex !== index) {\n                                        sel.start = self.adjustPosForChange(sel.start, textLines, edit.start, edit.end);\n                                        sel.end = self.adjustPosForChange(sel.end, textLines, edit.start, edit.end);\n                                    }\n                                });\n                            }\n                        });\n                    }\n                });\n            });\n        });\n\n        result = _.chain(result)\n            .filter(function (item) {\n                return item !== undefined;\n            })\n            .flatten()\n            .sort(function (sel1, sel2) {\n                return CodeMirror.cmpPos(sel1.start, sel2.start);\n            })\n            .value();\n        _.each(result, function (item) {\n            delete item.isBeforeEdit;\n        });\n        return result;\n    };\n\n    /* (pretty toString(), to aid debugging) */\n    Document.prototype.toString = function () {\n        var dirtyInfo = (this.isDirty ? \" (dirty!)\" : \" (clean)\");\n        var editorInfo = (this._masterEditor ? \" (Editable)\" : \" (Non-editable)\");\n        var refInfo = \" refs:\" + this._refCount;\n        return \"[Document \" + this.file.fullPath + dirtyInfo + editorInfo + refInfo + \"]\";\n    };\n\n    /**\n     * Returns the language this document is written in.\n     * The language returned is based on the file extension.\n     * @return {Language} An object describing the language used in this document\n     */\n    Document.prototype.getLanguage = function () {\n        return this.language;\n    };\n\n    /**\n     * Updates the language to match the current mapping given by LanguageManager\n     */\n    Document.prototype._updateLanguage = function () {\n        var oldLanguage = this.language;\n        this.language = LanguageManager.getLanguageForPath(this.file.fullPath);\n        if (oldLanguage && oldLanguage !== this.language) {\n            this.trigger(\"languageChanged\", oldLanguage, this.language);\n        }\n    };\n\n    /** Called when Document.file has been modified (due to a rename) */\n    Document.prototype._notifyFilePathChanged = function () {\n        // File extension may have changed\n        this._updateLanguage();\n    };\n\n    /**\n     * Is this an untitled document?\n     *\n     * @return {boolean} - whether or not the document is untitled\n     */\n    Document.prototype.isUntitled = function () {\n        return this.file instanceof InMemoryFile;\n    };\n\n    /**\n     *  Reloads the document from FileSystem\n     *  @return {promise} - to check if reload was successful or not\n     */\n    Document.prototype.reload = function () {\n        var $deferred = $.Deferred();\n        var self = this;\n        FileUtils.readAsText(this.file)\n            .done(function (text, readTimestamp) {\n                self.refreshText(text, readTimestamp);\n                $deferred.resolve();\n            })\n            .fail(function (error) {\n                console.log(\"Error reloading contents of \" + self.file.fullPath, error);\n                $deferred.reject();\n            });\n        return $deferred.promise();\n    };\n\n    // We dispatch events from the module level, and the instance level. Instance events are wired up\n    // in the Document constructor.\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // Define public API\n    exports.Document = Document;\n});\n"],"file":"Document.js"}
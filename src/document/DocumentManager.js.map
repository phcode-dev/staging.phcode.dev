{"version":3,"sources":["document/DocumentManager.js"],"names":["define","require","exports","module","_","AppInit","EventDispatcher","DocumentModule","DeprecationWarning","MainViewManager","MainViewFactory","FileSyncManager","FileSystem","PreferencesManager","FileUtils","InMemoryFile","CommandManager","Commands","PerfUtils","LanguageManager","ProjectManager","Strings","_untitledDocumentPath","random","_openDocuments","getOpenDocumentForPath","fullPath","id","hasOwnProperty","file","getCurrentDocument","getCurrentlyViewedFile","ACTIVE_PANE","getWorkingSet","deprecationWarning","ALL_PANES","filter","findSuitableFactoryForPath","findInWorkingSet","getAllOpenDocuments","result","push","addToWorkingSet","index","forceRedraw","addListToWorkingSet","fileList","removeListFromWorkingSet","list","execute","FILE_CLOSE_LIST","PaneId","closeAll","FILE_CLOSE_ALL","closeFullEditor","FILE_CLOSE","File","setCurrentDocument","doc","CMD_OPEN","beginDocumentNavigation","beginTraversal","finalizeDocumentNavigation","endTraversal","getNextPrevFile","inc","traverseToNextViewByMRU","_gcDocuments","forEach","_refCount","_masterEditor","_destroyEditorIfNotNeeded","getDocumentForPath","fileObj","$","Deferred","resolve","promise","indexOf","getFileForPath","pendingPromise","_pendingDocumentPromises","perfTimerName","markStart","done","addMeasurement","fail","finalizeMeasurement","readAsText","always","rawText","readTimestamp","Document","fileError","reject","getDocumentText","checkLineEndings","getText","diskTimestamp","_lineEndings","read","err","contents","encoding","stat","originalLineEndings","sniffLineEndings","normalizeText","mtime","createUntitledDocument","counter","fileExt","filename","UNTITLED","now","Date","addEntryForPathIfRequired","notifyFileDeleted","trigger","console","warn","notifyPathDeleted","syncOpenDocuments","FILE_DELETED_TITLE","projectRoot","context","location","scope","layer","layerID","getProjectRoot","getViewState","setViewState","findInAllWorkingSets","length","notifyPathNameChanged","oldName","newName","_notifyFilePathChanged","_handleLanguageAdded","getLanguage","isFallbackLanguage","_updateLanguage","_handleLanguageModified","event","language","docLanguage","on","error","isDirty","FILE_OPEN","makeEventDispatcher","markDeprecated","extensionsLoaded","_proxyDeprecatedEvent","eventName","deprecateEvent","e","fileChanged","newFile","newPaneId","oldFile","newDoc","oldDoc","off","_setCurrentLanguage","getId","oldLang","newLang","undefined","createPerfMeasurement"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/**\n * DocumentManager maintains a list of currently 'open' Documents. The DocumentManager is responsible\n * for coordinating document operations and dispatching certain document events.\n *\n * Document is the model for a file's contents; it dispatches events whenever those contents change.\n * To transiently inspect a file's content, simply get a Document and call getText() on it. However,\n * to be notified of Document changes or to modify a Document, you MUST call addRef() to ensure the\n * Document instance 'stays alive' and is shared by all other who read/modify that file. ('Open'\n * Documents are all Documents that are 'kept alive', i.e. have ref count > 0).\n *\n * To get a Document, call getDocumentForPath(); never new up a Document yourself.\n *\n * Secretly, a Document may use an Editor instance to act as the model for its internal state. (This\n * is unavoidable because CodeMirror does not separate its model from its UI). Documents are not\n * modifiable until they have a backing 'master Editor'. Creation of the backing Editor is owned by\n * EditorManager. A Document only gets a backing Editor if it opened in an editor.\n *\n * A non-modifiable Document may still dispatch change notifications, if the Document was changed\n * externally on disk.\n *\n * Aside from the text content, Document tracks a few pieces of metadata - notably, whether there are\n * any unsaved changes.\n *\n * This module dispatches several events:\n *\n *    - dirtyFlagChange -- When any Document's isDirty flag changes. The 2nd arg to the listener is the\n *      Document whose flag changed.\n *    - documentSaved -- When a Document's changes have been saved. The 2nd arg to the listener is the\n *      Document that has been saved.\n *    - documentRefreshed -- When a Document's contents have been reloaded from disk. The 2nd arg to the\n *      listener is the Document that has been refreshed.\n *\n * NOTE: WorkingSet APIs have been deprecated and have moved to MainViewManager as WorkingSet APIs\n *       Some WorkingSet APIs that have been identified as being used by 3rd party extensions will\n *       emit deprecation warnings and call the WorkingSet APIS to maintain backwards compatibility\n *\n *    - currentDocumentChange -- Deprecated: use EditorManager activeEditorChange (which covers all editors,\n *      not just full-sized editors) or MainViewManager currentFileChange (which covers full-sized views\n *      only, but is also triggered for non-editor views e.g. image files).\n *\n *    - fileNameChange -- When the name of a file or folder has changed. The 2nd arg is the old name.\n *      The 3rd arg is the new name.  Generally, however, file objects have already been changed by the\n *      time this event is dispatched so code that relies on matching the filename to a file object\n *      will need to compare the newname.\n *\n *    - pathDeleted -- When a file or folder has been deleted. The 2nd arg is the path that was deleted.\n *\n * To listen for events, do something like this: (see EventDispatcher for details on this pattern)\n *    DocumentManager.on(\"eventname\", handler);\n *\n * Document objects themselves also dispatch some events - see Document docs for details.\n */\ndefine(function (require, exports, module) {\n\n\n    var _ = require(\"thirdparty/lodash\");\n\n    var AppInit             = require(\"utils/AppInit\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        DocumentModule      = require(\"document/Document\"),\n        DeprecationWarning  = require(\"utils/DeprecationWarning\"),\n        MainViewManager     = require(\"view/MainViewManager\"),\n        MainViewFactory     = require(\"view/MainViewFactory\"),\n        FileSyncManager     = require(\"project/FileSyncManager\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        PreferencesManager  = require(\"preferences/PreferencesManager\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        InMemoryFile        = require(\"document/InMemoryFile\"),\n        CommandManager      = require(\"command/CommandManager\"),\n        Commands            = require(\"command/Commands\"),\n        PerfUtils           = require(\"utils/PerfUtils\"),\n        LanguageManager     = require(\"language/LanguageManager\"),\n        ProjectManager      = require(\"project/ProjectManager\"),\n        Strings             = require(\"strings\");\n\n\n    /**\n     * @private\n     * Random path prefix for untitled documents\n     */\n    var _untitledDocumentPath = \"/_brackets_\" + _.random(10000000, 99999999);\n\n    /**\n     * All documents with refCount > 0. Maps Document.file.id -> Document.\n     * @private\n     * @type {Object.<string, Document>}\n     */\n    var _openDocuments = {};\n\n    /**\n     * Returns the existing open Document for the given file, or null if the file is not open ('open'\n     * means referenced by the UI somewhere). If you will hang onto the Document, you must addRef()\n     * it; see {@link #getDocumentForPath} for details.\n     * @param {!string} fullPath\n     * @return {?Document}\n     */\n    function getOpenDocumentForPath(fullPath) {\n        var id;\n\n        // Need to walk all open documents and check for matching path. We can't\n        // use getFileForPath(fullPath).id since the file it returns won't match\n        // an Untitled document's InMemoryFile.\n        for (id in _openDocuments) {\n            if (_openDocuments.hasOwnProperty(id)) {\n                if (_openDocuments[id].file.fullPath === fullPath) {\n                    return _openDocuments[id];\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the Document that is currently open in the editor UI. May be null.\n     * @return {?Document}\n     */\n    function getCurrentDocument() {\n        var file = MainViewManager.getCurrentlyViewedFile(MainViewManager.ACTIVE_PANE);\n\n        if (file) {\n            return getOpenDocumentForPath(file.fullPath);\n        }\n\n        return null;\n    }\n\n\n    /**\n     * Returns a list of items in the working set in UI list order. May be 0-length, but never null.\n     * @deprecated Use MainViewManager.getWorkingSet() instead\n     * @return {Array.<File>}\n     */\n    function getWorkingSet() {\n        DeprecationWarning.deprecationWarning(\"Use MainViewManager.getWorkingSet() instead of DocumentManager.getWorkingSet()\", true);\n        return MainViewManager.getWorkingSet(MainViewManager.ALL_PANES)\n            .filter(function (file) {\n                // Legacy didn't allow for files with custom viewers\n                return !MainViewFactory.findSuitableFactoryForPath(file.fullPath);\n            });\n    }\n\n    /**\n     * Returns the index of the file matching fullPath in the working set.\n     * @deprecated Use MainViewManager.findInWorkingSet() instead\n     * @param {!string} fullPath\n     * @return {number} index, -1 if not found\n     */\n    function findInWorkingSet(fullPath) {\n        DeprecationWarning.deprecationWarning(\"Use MainViewManager.findInWorkingSet() instead of DocumentManager.findInWorkingSet()\", true);\n        return MainViewManager.findInWorkingSet(MainViewManager.ACTIVE_PANE, fullPath);\n    }\n\n    /**\n     * Returns all Documents that are 'open' in the UI somewhere (for now, this means open in an\n     * inline editor and/or a full-size editor). Only these Documents can be modified, and only\n     * these Documents are synced with external changes on disk.\n     * @return {Array.<Document>}\n     */\n    function getAllOpenDocuments() {\n        var result = [];\n        var id;\n        for (id in _openDocuments) {\n            if (_openDocuments.hasOwnProperty(id)) {\n                result.push(_openDocuments[id]);\n            }\n        }\n        return result;\n    }\n\n\n    /**\n     * Adds the given file to the end of the working set list.\n     * @deprecated Use MainViewManager.addToWorkingSet() instead\n     * @param {!File} file\n     * @param {number=} index  Position to add to list (defaults to last); -1 is ignored\n     * @param {boolean=} forceRedraw  If true, a working set change notification is always sent\n     *    (useful if suppressRedraw was used with removeFromWorkingSet() earlier)\n     */\n    function addToWorkingSet(file, index, forceRedraw) {\n        DeprecationWarning.deprecationWarning(\"Use MainViewManager.addToWorkingSet() instead of DocumentManager.addToWorkingSet()\", true);\n        MainViewManager.addToWorkingSet(MainViewManager.ACTIVE_PANE, file, index, forceRedraw);\n    }\n\n    /**\n     * @deprecated Use MainViewManager.addListToWorkingSet() instead\n     * Adds the given file list to the end of the working set list.\n     * If a file in the list has its own custom viewer, then it\n     * is not added into the working set.\n     * Does not change which document is currently open in the editor.\n     * More efficient than calling addToWorkingSet() (in a loop) for\n     * a list of files because there's only 1 redraw at the end\n     * @param {!Array.<File>} fileList\n     */\n    function addListToWorkingSet(fileList) {\n        DeprecationWarning.deprecationWarning(\"Use MainViewManager.addListToWorkingSet() instead of DocumentManager.addListToWorkingSet()\", true);\n        MainViewManager.addListToWorkingSet(MainViewManager.ACTIVE_PANE, fileList);\n    }\n\n\n    /**\n     * closes a list of files\n     * @deprecated Use CommandManager.execute(Commands.FILE_CLOSE_LIST) instead\n     * @param {!Array.<File>} list - list of File objectgs to close\n     */\n    function removeListFromWorkingSet(list) {\n        DeprecationWarning.deprecationWarning(\"Use CommandManager.execute(Commands.FILE_CLOSE_LIST, {PaneId: MainViewManager.ALL_PANES, fileList: list}) instead of DocumentManager.removeListFromWorkingSet()\", true);\n        CommandManager.execute(Commands.FILE_CLOSE_LIST, {PaneId: MainViewManager.ALL_PANES, fileList: list});\n    }\n\n    /**\n     * closes all open files\n     * @deprecated CommandManager.execute(Commands.FILE_CLOSE_ALL) instead\n     */\n    function closeAll() {\n        DeprecationWarning.deprecationWarning(\"Use CommandManager.execute(Commands.FILE_CLOSE_ALL,{PaneId: MainViewManager.ALL_PANES}) instead of DocumentManager.closeAll()\", true);\n        CommandManager.execute(Commands.FILE_CLOSE_ALL, {PaneId: MainViewManager.ALL_PANES});\n    }\n\n    /**\n     * closes the specified file file\n     * @deprecated use CommandManager.execute(Commands.FILE_CLOSE, {File: file}) instead\n     * @param {!File} file - the file to close\n     */\n    function closeFullEditor(file) {\n        DeprecationWarning.deprecationWarning(\"Use CommandManager.execute(Commands.FILE_CLOSE, {File: file} instead of DocumentManager.closeFullEditor()\", true);\n        CommandManager.execute(Commands.FILE_CLOSE, {File: file});\n    }\n\n    /**\n     * opens the specified document for editing in the currently active pane\n     * @deprecated use CommandManager.execute(Commands.CMD_OPEN, {fullPath: doc.file.fullPath}) instead\n     * @param {!Document} document  The Document to make current.\n     */\n    function setCurrentDocument(doc) {\n        DeprecationWarning.deprecationWarning(\"Use CommandManager.execute(Commands.CMD_OPEN) instead of DocumentManager.setCurrentDocument()\", true);\n        CommandManager.execute(Commands.CMD_OPEN, {fullPath: doc.file.fullPath});\n    }\n\n\n    /**\n     * freezes the Working Set MRU list\n     * @deprecated use MainViewManager.beginTraversal() instead\n     */\n    function beginDocumentNavigation() {\n        DeprecationWarning.deprecationWarning(\"Use MainViewManager.beginTraversal() instead of DocumentManager.beginDocumentNavigation()\", true);\n        MainViewManager.beginTraversal();\n    }\n\n    /**\n     * ends document navigation and moves the current file to the front of the MRU list in the Working Set\n     * @deprecated use MainViewManager.endTraversal() instead\n     */\n    function finalizeDocumentNavigation() {\n        DeprecationWarning.deprecationWarning(\"Use MainViewManager.endTraversal() instead of DocumentManager.finalizeDocumentNavigation()\", true);\n        MainViewManager.endTraversal();\n    }\n\n    /**\n     * Get the next or previous file in the working set, in MRU order (relative to currentDocument). May\n     * return currentDocument itself if working set is length 1.\n     * @deprecated use MainViewManager.traverseToNextViewByMRU() instead\n     */\n    function getNextPrevFile(inc) {\n        DeprecationWarning.deprecationWarning(\"Use MainViewManager.traverseToNextViewByMRU() instead of DocumentManager.getNextPrevFile()\", true);\n        var result = MainViewManager.traverseToNextViewByMRU(inc);\n        if (result) {\n            return result.file;\n        }\n        return null;\n    }\n\n    /**\n     * Cleans up any loose Documents whose only ref is its own master Editor, and that Editor is not\n     * rooted in the UI anywhere. This can happen if the Editor is auto-created via Document APIs that\n     * trigger _ensureMasterEditor() without making it dirty. E.g. a command invoked on the focused\n     * inline editor makes no-op edits or does a read-only operation.\n     */\n    function _gcDocuments() {\n        getAllOpenDocuments().forEach(function (doc) {\n            // Is the only ref to this document its own master Editor?\n            if (doc._refCount === 1 && doc._masterEditor) {\n                // Destroy the Editor if it's not being kept alive by the UI\n                MainViewManager._destroyEditorIfNotNeeded(doc);\n            }\n        });\n    }\n\n\n    /**\n     * Gets an existing open Document for the given file, or creates a new one if the Document is\n     * not currently open ('open' means referenced by the UI somewhere). Always use this method to\n     * get Documents; do not call the Document constructor directly. This method is safe to call\n     * in parallel.\n     *\n     * If you are going to hang onto the Document for more than just the duration of a command - e.g.\n     * if you are going to display its contents in a piece of UI - then you must addRef() the Document\n     * and listen for changes on it. (Note: opening the Document in an Editor automatically manages\n     * refs and listeners for that Editor UI).\n     *\n     * If all you need is the Document's getText() value, use the faster getDocumentText() instead.\n     *\n     * @param {!string} fullPath\n     * @param {!object} fileObj actual File|RemoteFile or some other protocol adapter handle\n     * @return {$.Promise} A promise object that will be resolved with the Document, or rejected\n     *      with a FileSystemError if the file is not yet open and can't be read from disk.\n     */\n    function getDocumentForPath(fullPath, fileObj) {\n        var doc = getOpenDocumentForPath(fullPath);\n\n        if (doc) {\n            // use existing document\n            return new $.Deferred().resolve(doc).promise();\n        }\n        var result = new $.Deferred(),\n            promise = result.promise();\n\n            // return null in case of untitled documents\n        if (fullPath.indexOf(_untitledDocumentPath) === 0) {\n            result.resolve(null);\n            return promise;\n        }\n\n        var file            = fileObj || FileSystem.getFileForPath(fullPath),\n            pendingPromise  = getDocumentForPath._pendingDocumentPromises[file.id];\n\n        if (pendingPromise) {\n                // wait for the result of a previous request\n            return pendingPromise;\n        }\n                // log this document's Promise as pending\n        getDocumentForPath._pendingDocumentPromises[file.id] = promise;\n\n                // create a new document\n        var perfTimerName = PerfUtils.markStart(\"getDocumentForPath:\\t\" + fullPath);\n\n        result.done(function () {\n            PerfUtils.addMeasurement(perfTimerName);\n        }).fail(function () {\n            PerfUtils.finalizeMeasurement(perfTimerName);\n        });\n\n        FileUtils.readAsText(file)\n                    .always(function () {\n                        // document is no longer pending\n                        delete getDocumentForPath._pendingDocumentPromises[file.id];\n                    })\n                    .done(function (rawText, readTimestamp) {\n                        doc = new DocumentModule.Document(file, readTimestamp, rawText);\n\n                        // This is a good point to clean up any old dangling Documents\n                        _gcDocuments();\n\n                        result.resolve(doc);\n                    })\n                    .fail(function (fileError) {\n                        result.reject(fileError);\n                    });\n\n        return promise;\n\n\n    }\n\n    /**\n     * Document promises that are waiting to be resolved. It is possible for multiple clients\n     * to request the same document simultaneously before the initial request has completed.\n     * In particular, this happens at app startup where the working set is created and the\n     * initial active document is opened in an editor. This is essential to ensure that only\n     * one Document exists for any File.\n     * @private\n     * @type {Object.<string, $.Promise>}\n     */\n    getDocumentForPath._pendingDocumentPromises = {};\n\n    /**\n     * Gets the text of a Document (including any unsaved changes), or would-be Document if the\n     * file is not actually open. More efficient than getDocumentForPath(). Use when you're reading\n     * document(s) but don't need to hang onto a Document object.\n     *\n     * If the file is open this is equivalent to calling getOpenDocumentForPath().getText(). If the\n     * file is NOT open, this is like calling getDocumentForPath()...getText() but more efficient.\n     * Differs from plain FileUtils.readAsText() in two ways: (a) line endings are still normalized\n     * as in Document.getText(); (b) unsaved changes are returned if there are any.\n     *\n     * @param {!File} file The file to get the text for.\n     * @param {boolean=} checkLineEndings Whether to return line ending information. Default false (slightly more efficient).\n     * @return {$.Promise}\n     *     A promise that is resolved with three parameters:\n     *          contents - string: the document's text\n     *          timestamp - Date: the last time the document was changed on disk (might not be the same as the last time it was changed in memory)\n     *          lineEndings - string: the original line endings of the file, one of the FileUtils.LINE_ENDINGS_* constants;\n     *              will be null if checkLineEndings was false.\n     *     or rejected with a filesystem error.\n     */\n    function getDocumentText(file, checkLineEndings) {\n        var result = new $.Deferred(),\n            doc = getOpenDocumentForPath(file.fullPath);\n        if (doc) {\n            result.resolve(doc.getText(), doc.diskTimestamp, checkLineEndings ? doc._lineEndings : null);\n        } else {\n            file.read(function (err, contents, encoding, stat) {\n                if (err) {\n                    result.reject(err);\n                } else {\n                    // Normalize line endings the same way Document would, but don't actually\n                    // new up a Document (which entails a bunch of object churn).\n                    var originalLineEndings = checkLineEndings ? FileUtils.sniffLineEndings(contents) : null;\n                    contents = DocumentModule.Document.normalizeText(contents);\n                    result.resolve(contents, stat.mtime, originalLineEndings);\n                }\n            });\n        }\n        return result.promise();\n    }\n\n\n    /**\n     * Creates an untitled document. The associated File has a fullPath that\n     * looks like /some-random-string/Untitled-counter.fileExt.\n     *\n     * @param {number} counter - used in the name of the new Document's File\n     * @param {string} fileExt - file extension of the new Document's File, including \".\"\n     * @return {Document} - a new untitled Document\n     */\n    function createUntitledDocument(counter, fileExt) {\n        var filename = Strings.UNTITLED + \"-\" + counter + fileExt,\n            fullPath = _untitledDocumentPath + \"/\" + filename,\n            now = new Date(),\n            file = new InMemoryFile(fullPath, FileSystem);\n\n        FileSystem.addEntryForPathIfRequired(file, fullPath);\n\n        return new DocumentModule.Document(file, now, \"\");\n    }\n\n    /**\n     * Reacts to a file being deleted: if there is a Document for this file, causes it to dispatch a\n     * \"deleted\" event; ensures it's not the currentDocument; and removes this file from the working\n     * set. These actions in turn cause all open editors for this file to close. Discards any unsaved\n     * changes - it is expected that the UI has already confirmed with the user before calling.\n     *\n     * To simply close a main editor when the file hasn't been deleted, use closeFullEditor() or FILE_CLOSE.\n     *\n     * FUTURE: Instead of an explicit notify, we should eventually listen for deletion events on some\n     * sort of \"project file model,\" making this just a private event handler.\n     *\n     * NOTE: This function is not for general consumption, is considered private and may be deprecated\n     *        without warning in a future release.\n     *\n     * @param {!File} file\n     */\n    function notifyFileDeleted(file) {\n        // Notify all editors to close as well\n        exports.trigger(\"pathDeleted\", file.fullPath);\n\n        var doc = getOpenDocumentForPath(file.fullPath);\n\n        if (doc) {\n            doc.trigger(\"deleted\");\n        }\n\n        // At this point, all those other views SHOULD have released the Doc\n        if (doc && doc._refCount > 0) {\n            console.warn(\"Deleted \" + file.fullPath + \" Document still has \" + doc._refCount + \" references. Did someone addRef() without listening for 'deleted'?\");\n        }\n    }\n\n    /**\n     * Called after a file or folder has been deleted. This function is responsible\n     * for updating underlying model data and notifying all views of the change.\n     *\n     * @param {string} fullPath The path of the file/folder that has been deleted\n     */\n    function notifyPathDeleted(fullPath) {\n        // FileSyncManager.syncOpenDocuments() does all the work prompting\n        //  the user to save any unsaved changes and then calls us back\n        //  via notifyFileDeleted\n        FileSyncManager.syncOpenDocuments(Strings.FILE_DELETED_TITLE);\n\n        var projectRoot = ProjectManager.getProjectRoot(),\n            context = {\n                location: {\n                    scope: \"user\",\n                    layer: \"project\",\n                    layerID: projectRoot.fullPath\n                }\n            };\n        var encoding = PreferencesManager.getViewState(\"encoding\", context);\n        delete encoding[fullPath];\n        PreferencesManager.setViewState(\"encoding\", encoding, context);\n\n        if (!getOpenDocumentForPath(fullPath) &&\n                !MainViewManager.findInAllWorkingSets(fullPath).length) {\n            // For images not open in the workingset,\n            // FileSyncManager.syncOpenDocuments() will\n            //  not tell us to close those views\n            exports.trigger(\"pathDeleted\", fullPath);\n        }\n    }\n\n    /**\n     * Called after a file or folder name has changed. This function is responsible\n     * for updating underlying model data and notifying all views of the change.\n     *\n     * @param {string} oldName The old name of the file/folder\n     * @param {string} newName The new name of the file/folder\n     */\n    function notifyPathNameChanged(oldName, newName) {\n        // Notify all open documents\n        _.forEach(_openDocuments, function (doc) {\n            // TODO: Only notify affected documents? For now _notifyFilePathChange\n            // just updates the language if the extension changed, so it's fine\n            // to call for all open docs.\n            doc._notifyFilePathChanged();\n        });\n\n        // Send a \"fileNameChange\" event. This will trigger the views to update.\n        exports.trigger(\"fileNameChange\", oldName, newName);\n    }\n\n\n    /**\n     * @private\n     * Update document\n     */\n    function _handleLanguageAdded() {\n        _.forEach(_openDocuments, function (doc) {\n            // No need to look at the new language if this document has one already\n            if (doc.getLanguage().isFallbackLanguage()) {\n                doc._updateLanguage();\n            }\n        });\n    }\n\n    /**\n     * @private\n     * Update document\n     */\n    function _handleLanguageModified(event, language) {\n        _.forEach(_openDocuments, function (doc) {\n            var docLanguage = doc.getLanguage();\n            // A modified language can affect a document\n            // - if its language was modified\n            // - if the document doesn't have a language yet and its file extension was added to the modified language\n            if (docLanguage === language || docLanguage.isFallbackLanguage()) {\n                doc._updateLanguage();\n            }\n        });\n    }\n\n    // For compatibility\n    DocumentModule\n        .on(\"_afterDocumentCreate\", function (event, doc) {\n            if (_openDocuments[doc.file.id]) {\n                console.error(\"Document for this path already in _openDocuments!\");\n                return true;\n            }\n\n            _openDocuments[doc.file.id] = doc;\n            exports.trigger(\"afterDocumentCreate\", doc);\n        })\n        .on(\"_beforeDocumentDelete\", function (event, doc) {\n            if (!_openDocuments[doc.file.id]) {\n                console.error(\"Document with references was not in _openDocuments!\");\n                return true;\n            }\n\n            exports.trigger(\"beforeDocumentDelete\", doc);\n            delete _openDocuments[doc.file.id];\n        })\n        .on(\"_documentRefreshed\", function (event, doc) {\n            exports.trigger(\"documentRefreshed\", doc);\n        })\n        .on(\"_dirtyFlagChange\", function (event, doc) {\n            // Modules listening on the doc instance notified about dirtyflag change\n            // To be used internally by Editor\n            doc.trigger(\"_dirtyFlagChange\", doc);\n            exports.trigger(\"dirtyFlagChange\", doc);\n            if (doc.isDirty) {\n                MainViewManager.addToWorkingSet(MainViewManager.ACTIVE_PANE, doc.file);\n\n                // We just dirtied a doc and added it to the active working set\n                //  this may have come from an internal dirtying so if it was\n                //  added to a working set that had no active document then\n                //  open the document\n                //\n                // See: https://github.com/adobe/brackets/issues/9569\n                //\n                // NOTE: Adding a file to the active working set may not actually add\n                //       it to the active working set (e.g. the document was already\n                //       opened to the inactive working set.)\n                //\n                //       Check that it was actually added to the active working set\n\n                if (!MainViewManager.getCurrentlyViewedFile() &&\n                        MainViewManager.findInWorkingSet(MainViewManager.ACTIVE_PANE, doc.file.fullPath) !== -1) {\n                    CommandManager.execute(Commands.FILE_OPEN, {fullPath: doc.file.fullPath});\n                }\n            }\n        })\n        .on(\"_documentSaved\", function (event, doc) {\n            exports.trigger(\"documentSaved\", doc);\n        });\n\n    // Set up event dispatch\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // This deprecated event is dispatched manually from \"currentFileChange\" below\n    EventDispatcher.markDeprecated(exports, \"currentDocumentChange\", \"MainViewManager.currentFileChange\");\n\n    // These deprecated events are automatically dispatched by DeprecationWarning, set up in AppInit.extensionsLoaded()\n    EventDispatcher.markDeprecated(exports, \"workingSetAdd\",        \"MainViewManager.workingSetAdd\");\n    EventDispatcher.markDeprecated(exports, \"workingSetAddList\",    \"MainViewManager.workingSetAddList\");\n    EventDispatcher.markDeprecated(exports, \"workingSetRemove\",     \"MainViewManager.workingSetRemove\");\n    EventDispatcher.markDeprecated(exports, \"workingSetRemoveList\", \"MainViewManager.workingSetRemoveList\");\n    EventDispatcher.markDeprecated(exports, \"workingSetSort\",       \"MainViewManager.workingSetSort\");\n\n    /*\n     * After extensionsLoaded, register the proxying listeners that convert newer events to\n     * deprecated events. This ensures that extension listeners still run later than core\n     * listeners. If we registered these proxies earlier, extensions would get the deprecated\n     * event before some core listeners may have run, which could cause bugs (e.g. WorkingSetView\n     * needs to process these events before the Extension Highlighter extension).\n     */\n    AppInit.extensionsLoaded(function () {\n        // Listens for the given event on MainViewManager, and triggers a copy of the event\n        // on DocumentManager whenever it occurs\n        function _proxyDeprecatedEvent(eventName) {\n            DeprecationWarning.deprecateEvent(exports,\n                                              MainViewManager,\n                                              eventName,\n                                              eventName,\n                                              \"DocumentManager.\" + eventName,\n                                              \"MainViewManager.\" + eventName);\n        }\n        _proxyDeprecatedEvent(\"workingSetAdd\");\n        _proxyDeprecatedEvent(\"workingSetAddList\");\n        _proxyDeprecatedEvent(\"workingSetRemove\");\n        _proxyDeprecatedEvent(\"workingSetRemoveList\");\n        _proxyDeprecatedEvent(\"workingSetSort\");\n    });\n\n    // Handle file saves that may affect preferences\n    exports.on(\"documentSaved\", function (e, doc) {\n        PreferencesManager.fileChanged(doc.file.fullPath);\n    });\n\n    MainViewManager.on(\"currentFileChange\", function (e, newFile, newPaneId, oldFile) {\n        var newDoc = null,\n            oldDoc = null;\n\n        if (newFile) {\n            newDoc = getOpenDocumentForPath(newFile.fullPath);\n        }\n\n        if (oldFile) {\n            oldDoc = getOpenDocumentForPath(oldFile.fullPath);\n        }\n\n        if (oldDoc) {\n            oldDoc.off(\"languageChanged.DocumentManager\");\n        }\n\n        if (newDoc) {\n            PreferencesManager._setCurrentLanguage(newDoc.getLanguage().getId());\n            newDoc.on(\"languageChanged.DocumentManager\", function (e, oldLang, newLang) {\n                PreferencesManager._setCurrentLanguage(newLang.getId());\n                exports.trigger(\"currentDocumentLanguageChanged\", [oldLang, newLang]);\n            });\n        } else {\n            PreferencesManager._setCurrentLanguage(undefined);\n        }\n\n        if (newDoc !== oldDoc) {\n            // Dispatch deprecated event with doc args (not File args as the new event uses)\n            exports.trigger(\"currentDocumentChange\", newDoc, oldDoc);\n        }\n\n    });\n\n    // Deprecated APIs\n    exports.getWorkingSet                  = getWorkingSet;\n    exports.findInWorkingSet               = findInWorkingSet;\n    exports.addToWorkingSet                = addToWorkingSet;\n    exports.addListToWorkingSet            = addListToWorkingSet;\n    exports.removeListFromWorkingSet       = removeListFromWorkingSet;\n    exports.getCurrentDocument             = getCurrentDocument;\n    exports.beginDocumentNavigation        = beginDocumentNavigation;\n    exports.finalizeDocumentNavigation     = finalizeDocumentNavigation;\n    exports.getNextPrevFile                = getNextPrevFile;\n    exports.setCurrentDocument             = setCurrentDocument;\n    exports.closeFullEditor                = closeFullEditor;\n    exports.closeAll                       = closeAll;\n\n    // Define public API\n    exports.Document                    = DocumentModule.Document;\n    exports.getDocumentForPath          = getDocumentForPath;\n    exports.getOpenDocumentForPath      = getOpenDocumentForPath;\n    exports.getDocumentText             = getDocumentText;\n    exports.createUntitledDocument      = createUntitledDocument;\n    exports.getAllOpenDocuments         = getAllOpenDocuments;\n\n    // For internal use only\n    exports.notifyPathNameChanged       = notifyPathNameChanged;\n    exports.notifyPathDeleted           = notifyPathDeleted;\n    exports.notifyFileDeleted           = notifyFileDeleted;\n\n    // Performance measurements\n    PerfUtils.createPerfMeasurement(\"DOCUMENT_MANAGER_GET_DOCUMENT_FOR_PATH\", \"DocumentManager.getDocumentForPath()\");\n\n    // Handle Language change events\n    LanguageManager.on(\"languageAdded\", _handleLanguageAdded);\n    LanguageManager.on(\"languageModified\", _handleLanguageModified);\n});\n"],"file":"DocumentManager.js"}
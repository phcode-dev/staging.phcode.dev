{"version":3,"sources":["NodeConnector.js"],"names":["define","require","exports","module","createNodeConnector","nodeConnectorID","moduleExports","window","PhNodeEngine","isNodeAvailable","terminateNode","Promise","resolve","setInspectEnabled","enabled","isInspectEnabled","getInspectPort"],"mappings":"AAqJAA,OAAO,SAAUC,QAASC,QAASC,QA2B/B,SAASC,oBAAoBC,gBAAiBC,eAC1C,OAAOC,OAAOC,aAAaJ,oBAAoBC,gBAAiBC,eAQpE,SAASG,kBACL,QAASF,OAAOC,aAQpB,SAASE,gBACL,OAAGD,kBACQF,OAAOC,aAAaE,gBAExBC,QAAQC,QAAQ,mCAQ3B,SAASC,kBAAkBC,SACvBP,OAAOC,aAAaK,kBAAkBC,SAQ1C,SAASC,mBACL,QAAGN,mBACQF,OAAOC,aAAaO,mBAUnC,SAASC,iBACL,OAAOT,OAAOC,aAAaQ,iBAG/Bd,QAAQE,oBAAsBA,oBAC9BF,QAAQO,gBAAkBA,gBAC1BP,QAAQQ,cAAgBA,cACxBR,QAAQa,iBAAmBA,iBAC3Bb,QAAQW,kBAAoBA,kBAC5BX,QAAQc,eAAiBA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n// @INCLUDE_IN_API_DOCS\n\n/**\n * Node Connector Communication Module\n *\n * This module simplifies communication between Node.js and Phoenix (phcode). A `NodeConnector` acts as an intermediary,\n * allowing you to execute functions in Node.js from Phoenix and vice versa. You can use the `execPeer` method to call\n * functions on the other side and handle communication seamlessly. Use `triggerPeer` to trigger events\n * on the other side.\n *\n * ## Setting Up a `NodeConnector`\n *\n * To establish communication between two modules, such as `x.js` in Phoenix and `y.js` in Node.js, follow these steps:\n *\n * ### Create `NodeConnector` in Phoenix (`x.js`)\n *\n * ```js\n * const NodeConnector = require('NodeConnector');\n * const XY_NODE_CONNECTOR_ID = 'ext_x_y'; // Use a unique ID\n * let nodeConnector = NodeConnector.createNodeConnector(XY_NODE_CONNECTOR_ID, exports);\n *\n * exports.modifyImage = async function(imageName, imageArrayBuffer) {\n *   // Perform image operations with the imageArrayBuffer\n *   // To return an ArrayBuffer, return an object with a `buffer` key.\n *   return {\n *     operationDone: 'colored, cropped',\n *     buffer: imageArrayBuffer,\n *   };\n * };\n * ```\n *\n * ### Create `NodeConnector` in Node.js (`y.js`)\n *\n * ```js\n * const XY_NODE_CONNECTOR_ID = 'ext_x_y'; // Use the same unique ID\n * let nodeConnector = global.createNodeConnector(XY_NODE_CONNECTOR_ID, exports);\n *\n * exports.getPWDRelative = async function(subPath) {\n *   return process.cwd + '/' + subPath;\n * };\n * ```\n *\n * With these steps, a `NodeConnector` is set up, enabling two-way communication.\n *\n * ## Executing Functions\n *\n * To call a Node.js function from Phoenix, use the `execPeer` method.\n *\n * ```js\n * // In `x.js` (Phoenix)\n * const fullPath = await nodeConnector.execPeer('getPWDRelative', 'sub/path.html');\n * ```\n *\n * To execute a Phoenix function from Node.js and transfer binary data, pass an optional ArrayBuffer.\n *\n * ```js\n * // In `y.js` (Node.js)\n * const { operationDone, buffer } = await nodeConnector.execPeer('modifyImage', {name:'theHills.png'}, imageAsArrayBuffer);\n * ```\n *\n * ## Event Handling\n *\n * The `NodeConnector` object implements all the APIs supported by `utils/EventDispatcher`. You can trigger and listen\n * to events between Node.js and Phoenix using the `triggerPeer` and (`on`, `one` or `off`) methods.\n *\n * ```js\n * // In `y.js` (Node.js)\n * nodeConnector.on('phoenixProjectOpened', (_event, projectPath) => {\n *   console.log(projectPath);\n * });\n *\n * nodeConnector.one('phoenixProjectOpened', (_event, projectPath) => {\n *   console.log(projectPath + \"will be received only once\");\n * });\n * ```\n *\n * To raise an event from Phoenix to Node.js:\n *\n * ```js\n * // In `x.js` (Phoenix)\n * nodeConnector.triggerPeer('phoenixProjectOpened', '/x/project/folder');\n * ```\n *\n * To Switch off events\n * ```js\n * nodeConnector.off('phoenixProjectOpened'); // will switch off all event handlers of that name.\n * ```\n *\n * By Default, all events handlers with the eventName is removed when you call `nodeConnector.off(eventName)` fn.\n * To selectively switch off event handlers, please see reference for `utils/EventDispatcher` module.\n *\n * ### Handling ArrayBuffer Data in Function Execution\n *\n * When executing functions that send or receive binary data, ensure that the functions are asynchronous and accept an\n * optional ArrayBuffer as a parameter. To return binary data, use an object with a `buffer` key.\n *\n * Example of calling a function in Node.js with binary data transfer:\n *\n * ```js\n * // In `y.js` (Node.js)\n * const { operationDone, buffer } = await nodeConnector.execPeer('modifyImage', {name:'name.png'}, imageArrayBuffer);\n * ```\n *\n * ### Handling ArrayBuffer Data in Event Handling\n *\n * Use the `triggerPeer` method to send binary data in events. Include the ArrayBuffer as an optional parameter.\n *\n * Example of sending binary data in an event from Phoenix to Node.js:\n *\n * ```js\n * // In `x.js` (Phoenix)\n * const imageArrayBuffer = getSomeImageArrayBuffer(); // Get the ArrayBuffer\n * nodeConnector.triggerPeer('imageEdited', 'name.png', imageArrayBuffer);\n * ```\n *\n * * ## Caveats\n *\n * - Be cautious when sending large binary data, as it may affect performance and memory usage. Transferring large\n *   data is fully supported, but be mindful of performance.\n * - Functions called with `execPeer` and `triggerPeer` must be asynchronous and accept a single argument. An optional\n *   second argument can be used to transfer large binary data as an ArrayBuffer.\n *\n * For more event handling operations and details, refer to the documentation for the `utils/EventDispatcher` module.\n *\n * @module NodeConnector\n */\n\n\ndefine(function (require, exports, module) {\n    /**\n     * Creates a new node connector with the specified ID and module exports.\n     *\n     * Returns a NodeConnector Object (which is an EventDispatcher with\n     * additional `execPeer` and `triggerPeer` methods. `peer` here means, if you are executing `execPeer`\n     * in Phoenix, it will execute the named function in node side, and vice versa. You can right away start\n     * using `execPeer`, `triggerPeer`(to send/receive events) APIs without waiting to check if the\n     * other side nodeConnector is created.\n     *\n     * Note: If the NodeConnector has not been created on the other end, requests made with `execPeer` or\n     * `triggerPeer` will be temporarily queued for up to 10 seconds to allow time for the connector to be created.\n     * If the connector is not created within this timeout period, all queued `execPeer` requests will be rejected,\n     * and all queued events will be dropped. It is recommended to call the `createNodeConnector` API on both ends\n     * within a timeframe of less than 10 seconds(ideally same time) for seamless communication.\n     *\n     * - execPeer: A function that executes a peer function with specified parameters.\n     * - triggerPeer: A function that triggers an event to be sent to a peer.\n     * - Also contains all the APIs supported by `utils/EventDispatcher` module.\n     *\n     * @param {string} nodeConnectorID - The unique identifier for the new node connector.\n     * @param {Object} moduleExports - The exports of the module that contains the functions to be executed on the other side.\n     *\n     * @returns {{execPeer:function, triggerPeer:function, trigger:function, on:function, off:function, one:function}} - A NodeConnector Object. Also contains all the APIs supported by `utils/EventDispatcher` module.\n     *\n     * @throws {Error} - If a node connector with the same ID already exists/invalid args passed.\n     */\n    function createNodeConnector(nodeConnectorID, moduleExports) {\n        return window.PhNodeEngine.createNodeConnector(nodeConnectorID, moduleExports);\n    }\n\n    /**\n     * Checks if Node.js Engine is available.\n     *\n     * @returns {boolean} Returns true if Node.js Engine is available.\n     */\n    function isNodeAvailable() {\n        return !!window.PhNodeEngine;\n    }\n\n    /**\n     * Terminate the PhNodeEngine node if it is available. Else does nothing.\n     *\n     * @return {Promise} promise that resolves when node process is terminated and exits.\n     */\n    function terminateNode() {\n        if(isNodeAvailable()){\n            return window.PhNodeEngine.terminateNode();\n        }\n        return Promise.resolve(\"Node not available to terminate\");\n    }\n\n    /**\n     * Sets weather to enable node inspector in next boot.\n     *\n     * @param {boolean} enabled - true to enable, else false.\n     */\n    function setInspectEnabled(enabled) {\n        window.PhNodeEngine.setInspectEnabled(enabled);\n    }\n\n    /**\n     * Returns whether node inspector is enabled. If node is not present, always returns false.\n     *\n     * @returns {boolean} True if inspect mode is enabled, false otherwise.\n     */\n    function isInspectEnabled() {\n        if(isNodeAvailable()){\n            return window.PhNodeEngine.isInspectEnabled();\n        }\n        return false;\n    }\n\n    /**\n     * Retrieves the node inspector port for the Phoenix Node.js engine.\n     *\n     * @returns {number} The inspection port number.\n     */\n    function getInspectPort() {\n        return window.PhNodeEngine.getInspectPort();\n    }\n\n    exports.createNodeConnector = createNodeConnector;\n    exports.isNodeAvailable = isNodeAvailable;\n    exports.terminateNode = terminateNode;\n    exports.isInspectEnabled = isInspectEnabled;\n    exports.setInspectEnabled = setInspectEnabled;\n    exports.getInspectPort = getInspectPort;\n});\n"],"file":"NodeConnector.js"}
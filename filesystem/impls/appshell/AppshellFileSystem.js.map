{"version":3,"sources":["filesystem/impls/appshell/AppshellFileSystem.js"],"names":["define","require","exports","module","FileUtils","FileSystemStats","FileSystemError","FILE_WATCHER_BATCH_TIMEOUT","_changeCallback","_offlineCallback","_changeTimeout","_pendingChanges","_enqueueChange","changedPath","stats","window","setTimeout","Object","keys","forEach","path","_fileWatcherChangeHandler","event","parentDirPath","entryName","fullPath","stat","err","newStat","console","error","_mapError","FS_ERROR_CODES","Phoenix","app","ERR_CODES","log","code","EINVAL","INVALID_PARAMS","ENOENT","NOT_FOUND","EIO","NOT_READABLE","EROFS","NOT_WRITABLE","ECHARSET","UNSUPPORTED_ENCODING","ENOSPC","OUT_OF_SPACE","EEXIST","ALREADY_EXISTS","ENCODE_FILE_FAILED","DECODE_FILE_FAILED","UNSUPPORTED_UTF16_ENCODING","UNKNOWN","_normalise_path","VFS","normalize","_wrap","cb","args","Array","prototype","slice","call","arguments","apply","showOpenDialog","allowMultipleSelection","chooseDirectories","title","initialPath","fileTypes","callback","appshell","fs","mountNativeFolder","showSaveDialog","proposedNewFilename","_createStatObject","realPath","hash","mtime","getTime","options","isFile","size","fsStats","exists","existsAsync","Promise","resolve","reject","existStatus","readdir","withFileTypes","count","length","contents","statsObject","entryStat","push","name","entryPath","mkdir","mode","parseInt","mkdirs","copy","src","dst","copiedPath","rename","oldPath","newPath","readFile","encoding","getFsEncoding","doReadFile","EXCEEDS_MAX_FILE_SIZE","_err","_data","preserveBOM","_stat","writeFile","data","_finishWrite","created","hasOwnProperty","expectedHash","_hash","expectedContents","CONTENTS_MODIFIED","unlink","moveToTrash","initWatchers","changeCallback","offlineCallback","watchPath","ignored","watch","unwatchPath","unwatch","unwatchAll","pathLib","recursiveWatch","normalizeUNCPaths","brackets","platform"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global appshell, window, define, console*/\n/*eslint-env es6*/\n// jshint ignore: start\n\ndefine(function (require, exports, module) {\n\n\n    var FileUtils           = require(\"file/FileUtils\"),\n        FileSystemStats     = require(\"filesystem/FileSystemStats\"),\n        FileSystemError     = require(\"filesystem/FileSystemError\");\n\n    /**\n     * @const\n     */\n    var FILE_WATCHER_BATCH_TIMEOUT = 200;   // 200ms - granularity of file watcher changes\n\n    /**\n     * Callback to notify FileSystem of watcher changes\n     * @type {?function(string, FileSystemStats=)}\n     */\n    var _changeCallback;\n\n    /**\n     * Callback to notify FileSystem if watchers stop working entirely\n     * @type {?function()}\n     */\n    var _offlineCallback;\n\n    /** Timeout used to batch up file watcher changes (setTimeout() return value) */\n    var _changeTimeout;\n\n    /**\n     * Pending file watcher changes - map from fullPath to flag indicating whether we need to pass stats\n     * to _changeCallback() for this path.\n     * @type {!Object.<string, boolean>}\n     */\n    var _pendingChanges = {};\n\n    /**\n     * Enqueue a file change event for eventual reporting back to the FileSystem.\n     *\n     * @param {string} changedPath The path that was changed\n     * @param {object} stats Stats coming from the underlying watcher, if available\n     * @private\n     */\n    function _enqueueChange(changedPath, stats) {\n        _pendingChanges[changedPath] = stats;\n        if (!_changeTimeout) {\n            _changeTimeout = window.setTimeout(function () {\n                if (_changeCallback) {\n                    Object.keys(_pendingChanges).forEach(function (path) {\n                        _changeCallback(path, _pendingChanges[path]);\n                    });\n                }\n\n                _changeTimeout = null;\n                _pendingChanges = {};\n            }, FILE_WATCHER_BATCH_TIMEOUT);\n        }\n    }\n\n    /**\n     * Event handler for file system change event\n     *\n     * @param {string} event The type of the event: \"changed\", \"created\" or \"deleted\"\n     * @param {string} parentDirPath The path to the directory holding entry that has changed\n     * @param {string=} entryName The name of the file/directory that has changed\n     * * @param {string=} fullPath The full path that has changed\n     * @private\n     */\n    function _fileWatcherChangeHandler(event, parentDirPath, entryName, fullPath) {\n        switch (event) {\n        case \"changed\":\n            stat(fullPath, (err, newStat) => {\n                // fire change event irrespective of error. if err, stat will be null.\n                _enqueueChange(fullPath, newStat);\n            });\n            break;\n        case \"created\":\n        case \"deleted\":\n            // file/directory was created/deleted; fire change on parent to reload contents\n            _enqueueChange(`${parentDirPath}/`, null);\n            break;\n        default:\n            console.error(\"Unexpected 'change' event:\", event);\n        }\n    }\n\n    /**\n     * Convert appshell error codes to FileSystemError values.\n     *\n     * @param {?number} err An appshell error code\n     * @return {?string} A FileSystemError string, or null if there was no error code.\n     * @private\n     */\n    function _mapError(err) {\n        if (!err) {\n            return null;\n        }\n\n        const FS_ERROR_CODES = window.Phoenix.app.ERR_CODES.FS_ERROR_CODES;\n        console.log('appshell fs error: ', err);\n\n        switch (err.code) {\n        case FS_ERROR_CODES.EINVAL:\n            return FileSystemError.INVALID_PARAMS;\n        case FS_ERROR_CODES.ENOENT:\n            return FileSystemError.NOT_FOUND;\n        case FS_ERROR_CODES.EIO:\n            return FileSystemError.NOT_READABLE;\n        case FS_ERROR_CODES.EROFS:\n            return FileSystemError.NOT_WRITABLE;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.UNSUPPORTED_ENCODING;\n        case FS_ERROR_CODES.ENOSPC:\n            return FileSystemError.OUT_OF_SPACE;\n        case FS_ERROR_CODES.EEXIST:\n            return FileSystemError.ALREADY_EXISTS;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.ENCODE_FILE_FAILED;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.DECODE_FILE_FAILED;\n        case FS_ERROR_CODES.ECHARSET:\n            return FileSystemError.UNSUPPORTED_UTF16_ENCODING;\n        }\n\n        console.error('unknown error: ', err);\n        return FileSystemError.UNKNOWN;\n    }\n\n    /**\n     * Normalises path.\n     *\n     * @param {string} path The path to normalise\n     * @return {string} Normalised path.\n     * @private\n     */\n    function _normalise_path(path) {\n        return window.Phoenix.VFS.path.normalize(path);\n    }\n\n    /**\n     * Convert a callback to one that transforms its first parameter from an\n     * appshell error code to a FileSystemError string.\n     *\n     * @param {function(?number)} cb A callback that expects an appshell error code\n     * @return {function(?string)} A callback that expects a FileSystemError string\n     * @private\n     */\n    function _wrap(cb) {\n        return function (err) {\n            var args = Array.prototype.slice.call(arguments);\n            args[0] = _mapError(args[0]);\n            cb.apply(null, args);\n        };\n    }\n\n    /**\n     * Display an open-files dialog to the user and call back asynchronously with\n     * either a FileSystmError string or an array of path strings, which indicate\n     * the entry or entries selected.\n     *\n     * @param {boolean} allowMultipleSelection\n     * @param {boolean} chooseDirectories\n     * @param {string} title\n     * @param {string} initialPath\n     * @param {Array.<string>=} fileTypes\n     * @param {function(?string, Array.<string>=)} callback\n     */\n    function showOpenDialog(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback) {\n        // TODO: handle more cases relating to multiple selection ans stuff.\n        appshell.fs.mountNativeFolder(_wrap(callback));\n    }\n\n    /**\n     * Display a save-file dialog and call back asynchronously with either a\n     * FileSystemError string or the path to which the user has chosen to save\n     * the file. If the dialog is cancelled, the path string will be empty.\n     *\n     * @param {string} title\n     * @param {string} initialPath\n     * @param {string} proposedNewFilename\n     * @param {function(?string, string=)} callback\n     */\n    function showSaveDialog(title, initialPath, proposedNewFilename, callback) {\n        appshell.fs.showSaveDialog(title, initialPath, proposedNewFilename, _wrap(callback));\n    }\n\n    function _createStatObject(stats, realPath) {\n        const hash = stats.mtime? stats.mtime.getTime() : null;\n        var options = {\n            isFile: stats.isFile(),\n            mtime: stats.mtime,\n            size: stats.size,\n            realPath: stats.realPath || realPath,\n            hash: hash\n        };\n        return  new FileSystemStats(options);\n    }\n\n    /**\n     * Stat the file or directory at the given path, calling back\n     * asynchronously with either a FileSystemError string or the entry's\n     * associated FileSystemStats object.\n     *\n     * @param {string} path\n     * @param {function(?string, FileSystemStats=)} callback\n     */\n    function stat(path, callback) {\n        console.log('stat: ', path);\n        path = _normalise_path(path);\n        appshell.fs.stat(path, function (err, stats) {\n            if (err) {\n                callback(_mapError(err));\n            } else {\n                var fsStats = _createStatObject(stats, path);\n                callback(null, fsStats);\n            }\n        });\n    }\n\n    /**\n     * Determine whether a file or directory exists at the given path by calling\n     * back asynchronously with either a FileSystemError string or a boolean,\n     * which is true if the file exists and false otherwise. The error will never\n     * be FileSystemError.NOT_FOUND; in that case, there will be no error and the\n     * boolean parameter will be false.\n     *\n     * @param {string} path\n     * @param {function(?string, boolean)} callback\n     */\n    function exists(path, callback) {\n        console.log('exists: ', path);\n        path = _normalise_path(path);\n        stat(path, function (err) {\n            if (err) {\n                if (err === FileSystemError.NOT_FOUND) {\n                    callback(null, false);\n                } else {\n                    callback(err);\n                }\n                return;\n            }\n\n            callback(null, true);\n        });\n    }\n\n    /**\n     * Determine whether a file or directory exists at the given path by calling\n     * back asynchronously with either a FileSystemError string or a boolean,\n     * which is true if the file exists and false otherwise. The error will never\n     * be FileSystemError.NOT_FOUND; in that case, there will be no error and the\n     * boolean parameter will be false.\n     *\n     * @param {string} path\n     * @param {function(?string, boolean)} callback\n     */\n    function existsAsync(path) {\n        console.log('exists: ', path);\n        return new Promise(function (resolve, reject) {\n            exists(path, function (err, existStatus) {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(existStatus);\n            });\n        });\n    }\n\n    /**\n     * Read the contents of the directory at the given path, calling back\n     * asynchronously either with a FileSystemError string or an array of\n     * FileSystemEntry objects along with another consistent array, each index\n     * of which either contains a FileSystemStats object for the corresponding\n     * FileSystemEntry object in the second parameter or a FileSystemError\n     * string describing a stat error.\n     *\n     * @param {string} path\n     * @param {function(?string, Array.<FileSystemEntry>=, Array.<string|FileSystemStats>=)} callback\n     */\n    function readdir(path, callback) {\n        console.log('readdir: ', path);\n        path = _normalise_path(path);\n        appshell.fs.readdir(path, {withFileTypes: true}, function (err, stats) {\n            if (err) {\n                callback(_mapError(err));\n                return;\n            }\n\n            var count = stats.length;\n            if (!count) {\n                callback(null, [], []);\n                return;\n            }\n\n            let contents = [],\n                statsObject =[];\n\n            stats.forEach(function (entryStat) {\n                contents.push(entryStat.name);\n                let entryPath = `${path}/${entryStat.name}`;\n                statsObject.push(_createStatObject(entryStat, entryPath));\n            });\n            callback(null, contents, statsObject);\n        });\n    }\n\n    /**\n     * Create a directory at the given path, and call back asynchronously with\n     * either a FileSystemError string or a stats object for the newly created\n     * directory. The octal mode parameter is optional; if unspecified, the mode\n     * of the created directory is implementation dependent.\n     *\n     * @param {string} path\n     * @param {number=} mode The base-eight mode of the newly created directory.\n     * @param {function(?string, FileSystemStats=)=} callback\n     */\n    function mkdir(path, mode, callback) {\n        console.log('mkdir: ', path);\n        path = _normalise_path(path);\n        if (typeof mode === \"function\") {\n            callback = mode;\n            mode = parseInt(\"0755\", 8);\n        }\n        appshell.fs.mkdirs(path, mode, true, function (err) {\n            if (err) {\n                callback(_mapError(err));\n            } else {\n                stat(path, function (err, stat) {\n                    callback(err, stat);\n                });\n            }\n        });\n    }\n\n    /**\n     * copies a file/folder path from src to destination recursively. follows unix copy semantics mostly.\n     * As with unix copy, the destination path may not be exactly the `dst` path provided.\n     * Eg. copy(\"/a/b\", \"/a/x\") -> will copy to `/a/x/b` if folder `/a/x` exists. If dst `/a/x` not exists,\n     * then copy will honor the given destination `/a/x`\n     *\n     * @param {string} src Absolute path of file or directory to copy\n     * @param {string} dst Absolute path of file or directory destination\n     * @param {function(err, string)} callback Callback with err or stat of copied destination.\n     */\n    function copy(src, dst, callback) {\n        console.log('copy: ', src);\n        src = _normalise_path(src);\n        dst = _normalise_path(dst);\n        appshell.fs.copy(src, dst, function (err, copiedPath) {\n            if (err) {\n                callback(_mapError(err));\n            } else {\n                stat(copiedPath, function (err, stat) {\n                    callback(err, stat);\n                });\n            }\n        });\n    }\n\n    /**\n     * Rename the file or directory at oldPath to newPath, and call back\n     * asynchronously with a possibly null FileSystemError string.\n     *\n     * @param {string} oldPath\n     * @param {string} newPath\n     * @param {function(?string)=} callback\n     */\n    function rename(oldPath, newPath, callback) {\n        console.log('rename: ', oldPath, ' to ', newPath);\n        oldPath = _normalise_path(oldPath);\n        newPath = _normalise_path(newPath);\n        appshell.fs.rename(oldPath, newPath, _wrap(callback));\n    }\n\n    /**\n     * Read the contents of the file at the given path, calling back\n     * asynchronously with either a FileSystemError string, or with the data and\n     * the FileSystemStats object associated with the read file. The options\n     * parameter can be used to specify an encoding (default \"utf8\"), and also\n     * a cached stats object that the implementation is free to use in order\n     * to avoid an additional stat call.\n     *\n     * Note: if either the read or the stat call fails then neither the read data\n     * nor stat will be passed back, and the call should be considered to have failed.\n     * If both calls fail, the error from the read call is passed back.\n     *\n     * @param {string} path\n     * @param {{encoding: string=, stat: FileSystemStats=}} options\n     * @param {function(?string, string=, FileSystemStats=)} callback\n     */\n    function readFile(path, options, callback) {\n        console.log('Reading file: ', path);\n        path = _normalise_path(path);\n        var encoding = window.Phoenix.VFS.getFsEncoding(options.encoding) || \"utf8\";\n\n        // callback to be executed when the call to stat completes\n        //  or immediately if a stat object was passed as an argument\n        function doReadFile(stat) {\n            if (stat.size > (FileUtils.MAX_FILE_SIZE)) {\n                callback(FileSystemError.EXCEEDS_MAX_FILE_SIZE);\n            } else {\n                appshell.fs.readFile(path, encoding, function (_err, _data, encoding, preserveBOM) {\n                    if (_err) {\n                        callback(_mapError(_err));\n                    } else {\n                        callback(null, _data, encoding, preserveBOM, stat);\n                    }\n                });\n            }\n        }\n\n        if (options.stat) {\n            doReadFile(options.stat);\n        } else {\n            exports.stat(path, function (_err, _stat) {\n                if (_err) {\n                    callback(_err);\n                } else {\n                    doReadFile(_stat);\n                }\n            });\n        }\n    }\n    /**\n     * Write data to the file at the given path, calling back asynchronously with\n     * either a FileSystemError string or the FileSystemStats object associated\n     * with the written file and a boolean that indicates whether the file was\n     * created by the write (true) or not (false). If no file exists at the\n     * given path, a new file will be created. The options parameter can be used\n     * to specify an encoding (default \"utf8\"), an octal mode (default\n     * unspecified and implementation dependent), and a consistency hash, which\n     * is used to the current state of the file before overwriting it. If a\n     * consistency hash is provided but does not match the hash of the file on\n     * disk, a FileSystemError.CONTENTS_MODIFIED error is passed to the callback.\n     *\n     * @param {string} path\n     * @param {string} data\n     * @param {{encoding : string=, mode : number=, expectedHash : object=, expectedContents : string=}} options\n     * @param {function(?string, FileSystemStats=, boolean)} callback\n     */\n    function writeFile(path, data, options, callback) {\n        console.log('Write file: ', path);\n        path = _normalise_path(path);\n        var encoding = window.Phoenix.VFS.getFsEncoding(options.encoding) || \"utf8\",\n            preserveBOM = options.preserveBOM;\n\n        function _finishWrite(created) {\n            appshell.fs.writeFile(path, data, encoding, preserveBOM, function (err) {\n                if (err) {\n                    callback(_mapError(err));\n                } else {\n                    stat(path, function (err, stat) {\n                        callback(err, stat, created);\n                    });\n                }\n            });\n        }\n\n        stat(path, function (err, stats) {\n            if (err) {\n                switch (err) {\n                case FileSystemError.NOT_FOUND:\n                    _finishWrite(true);\n                    break;\n                default:\n                    callback(err);\n                }\n                return;\n            }\n\n            if (options.hasOwnProperty(\"expectedHash\") && options.expectedHash !== stats._hash) {\n                console.error(\"Blind write attempted: \", path, stats._hash, options.expectedHash);\n\n                if (options.hasOwnProperty(\"expectedContents\")) {\n                    appshell.fs.readFile(path, encoding, function (_err, _data) {\n                        if (_err || _data !== options.expectedContents) {\n                            callback(FileSystemError.CONTENTS_MODIFIED);\n                            return;\n                        }\n\n                        _finishWrite(false);\n                    });\n                    return;\n                }\n                callback(FileSystemError.CONTENTS_MODIFIED);\n                return;\n\n            }\n\n            _finishWrite(false);\n        });\n    }\n\n    /**\n     * Unlink (i.e., permanently delete) the file or directory at the given path,\n     * calling back asynchronously with a possibly null FileSystemError string.\n     * Directories will be unlinked even when non-empty.\n     *\n     * @param {string} path\n     * @param {function(string)=} callback\n     */\n    function unlink(path, callback) {\n        console.log('delete file: ', path);\n        path = _normalise_path(path);\n        appshell.fs.unlink(path, function (err) {\n            callback(_mapError(err));\n        });\n    }\n\n    /**\n     * Move the file or directory at the given path to a system dependent trash\n     * location, calling back asynchronously with a possibly null FileSystemError\n     * string. Directories will be moved even when non-empty.\n     *\n     * @param {string} path\n     * @param {function(string)=} callback\n     */\n    function moveToTrash(path, callback) {\n        console.log('Trash file: ', path);\n        path = _normalise_path(path);\n        appshell.fs.moveToTrash(path, function (err) {\n            callback(_mapError(err));\n        });\n    }\n\n    /**\n     * Initialize file watching for this filesystem, using the supplied\n     * changeCallback to provide change notifications. The first parameter of\n     * changeCallback specifies the changed path (either a file or a directory);\n     * if this parameter is null, it indicates that the implementation cannot\n     * specify a particular changed path, and so the callers should consider all\n     * paths to have changed and to update their state accordingly. The second\n     * parameter to changeCallback is an optional FileSystemStats object that\n     * may be provided in case the changed path already exists and stats are\n     * readily available. The offlineCallback will be called in case watchers\n     * are no longer expected to function properly. All watched paths are\n     * cleared when the offlineCallback is called.\n     *\n     * @param {function(?string, FileSystemStats=)} changeCallback\n     * @param {function()=} offlineCallback\n     */\n    function initWatchers(changeCallback, offlineCallback) {\n        _changeCallback = changeCallback;\n        _offlineCallback = offlineCallback;\n\n        if (_offlineCallback) {\n            _offlineCallback();\n        }\n    }\n\n    /**\n     * Start providing change notifications for the file or directory at the\n     * given path, calling back asynchronously with a possibly null FileSystemError\n     * string when the initialization is complete. Notifications are provided\n     * using the changeCallback function provided by the initWatchers method.\n     * Note that change notifications are only provided recursively for directories\n     * when the recursiveWatch property of this module is true.\n     *\n     * @param {string} path\n     * @param {Array<string>} ignored\n     * @param {function(?string)=} callback\n     */\n    function watchPath(path, ignored, callback) {\n        console.log('Watch path: ', path, ignored);\n        path = _normalise_path(path);\n        appshell.fs.watch(path, ignored, _fileWatcherChangeHandler, callback);\n    }\n    /**\n     * Stop providing change notifications for the file or directory at the\n     * given path, calling back asynchronously with a possibly null FileSystemError\n     * string when the operation is complete.\n     * This function needs to mirror the signature of watchPath\n     * because of FileSystem.prototype._watchOrUnwatchEntry implementation.\n     *\n     * @param {string} path\n     * @param {Array<string>} ignored\n     * @param {function(?string)=} callback\n     */\n    function unwatchPath(path, ignored, callback) {\n        console.log('unwatch path: ', path);\n        path = _normalise_path(path);\n        appshell.fs.unwatch(path, callback);\n    }\n\n    /**\n     * Stop providing change notifications for all previously watched files and\n     * directories, optionally calling back asynchronously with a possibly null\n     * FileSystemError string when the operation is complete.\n     *\n     * @param {function(?string)=} callback\n     */\n    function unwatchAll(callback) {\n        appshell.fs.unwatchAll(callback);\n    }\n\n\n    // Export public API\n    exports.showOpenDialog  = showOpenDialog;\n    exports.showSaveDialog  = showSaveDialog;\n    exports.exists          = exists;\n    exports.existsAsync     = existsAsync;\n    exports.readdir         = readdir;\n    exports.mkdir           = mkdir;\n    exports.rename          = rename;\n    exports.copy            = copy;\n    exports.stat            = stat;\n    exports.readFile        = readFile;\n    exports.writeFile       = writeFile;\n    exports.unlink          = unlink;\n    exports.moveToTrash     = moveToTrash;\n    exports.initWatchers    = initWatchers;\n    exports.watchPath       = watchPath;\n    exports.unwatchPath     = unwatchPath;\n    exports.unwatchAll      = unwatchAll;\n    exports.pathLib         = window.Phoenix.VFS.path;\n\n    /**\n     * Indicates whether or not recursive watching notifications are supported\n     * by the watchPath call.\n     *\n     * @type {boolean}\n     */\n    exports.recursiveWatch = true;\n\n    /**\n     * Indicates whether or not the filesystem should expect and normalize UNC\n     * paths. If set, then //server/directory/ is a normalized path; otherwise the\n     * filesystem will normalize it to /server/directory. Currently, UNC path\n     * normalization only occurs on Windows.\n     *\n     * @type {boolean}\n     */\n    exports.normalizeUNCPaths = brackets.platform === \"win\";\n});\n"],"file":"AppshellFileSystem.js"}
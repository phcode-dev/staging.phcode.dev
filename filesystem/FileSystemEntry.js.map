{"version":3,"sources":["filesystem/FileSystemEntry.js"],"names":["define","require","exports","module","FileSystemError","WatchedRoot","VISIT_DEFAULT_MAX_DEPTH","VISIT_DEFAULT_MAX_ENTRIES","nextId","FileSystemEntry","path","fileSystem","this","_setPath","_fileSystem","_id","_ensureTrailingSlash","length","Object","defineProperties","prototype","fullPath","get","_path","set","Error","name","_name","parentPath","_parentPath","id","isFile","_isFile","isDirectory","_isDirectory","_impl","_stat","_watchedRoot","undefined","_watchedRootFilterResult","_isWatched","relaxed","watchedRoot","filterResult","_findWatchedRootForPath","parentEntry","entry","getDirectoryForPath","filter","status","ACTIVE","STARTING","_clearCachedData","newPath","parts","split","pop","join","indexOf","toString","exists","callback","err","bind","existsAsync","async","that","Promise","resolve","reject","stat","rename","newFullPath","_beginChange","oldFullPath","_handleRename","_fireRenameEvent","_endChange","unlink","parent","_handleDirectoryChange","added","removed","_fireChangeEvent","moveToTrash","_visitHelper","stats","visitedPaths","visitor","options","_currentDepth","self","maxDepth","maxEntries","sortList","totalPathsVisited","_totalPathsVisited","shouldVisitChildren","currentPath","realPath","hasOwnProperty","TOO_MANY_ENTRIES","getContents","entries","entriesStats","i","_entryStats","compare","entry1","entry2","toLocaleLowerCase","localeCompare","sort","e","visit","then","catch"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*\n * To ensure cache coherence, current and future asynchronous state-changing\n * operations of FileSystemEntry and its subclasses should implement the\n * following high-level sequence of steps:\n *\n * 1. Block external filesystem change events;\n * 2. Execute the low-level state-changing operation;\n * 3. Update the internal filesystem state, including caches;\n * 4. Apply the callback;\n * 5. Fire an appropriate internal change notification; and\n * 6. Unblock external change events.\n *\n * Note that because internal filesystem state is updated first, both the original\n * caller and the change notification listeners observe filesystem state that is\n * current w.r.t. the operation. Furthermore, because external change events are\n * blocked before the operation begins, listeners will only receive the internal\n * change event for the operation and not additional (or possibly inconsistent)\n * external change events.\n *\n * State-changing operations that block external filesystem change events must\n * take care to always subsequently unblock the external change events in all\n * control paths. It is safe to assume, however, that the underlying impl will\n * always apply the callback with some value.\n\n * Caches should be conservative. Consequently, the entry's cached data should\n * always be cleared if the underlying impl's operation fails. This is the case\n * event for read-only operations because an unexpected failure implies that the\n * system is in an unknown state. The entry should communicate this by failing\n * where appropriate, and should not use the cache to hide failure.\n *\n * Only watched entries should make use of cached data because change events are\n * only expected for such entries, and change events are used to granularly\n * invalidate out-of-date caches.\n *\n * By convention, callbacks are optional for asynchronous, state-changing\n * operations, but required for read-only operations. The first argument to the\n * callback should always be a nullable error string from FileSystemError.\n */\ndefine(function (require, exports, module) {\n\n\n    var FileSystemError = require(\"filesystem/FileSystemError\"),\n        WatchedRoot     = require(\"filesystem/WatchedRoot\");\n\n    var VISIT_DEFAULT_MAX_DEPTH = 100,\n        VISIT_DEFAULT_MAX_ENTRIES = 200000;\n\n    /* Counter to give every entry a unique id */\n    var nextId = 0;\n\n    /**\n     * Model for a file system entry. This is the base class for File and Directory,\n     * and is never used directly.\n     *\n     * See the File, Directory, and FileSystem classes for more details.\n     *\n     * @constructor\n     * @param {string} path The path for this entry.\n     * @param {FileSystem} fileSystem The file system associated with this entry.\n     */\n    function FileSystemEntry(path, fileSystem) {\n        this._setPath(path);\n        this._fileSystem = fileSystem;\n        this._id = nextId++;\n    }\n\n    // Add \"fullPath\", \"name\", \"parent\", \"id\", \"isFile\" and \"isDirectory\" getters\n    Object.defineProperties(FileSystemEntry.prototype, {\n        \"fullPath\": {\n            get: function () { return this._path; },\n            set: function () { throw new Error(\"Cannot set fullPath\"); }\n        },\n        \"name\": {\n            get: function () { return this._name; },\n            set: function () { throw new Error(\"Cannot set name\"); }\n        },\n        \"parentPath\": {\n            get: function () { return this._parentPath; },\n            set: function () { throw new Error(\"Cannot set parentPath\"); }\n        },\n        \"id\": {\n            get: function () { return this._id; },\n            set: function () { throw new Error(\"Cannot set id\"); }\n        },\n        \"isFile\": {\n            get: function () { return this._isFile; },\n            set: function () { throw new Error(\"Cannot set isFile\"); }\n        },\n        \"isDirectory\": {\n            get: function () { return this._isDirectory; },\n            set: function () { throw new Error(\"Cannot set isDirectory\"); }\n        },\n        \"_impl\": {\n            get: function () { return this._fileSystem._impl; },\n            set: function () { throw new Error(\"Cannot set _impl\"); }\n        }\n    });\n\n    /**\n     * Cached stat object for this file.\n     * @type {?FileSystemStats}\n     */\n    FileSystemEntry.prototype._stat = null;\n\n    /**\n     * Parent file system.\n     * @type {!FileSystem}\n     */\n    FileSystemEntry.prototype._fileSystem = null;\n\n    /**\n     * The path of this entry.\n     * @type {string}\n     */\n    FileSystemEntry.prototype._path = null;\n\n    /**\n     * The name of this entry.\n     * @type {string}\n     */\n    FileSystemEntry.prototype._name = null;\n\n    /**\n     * The parent of this entry.\n     * @type {string}\n     */\n    FileSystemEntry.prototype._parentPath = null;\n\n    /**\n     * Whether or not the entry is a file\n     * @type {boolean}\n     */\n    FileSystemEntry.prototype._isFile = false;\n\n    /**\n     * Whether or not the entry is a directory\n     * @type {boolean}\n     */\n    FileSystemEntry.prototype._isDirectory = false;\n\n    /**\n     * Cached copy of this entry's watched root\n     * @type {entry: File|Directory, filter: function(FileSystemEntry):boolean, active: boolean}\n     */\n    FileSystemEntry.prototype._watchedRoot = undefined;\n\n    /**\n     * Cached result of _watchedRoot.filter(this.name, this.parentPath).\n     * @type {boolean}\n     */\n    FileSystemEntry.prototype._watchedRootFilterResult = undefined;\n\n    /**\n     * Determines whether or not the entry is watched.\n     * @param {boolean=} relaxed If falsey, the method will only return true if\n     *      the watched root is fully active. If true, the method will return\n     *      true if the watched root is either starting up or fully active.\n     * @return {boolean}\n     */\n    FileSystemEntry.prototype._isWatched = function (relaxed) {\n        var watchedRoot = this._watchedRoot,\n            filterResult = this._watchedRootFilterResult;\n\n        if (!watchedRoot) {\n            watchedRoot = this._fileSystem._findWatchedRootForPath(this._path);\n\n            if (watchedRoot) {\n                this._watchedRoot = watchedRoot;\n                if (watchedRoot.entry !== this) { // avoid creating entries for root's parent\n                    var parentEntry = this._fileSystem.getDirectoryForPath(this._parentPath);\n                    if (parentEntry._isWatched() === false) {\n                        filterResult = false;\n                    } else {\n                        filterResult = watchedRoot.filter(this._name, this._parentPath);\n                    }\n                } else { // root itself is watched\n                    filterResult = true;\n                }\n                this._watchedRootFilterResult = filterResult;\n            }\n        }\n\n        if (watchedRoot) {\n            if (watchedRoot.status === WatchedRoot.ACTIVE ||\n                    (relaxed && watchedRoot.status === WatchedRoot.STARTING)) {\n                return filterResult;\n            }\n                // We had a watched root, but it's no longer active, so it must now be invalid.\n            this._watchedRoot = undefined;\n            this._watchedRootFilterResult = false;\n            this._clearCachedData();\n\n        }\n        return false;\n    };\n\n    /**\n     * Update the path for this entry\n     * @private\n     * @param {String} newPath\n     */\n    FileSystemEntry.prototype._setPath = function (newPath) {\n        var parts = newPath.split(\"/\");\n        if (this.isDirectory) {\n            parts.pop(); // Remove the empty string after last trailing \"/\"\n        }\n        this._name = parts[parts.length - 1];\n        parts.pop(); // Remove name\n\n        if (parts.length > 0) {\n            this._parentPath = parts.join(\"/\") + \"/\";\n        } else {\n            // root directories have no parent path\n            this._parentPath = null;\n        }\n\n        this._path = newPath;\n\n        var watchedRoot = this._watchedRoot;\n        if (watchedRoot) {\n            if (newPath.indexOf(watchedRoot.entry.fullPath) === 0) {\n                // Update watchedRootFilterResult\n                this._watchedRootFilterResult = watchedRoot.filter(this._name, this._parentPath);\n            } else {\n                // The entry was moved outside of the watched root\n                this._watchedRoot = null;\n                this._watchedRootFilterResult = false;\n            }\n        }\n    };\n\n    /**\n     * Clear any cached data for this entry\n     * @private\n     */\n    FileSystemEntry.prototype._clearCachedData = function () {\n        this._stat = undefined;\n    };\n\n    /**\n     * Helpful toString for debugging purposes\n     */\n    FileSystemEntry.prototype.toString = function () {\n        return \"[\" + (this.isDirectory ? \"Directory \" : \"File \") + this._path + \"]\";\n    };\n\n    /**\n     * Check to see if the entry exists on disk. Note that there will NOT be an\n     * error returned if the file does not exist on the disk; in that case the\n     * error parameter will be null and the boolean will be false. The error\n     * parameter will only be truthy when an unexpected error was encountered\n     * during the test, in which case the state of the entry should be considered\n     * unknown.\n     *\n     * @param {function (?string, boolean)} callback Callback with a FileSystemError\n     *      string or a boolean indicating whether or not the file exists.\n     */\n    FileSystemEntry.prototype.exists = function (callback) {\n        if (this._stat) {\n            callback(null, true);\n            return;\n        }\n\n        this._impl.exists(this._path, function (err, exists) {\n            if (err) {\n                this._clearCachedData();\n                callback(err);\n                return;\n            }\n\n            if (!exists) {\n                this._clearCachedData();\n            }\n\n            callback(null, exists);\n        }.bind(this));\n    };\n\n    /**\n     * Async version of exists API. Returns true or false if the entry exists. or error rejects.\n     */\n    FileSystemEntry.prototype.existsAsync = async function () {\n        let that = this;\n        return new Promise((resolve, reject)=>{\n            that.exists((err, exists)=>{\n                if(err){\n                    reject(err);\n                } else {\n                    resolve(exists);\n                }\n            });\n        });\n\n    };\n\n    /**\n     * Returns the stats for the entry.\n     *\n     * @param {function (?string, FileSystemStats=)} callback Callback with a\n     *      FileSystemError string or FileSystemStats object.\n     */\n    FileSystemEntry.prototype.stat = function (callback) {\n        if (this._stat) {\n            callback(null, this._stat);\n            return;\n        }\n\n        this._impl.stat(this._path, function (err, stat) {\n            if (err) {\n                this._clearCachedData();\n                callback(err);\n                return;\n            }\n\n            if (this._isWatched()) {\n                this._stat = stat;\n            }\n\n            callback(null, stat);\n        }.bind(this));\n    };\n\n    function _ensureTrailingSlash(path) {\n        if (path[path.length - 1] !== \"/\") {\n            path += \"/\";\n        }\n\n        return path;\n    }\n\n    /**\n     * Rename this entry.\n     *\n     * @param {string} newFullPath New path & name for this entry.\n     * @param {function (?string)=} callback Callback with a single FileSystemError\n     *      string parameter.\n     */\n    FileSystemEntry.prototype.rename = function (newFullPath, callback) {\n        callback = callback || function () {};\n        if(this.isDirectory){\n            newFullPath = _ensureTrailingSlash(newFullPath);\n        }\n\n        // Block external change events until after the write has finished\n        this._fileSystem._beginChange();\n\n        this._impl.rename(this._path, newFullPath, function (err) {\n            var oldFullPath = this._path;\n\n            try {\n                if (err) {\n                    this._clearCachedData();\n                    callback(err);\n                    return;\n                }\n\n                // Update internal filesystem state\n                this._fileSystem._handleRename(oldFullPath, newFullPath, this.isDirectory);\n\n                try {\n                    // Notify the caller\n                    callback(null);\n                } finally {\n                    // Notify rename listeners\n                    this._fileSystem._fireRenameEvent(oldFullPath, newFullPath);\n                }\n            } finally {\n                // Unblock external change events\n                this._fileSystem._endChange();\n            }\n        }.bind(this));\n    };\n\n    /**\n     * Permanently delete this entry. For Directories, this will delete the directory\n     * and all of its contents. For reversible delete, see moveToTrash().\n     *\n     * @param {function (?string)=} callback Callback with a single FileSystemError\n     *      string parameter.\n     */\n    FileSystemEntry.prototype.unlink = function (callback) {\n        callback = callback || function () {};\n\n        // Block external change events until after the write has finished\n        this._fileSystem._beginChange();\n\n        this._clearCachedData();\n        this._impl.unlink(this._path, function (err) {\n            var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\n\n            // Update internal filesystem state\n            this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\n                try {\n                    // Notify the caller\n                    callback(err);\n                } finally {\n                    if (parent._isWatched()) {\n                        // Notify change listeners\n                        this._fileSystem._fireChangeEvent(parent, added, removed);\n                    }\n\n                    // Unblock external change events\n                    this._fileSystem._endChange();\n                }\n            }.bind(this));\n        }.bind(this));\n    };\n\n    /**\n     * Move this entry to the trash. If the underlying file system doesn't support move\n     * to trash, the item is permanently deleted.\n     *\n     * @param {function (?string)=} callback Callback with a single FileSystemError\n     *      string parameter.\n     */\n    FileSystemEntry.prototype.moveToTrash = function (callback) {\n        if (!this._impl.moveToTrash) {\n            this.unlink(callback);\n            return;\n        }\n\n        callback = callback || function () {};\n\n        // Block external change events until after the write has finished\n        this._fileSystem._beginChange();\n\n        this._clearCachedData();\n        this._impl.moveToTrash(this._path, function (err) {\n            var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\n\n            // Update internal filesystem state\n            this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\n                try {\n                    // Notify the caller\n                    callback(err);\n                } finally {\n                    if (parent._isWatched()) {\n                        // Notify change listeners\n                        this._fileSystem._fireChangeEvent(parent, added, removed);\n                    }\n\n                    // Unblock external change events\n                    this._fileSystem._endChange();\n                }\n            }.bind(this));\n        }.bind(this));\n    };\n\n    /**\n     * Private helper function for FileSystemEntry.visit that requires sanitized options.\n     *\n     * @private\n     * @param {FileSystemStats} stats - the stats for this entry\n     * @param {{string: boolean}} visitedPaths - the set of fullPaths that have already been visited\n     * @param {function(FileSystemEntry): boolean} visitor - A visitor function, which is\n     *      applied to descendent FileSystemEntry objects. If the function returns false for\n     *      a particular Directory entry, that directory's descendents will not be visited.\n     * @param {{maxDepth: number, maxEntries: number, sortList: boolean}} options\n     * @returns {Promise<>} that resolves when the visit is complete\n     */\n    FileSystemEntry.prototype._visitHelper = function (stats, visitedPaths, visitor, options, _currentDepth = 0) {\n        return new Promise((resolve, reject)=>{\n            const self = this;\n            let maxDepth = options.maxDepth,\n                maxEntries = options.maxEntries,\n                sortList = options.sortList,\n                totalPathsVisited = visitedPaths._totalPathsVisited || 0;\n\n            if (self.isDirectory) {\n                var currentPath = stats.realPath || self.fullPath;\n\n                if (visitedPaths.hasOwnProperty(currentPath)) {\n                    // Link cycle detected\n                    resolve();\n                    return;\n                }\n\n                visitedPaths[currentPath] = true;\n            }\n\n            if (visitedPaths._totalPathsVisited >= maxEntries) {\n                reject(FileSystemError.TOO_MANY_ENTRIES);\n                return;\n            }\n\n            visitedPaths._totalPathsVisited = totalPathsVisited + 1;\n            let shouldVisitChildren = visitor(self);\n            if (!shouldVisitChildren || self.isFile || _currentDepth >= maxDepth) {\n                resolve();\n                return;\n            }\n\n            self.getContents(async function (err, entries, entriesStats) {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n\n                for(let i=0; i<entriesStats.length; i++){\n                    entries[i]._entryStats = entriesStats[i];\n                }\n\n                //sort entries if required\n                if (sortList) {\n                    function compare(entry1, entry2) {\n                        return entry1._name.toLocaleLowerCase().localeCompare(entry2._name.toLocaleLowerCase());\n                    }\n                    entries = entries.sort(compare);\n                }\n\n                try{\n                    for(let entry of entries){\n                        // this is left intentionally serial to prevent a chrome crash bug when large number of fs\n                        // access APIs are called. Try to make this parallel in the future after verifying on a large\n                        // folder with more than 100K entries.\n                        await entry._visitHelper(entry._entryStats, visitedPaths, visitor, options, _currentDepth + 1);\n                    }\n                    resolve();\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    };\n\n    /**\n     * Visit this entry and its descendents with the supplied visitor function.\n     * Correctly handles symbolic link cycles and options can be provided to limit\n     * search depth and total number of entries visited. No particular traversal\n     * order is guaranteed; instead of relying on such an order, it is preferable\n     * to use the visit function to build a list of visited entries, sort those\n     * entries as desired, and then process them. Whenever possible, deep\n     * filesystem traversals should use this method.\n     *\n     * @param {function(FileSystemEntry): boolean} visitor - A visitor function, which is\n     *      applied to this entry and all descendent FileSystemEntry objects. If the function returns\n     *      false for a particular Directory entry, that directory's descendents will not be visited.\n     * @param {{maxDepth: number=, maxEntries: number=}=} options\n     * @param {function(?string)=} callback Callback with single FileSystemError string parameter.\n     */\n    FileSystemEntry.prototype.visit = function (visitor, options, callback) {\n        let self = this;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        } else {\n            if (options === undefined) {\n                options = {};\n            }\n\n            callback = callback || function () {};\n        }\n\n        if (options.maxDepth === undefined) {\n            options.maxDepth = VISIT_DEFAULT_MAX_DEPTH;\n        }\n\n        if (options.maxEntries === undefined) {\n            options.maxEntries = VISIT_DEFAULT_MAX_ENTRIES;\n        }\n\n        self.stat(function (err, stats) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            self._visitHelper(stats, {}, visitor, options)\n                .then(()=>{\n                    callback(null);\n                })\n                .catch((err)=>{\n                    callback(err);\n                });\n        });\n    };\n\n    // Export this class\n    module.exports = FileSystemEntry;\n});\n"],"file":"FileSystemEntry.js"}
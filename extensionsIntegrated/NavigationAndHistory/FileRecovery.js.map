{"version":3,"sources":["extensionsIntegrated/NavigationAndHistory/FileRecovery.js"],"names":["define","require","exports","module","NativeApp","FileSystem","ProjectManager","MainViewManager","FileSystemError","FileUtils","DocumentManager","NotificationUI","Mustache","Strings","FileViewController","recoveryTemplate","EventDispatcher","Metrics","EventManager","makeEventDispatcher","registerEventHandler","BACKUP_INTERVAL_MS","sessionRestoreDir","getDirectoryForPath","path","normalize","getApplicationSupportDirectory","trackedProjects","simpleHash","str","hash","i","length","char","charCodeAt","Math","abs","createDir","dir","Promise","resolve","reject","create","err","ALREADY_EXISTS","console","error","fullPath","silentlyRemoveFile","getFileForPath","unlink","silentlyRemoveDirectory","getProjectRestoreRoot","projectPath","baseName","basename","restoreRootPath","getRestoreFilePath","projectFilePath","projectRootPath","startsWith","pathWithinProject","replace","restoreRoot","getProjectFilePath","restoreFilePath","project","filePathInProject","async","ensureFolderIsClean","folder","unlinkEmptyDirectoryAsync","loadLastBackedUpFileContents","currentProjectLoadCount","projectLoadCount","restoreFolder","allEntries","getAllDirectoryContents","backupExists","entry","isDirectory","text","jsPromise","readAsText","lastBackedUpFileContents","lastBackedupLoadInProgress","notificationHTML","render","PROJECT_TO_RECOVER","restoreNotification","close","createToastFromTemplate","RECOVER_UNSAVED_FILES_TITLE","dismissOnClick","toastStyle","NOTIFICATION_STYLES_CSS_CLASS","SUCCESS","countEvent","EVENT_TYPE","PROJECT","currentProjectRoot","projectOpened","_event","projectRoot","firstEditHandled","trackedFileUpdateTimestamps","trackedFileContents","changeErrorReported","catch","writeFileIgnoreFailure","filePath","contents","parentDir","dirname","file","writeText","e","backupChangedDocs","trackedFilePaths","Object","keys","trackedFilePath","restorePath","content","cleanupUntrackedFiles","docPathsToTrack","allTrackingPaths","trackedPath","restoreFile","backupInProgress","changeScanner","getProjectRoot","openDocs","getAllOpenDocuments","dirtyDocsExists","doc","isDirty","lastTrackedTimestamp","lastChangeTimestamp","getText","log","$","addClass","logger","reportError","beforeProjectClosed","ensureOpenEditors","pathList","allOpenFiles","getAllOpenFiles","openFilePaths","openFileAndAddToWorkingSet","restoreBtnClicked","projectToRestore","pathsToRestore","isWithinProject","document","getDocumentForPath","setText","discardBtnClicked","initWith","scanIntervalMs","restoreDir","on","EVENT_AFTER_PROJECT_OPEN","EVENT_PROJECT_BEFORE_CLOSE","setInterval","init","window","testEnvironment","_FileRecoveryExtensionForTests"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2016 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global path, logger, jsPromise*/\n\n/**\n * This file outlines the process phcode follows to restore files if the application crashes or if a user closes\n * the application without saving their files.\n *\n * For each project in phcode, there's a unique 'restore' folder located in the appdata directory.\n * This folder is named according to the pattern <projectName>-<projectPathHash>.\n *\n * The restore folder monitors all files being edited in phcode, and this tracking is updated every 5 seconds\n * by a function called changeScanner. The function backs up changes every 5 seconds, and only unsaved files\n * that have been modified since the last backup are synced again. When files are saved, they're removed from\n * the backup during this changeScanner process because there's no need to restore them.\n *\n * When opening a project, we first check for the existence of a 'restore' folder associated with that project\n * and scan for any files within it. If we find any, these files are marked for potential restoration.\n *\n * During this process, we load all recoverable file data into memory and temporarily halt any writing activity\n * to the 'restore' folder. This safeguard is in place to prevent any accidental overwriting of the restore files'\n * data in case the user edits any files currently marked for restoration.\n *\n * Once we've cached the data from the restore files, we present a notification to the user, asking if they would\n * like these files to be restored. If the user agrees, we then open all of these files in the editor and populate\n * them with the previously cached, restored content.\n */\n\ndefine(function (require, exports, module) {\n    const NativeApp = require(\"utils/NativeApp\"),\n        FileSystem = require(\"filesystem/FileSystem\"),\n        ProjectManager = require(\"project/ProjectManager\"),\n        MainViewManager = require(\"view/MainViewManager\"),\n        FileSystemError = require(\"filesystem/FileSystemError\"),\n        FileUtils = require(\"file/FileUtils\"),\n        DocumentManager = require(\"document/DocumentManager\"),\n        NotificationUI = require(\"widgets/NotificationUI\"),\n        Mustache = require(\"thirdparty/mustache/mustache\"),\n        Strings = require(\"strings\"),\n        FileViewController  = require(\"project/FileViewController\"),\n        recoveryTemplate = require(\"text!./html/recovery-template.html\"),\n        EventDispatcher = require(\"utils/EventDispatcher\"),\n        Metrics = require(\"utils/Metrics\"),\n        EventManager = require(\"utils/EventManager\");\n\n    EventDispatcher.makeEventDispatcher(exports);\n    EventManager.registerEventHandler(\"ph-recovery\", exports);\n\n    const BACKUP_INTERVAL_MS = 5000;\n    let sessionRestoreDir = FileSystem.getDirectoryForPath(\n        path.normalize(NativeApp.getApplicationSupportDirectory() + \"/sessionRestore\"));\n\n    const trackedProjects = {};\n\n    function simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            let char = str.charCodeAt(i);\n            // eslint-disable-next-line no-bitwise\n            hash = ((hash << 5) - hash) + char;\n            // eslint-disable-next-line no-bitwise\n            hash = hash & hash; // Convert to 32bit integer\n        }\n        return Math.abs(hash) + \"\";\n    }\n\n    function createDir(dir) {\n        return new Promise((resolve, reject)=>{\n            dir.create(function (err) {\n                if (err && err !== FileSystemError.ALREADY_EXISTS) {\n                    console.error(\"[recovery] Error creating project crash restore folder \" + dir.fullPath, err);\n                    reject(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function silentlyRemoveFile(path) {\n        return new Promise((resolve)=>{\n            FileSystem.getFileForPath(path).unlink((err)=>{\n                if(err) {\n                    console.error(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function silentlyRemoveDirectory(dir) {\n        return new Promise((resolve)=>{\n            dir.unlink((err)=>{\n                if(err) {\n                    console.error(err);\n                }\n                resolve();\n            });\n        });\n    }\n\n    function getProjectRestoreRoot(projectPath) {\n        const baseName = path.basename(projectPath),\n            restoreRootPath = path.normalize(`${sessionRestoreDir.fullPath}/${baseName}_${simpleHash(projectPath)}`);\n        return FileSystem.getDirectoryForPath(restoreRootPath);\n    }\n\n    function getRestoreFilePath(projectFilePath, projectRootPath) {\n        if(!projectFilePath.startsWith(projectRootPath) || !trackedProjects[projectRootPath]){\n            console.error(`[recovery] cannot backed up as ${projectFilePath} is not in project ${projectRootPath}`);\n            return null;\n        }\n        let pathWithinProject = projectFilePath.replace(projectRootPath, \"\");\n        let restoreRoot = trackedProjects[projectRootPath].restoreRoot;\n        return path.normalize(`${restoreRoot.fullPath}/${pathWithinProject}`);\n    }\n\n    // try not to use this\n    function getProjectFilePath(restoreFilePath, projectRootPath) {\n        const project = trackedProjects[projectRootPath];\n        if(!project || !restoreFilePath.startsWith(project.restoreRoot.fullPath)){\n            return null;\n        }\n\n        let filePathInProject = restoreFilePath.replace(project.restoreRoot.fullPath, \"\");\n        return path.normalize(`${projectRootPath}/${filePathInProject}`);\n    }\n\n    /**\n     * the restore folder may have empty folders as files get deleted according to backup algorithm. This fn will\n     * ensure that there are no empty folders and restore folder exists\n     * @param folder\n     * @return {Promise<void>}\n     */\n    async function ensureFolderIsClean(folder) {\n        await createDir(folder);\n        await folder.unlinkEmptyDirectoryAsync();\n        await createDir(folder);\n    }\n\n    async function loadLastBackedUpFileContents(projectRootPath) {\n        const project = trackedProjects[projectRootPath];\n        if(!project){\n            console.error(\"[recovery] Cannot load backup, no tracking info of project \" + projectRootPath);\n            return;\n        }\n        const currentProjectLoadCount = project.projectLoadCount;\n        let restoreFolder = project.restoreRoot;\n        await ensureFolderIsClean(restoreFolder);\n        let allEntries = await FileSystem.getAllDirectoryContents(restoreFolder);\n        let backupExists = false;\n        for(let entry of allEntries){\n            if(entry.isDirectory){\n                continue;\n            }\n            let text = await jsPromise(FileUtils.readAsText(entry));\n            let projectFilePath = getProjectFilePath(entry.fullPath, projectRootPath);\n            if(currentProjectLoadCount !== project.projectLoadCount){\n                // this means that while we were tying to load a project backup, the user switched to another project\n                // and then switched back to this project, all before the first backup load was complete. so\n                // we just return without doing anything here. This function will be eventually called on projectOpened\n                // event handler.\n                return;\n            }\n            project.lastBackedUpFileContents[projectFilePath] = text;\n            backupExists = true;\n        }\n        project.lastBackedupLoadInProgress = false;\n        if(backupExists) {\n            let notificationHTML = Mustache.render(recoveryTemplate, {\n                Strings: Strings,\n                PROJECT_TO_RECOVER: projectRootPath\n            });\n            if(project.restoreNotification){\n                project.restoreNotification.close();\n                project.restoreNotification = null;\n            }\n            project.restoreNotification = NotificationUI.createToastFromTemplate( Strings.RECOVER_UNSAVED_FILES_TITLE,\n                notificationHTML, {\n                    dismissOnClick: false,\n                    toastStyle: NotificationUI.NOTIFICATION_STYLES_CSS_CLASS.SUCCESS\n                });\n            Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"notified\");\n        } else {\n            Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"none\");\n        }\n    }\n\n    let currentProjectRoot = null;\n    function projectOpened(_event, projectRoot) {\n        if(projectRoot.fullPath === '/') {\n            console.error(\"[recovery] Backups will not be done for root folder `/`\");\n            return;\n        }\n        if(currentProjectRoot && currentProjectRoot.fullPath === projectRoot.fullPath){\n            // If we get a redundant project open event return. This is because of #SEARCH_THIS_TAG_IN_FILE_1\n            return;\n        }\n        currentProjectRoot = projectRoot;\n        if(trackedProjects[projectRoot.fullPath]){\n            if(trackedProjects[projectRoot.fullPath].restoreNotification){\n                trackedProjects[projectRoot.fullPath].restoreNotification.close();\n                trackedProjects[projectRoot.fullPath].restoreNotification = null;\n            }\n            trackedProjects[projectRoot.fullPath].projectLoadCount++;// we use this to prevent race conditions\n            // on frequent project switch before all project backup files are loaded.\n            trackedProjects[projectRoot.fullPath].lastBackedUpFileContents = {};\n            trackedProjects[projectRoot.fullPath].firstEditHandled = false;\n            trackedProjects[projectRoot.fullPath].lastBackedupLoadInProgress = true;\n            trackedProjects[projectRoot.fullPath].trackedFileUpdateTimestamps = {};\n            trackedProjects[projectRoot.fullPath].trackedFileContents = {};\n            trackedProjects[projectRoot.fullPath].changeErrorReported = false;\n            loadLastBackedUpFileContents(projectRoot.fullPath).catch(err=>{\n                console.error(\"[recovery] loadLastBackedUpFileContents failed \", err);\n            });\n            return;\n        }\n        trackedProjects[projectRoot.fullPath] = {\n            projectLoadCount: 0, // we use this to prevent race conditions on frequent project switch before all\n            // project backup files are loaded.\n            projectRoot: projectRoot,\n            restoreRoot: getProjectRestoreRoot(projectRoot.fullPath),\n            lastBackedUpFileContents: {},\n            firstEditHandled: false, // after a project is loaded, has the first edit by user on any file been handled?\n            lastBackedupLoadInProgress: true, // while the backup is loading, we need to prevent write over the existing\n            // backup with backup info of the current session\n            trackedFileUpdateTimestamps: {},\n            trackedFileContents: {},\n            restoreNotification: null,\n            changeErrorReported: false // we only report change errors once to prevent too many Bugsnag reports\n        };\n        loadLastBackedUpFileContents(projectRoot.fullPath).catch(err=>{\n            console.error(\"[recovery] loadLastBackedUpFileContents failed \", err);\n        });\n    }\n\n    async function writeFileIgnoreFailure(filePath, contents) {\n        try {\n            let parentDir = FileSystem.getDirectoryForPath(path.dirname(filePath));\n            await createDir(parentDir);\n            let file = FileSystem.getFileForPath(filePath);\n            await jsPromise(FileUtils.writeText(file, contents, true));\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    async function backupChangedDocs(projectRoot) {\n        const project = trackedProjects[projectRoot.fullPath];\n        let trackedFilePaths =  Object.keys(project.trackedFileContents);\n        for(let trackedFilePath of trackedFilePaths){\n            const restorePath = getRestoreFilePath(trackedFilePath, projectRoot.fullPath);\n            if(restorePath) {\n                const content = project.trackedFileContents[trackedFilePath];\n                await writeFileIgnoreFailure(restorePath, content);\n            }\n            delete project.trackedFileContents[trackedFilePath];\n        }\n    }\n\n    async function cleanupUntrackedFiles(docPathsToTrack, projectRoot) {\n        const project = trackedProjects[projectRoot.fullPath];\n        let allTrackingPaths = Object.keys(project.trackedFileUpdateTimestamps);\n        for(let trackedPath of allTrackingPaths){\n            if(!docPathsToTrack[trackedPath]){\n                const restoreFile = getRestoreFilePath(trackedPath, projectRoot.fullPath);\n                if(restoreFile) {\n                    await silentlyRemoveFile(restoreFile);\n                }\n                delete project.trackedFileUpdateTimestamps[trackedPath];\n            }\n        }\n    }\n\n    let backupInProgress = false;\n\n    /**\n     * This gets executed every 5 seconds and should be as light-weight as possible. If there are no changes to be\n     * backed up, then this function should return as soon as possible without waiting for any async flows.\n     * @return {Promise<void>}\n     */\n    async function changeScanner() {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        if(backupInProgress || currentProjectRoot.fullPath === \"/\" || !project || project.lastBackedupLoadInProgress){\n            // trackingProjectRoot can be \"/\" if debug>open virtual file system menu is clicked. Don't track root fs\n            return;\n        }\n        backupInProgress = true;\n        try{\n            // do backup\n            const openDocs = DocumentManager.getAllOpenDocuments();\n            let docPathsToTrack = {}, dirtyDocsExists = false;\n            for(let doc of openDocs){\n                if(doc && doc.isDirty){\n                    dirtyDocsExists = true;\n                    docPathsToTrack[doc.file.fullPath] = true;\n                    const lastTrackedTimestamp = project.trackedFileUpdateTimestamps[doc.file.fullPath];\n                    if(!lastTrackedTimestamp || lastTrackedTimestamp !== doc.lastChangeTimestamp){\n                        // Already backed up, only need to consider it again if its contents changed\n                        project.trackedFileContents[doc.file.fullPath] = doc.getText();\n                        project.trackedFileUpdateTimestamps[doc.file.fullPath] = doc.lastChangeTimestamp;\n                    }\n                }\n            }\n            if(!project.firstEditHandled && dirtyDocsExists) {\n                // this means that the last backup session has been fully loaded in memory and a new edit has been\n                // done by the user. The user may not have yet clicked on the restore backup button. But as the user\n                // made an edit, we should delete the project restore folder to start a new backup session. The user\n                // can still restore the last backup session from the in memory `project.lastBackedUpFileContents`\n                console.log(\"Discarding old backup for restore...\");\n                await silentlyRemoveDirectory(project.restoreRoot);\n                await createDir(project.restoreRoot);\n                await backupChangedDocs(currentProjectRoot);\n                project.firstEditHandled = true;\n                if(project.restoreNotification) {\n                    // this means the user edited a file while the restore dialog was shown. This generally means the\n                    // restore folder has been nuked to make way for the new session, but the old restore contents are still\n                    // available in project.lastBackedUpFileContents. So the contents can be restored, but the restore\n                    // data has already been discarded. We hide the discard option in the case as it's already done.\n                    $(\"#DISCARD_UNSAVED_FILES_RESTORE\").addClass(\"forced-hidden\");\n                }\n            } else {\n                await backupChangedDocs(currentProjectRoot);\n                await cleanupUntrackedFiles(docPathsToTrack, currentProjectRoot);\n            }\n        } catch (e) {\n            console.error(\"[recovery] changeScanner error\", e);\n            if(!project.changeErrorReported){\n                project.changeErrorReported = true;\n                // we only report change errors once to prevent too many Bugsnag reports\n                logger.reportError(e);\n            }\n        }\n        backupInProgress = false;\n    }\n\n    function beforeProjectClosed() {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        if(project.restoreNotification) {\n            project.restoreNotification.close();\n            project.restoreNotification = null;\n        }\n        changeScanner().catch(err=>{\n            console.error(\"[recovery] beforeProjectClosed failed which scanning for changes to backup\", err);\n        });\n    }\n\n    async function ensureOpenEditors(pathList) {\n        let allOpenFiles = MainViewManager.getAllOpenFiles();\n        let openFilePaths = {};\n        for(let file of allOpenFiles){\n            openFilePaths[file.fullPath] = true;\n        }\n        for(let path of pathList) {\n            if(!openFilePaths[path]){\n                let file = FileSystem.getFileForPath(path);\n                await jsPromise(FileViewController.openFileAndAddToWorkingSet(file.fullPath));\n            }\n        }\n    }\n\n    async function restoreBtnClicked(_event, projectToRestore) {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"restoreClick\");\n        if(!project || projectToRestore !== currentProjectRoot.fullPath){\n            console.error(`[recovery] current project ${currentProjectRoot.fullPath} != restore ${projectToRestore}`);\n            return;\n        }\n        let pathsToRestore = Object.keys(project.lastBackedUpFileContents);\n        await ensureOpenEditors(pathsToRestore);\n        for(let filePath of pathsToRestore){\n            if(ProjectManager.isWithinProject(filePath)) {\n                console.log(\"restoring\", filePath);\n                let document = await jsPromise(DocumentManager.getDocumentForPath(filePath));\n                document.setText(project.lastBackedUpFileContents[filePath]);\n            } else {\n                console.error(\"[recovery] Skipping restore of non project file: \", filePath);\n            }\n        }\n        if(project.restoreNotification){\n            project.restoreNotification.close();\n            project.restoreNotification = null;\n        }\n    }\n\n    async function discardBtnClicked(_event, projectToRestore) {\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        const project = trackedProjects[currentProjectRoot.fullPath];\n        Metrics.countEvent(Metrics.EVENT_TYPE.PROJECT, \"recovery\", \"discardClick\");\n        if(!project || projectToRestore !== currentProjectRoot.fullPath){\n            console.error(`[recovery] current project ${currentProjectRoot.fullPath} != restore ${projectToRestore}`);\n            return;\n        }\n        trackedProjects[currentProjectRoot.fullPath].lastBackedUpFileContents = {};\n        // if first edit is handled, the restore directory is nuked and the backup discarded.The discard button will\n        // not be shown so this fn should never get called in the case. We also should mark firstEditHandled to true to\n        // indicate a fresh backup start for the project\n        trackedProjects[currentProjectRoot.fullPath].firstEditHandled = true;\n        if(project.restoreNotification) {\n            project.restoreNotification.close();\n            project.restoreNotification = null;\n        }\n        await silentlyRemoveDirectory(project.restoreRoot);\n        await createDir(project.restoreRoot);\n        await backupChangedDocs(currentProjectRoot);\n    }\n\n    function initWith(scanIntervalMs, restoreDir) {\n        ProjectManager.on(ProjectManager.EVENT_AFTER_PROJECT_OPEN, projectOpened);\n        ProjectManager.on(ProjectManager.EVENT_PROJECT_BEFORE_CLOSE, beforeProjectClosed);\n        exports.on(\"restoreProject\", restoreBtnClicked);\n        exports.on(\"discardProject\", discardBtnClicked);\n        sessionRestoreDir = restoreDir;\n        createDir(sessionRestoreDir);\n        setInterval(changeScanner, scanIntervalMs);\n        let currentProjectRoot = ProjectManager.getProjectRoot();\n        if(currentProjectRoot) {\n            // ##SEARCH_THIS_TAG_IN_FILE_1\n            // At boot, the startup project may be opened and we may never get the projectOpened event triggered\n            // for the startup project. So we call manually.\n            projectOpened(null, currentProjectRoot);\n        }\n    }\n\n    function init() {\n        if(!window.testEnvironment){\n            initWith(BACKUP_INTERVAL_MS, sessionRestoreDir);\n        } else {\n            // this is a test environment, expose functions to test\n            exports.getProjectRestoreRoot = getProjectRestoreRoot;\n            exports.initWith = initWith;\n            window._FileRecoveryExtensionForTests = exports;\n        }\n    }\n\n    exports.init = init;\n});\n"],"file":"FileRecovery.js"}
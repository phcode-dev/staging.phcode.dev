{"version":3,"sources":["virtual-server-main.js"],"names":["importScripts","_debugSWCacheLogs","CACHE_FILE_NAME","CACHE_FS_PATH","workbox","setConfig","debug","Route","routing","cacheFirst","strategies","CacheFirst","StaleWhileRevalidate","ExpirationPlugin","expiration","CacheExpiration","DAYS_30_IN_SEC","CACHE_NAME_EVERYTHING","CACHE_NAME_CORE_SCRIPTS","CACHE_NAME_EXTERNAL","ExpirationManager","everything","maxAgeSeconds","coreScripts","external","_debugCacheLog","args","console","log","_removeParams","url","indexOf","substring","location","href","self","_debugLivePreviewLog","_debugSWLivePreviewLogs","baseURL","lastIndexOf","endsWith","CACHE_MANIFEST_URL","virtualServerBaseURL","Config","route","wwwRegex","RegExp","_isVirtualServing","startsWith","_shouldVirtualServe","request","_clearCache","event","caches","open","then","cache","keys","forEach","index","array","delete","ports","postMessage","updatedFilesCount","length","_updateTTL","cacheName","urls","updateTimestamp","_getCurrentCacheManifest","Promise","resolve","fs","readFile","err","data","JSON","parse","_putCurrentCacheManifest","manifestObject","writeFile","stringify","error","_getNewCacheManifest","fetch","response","json","catch","_fixCache","currentCacheManifest","newCacheManifest","currentCacheKeys","Object","newCacheKeys","reject","async","changedContentURLs","deletePromises","_index","_array","relativeURL","push","all","addAll","registerRoute","path","pathname","match","download","phoenixInstanceID","decodeURI","pathSplit","split","replace","shift","join","Serve","serve","Response","redirect","refreshInProgress","_refreshCache","e","_isCacheableExternalUrl","EXTERNAL_URLS","start","addEventListener","eventType","type","skipWaiting","debugMode","logLivePreview","__WB_DISABLE_DEV_LOGS","setInstrumentedURLs","msgProcessed","processVirtualServerMessage","DONT_CACHE_BASE_URLS","origin","_isNotCacheableUrl","CORE_SCRIPTS_URLS","_isCoreScript","coreScript","_belongsToEverythingCache","destination","disAllowedExtensions","test","allCachedRoutes","method","plugins","purgeOnQuotaError","freshnessPreferredRoutes","externalCachedRoutes","core","clientsClaim"],"mappings":"AAoBAA,cAAc,wBACdA,cAAc,uCACdA,cAAc,mCACdA,cAAc,yCACdA,cAAc,sCACdA,cAAc,2EAEd,MAAMC,mBAAoB,EACpBC,gBAAkB,qBAClBC,cAAgB,sBAEtBC,QAAQC,UAAU,CAACC,MAAOL,oBAE1B,MAAMM,MAAQH,QAAQI,QAAQD,MAExBE,WAAaL,QAAQM,WAAWC,WAChCC,qBAAuBR,QAAQM,WAAWE,qBAC1CC,iBAAmBT,QAAQU,WAAWD,iBACtCE,gBAAkBX,QAAQU,WAAWC,gBACrCC,eAAiB,OACjBC,sBAAwB,aACxBC,wBAA0B,cAC1BC,oBAAsB,WACtBC,kBAAmB,CACrBC,WAAc,IAAIN,gBAAgBE,sBAAuB,CACjDK,cANW,SAQnBC,YAAe,IAAIR,gBANS,cAMgC,CACpDO,cATW,SAWnBE,SAAY,IAAIT,gBARQ,WAQ6B,CACjDO,cAZe,UAgBvB,SAASG,kBAAkBC,MACpBzB,mBACC0B,QAAQC,OAAOF,MAUvB,SAASG,cAAcC,KAOnB,OANGA,IAAIC,QAAS,MAAM,IAClBD,IAAMA,IAAIE,UAAW,EAAGF,IAAIC,QAAS,OAEtCE,SAASC,KAAKH,QAAS,MAAM,IAC5BD,IAAMA,IAAIE,UAAW,EAAGF,IAAIC,QAAS,OAElCD,IAbXK,KAAKC,qBAAuB,YAAaV,MAClCS,KAAKE,yBACJV,QAAQC,OAAOF,OAevB,IAAIY,QAAUL,SAASC,KACvBI,QAAUT,cAAcI,SAASC,MAC9BD,SAASC,KAAKH,QAAS,MAAM,IAE5BO,QAAUA,QAAQN,UAAW,EAAGM,QAAQC,YAAa,OAErDD,QAAQE,SAAS,OACjBF,SAAoB,KAExBX,QAAQC,IAAI,gCAAiCU,SAE7C,MAAMG,sBAAwBH,4BAC9BX,QAAQC,IAAI,0CAA2Ca,oBAIvD,MAAMC,wBAA0BJ,UAAUK,OAAOC,QACjDjB,QAAQC,IAAI,+CAAgDc,sBAG5D,MAAMG,SAAW,IAAIC,UAAUH,OAAOC,cAGtC,SAASG,kBAAkBjB,KACvB,OAAOA,IAAIkB,WAAWN,sBAG1B,SAASO,oBAAoBC,SACzB,OAAOH,kBAAkBG,QAAQpB,IAAII,MAuCzC,SAASiB,YAAYC,OACjBC,OAAOC,KAAKrC,uBAAuBsC,KAAMC,QACrCA,MAAMC,OAAOF,KAAME,OACfA,KAAKC,QAAQ,CAACR,QAASS,MAAOC,SAC1BJ,MAAMK,OAAOX,WAEjBE,MAAMU,MAAM,GAAGC,YAAY,CAACC,kBAAmBP,KAAKQ,aAKhE,SAASC,WAAWC,UAAWC,MAG3BzC,QAAQC,2CAA2CwC,KAAKH,yBAAyBE,aACjF,IAAI,IAAIrC,OAAOsC,KACXhD,kBAAkB+C,WAAWE,gBAAgBvC,KAIrD,SAASwC,2BACL,OAAO,IAAIC,QAASC,UAChBC,GAAGC,SAASvE,cAAe,OAAQ,SAAUwE,IAAKC,MAE1CJ,QADAG,IACQ,KAEAE,KAAKC,MAAMF,WAKnC,SAASG,yBAAyBC,gBAC9B,OAAO,IAAIT,QAASC,UAChBC,GAAGQ,UAAU9E,cAAe0E,KAAKK,UAAUF,eAAgB,KAAM,GAAI,OAAQ,SAAUL,KAC/EA,KACAhD,QAAQwD,MAAM,sDAAuDR,KAEzEH,QAAQ,UAIpB,SAASY,uBACL,OAAO,IAAIb,QAASC,UAChBa,MAAM5C,oBACDc,KAAM+B,UAAaA,SAASC,QAC5BhC,KAAMqB,MAASJ,QAAQI,OACvBY,MAAMb,MACHhD,QAAQwD,MAAM,iEAAkER,KAChFH,QAAQ,UAKxB,SAASiB,UAAUC,qBAAsBC,kBACrC,MAAMC,iBAAmBC,OAAOpC,KAAKiC,sBAC/BI,aAAeD,OAAOpC,KAAKkC,kBAGjC,OAFAhE,QAAQC,qDAAqDX,uEAClD2E,iBAAiB3B,eAAe6B,aAAa7B,UACjD,IAAIM,QAAQ,CAACC,QAASuB,UACzB1C,OAAOC,KAAKrC,uBAAuBsC,KAAMC,QACrCA,MAAMC,OAAOF,KAAKyC,MAAOvC,OACrB9B,QAAQC,IAAI,iEAAkE6B,KAAKQ,QACnF,IAAIgC,mBAAqB,GAAIC,eAAiB,GAC9CzC,KAAKC,QAAQ,CAACR,QAASiD,OAAQC,UAC3B,IAAIC,YAAcxE,cAAcqB,QAAQpB,KAExC,GADAuE,YAAcA,YAAYrE,UAAUM,QAAQ2B,OAAQoC,YAAYpC,SAC5D0B,iBAAiBU,aAGjB,OAFA5E,eAAe,2CAA4C4E,kBAC3DH,eAAeI,KAAK9C,MAAMK,OAAOX,UAGlCwC,qBAAqBW,eAAiBV,iBAAiBU,eACtD5E,eAAe,2CAA4C4E,aAC3DH,eAAeI,KAAK9C,MAAMK,OAAOX,UACjC+C,mBAAmBK,KAAKpD,QAAQpB,QAGxCH,QAAQC,gCAAgCsE,eAAejC,iCAAiChD,+BAClFsD,QAAQgC,IAAIL,gBAClBvE,QAAQC,0CAA0CqE,mBAAmBhC,aAAahD,yBAClFuC,MAAMgD,OAAOP,oBAAoB1C,KAAK,KAClC5B,QAAQC,kDAAkDqE,mBAAmBhC,kBAAkBhD,yBAC/FiD,WAAWjD,sBAAuBgF,oBAClCzB,QAAQyB,mBAAmBhC,UAC5BuB,MAAMb,MACLhD,QAAQwD,kDAAkDc,mBAAmBhC,kBAAkBhD,wBAAyB0D,KACxHoB,eAGTP,MAAMO,UA7HjB3F,QAAQI,QAAQiG,cACZxD,oBACA,EAAEnB,IAAAA,QAEE,IAAI4E,KAAO5E,IAAI6E,SAASC,MAAM/D,UAAU,GAIxC,MAAMgE,UAAW,EAIjB,IAAIC,kBACJ,IAPAJ,KAAOK,UAAUL,OAOT1D,WAAW,0BAA0B,CACzC,IAAIgE,UAAYN,KAAKO,MAAM,KAC3BH,kBAAoBE,UAAU,GAAGE,QAAQ,wBAAwB,IACjEF,UAAUG,QAAQH,UAAUG,QAC5BT,SAAWM,UAAUI,KAAK,OAG9B,OAAOC,MAAMC,MAAMZ,MAZF,EAYkBI,oBAEvC,OAIJ1G,QAAQI,QAAQiG,cACZxD,oBACA,EAAEnB,IAAAA,QACEA,IAAI6E,YAAchE,OAAOC,SAClB2B,QAAQC,QAAQ+C,SAASC,SAAS1F,IAAK,OAElD,OAiGJ,IAAI2F,mBAAoB,EACxBzB,eAAe0B,cAActE,OACzB,GAAGqE,kBACC9F,QAAQC,IAAI,uDADhB,CAIA6F,mBAAoB,EACpB,IACI9F,QAAQC,IAAI,6DACZ,MAAM8D,2BAA6BpB,2BAC7BqB,uBAAyBP,uBAC/B,IAAIO,iBAGA,OAFAhE,QAAQC,IAAI,4FACZ6F,mBAAoB,GAGxB,IAAI/B,sBAAwBC,iBAIxB,OAHAhE,QAAQC,kEAAkEiE,OAAOpC,KAAKkC,kBAAkB1B,wBAClGc,yBAAyBY,uBAC/B8B,mBAAoB,GAGxB,MAAMzD,wBAA0ByB,UAAUC,qBAAsBC,wBAC1DZ,yBAAyBY,kBAC/BvC,MAAMU,MAAM,GAAGC,YAAY,CAACC,kBAAAA,oBAC9B,MAAO2D,GACLhG,QAAQwD,MAAM,+CAAgDwC,GAElEF,mBAAoB,GA8BxB,SAASG,wBAAwB9F,KAC7B,IAAI+F,cAAgB,CAChB,+CAEJ,IAAI,IAAIC,SAASD,cACb,GAAG/F,IAAIkB,WAAW8E,OACd,OAAO,EAGf,OAAO,EApCXC,iBAAiB,UAAY3E,QAOzB,IAAI4E,UACJ,OADgB5E,MAAMwB,MAAQxB,MAAMwB,KAAKqD,MAErC,IAAK,eAAgB9F,KAAK+F,cAAe,MACzC,IAAK,sBACDvF,OAAOrC,MAAQ8C,MAAMwB,KAAKuD,UAC1BhG,KAAKE,wBAA0Be,MAAMwB,KAAKwD,eAC1CjG,KAAKkG,sBAAwB1F,OAAOrC,OAASL,kBAC7CmD,MAAMU,MAAM,GAAGC,YAAY,CAACzB,QAAAA,UAAW,MAC3C,IAAK,cAAea,YAAYC,OAAQ,MACxC,IAAK,gBAAiBsE,cAActE,OAAQ,MAC5C,IAAK,sBAA8D,OAAvCjB,KAAKkF,MAAMiB,oBAAoBlF,QAAe,EAC1E,QACI,IAAImF,aAAepG,KAAKkF,OAASlF,KAAKkF,MAAMmB,6BACxCrG,KAAKkF,MAAMmB,4BAA4BpF,QAEvCzB,QAAQwD,MAAM,4DAA6D/B,UAmB3F,MAAMqF,qBAAuB,IACtBxG,SAASyG,iBAAkBzG,SAASyG,kBAAmBzG,SAASyG,kBAEhEpG,iBAAkBA,kBAAmBA,kBAAmBA,6BAC/D,SAASqG,mBAAmB7G,KACxB,IAAI,IAAIgG,SAASW,qBACb,GAAG3G,IAAIkB,WAAW8E,OACd,OAAO,EAGf,OAAO,EAKX,MAAMc,kBAAoB,IAAI3G,SAASyG,uBAAwBzG,SAASyG,aACjEzG,SAASyG,mCAAoCzG,SAASyG,6CAEtDpG,uBAAwBA,aACxBA,mCAAoCA,2CAC3C,SAASuG,cAAc/G,KACnB,IAAI,IAAIgH,cAAcF,kBAClB,GAAG9G,MAAQgH,WACP,OAAO,EAGf,OAAO,EAGX,SAASC,0BAA0B7F,SAG/B,IAAIhB,KAAOgB,QAAQpB,IAAImF,MAAM,KAAK,GAClC,GAA2B,UAAxB/D,QAAQ8F,aAAmD,UAAxB9F,QAAQ8F,YAE1C,OADAvH,eAAe,gCAAiCyB,UACzC,EAEX,GAAGyF,mBAAmBzG,MAElB,OADAT,eAAe,qDAAsDyB,UAC9D,EAEX,GAAG2F,cAAc3G,MAEb,OADAT,eAAe,iDAAkDyB,UAC1D,EAEX,GAAG0E,wBAAwB1F,MAEvB,OADAT,eAAe,iDAAkDyB,UAC1D,EAEX,IAAI+F,qBAAwB,eAC5B,SAAG/G,KAAKc,WAAWV,UAAa2G,qBAAqBC,KAAKhH,SAG1DT,eAAe,oBAAqByB,UAC7B,GAIX,MAAMiG,gBAAkB,IAAI5I,MAAM,EAAG2C,QAAAA,WACN,QAAnBA,QAAQkG,QACTL,0BAA0B7F,WAAaH,kBAAkBG,QAAQpB,KACzE,IAAIrB,WAAW,CACd0D,UAAWlD,sBACXoI,QAAS,CACL,IAAIxI,iBAAiB,CACjBS,cAhVW,OAiVXgI,mBAAmB,QAMzBC,yBAA2B,IAAIhJ,MAAM,EAAG2C,QAAAA,WAChB,QAAnBA,QAAQkG,QAAoBP,cAAc3F,QAAQpB,OAASiB,kBAAkBG,QAAQpB,KAC7F,IAAIlB,qBAAqB,CACxBuD,UAxV4B,cAyV5BkF,QAAS,CACL,IAAIxI,iBAAiB,CACjBS,cA7VW,OA8VXgI,mBAAmB,QAMzBE,qBAAuB,IAAIjJ,MAAM,EAAG2C,QAAAA,WACZ,QAAnBA,QAAQkG,QAAoBxB,wBAAwB1E,QAAQpB,OAASiB,kBAAkBG,QAAQpB,KACvG,IAAIlB,qBAAqB,CACxBuD,UApWwB,WAqWxBkF,QAAS,CACL,IAAIxI,iBAAiB,CACjBS,cA1WW,OA2WXgI,mBAAmB,QAK/BlJ,QAAQI,QAAQiG,cAAc0C,iBAC9B/I,QAAQI,QAAQiG,cAAc8C,0BAC9BnJ,QAAQI,QAAQiG,cAAc+C,sBAE9BpJ,QAAQqJ,KAAKC","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * modified by core.ai, based on work by David Humphrey <david.humphrey@senecacolleage.ca> (@humphd)\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* global workbox, importScripts, Serve, HtmlFormatter, Config*/\nimportScripts('phoenix/virtualfs.js');\nimportScripts('phoenix/virtualServer/mime-types.js');\nimportScripts('phoenix/virtualServer/config.js');\nimportScripts('phoenix/virtualServer/content-type.js');\nimportScripts('phoenix/virtualServer/webserver.js');\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js');\n\nconst _debugSWCacheLogs = false; // change debug to true to see more logs\nconst CACHE_FILE_NAME = \"cacheManifest.json\";\nconst CACHE_FS_PATH = `/${CACHE_FILE_NAME}`;\n\nworkbox.setConfig({debug: _debugSWCacheLogs});\n\nconst Route = workbox.routing.Route;\n// other strategies include CacheFirst, NetworkFirst Etc..\nconst cacheFirst = workbox.strategies.CacheFirst;\nconst StaleWhileRevalidate = workbox.strategies.StaleWhileRevalidate;\nconst ExpirationPlugin = workbox.expiration.ExpirationPlugin;\nconst CacheExpiration = workbox.expiration.CacheExpiration;\nconst DAYS_30_IN_SEC = 60 * 60 * 24 * 30;\nconst CACHE_NAME_EVERYTHING = \"everything\";\nconst CACHE_NAME_CORE_SCRIPTS = \"coreScripts\";\nconst CACHE_NAME_EXTERNAL = \"external\";\nconst ExpirationManager ={\n    \"everything\": new CacheExpiration(CACHE_NAME_EVERYTHING, {\n            maxAgeSeconds: DAYS_30_IN_SEC\n        }),\n    \"coreScripts\": new CacheExpiration(CACHE_NAME_CORE_SCRIPTS, {\n            maxAgeSeconds: DAYS_30_IN_SEC\n        }),\n    \"external\": new CacheExpiration(CACHE_NAME_EXTERNAL, {\n        maxAgeSeconds: DAYS_30_IN_SEC\n    })\n};\n\nfunction _debugCacheLog(...args) {\n    if(_debugSWCacheLogs){\n        console.log(...args);\n    }\n}\n\nself._debugLivePreviewLog = function (...args) {\n    if(self._debugSWLivePreviewLogs){ // this is set from the debug menu\n        console.log(...args);\n    }\n}\n\nfunction _removeParams(url) {\n    if(url.indexOf( \"?\")>-1){\n        url = url.substring( 0, url.indexOf( \"?\")); // remove query string params\n    }\n    if(location.href.indexOf( \"#\")>-1){\n        url = url.substring( 0, url.indexOf( \"#\")); // remove hrefs in page\n    }\n    return url;\n}\n\n// service worker controlling route base url. This will be something like https://phcode.dev/ or http://localhost:8000/\nlet baseURL = location.href;\nbaseURL = _removeParams(location.href);\nif(location.href.indexOf( \"/\")>-1){\n    // http://phcode.dev/index.html -> http://phcode.dev\n    baseURL = baseURL.substring( 0, baseURL.lastIndexOf( \"/\"));\n}\nif(!baseURL.endsWith('/')){\n    baseURL = baseURL + '/';\n}\nconsole.log(\"Service worker: base URL is: \", baseURL);\n\nconst CACHE_MANIFEST_URL = `${baseURL}${CACHE_FILE_NAME}`;\nconsole.log(\"Service worker: cache manifest URL is: \", CACHE_MANIFEST_URL);\n\n// this is the base url where our file system virtual server lives. http://phcode.dev/phoenix/vfs in phoenix or\n// http://localhost:8000/phoenix/vfs in dev builds\nconst virtualServerBaseURL = `${baseURL}${Config.route}`;\nconsole.log(\"Service worker: Virtual server base URL is: \", virtualServerBaseURL);\n\n// Route with trailing slash (i.e., /path/into/filesystem)\nconst wwwRegex = new RegExp(`${Config.route}(/.*)`);\n// Route minus the trailing slash\n\nfunction _isVirtualServing(url) {\n    return url.startsWith(virtualServerBaseURL);\n}\n\nfunction _shouldVirtualServe(request) {\n    return _isVirtualServing(request.url.href);\n}\n\nworkbox.routing.registerRoute(\n    _shouldVirtualServe,\n    ({url}) => {\n        // Pull the filesystem path off the url\n        let path = url.pathname.match(wwwRegex)[1];\n        // Deal with encoding in the filename (e.g., spaces as %20)\n        path = decodeURI(path);\n\n        const download = false;\n        // commented Allow passing `?download` or `dl` to have the file downloaded vs. displayed\n        // url.searchParams.get('download') !== null ||\n        // url.searchParams.get('dl') !== null;\n        let phoenixInstanceID;\n        if(path.startsWith(\"/PHOENIX_LIVE_PREVIEW_\")){\n            let pathSplit = path.split(\"/\");\n            phoenixInstanceID = pathSplit[1].replace(\"PHOENIX_LIVE_PREVIEW_\",\"\");\n            pathSplit.shift();pathSplit.shift();\n            path = `/${pathSplit.join(\"/\")}`;\n        }\n\n        return Serve.serve(path, download, phoenixInstanceID);\n    },\n    'GET'\n);\n\n// Redirect if missing the / on our expected route\nworkbox.routing.registerRoute(\n    _shouldVirtualServe,\n    ({url}) => {\n        url.pathname = `${Config.route}/`;\n        return Promise.resolve(Response.redirect(url, 302));\n    },\n    'GET'\n);\n\n// cache and offline access route\nfunction _clearCache(event) {\n    caches.open(CACHE_NAME_EVERYTHING).then((cache) => {\n        cache.keys().then((keys) => {\n            keys.forEach((request, index, array) => {\n                cache.delete(request);\n            });\n            event.ports[0].postMessage({updatedFilesCount: keys.length});\n        });\n    });\n}\n\nfunction _updateTTL(cacheName, urls) {\n    // this is needed for workbox to purge cache by ttl. purge behaviour is not part of w3c spec, but done by workbox.\n    // cache.addall browser api will not update expiry ttls that workbox lib needs. So we add it here.\n    console.log(`Service worker: Updating expiry for ${urls.length} urls in cache: ${cacheName}`);\n    for(let url of urls){\n        ExpirationManager[cacheName].updateTimestamp(url);\n    }\n}\n\nfunction _getCurrentCacheManifest() {\n    return new Promise((resolve)=>{\n        fs.readFile(CACHE_FS_PATH, \"utf8\", function (err, data) {\n            if (err) {\n                resolve(null);\n            } else {\n                resolve(JSON.parse(data));\n            }\n        });\n    });\n}\nfunction _putCurrentCacheManifest(manifestObject) {\n    return new Promise((resolve)=>{\n        fs.writeFile(CACHE_FS_PATH, JSON.stringify(manifestObject, null, 2), \"UTF8\", function (err) {\n            if (err) {\n                console.error(\"Service worker: Failed while writing cache manifest\", err);\n            }\n            resolve(null);\n        });\n    });\n}\nfunction _getNewCacheManifest() {\n    return new Promise((resolve) => {\n        fetch(CACHE_MANIFEST_URL)\n            .then((response) => response.json())\n            .then((data) => resolve(data))\n            .catch(err =>{\n                console.error(\"Service worker: could not fetch cache manifest for app updates\", err);\n                resolve(null);\n            });\n    });\n}\n\nfunction _fixCache(currentCacheManifest, newCacheManifest) {\n    const currentCacheKeys = Object.keys(currentCacheManifest);\n    const newCacheKeys = Object.keys(newCacheManifest);\n    console.log(`Service worker: Fixing Stale Cache Entries in ${CACHE_NAME_EVERYTHING}. num cache entries in manifest:\n    current: ${currentCacheKeys.length} new: ${newCacheKeys.length}`);\n    return new Promise((resolve, reject) => {\n        caches.open(CACHE_NAME_EVERYTHING).then((cache) => {\n            cache.keys().then(async (keys) => {\n                console.log(\"Service worker: Number of cached entries in everything cache: \", keys.length);\n                let changedContentURLs = [], deletePromises = [];\n                keys.forEach((request, _index, _array) => {\n                    let relativeURL = _removeParams(request.url);\n                    relativeURL = relativeURL.substring(baseURL.length, relativeURL.length);\n                    if(!newCacheManifest[relativeURL]){\n                        _debugCacheLog(\"Service worker: entry renewed as deleted\", relativeURL);\n                        deletePromises.push(cache.delete(request));\n                        return;\n                    }\n                    if(currentCacheManifest[relativeURL] !== newCacheManifest[relativeURL]){\n                        _debugCacheLog(\"Service worker: entry renewed as changed\", relativeURL);\n                        deletePromises.push(cache.delete(request));\n                        changedContentURLs.push(request.url);\n                    }\n                });\n                console.log(`Service worker: deleting ${deletePromises.length} stale cache entries in ${CACHE_NAME_EVERYTHING}`);\n                await Promise.all(deletePromises);\n                console.log(`Service worker: updating cache for ${changedContentURLs.length} in ${CACHE_NAME_EVERYTHING}`);\n                cache.addAll(changedContentURLs).then(()=>{\n                    console.log(`Service worker: cache refresh complete for ${changedContentURLs.length} URLS in ${CACHE_NAME_EVERYTHING}`);\n                    _updateTTL(CACHE_NAME_EVERYTHING, changedContentURLs);\n                    resolve(changedContentURLs.length);\n                }).catch(err=>{\n                    console.error(`Service worker: cache refresh failed for ${changedContentURLs.length} URLS in ${CACHE_NAME_EVERYTHING}`, err);\n                    reject();\n                });\n            });\n        }).catch(reject);\n    });\n}\n\nlet refreshInProgress = false;\nasync function _refreshCache(event) {\n    if(refreshInProgress){\n        console.log(\"Another cache refresh is in progress, ignoring.\");\n        return;\n    }\n    refreshInProgress = true;\n    try{\n        console.log(\"Service worker: Refreshing browser cache for app updates.\");\n        const currentCacheManifest = await _getCurrentCacheManifest();\n        const newCacheManifest = await _getNewCacheManifest();\n        if(!newCacheManifest){\n            console.log(\"Service worker: could not fetch new cache manifest. Cache refresh will not be done.\");\n            refreshInProgress = false;\n            return;\n        }\n        if(!currentCacheManifest && newCacheManifest){\n            console.log(`Service worker: Fresh install, writing cache manifest with ${Object.keys(newCacheManifest).length} entries`);\n            await _putCurrentCacheManifest(newCacheManifest);\n            refreshInProgress = false;\n            return;\n        }\n        const updatedFilesCount = await _fixCache(currentCacheManifest, newCacheManifest);\n        await _putCurrentCacheManifest(newCacheManifest);\n        event.ports[0].postMessage({updatedFilesCount});\n    } catch (e) {\n        console.error(\"Service worker: error while refreshing cache\", e);\n    }\n    refreshInProgress = false;\n}\n\naddEventListener('message', (event) => {\n    // NB: Do not expect anything to persist in the service worker variables, the service worker may be reset at\n    // any time by the browser if it is not in use, and only load it when required. This means that if there is a\n    // long inactivity in the page, even if the tab is opened, the service worker will be unloaded by chrome. Then will\n    // be re-enabled when needed. Hens some of our stored variables transferred from browser tabs was being erased\n    // leading to live preview failures before. Use indexDB persistent storage only inside worker is you want to keep\n    // track of data transferred from the main browser tabs, never hold it in variables here!\n    let eventType = event.data && event.data.type;\n    switch (eventType) {\n        case 'SKIP_WAITING': self.skipWaiting(); break;\n        case 'INIT_PHOENIX_CONFIG':\n            Config.debug = event.data.debugMode;\n            self._debugSWLivePreviewLogs = event.data.logLivePreview;\n            self.__WB_DISABLE_DEV_LOGS = Config.debug && _debugSWCacheLogs;\n            event.ports[0].postMessage({baseURL}); break;\n        case 'CLEAR_CACHE': _clearCache(event); break;\n        case 'REFRESH_CACHE': _refreshCache(event); break;\n        case 'setInstrumentedURLs': self.Serve.setInstrumentedURLs(event); return true;\n        default:\n            let msgProcessed = self.Serve && self.Serve.processVirtualServerMessage &&\n                self.Serve.processVirtualServerMessage(event);\n            if(!msgProcessed){\n                console.error(\"Service worker cannot process, received unknown message: \", event);\n            }\n    }\n});\n\nfunction _isCacheableExternalUrl(url) {\n    let EXTERNAL_URLS = [\n        'https://storage.googleapis.com/workbox-cdn/'\n    ];\n    for(let start of EXTERNAL_URLS){\n        if(url.startsWith(start)){\n            return true;\n        }\n    }\n    return false;\n}\n\n// queue cache update\n\nconst DONT_CACHE_BASE_URLS = [\n    `${location.origin}/src/`, `${location.origin}/test/`, `${location.origin}/dist/`, // https://phcode.dev/src or other\n    // https://phcode.dev/subfolder/src/ or other when phoenix is loaded from https://phcode.dev/subfolder/index.html\n    `${baseURL}src/`, `${baseURL}test/`, `${baseURL}dist/`, `${baseURL}cacheManifest.json`];\nfunction _isNotCacheableUrl(url) {\n    for(let start of DONT_CACHE_BASE_URLS){\n        if(url.startsWith(start)){\n            return true;\n        }\n    }\n    return false;\n}\n\n// we always try to load main worker scripts and index html from core scripts cache which uses stale while revalidate\n// to get aggressive updates.\nconst CORE_SCRIPTS_URLS = [`${location.origin}/index.html`, `${location.origin}/`, // https://phcode.dev/src or other\n    `${location.origin}/virtual-server-main.js`, `${location.origin}/phoenix/virtual-server-loader.js`,\n    // https://phcode.dev/subfolder/src/ or other when phoenix is loaded from https://phcode.dev/subfolder/index.html\n    `${baseURL}index.html`, `${baseURL}`,\n    `${baseURL}virtual-server-main.js`, `${baseURL}phoenix/virtual-server-loader.js`];\nfunction _isCoreScript(url) {\n    for(let coreScript of CORE_SCRIPTS_URLS){\n        if(url === coreScript){\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _belongsToEverythingCache(request) {\n    // now do url checks, Remove # ,http://localhost:9000/dist/styles/images/sprites.svg#leftArrowDisabled.\n    // we cache entries with query string parameters in static pages with base url starting with phoenix base\n    let href = request.url.split(\"#\")[0];\n    if(request.destination === 'video' || request.destination === 'audio'){\n        _debugCacheLog(\"Not Caching audio/video URL: \", request);\n        return false;\n    }\n    if(_isNotCacheableUrl(href)){\n        _debugCacheLog(\"Not Caching un cacheable URL in everything cache: \", request);\n        return false;\n    }\n    if(_isCoreScript(href)){\n        _debugCacheLog(\"Not Caching core scripts in everything cache: \", request);\n        return false;\n    }\n    if(_isCacheableExternalUrl(href)){\n        _debugCacheLog(\"Not Caching external url in everything cache: \", request);\n        return false;\n    }\n    let disAllowedExtensions =  /.zip$|.map$/i;\n    if(href.startsWith(baseURL) && !disAllowedExtensions.test(href)) {\n        return true;\n    }\n    _debugCacheLog(\"Not Caching URL: \", request);\n    return false;\n}\n\n// handle all document\nconst allCachedRoutes = new Route(({ request }) => {\n    return (request.method === 'GET'\n        && _belongsToEverythingCache(request) && !_isVirtualServing(request.url));\n}, new cacheFirst({\n    cacheName: CACHE_NAME_EVERYTHING,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\n// core scripts route\nconst freshnessPreferredRoutes = new Route(({ request }) => {\n    return request.method === 'GET' && _isCoreScript(request.url) && !_isVirtualServing(request.url);\n}, new StaleWhileRevalidate({\n    cacheName: CACHE_NAME_CORE_SCRIPTS,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\n// scripts with a different origin like third party libs\nconst externalCachedRoutes = new Route(({ request }) => {\n    return request.method === 'GET' && _isCacheableExternalUrl(request.url) && !_isVirtualServing(request.url);\n}, new StaleWhileRevalidate({\n    cacheName: CACHE_NAME_EXTERNAL,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\nworkbox.routing.registerRoute(allCachedRoutes);\nworkbox.routing.registerRoute(freshnessPreferredRoutes);\nworkbox.routing.registerRoute(externalCachedRoutes);\n\nworkbox.core.clientsClaim();\n"],"file":"virtual-server-main.js"}
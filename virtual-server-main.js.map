{"version":3,"sources":["virtual-server-main.js"],"names":["importScripts","_debugSWCacheLogs","CACHE_FILE_NAME","CACHE_FS_PATH","workbox","setConfig","debug","Route","routing","cacheFirst","strategies","CacheFirst","StaleWhileRevalidate","ExpirationPlugin","expiration","CacheExpiration","DAYS_30_IN_SEC","CACHE_NAME_EVERYTHING","CACHE_NAME_CORE_SCRIPTS","CACHE_NAME_EXTERNAL","ExpirationManager","everything","maxAgeSeconds","coreScripts","external","_debugCacheLog","args","console","log","_removeParams","url","indexOf","substring","location","href","self","_debugLivePreviewLog","_debugSWLivePreviewLogs","baseURL","lastIndexOf","endsWith","CACHE_MANIFEST_URL","virtualServerBaseURL","Config","route","wwwRegex","RegExp","_isVirtualServing","startsWith","_shouldVirtualServe","request","_clearCache","caches","open","then","cache","keys","forEach","index","array","delete","_updateTTL","cacheName","urls","length","updateTimestamp","_getCurrentCacheManifest","Promise","resolve","fs","readFile","err","data","JSON","parse","_putCurrentCacheManifest","manifestObject","writeFile","stringify","error","_getNewCacheManifest","fetch","response","json","catch","_fixCache","currentCacheManifest","newCacheManifest","currentCacheKeys","Object","newCacheKeys","reject","async","changedContentURLs","deletePromises","_index","_array","relativeURL","push","all","addAll","registerRoute","path","pathname","match","decodeURI","formatter","searchParams","get","JSONFormatter","HtmlFormatter","download","Serve","serve","Response","redirect","refreshInProgress","_refreshCache","event","updatedFilesCount","ports","postMessage","e","_isCacheableExternalUrl","EXTERNAL_URLS","start","addEventListener","eventType","type","skipWaiting","debugMode","logLivePreview","__WB_DISABLE_DEV_LOGS","setInstrumentedURLs","msgProcessed","processVirtualServerMessage","DONT_CACHE_BASE_URLS","origin","_isNotCacheableUrl","CORE_SCRIPTS_URLS","_isCoreScript","coreScript","_belongsToEverythingCache","split","destination","disAllowedExtensions","test","allCachedRoutes","method","plugins","purgeOnQuotaError","freshnessPreferredRoutes","externalCachedRoutes","core","clientsClaim"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * modified by core.ai, based on work by David Humphrey <david.humphrey@senecacolleage.ca> (@humphd)\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* global workbox, importScripts, Serve, JSONFormatter, HtmlFormatter, Config*/\nimportScripts('phoenix/virtualfs.js');\nimportScripts('phoenix/virtualServer/mime-types.js');\nimportScripts('phoenix/virtualServer/config.js');\nimportScripts('phoenix/virtualServer/content-type.js');\nimportScripts('phoenix/virtualServer/webserver.js');\nimportScripts('phoenix/virtualServer/json-formatter.js');\nimportScripts('phoenix/virtualServer/html-formatter.js');\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js');\n\nconst _debugSWCacheLogs = false; // change debug to true to see more logs\nconst CACHE_FILE_NAME = \"cacheManifest.json\";\nconst CACHE_FS_PATH = `/${CACHE_FILE_NAME}`;\n\nworkbox.setConfig({debug: _debugSWCacheLogs});\n\nconst Route = workbox.routing.Route;\n// other strategies include CacheFirst, NetworkFirst Etc..\nconst cacheFirst = workbox.strategies.CacheFirst;\nconst StaleWhileRevalidate = workbox.strategies.StaleWhileRevalidate;\nconst ExpirationPlugin = workbox.expiration.ExpirationPlugin;\nconst CacheExpiration = workbox.expiration.CacheExpiration;\nconst DAYS_30_IN_SEC = 60 * 60 * 24 * 30;\nconst CACHE_NAME_EVERYTHING = \"everything\";\nconst CACHE_NAME_CORE_SCRIPTS = \"coreScripts\";\nconst CACHE_NAME_EXTERNAL = \"external\";\nconst ExpirationManager ={\n    \"everything\": new CacheExpiration(CACHE_NAME_EVERYTHING, {\n            maxAgeSeconds: DAYS_30_IN_SEC\n        }),\n    \"coreScripts\": new CacheExpiration(CACHE_NAME_CORE_SCRIPTS, {\n            maxAgeSeconds: DAYS_30_IN_SEC\n        }),\n    \"external\": new CacheExpiration(CACHE_NAME_EXTERNAL, {\n        maxAgeSeconds: DAYS_30_IN_SEC\n    })\n};\n\nfunction _debugCacheLog(...args) {\n    if(_debugSWCacheLogs){\n        console.log(...args);\n    }\n}\n\nself._debugLivePreviewLog = function (...args) {\n    if(self._debugSWLivePreviewLogs){ // this is set from the debug menu\n        console.log(...args);\n    }\n}\n\nfunction _removeParams(url) {\n    if(url.indexOf( \"?\")>-1){\n        url = url.substring( 0, url.indexOf( \"?\")); // remove query string params\n    }\n    if(location.href.indexOf( \"#\")>-1){\n        url = url.substring( 0, url.indexOf( \"#\")); // remove hrefs in page\n    }\n    return url;\n}\n\n// service worker controlling route base url. This will be something like https://phcode.dev/ or http://localhost:8000/\nlet baseURL = location.href;\nbaseURL = _removeParams(location.href);\nif(location.href.indexOf( \"/\")>-1){\n    // http://phcode.dev/index.html -> http://phcode.dev\n    baseURL = baseURL.substring( 0, baseURL.lastIndexOf( \"/\"));\n}\nif(!baseURL.endsWith('/')){\n    baseURL = baseURL + '/';\n}\nconsole.log(\"Service worker: base URL is: \", baseURL);\n\nconst CACHE_MANIFEST_URL = `${baseURL}${CACHE_FILE_NAME}`;\nconsole.log(\"Service worker: cache manifest URL is: \", CACHE_MANIFEST_URL);\n\n// this is the base url where our file system virtual server lives. http://phcode.dev/phoenix/vfs in phoenix or\n// http://localhost:8000/phoenix/vfs in dev builds\nconst virtualServerBaseURL = `${baseURL}${Config.route}`;\nconsole.log(\"Service worker: Virtual server base URL is: \", virtualServerBaseURL);\n\n// Route with trailing slash (i.e., /path/into/filesystem)\nconst wwwRegex = new RegExp(`${Config.route}(/.*)`);\n// Route minus the trailing slash\n\nfunction _isVirtualServing(url) {\n    return url.startsWith(virtualServerBaseURL);\n}\n\nfunction _shouldVirtualServe(request) {\n    return _isVirtualServing(request.url.href);\n}\n\nworkbox.routing.registerRoute(\n    _shouldVirtualServe,\n    ({url}) => {\n        // Pull the filesystem path off the url\n        let path = url.pathname.match(wwwRegex)[1];\n        // Deal with encoding in the filename (e.g., spaces as %20)\n        path = decodeURI(path);\n\n        // Allow passing `?json` on URL to get back JSON vs. raw response\n        const formatter =\n            url.searchParams.get('json') !== null\n                ? JSONFormatter\n                : HtmlFormatter;\n\n        const download = false;\n        // commented Allow passing `?download` or `dl` to have the file downloaded vs. displayed\n        // url.searchParams.get('download') !== null ||\n        // url.searchParams.get('dl') !== null;\n\n        return Serve.serve(path, formatter, download);\n    },\n    'GET'\n);\n\n// Redirect if missing the / on our expected route\nworkbox.routing.registerRoute(\n    _shouldVirtualServe,\n    ({url}) => {\n        url.pathname = `${Config.route}/`;\n        return Promise.resolve(Response.redirect(url, 302));\n    },\n    'GET'\n);\n\n// cache and offline access route\nfunction _clearCache() {\n    caches.open(CACHE_NAME_EVERYTHING).then((cache) => {\n        cache.keys().then((keys) => {\n            keys.forEach((request, index, array) => {\n                cache.delete(request);\n            });\n        });\n    });\n}\n\nfunction _updateTTL(cacheName, urls) {\n    // this is needed for workbox to purge cache by ttl. purge behaviour is not part of w3c spec, but done by workbox.\n    // cache.addall browser api will not update expiry ttls that workbox lib needs. So we add it here.\n    console.log(`Service worker: Updating expiry for ${urls.length} urls in cache: ${cacheName}`);\n    for(let url of urls){\n        ExpirationManager[cacheName].updateTimestamp(url);\n    }\n}\n\nfunction _getCurrentCacheManifest() {\n    return new Promise((resolve)=>{\n        fs.readFile(CACHE_FS_PATH, \"utf8\", function (err, data) {\n            if (err) {\n                resolve(null);\n            } else {\n                resolve(JSON.parse(data));\n            }\n        });\n    });\n}\nfunction _putCurrentCacheManifest(manifestObject) {\n    return new Promise((resolve)=>{\n        fs.writeFile(CACHE_FS_PATH, JSON.stringify(manifestObject, null, 2), \"UTF8\", function (err) {\n            if (err) {\n                console.error(\"Service worker: Failed while writing cache manifest\", err);\n            }\n            resolve(null);\n        });\n    });\n}\nfunction _getNewCacheManifest() {\n    return new Promise((resolve) => {\n        fetch(CACHE_MANIFEST_URL)\n            .then((response) => response.json())\n            .then((data) => resolve(data))\n            .catch(err =>{\n                console.error(\"Service worker: could not fetch cache manifest for app updates\", err);\n                resolve(null);\n            });\n    });\n}\n\nfunction _fixCache(currentCacheManifest, newCacheManifest) {\n    const currentCacheKeys = Object.keys(currentCacheManifest);\n    const newCacheKeys = Object.keys(newCacheManifest);\n    console.log(`Service worker: Fixing Stale Cache Entries in ${CACHE_NAME_EVERYTHING}. num cache entries in manifest:\n    current: ${currentCacheKeys.length} new: ${newCacheKeys.length}`);\n    return new Promise((resolve, reject) => {\n        caches.open(CACHE_NAME_EVERYTHING).then((cache) => {\n            cache.keys().then(async (keys) => {\n                console.log(\"Service worker: Number of cached entries in everything cache: \", keys.length);\n                let changedContentURLs = [], deletePromises = [];\n                keys.forEach((request, _index, _array) => {\n                    let relativeURL = _removeParams(request.url);\n                    relativeURL = relativeURL.substring(baseURL.length, relativeURL.length);\n                    if(!newCacheManifest[relativeURL]){\n                        _debugCacheLog(\"Service worker: entry renewed as deleted\", relativeURL);\n                        deletePromises.push(cache.delete(request));\n                        return;\n                    }\n                    if(currentCacheManifest[relativeURL] !== newCacheManifest[relativeURL]){\n                        _debugCacheLog(\"Service worker: entry renewed as changed\", relativeURL);\n                        deletePromises.push(cache.delete(request));\n                        changedContentURLs.push(request.url);\n                    }\n                });\n                console.log(`Service worker: deleting ${deletePromises.length} stale cache entries in ${CACHE_NAME_EVERYTHING}`);\n                await Promise.all(deletePromises);\n                console.log(`Service worker: updating cache for ${changedContentURLs.length} in ${CACHE_NAME_EVERYTHING}`);\n                cache.addAll(changedContentURLs).then(()=>{\n                    console.log(`Service worker: cache refresh complete for ${changedContentURLs.length} URLS in ${CACHE_NAME_EVERYTHING}`);\n                    _updateTTL(CACHE_NAME_EVERYTHING, changedContentURLs);\n                    resolve(changedContentURLs.length);\n                }).catch(err=>{\n                    console.error(`Service worker: cache refresh failed for ${changedContentURLs.length} URLS in ${CACHE_NAME_EVERYTHING}`, err);\n                    reject();\n                });\n            });\n        }).catch(reject);\n    });\n}\n\nlet refreshInProgress = false;\nasync function _refreshCache(event) {\n    if(refreshInProgress){\n        console.log(\"Another cache refresh is in progress, ignoring.\");\n        return;\n    }\n    refreshInProgress = true;\n    try{\n        console.log(\"Service worker: Refreshing browser cache for app updates.\");\n        const currentCacheManifest = await _getCurrentCacheManifest();\n        const newCacheManifest = await _getNewCacheManifest();\n        if(!newCacheManifest){\n            console.log(\"Service worker: could not fetch new cache manifest. Cache refresh will not be done.\");\n            refreshInProgress = false;\n            return;\n        }\n        if(!currentCacheManifest && newCacheManifest){\n            console.log(`Service worker: Fresh install, writing cache manifest with ${Object.keys(newCacheManifest).length} entries`);\n            await _putCurrentCacheManifest(newCacheManifest);\n            refreshInProgress = false;\n            return;\n        }\n        const updatedFilesCount = await _fixCache(currentCacheManifest, newCacheManifest);\n        await _putCurrentCacheManifest(newCacheManifest);\n        event.ports[0].postMessage({updatedFilesCount});\n    } catch (e) {\n        console.error(\"Service worker: error while refreshing cache\", e);\n    }\n    refreshInProgress = false;\n}\n\naddEventListener('message', (event) => {\n    // NB: Do not expect anything to persist in the service worker variables, the service worker may be reset at\n    // any time by the browser if it is not in use, and only load it when required. This means that if there is a\n    // long inactivity in the page, even if the tab is opened, the service worker will be unloaded by chrome. Then will\n    // be re-enabled when needed. Hens some of our stored variables transferred from browser tabs was being erased\n    // leading to live preview failures before. Use indexDB persistent storage only inside worker is you want to keep\n    // track of data transferred from the main browser tabs, never hold it in variables here!\n    let eventType = event.data && event.data.type;\n    switch (eventType) {\n        case 'SKIP_WAITING': self.skipWaiting(); break;\n        case 'INIT_PHOENIX_CONFIG':\n            Config.debug = event.data.debugMode;\n            self._debugSWLivePreviewLogs = event.data.logLivePreview;\n            self.__WB_DISABLE_DEV_LOGS = Config.debug && _debugSWCacheLogs;\n            event.ports[0].postMessage({baseURL}); break;\n        case 'CLEAR_CACHE': _clearCache(); break;\n        case 'REFRESH_CACHE': _refreshCache(event); break;\n        case 'setInstrumentedURLs': self.Serve.setInstrumentedURLs(event); return true;\n        default:\n            let msgProcessed = self.Serve && self.Serve.processVirtualServerMessage &&\n                self.Serve.processVirtualServerMessage(event);\n            if(!msgProcessed){\n                console.error(\"Service worker cannot process, received unknown message: \", event);\n            }\n    }\n});\n\nfunction _isCacheableExternalUrl(url) {\n    let EXTERNAL_URLS = [\n        'https://storage.googleapis.com/workbox-cdn/'\n    ];\n    for(let start of EXTERNAL_URLS){\n        if(url.startsWith(start)){\n            return true;\n        }\n    }\n    return false;\n}\n\n// queue cache update\n\nconst DONT_CACHE_BASE_URLS = [\n    `${location.origin}/src/`, `${location.origin}/test/`, `${location.origin}/dist/`, // https://phcode.dev/src or other\n    // https://phcode.dev/subfolder/src/ or other when phoenix is loaded from https://phcode.dev/subfolder/index.html\n    `${baseURL}src/`, `${baseURL}test/`, `${baseURL}dist/`, `${baseURL}cacheManifest.json`];\nfunction _isNotCacheableUrl(url) {\n    for(let start of DONT_CACHE_BASE_URLS){\n        if(url.startsWith(start)){\n            return true;\n        }\n    }\n    return false;\n}\n\n// we always try to load main worker scripts and index html from core scripts cache which uses stale while revalidate\n// to get aggressive updates.\nconst CORE_SCRIPTS_URLS = [`${location.origin}/index.html`, `${location.origin}/`, // https://phcode.dev/src or other\n    `${location.origin}/virtual-server-main.js`, `${location.origin}/phoenix/virtual-server-loader.js`,\n    // https://phcode.dev/subfolder/src/ or other when phoenix is loaded from https://phcode.dev/subfolder/index.html\n    `${baseURL}index.html`, `${baseURL}`,\n    `${baseURL}virtual-server-main.js`, `${baseURL}phoenix/virtual-server-loader.js`];\nfunction _isCoreScript(url) {\n    for(let coreScript of CORE_SCRIPTS_URLS){\n        if(url === coreScript){\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _belongsToEverythingCache(request) {\n    // now do url checks, Remove # ,http://localhost:9000/dist/styles/images/sprites.svg#leftArrowDisabled.\n    // we cache entries with query string parameters in static pages with base url starting with phoenix base\n    let href = request.url.split(\"#\")[0];\n    if(request.destination === 'video' || request.destination === 'audio'){\n        _debugCacheLog(\"Not Caching audio/video URL: \", request);\n        return false;\n    }\n    if(_isNotCacheableUrl(href)){\n        _debugCacheLog(\"Not Caching un cacheable URL in everything cache: \", request);\n        return false;\n    }\n    if(_isCoreScript(href)){\n        _debugCacheLog(\"Not Caching core scripts in everything cache: \", request);\n        return false;\n    }\n    if(_isCacheableExternalUrl(href)){\n        _debugCacheLog(\"Not Caching external url in everything cache: \", request);\n        return false;\n    }\n    let disAllowedExtensions =  /.zip$|.map$/i;\n    if(href.startsWith(baseURL) && !disAllowedExtensions.test(href)) {\n        return true;\n    }\n    _debugCacheLog(\"Not Caching URL: \", request);\n    return false;\n}\n\n// handle all document\nconst allCachedRoutes = new Route(({ request }) => {\n    return (request.method === 'GET'\n        && _belongsToEverythingCache(request) && !_isVirtualServing(request.url));\n}, new cacheFirst({\n    cacheName: CACHE_NAME_EVERYTHING,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\n// core scripts route\nconst freshnessPreferredRoutes = new Route(({ request }) => {\n    return request.method === 'GET' && _isCoreScript(request.url) && !_isVirtualServing(request.url);\n}, new StaleWhileRevalidate({\n    cacheName: CACHE_NAME_CORE_SCRIPTS,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\n// scripts with a different origin like third party libs\nconst externalCachedRoutes = new Route(({ request }) => {\n    return request.method === 'GET' && _isCacheableExternalUrl(request.url) && !_isVirtualServing(request.url);\n}, new StaleWhileRevalidate({\n    cacheName: CACHE_NAME_EXTERNAL,\n    plugins: [\n        new ExpirationPlugin({\n            maxAgeSeconds: DAYS_30_IN_SEC,\n            purgeOnQuotaError: true\n        })\n    ]\n}));\n\nworkbox.routing.registerRoute(allCachedRoutes);\nworkbox.routing.registerRoute(freshnessPreferredRoutes);\nworkbox.routing.registerRoute(externalCachedRoutes);\n\nworkbox.core.clientsClaim();\n"],"file":"virtual-server-main.js"}
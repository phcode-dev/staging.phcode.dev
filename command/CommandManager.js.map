{"version":3,"sources":["command/CommandManager.js"],"names":["define","require","exports","module","EventDispatcher","_commands","_commandsOriginal","Command","name","id","commandFn","this","_name","_id","_commandFn","_checked","undefined","_enabled","register","console","log","error","command","trigger","registerInternal","_testReset","_testRestore","get","getAll","Object","keys","execute","err","apply","Array","prototype","slice","call","arguments","$","Deferred","reject","promise","makeEventDispatcher","getID","result","resolve","getEnabled","setEnabled","enabled","changed","setChecked","checked","getChecked","setName","getName"],"mappings":"AA6BAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,gBAAkBH,QAAQ,yBAO1BI,UAAY,GAOZC,kBAAoB,GAiBxB,SAASC,QAAQC,KAAMC,GAAIC,WACvBC,KAAKC,MAAQJ,KACbG,KAAKE,IAAMJ,GACXE,KAAKG,WAAaJ,UAClBC,KAAKI,cAAWC,EAChBL,KAAKM,UAAW,EAsHpB,SAASC,SAASV,KAAMC,GAAIC,WACxB,GAAIL,UAAUI,IAEV,OADAU,QAAQC,IAAI,yDAA2DX,IAChE,KAEX,IAAKD,OAASC,KAAOC,UAEjB,OADAS,QAAQE,MAAM,iFAAmFb,KAAO,IAAMC,IACvG,KAGX,IAAIa,QAAU,IAAIf,QAAQC,KAAMC,GAAIC,WAKpC,OAJAL,UAAUI,IAAMa,QAEhBpB,QAAQqB,QAAQ,oBAAqBD,SAE9BA,QAeX,SAASE,iBAAiBf,GAAIC,WAC1B,GAAIL,UAAUI,IAEV,OADAU,QAAQC,IAAI,yDAA2DX,IAChE,KAEX,IAAKA,KAAOC,UAER,OADAS,QAAQE,MAAM,sFAAwFZ,IAC/F,KAGX,IAAIa,QAAU,IAAIf,QAAQ,KAAME,GAAIC,WAKpC,OAJAL,UAAUI,IAAMa,QAEhBpB,QAAQqB,QAAQ,oBAAqBD,SAE9BA,QAOX,SAASG,aACLnB,kBAAoBD,UACpBA,UAAY,GAMhB,SAASqB,eACLrB,UAAYC,kBACZA,kBAAoB,GAQxB,SAASqB,IAAIlB,IACT,OAAOJ,UAAUI,IAOrB,SAASmB,SACL,OAAOC,OAAOC,KAAKzB,WASvB,SAAS0B,QAAQtB,IACb,IAAIa,QAAUjB,UAAUI,IAExB,GAAIa,QAAS,CACT,IACIpB,QAAQqB,QAAQ,uBAAwBd,IAC1C,MAAOuB,KACLb,QAAQE,MAAMW,KAGlB,OAAOV,QAAQS,QAAQE,MAAMX,QAASY,MAAMC,UAAUC,MAAMC,KAAKC,UAAW,IAEhF,OAAO,IAAKC,EAAEC,UAAYC,SAASC,UAxNvCtC,gBAAgBuC,oBAAoBpC,QAAQ4B,WAM5C5B,QAAQ4B,UAAUS,MAAQ,WACtB,OAAOjC,KAAKE,KAQhBN,QAAQ4B,UAAUJ,QAAU,WACxB,IAAKpB,KAAKM,SACN,OAAO,IAAKsB,EAAEC,UAAYC,SAASC,UAGvC,IAAIG,OAASlC,KAAKG,WAAWmB,MAAMtB,KAAM2B,WACzC,OAAKO,SAGM,IAAKN,EAAEC,UAAYM,UAAUJ,WAU5CnC,QAAQ4B,UAAUY,WAAa,WAC3B,OAAOpC,KAAKM,UAQhBV,QAAQ4B,UAAUa,WAAa,SAAUC,SACrC,IAAIC,QAAUvC,KAAKM,WAAagC,QAChCtC,KAAKM,SAAWgC,QAEZC,SACAvC,KAAKY,QAAQ,uBASrBhB,QAAQ4B,UAAUgB,WAAa,SAAUC,SACrC,IAAIF,QAAUvC,KAAKI,WAAaqC,QAChCzC,KAAKI,SAAWqC,QAEZF,SACAvC,KAAKY,QAAQ,uBAQrBhB,QAAQ4B,UAAUkB,WAAa,WAC3B,OAAO1C,KAAKI,UAahBR,QAAQ4B,UAAUmB,QAAU,SAAU9C,MAClC,IAAI0C,QAAUvC,KAAKC,QAAUJ,KAC7BG,KAAKC,MAAQJ,KAET0C,SACAvC,KAAKY,QAAQ,eAQrBhB,QAAQ4B,UAAUoB,QAAU,WACxB,OAAO5C,KAAKC,OA0HhBR,gBAAgBuC,oBAAoBzC,SAGpCA,QAAQgB,SAAsBA,SAC9BhB,QAAQsB,iBAAsBA,iBAC9BtB,QAAQ6B,QAAsBA,QAC9B7B,QAAQyB,IAAsBA,IAC9BzB,QAAQ0B,OAAsBA,OAC9B1B,QAAQuB,WAAsBA,WAC9BvB,QAAQwB,aAAsBA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n /**\n  * Manages global application commands that can be called from menu items, key bindings, or subparts\n  * of the application.\n  *\n  * This module dispatches these event(s):\n  *    - commandRegistered  -- when a new command is registered\n  *    - beforeExecuteCommand -- before dispatching a command\n  */\ndefine(function (require, exports, module) {\n\n\n    var EventDispatcher = require(\"utils/EventDispatcher\");\n\n\n    /**\n     * Map of all registered global commands\n     * @type {Object.<commandID: string, Command>}\n     */\n    var _commands = {};\n\n    /**\n     * Temporary copy of commands map for restoring after testing\n     * TODO (issue #1039): implement separate require contexts for unit tests\n     * @type {Object.<commandID: string, Command>}\n     */\n    var _commandsOriginal = {};\n\n    /**\n     * Events:\n     * - enabledStateChange\n     * - checkedStateChange\n     * - keyBindingAdded\n     * - keyBindingRemoved\n     *\n     * @constructor\n     * @private\n     * @param {string} name - text that will be displayed in the UI to represent command\n     * @param {string} id\n     * @param {function} commandFn - the function that is called when the command is executed.\n     *\n     * TODO: where should this be triggered, The Command or Exports?\n     */\n    function Command(name, id, commandFn) {\n        this._name = name;\n        this._id = id;\n        this._commandFn = commandFn;\n        this._checked = undefined;\n        this._enabled = true;\n    }\n    EventDispatcher.makeEventDispatcher(Command.prototype);\n\n    /**\n     * Get command id\n     * @return {string}\n     */\n    Command.prototype.getID = function () {\n        return this._id;\n    };\n\n    /**\n     * Executes the command. Additional arguments are passed to the executing function\n     *\n     * @return {$.Promise} a jQuery promise that will be resolved when the command completes.\n     */\n    Command.prototype.execute = function () {\n        if (!this._enabled) {\n            return (new $.Deferred()).reject().promise();\n        }\n\n        var result = this._commandFn.apply(this, arguments);\n        if (!result) {\n            // If command does not return a promise, assume that it handled the\n            // command and return a resolved promise\n            return (new $.Deferred()).resolve().promise();\n        }\n        return result;\n\n    };\n\n    /**\n     * Is command enabled?\n     * @return {boolean}\n     */\n    Command.prototype.getEnabled = function () {\n        return this._enabled;\n    };\n\n    /**\n     * Sets enabled state of Command and dispatches \"enabledStateChange\"\n     * when the enabled state changes.\n     * @param {boolean} enabled\n     */\n    Command.prototype.setEnabled = function (enabled) {\n        var changed = this._enabled !== enabled;\n        this._enabled = enabled;\n\n        if (changed) {\n            this.trigger(\"enabledStateChange\");\n        }\n    };\n\n    /**\n     * Sets enabled state of Command and dispatches \"checkedStateChange\"\n     * when the enabled state changes.\n     * @param {boolean} checked\n     */\n    Command.prototype.setChecked = function (checked) {\n        var changed = this._checked !== checked;\n        this._checked = checked;\n\n        if (changed) {\n            this.trigger(\"checkedStateChange\");\n        }\n    };\n\n    /**\n     * Is command checked?\n     * @return {boolean}\n     */\n    Command.prototype.getChecked = function () {\n        return this._checked;\n    };\n\n    /**\n     * Sets the name of the Command and dispatches \"nameChange\" so that\n     * UI that reflects the command name can update.\n     *\n     * Note, a Command name can appear in either HTML or native UI\n     * so HTML tags should not be used. To add a Unicode character,\n     * use \\uXXXX instead of an HTML entity.\n     *\n     * @param {string} name\n     */\n    Command.prototype.setName = function (name) {\n        var changed = this._name !== name;\n        this._name = name;\n\n        if (changed) {\n            this.trigger(\"nameChange\");\n        }\n    };\n\n    /**\n     * Get command name\n     * @return {string}\n     */\n    Command.prototype.getName = function () {\n        return this._name;\n    };\n\n\n\n    /**\n     * Registers a global command.\n     * @param {string} name - text that will be displayed in the UI to represent command\n     * @param {string} id - unique identifier for command.\n     *      Core commands in Brackets use a simple command title as an id, for example \"open.file\".\n     *      Extensions should use the following format: \"author.myextension.mycommandname\".\n     *      For example, \"lschmitt.csswizard.format.css\".\n     * @param {function(...)} commandFn - the function to call when the command is executed. Any arguments passed to\n     *     execute() (after the id) are passed as arguments to the function. If the function is asynchronous,\n     *     it must return a jQuery promise that is resolved when the command completes. Otherwise, the\n     *     CommandManager will assume it is synchronous, and return a promise that is already resolved.\n     * @return {?Command}\n     */\n    function register(name, id, commandFn) {\n        if (_commands[id]) {\n            console.log(\"Attempting to register an already-registered command: \" + id);\n            return null;\n        }\n        if (!name || !id || !commandFn) {\n            console.error(\"Attempting to register a command with a missing name, id, or command function:\" + name + \" \" + id);\n            return null;\n        }\n\n        var command = new Command(name, id, commandFn);\n        _commands[id] = command;\n\n        exports.trigger(\"commandRegistered\", command);\n\n        return command;\n    }\n\n    /**\n     * Registers a global internal only command.\n     * @param {string} id - unique identifier for command.\n     *      Core commands in Brackets use a simple command title as an id, for example \"app.abort_quit\".\n     *      Extensions should use the following format: \"author.myextension.mycommandname\".\n     *      For example, \"lschmitt.csswizard.format.css\".\n     * @param {function(...)} commandFn - the function to call when the command is executed. Any arguments passed to\n     *     execute() (after the id) are passed as arguments to the function. If the function is asynchronous,\n     *     it must return a jQuery promise that is resolved when the command completes. Otherwise, the\n     *     CommandManager will assume it is synchronous, and return a promise that is already resolved.\n     * @return {?Command}\n     */\n    function registerInternal(id, commandFn) {\n        if (_commands[id]) {\n            console.log(\"Attempting to register an already-registered command: \" + id);\n            return null;\n        }\n        if (!id || !commandFn) {\n            console.error(\"Attempting to register an internal command with a missing id, or command function: \" + id);\n            return null;\n        }\n\n        var command = new Command(null, id, commandFn);\n        _commands[id] = command;\n\n        exports.trigger(\"commandRegistered\", command);\n\n        return command;\n    }\n\n    /**\n     * Clear all commands for unit testing, but first make copy of commands so that\n     * they can be restored afterward\n     */\n    function _testReset() {\n        _commandsOriginal = _commands;\n        _commands = {};\n    }\n\n    /**\n     * Restore original commands after test and release copy\n     */\n    function _testRestore() {\n        _commands = _commandsOriginal;\n        _commandsOriginal = {};\n    }\n\n    /**\n     * Retrieves a Command object by id\n     * @param {string} id\n     * @return {Command}\n     */\n    function get(id) {\n        return _commands[id];\n    }\n\n    /**\n     * Returns the ids of all registered commands\n     * @return {Array.<string>}\n     */\n    function getAll() {\n        return Object.keys(_commands);\n    }\n\n    /**\n     * Looks up and runs a global command. Additional arguments are passed to the command.\n     *\n     * @param {string} id The ID of the command to run.\n     * @return {$.Promise} a jQuery promise that will be resolved when the command completes.\n     */\n    function execute(id) {\n        var command = _commands[id];\n\n        if (command) {\n            try {\n                exports.trigger(\"beforeExecuteCommand\", id);\n            } catch (err) {\n                console.error(err);\n            }\n\n            return command.execute.apply(command, Array.prototype.slice.call(arguments, 1));\n        }\n        return (new $.Deferred()).reject().promise();\n\n    }\n\n    EventDispatcher.makeEventDispatcher(exports);\n\n    // Define public API\n    exports.register            = register;\n    exports.registerInternal    = registerInternal;\n    exports.execute             = execute;\n    exports.get                 = get;\n    exports.getAll              = getAll;\n    exports._testReset          = _testReset;\n    exports._testRestore        = _testRestore;\n});\n"],"file":"CommandManager.js"}
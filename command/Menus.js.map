{"version":3,"sources":["command/Menus.js"],"names":["define","require","exports","module","_","Commands","EventDispatcher","KeyBindingManager","StringUtils","CommandManager","PopUpManager","ViewUtils","Metrics","DeprecationWarning","AppMenuBar","FILE_MENU","EDIT_MENU","FIND_MENU","VIEW_MENU","NAVIGATE_MENU","HELP_MENU","ContextMenuIds","EDITOR_MENU","INLINE_EDITOR_MENU","PROJECT_MENU","WORKING_SET_CONTEXT_MENU","WORKING_SET_CONFIG_MENU","SPLITVIEW_MENU","MenuSection","FILE_OPEN_CLOSE_COMMANDS","sectionMarker","FILE_NEW","FILE_SAVE_COMMANDS","FILE_SAVE","FILE_LIVE","FILE_LIVE_FILE_PREVIEW","FILE_EXTENSION_MANAGER","EDIT_UNDO_REDO_COMMANDS","EDIT_UNDO","EDIT_TEXT_COMMANDS","EDIT_CUT","EDIT_SELECTION_COMMANDS","EDIT_SELECT_ALL","EDIT_MODIFY_SELECTION","EDIT_INDENT","EDIT_COMMENT_SELECTION","EDIT_LINE_COMMENT","EDIT_CODE_HINTS_COMMANDS","SHOW_CODE_HINTS","EDIT_TOGGLE_OPTIONS","TOGGLE_CLOSE_BRACKETS","FIND_FIND_COMMANDS","CMD_FIND","FIND_FIND_IN_COMMANDS","CMD_FIND_IN_FILES","FIND_REPLACE_COMMANDS","CMD_REPLACE","VIEW_HIDESHOW_COMMANDS","VIEW_HIDE_SIDEBAR","VIEW_FONTSIZE_COMMANDS","VIEW_INCREASE_FONT_SIZE","VIEW_TOGGLE_OPTIONS","TOGGLE_ACTIVE_LINE","NAVIGATE_GOTO_COMMANDS","NAVIGATE_QUICK_OPEN","NAVIGATE_DOCUMENTS_COMMANDS","NAVIGATE_NEXT_DOC","NAVIGATE_OS_COMMANDS","NAVIGATE_SHOW_IN_FILE_TREE","NAVIGATE_QUICK_EDIT_COMMANDS","TOGGLE_QUICK_EDIT","NAVIGATE_QUICK_DOCS_COMMANDS","TOGGLE_QUICK_DOCS","BEFORE","AFTER","FIRST","LAST","FIRST_IN_SECTION","LAST_IN_SECTION","DIVIDER","SUBMENU","NO_ERROR","ERR_UNKNOWN","ERR_INVALID_PARAMS","ERR_NOT_FOUND","menuMap","contextMenuMap","menuItemMap","getMenu","id","getAllMenus","getContextMenu","removeMenuItemEventListeners","menuItem","_command","off","_enabledChanged","_checkedChanged","_nameChanged","_keyBindingAdded","_keyBindingRemoved","getMenuItem","_getHTMLMenu","$","jQueryIdEscape","get","_getHTMLMenuItem","_addKeyBindingToMenuItem","$menuItem","key","displayKey","$shortcut","find","length","append","data","text","formatKeyDescriptor","_addExistingKeyBinding","bindings","getKeyBindings","getCommand","getID","binding","_menuDividerIDCount","_getNextMenuItemDividerID","_insertInList","$list","$element","position","$relativeElement","inserted","prepend","after","before","MenuItem","command","this","isDivider","isNative","bind","on","Menu","closeAll","removeClass","addMenu","name","relativeID","escape","$menubar","menu","console","error","log","$toggle","$popUp","$newMenu","addPopUp","removeMenu","commandID","forEach","value","startsWith","removeMenuDivider","removeMenuItem","remove","ContextMenu","apply","arguments","hide","self","close","listenToContextMenu","registerContextMenu","cmenu","prototype","_getMenuItemId","commandId","_getMenuItemForCommand","foundMenuItem","closest","_getRelativeMenuItem","hasOwnProperty","$sectionMarker","$listElem","prev","next","menuItemID","commandObj","parent","$HTMLMenuItem","addMenuItem","keyBindings","getName","countEvent","EVENT_TYPE","UI_MENU","execute","closeSubMenu","dividerId","Array","isArray","addBinding","addMenuDivider","addSubMenu","parentMenuItem","e","openSubMenu","open","removeSubMenu","subMenuID","subMenu","getParentMenu","parents","checked","getChecked","enabled","getEnabled","brackets","app","setMenuItemState","err","toggleClass","setMenuTitle","event","keyBinding","shortcutKey","setMenuItemShortcut","empty","Object","create","constructor","parentClass","makeEventDispatcher","mouseOrLocation","$window","window","escapedId","$menuAnchor","$menuWindow","posTop","posLeft","children","trigger","$parentMenuItem","elementRect","top","offset","left","outerWidth","height","width","clip","getElementClipSize","bottom","Math","max","right","pageY","pageX","addClass","css","isOpen","hasClass","assignContextMenuToSelector","selector","buttonOffset","buttonHeight","stopPropagation","outerHeight","deprecateConstant"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    let _ = require(\"thirdparty/lodash\");\n\n    // Load dependent modules\n    let Commands            = require(\"command/Commands\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        KeyBindingManager   = require(\"command/KeyBindingManager\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        CommandManager      = require(\"command/CommandManager\"),\n        PopUpManager        = require(\"widgets/PopUpManager\"),\n        ViewUtils           = require(\"utils/ViewUtils\"),\n        Metrics             = require(\"utils/Metrics\"),\n        DeprecationWarning  = require(\"utils/DeprecationWarning\");\n\n    // make sure the global brackets letiable is loaded\n    require(\"utils/Global\");\n\n    /**\n     * Brackets Application Menu Constants\n     * @enum {string}\n     */\n    let AppMenuBar = {\n        FILE_MENU: \"file-menu\",\n        EDIT_MENU: \"edit-menu\",\n        FIND_MENU: \"find-menu\",\n        VIEW_MENU: \"view-menu\",\n        NAVIGATE_MENU: \"navigate-menu\",\n        HELP_MENU: \"help-menu\"\n    };\n\n    /**\n     * Brackets Context Menu Constants\n     * @enum {string}\n     */\n    let ContextMenuIds = {\n        EDITOR_MENU: \"editor-context-menu\",\n        INLINE_EDITOR_MENU: \"inline-editor-context-menu\",\n        PROJECT_MENU: \"project-context-menu\",\n        WORKING_SET_CONTEXT_MENU: \"workingset-context-menu\",\n        WORKING_SET_CONFIG_MENU: \"workingset-configuration-menu\",\n        SPLITVIEW_MENU: \"splitview-menu\"\n    };\n\n    /**\n     * Brackets Application Menu Section Constants\n     * It is preferred that plug-ins specify the location of new MenuItems\n     * in terms of a menu section rather than a specific MenuItem. This provides\n     * looser coupling to Bracket's internal MenuItems and makes menu organization\n     * more semantic.\n     * Use these constants as the \"relativeID\" parameter when calling addMenuItem() and\n     * specify a position of FIRST_IN_SECTION or LAST_IN_SECTION.\n     *\n     * Menu sections are denoted by dividers or the beginning/end of a menu\n     */\n    let MenuSection = {\n        // Menu Section                     Command ID to mark the section\n        FILE_OPEN_CLOSE_COMMANDS: {sectionMarker: Commands.FILE_NEW},\n        FILE_SAVE_COMMANDS: {sectionMarker: Commands.FILE_SAVE},\n        FILE_LIVE: {sectionMarker: Commands.FILE_LIVE_FILE_PREVIEW},\n        FILE_EXTENSION_MANAGER: {sectionMarker: Commands.FILE_EXTENSION_MANAGER},\n\n        EDIT_UNDO_REDO_COMMANDS: {sectionMarker: Commands.EDIT_UNDO},\n        EDIT_TEXT_COMMANDS: {sectionMarker: Commands.EDIT_CUT},\n        EDIT_SELECTION_COMMANDS: {sectionMarker: Commands.EDIT_SELECT_ALL},\n        EDIT_MODIFY_SELECTION: {sectionMarker: Commands.EDIT_INDENT},\n        EDIT_COMMENT_SELECTION: {sectionMarker: Commands.EDIT_LINE_COMMENT},\n        EDIT_CODE_HINTS_COMMANDS: {sectionMarker: Commands.SHOW_CODE_HINTS},\n        EDIT_TOGGLE_OPTIONS: {sectionMarker: Commands.TOGGLE_CLOSE_BRACKETS},\n\n        FIND_FIND_COMMANDS: {sectionMarker: Commands.CMD_FIND},\n        FIND_FIND_IN_COMMANDS: {sectionMarker: Commands.CMD_FIND_IN_FILES},\n        FIND_REPLACE_COMMANDS: {sectionMarker: Commands.CMD_REPLACE},\n\n        VIEW_HIDESHOW_COMMANDS: {sectionMarker: Commands.VIEW_HIDE_SIDEBAR},\n        VIEW_FONTSIZE_COMMANDS: {sectionMarker: Commands.VIEW_INCREASE_FONT_SIZE},\n        VIEW_TOGGLE_OPTIONS: {sectionMarker: Commands.TOGGLE_ACTIVE_LINE},\n\n        NAVIGATE_GOTO_COMMANDS: {sectionMarker: Commands.NAVIGATE_QUICK_OPEN},\n        NAVIGATE_DOCUMENTS_COMMANDS: {sectionMarker: Commands.NAVIGATE_NEXT_DOC},\n        NAVIGATE_OS_COMMANDS: {sectionMarker: Commands.NAVIGATE_SHOW_IN_FILE_TREE},\n        NAVIGATE_QUICK_EDIT_COMMANDS: {sectionMarker: Commands.TOGGLE_QUICK_EDIT},\n        NAVIGATE_QUICK_DOCS_COMMANDS: {sectionMarker: Commands.TOGGLE_QUICK_DOCS}\n    };\n\n\n    /**\n     * Insertion position constants\n     * Used by addMenu(), addMenuItem(), and addSubMenu() to\n     * specify the relative position of a newly created menu object\n     * @enum {string}\n     */\n    let BEFORE           = \"before\",\n        AFTER            = \"after\",\n        FIRST            = \"first\",\n        LAST             = \"last\",\n        FIRST_IN_SECTION = \"firstInSection\",\n        LAST_IN_SECTION  = \"lastInSection\";\n\n    /**\n     * Other constants\n     */\n    let DIVIDER = \"---\";\n    let SUBMENU = \"SUBMENU\";\n\n    /**\n     * Error Codes from Brackets Shell\n     * @enum {number}\n     */\n    let NO_ERROR           = 0,\n        ERR_UNKNOWN        = 1,\n        ERR_INVALID_PARAMS = 2,\n        ERR_NOT_FOUND      = 3;\n\n    /**\n     * Maps menuID's to Menu objects\n     * @type {Object.<string, Menu>}\n     */\n    let menuMap = {};\n\n    /**\n     * Maps contextMenuID's to ContextMenu objects\n     * @type {Object.<string, ContextMenu>}\n     */\n    let contextMenuMap = {};\n\n    /**\n     * Maps menuItemID's to MenuItem objects\n     * @type {Object.<string, MenuItem>}\n     */\n    let menuItemMap = {};\n\n    /**\n     * Retrieves the Menu object for the corresponding id.\n     * @param {string} id\n     * @return {Menu}\n     */\n    function getMenu(id) {\n        return menuMap[id];\n    }\n\n    /**\n     * Retrieves the map of all Menu objects.\n     * @return {Object.<string, Menu>}\n     */\n    function getAllMenus() {\n        return menuMap;\n    }\n\n    /**\n     * Retrieves the ContextMenu object for the corresponding id.\n     * @param {string} id\n     * @return {ContextMenu}\n     */\n    function getContextMenu(id) {\n        return contextMenuMap[id];\n    }\n\n    /**\n    * Removes the attached event listeners from the corresponding object.\n    * @param {ManuItem} menuItem\n    */\n    function removeMenuItemEventListeners(menuItem) {\n        menuItem._command\n            .off(\"enabledStateChange\", menuItem._enabledChanged)\n            .off(\"checkedStateChange\", menuItem._checkedChanged)\n            .off(\"nameChange\", menuItem._nameChanged)\n            .off(\"keyBindingAdded\", menuItem._keyBindingAdded)\n            .off(\"keyBindingRemoved\", menuItem._keyBindingRemoved);\n    }\n\n    /**\n     * Retrieves the MenuItem object for the corresponding id.\n     * @param {string} id\n     * @return {MenuItem}\n     */\n    function getMenuItem(id) {\n        return menuItemMap[id];\n    }\n\n    function _getHTMLMenu(id) {\n        return $(\"#\" + StringUtils.jQueryIdEscape(id)).get(0);\n    }\n\n    function _getHTMLMenuItem(id) {\n        return $(\"#\" + StringUtils.jQueryIdEscape(id)).get(0);\n    }\n\n    function _addKeyBindingToMenuItem($menuItem, key, displayKey) {\n        let $shortcut = $menuItem.find(\".menu-shortcut\");\n\n        if ($shortcut.length === 0) {\n            $shortcut = $(\"<span class='menu-shortcut' />\");\n            $menuItem.append($shortcut);\n        }\n\n        $shortcut.data(\"key\", key);\n        $shortcut.text(KeyBindingManager.formatKeyDescriptor(displayKey));\n    }\n\n    function _addExistingKeyBinding(menuItem) {\n        let bindings = KeyBindingManager.getKeyBindings(menuItem.getCommand().getID()),\n            binding = null;\n\n        if (bindings.length > 0) {\n            // add the latest key binding\n            binding = bindings[bindings.length - 1];\n            _addKeyBindingToMenuItem($(_getHTMLMenuItem(menuItem.id)), binding.key, binding.displayKey);\n        }\n\n        return binding;\n    }\n\n    let _menuDividerIDCount = 1;\n    function _getNextMenuItemDividerID() {\n        return \"brackets-menuDivider-\" + _menuDividerIDCount++;\n    }\n\n    // Help function for inserting elements into a list\n    function _insertInList($list, $element, position, $relativeElement) {\n        // Determine where to insert. Default is LAST.\n        let inserted = false;\n        if (position) {\n\n            // Adjust relative position for menu section positions since $relativeElement\n            // has already been resolved by _getRelativeMenuItem() to a menuItem\n            if (position === FIRST_IN_SECTION) {\n                position = BEFORE;\n            } else if (position === LAST_IN_SECTION) {\n                position = AFTER;\n            }\n\n            if (position === FIRST) {\n                $list.prepend($element);\n                inserted = true;\n            } else if ($relativeElement && $relativeElement.length > 0) {\n                if (position === AFTER) {\n                    $relativeElement.after($element);\n                    inserted = true;\n                } else if (position === BEFORE) {\n                    $relativeElement.before($element);\n                    inserted = true;\n                }\n            }\n        }\n\n        // Default to LAST\n        if (!inserted) {\n            $list.append($element);\n        }\n    }\n\n    /**\n     * MenuItem represents a single menu item that executes a Command or a menu divider. MenuItems\n     * may have a sub-menu. A MenuItem may correspond to an HTML-based\n     * menu item or a native menu item if Brackets is running in a native application shell\n     *\n     * Since MenuItems may have a native implementation clients should create MenuItems through\n     * addMenuItem() and should NOT construct a MenuItem object directly.\n     * Clients should also not access HTML content of a menu directly and instead use\n     * the MenuItem API to query and modify menus items.\n     *\n     * MenuItems are views on to Command objects so modify the underlying Command to modify the\n     * name, enabled, and checked state of a MenuItem. The MenuItem will update automatically\n     *\n     * @constructor\n     * @private\n     *\n     * @param {string} id\n     * @param {string|Command} command - the Command this MenuItem will reflect.\n     *                                   Use DIVIDER to specify a menu divider\n     */\n    function MenuItem(id, command) {\n        this.id = id;\n        this.isDivider = (command === DIVIDER);\n        this.isNative = false;\n\n        if (!this.isDivider && command !== SUBMENU) {\n            // Bind event handlers\n            this._enabledChanged = this._enabledChanged.bind(this);\n            this._checkedChanged = this._checkedChanged.bind(this);\n            this._nameChanged = this._nameChanged.bind(this);\n            this._keyBindingAdded = this._keyBindingAdded.bind(this);\n            this._keyBindingRemoved = this._keyBindingRemoved.bind(this);\n\n            this._command = command;\n            this._command\n                .on(\"enabledStateChange\", this._enabledChanged)\n                .on(\"checkedStateChange\", this._checkedChanged)\n                .on(\"nameChange\", this._nameChanged)\n                .on(\"keyBindingAdded\", this._keyBindingAdded)\n                .on(\"keyBindingRemoved\", this._keyBindingRemoved);\n        }\n    }\n\n    /**\n     * Menu represents a top-level menu in the menu bar. A Menu may correspond to an HTML-based\n     * menu or a native menu if Brackets is running in a native application shell.\n     *\n     * Since menus may have a native implementation clients should create Menus through\n     * addMenu() and should NOT construct a Menu object directly.\n     * Clients should also not access HTML content of a menu directly and instead use\n     * the Menu API to query and modify menus.\n     *\n     * @constructor\n     * @private\n     *\n     * @param {string} id\n     */\n    function Menu(id) {\n        this.id = id;\n    }\n\n    Menu.prototype._getMenuItemId = function (commandId) {\n        return (this.id + \"-\" + commandId);\n    };\n\n    /**\n     * Determine MenuItem in this Menu, that has the specified command\n     *\n     * @param {Command} command - the command to search for.\n     * @return {?HTMLLIElement} menu item list element\n     */\n    Menu.prototype._getMenuItemForCommand = function (command) {\n        if (!command) {\n            return null;\n        }\n        let foundMenuItem = menuItemMap[this._getMenuItemId(command.getID())];\n        if (!foundMenuItem) {\n            return null;\n        }\n        return $(_getHTMLMenuItem(foundMenuItem.id)).closest(\"li\");\n    };\n\n    /**\n     * Determine relative MenuItem\n     *\n     * @param {?string} relativeID - id of command (future: sub-menu).\n     * @param {?string} position - only needed when relativeID is a MenuSection\n     * @return {?HTMLLIElement} menu item list element\n     */\n    Menu.prototype._getRelativeMenuItem = function (relativeID, position) {\n        let $relativeElement;\n\n        if (relativeID) {\n            if (position === FIRST_IN_SECTION || position === LAST_IN_SECTION) {\n                if (!relativeID.hasOwnProperty(\"sectionMarker\")) {\n                    console.error(\"Bad Parameter in _getRelativeMenuItem(): relativeID must be a MenuSection when position refers to a menu section\");\n                    return null;\n                }\n\n                // Determine the $relativeElement by traversing the sibling list and\n                // stop at the first divider found\n                // TODO: simplify using nextUntil()/prevUntil()\n                let $sectionMarker = this._getMenuItemForCommand(CommandManager.get(relativeID.sectionMarker));\n                if (!$sectionMarker) {\n                    console.error(\"_getRelativeMenuItem(): MenuSection \" + relativeID.sectionMarker +\n                                  \" not found in Menu \" + this.id);\n                    return null;\n                }\n                let $listElem = $sectionMarker;\n                $relativeElement = $listElem;\n                while (true) {\n                    $listElem = (position === FIRST_IN_SECTION ? $listElem.prev() : $listElem.next());\n                    if ($listElem.length === 0) {\n                        break;\n                    } else if ($listElem.find(\".divider\").length > 0) {\n                        break;\n                    } else {\n                        $relativeElement = $listElem;\n                    }\n                }\n\n            } else {\n                if (relativeID.hasOwnProperty(\"sectionMarker\")) {\n                    console.error(\"Bad Parameter in _getRelativeMenuItem(): if relativeID is a MenuSection, position must be FIRST_IN_SECTION or LAST_IN_SECTION\");\n                    return null;\n                }\n\n                // handle FIRST, LAST, BEFORE, & AFTER\n                let command = CommandManager.get(relativeID);\n                if (command) {\n                    // Lookup Command for this Command id\n                    // Find MenuItem that has this command\n                    $relativeElement = this._getMenuItemForCommand(command);\n                }\n                if (!$relativeElement) {\n                    console.error(\"_getRelativeMenuItem(): MenuItem with Command id \" + relativeID +\n                                  \" not found in Menu \" + this.id);\n                    return null;\n                }\n            }\n\n            return $relativeElement;\n\n        } else if (position && position !== FIRST && position !== LAST) {\n            console.error(\"Bad Parameter in _getRelativeMenuItem(): relative position specified with no relativeID\");\n            return null;\n        }\n\n        return $relativeElement;\n    };\n\n    /**\n     * Removes the specified menu item from this Menu. Key bindings are unaffected; use KeyBindingManager\n     * directly to remove key bindings if desired.\n     *\n     * @param {!string | Command} command - command the menu would execute if we weren't deleting it.\n     */\n    Menu.prototype.removeMenuItem = function (command) {\n        let menuItemID,\n            commandID;\n\n        if (!command) {\n            console.error(\"removeMenuItem(): missing required parameters: command\");\n            return;\n        }\n\n        if (typeof (command) === \"string\") {\n            let commandObj = CommandManager.get(command);\n            if (!commandObj) {\n                console.error(\"removeMenuItem(): command not found: \" + command);\n                return;\n            }\n            commandID = command;\n        } else {\n            commandID = command.getID();\n        }\n        menuItemID = this._getMenuItemId(commandID);\n\n        let menuItem = getMenuItem(menuItemID);\n        removeMenuItemEventListeners(menuItem);\n\n        $(_getHTMLMenuItem(menuItemID)).parent().remove();\n\n        delete menuItemMap[menuItemID];\n    };\n\n    /**\n     * Removes the specified menu divider from this Menu.\n     *\n     * @param {!string} menuItemID - the menu item id of the divider to remove.\n     */\n    Menu.prototype.removeMenuDivider = function (menuItemID) {\n        let menuItem,\n            $HTMLMenuItem;\n\n        if (!menuItemID) {\n            console.error(\"removeMenuDivider(): missing required parameters: menuItemID\");\n            return;\n        }\n\n        menuItem = getMenuItem(menuItemID);\n\n        if (!menuItem) {\n            console.error(\"removeMenuDivider(): parameter menuItemID: %s is not a valid menu item id\", menuItemID);\n            return;\n        }\n\n        if (!menuItem.isDivider) {\n            console.error(\"removeMenuDivider(): parameter menuItemID: %s is not a menu divider\", menuItemID);\n            return;\n        }\n\n        // Targeting parent to get the menu divider <hr> and the <li> that contains it\n        $HTMLMenuItem = $(_getHTMLMenuItem(menuItemID)).parent();\n        if ($HTMLMenuItem) {\n            $HTMLMenuItem.remove();\n        } else {\n            console.error(\"removeMenuDivider(): HTML menu divider not found: %s\", menuItemID);\n            return;\n        }\n\n        if (!menuItemMap[menuItemID]) {\n            console.error(\"removeMenuDivider(): menu divider not found in menuItemMap: %s\", menuItemID);\n            return;\n        }\n\n        delete menuItemMap[menuItemID];\n    };\n\n    /**\n     * Adds a new menu item with the specified id and display text. The insertion position is\n     * specified via the relativeID and position arguments which describe a position\n     * relative to another MenuItem or MenuGroup. It is preferred that plug-ins\n     * insert new  MenuItems relative to a menu section rather than a specific\n     * MenuItem (see Menu Section Constants).\n     *\n     * TODO: Sub-menus are not yet supported, but when they are implemented this API will\n     * allow adding new MenuItems to sub-menus as well.\n     *\n     * Note, keyBindings are bound to Command objects not MenuItems. The provided keyBindings\n     *      will be bound to the supplied Command object rather than the MenuItem.\n     *\n     * @param {!string | Command} command - the command the menu will execute.\n     *      Pass Menus.DIVIDER for a menu divider, or just call addMenuDivider() instead.\n     * @param {?string | Array.<{key: string, platform: string}>}  keyBindings - register one\n     *      one or more key bindings to associate with the supplied command.\n     * @param {?string} [position] - constant defining the position of new MenuItem relative to\n     *      other MenuItems. Values:\n     *          - With no relativeID, use Menus.FIRST or LAST (default is LAST)\n     *          - Relative to a command id, use BEFORE or AFTER (required)\n     *          - Relative to a MenuSection, use FIRST_IN_SECTION or LAST_IN_SECTION (required)\n     * @param {?string} [relativeID] - command id OR one of the MenuSection.* constants. Required\n     *      for all position constants except FIRST and LAST.\n     *\n     * @return {MenuItem} the newly created MenuItem\n     */\n    Menu.prototype.addMenuItem = function (command, keyBindings, position, relativeID) {\n        let id,\n            $menuItem,\n            menuItem,\n            name,\n            commandID;\n\n        if (!command) {\n            console.error(\"addMenuItem(): missing required parameters: command\");\n            return null;\n        }\n\n        if (typeof (command) === \"string\") {\n            if (command === DIVIDER) {\n                name = DIVIDER;\n                commandID = _getNextMenuItemDividerID();\n            } else {\n                commandID = command;\n                command = CommandManager.get(commandID);\n                if (!command) {\n                    console.error(\"addMenuItem(): commandID not found: \" + commandID);\n                    return null;\n                }\n                name = command.getName();\n            }\n        } else {\n            commandID = command.getID();\n            name = command.getName();\n        }\n\n        // Internal id is the a composite of the parent menu id and the command id.\n        id = this._getMenuItemId(commandID);\n\n        if (menuItemMap[id]) {\n            console.log(\"MenuItem added with same id of existing MenuItem: \" + id);\n            return null;\n        }\n\n        // create MenuItem\n        menuItem = new MenuItem(id, command);\n        menuItemMap[id] = menuItem;\n\n\n        if (name === DIVIDER) {\n            $menuItem = $(\"<li><hr class='divider' id='\" + id + \"' /></li>\");\n        } else {\n            // Create the HTML Menu\n            $menuItem = $(\"<li><a href='#' id='\" + id + \"'> <span class='menu-name'></span></a></li>\");\n\n            $menuItem.on(\"click\", function () {\n                Metrics.countEvent(Metrics.EVENT_TYPE.UI_MENU, \"click\", menuItem._command.getID());\n                menuItem._command.execute();\n            });\n\n            let self = this;\n            $menuItem.on(\"mouseenter\", function () {\n                self.closeSubMenu();\n            });\n        }\n\n        // Insert menu item\n        let $relativeElement = this._getRelativeMenuItem(relativeID, position);\n        _insertInList($(\"li#\" + StringUtils.jQueryIdEscape(this.id) + \" > ul.dropdown-menu\"),\n                      $menuItem, position, $relativeElement);\n\n\n        // Initialize MenuItem state\n        if (menuItem.isDivider) {\n            menuItem.dividerId = commandID;\n        } else {\n            if (keyBindings) {\n                // Add key bindings. The MenuItem listens to the Command object to update MenuItem DOM with shortcuts.\n                if (!Array.isArray(keyBindings)) {\n                    keyBindings = [keyBindings];\n                }\n            }\n\n            // Note that keyBindings passed during MenuItem creation take precedent over any existing key bindings\n            KeyBindingManager.addBinding(commandID, keyBindings);\n\n            // Look for existing key bindings\n            _addExistingKeyBinding(menuItem);\n\n            menuItem._checkedChanged();\n            menuItem._enabledChanged();\n            menuItem._nameChanged();\n        }\n\n        return menuItem;\n    };\n\n    /**\n     * Inserts divider item in menu.\n     * @param {?string} position - constant defining the position of new the divider relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants).\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      divider will be positioned relative to. Required for all position constants\n     *      except FIRST and LAST\n     *\n     * @return {MenuItem} the newly created divider\n     */\n    Menu.prototype.addMenuDivider = function (position, relativeID) {\n        return this.addMenuItem(DIVIDER, \"\", position, relativeID);\n    };\n\n    /**\n     * NOT IMPLEMENTED\n     * Alternative JSON based API to addMenuItem()\n     *\n     * All properties are required unless noted as optional.\n     *\n     * @param { Array.<{\n     *              id:         string,\n     *              command:    string | Command,\n     *              ?bindings:   string | Array.<{key: string, platform: string}>,\n     *          }>} jsonStr\n     *        }\n     * @param {?string} position - constant defining the position of new the MenuItem relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants).\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      menuItem will be positioned relative to. Required when position is\n     *      AFTER or BEFORE, ignored when position is FIRST or LAST.\n     *\n     * @return {MenuItem} the newly created MenuItem\n     */\n    // Menu.prototype.createMenuItemsFromJSON = function (jsonStr, position, relativeID) {\n    //     NOT IMPLEMENTED\n    // };\n\n\n    /**\n     * NOT IMPLEMENTED\n     * @param {!string} text displayed in menu item\n     * @param {!string} id\n     * @param {?string} position - constant defining the position of new the MenuItem relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants)\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      menuItem will be positioned relative to. Required when position is\n     *      AFTER or BEFORE, ignored when position is FIRST or LAST.\n     *\n     * @return {MenuItem} newly created menuItem for sub-menu\n     */\n    // MenuItem.prototype.createSubMenu = function (text, id, position, relativeID) {\n    //     NOT IMPLEMENTED\n    // };\n\n    /**\n     *\n     * Creates a new submenu and a menuItem and adds the menuItem of the submenu\n     * to the menu and returns the submenu.\n     *\n     * A submenu will have the same structure of a menu with a additional field\n     * parentMenuItem which has the reference of the submenu's parent menuItem.\n\n     * A submenu will raise the following events:\n     * - beforeSubMenuOpen\n     * - beforeSubMenuClose\n     *\n     * Note, This function will create only a context submenu.\n     *\n     * TODO: Make this function work for Menus\n     *\n     *\n     * @param {!string} name displayed in menu item of the submenu\n     * @param {!string} id\n     * @param {?string} position - constant defining the position of new MenuItem of the submenu relative to\n     *      other MenuItems. Values:\n     *          - With no relativeID, use Menus.FIRST or LAST (default is LAST)\n     *          - Relative to a command id, use BEFORE or AFTER (required)\n     *          - Relative to a MenuSection, use FIRST_IN_SECTION or LAST_IN_SECTION (required)\n     * @param {?string} relativeID - command id OR one of the MenuSection.* constants. Required\n     *      for all position constants except FIRST and LAST.\n     *\n     * @return {Menu} the newly created submenu\n     */\n    Menu.prototype.addSubMenu = function (name, id, position, relativeID) {\n\n        if (!name || !id) {\n            console.error(\"addSubMenu(): missing required parameters: name and id\");\n            return null;\n        }\n\n        // Guard against duplicate context menu ids\n        if (contextMenuMap[id]) {\n            console.log(\"Context menu added with id of existing Context Menu: \" + id);\n            return null;\n        }\n\n        let menu = new ContextMenu(id);\n        contextMenuMap[id] = menu;\n\n        let menuItemID = this.id + \"-\" + id;\n\n        if (menuItemMap[menuItemID]) {\n            console.log(\"MenuItem added with same id of existing MenuItem: \" + id);\n            return null;\n        }\n\n        // create MenuItem\n        let menuItem = new MenuItem(menuItemID, SUBMENU);\n        menuItemMap[menuItemID] = menuItem;\n\n        menu.parentMenuItem = menuItem;\n\n        // create MenuItem DOM\n        // Create the HTML MenuItem\n        let $menuItem = $(\"<li><a href='#' id='\" + menuItemID + \"'> \"   +\n                         \"<span class='menu-name'>\" + name + \"</span>\" +\n                         \"<span style='float: right'>&rtrif;</span>\"   +\n                         \"</a></li>\");\n\n        let self = this;\n        $menuItem.on(\"mouseenter\", function(e) {\n            if (self.openSubMenu && self.openSubMenu.id === menu.id) {\n                return;\n            }\n            self.closeSubMenu();\n            self.openSubMenu = menu;\n            menu.open();\n        });\n\n        // Insert menu item\n        let $relativeElement = this._getRelativeMenuItem(relativeID, position);\n        _insertInList($(\"li#\" + StringUtils.jQueryIdEscape(this.id) + \" > ul.dropdown-menu\"),\n        $menuItem, position, $relativeElement);\n\n        return menu;\n    };\n\n\n    /**\n     * Removes the specified submenu from this Menu.\n     *\n     * Note, this function will only remove context submenus\n     *\n     * TODO: Make this function work for Menus\n     *\n     * @param {!string} subMenuID - the menu id of the submenu to remove.\n     */\n    Menu.prototype.removeSubMenu = function (subMenuID) {\n        let subMenu,\n            parentMenuItem,\n            commandID = \"\";\n\n        if (!subMenuID) {\n            console.error(\"removeSubMenu(): missing required parameters: subMenuID\");\n            return;\n        }\n\n        subMenu = getContextMenu(subMenuID);\n\n        if (!subMenu || !subMenu.parentMenuItem) {\n            console.error(\"removeSubMenu(): parameter subMenuID: %s is not a valid submenu id\", subMenuID);\n            return;\n        }\n\n        parentMenuItem = subMenu.parentMenuItem;\n\n\n        if (!menuItemMap[parentMenuItem.id]) {\n            console.error(\"removeSubMenu(): parent menuItem not found in menuItemMap: %s\", parentMenuItem.id);\n            return;\n        }\n\n        // Remove all of the menu items in the submenu\n        _.forEach(menuItemMap, function (value, key) {\n            if (_.startsWith(key, subMenuID)) {\n                if (value.isDivider) {\n                    subMenu.removeMenuDivider(key);\n                } else {\n                    commandID = value.getCommand();\n                    subMenu.removeMenuItem(commandID);\n                }\n            }\n        });\n\n        $(_getHTMLMenuItem(parentMenuItem.id)).parent().remove(); // remove the menu item\n        $(_getHTMLMenu(subMenuID)).remove(); // remove the menu\n\n\n        delete menuItemMap[parentMenuItem.id];\n        delete contextMenuMap[subMenuID];\n    };\n\n    /**\n     * Closes the submenu if the menu has a submenu open.\n     */\n    Menu.prototype.closeSubMenu = function() {\n        if (this.openSubMenu) {\n            this.openSubMenu.close();\n            this.openSubMenu = null;\n        }\n    };\n    /**\n     * Gets the Command associated with a MenuItem\n     * @return {Command}\n     */\n    MenuItem.prototype.getCommand = function () {\n        return this._command;\n    };\n\n    /**\n     * NOT IMPLEMENTED\n     * Returns the parent MenuItem if the menu item is a sub-menu, returns null otherwise.\n     * @return {MenuItem}\n     */\n    // MenuItem.prototype.getParentMenuItem = function () {\n    //     NOT IMPLEMENTED;\n    // };\n\n    /**\n     * Returns the parent Menu for this MenuItem\n     * @return {Menu}\n     */\n    MenuItem.prototype.getParentMenu = function () {\n        let parent = $(_getHTMLMenuItem(this.id)).parents(\".dropdown\").get(0);\n        if (!parent) {\n            return null;\n        }\n\n        return getMenu(parent.id);\n    };\n\n    /**\n     * Synchronizes MenuItem checked state with underlying Command checked state\n     */\n    MenuItem.prototype._checkedChanged = function () {\n        let checked = !!this._command.getChecked();\n        if (this.isNative) {\n            let enabled = !!this._command.getEnabled();\n            brackets.app.setMenuItemState(this._command.getID(), enabled, checked, function (err) {\n                if (err) {\n                    console.log(\"Error setting menu item state: \" + err);\n                }\n            });\n        } else {\n            ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), \"checked\", checked);\n        }\n    };\n\n    /**\n     * Synchronizes MenuItem enabled state with underlying Command enabled state\n     */\n    MenuItem.prototype._enabledChanged = function () {\n        if (this.isNative) {\n            let enabled = !!this._command.getEnabled();\n            let checked = !!this._command.getChecked();\n            brackets.app.setMenuItemState(this._command.getID(), enabled, checked, function (err) {\n                if (err) {\n                    console.log(\"Error setting menu item state: \" + err);\n                }\n            });\n        } else {\n            ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), \"disabled\", !this._command.getEnabled());\n        }\n    };\n\n    /**\n     * Synchronizes MenuItem name with underlying Command name\n     */\n    MenuItem.prototype._nameChanged = function () {\n        if (this.isNative) {\n            brackets.app.setMenuTitle(this._command.getID(), this._command.getName(), function (err) {\n                if (err) {\n                    console.log(\"Error setting menu title: \" + err);\n                }\n            });\n        } else {\n            $(_getHTMLMenuItem(this.id)).find(\".menu-name\").text(this._command.getName());\n        }\n    };\n\n    /**\n     * @private\n     * Updates MenuItem DOM with a keyboard shortcut label\n     */\n    MenuItem.prototype._keyBindingAdded = function (event, keyBinding) {\n        if (this.isNative) {\n            let shortcutKey = keyBinding.displayKey || keyBinding.key;\n            brackets.app.setMenuItemShortcut(this._command.getID(), shortcutKey, KeyBindingManager.formatKeyDescriptor(shortcutKey), function (err) {\n                if (err) {\n                    console.error(\"Error setting menu item shortcut key \" + shortcutKey + \" : \" + err );\n                }\n            });\n        } else {\n            _addKeyBindingToMenuItem($(_getHTMLMenuItem(this.id)), keyBinding.key, keyBinding.displayKey);\n        }\n    };\n\n    /**\n     * @private\n     * Updates MenuItem DOM to remove keyboard shortcut label\n     */\n    MenuItem.prototype._keyBindingRemoved = function (event, keyBinding) {\n        if (this.isNative) {\n            brackets.app.setMenuItemShortcut(this._command.getID(), \"\", \"\", function (err) {\n                if (err) {\n                    console.error(\"Error setting menu item shortcut: \" + err);\n                }\n            });\n        } else {\n            let $shortcut = $(_getHTMLMenuItem(this.id)).find(\".menu-shortcut\");\n\n            if ($shortcut.length > 0 && $shortcut.data(\"key\") === keyBinding.key) {\n                // check for any other bindings\n                if (_addExistingKeyBinding(this) === null) {\n                    $shortcut.empty();\n                }\n            }\n        }\n    };\n\n    /**\n     * Closes all menus that are open\n     */\n    function closeAll() {\n        $(\".dropdown\").removeClass(\"open\");\n    }\n\n    /**\n     * Adds a top-level menu to the application menu bar which may be native or HTML-based.\n     *\n     * @param {!string} name - display text for menu\n     * @param {!string} id - unique identifier for a menu.\n     *      Core Menus in Brackets use a simple  title as an id, for example \"file-menu\".\n     *      Extensions should use the following format: \"author.myextension.mymenuname\".\n     * @param {?string} position - constant defining the position of new the Menu relative\n     *  to other Menus. Default is LAST (see Insertion position constants).\n     *\n     * @param {?string} relativeID - id of Menu the new Menu will be positioned relative to. Required\n     *      when position is AFTER or BEFORE, ignored when position is FIRST or LAST\n     *\n     * @return {?Menu} the newly created Menu\n     */\n    function addMenu(name, id, position, relativeID) {\n        name = _.escape(name);\n        let $menubar = $(\"#titlebar .nav\"),\n            menu;\n\n        if (!name || !id) {\n            console.error(\"call to addMenu() is missing required parameters\");\n            return null;\n        }\n\n        // Guard against duplicate menu ids\n        if (menuMap[id]) {\n            console.log(\"Menu added with same name and id of existing Menu: \" + id);\n            return null;\n        }\n\n        menu = new Menu(id);\n        menuMap[id] = menu;\n\n\n        let $toggle = $(\"<a href='#' class='dropdown-toggle' data-toggle='dropdown'>\" + name + \"</a>\"),\n            $popUp = $(\"<ul class='dropdown-menu'></ul>\"),\n            $newMenu = $(\"<li class='dropdown' id='\" + id + \"'></li>\").append($toggle).append($popUp);\n\n        // Insert menu\n        let $relativeElement = relativeID && $(_getHTMLMenu(relativeID));\n        _insertInList($menubar, $newMenu, position, $relativeElement);\n\n        // Install ESC key handling\n        PopUpManager.addPopUp($popUp, closeAll, false);\n\n        // todo error handling\n\n        return menu;\n    }\n\n    /**\n     * Removes a top-level menu from the application menu bar which may be native or HTML-based.\n     *\n     * @param {!string} id - unique identifier for a menu.\n     *      Core Menus in Brackets use a simple title as an id, for example \"file-menu\".\n     *      Extensions should use the following format: \"author.myextension.mymenuname\".\n     */\n    function removeMenu(id) {\n        let menu,\n            commandID = \"\";\n\n        if (!id) {\n            console.error(\"removeMenu(): missing required parameter: id\");\n            return;\n        }\n\n        if (!menuMap[id]) {\n            console.error(\"removeMenu(): menu id not found: %s\", id);\n            return;\n        }\n\n        // Remove all of the menu items in the menu\n        menu = getMenu(id);\n\n        _.forEach(menuItemMap, function (value, key) {\n            if (_.startsWith(key, id)) {\n                if (value.isDivider) {\n                    menu.removeMenuDivider(key);\n                } else {\n                    commandID = value.getCommand();\n                    menu.removeMenuItem(commandID);\n                }\n            }\n        });\n\n        $(_getHTMLMenu(id)).remove();\n\n        delete menuMap[id];\n    }\n\n    /**\n     * Represents a context menu that can open at a specific location in the UI.\n     *\n     * Clients should not create this object directly and should instead use registerContextMenu()\n     * to create new ContextMenu objects.\n     *\n     * Context menus in brackets may be HTML-based or native so clients should not reach into\n     * the HTML and should instead manipulate ContextMenus through the API.\n     *\n     * Events:\n     * - beforeContextMenuOpen\n     * - beforeContextMenuClose\n     *\n     * @constructor\n     * @extends {Menu}\n     */\n    function ContextMenu(id) {\n        Menu.apply(this, arguments);\n\n        let $newMenu = $(\"<li class='dropdown context-menu' id='\" + StringUtils.jQueryIdEscape(id) + \"'></li>\"),\n            $popUp = $(\"<ul class='dropdown-menu'></ul>\"),\n            $toggle = $(\"<a href='#' class='dropdown-toggle' data-toggle='dropdown'></a>\").hide();\n\n        // assemble the menu fragments\n        $newMenu.append($toggle).append($popUp);\n\n        // insert into DOM\n        $(\"#context-menu-bar > ul\").append($newMenu);\n\n        let self = this;\n        PopUpManager.addPopUp($popUp,\n            function () {\n                self.close();\n            },\n            false);\n\n        // Listen to ContextMenu's beforeContextMenuOpen event to first close other popups\n        PopUpManager.listenToContextMenu(this);\n    }\n    ContextMenu.prototype = Object.create(Menu.prototype);\n    ContextMenu.prototype.constructor = ContextMenu;\n    ContextMenu.prototype.parentClass = Menu.prototype;\n    EventDispatcher.makeEventDispatcher(ContextMenu.prototype);\n\n\n    /**\n     * Displays the ContextMenu at the specified location and dispatches the\n     * \"beforeContextMenuOpen\" event or \"beforeSubMenuOpen\" event (for submenus).\n     * The menu location may be adjusted to prevent clipping by the browser window.\n     * All other menus and ContextMenus will be closed before a new menu\n     * will be closed before a new menu is shown (if the new menu is not\n     * a submenu).\n     *\n     * In case of submenus, the parentMenu of the submenu will not be closed when the\n     * sub menu is open.\n     *\n     * @param {MouseEvent | {pageX:number, pageY:number}} mouseOrLocation - pass a MouseEvent\n     *      to display the menu near the mouse or pass in an object with page x/y coordinates\n     *      for a specific location.This paramter is not used for submenus. Submenus are always\n     *      displayed at a position relative to the parent menu.\n     */\n    ContextMenu.prototype.open = function (mouseOrLocation) {\n        Metrics.countEvent(Metrics.EVENT_TYPE.UI_MENU, \"contextMenuOpen\", this.id);\n        if (!this.parentMenuItem &&\n           (!mouseOrLocation || !mouseOrLocation.hasOwnProperty(\"pageX\") || !mouseOrLocation.hasOwnProperty(\"pageY\"))) {\n            console.error(\"ContextMenu open(): missing required parameter\");\n            return;\n        }\n\n        let $window = $(window),\n            escapedId = StringUtils.jQueryIdEscape(this.id),\n            $menuAnchor = $(\"#\" + escapedId),\n            $menuWindow = $(\"#\" + escapedId + \" > ul\"),\n            posTop,\n            posLeft;\n\n        // only show context menu if it has menu items\n        if ($menuWindow.children().length <= 0) {\n            return;\n        }\n\n\n        // adjust positioning so menu is not clipped off bottom or right\n        if (this.parentMenuItem) { // If context menu is a submenu\n\n            this.trigger(\"beforeSubMenuOpen\");\n\n            let $parentMenuItem = $(_getHTMLMenuItem(this.parentMenuItem.id));\n\n            posTop = $parentMenuItem.offset().top;\n            posLeft = $parentMenuItem.offset().left + $parentMenuItem.outerWidth();\n\n            let elementRect = {\n                    top: posTop,\n                    left: posLeft,\n                    height: $menuWindow.height() + 25,\n                    width: $menuWindow.width()\n                },\n                clip = ViewUtils.getElementClipSize($window, elementRect);\n\n            if (clip.bottom > 0) {\n                posTop = Math.max(0, posTop + $parentMenuItem.height() - $menuWindow.height());\n            }\n\n            posTop -= 30;   // shift top for hidden parent element\n            posLeft += 3;\n\n            if (clip.right > 0) {\n                posLeft = Math.max(0, posLeft - $parentMenuItem.outerWidth() - $menuWindow.outerWidth());\n            }\n        } else {\n            this.trigger(\"beforeContextMenuOpen\");\n\n            // close all other dropdowns\n            closeAll();\n\n            posTop  = mouseOrLocation.pageY;\n            posLeft = mouseOrLocation.pageX;\n\n            let elementRect = {\n                    top: posTop,\n                    left: posLeft,\n                    height: $menuWindow.height() + 25,\n                    width: $menuWindow.width()\n                },\n                clip = ViewUtils.getElementClipSize($window, elementRect);\n\n            if (clip.bottom > 0) {\n                posTop = Math.max(0, posTop - clip.bottom);\n            }\n            posTop -= 30;   // shift top for hidden parent element\n            posLeft += 5;\n\n\n            if (clip.right > 0) {\n                posLeft = Math.max(0, posLeft - clip.right);\n            }\n        }\n\n        // open the context menu at final location\n        $menuAnchor.addClass(\"open\")\n                   .css({\"left\": posLeft, \"top\": posTop});\n    };\n\n\n    /**\n     * Closes the context menu.\n     */\n    ContextMenu.prototype.close = function () {\n        if (this.parentMenuItem) {\n            this.trigger(\"beforeSubMenuClose\");\n        } else {\n            this.trigger(\"beforeContextMenuClose\");\n        }\n        this.closeSubMenu();\n        $(\"#\" + StringUtils.jQueryIdEscape(this.id)).removeClass(\"open\");\n    };\n\n    /**\n     * Detect if current context menu is already open\n     */\n    ContextMenu.prototype.isOpen = function () {\n        return $(\"#\" + StringUtils.jQueryIdEscape(this.id)).hasClass(\"open\");\n    };\n\n\n    /**\n     * Associate a context menu to a DOM element.\n     * This static function take care of registering event handlers for the click event\n     * listener and passing the right \"position\" object to the Context#open method\n     */\n    ContextMenu.assignContextMenuToSelector = function (selector, cmenu) {\n        $(selector).on(\"click\", function (e) {\n            let buttonOffset,\n                buttonHeight;\n\n            e.stopPropagation();\n\n            if (cmenu.isOpen()) {\n                cmenu.close();\n            } else {\n                buttonOffset = $(this).offset();\n                buttonHeight = $(this).outerHeight();\n                cmenu.open({\n                    pageX: buttonOffset.left,\n                    pageY: buttonOffset.top + buttonHeight\n                });\n            }\n        });\n    };\n\n\n    /**\n     * Registers new context menu with Brackets.\n\n     * Extensions should generally use the predefined context menus built into Brackets. Use this\n     * API to add a new context menu to UI that is specific to an extension.\n     *\n     * After registering  a new context menu clients should:\n     *      - use addMenuItem() to add items to the context menu\n     *      - call open() to show the context menu.\n     *      For example:\n     *      $(\"#my_ID\").contextmenu(function (e) {\n     *          if (e.which === 3) {\n     *              my_cmenu.open(e);\n     *          }\n     *      });\n     *\n     * To make menu items be contextual to things like selection, listen for the \"beforeContextMenuOpen\"\n     * to make changes to Command objects before the context menu is shown. MenuItems are views of\n     * Commands, which control a MenuItem's name, enabled state, and checked state.\n     *\n     * @param {string} id - unique identifier for context menu.\n     *      Core context menus in Brackets use a simple title as an id.\n     *      Extensions should use the following format: \"author.myextension.mycontextmenu name\"\n     * @return {?ContextMenu} the newly created context menu\n     */\n    function registerContextMenu(id) {\n        if (!id) {\n            console.error(\"call to registerContextMenu() is missing required parameters\");\n            return null;\n        }\n\n        // Guard against duplicate menu ids\n        if (contextMenuMap[id]) {\n            console.log(\"Context Menu added with same name and id of existing Context Menu: \" + id);\n            return null;\n        }\n\n        let cmenu = new ContextMenu(id);\n        contextMenuMap[id] = cmenu;\n        return cmenu;\n    }\n\n    // Deprecated menu ids\n    DeprecationWarning.deprecateConstant(ContextMenuIds, \"WORKING_SET_MENU\", \"WORKING_SET_CONTEXT_MENU\");\n    DeprecationWarning.deprecateConstant(ContextMenuIds, \"WORKING_SET_SETTINGS_MENU\", \"WORKING_SET_CONFIG_MENU\");\n\n    // Define public API\n    exports.AppMenuBar = AppMenuBar;\n    exports.ContextMenuIds = ContextMenuIds;\n    exports.MenuSection = MenuSection;\n    exports.BEFORE = BEFORE;\n    exports.AFTER = AFTER;\n    exports.LAST = LAST;\n    exports.FIRST = FIRST;\n    exports.FIRST_IN_SECTION = FIRST_IN_SECTION;\n    exports.LAST_IN_SECTION = LAST_IN_SECTION;\n    exports.DIVIDER = DIVIDER;\n    exports.getMenu = getMenu;\n    exports.getAllMenus = getAllMenus;\n    exports.getMenuItem = getMenuItem;\n    exports.getContextMenu = getContextMenu;\n    exports.addMenu = addMenu;\n    exports.removeMenu = removeMenu;\n    exports.registerContextMenu = registerContextMenu;\n    exports.closeAll = closeAll;\n    exports.Menu = Menu;\n    exports.MenuItem = MenuItem;\n    exports.ContextMenu = ContextMenu;\n});\n"],"file":"Menus.js"}
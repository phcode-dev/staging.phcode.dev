{"version":3,"sources":["command/Menus.js"],"names":["define","require","exports","module","_","Commands","EventDispatcher","KeyBindingManager","StringUtils","CommandManager","PopUpManager","ViewUtils","Metrics","MainViewManager","AppInit","DeprecationWarning","KEY","AppMenuBar","FILE_MENU","EDIT_MENU","FIND_MENU","VIEW_MENU","NAVIGATE_MENU","DEBUG_MENU","HELP_MENU","ContextMenuIds","EDITOR_MENU","INLINE_EDITOR_MENU","PROJECT_MENU","WORKING_SET_CONTEXT_MENU","WORKING_SET_CONFIG_MENU","SPLITVIEW_MENU","EVENT_BEFORE_CONTEXT_MENU_OPEN","EVENT_BEFORE_CONTEXT_MENU_CLOSE","EVENT_BEFORE_SUB_MENU_OPEN","EVENT_BEFORE_SUB_MENU_CLOSE","MenuSection","FILE_OPEN_CLOSE_COMMANDS","sectionMarker","FILE_NEW","FILE_SAVE_COMMANDS","FILE_SAVE","FILE_LIVE","FILE_LIVE_FILE_PREVIEW","FILE_SETTINGS","FILE_EXTENSION_MANAGER","EDIT_UNDO_REDO_COMMANDS","EDIT_UNDO","EDIT_TEXT_COMMANDS","EDIT_CUT","EDIT_SELECTION_COMMANDS","EDIT_SELECT_ALL","EDIT_MODIFY_SELECTION","EDIT_INDENT","EDIT_COMMENT_SELECTION","EDIT_LINE_COMMENT","EDIT_CODE_HINTS_COMMANDS","SHOW_CODE_HINTS","EDIT_TOGGLE_OPTIONS","TOGGLE_CLOSE_BRACKETS","FIND_FIND_COMMANDS","CMD_FIND","FIND_FIND_IN_COMMANDS","CMD_FIND_IN_FILES","FIND_REPLACE_COMMANDS","CMD_REPLACE","VIEW_HIDESHOW_COMMANDS","VIEW_HIDE_SIDEBAR","VIEW_FONTSIZE_COMMANDS","VIEW_ZOOM_SUBMENU","VIEW_TOGGLE_OPTIONS","TOGGLE_ACTIVE_LINE","NAVIGATE_GOTO_COMMANDS","NAVIGATE_QUICK_OPEN","NAVIGATE_DOCUMENTS_COMMANDS","NAVIGATE_NEXT_DOC","NAVIGATE_OS_COMMANDS","NAVIGATE_SHOW_IN_FILE_TREE","NAVIGATE_QUICK_EDIT_COMMANDS","TOGGLE_QUICK_EDIT","NAVIGATE_QUICK_DOCS_COMMANDS","TOGGLE_QUICK_DOCS","BEFORE","AFTER","FIRST","LAST","FIRST_IN_SECTION","LAST_IN_SECTION","DIVIDER","SUBMENU","menuMap","contextMenuMap","menuItemMap","subMenuItemMap","getMenu","id","getAllMenus","getContextMenu","removeMenuItemEventListeners","menuItem","_command","off","_enabledChanged","_checkedChanged","_nameChanged","_keyBindingAdded","_keyBindingRemoved","getMenuItem","_getHTMLMenu","$","jQueryIdEscape","get","_getHTMLMenuItem","_addKeyBindingToMenuItem","$menuItem","key","displayKey","$shortcut","find","length","append","data","text","formatKeyDescriptor","_addExistingKeyBinding","bindings","getKeyBindings","getCommand","getID","binding","_menuDividerIDCount","_getNextMenuItemDividerID","_insertInList","$list","$element","position","$relativeElement","inserted","prepend","after","before","MenuItem","command","options","this","isDivider","isNative","bind","_hideWhenCommandDisabled","hideWhenCommandDisabled","on","Menu","closeAll","removeClass","_closeAllSubMenus","menu","Object","values","closeSubMenu","addMenu","name","relativeID","escape","$menubar","console","error","log","$toggle","$popUp","$dropdown","$newMenu","$this","is","addClass","focus","addPopUp","_switchMenus","$menuDropdownToggle","event","parent","menuID","mainMenu","$dropdownToggles","currentIndex","index","nextIndex","ARROW_LEFT","eq","_switchMenuItems","$dropdownMenu","$selected","first","$next","ARROW_DOWN","$nextLi","closest","next","hasClass","ARROW_UP","$prevLi","prev","last","submenuID","submenu","openSubMenu","open","_execMenuItem","focusActivePane","click","preventDefault","stopPropagation","menuKeyboardNavigationHandler","allowedKeys","ARROW_RIGHT","ESCAPE","ENTER","RETURN","includes","$focusedElement","isDescendantOfTitleBar","SPACE","removeMenu","commandID","forEach","value","startsWith","removeMenuDivider","removeMenuItem","remove","ContextMenu","apply","arguments","hide","self","close","listenToContextMenu","registerContextMenu","cmenu","prototype","_getMenuItemId","commandId","_getMenuItemForCommand","foundMenuItem","_getRelativeMenuItem","hasOwnProperty","$sectionMarker","$listElem","menuItemID","commandObj","$HTMLMenuItem","addMenuItem","keyBindings","getName","$menuAnchor","countEvent","EVENT_TYPE","UI_MENU","logger","leaveTrail","_options","eventSource","execute","SOURCE_UI_MENU_CLICK","sourceType","dividerId","Array","isArray","addBinding","addMenuDivider","addSubMenu","parentMenuItem","e","removeSubMenu","subMenuID","subMenu","getParentMenu","parents","checked","getChecked","enabled","getEnabled","brackets","app","setMenuItemState","err","toggleClass","setMenuTitle","keyBinding","shortcutKey","setMenuItemShortcut","empty","create","constructor","parentClass","makeEventDispatcher","mouseOrLocation","$window","window","escapedId","$menuWindow","posTop","posLeft","children","trigger","$parentMenuItem","elementRect","top","offset","left","outerWidth","height","width","clip","getElementClipSize","bottom","Math","max","right","pageY","pageX","css","isOpen","assignContextMenuToSelector","selector","buttonOffset","buttonHeight","outerHeight","htmlReady","addGlobalKeydownHook","removeGlobalKeydownHook","deprecateConstant"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n/*global logger*/\n\ndefine(function (require, exports, module) {\n\n\n    let _ = require(\"thirdparty/lodash\");\n\n    // Load dependent modules\n    let Commands            = require(\"command/Commands\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        KeyBindingManager   = require(\"command/KeyBindingManager\"),\n        StringUtils         = require(\"utils/StringUtils\"),\n        CommandManager      = require(\"command/CommandManager\"),\n        PopUpManager        = require(\"widgets/PopUpManager\"),\n        ViewUtils           = require(\"utils/ViewUtils\"),\n        Metrics             = require(\"utils/Metrics\"),\n        MainViewManager     = require(\"view/MainViewManager\"),\n        AppInit                 = require(\"utils/AppInit\"),\n        DeprecationWarning  = require(\"utils/DeprecationWarning\");\n\n    // make sure the global brackets letiable is loaded\n    require(\"utils/Global\");\n\n    const KEY = KeyBindingManager.KEY;\n    /**\n     * Brackets Application Menu Constants\n     * @enum {string}\n     */\n    let AppMenuBar = {\n        FILE_MENU: \"file-menu\",\n        EDIT_MENU: \"edit-menu\",\n        FIND_MENU: \"find-menu\",\n        VIEW_MENU: \"view-menu\",\n        NAVIGATE_MENU: \"navigate-menu\",\n        DEBUG_MENU: \"debug-menu\",\n        HELP_MENU: \"help-menu\"\n    };\n\n    /**\n     * Brackets Context Menu Constants\n     * @enum {string}\n     */\n    let ContextMenuIds = {\n        EDITOR_MENU: \"editor-context-menu\",\n        INLINE_EDITOR_MENU: \"inline-editor-context-menu\",\n        PROJECT_MENU: \"project-context-menu\",\n        WORKING_SET_CONTEXT_MENU: \"workingset-context-menu\",\n        WORKING_SET_CONFIG_MENU: \"workingset-configuration-menu\",\n        SPLITVIEW_MENU: \"splitview-menu\"\n    };\n\n    const EVENT_BEFORE_CONTEXT_MENU_OPEN = \"beforeContextMenuOpen\",\n        EVENT_BEFORE_CONTEXT_MENU_CLOSE = \"beforeContextMenuClose\",\n        EVENT_BEFORE_SUB_MENU_OPEN = \"beforeSubMenuOpen\",\n        EVENT_BEFORE_SUB_MENU_CLOSE = \"beforeSubMenuClose\";\n\n    /**\n     * Brackets Application Menu Section Constants\n     * It is preferred that plug-ins specify the location of new MenuItems\n     * in terms of a menu section rather than a specific MenuItem. This provides\n     * looser coupling to Bracket's internal MenuItems and makes menu organization\n     * more semantic.\n     * Use these constants as the \"relativeID\" parameter when calling addMenuItem() and\n     * specify a position of FIRST_IN_SECTION or LAST_IN_SECTION.\n     *\n     * Menu sections are denoted by dividers or the beginning/end of a menu\n     */\n    let MenuSection = {\n        // Menu Section                     Command ID to mark the section\n        FILE_OPEN_CLOSE_COMMANDS: {sectionMarker: Commands.FILE_NEW},\n        FILE_SAVE_COMMANDS: {sectionMarker: Commands.FILE_SAVE},\n        FILE_LIVE: {sectionMarker: Commands.FILE_LIVE_FILE_PREVIEW},\n        FILE_SETTINGS: {sectionMarker: Commands.FILE_EXTENSION_MANAGER},\n        FILE_EXTENSION_MANAGER: {sectionMarker: Commands.FILE_EXTENSION_MANAGER}, // deprecated. here for legacy support\n\n        EDIT_UNDO_REDO_COMMANDS: {sectionMarker: Commands.EDIT_UNDO},\n        EDIT_TEXT_COMMANDS: {sectionMarker: Commands.EDIT_CUT},\n        EDIT_SELECTION_COMMANDS: {sectionMarker: Commands.EDIT_SELECT_ALL},\n        EDIT_MODIFY_SELECTION: {sectionMarker: Commands.EDIT_INDENT},\n        EDIT_COMMENT_SELECTION: {sectionMarker: Commands.EDIT_LINE_COMMENT},\n        EDIT_CODE_HINTS_COMMANDS: {sectionMarker: Commands.SHOW_CODE_HINTS},\n        EDIT_TOGGLE_OPTIONS: {sectionMarker: Commands.TOGGLE_CLOSE_BRACKETS},\n\n        FIND_FIND_COMMANDS: {sectionMarker: Commands.CMD_FIND},\n        FIND_FIND_IN_COMMANDS: {sectionMarker: Commands.CMD_FIND_IN_FILES},\n        FIND_REPLACE_COMMANDS: {sectionMarker: Commands.CMD_REPLACE},\n\n        VIEW_HIDESHOW_COMMANDS: {sectionMarker: Commands.VIEW_HIDE_SIDEBAR},\n        VIEW_FONTSIZE_COMMANDS: {sectionMarker: Commands.VIEW_ZOOM_SUBMENU},\n        VIEW_TOGGLE_OPTIONS: {sectionMarker: Commands.TOGGLE_ACTIVE_LINE},\n\n        NAVIGATE_GOTO_COMMANDS: {sectionMarker: Commands.NAVIGATE_QUICK_OPEN},\n        NAVIGATE_DOCUMENTS_COMMANDS: {sectionMarker: Commands.NAVIGATE_NEXT_DOC},\n        NAVIGATE_OS_COMMANDS: {sectionMarker: Commands.NAVIGATE_SHOW_IN_FILE_TREE},\n        NAVIGATE_QUICK_EDIT_COMMANDS: {sectionMarker: Commands.TOGGLE_QUICK_EDIT},\n        NAVIGATE_QUICK_DOCS_COMMANDS: {sectionMarker: Commands.TOGGLE_QUICK_DOCS}\n    };\n\n\n    /**\n     * Insertion position constants\n     * Used by addMenu(), addMenuItem(), and addSubMenu() to\n     * specify the relative position of a newly created menu object\n     * @enum {string}\n     */\n    let BEFORE           = \"before\",\n        AFTER            = \"after\",\n        FIRST            = \"first\",\n        LAST             = \"last\",\n        FIRST_IN_SECTION = \"firstInSection\",\n        LAST_IN_SECTION  = \"lastInSection\";\n\n    /**\n     * Other constants\n     */\n    let DIVIDER = \"---\";\n    let SUBMENU = \"SUBMENU\";\n\n    /**\n     * Maps menuID's to Menu objects\n     * @type {Object.<string, Menu>}\n     */\n    let menuMap = {};\n\n    /**\n     * Maps contextMenuID's to ContextMenu objects\n     * @type {Object.<string, ContextMenu>}\n     */\n    let contextMenuMap = {};\n\n    /**\n     * Maps menuItemID's to MenuItem objects\n     * @type {Object.<string, MenuItem>}\n     */\n    let menuItemMap = {};\n\n    /**\n     * Maps menuItemID's to ContextMenu objects\n     * @type {Object.<string, ContextMenu>}\n     */\n    let subMenuItemMap = {};\n\n    /**\n     * Retrieves the Menu object for the corresponding id.\n     * @param {string} id\n     * @return {Menu}\n     */\n    function getMenu(id) {\n        return menuMap[id];\n    }\n\n    /**\n     * Retrieves the map of all Menu objects.\n     * @return {Object.<string, Menu>}\n     */\n    function getAllMenus() {\n        return menuMap;\n    }\n\n    /**\n     * Retrieves the ContextMenu object for the corresponding id.\n     * @param {string} id\n     * @return {ContextMenu}\n     */\n    function getContextMenu(id) {\n        return contextMenuMap[id];\n    }\n\n    /**\n    * Removes the attached event listeners from the corresponding object.\n    * @param {ManuItem} menuItem\n    */\n    function removeMenuItemEventListeners(menuItem) {\n        menuItem._command\n            .off(\"enabledStateChange\", menuItem._enabledChanged)\n            .off(\"checkedStateChange\", menuItem._checkedChanged)\n            .off(\"nameChange\", menuItem._nameChanged)\n            .off(\"keyBindingAdded\", menuItem._keyBindingAdded)\n            .off(\"keyBindingRemoved\", menuItem._keyBindingRemoved);\n    }\n\n    /**\n     * Retrieves the MenuItem object for the corresponding id.\n     * @param {string} id\n     * @return {MenuItem}\n     */\n    function getMenuItem(id) {\n        return menuItemMap[id];\n    }\n\n    function _getHTMLMenu(id) {\n        return $(\"#\" + StringUtils.jQueryIdEscape(id)).get(0);\n    }\n\n    function _getHTMLMenuItem(id) {\n        return $(\"#\" + StringUtils.jQueryIdEscape(id)).get(0);\n    }\n\n    function _addKeyBindingToMenuItem($menuItem, key, displayKey) {\n        let $shortcut = $menuItem.find(\".menu-shortcut\");\n\n        if ($shortcut.length === 0) {\n            $shortcut = $(\"<span class='menu-shortcut' />\");\n            $menuItem.append($shortcut);\n        }\n\n        $shortcut.data(\"key\", key);\n        $shortcut.text(KeyBindingManager.formatKeyDescriptor(displayKey));\n    }\n\n    function _addExistingKeyBinding(menuItem) {\n        let bindings = KeyBindingManager.getKeyBindings(menuItem.getCommand().getID()),\n            binding = null;\n\n        if (bindings.length > 0) {\n            // add the latest key binding\n            binding = bindings[bindings.length - 1];\n            _addKeyBindingToMenuItem($(_getHTMLMenuItem(menuItem.id)), binding.key, binding.displayKey);\n        }\n\n        return binding;\n    }\n\n    let _menuDividerIDCount = 1;\n    function _getNextMenuItemDividerID() {\n        return \"brackets-menuDivider-\" + _menuDividerIDCount++;\n    }\n\n    // Help function for inserting elements into a list\n    function _insertInList($list, $element, position, $relativeElement) {\n        // Determine where to insert. Default is LAST.\n        let inserted = false;\n        if (position) {\n\n            // Adjust relative position for menu section positions since $relativeElement\n            // has already been resolved by _getRelativeMenuItem() to a menuItem\n            if (position === FIRST_IN_SECTION) {\n                position = BEFORE;\n            } else if (position === LAST_IN_SECTION) {\n                position = AFTER;\n            }\n\n            if (position === FIRST) {\n                $list.prepend($element);\n                inserted = true;\n            } else if ($relativeElement && $relativeElement.length > 0) {\n                if (position === AFTER) {\n                    $relativeElement.after($element);\n                    inserted = true;\n                } else if (position === BEFORE) {\n                    $relativeElement.before($element);\n                    inserted = true;\n                }\n            }\n        }\n\n        // Default to LAST\n        if (!inserted) {\n            $list.append($element);\n        }\n    }\n\n    /**\n     * MenuItem represents a single menu item that executes a Command or a menu divider. MenuItems\n     * may have a sub-menu. A MenuItem may correspond to an HTML-based\n     * menu item or a native menu item if Brackets is running in a native application shell\n     *\n     * Since MenuItems may have a native implementation clients should create MenuItems through\n     * addMenuItem() and should NOT construct a MenuItem object directly.\n     * Clients should also not access HTML content of a menu directly and instead use\n     * the MenuItem API to query and modify menus items.\n     *\n     * MenuItems are views on to Command objects so modify the underlying Command to modify the\n     * name, enabled, and checked state of a MenuItem. The MenuItem will update automatically\n     *\n     * @constructor\n     * @private\n     *\n     * @param {string} id\n     * @param {string|Command} command - the Command this MenuItem will reflect.\n     *                                   Use DIVIDER to specify a menu divider\n     * @param [options]\n     * @param {boolean} options.hideWhenCommandDisabled will not show the menu item if command is disabled.\n     */\n    function MenuItem(id, command, options = {}) {\n        this.id = id;\n        this.isDivider = (command === DIVIDER);\n        this.isNative = false;\n\n        if (!this.isDivider && command !== SUBMENU) {\n            // Bind event handlers\n            this._enabledChanged = this._enabledChanged.bind(this);\n            this._checkedChanged = this._checkedChanged.bind(this);\n            this._nameChanged = this._nameChanged.bind(this);\n            this._keyBindingAdded = this._keyBindingAdded.bind(this);\n            this._keyBindingRemoved = this._keyBindingRemoved.bind(this);\n\n            this._command = command;\n            this._hideWhenCommandDisabled = options.hideWhenCommandDisabled;\n            this._command\n                .on(\"enabledStateChange\", this._enabledChanged)\n                .on(\"checkedStateChange\", this._checkedChanged)\n                .on(\"nameChange\", this._nameChanged)\n                .on(\"keyBindingAdded\", this._keyBindingAdded)\n                .on(\"keyBindingRemoved\", this._keyBindingRemoved);\n        }\n    }\n\n    /**\n     * Menu represents a top-level menu in the menu bar. A Menu may correspond to an HTML-based\n     * menu or a native menu if Brackets is running in a native application shell.\n     *\n     * Since menus may have a native implementation clients should create Menus through\n     * addMenu() and should NOT construct a Menu object directly.\n     * Clients should also not access HTML content of a menu directly and instead use\n     * the Menu API to query and modify menus.\n     *\n     * @constructor\n     * @private\n     *\n     * @param {string} id\n     */\n    function Menu(id) {\n        this.id = id;\n    }\n\n    Menu.prototype._getMenuItemId = function (commandId) {\n        return (this.id + \"-\" + commandId);\n    };\n\n    /**\n     * Determine MenuItem in this Menu, that has the specified command\n     *\n     * @param {Command} command - the command to search for.\n     * @return {?HTMLLIElement} menu item list element\n     */\n    Menu.prototype._getMenuItemForCommand = function (command) {\n        if (!command) {\n            return null;\n        }\n        let foundMenuItem = menuItemMap[this._getMenuItemId(command.getID())];\n        if (!foundMenuItem) {\n            return null;\n        }\n        return $(_getHTMLMenuItem(foundMenuItem.id)).closest(\"li\");\n    };\n\n    /**\n     * Determine relative MenuItem\n     *\n     * @param {?string} relativeID - id of command (future: sub-menu).\n     * @param {?string} position - only needed when relativeID is a MenuSection\n     * @return {?HTMLLIElement} menu item list element\n     */\n    Menu.prototype._getRelativeMenuItem = function (relativeID, position) {\n        let $relativeElement;\n\n        if (relativeID) {\n            if (position === FIRST_IN_SECTION || position === LAST_IN_SECTION) {\n                if (!relativeID.hasOwnProperty(\"sectionMarker\")) {\n                    console.error(\"Bad Parameter in _getRelativeMenuItem(): relativeID must be a MenuSection when position refers to a menu section\");\n                    return null;\n                }\n\n                // Determine the $relativeElement by traversing the sibling list and\n                // stop at the first divider found\n                // TODO: simplify using nextUntil()/prevUntil()\n                let $sectionMarker = this._getMenuItemForCommand(CommandManager.get(relativeID.sectionMarker));\n                if (!$sectionMarker) {\n                    console.error(\"_getRelativeMenuItem(): MenuSection \" + relativeID.sectionMarker +\n                                  \" not found in Menu \" + this.id);\n                    return null;\n                }\n                let $listElem = $sectionMarker;\n                $relativeElement = $listElem;\n                while (true) {\n                    $listElem = (position === FIRST_IN_SECTION ? $listElem.prev() : $listElem.next());\n                    if ($listElem.length === 0) {\n                        break;\n                    } else if ($listElem.find(\".divider\").length > 0) {\n                        break;\n                    } else {\n                        $relativeElement = $listElem;\n                    }\n                }\n\n            } else {\n                if (relativeID.hasOwnProperty(\"sectionMarker\")) {\n                    console.error(\"Bad Parameter in _getRelativeMenuItem(): if relativeID is a MenuSection, position must be FIRST_IN_SECTION or LAST_IN_SECTION\");\n                    return null;\n                }\n\n                // handle FIRST, LAST, BEFORE, & AFTER\n                let command = CommandManager.get(relativeID);\n                if (command) {\n                    // Lookup Command for this Command id\n                    // Find MenuItem that has this command\n                    $relativeElement = this._getMenuItemForCommand(command);\n                }\n                if (!$relativeElement) {\n                    console.error(\"_getRelativeMenuItem(): MenuItem with Command id \" + relativeID +\n                                  \" not found in Menu \" + this.id);\n                    return null;\n                }\n            }\n\n            return $relativeElement;\n\n        } else if (position && position !== FIRST && position !== LAST) {\n            console.error(\"Bad Parameter in _getRelativeMenuItem(): relative position specified with no relativeID\");\n            return null;\n        }\n\n        return $relativeElement;\n    };\n\n    /**\n     * Removes the specified menu item from this Menu. Key bindings are unaffected; use KeyBindingManager\n     * directly to remove key bindings if desired.\n     *\n     * @param {!string | Command} command - command the menu would execute if we weren't deleting it.\n     */\n    Menu.prototype.removeMenuItem = function (command) {\n        let menuItemID,\n            commandID;\n\n        if (!command) {\n            console.error(\"removeMenuItem(): missing required parameters: command\");\n            return;\n        }\n\n        if (typeof (command) === \"string\") {\n            let commandObj = CommandManager.get(command);\n            if (!commandObj) {\n                console.error(\"removeMenuItem(): command not found: \" + command);\n                return;\n            }\n            commandID = command;\n        } else {\n            commandID = command.getID();\n        }\n        menuItemID = this._getMenuItemId(commandID);\n\n        let menuItem = getMenuItem(menuItemID);\n        removeMenuItemEventListeners(menuItem);\n\n        $(_getHTMLMenuItem(menuItemID)).parent().remove();\n\n        delete menuItemMap[menuItemID];\n    };\n\n    /**\n     * Removes the specified menu divider from this Menu.\n     *\n     * @param {!string} menuItemID - the menu item id of the divider to remove.\n     */\n    Menu.prototype.removeMenuDivider = function (menuItemID) {\n        let menuItem,\n            $HTMLMenuItem;\n\n        if (!menuItemID) {\n            console.error(\"removeMenuDivider(): missing required parameters: menuItemID\");\n            return;\n        }\n\n        menuItem = getMenuItem(menuItemID);\n\n        if (!menuItem) {\n            console.error(\"removeMenuDivider(): parameter menuItemID: %s is not a valid menu item id\", menuItemID);\n            return;\n        }\n\n        if (!menuItem.isDivider) {\n            console.error(\"removeMenuDivider(): parameter menuItemID: %s is not a menu divider\", menuItemID);\n            return;\n        }\n\n        // Targeting parent to get the menu divider <hr> and the <li> that contains it\n        $HTMLMenuItem = $(_getHTMLMenuItem(menuItemID)).parent();\n        if ($HTMLMenuItem) {\n            $HTMLMenuItem.remove();\n        } else {\n            console.error(\"removeMenuDivider(): HTML menu divider not found: %s\", menuItemID);\n            return;\n        }\n\n        if (!menuItemMap[menuItemID]) {\n            console.error(\"removeMenuDivider(): menu divider not found in menuItemMap: %s\", menuItemID);\n            return;\n        }\n\n        delete menuItemMap[menuItemID];\n    };\n\n    /**\n     * Adds a new menu item with the specified id and display text. The insertion position is\n     * specified via the relativeID and position arguments which describe a position\n     * relative to another MenuItem or MenuGroup. It is preferred that plug-ins\n     * insert new  MenuItems relative to a menu section rather than a specific\n     * MenuItem (see Menu Section Constants).\n     *\n     * TODO: Sub-menus are not yet supported, but when they are implemented this API will\n     * allow adding new MenuItems to sub-menus as well.\n     *\n     * Note, keyBindings are bound to Command objects not MenuItems. The provided keyBindings\n     *      will be bound to the supplied Command object rather than the MenuItem.\n     *\n     * @param {!string | Command} command - the command the menu will execute.\n     *      Pass Menus.DIVIDER for a menu divider, or just call addMenuDivider() instead.\n     * @param {?string | Array.<{key: string, platform: string}>}  [keyBindings] - register one\n     *      one or more key bindings to associate with the supplied command.\n     * @param {?string} [position] - constant defining the position of new MenuItem relative to\n     *      other MenuItems. Values:\n     *          - With no relativeID, use Menus.FIRST or LAST (default is LAST)\n     *          - Relative to a command id, use BEFORE or AFTER (required)\n     *          - Relative to a MenuSection, use FIRST_IN_SECTION or LAST_IN_SECTION (required)\n     * @param {?string} [relativeID] - command id OR one of the MenuSection.* constants. Required\n     *      for all position constants except FIRST and LAST.\n     * @param [options]\n     * @param {boolean} options.hideWhenCommandDisabled will not show the menu item if command is disabled. Helps to\n     *   clear the clutter on greyed out menu items if not applicable to context.\n     *\n     * @return {MenuItem} the newly created MenuItem\n     */\n    Menu.prototype.addMenuItem = function (command, keyBindings, position, relativeID, options = {}) {\n        const self = this;\n        let id,\n            $menuItem,\n            menuItem,\n            name,\n            commandID;\n\n        if (!command) {\n            console.error(\"addMenuItem(): missing required parameters: command\");\n            return null;\n        }\n\n        if (typeof (command) === \"string\") {\n            if (command === DIVIDER) {\n                name = DIVIDER;\n                commandID = _getNextMenuItemDividerID();\n            } else {\n                commandID = command;\n                command = CommandManager.get(commandID);\n                if (!command) {\n                    console.error(\"addMenuItem(): commandID not found: \" + commandID);\n                    return null;\n                }\n                name = command.getName();\n            }\n        } else {\n            commandID = command.getID();\n            name = command.getName();\n        }\n\n        // Internal id is the a composite of the parent menu id and the command id.\n        id = self._getMenuItemId(commandID);\n\n        if (menuItemMap[id]) {\n            console.log(\"MenuItem added with same id of existing MenuItem: \" + id);\n            return null;\n        }\n\n        // create MenuItem\n        menuItem = new MenuItem(id, command, {\n            hideWhenCommandDisabled: options.hideWhenCommandDisabled\n        });\n        menuItemMap[id] = menuItem;\n\n\n        if (name === DIVIDER) {\n            $menuItem = $(\"<li><hr class='divider' id='\" + id + \"' /></li>\");\n        } else {\n            // Create the HTML Menu\n            $menuItem = $(\"<li><a href='#' class='menuAnchor' id='\" + id + \"'> <span class='menu-name'></span></a></li>\");\n            const $menuAnchor = $menuItem.find(\".menuAnchor\");\n\n            $menuItem.on(\"click\", function (event) {\n                if($menuAnchor.hasClass('disabled')){\n                    event.preventDefault();\n                    event.stopPropagation();\n                    return true;\n                }\n                Metrics.countEvent(Metrics.EVENT_TYPE.UI_MENU, \"click\", menuItem._command.getID());\n                logger.leaveTrail(\"UI Menu Click: \" + menuItem._command.getID());\n                MainViewManager.focusActivePane();\n                if(menuItem._command._options.eventSource){\n                    menuItem._command.execute({\n                        eventSource: CommandManager.SOURCE_UI_MENU_CLICK,\n                        sourceType: self.id\n                    });\n                } else {\n                    menuItem._command.execute();\n                }\n            });\n\n            let self = this;\n            $menuItem.on(\"mouseenter\", function () {\n                self.closeSubMenu();\n                $menuItem.parent().find(\".menuAnchor\").removeClass(\"selected\");\n                if(!$menuAnchor.hasClass('disabled')){\n                    $menuAnchor.addClass(\"selected\");\n                }\n            });\n            $menuItem.on(\"mouseleave\", function () {\n                self.closeSubMenu();\n                $menuItem.find(\".menuAnchor\").removeClass(\"selected\");\n            });\n        }\n\n        // Insert menu item\n        let $relativeElement = this._getRelativeMenuItem(relativeID, position);\n        _insertInList($(\"li#\" + StringUtils.jQueryIdEscape(this.id) + \" > ul.dropdown-menu\"),\n                      $menuItem, position, $relativeElement);\n\n\n        // Initialize MenuItem state\n        if (menuItem.isDivider) {\n            menuItem.dividerId = commandID;\n        } else {\n            if (keyBindings) {\n                // Add key bindings. The MenuItem listens to the Command object to update MenuItem DOM with shortcuts.\n                if (!Array.isArray(keyBindings)) {\n                    keyBindings = [keyBindings];\n                }\n            }\n\n            // Note that keyBindings passed during MenuItem creation take precedent over any existing key bindings\n            KeyBindingManager.addBinding(commandID, keyBindings);\n\n            // Look for existing key bindings\n            _addExistingKeyBinding(menuItem);\n\n            menuItem._checkedChanged();\n            menuItem._enabledChanged();\n            menuItem._nameChanged();\n        }\n\n        return menuItem;\n    };\n\n    /**\n     * Inserts divider item in menu.\n     * @param {?string} position - constant defining the position of new the divider relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants).\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      divider will be positioned relative to. Required for all position constants\n     *      except FIRST and LAST\n     *\n     * @return {MenuItem} the newly created divider\n     */\n    Menu.prototype.addMenuDivider = function (position, relativeID) {\n        return this.addMenuItem(DIVIDER, \"\", position, relativeID);\n    };\n\n    /**\n     * NOT IMPLEMENTED\n     * Alternative JSON based API to addMenuItem()\n     *\n     * All properties are required unless noted as optional.\n     *\n     * @param { Array.<{\n     *              id:         string,\n     *              command:    string | Command,\n     *              ?bindings:   string | Array.<{key: string, platform: string}>,\n     *          }>} jsonStr\n     *        }\n     * @param {?string} position - constant defining the position of new the MenuItem relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants).\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      menuItem will be positioned relative to. Required when position is\n     *      AFTER or BEFORE, ignored when position is FIRST or LAST.\n     *\n     * @return {MenuItem} the newly created MenuItem\n     */\n    // Menu.prototype.createMenuItemsFromJSON = function (jsonStr, position, relativeID) {\n    //     NOT IMPLEMENTED\n    // };\n\n\n    /**\n     * NOT IMPLEMENTED\n     * @param {!string} text displayed in menu item\n     * @param {!string} id\n     * @param {?string} position - constant defining the position of new the MenuItem relative\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants)\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\n     *      menuItem will be positioned relative to. Required when position is\n     *      AFTER or BEFORE, ignored when position is FIRST or LAST.\n     *\n     * @return {MenuItem} newly created menuItem for sub-menu\n     */\n    // MenuItem.prototype.createSubMenu = function (text, id, position, relativeID) {\n    //     NOT IMPLEMENTED\n    // };\n\n    /**\n     *\n     * Creates a new submenu and a menuItem and adds the menuItem of the submenu\n     * to the menu and returns the submenu.\n     *\n     * A submenu will have the same structure of a menu with a additional field\n     * parentMenuItem which has the reference of the submenu's parent menuItem.\n\n     * A submenu will raise the following events:\n     * - beforeSubMenuOpen\n     * - beforeSubMenuClose\n     *\n     * Note, This function will create only a context submenu.\n     *\n     * TODO: Make this function work for Menus\n     *\n     *\n     * @param {!string} name displayed in menu item of the submenu\n     * @param {!string} id\n     * @param {?string} position - constant defining the position of new MenuItem of the submenu relative to\n     *      other MenuItems. Values:\n     *          - With no relativeID, use Menus.FIRST or LAST (default is LAST)\n     *          - Relative to a command id, use BEFORE or AFTER (required)\n     *          - Relative to a MenuSection, use FIRST_IN_SECTION or LAST_IN_SECTION (required)\n     * @param {?string} relativeID - command id OR one of the MenuSection.* constants. Required\n     *      for all position constants except FIRST and LAST.\n     *\n     * @return {Menu} the newly created submenu\n     */\n    Menu.prototype.addSubMenu = function (name, id, position, relativeID) {\n\n        if (!name || !id) {\n            console.error(\"addSubMenu(): missing required parameters: name and id\");\n            return null;\n        }\n\n        // Guard against duplicate context menu ids\n        if (contextMenuMap[id]) {\n            console.log(\"Context menu added with id of existing Context Menu: \" + id);\n            return null;\n        }\n\n        let menu = new ContextMenu(id);\n        contextMenuMap[id] = menu;\n\n        let menuItemID = this.id + \"-\" + id;\n\n        if (menuItemMap[menuItemID]) {\n            console.log(\"MenuItem added with same id of existing MenuItem: \" + id);\n            return null;\n        }\n\n        // create MenuItem\n        let menuItem = new MenuItem(menuItemID, SUBMENU);\n        menuItemMap[menuItemID] = menuItem;\n        subMenuItemMap[menuItemID] = menu;\n\n        menu.parentMenuItem = menuItem;\n\n        // create MenuItem DOM\n        // Create the HTML MenuItem\n        let $menuItem = $(\"<li><a class='sub-menu-item menuAnchor' href='#' id='\" + menuItemID + \"'> \"   +\n                         \"<span class='menu-name'>\" + name + \"</span>\" +\n                         \"<span style='float: right'>&rtrif;</span>\"   +\n                         \"</a></li>\");\n\n        let self = this;\n        $menuItem.on(\"mouseenter\", function(e) {\n            if (self.openSubMenu && self.openSubMenu.id === menu.id) {\n                return;\n            }\n            self.closeSubMenu();\n            self.openSubMenu = menu;\n            menu.open();\n            $menuItem.parent().find(\".menuAnchor\").removeClass(\"selected\");\n            $menuItem.find(\".menuAnchor\").addClass(\"selected\");\n        });\n\n        $menuItem.on(\"mouseleave\", function () {\n            $menuItem.find(\".menuAnchor\").removeClass(\"selected\");\n        });\n\n        // Insert menu item\n        let $relativeElement = this._getRelativeMenuItem(relativeID, position);\n        _insertInList($(\"li#\" + StringUtils.jQueryIdEscape(this.id) + \" > ul.dropdown-menu\"),\n        $menuItem, position, $relativeElement);\n\n        return menu;\n    };\n\n\n    /**\n     * Removes the specified submenu from this Menu.\n     *\n     * Note, this function will only remove context submenus\n     *\n     * TODO: Make this function work for Menus\n     *\n     * @param {!string} subMenuID - the menu id of the submenu to remove.\n     */\n    Menu.prototype.removeSubMenu = function (subMenuID) {\n        let subMenu,\n            parentMenuItem,\n            commandID = \"\";\n\n        if (!subMenuID) {\n            console.error(\"removeSubMenu(): missing required parameters: subMenuID\");\n            return;\n        }\n\n        subMenu = getContextMenu(subMenuID);\n\n        if (!subMenu || !subMenu.parentMenuItem) {\n            console.error(\"removeSubMenu(): parameter subMenuID: %s is not a valid submenu id\", subMenuID);\n            return;\n        }\n\n        parentMenuItem = subMenu.parentMenuItem;\n\n\n        if (!menuItemMap[parentMenuItem.id]) {\n            console.error(\"removeSubMenu(): parent menuItem not found in menuItemMap: %s\", parentMenuItem.id);\n            return;\n        }\n\n        // Remove all of the menu items in the submenu\n        _.forEach(menuItemMap, function (value, key) {\n            if (_.startsWith(key, subMenuID)) {\n                if (value.isDivider) {\n                    subMenu.removeMenuDivider(key);\n                } else {\n                    commandID = value.getCommand();\n                    subMenu.removeMenuItem(commandID);\n                }\n            }\n        });\n\n        $(_getHTMLMenuItem(parentMenuItem.id)).parent().remove(); // remove the menu item\n        $(_getHTMLMenu(subMenuID)).remove(); // remove the menu\n\n\n        delete menuItemMap[parentMenuItem.id];\n        delete subMenuItemMap[parentMenuItem.id];\n        delete contextMenuMap[subMenuID];\n    };\n\n    /**\n     * Closes the submenu if the menu has a submenu open.\n     */\n    Menu.prototype.closeSubMenu = function() {\n        if (this.openSubMenu) {\n            this.openSubMenu.close();\n            this.openSubMenu = null;\n        }\n    };\n    /**\n     * Gets the Command associated with a MenuItem\n     * @return {Command}\n     */\n    MenuItem.prototype.getCommand = function () {\n        return this._command;\n    };\n\n    /**\n     * NOT IMPLEMENTED\n     * Returns the parent MenuItem if the menu item is a sub-menu, returns null otherwise.\n     * @return {MenuItem}\n     */\n    // MenuItem.prototype.getParentMenuItem = function () {\n    //     NOT IMPLEMENTED;\n    // };\n\n    /**\n     * Returns the parent Menu for this MenuItem\n     * @return {Menu}\n     */\n    MenuItem.prototype.getParentMenu = function () {\n        let parent = $(_getHTMLMenuItem(this.id)).parents(\".dropdown\").get(0);\n        if (!parent) {\n            return null;\n        }\n\n        return getMenu(parent.id);\n    };\n\n    /**\n     * Synchronizes MenuItem checked state with underlying Command checked state\n     */\n    MenuItem.prototype._checkedChanged = function () {\n        let checked = !!this._command.getChecked();\n        if (this.isNative) {\n            let enabled = !!this._command.getEnabled();\n            let command = this._command;\n            brackets.app.setMenuItemState(this._command.getID(), enabled, checked, function (err) {\n                if (err) {\n                    console.log(\"Error setting menu item checked state for \" + command + \": \" + err);\n                }\n            });\n        } else {\n            ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), \"checked\", checked);\n        }\n    };\n\n    /**\n     * Synchronizes MenuItem enabled state with underlying Command enabled state\n     */\n    MenuItem.prototype._enabledChanged = function () {\n        if (this.isNative) {\n            let enabled = !!this._command.getEnabled();\n            let checked = !!this._command.getChecked();\n            let command = this._command;\n            brackets.app.setMenuItemState(this._command.getID(), enabled, checked, function (err) {\n                if (err) {\n                    console.log(\"Error setting menu item enabled state for \" + command + \": \" + err);\n                }\n            });\n        } else {\n            ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), \"disabled\", !this._command.getEnabled());\n            if(this._hideWhenCommandDisabled){\n                ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), \"forced-hidden\", !this._command.getEnabled());\n            }\n        }\n    };\n\n    /**\n     * Synchronizes MenuItem name with underlying Command name\n     */\n    MenuItem.prototype._nameChanged = function () {\n        if (this.isNative) {\n            let command = this._command;\n            brackets.app.setMenuTitle(this._command.getID(), this._command.getName(), function (err) {\n                if (err) {\n                    console.log(\"Error setting menu title for \" + command + \": \" + err);\n                }\n            });\n        } else {\n            $(_getHTMLMenuItem(this.id)).find(\".menu-name\").text(this._command.getName());\n        }\n    };\n\n    /**\n     * @private\n     * Updates MenuItem DOM with a keyboard shortcut label\n     */\n    MenuItem.prototype._keyBindingAdded = function (event, keyBinding) {\n        if (this.isNative) {\n            let shortcutKey = keyBinding.displayKey || keyBinding.key,\n                command = this._command;\n            brackets.app.setMenuItemShortcut(this._command.getID(), shortcutKey, KeyBindingManager.formatKeyDescriptor(shortcutKey), function (err) {\n                if (err) {\n                    console.error(\"Error setting menu item shortcut key \" + shortcutKey + \", \" + command + \" : \" + err );\n                }\n            });\n        } else {\n            _addKeyBindingToMenuItem($(_getHTMLMenuItem(this.id)), keyBinding.key, keyBinding.displayKey);\n        }\n    };\n\n    /**\n     * @private\n     * Updates MenuItem DOM to remove keyboard shortcut label\n     */\n    MenuItem.prototype._keyBindingRemoved = function (event, keyBinding) {\n        if (this.isNative) {\n            let shortcutKey = keyBinding.displayKey || keyBinding.key,\n                command = this._command;\n            brackets.app.setMenuItemShortcut(this._command.getID(), \"\", \"\", function (err) {\n                if (err) {\n                    console.error(\"Error setting menu item shortcut: \" + err, shortcutKey, command);\n                }\n            });\n        } else {\n            let $shortcut = $(_getHTMLMenuItem(this.id)).find(\".menu-shortcut\");\n\n            if ($shortcut.length > 0 && $shortcut.data(\"key\") === keyBinding.key) {\n                // check for any other bindings\n                if (_addExistingKeyBinding(this) === null) {\n                    $shortcut.empty();\n                }\n            }\n        }\n    };\n\n    /**\n     * Closes all menus that are open\n     */\n    function closeAll() {\n        $(\".dropdown\").removeClass(\"open\");\n    }\n\n    function _closeAllSubMenus() {\n        for(let menu of Object.values(menuMap)){\n            menu.closeSubMenu();\n        }\n    }\n\n    /**\n     * Adds a top-level menu to the application menu bar which may be native or HTML-based.\n     *\n     * @param {!string} name - display text for menu\n     * @param {!string} id - unique identifier for a menu.\n     *      Core Menus in Brackets use a simple  title as an id, for example \"file-menu\".\n     *      Extensions should use the following format: \"author.myextension.mymenuname\".\n     * @param {?string} position - constant defining the position of new the Menu relative\n     *  to other Menus. Default is LAST (see Insertion position constants).\n     *\n     * @param {?string} relativeID - id of Menu the new Menu will be positioned relative to. Required\n     *      when position is AFTER or BEFORE, ignored when position is FIRST or LAST\n     *\n     * @return {?Menu} the newly created Menu\n     */\n    function addMenu(name, id, position, relativeID) {\n        name = _.escape(name);\n        let $menubar = $(\"#titlebar .nav\"),\n            menu;\n\n        if (!name || !id) {\n            console.error(\"call to addMenu() is missing required parameters\");\n            return null;\n        }\n\n        // Guard against duplicate menu ids\n        if (menuMap[id]) {\n            console.log(\"Menu added with same name and id of existing Menu: \" + id);\n            return null;\n        }\n\n        menu = new Menu(id);\n        menuMap[id] = menu;\n\n\n        let $toggle = $(`<a id=\"${id}-dropdown-toggle\" href='#' class='dropdown-toggle' data-toggle='dropdown'>${name}</a>`),\n            $popUp = $(\"<ul class='dropdown-menu'></ul>\"),\n            $dropdown = $(\"<li class='dropdown' id='\" + id + \"'></li>\"),\n            $newMenu = $dropdown.append($toggle).append($popUp);\n\n        $toggle.on(\"mouseenter\", function() {\n            _closeAllSubMenus();\n            const $this = $(this); // Cache the jQuery object of the current element\n\n            // Check if '#titlebar' or any of its descendants has focus\n            if ($('#titlebar, #titlebar *').is(':focus')) {\n                // If '#titlebar' or a descendant has focus, add 'selected' class and focus the current element\n                $this.addClass('selected').focus();\n            } else {\n                // Otherwise, just add 'selected' class\n                $this.addClass('selected');\n            }\n        });\n\n        $toggle.on(\"mouseleave\", function() {\n            $(this).removeClass('selected');\n        });\n\n        // $popUp.on(\"mousemove\",function (event) {\n        //     $popUp.find(\".selected\").removeClass(\"selected\");\n        // });\n\n        // Insert menu\n        let $relativeElement = relativeID && $(_getHTMLMenu(relativeID));\n        _insertInList($menubar, $newMenu, position, $relativeElement);\n\n        // Install ESC key handling\n        PopUpManager.addPopUp($popUp, closeAll, false);\n\n        // todo error handling\n\n        return menu;\n    }\n\n    function _switchMenus($menuDropdownToggle, event) {\n        // remove the class 'open' from its parent element\n        $menuDropdownToggle.parent().removeClass('open');\n        const menuID = $menuDropdownToggle.parent().get(0).id;\n        const mainMenu = menuMap[menuID];\n        const $dropdownToggles = $('#titlebar .dropdown-toggle');\n        let currentIndex = $dropdownToggles.index($menuDropdownToggle);\n        currentIndex = event.key === KEY.ARROW_LEFT ? currentIndex - 1 : currentIndex + 1;\n        const nextIndex = currentIndex % $dropdownToggles.length;\n        $dropdownToggles.eq(nextIndex).parent().addClass('open');\n        $dropdownToggles.eq(nextIndex).focus();\n        mainMenu && mainMenu.closeSubMenu();\n    }\n\n    function _switchMenuItems($menuDropdownToggle, event) {\n        // change code such that if event.key is KEY.ARROW_UP or KEY.ARROW_DOWN, the selection will move formward or back\n        const menuID = $menuDropdownToggle.parent().get(0).id;\n        const $dropdownMenu = $menuDropdownToggle.parent().find(\".dropdown-menu\");\n        const $selected = $dropdownMenu.find('li a.selected');\n        if ($selected.length === 0) {\n            // If no selected class exists, add it to the first <a> tag\n            $dropdownMenu.find('li a').first().addClass('selected');\n        } else {\n            // Remove the class from the current item\n            $selected.removeClass('selected');\n\n            // Determine the next or previous item based on the arrow key pressed\n            let $next;\n            if (event.key === KEY.ARROW_DOWN) {\n                let $nextLi = $selected.closest('li').next('li');\n                $next = $nextLi.find('a');\n                while (($next.length === 0 || $next.hasClass('disabled') || !$next.is(':visible')) && $nextLi.length) {\n                    $nextLi = $nextLi.next('li');\n                    $next = $nextLi.find('a');\n                }\n                if($next.length === 0){\n                    $next = $dropdownMenu.find('li a').first();\n                }\n            } else if (event.key === KEY.ARROW_UP) {\n                let $prevLi = $selected.closest('li').prev('li');\n                $next = $prevLi.find('a');\n                while (($next.length === 0 || $next.hasClass('disabled') || !$next.is(':visible')) && $prevLi.length) {\n                    $prevLi = $prevLi.prev('li');\n                    $next = $prevLi.find('a');\n                }\n                if ($next.length === 0) {\n                    $next = $dropdownMenu.find('li a').last();\n                }\n            }\n\n            // Add the 'selected' class to the next item\n            $next.addClass('selected');\n            const mainMenu = menuMap[menuID];\n            if($next.hasClass(\"sub-menu-item\")){\n                const submenuID = $next.get(0).id;\n                const submenu = subMenuItemMap[submenuID];\n                if(submenu){\n                    mainMenu.closeSubMenu();\n                    mainMenu.openSubMenu = submenu;\n                    submenu.open();\n                }\n            } else {\n                mainMenu.closeSubMenu();\n            }\n        }\n    }\n    \n    function _execMenuItem($menuDropdownToggle, event) {\n        // change code such that if event.key is KEY.ARROW_UP or KEY.ARROW_DOWN, the selection will move formward or back\n        const $dropdownMenu = $menuDropdownToggle.parent().find(\".dropdown-menu\");\n        const $selected = $dropdownMenu.find('li a.selected');\n        if ($selected.length === 1 && $dropdownMenu.is(':visible')) {\n            // something is selected\n            MainViewManager.focusActivePane();\n            $selected.click();\n            event.preventDefault();\n            event.stopPropagation();\n            return true;\n        }\n    }\n\n    function menuKeyboardNavigationHandler(event) {\n        const allowedKeys = [KEY.ARROW_LEFT, KEY.ARROW_RIGHT, KEY.ARROW_UP, KEY.ARROW_DOWN,\n            KEY.ESCAPE, KEY.ENTER, KEY.RETURN];\n        if (!allowedKeys.includes(event.key)) {\n            return;\n        }\n        if ($('#titlebar, #titlebar *').is(':focus')) {\n            // If '#titlebar' or a descendant has focus, add 'selected' class and focus the current element\n            if(event.key === KEY.ESCAPE){\n                MainViewManager.focusActivePane();\n                event.preventDefault();\n                event.stopPropagation();\n                return;\n            }\n            const $focusedElement = $(':focus');\n            const isDescendantOfTitleBar = $focusedElement.closest('#titlebar').length > 0;\n            if(!isDescendantOfTitleBar){\n                return;\n            }\n            if($focusedElement.hasClass('dropdown-toggle')){\n                if(event.key === KEY.ARROW_LEFT || event.key === KEY.ARROW_RIGHT){\n                    // the main menu has focus, like file, edit etc..\n                    return _switchMenus($focusedElement, event);\n                } else if(event.key === KEY.ARROW_UP || event.key === KEY.ARROW_DOWN){\n                    return _switchMenuItems($focusedElement, event);\n                } else if(event.key === KEY.ENTER || event.key === KEY.RETURN || event.key === KEY.SPACE){\n                    return _execMenuItem($focusedElement, event);\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes a top-level menu from the application menu bar which may be native or HTML-based.\n     *\n     * @param {!string} id - unique identifier for a menu.\n     *      Core Menus in Brackets use a simple title as an id, for example \"file-menu\".\n     *      Extensions should use the following format: \"author.myextension.mymenuname\".\n     */\n    function removeMenu(id) {\n        let menu,\n            commandID = \"\";\n\n        if (!id) {\n            console.error(\"removeMenu(): missing required parameter: id\");\n            return;\n        }\n\n        if (!menuMap[id]) {\n            console.error(\"removeMenu(): menu id not found: %s\", id);\n            return;\n        }\n\n        // Remove all of the menu items in the menu\n        menu = getMenu(id);\n\n        _.forEach(menuItemMap, function (value, key) {\n            if (_.startsWith(key, id)) {\n                if (value.isDivider) {\n                    menu.removeMenuDivider(key);\n                } else {\n                    commandID = value.getCommand();\n                    menu.removeMenuItem(commandID);\n                }\n            }\n        });\n\n        $(_getHTMLMenu(id)).remove();\n\n        delete menuMap[id];\n    }\n\n    /**\n     * Represents a context menu that can open at a specific location in the UI.\n     *\n     * Clients should not create this object directly and should instead use registerContextMenu()\n     * to create new ContextMenu objects.\n     *\n     * Context menus in brackets may be HTML-based or native so clients should not reach into\n     * the HTML and should instead manipulate ContextMenus through the API.\n     *\n     * Events:\n     * - beforeContextMenuOpen\n     * - beforeContextMenuClose\n     *\n     * @constructor\n     * @extends {Menu}\n     */\n    function ContextMenu(id) {\n        Menu.apply(this, arguments);\n\n        let $newMenu = $(\"<li class='dropdown context-menu' id='\" + StringUtils.jQueryIdEscape(id) + \"'></li>\"),\n            $popUp = $(\"<ul class='dropdown-menu'></ul>\"),\n            $toggle = $(\"<a href='#' class='dropdown-toggle' data-toggle='dropdown'></a>\").hide();\n\n        // assemble the menu fragments\n        $newMenu.append($toggle).append($popUp);\n\n        // insert into DOM\n        $(\"#context-menu-bar > ul\").append($newMenu);\n\n        let self = this;\n        PopUpManager.addPopUp($popUp,\n            function () {\n                self.close();\n            },\n            false);\n\n        // Listen to ContextMenu's beforeContextMenuOpen event to first close other popups\n        PopUpManager.listenToContextMenu(this);\n    }\n    ContextMenu.prototype = Object.create(Menu.prototype);\n    ContextMenu.prototype.constructor = ContextMenu;\n    ContextMenu.prototype.parentClass = Menu.prototype;\n    EventDispatcher.makeEventDispatcher(ContextMenu.prototype);\n\n\n    /**\n     * Displays the ContextMenu at the specified location and dispatches the\n     * \"beforeContextMenuOpen\" event or \"beforeSubMenuOpen\" event (for submenus).\n     * The menu location may be adjusted to prevent clipping by the browser window.\n     * All other menus and ContextMenus will be closed before a new menu\n     * will be closed before a new menu is shown (if the new menu is not\n     * a submenu).\n     *\n     * In case of submenus, the parentMenu of the submenu will not be closed when the\n     * sub menu is open.\n     *\n     * @param {MouseEvent | {pageX:number, pageY:number}} mouseOrLocation - pass a MouseEvent\n     *      to display the menu near the mouse or pass in an object with page x/y coordinates\n     *      for a specific location.This paramter is not used for submenus. Submenus are always\n     *      displayed at a position relative to the parent menu.\n     */\n    ContextMenu.prototype.open = function (mouseOrLocation) {\n        Metrics.countEvent(Metrics.EVENT_TYPE.UI_MENU, \"contextMenuOpen\", this.id);\n        if (!this.parentMenuItem &&\n           (!mouseOrLocation || !mouseOrLocation.hasOwnProperty(\"pageX\") || !mouseOrLocation.hasOwnProperty(\"pageY\"))) {\n            console.error(\"ContextMenu open(): missing required parameter\");\n            return;\n        }\n\n        let $window = $(window),\n            escapedId = StringUtils.jQueryIdEscape(this.id),\n            $menuAnchor = $(\"#\" + escapedId),\n            $menuWindow = $(\"#\" + escapedId + \" > ul\"),\n            posTop,\n            posLeft;\n\n        // only show context menu if it has menu items\n        if ($menuWindow.children().length <= 0) {\n            return;\n        }\n\n\n        // adjust positioning so menu is not clipped off bottom or right\n        if (this.parentMenuItem) { // If context menu is a submenu\n\n            this.trigger(EVENT_BEFORE_SUB_MENU_OPEN);\n\n            let $parentMenuItem = $(_getHTMLMenuItem(this.parentMenuItem.id));\n\n            posTop = $parentMenuItem.offset().top;\n            posLeft = $parentMenuItem.offset().left + $parentMenuItem.outerWidth();\n\n            let elementRect = {\n                    top: posTop,\n                    left: posLeft,\n                    height: $menuWindow.height() + 25,\n                    width: $menuWindow.width()\n                },\n                clip = ViewUtils.getElementClipSize($window, elementRect);\n\n            if (clip.bottom > 0) {\n                posTop = Math.max(0, posTop + $parentMenuItem.height() - $menuWindow.height());\n            }\n\n            posTop -= 30;   // shift top for hidden parent element\n            posLeft += 3;\n\n            if (clip.right > 0) {\n                posLeft = Math.max(0, posLeft - $parentMenuItem.outerWidth() - $menuWindow.outerWidth());\n            }\n        } else {\n            this.trigger(EVENT_BEFORE_CONTEXT_MENU_OPEN);\n\n            // close all other dropdowns\n            closeAll();\n\n            posTop  = mouseOrLocation.pageY;\n            posLeft = mouseOrLocation.pageX;\n\n            let elementRect = {\n                    top: posTop,\n                    left: posLeft,\n                    height: $menuWindow.height() + 25,\n                    width: $menuWindow.width()\n                },\n                clip = ViewUtils.getElementClipSize($window, elementRect);\n\n            if (clip.bottom > 0) {\n                posTop = Math.max(0, posTop - clip.bottom);\n            }\n            posTop -= 30;   // shift top for hidden parent element\n            posLeft += 5;\n\n\n            if (clip.right > 0) {\n                posLeft = Math.max(0, posLeft - clip.right);\n            }\n        }\n\n        // open the context menu at final location\n        $menuAnchor.addClass(\"open\")\n                   .css({\"left\": posLeft, \"top\": posTop});\n    };\n\n\n    /**\n     * Closes the context menu.\n     */\n    ContextMenu.prototype.close = function () {\n        if (this.parentMenuItem) {\n            this.trigger(EVENT_BEFORE_SUB_MENU_CLOSE);\n        } else {\n            this.trigger(EVENT_BEFORE_CONTEXT_MENU_CLOSE);\n        }\n        this.closeSubMenu();\n        $(\"#\" + StringUtils.jQueryIdEscape(this.id)).removeClass(\"open\");\n    };\n\n    /**\n     * Detect if current context menu is already open\n     */\n    ContextMenu.prototype.isOpen = function () {\n        return $(\"#\" + StringUtils.jQueryIdEscape(this.id)).hasClass(\"open\");\n    };\n\n\n    /**\n     * Associate a context menu to a DOM element.\n     * This static function take care of registering event handlers for the click event\n     * listener and passing the right \"position\" object to the Context#open method\n     */\n    ContextMenu.assignContextMenuToSelector = function (selector, cmenu) {\n        $(selector).on(\"click\", function (e) {\n            let buttonOffset,\n                buttonHeight;\n\n            e.stopPropagation();\n\n            if (cmenu.isOpen()) {\n                cmenu.close();\n            } else {\n                buttonOffset = $(this).offset();\n                buttonHeight = $(this).outerHeight();\n                cmenu.open({\n                    pageX: buttonOffset.left,\n                    pageY: buttonOffset.top + buttonHeight\n                });\n            }\n        });\n    };\n\n\n    /**\n     * Registers new context menu with Brackets.\n\n     * Extensions should generally use the predefined context menus built into Brackets. Use this\n     * API to add a new context menu to UI that is specific to an extension.\n     *\n     * After registering  a new context menu clients should:\n     *      - use addMenuItem() to add items to the context menu\n     *      - call open() to show the context menu.\n     *      For example:\n     *      $(\"#my_ID\").contextmenu(function (e) {\n     *          if (e.which === 3) {\n     *              my_cmenu.open(e);\n     *          }\n     *      });\n     *\n     * To make menu items be contextual to things like selection, listen for the \"beforeContextMenuOpen\"\n     * to make changes to Command objects before the context menu is shown. MenuItems are views of\n     * Commands, which control a MenuItem's name, enabled state, and checked state.\n     *\n     * @param {string} id - unique identifier for context menu.\n     *      Core context menus in Brackets use a simple title as an id.\n     *      Extensions should use the following format: \"author.myextension.mycontextmenu name\"\n     * @return {?ContextMenu} the newly created context menu\n     */\n    function registerContextMenu(id) {\n        if (!id) {\n            console.error(\"call to registerContextMenu() is missing required parameters\");\n            return null;\n        }\n\n        // Guard against duplicate menu ids\n        if (contextMenuMap[id]) {\n            console.log(\"Context Menu added with same name and id of existing Context Menu: \" + id);\n            return null;\n        }\n\n        let cmenu = new ContextMenu(id);\n        contextMenuMap[id] = cmenu;\n        return cmenu;\n    }\n\n    AppInit.htmlReady(function () {\n        $('#titlebar').on('focusin', function() {\n            KeyBindingManager.addGlobalKeydownHook(menuKeyboardNavigationHandler);\n        });\n        $('#titlebar').on('focusout', function() {\n            KeyBindingManager.removeGlobalKeydownHook(menuKeyboardNavigationHandler);\n        });\n    });\n\n    // Deprecated menu ids\n    DeprecationWarning.deprecateConstant(ContextMenuIds, \"WORKING_SET_MENU\", \"WORKING_SET_CONTEXT_MENU\");\n    DeprecationWarning.deprecateConstant(ContextMenuIds, \"WORKING_SET_SETTINGS_MENU\", \"WORKING_SET_CONFIG_MENU\");\n\n    // Define public API\n    exports.AppMenuBar = AppMenuBar;\n    exports.ContextMenuIds = ContextMenuIds;\n    exports.MenuSection = MenuSection;\n    exports.BEFORE = BEFORE;\n    exports.AFTER = AFTER;\n    exports.LAST = LAST;\n    exports.FIRST = FIRST;\n    exports.FIRST_IN_SECTION = FIRST_IN_SECTION;\n    exports.LAST_IN_SECTION = LAST_IN_SECTION;\n    exports.DIVIDER = DIVIDER;\n    exports.getMenu = getMenu;\n    exports.getAllMenus = getAllMenus;\n    exports.getMenuItem = getMenuItem;\n    exports.getContextMenu = getContextMenu;\n    exports.addMenu = addMenu;\n    exports.removeMenu = removeMenu;\n    exports.registerContextMenu = registerContextMenu;\n    exports.closeAll = closeAll;\n    exports.Menu = Menu;\n    exports.MenuItem = MenuItem;\n    exports.ContextMenu = ContextMenu;\n    // public events\n    exports.EVENT_BEFORE_CONTEXT_MENU_OPEN = EVENT_BEFORE_CONTEXT_MENU_OPEN;\n    exports.EVENT_BEFORE_CONTEXT_MENU_CLOSE = EVENT_BEFORE_CONTEXT_MENU_CLOSE;\n    exports.EVENT_BEFORE_SUB_MENU_OPEN = EVENT_BEFORE_SUB_MENU_OPEN;\n    exports.EVENT_BEFORE_SUB_MENU_CLOSE = EVENT_BEFORE_SUB_MENU_CLOSE;\n});\n"],"file":"Menus.js"}
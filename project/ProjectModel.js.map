{"version":3,"sources":["project/ProjectModel.js"],"names":["define","require","exports","module","InMemoryFile","EventDispatcher","FileUtils","_","FileSystem","FileSystemError","FileTreeViewModel","Async","PerfUtils","EVENT_CHANGE","EVENT_SHOULD_SELECT","EVENT_SHOULD_FOCUS","EVENT_FS_RENAME_STARTED","EVENT_FS_RENAME_END","ERROR_CREATION","ERROR_INVALID_FILENAME","ERROR_NOT_IN_PROJECT","_exclusionListRegEx","_cacheExcludeRegEx","defaultIgnoreGlobs","_invalidChars","_illegalFilenamesRegEx","isValidFilename","filename","match","isValidPath","path","_shouldShowName","name","test","shouldShow","entry","shouldIndex","FILE_RENAMING","FILE_CREATING","RENAME_CANCELLED","_pathIsFile","last","_getFSObject","getFileForPath","getDirectoryForPath","_getPathFromFSObject","fsobj","fullPath","doCreate","isFolder","d","$","Deferred","getBaseName","resolve","err","directory","create","reject","file","writeText","then","ALREADY_EXISTS","promise","ProjectModel","initial","projectRoot","this","undefined","focused","_focused","_viewModel","on","trigger","bind","_selections","_ensureTrailingSlash","_getWelcomeProjectPath","sampleUrl","initialPath","substr","lastIndexOf","_addWelcomeProjectPath","currentProjects","pathNoSlash","stripTrailingSlash","newProjects","clone","indexOf","push","_isWelcomeProjectPath","welcomeProjectPath","welcomeProjects","makeEventDispatcher","prototype","_projectBaseUrl","_currentPath","_allFilesCachePromise","setFocused","setSelected","setSelectionWidth","width","setScrollerInfo","scrollWidth","scrollTop","scrollLeft","offsetTop","setSelectionScrollerInfo","getBaseUrl","setBaseUrl","projectBaseUrl","length","isWithinProject","absPathOrEntry","absPath","makeProjectRelativeIfPossible","slice","getDirectoryInProject","isDirectory","_getAllFilesCache","sort","deferred","allFiles","allFilesVisitor","isFile","projectIndexTimer","markStart","options","sortList","visit","finalizeMeasurement","addMeasurement","getAllFiles","filter","additionalFiles","filteredFilesDeferred","done","result","forEach","e","console","error","stack","fail","_resetCache","setProjectRoot","_rootChanged","self","getContents","contents","setDirectoryContents","_getDirectoryContents","setDirectoryOpen","open","projectRelative","needsLoading","isPathLoaded","onSuccess","openPath","currentPathInProject","isFilePathVisible","selected","relativeSelected","parentDirectory","getDirectoryPath","showInTree","doNotOpen","oldProjectPath","pathInProject","performRename","moveMarker","context","previousSelection","previousPath","hadFocus","getSelected","setCurrentFile","curFile","selectInWorkingSet","add","setContext","_doNotRename","_saveContext","previousContext","currentContext","restoreContext","getContext","startRename","isMoved","rename","type","projectRelativePath","newPath","setRenameValue","cancelRename","renameInfo","_cancelCreating","_renameItem","oldPath","newName","oldName","viewModel","createAtPath","finalizeRename","deleteAtPath","errorType","errorInfo","renameItem","startCreating","basedir","createPlaceholder","setSortDirectoriesFirst","sortDirectoriesFirst","getOpenNodes","reopenNodes","nodesByDepth","doSequentially","toOpenPaths","doInParallel","relative","refresh","openNodes","selections","handleFSEvent","added","removed","changes","changed","map","find","processChanges","closeSubtree","toggleSubdirectories","openOrClose","childNodes","getChildDirectories","node"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2014 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/* unittests: ProjectModel */\n\n/**\n * Provides the data source for a project and manages the view model for the FileTreeView.\n */\ndefine(function (require, exports, module) {\n\n\n    var InMemoryFile        = require(\"document/InMemoryFile\"),\n        EventDispatcher     = require(\"utils/EventDispatcher\"),\n        FileUtils           = require(\"file/FileUtils\"),\n        _                   = require(\"thirdparty/lodash\"),\n        FileSystem          = require(\"filesystem/FileSystem\"),\n        FileSystemError     = require(\"filesystem/FileSystemError\"),\n        FileTreeViewModel   = require(\"project/FileTreeViewModel\"),\n        Async               = require(\"utils/Async\"),\n        PerfUtils           = require(\"utils/PerfUtils\");\n\n    // Constants\n    var EVENT_CHANGE            = \"change\",\n        EVENT_SHOULD_SELECT     = \"select\",\n        EVENT_SHOULD_FOCUS      = \"focus\",\n        EVENT_FS_RENAME_STARTED = \"mvStart\",\n        EVENT_FS_RENAME_END     = \"mvEnd\",\n        ERROR_CREATION          = \"creationError\",\n        ERROR_INVALID_FILENAME  = \"invalidFilename\",\n        ERROR_NOT_IN_PROJECT    = \"notInProject\";\n\n    /**\n     * @private\n     * File and folder names which are not displayed or searched\n     * TODO: We should add the rest of the file names that TAR excludes:\n     *    http://www.gnu.org/software/tar/manual/html_section/exclude.html\n     * TODO: This should be user configurable\n     *    https://github.com/adobe/brackets/issues/6781\n     * @type {RegExp}\n     */\n    var _exclusionListRegEx = /\\.pyc$|^\\.git$|^\\.gitmodules$|^\\.svn$|^\\.DS_Store$|^Icon\\r|^Thumbs\\.db$|^\\.hg$|^CVS$|^\\.hgtags$|^\\.idea$|^\\.c9revisions$|^\\.SyncArchive$|^\\.SyncID$|^\\.SyncIgnore$|\\~$/;\n    var _cacheExcludeRegEx = /^node_modules$|^bower_components$/;\n\n    /**\n     * Glob definition of files and folders that should be excluded directly\n     * inside node domain watching with chokidar\n     */\n    var defaultIgnoreGlobs = [\n        \"**/(.pyc|.git|.gitmodules|.svn|.DS_Store|Thumbs.db|.hg|CVS|.hgtags|.idea|.c9revisions|.SyncArchive|.SyncID|.SyncIgnore)\",\n        \"**/bower_components\",\n        \"**/node_modules\"\n    ];\n\n    /**\n     * @private\n     * RegEx to validate a file path.\n     */\n    var _invalidChars = /([?\\*\\|\\<\\>\"]+|\\/{2,}|\\.{2,}|\\.$)/i;\n\n    /**\n     * @private\n     * RegEx to validate if a filename is not allowed even if the system allows it.\n     * This is done to prevent cross-platform issues.\n     */\n    var _illegalFilenamesRegEx = /((\\b(com[0-9]+|lpt[0-9]+|nul|con|prn|aux)\\b)|\\.+$|\\/+|\\\\+|\\:)/i;\n\n    /**\n     * Returns true if this matches valid filename specifications.\n     * See http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx\n     *\n     * TODO: This likely belongs in FileUtils.\n     *\n     * @param {string} filename to check\n     * @return {boolean} true if the filename is valid\n     */\n    function isValidFilename(filename) {\n        // Fix issue adobe#13099\n        // See https://github.com/adobe/brackets/issues/13099\n        return !(\n            filename.match(_invalidChars)|| filename.match(_illegalFilenamesRegEx)\n        );\n    }\n\n    /**\n     * Returns true if given path is valid.\n     *\n     * @param {string} path to check\n     * @return {boolean} true if the filename is valid\n     */\n    function isValidPath(path) {\n        // Fix issue adobe#13099\n        // See https://github.com/adobe/brackets/issues/13099\n        return !(path.match(_invalidChars));\n    }\n\n    /**\n     * @private\n     * @see #shouldShow\n     */\n    function _shouldShowName(name) {\n        return !_exclusionListRegEx.test(name);\n    }\n\n    /**\n     * Returns false for files and directories that are not commonly useful to display.\n     *\n     * @param {!FileSystemEntry} entry File or directory to filter\n     * @return {boolean} true if the file should be displayed\n     */\n    function shouldShow(entry) {\n        return _shouldShowName(entry.name);\n    }\n\n    /**\n     * Returns false for files and directories that should not be indexed for search or code hints.\n     *\n     * @param {!FileSystemEntry} entry File or directory to filter\n     * @return {boolean} true if the file should be displayed\n     */\n    function shouldIndex(entry) {\n        return shouldShow(entry) && !_cacheExcludeRegEx.test(entry.name);\n    }\n\n    // Constants used by the ProjectModel\n\n    var FILE_RENAMING     = 0,\n        FILE_CREATING     = 1,\n        RENAME_CANCELLED  = 2;\n\n\n    /**\n     * @private\n     *\n     * Determines if a path string is pointing to a directory (does it have a trailing slash?)\n     *\n     * @param {string} path Path to test.\n     */\n    function _pathIsFile(path) {\n        return _.last(path) !== \"/\";\n    }\n\n    /**\n     * @private\n     *\n     * Gets the FileSystem object (either a File or Directory) based on the path provided.\n     *\n     * @param {string} path Path to retrieve\n     */\n    function _getFSObject(path) {\n        if (!path) {\n            return path;\n        } else if (_pathIsFile(path)) {\n            return FileSystem.getFileForPath(path);\n        }\n        return FileSystem.getDirectoryForPath(path);\n    }\n\n    /**\n     * @private\n     *\n     * Given what is possible a FileSystem object, return its path (if a string path is passed in,\n     * it will be returned as-is).\n     *\n     * @param {FileSystemEntry} fsobj Object from which the path should be extracted\n     */\n    function _getPathFromFSObject(fsobj) {\n        if (fsobj && fsobj.fullPath) {\n            return fsobj.fullPath;\n        }\n        return fsobj;\n    }\n\n    /**\n     * Creates a new file or folder at the given path. The returned promise is rejected if the filename\n     * is invalid, the new path already exists or some other filesystem error comes up.\n     *\n     * @param {string} path path to create\n     * @param {boolean} isFolder true if the new entry is a folder\n     * @return {$.Promise} resolved when the file or directory has been created.\n     */\n    function doCreate(path, isFolder) {\n        var d = new $.Deferred();\n        var filename = FileUtils.getBaseName(path);\n\n        // Check if filename\n        if (!isValidFilename(filename)){\n            return d.reject(ERROR_INVALID_FILENAME).promise();\n        }\n\n        // Check if fullpath with filename is valid\n        // This check is used to circumvent directory jumps (Like ../..)\n        if (!isValidPath(path)) {\n            return d.reject(ERROR_INVALID_FILENAME).promise();\n        }\n\n        FileSystem.resolve(path, function (err) {\n            if (!err) {\n                // Item already exists, fail with error\n                d.reject(FileSystemError.ALREADY_EXISTS);\n            } else {\n                if (isFolder) {\n                    var directory = FileSystem.getDirectoryForPath(path);\n\n                    directory.create(function (err) {\n                        if (err) {\n                            d.reject(err);\n                        } else {\n                            d.resolve(directory);\n                        }\n                    });\n                } else {\n                    // Create an empty file\n                    var file = FileSystem.getFileForPath(path);\n\n                    FileUtils.writeText(file, \"\").then(function () {\n                        d.resolve(file);\n                    }, d.reject);\n                }\n            }\n        });\n\n        return d.promise();\n    }\n\n    /**\n     * @constructor\n     *\n     * The ProjectModel provides methods for accessing information about the current open project.\n     * It also manages the view model to display a FileTreeView of the project.\n     *\n     * Events:\n     * - EVENT_CHANGE (`change`) - Fired when there's a change that should refresh the UI\n     * - EVENT_SHOULD_SELECT (`select`) - Fired when a selection has been made in the file tree and the file tree should be selected\n     * - EVENT_SHOULD_FOCUS (`focus`)\n     * - ERROR_CREATION (`creationError`) - Triggered when there's a problem creating a file\n     */\n    function ProjectModel(initial) {\n        initial = initial || {};\n        if (initial.projectRoot) {\n            this.projectRoot = initial.projectRoot;\n        }\n\n        if (initial.focused !== undefined) {\n            this._focused = initial.focused;\n        }\n        this._viewModel = new FileTreeViewModel.FileTreeViewModel();\n        this._viewModel.on(FileTreeViewModel.EVENT_CHANGE, function () {\n            this.trigger(EVENT_CHANGE);\n        }.bind(this));\n        this._selections = {};\n    }\n    EventDispatcher.makeEventDispatcher(ProjectModel.prototype);\n\n    /**\n     * @type {Directory}\n     *\n     * The root Directory object for the project.\n     */\n    ProjectModel.prototype.projectRoot = null;\n\n    /**\n     * @private\n     * @type {FileTreeViewModel}\n     *\n     * The view model for this project.\n     */\n    ProjectModel.prototype._viewModel = null;\n\n    /**\n     * @private\n     * @type {string}\n     *\n     * Encoded URL\n     * @see {@link ProjectModel#getBaseUrl}, {@link ProjectModel#setBaseUrl}\n     */\n    ProjectModel.prototype._projectBaseUrl = \"\";\n\n    /**\n     * @private\n     * @type {{selected: ?string, context: ?string, previousContext: ?string, rename: ?Object}}\n     *\n     * Keeps track of selected files, context, previous context and files\n     * that are being renamed or created.\n     */\n    ProjectModel.prototype._selections = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     *\n     * Flag to store whether the file tree has focus.\n     */\n    ProjectModel.prototype._focused = true;\n\n    /**\n     * @private\n     * @type {string}\n     *\n     * Current file path being viewed.\n     */\n    ProjectModel.prototype._currentPath = null;\n\n    /**\n     * @private\n     * @type {?$.Promise.<Array<File>>}\n     *\n     * A promise that is resolved with an array of all project files. Used by\n     * ProjectManager.getAllFiles().\n     */\n    ProjectModel.prototype._allFilesCachePromise = null;\n\n    /**\n     * Sets whether the file tree is focused or not.\n     *\n     * @param {boolean} focused True if the file tree has the focus.\n     */\n    ProjectModel.prototype.setFocused = function (focused) {\n        this._focused = focused;\n        if (!focused) {\n            this.setSelected(null);\n        }\n    };\n\n    /**\n     * Sets the width of the selection bar.\n     *\n     * @param {int} width New width\n     */\n    ProjectModel.prototype.setSelectionWidth = function (width) {\n        this._viewModel.setSelectionWidth(width);\n    };\n\n    /**\n     * Tracks the scroller position.\n     *\n     * @param {int} scrollWidth Width of the tree container\n     * @param {int} scrollTop Top of scroll position\n     * @param {int} scrollLeft Left of scroll position\n     * @param {int} offsetTop Top of scroller element\n     */\n    ProjectModel.prototype.setScrollerInfo = function (scrollWidth, scrollTop, scrollLeft, offsetTop) {\n        this._viewModel.setSelectionScrollerInfo(scrollWidth, scrollTop, scrollLeft, offsetTop);\n    };\n\n    /**\n     * Returns the encoded Base URL of the currently loaded project, or empty string if no project\n     * is open (during startup, or running outside of app shell).\n     * @return {String}\n     */\n    ProjectModel.prototype.getBaseUrl = function getBaseUrl() {\n        return this._projectBaseUrl;\n    };\n\n    /**\n     * Sets the encoded Base URL of the currently loaded project.\n     * @param {String}\n     */\n    ProjectModel.prototype.setBaseUrl = function setBaseUrl(projectBaseUrl) {\n        // Ensure trailing slash to be consistent with projectRoot.fullPath\n        // so they're interchangable (i.e. easy to convert back and forth)\n        if (projectBaseUrl.length > 0 && projectBaseUrl[projectBaseUrl.length - 1] !== \"/\") {\n            projectBaseUrl += \"/\";\n        }\n\n        this._projectBaseUrl = projectBaseUrl;\n        return projectBaseUrl;\n    };\n\n    /**\n     * Returns true if absPath lies within the project, false otherwise.\n     * Does not support paths containing \"..\"\n     *\n     * @param {string|FileSystemEntry} absPathOrEntry\n     * @return {boolean}\n     */\n    ProjectModel.prototype.isWithinProject = function isWithinProject(absPathOrEntry) {\n        var absPath = absPathOrEntry.fullPath || absPathOrEntry;\n        return (this.projectRoot && absPath.indexOf(this.projectRoot.fullPath) === 0);\n    };\n\n    /**\n     * If absPath lies within the project, returns a project-relative path. Else returns absPath\n     * unmodified.\n     * Does not support paths containing \"..\"\n     *\n     * @param {!string} absPath\n     * @return {!string}\n     */\n    ProjectModel.prototype.makeProjectRelativeIfPossible = function makeProjectRelativeIfPossible(absPath) {\n        if (absPath && this.isWithinProject(absPath)) {\n            return absPath.slice(this.projectRoot.fullPath.length);\n        }\n        return absPath;\n    };\n\n    /**\n     * Returns a valid directory within the project, either the path (or Directory object)\n     * provided or the project root.\n     *\n     * @param {string|Directory} path Directory path to verify against the project\n     * @return {string} A directory path within the project.\n     */\n    ProjectModel.prototype.getDirectoryInProject = function (path) {\n        if (path && typeof path === \"string\") {\n            if (_.last(path) !== \"/\") {\n                path += \"/\";\n            }\n        } else if (path && path.isDirectory) {\n            path = path.fullPath;\n        } else {\n            path = null;\n        }\n\n        if (!path || (typeof path !== \"string\") || !this.isWithinProject(path)) {\n            path = this.projectRoot.fullPath;\n        }\n        return path;\n    };\n\n    /**\n     * @private\n     *\n     * Returns a promise that resolves with a cached copy of all project files.\n     * Used by ProjectManager.getAllFiles(). Ensures that at most one un-cached\n     * directory traversal is active at a time, which is useful at project load\n     * time when watchers (and hence filesystem-level caching) has not finished\n     * starting up. The cache is cleared on every filesystem change event, and\n     * also on project load and unload.\n     *\n     * @param {boolean} true to sort files by their paths\n     * @return {$.Promise.<Array.<File>>}\n     */\n    ProjectModel.prototype._getAllFilesCache = function _getAllFilesCache(sort) {\n        if (!this._allFilesCachePromise) {\n            var deferred = new $.Deferred(),\n                allFiles = [],\n                allFilesVisitor = function (entry) {\n                    if (shouldIndex(entry)) {\n                        if (entry.isFile) {\n                            allFiles.push(entry);\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n\n            this._allFilesCachePromise = deferred.promise();\n\n            var projectIndexTimer = PerfUtils.markStart(\"Creating project files cache: \" +\n                                                        this.projectRoot.fullPath),\n                options = {\n                    sortList: sort\n                };\n\n            this.projectRoot.visit(allFilesVisitor, options, function (err) {\n                if (err) {\n                    PerfUtils.finalizeMeasurement(projectIndexTimer);\n                    deferred.reject(err);\n                } else {\n                    PerfUtils.addMeasurement(projectIndexTimer);\n                    deferred.resolve(allFiles);\n                }\n            }.bind(this));\n        }\n\n        return this._allFilesCachePromise;\n    };\n\n    /**\n     * Returns an Array of all files for this project, optionally including\n     * files additional files provided. Files are filtered out by shouldShow().\n     *\n     * @param {function (File, number):boolean=} filter Optional function to filter\n     *          the file list (does not filter directory traversal). API matches Array.filter().\n     * @param {Array.<File>=} additionalFiles Additional files to include (for example, the WorkingSet)\n     *          Only adds files that are *not* under the project root or untitled documents.\n     * @param {boolean} true to sort files by their paths\n     *\n     * @return {$.Promise} Promise that is resolved with an Array of File objects.\n     */\n    ProjectModel.prototype.getAllFiles = function getAllFiles(filter, additionalFiles, sort) {\n        // The filter and includeWorkingSet params are both optional.\n        // Handle the case where filter is omitted but includeWorkingSet is\n        // specified.\n        if (additionalFiles === undefined && typeof (filter) !== \"function\") {\n            additionalFiles = filter;\n            filter = null;\n        }\n\n        var filteredFilesDeferred = new $.Deferred();\n\n        // First gather all files in project proper\n        // Note that with proper promises we may be able to fix this so that we're not doing this\n        // anti-pattern of creating a separate deferred rather than just chaining off of the promise\n        // from _getAllFilesCache\n        this._getAllFilesCache(sort).done(function (result) {\n            // Add working set entries, if requested\n            if (additionalFiles) {\n                additionalFiles.forEach(function (file) {\n                    if (result.indexOf(file) === -1 && !(file instanceof InMemoryFile)) {\n                        result.push(file);\n                    }\n                });\n            }\n\n            // Filter list, if requested\n            if (filter) {\n                result = result.filter(filter);\n            }\n\n            // If a done handler attached to the returned filtered files promise\n            // throws an exception that isn't handled here then it will leave\n            // _allFilesCachePromise in an inconsistent state such that no\n            // additional done handlers will ever be called!\n            try {\n                filteredFilesDeferred.resolve(result);\n            } catch (e) {\n                console.error(\"Unhandled exception in getAllFiles handler: \" + e, e.stack);\n            }\n        }).fail(function (err) {\n            try {\n                filteredFilesDeferred.reject(err);\n            } catch (e) {\n                console.error(\"Unhandled exception in getAllFiles handler: \" + e, e.stack);\n            }\n        });\n\n        return filteredFilesDeferred.promise();\n    };\n\n    /**\n     * @private\n     *\n     * Resets the all files cache.\n     */\n    ProjectModel.prototype._resetCache = function _resetCache() {\n        this._allFilesCachePromise = null;\n    };\n\n    /**\n     * Sets the project root (effectively resetting this ProjectModel).\n     *\n     * @param {Directory} projectRoot new project root\n     * @return {$.Promise} resolved when the project root has been updated\n     */\n    ProjectModel.prototype.setProjectRoot = function (projectRoot) {\n        this.projectRoot = projectRoot;\n        this._resetCache();\n        this._viewModel._rootChanged();\n\n        var d = new $.Deferred(),\n            self = this;\n\n        projectRoot.getContents(function (err, contents) {\n            if (err) {\n                d.reject(err);\n            } else {\n                self._viewModel.setDirectoryContents(\"\", contents);\n                d.resolve();\n            }\n        });\n        return d.promise();\n    };\n\n    /**\n     * @private\n     *\n     * Gets the contents of a directory at the given path.\n     *\n     * @param {string} path path to retrieve\n     * @return {$.Promise} Resolved with the directory contents.\n     */\n    ProjectModel.prototype._getDirectoryContents = function (path) {\n        var d = new $.Deferred();\n        FileSystem.getDirectoryForPath(path).getContents(function (err, contents) {\n            if (err) {\n                d.reject(err);\n            } else {\n                d.resolve(contents);\n            }\n        });\n        return d.promise();\n    };\n\n    /**\n     * Opens or closes the given directory in the file tree.\n     *\n     * @param {string} path Path to open\n     * @param {boolean} open `true` to open the path\n     * @return {$.Promise} resolved when the path has been opened.\n     */\n    ProjectModel.prototype.setDirectoryOpen = function (path, open) {\n        var projectRelative = this.makeProjectRelativeIfPossible(path),\n            needsLoading    = !this._viewModel.isPathLoaded(projectRelative),\n            d               = new $.Deferred(),\n            self            = this;\n\n        function onSuccess(contents) {\n            // Update the view model\n            if (contents) {\n                self._viewModel.setDirectoryContents(projectRelative, contents);\n            }\n\n            if (open) {\n                self._viewModel.openPath(projectRelative);\n                if (self._focused) {\n                    var currentPathInProject = self.makeProjectRelativeIfPossible(self._currentPath);\n                    if (self._viewModel.isFilePathVisible(currentPathInProject)) {\n                        self.setSelected(self._currentPath, true);\n                    } else {\n                        self.setSelected(null);\n                    }\n                }\n            } else {\n                self._viewModel.setDirectoryOpen(projectRelative, false);\n                var selected = self._selections.selected;\n                if (selected) {\n                    var relativeSelected = self.makeProjectRelativeIfPossible(selected);\n                    if (!self._viewModel.isFilePathVisible(relativeSelected)) {\n                        self.setSelected(null);\n                    }\n                }\n            }\n\n            d.resolve();\n        }\n\n        // If the view model doesn't have the data it needs, we load it now, otherwise we can just\n        // manage the selection and resovle the promise.\n        if (open && needsLoading) {\n            var parentDirectory = FileUtils.getDirectoryPath(FileUtils.stripTrailingSlash(path));\n            this.setDirectoryOpen(parentDirectory, true).then(function () {\n                self._getDirectoryContents(path).then(onSuccess).fail(function (err) {\n                    d.reject(err);\n                });\n            }, function (err) {\n                d.reject(err);\n            });\n        } else {\n            onSuccess();\n        }\n\n        return d.promise();\n    };\n\n    /**\n     * Shows the given path in the tree and selects it if it's a file. Any intermediate directories\n     * will be opened and a promise is returned to show when the entire operation is complete.\n     *\n     * @param {string|File|Directory} path full path to the file or directory\n     * @return {$.Promise} promise resolved when the path is shown\n     */\n    ProjectModel.prototype.showInTree = function (path) {\n        var d = new $.Deferred();\n        path = _getPathFromFSObject(path);\n\n        if (!this.isWithinProject(path)) {\n            return d.resolve().promise();\n        }\n\n        var parentDirectory = FileUtils.getDirectoryPath(path),\n            self = this;\n        this.setDirectoryOpen(parentDirectory, true).then(function () {\n            if (_pathIsFile(path)) {\n                self.setSelected(path);\n            }\n            d.resolve();\n        }, function (err) {\n            d.reject(err);\n        });\n        return d.promise();\n    };\n\n    /**\n     * Selects the given path in the file tree and opens the file (unless doNotOpen is specified).\n     * Directories will not be selected.\n     *\n     * When the selection changes, any rename operation that is currently underway will be completed.\n     *\n     * @param {string} path full path to the file being selected\n     * @param {boolean} doNotOpen `true` if the file should not be opened.\n     */\n    ProjectModel.prototype.setSelected = function (path, doNotOpen) {\n        path = _getPathFromFSObject(path);\n\n        // Directories are not selectable\n        if (!_pathIsFile(path)) {\n            return;\n        }\n\n        var oldProjectPath = this.makeProjectRelativeIfPossible(this._selections.selected),\n            pathInProject = this.makeProjectRelativeIfPossible(path);\n\n        if (path && !this._viewModel.isFilePathVisible(pathInProject)) {\n            path = null;\n            pathInProject = null;\n        }\n\n        this.performRename();\n\n        this._viewModel.moveMarker(\"selected\", oldProjectPath, pathInProject);\n        if (this._selections.context) {\n            this._viewModel.moveMarker(\"context\", this.makeProjectRelativeIfPossible(this._selections.context), null);\n            delete this._selections.context;\n        }\n\n        var previousSelection = this._selections.selected;\n        this._selections.selected = path;\n\n        if (path) {\n            if (!doNotOpen) {\n                this.trigger(EVENT_SHOULD_SELECT, {\n                    path: path,\n                    previousPath: previousSelection,\n                    hadFocus: this._focused\n                });\n            }\n\n            this.trigger(EVENT_SHOULD_FOCUS);\n        }\n    };\n\n    /**\n     * Gets the currently selected file or directory.\n     *\n     * @return {FileSystemEntry} the filesystem object for the currently selected file\n     */\n    ProjectModel.prototype.getSelected = function () {\n        return _getFSObject(this._selections.selected);\n    };\n\n    /**\n     * Keeps track of which file is currently being edited.\n     *\n     * @param {File|string} curFile Currently edited file.\n     */\n    ProjectModel.prototype.setCurrentFile = function (curFile) {\n        this._currentPath = _getPathFromFSObject(curFile);\n    };\n\n    /**\n     * Adds the file at the given path to the Working Set and selects it there.\n     *\n     * @param {string} path full path of file to open in Working Set\n     */\n    ProjectModel.prototype.selectInWorkingSet = function (path) {\n        this.performRename();\n        this.trigger(EVENT_SHOULD_SELECT, {\n            path: path,\n            add: true\n        });\n    };\n\n    /**\n     * Sets the context (for context menu operations) to the given path. This is independent from the\n     * open/selected file.\n     *\n     * @param {string} path full path of file or directory to which the context should be setBaseUrl\n     * @param {boolean} _doNotRename True if this context change should not cause a rename operation to finish. This is a special case that goes with context menu handling.\n     * @param {boolean} _saveContext True if the current context should be saved (see comment below)\n     */\n    ProjectModel.prototype.setContext = function (path, _doNotRename, _saveContext) {\n        // This bit is not ideal: when the user right-clicks on an item in the file tree\n        // and there is already a context menu up, the FileTreeView sends a signal to set the\n        // context to the new element but the PopupManager follows that with a message that it's\n        // closing the context menu (because it closes the previous one and then opens the new\n        // one.) This timing means that we need to provide some special case handling here.\n        if (_saveContext) {\n            if (!path) {\n                this._selections.previousContext = this._selections.context;\n            } else {\n                this._selections.previousContext = path;\n            }\n        } else {\n            delete this._selections.previousContext;\n        }\n\n        path = _getPathFromFSObject(path);\n\n        if (!_doNotRename) {\n            this.performRename();\n        }\n        var currentContext = this._selections.context;\n        this._selections.context = path;\n        this._viewModel.moveMarker(\"context\", this.makeProjectRelativeIfPossible(currentContext),\n                                   this.makeProjectRelativeIfPossible(path));\n    };\n\n    /**\n     * Restores the context to the last non-null context. This is specifically here to handle\n     * the sequence of messages that we get from the project context menu.\n     */\n    ProjectModel.prototype.restoreContext = function () {\n        if (this._selections.previousContext) {\n            this.setContext(this._selections.previousContext);\n        }\n    };\n\n    /**\n     * Gets the currently selected context.\n     *\n     * @return {FileSystemEntry} filesystem object for the context file or directory\n     */\n    ProjectModel.prototype.getContext = function () {\n        return _getFSObject(this._selections.context);\n    };\n\n    /**\n     * Starts a rename operation for the file or directory at the given path. If the path is\n     * not provided, the current context is used.\n     *\n     * If a rename operation is underway, it will be completed automatically.\n     *\n     * The Promise returned is resolved with an object with a `newPath` property with the renamed path. If the user cancels the operation, the promise is resolved with the value RENAME_CANCELLED.\n     *\n     * @param {string=} path optional path to start renaming\n     * @param {boolean=} isMoved optional flag which indicates whether the entry is being moved instead of renamed\n     * @return {$.Promise} resolved when the operation is complete.\n     */\n    ProjectModel.prototype.startRename = function (path, isMoved) {\n        var d = new $.Deferred();\n        path = _getPathFromFSObject(path);\n        if (!path) {\n            path = this._selections.context;\n            if (!path) {\n                return d.resolve().promise();\n            }\n        }\n\n        if (this._selections.rename && this._selections.rename.path === path) {\n            return d.resolve().promise();\n        }\n\n        if (!this.isWithinProject(path)) {\n            return d.reject({\n                type: ERROR_NOT_IN_PROJECT,\n                isFolder: !_pathIsFile(path),\n                fullPath: path\n            }).promise();\n        }\n\n        var projectRelativePath = this.makeProjectRelativeIfPossible(path);\n\n        if (!this._viewModel.isFilePathVisible(projectRelativePath)) {\n            this.showInTree(path);\n        }\n\n        if (!isMoved) {\n            if (path !== this._selections.context) {\n                this.setContext(path);\n            } else {\n                this.performRename();\n            }\n\n            this._viewModel.moveMarker(\"rename\", null,\n                projectRelativePath);\n        }\n        this._selections.rename = {\n            deferred: d,\n            type: FILE_RENAMING,\n            path: path,\n            newPath: path\n        };\n        return d.promise();\n    };\n\n    /**\n     * Sets the new value for the rename operation that is in progress (started previously with a call\n     * to `startRename`).\n     *\n     * @param {string} newPath new path for the file or directory being renamed\n     */\n    ProjectModel.prototype.setRenameValue = function (newPath) {\n        if (!this._selections.rename) {\n            return;\n        }\n        this._selections.rename.newPath = newPath;\n    };\n\n    /**\n     * Cancels the rename operation that is in progress. This resolves the original promise with\n     * a RENAME_CANCELLED value.\n     */\n    ProjectModel.prototype.cancelRename = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo) {\n            return;\n        }\n\n        // File creation is a special case.\n        if (renameInfo.type === FILE_CREATING) {\n            this._cancelCreating();\n            return;\n        }\n\n        this._viewModel.moveMarker(\"rename\", this.makeProjectRelativeIfPossible(renameInfo.path), null);\n        renameInfo.deferred.resolve(RENAME_CANCELLED);\n        delete this._selections.rename;\n        this.setContext(null);\n    };\n\n    /**\n     * @private\n     *\n     * Renames the item at the old path to the new name provided.\n     *\n     * @param {string} oldPath full path to the current location of file or directory (should include trailing slash for directory)\n     * @param {string} newPath full path to the new location of the file or directory\n     * @param {string} newName new name for the file or directory\n     */\n    ProjectModel.prototype._renameItem = function (oldPath, newPath, newName) {\n        const result = new $.Deferred();\n        const isFolder = !_pathIsFile(oldPath);\n        const self = this;\n\n        if (oldPath === newPath) {\n            result.resolve();\n        } else if (!isValidFilename(newName)) {\n            result.reject(ERROR_INVALID_FILENAME);\n        } else {\n            var entry = isFolder ? FileSystem.getDirectoryForPath(oldPath) : FileSystem.getFileForPath(oldPath);\n            self.trigger(EVENT_FS_RENAME_STARTED);\n            entry.rename(newPath, function (err) {\n                self.trigger(EVENT_FS_RENAME_END);\n                if (err) {\n                    result.reject(err);\n                } else {\n                    result.resolve();\n                }\n            });\n        }\n\n        return result.promise();\n    };\n\n    /**\n     * Completes the rename operation that is in progress.\n     */\n    ProjectModel.prototype.performRename = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo) {\n            return;\n        }\n        var oldPath         = renameInfo.path,\n            isFolder        = renameInfo.isFolder || !_pathIsFile(oldPath),\n            oldProjectPath  = this.makeProjectRelativeIfPossible(oldPath),\n\n            // To get the parent directory, we need to strip off the trailing slash on a directory name\n            parentDirectory = FileUtils.getDirectoryPath(isFolder ? FileUtils.stripTrailingSlash(oldPath) : oldPath),\n            oldName         = FileUtils.getBaseName(oldPath),\n            newPath         = renameInfo.newPath,\n            newName         = FileUtils.getBaseName(newPath),\n            viewModel       = this._viewModel,\n            self            = this;\n\n        if (renameInfo.type !== FILE_CREATING && oldPath === newPath) {\n            this.cancelRename();\n            return;\n        }\n\n        if (isFolder && _.last(newPath) !== \"/\") {\n            newPath += \"/\";\n        }\n\n        delete this._selections.rename;\n        delete this._selections.context;\n\n        viewModel.moveMarker(\"rename\", oldProjectPath, null);\n        viewModel.moveMarker(\"context\", oldProjectPath, null);\n        viewModel.moveMarker(\"creating\", oldProjectPath, null);\n\n        function finalizeRename() {\n            viewModel.renameItem(oldProjectPath, self.makeProjectRelativeIfPossible(newPath));\n            if (self._selections.selected && self._selections.selected.indexOf(oldPath) === 0) {\n                self._selections.selected = newPath + self._selections.selected.slice(oldPath.length);\n                self.setCurrentFile(newPath);\n            }\n        }\n\n        if (renameInfo.type === FILE_CREATING) {\n            this.createAtPath(newPath).done(function (entry) {\n                finalizeRename();\n                renameInfo.deferred.resolve(entry);\n            }).fail(function (error) {\n                self._viewModel.deleteAtPath(self.makeProjectRelativeIfPossible(renameInfo.path));\n                renameInfo.deferred.reject(error);\n            });\n        } else {\n            this._renameItem(oldPath, newPath, newName).then(function () {\n                finalizeRename();\n                renameInfo.deferred.resolve({\n                    newPath: newPath\n                });\n            }).fail(function (errorType) {\n                var errorInfo = {\n                    type: errorType,\n                    isFolder: isFolder,\n                    fullPath: oldPath\n                };\n                renameInfo.deferred.reject(errorInfo);\n            });\n        }\n    };\n\n    /**\n     * Creates a file or folder at the given path. Folder paths should have a trailing slash.\n     *\n     * If an error comes up during creation, the ERROR_CREATION event is triggered.\n     *\n     * @param {string} path full path to file or folder to create\n     * @return {$.Promise} resolved when creation is complete\n     */\n    ProjectModel.prototype.createAtPath = function (path) {\n        var isFolder  = !_pathIsFile(path),\n            name      = FileUtils.getBaseName(path),\n            self      = this;\n\n        return doCreate(path, isFolder).done(function (entry) {\n            if (!isFolder) {\n                self.selectInWorkingSet(entry.fullPath);\n            }\n        }).fail(function (error) {\n            self.trigger(ERROR_CREATION, {\n                type: error,\n                name: name,\n                isFolder: isFolder\n            });\n        });\n    };\n\n    /**\n     * Starts creating a file or folder with the given name in the given directory.\n     *\n     * The Promise returned is resolved with an object with a `newPath` property with the renamed path. If the user cancels the operation, the promise is resolved with the value RENAME_CANCELLED.\n     *\n     * @param {string} basedir directory that should contain the new entry\n     * @param {string} newName initial name for the new entry (the user can rename it)\n     * @param {boolean} isFolder `true` if the entry being created is a folder\n     * @return {$.Promise} resolved when the user is done creating the entry.\n     */\n    ProjectModel.prototype.startCreating = function (basedir, newName, isFolder) {\n        this.performRename();\n        var d = new $.Deferred(),\n            self = this;\n\n        this.setDirectoryOpen(basedir, true).then(function () {\n            self._viewModel.createPlaceholder(self.makeProjectRelativeIfPossible(basedir), newName, isFolder);\n            var promise = self.startRename(basedir + newName);\n            self._selections.rename.type = FILE_CREATING;\n            if (isFolder) {\n                self._selections.rename.isFolder = isFolder;\n            }\n            promise.then(d.resolve).fail(d.reject);\n        }).fail(function (err) {\n            d.reject(err);\n        });\n        return d.promise();\n    };\n\n    /**\n     * Cancels the creation process that is underway. The original promise returned will be resolved with the\n     * RENAME_CANCELLED value. The temporary entry added to the file tree will be deleted.\n     */\n    ProjectModel.prototype._cancelCreating = function () {\n        var renameInfo = this._selections.rename;\n        if (!renameInfo || renameInfo.type !== FILE_CREATING) {\n            return;\n        }\n        this._viewModel.deleteAtPath(this.makeProjectRelativeIfPossible(renameInfo.path));\n        renameInfo.deferred.resolve(RENAME_CANCELLED);\n        delete this._selections.rename;\n        this.setContext(null);\n    };\n\n    /**\n     * Sets the `sortDirectoriesFirst` option for the file tree view.\n     *\n     * @param {boolean} True if directories should appear first\n     */\n    ProjectModel.prototype.setSortDirectoriesFirst = function (sortDirectoriesFirst) {\n        this._viewModel.setSortDirectoriesFirst(sortDirectoriesFirst);\n    };\n\n    /**\n     * Gets an array of arrays where each entry of the top-level array has an array\n     * of paths that are at the same depth in the tree. All of the paths are full paths.\n     *\n     * @return {Array.<Array.<string>>} Array of array of full paths, organized by depth in the tree.\n     */\n    ProjectModel.prototype.getOpenNodes = function () {\n        return this._viewModel.getOpenNodes(this.projectRoot.fullPath);\n    };\n\n    /**\n     * Reopens a set of nodes in the tree by full path.\n     * @param {Array.<Array.<string>>} nodesByDepth An array of arrays of node ids to reopen. The ids within\n     *     each sub-array are reopened in parallel, and the sub-arrays are reopened in order, so they should\n     *     be sorted by depth within the tree.\n     * @return {$.Deferred} A promise that will be resolved when all nodes have been fully\n     *     reopened.\n     */\n    ProjectModel.prototype.reopenNodes = function (nodesByDepth) {\n        var deferred = new $.Deferred();\n\n        if (!nodesByDepth || nodesByDepth.length === 0) {\n            // All paths are opened and fully rendered.\n            return deferred.resolve().promise();\n        }\n        var self = this;\n        return Async.doSequentially(nodesByDepth, function (toOpenPaths) {\n            return Async.doInParallel(\n                    toOpenPaths,\n                    function (path) {\n                        return self._getDirectoryContents(path).then(function (contents) {\n                            var relative = self.makeProjectRelativeIfPossible(path);\n                            self._viewModel.setDirectoryContents(relative, contents);\n                            self._viewModel.setDirectoryOpen(relative, true);\n                        });\n                    },\n                    false\n                );\n        });\n\n    };\n\n    /**\n     * Clears caches and refreshes the contents of the tree.\n     *\n     * @return {$.Promise} resolved when the tree has been refreshed\n     */\n    ProjectModel.prototype.refresh = function () {\n        var projectRoot = this.projectRoot,\n            openNodes   = this.getOpenNodes(),\n            self        = this,\n            selections  = this._selections,\n            viewModel   = this._viewModel,\n            deferred    = new $.Deferred();\n\n        this.setProjectRoot(projectRoot).then(function () {\n            self.reopenNodes(openNodes).then(function () {\n                if (selections.selected) {\n                    viewModel.moveMarker(\"selected\", null, self.makeProjectRelativeIfPossible(selections.selected));\n                }\n\n                if (selections.context) {\n                    viewModel.moveMarker(\"context\", null, self.makeProjectRelativeIfPossible(selections.context));\n                }\n\n                if (selections.rename) {\n                    viewModel.moveMarker(\"rename\", null, self.makeProjectRelativeIfPossible(selections.rename));\n                }\n\n                deferred.resolve();\n            });\n        });\n\n        return deferred.promise();\n    };\n\n    /**\n     * Handles filesystem change events and prepares the update for the view model.\n     *\n     * @param {?(File|Directory)} entry File or Directory changed\n     * @param {Array.<FileSystemEntry>=} added If entry is a Directory, contains zero or more added children\n     * @param {Array.<FileSystemEntry>=} removed If entry is a Directory, contains zero or more removed\n     */\n    ProjectModel.prototype.handleFSEvent = function (entry, added, removed) {\n        this._resetCache();\n\n        if (!entry) {\n            this.refresh();\n            return;\n        }\n\n        if (!this.isWithinProject(entry)) {\n            return;\n        }\n\n        var changes = {},\n            self = this;\n\n        if (entry.isFile) {\n            changes.changed = [\n                this.makeProjectRelativeIfPossible(entry.fullPath)\n            ];\n        } else {\n            // Special case: a directory passed in without added and removed values\n            // needs to be updated.\n            if (!added && !removed) {\n                entry.getContents(function (err, contents) {\n                    if (err) {\n                        console.error(\"Unexpected error refreshing file tree for directory \" + entry.fullPath + \": \" + err, err.stack);\n                        return;\n                    }\n                    self._viewModel.setDirectoryContents(self.makeProjectRelativeIfPossible(entry.fullPath), contents);\n                });\n\n                // Exit early because we can't update the viewModel until we get the directory contents.\n                return;\n            }\n        }\n\n        if (added) {\n            changes.added = added.map(function (entry) {\n                return self.makeProjectRelativeIfPossible(entry.fullPath);\n            });\n        }\n\n        if (removed) {\n            if (this._selections.selected &&\n                    _.find(removed, { fullPath: this._selections.selected })) {\n                this.setSelected(null);\n            }\n\n            if (this._selections.rename &&\n                    _.find(removed, { fullPath: this._selections.rename.path })) {\n                this.cancelRename();\n            }\n\n            if (this._selections.context &&\n                    _.find(removed, { fullPath: this._selections.context })) {\n                this.setContext(null);\n            }\n            changes.removed = removed.map(function (entry) {\n                return self.makeProjectRelativeIfPossible(entry.fullPath);\n            });\n        }\n\n        this._viewModel.processChanges(changes);\n    };\n\n    /**\n     * Closes the directory at path and recursively closes all of its children.\n     *\n     * @param {string} path Path of subtree to close\n     */\n    ProjectModel.prototype.closeSubtree = function (path) {\n        this._viewModel.closeSubtree(this.makeProjectRelativeIfPossible(path));\n    };\n\n    /**\n     * Toggle the open state of subdirectories.\n     * @param {!string}  path        parent directory\n     * @param {boolean} openOrClose  true to open directory, false to close\n     * @return {$.Promise} promise resolved when the directories are open\n     */\n    ProjectModel.prototype.toggleSubdirectories = function (path, openOrClose) {\n        var self = this,\n            d = new $.Deferred();\n\n        this.setDirectoryOpen(path, true).then(function () {\n            var projectRelativePath = self.makeProjectRelativeIfPossible(path),\n                childNodes = self._viewModel.getChildDirectories(projectRelativePath);\n\n            Async.doInParallel(childNodes, function (node) {\n                return self.setDirectoryOpen(path + node, openOrClose);\n            }, true).then(function () {\n                d.resolve();\n            }, function (err) {\n                d.reject(err);\n            });\n        });\n\n        return d.promise();\n    };\n\n    /**\n     * Although Brackets is generally standardized on folder paths with a trailing \"/\", some APIs here\n     * receive project paths without \"/\" due to legacy preference storage formats, etc.\n     * @param {!string} fullPath  Path that may or may not end in \"/\"\n     * @return {!string} Path that ends in \"/\"\n     */\n    function _ensureTrailingSlash(fullPath) {\n        if (_pathIsFile(fullPath)) {\n            return fullPath + \"/\";\n        }\n        return fullPath;\n    }\n\n    /**\n     * @private\n     *\n     * Returns the full path to the welcome project, which we open on first launch.\n     *\n     * @param {string} sampleUrl URL for getting started project\n     * @param {string} initialPath Path to Brackets directory (see {@link FileUtils::#getNativeBracketsDirectoryPath})\n     * @return {!string} fullPath reference\n     */\n    function _getWelcomeProjectPath(sampleUrl, initialPath) {\n        if (sampleUrl) {\n            // Back up one more folder. The samples folder is assumed to be at the same level as\n            // the src folder, and the sampleUrl is relative to the samples folder.\n            initialPath = initialPath.substr(0, initialPath.lastIndexOf(\"/\")) + \"/samples/\" + sampleUrl;\n        }\n\n        return _ensureTrailingSlash(initialPath); // paths above weren't canonical\n    }\n\n    /**\n     * @private\n     *\n     * Adds the path to the list of welcome projects we've ever seen, if not on the list already.\n     *\n     * @param {string} path Path to possibly add\n     * @param {Array.<string>=} currentProjects Array of current welcome projects\n     * @return {Array.<string>} New array of welcome projects with the additional project added\n     */\n    function _addWelcomeProjectPath(path, currentProjects) {\n        var pathNoSlash = FileUtils.stripTrailingSlash(path);  // \"welcomeProjects\" pref has standardized on no trailing \"/\"\n\n        var newProjects;\n\n        if (currentProjects) {\n            newProjects = _.clone(currentProjects);\n        } else {\n            newProjects = [];\n        }\n\n        if (newProjects.indexOf(pathNoSlash) === -1) {\n            newProjects.push(pathNoSlash);\n        }\n        return newProjects;\n    }\n\n    /**\n     * Returns true if the given path is the same as one of the welcome projects we've previously opened,\n     * or the one for the current build.\n     *\n     * @param {string} path Path to check to see if it's a welcome project\n     * @param {string} welcomeProjectPath Current welcome project path\n     * @param {Array.<string>=} welcomeProjects All known welcome projects\n     */\n    function _isWelcomeProjectPath(path, welcomeProjectPath, welcomeProjects) {\n        if (path === welcomeProjectPath) {\n            return true;\n        }\n\n        // No match on the current path, and it's not a match if there are no previously known projects\n        if (!welcomeProjects) {\n            return false;\n        }\n\n        var pathNoSlash = FileUtils.stripTrailingSlash(path);  // \"welcomeProjects\" pref has standardized on no trailing \"/\"\n        return welcomeProjects.indexOf(pathNoSlash) !== -1;\n    }\n\n    exports._getWelcomeProjectPath  = _getWelcomeProjectPath;\n    exports._addWelcomeProjectPath  = _addWelcomeProjectPath;\n    exports._isWelcomeProjectPath   = _isWelcomeProjectPath;\n    exports._ensureTrailingSlash    = _ensureTrailingSlash;\n    exports._shouldShowName         = _shouldShowName;\n    exports._invalidChars           = \"? * | : / < > \\\\ | \\\" ..\";\n\n    exports.shouldShow              = shouldShow;\n    exports.shouldIndex             = shouldIndex;\n    exports.defaultIgnoreGlobs      = defaultIgnoreGlobs;\n    exports.isValidFilename         = isValidFilename;\n    exports.isValidPath             = isValidPath;\n    exports.EVENT_CHANGE            = EVENT_CHANGE;\n    exports.EVENT_SHOULD_SELECT     = EVENT_SHOULD_SELECT;\n    exports.EVENT_SHOULD_FOCUS      = EVENT_SHOULD_FOCUS;\n    exports.EVENT_FS_RENAME_STARTED = EVENT_FS_RENAME_STARTED;\n    exports.EVENT_FS_RENAME_END     = EVENT_FS_RENAME_END;\n    exports.ERROR_CREATION          = ERROR_CREATION;\n    exports.ERROR_INVALID_FILENAME  = ERROR_INVALID_FILENAME;\n    exports.ERROR_NOT_IN_PROJECT    = ERROR_NOT_IN_PROJECT;\n    exports.FILE_RENAMING           = FILE_RENAMING;\n    exports.FILE_CREATING           = FILE_CREATING;\n    exports.RENAME_CANCELLED        = RENAME_CANCELLED;\n    exports.doCreate                = doCreate;\n    exports.ProjectModel            = ProjectModel;\n});\n"],"file":"ProjectModel.js"}
{"version":3,"sources":["extensions/default/Phoenix-live-preview/StaticServer.js"],"names":["define","require","exports","module","BaseServer","brackets","getModule","LiveDevelopmentUtils","LiveDevelopment","LiveDevServerManager","LiveDevProtocol","marked","DocumentManager","Mustache","FileSystem","EventDispatcher","EventManager","ProjectManager","Strings","markdownHTMLTemplate","redirectionHTMLTemplate","utils","makeEventDispatcher","PHCODE_LIVE_PREVIEW_QUERY_PARAM","_staticServerInstance","$livepreviewServerIframe","setOptions","renderer","Renderer","pedantic","gfm","breaks","sanitize","smartLists","smartypants","xhtml","EVENT_GET_PHOENIX_INSTANCE_ID","StaticServer","config","baseUrl","getStaticServerBaseURLs","projectBaseURL","this","_sendInstrumentedContent","bind","call","_sendMarkdown","fullPath","requestID","getDocumentForPath","done","doc","text","getText","markdownHtml","templateVars","markdownContent","parse","BOOTSTRAP_LIB_CSS","window","parent","Phoenix","baseURL","HIGHLIGHT_JS_CSS","HIGHLIGHT_JS","GFM_CSS","html","render","messageToLivePreviewTabs","type","contents","headers","Content-Type","fail","err","console","error","_getExtension","filePath","pathSplit","split","length","_isMarkdownFile","extension","includes","toLowerCase","_getRedirectionPage","redirectURL","url","URL","searchParams","delete","getPageLoaderURL","href","getContent","eventData","logger","livePreview","log","PHOENIX_INSTANCE_ID","eventName","message","phoenixInstanceID","path","prototype","Object","create","constructor","pathToUrl","getBaseUrl","relativePath","_pathResolver","encodeURI","urlToPath","indexOf","replace","decodeURI","canServe","localPath","match","isStaticHtmlFileExt","readyToServe","$","Deferred","resolve","promise","addVirtualContentAtPath","docText","add","liveDocument","setInstrumentationEnabled","remove","removeVirtualContentAtPath","clear","_send","location","response","_nodeDomain","exec","root","pathname","data","_documentKey","_liveDocuments","virtualDocument","_virtualServingDocuments","isWithinProject","DESCRIPTION_LIVEDEV_SECURITY","isLivePreviewPopoutPage","get","getResponseData","body","getRemoteScript","file","getFileForPath","getOpenDocumentForPath","fs","readFile","BYTE_ARRAY_ENCODING","binContent","serverStarted","start","browser","isTauri","origin","attr","stop","undefined","registerEventHandler","on","_ev","event","reportError","Error","livePreviewTabs","Map","set","clientID","lastSeen","Date","TAB_HEARTBEAT_TIMEOUT","contentWindow","postMessage","setInterval","endTime","tab","keys","timeDiff","trigger","setLivePreviewTransportBridge"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2012 - present Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*global Phoenix, logger, fs */\n\ndefine(function (require, exports, module) {\n\n    const BaseServer = brackets.getModule(\"LiveDevelopment/Servers/BaseServer\").BaseServer,\n        LiveDevelopmentUtils = brackets.getModule(\"LiveDevelopment/LiveDevelopmentUtils\"),\n        LiveDevelopment    = brackets.getModule(\"LiveDevelopment/main\"),\n        LiveDevServerManager = brackets.getModule(\"LiveDevelopment/LiveDevServerManager\"),\n        LiveDevProtocol = brackets.getModule(\"LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol\"),\n        marked = brackets.getModule('thirdparty/marked.min'),\n        DocumentManager = brackets.getModule(\"document/DocumentManager\"),\n        Mustache = brackets.getModule(\"thirdparty/mustache/mustache\"),\n        FileSystem = brackets.getModule(\"filesystem/FileSystem\"),\n        EventDispatcher = brackets.getModule(\"utils/EventDispatcher\"),\n        EventManager = brackets.getModule(\"utils/EventManager\"),\n        ProjectManager = brackets.getModule(\"project/ProjectManager\"),\n        Strings = brackets.getModule(\"strings\"),\n        markdownHTMLTemplate = require(\"text!markdown.html\"),\n        redirectionHTMLTemplate = require(\"text!redirectPage.html\"),\n        utils = require('utils');\n\n    EventDispatcher.makeEventDispatcher(exports);\n    const PHCODE_LIVE_PREVIEW_QUERY_PARAM = \"phcodeLivePreview\";\n\n    let _staticServerInstance, $livepreviewServerIframe;\n\n    // see markdown advanced rendering options at https://marked.js.org/using_advanced\n    marked.setOptions({\n        renderer: new marked.Renderer(),\n        pedantic: false,\n        gfm: true,\n        breaks: false,\n        sanitize: false,\n        smartLists: true,\n        smartypants: false,\n        xhtml: false\n    });\n\n    const EVENT_GET_PHOENIX_INSTANCE_ID = 'GET_PHOENIX_INSTANCE_ID';\n    /**\n     * @constructor\n     * @extends {BaseServer}\n     * Live preview server that uses a built-in HTTP server to serve static\n     * and instrumented files.\n     *\n     * @param {!{baseUrl: string, root: string, pathResolver: function(string), nodeDomain: NodeDomain}} config\n     *    Configuration parameters for this server:\n     *        baseUrl        - Optional base URL (populated by the current project)\n     *        pathResolver   - Function to covert absolute native paths to project relative paths\n     *        root           - Native path to the project root (and base URL)\n     */\n    function StaticServer(config) {\n        config.baseUrl= LiveDevServerManager.getStaticServerBaseURLs().projectBaseURL;\n        this._sendInstrumentedContent = this._sendInstrumentedContent.bind(this);\n        BaseServer.call(this, config);\n    }\n\n    StaticServer.prototype = Object.create(BaseServer.prototype);\n    StaticServer.prototype.constructor = StaticServer;\n\n    /**\n     * Returns a URL for a given path\n     * @param {string} path Absolute path to covert to a URL\n     * @return {?string} Converts a path within the project root to a URL.\n     *  Returns null if the path is not a descendant of the project root.\n     */\n    StaticServer.prototype.pathToUrl = function (path) {\n        const baseUrl         = this.getBaseUrl(),\n            relativePath    = this._pathResolver(path);\n\n        // See if base url has been specified and path is within project\n        if (relativePath !== path) {\n            // Map to server url. Base url is already encoded, so don't encode again.\n\n            return `${baseUrl}${encodeURI(path)}`;\n        }\n\n        return null;\n    };\n\n    /**\n     * Convert a URL to a local full file path\n     * @param {string} url\n     * @return {?string} The absolute path for given URL or null if the path is\n     *  not a descendant of the project.\n     */\n    StaticServer.prototype.urlToPath = function (url) {\n        let path,\n            baseUrl = \"\";\n\n        baseUrl = this.getBaseUrl();\n\n        if (baseUrl !== \"\" && url.indexOf(baseUrl) === 0) {\n            // Use base url to translate to local file path.\n            // Need to use encoded project path because it's decoded below.\n            path = url.replace(baseUrl, \"\");\n\n            return decodeURI(path);\n        }\n\n        return null;\n    };\n\n    /**\n     * Determines whether we can serve local file.\n     * @param {string} localPath A local path to file being served.\n     * @return {boolean} true for yes, otherwise false.\n     */\n    StaticServer.prototype.canServe = function (localPath) {\n        // If we can't transform the local path to a project relative path,\n        // the path cannot be served\n        if (localPath === this._pathResolver(localPath)) {\n            return false;\n        }\n\n        // Url ending in \"/\" implies default file, which is usually index.html.\n        // Return true to indicate that we can serve it.\n        if (localPath.match(/\\/$/)) {\n            return true;\n        }\n\n        // FUTURE: do a MIME Type lookup on file extension\n        return LiveDevelopmentUtils.isStaticHtmlFileExt(localPath);\n    };\n\n    /**\n     * Gets the server details from the StaticServerDomain in node.\n     * The domain itself handles starting a server if necessary (when\n     * the staticServer.getServer command is called).\n     *\n     * @return {jQuery.Promise} A promise that resolves/rejects when\n     *     the server is ready/failed.\n     */\n    StaticServer.prototype.readyToServe = function () {\n        return $.Deferred().resolve().promise(); // virtual server is always assumed present in phoenix\n    };\n\n    /**\n     * This will add the given text to be served when the path is hit in server. use this to either serve a file\n     * that doesn't exist in project, or to override a given path to the contents you give.\n     */\n    StaticServer.prototype.addVirtualContentAtPath = function (path, docText) {\n        BaseServer.prototype.addVirtualContentAtPath.call(this, path, docText);\n    };\n\n    /**\n     * See BaseServer#add. StaticServer ignores documents that do not have\n     * a setInstrumentationEnabled method. Updates request filters.\n     */\n    StaticServer.prototype.add = function (liveDocument) {\n        if (liveDocument.setInstrumentationEnabled) {\n            // enable instrumentation\n            liveDocument.setInstrumentationEnabled(true);\n        }\n\n        BaseServer.prototype.add.call(this, liveDocument);\n    };\n\n    /**\n     * See BaseServer#remove. Updates request filters.\n     */\n    StaticServer.prototype.remove = function (liveDocument) {\n        BaseServer.prototype.remove.call(this, liveDocument);\n    };\n\n    /**\n     * removes path added by addVirtualContentAtPath()\n     */\n    StaticServer.prototype.removeVirtualContentAtPath = function (path) {\n        BaseServer.prototype.removeVirtualContentAtPath.call(this, path);\n    };\n\n    /**\n     * See BaseServer#clear. Updates request filters.\n     */\n    StaticServer.prototype.clear = function () {\n        BaseServer.prototype.clear.call(this);\n    };\n\n    /**\n     * @private\n     * Send HTTP response data back to the StaticServerSomain\n     */\n    StaticServer.prototype._send = function (location, response) {\n        this._nodeDomain.exec(\"writeFilteredResponse\", location.root, location.pathname, response);\n    };\n\n    function _sendMarkdown(fullPath, requestID) {\n        DocumentManager.getDocumentForPath(fullPath)\n            .done(function (doc) {\n                let text = doc.getText();\n                let markdownHtml = marked.parse(text);\n                let templateVars = {\n                    markdownContent: markdownHtml,\n                    BOOTSTRAP_LIB_CSS: `${window.parent.Phoenix.baseURL}thirdparty/bootstrap/bootstrap.min.css`,\n                    HIGHLIGHT_JS_CSS: `${window.parent.Phoenix.baseURL}thirdparty/highlight.js/styles/github.min.css`,\n                    HIGHLIGHT_JS: `${window.parent.Phoenix.baseURL}thirdparty/highlight.js/highlight.min.js`,\n                    GFM_CSS: `${window.parent.Phoenix.baseURL}thirdparty/gfm.min.css`\n                };\n                let html = Mustache.render(markdownHTMLTemplate, templateVars);\n                messageToLivePreviewTabs({\n                    type: 'REQUEST_RESPONSE',\n                    requestID, //pass along the requestID to call the appropriate callback at service worker\n                    fullPath,\n                    contents: html,\n                    headers: {'Content-Type': 'text/html'}\n                });\n            })\n            .fail(function (err) {\n                console.error(`Markdown rendering failed for ${fullPath}: `, err);\n            });\n    }\n\n    function _getExtension(filePath) {\n        filePath = filePath || '';\n        let pathSplit = filePath.split('.');\n        return pathSplit && pathSplit.length>1 ? pathSplit[pathSplit.length-1] : '';\n    }\n\n    function _isMarkdownFile(filePath) {\n        let extension = _getExtension(filePath);\n        return ['md', 'markdown'].includes(extension.toLowerCase());\n    }\n\n    /**\n     * return a page loader url after stripping the PHCODE_LIVE_PREVIEW_QUERY_PARAM\n     * \"https://phcode.live/pageLoader.html?broadcastChannel=PH-697797864197_livePreview&URL=https%3A%2...\n     * @param redirectURL\n     * @return {string}\n     * @private\n     */\n    function _getRedirectionPage(redirectURL) {\n        let url = new URL(redirectURL);\n        // strip this query param as the redirection will be done by the page loader and not the content iframe.\n        url.searchParams.delete(PHCODE_LIVE_PREVIEW_QUERY_PARAM);\n        let templateVars = {\n            redirectURL: utils.getPageLoaderURL(url.href)\n        };\n        return Mustache.render(redirectionHTMLTemplate, templateVars);\n    }\n\n    /**\n     * @private\n     * Events raised by broadcast channel from the service worker will be captured here. The service worker will ask\n     * all phoenix instances if the url to be served should be replaced with instrumented content here or served\n     * as static file from disk.\n     * @param {{hostname: string, pathname: string, port: number, root: string, id: number}} request\n     */\n    StaticServer.prototype._sendInstrumentedContent = function (data) {\n        if(data.phoenixInstanceID && data.phoenixInstanceID !== Phoenix.PHOENIX_INSTANCE_ID) {\n            return;\n        }\n        let path = this._documentKey(data.path),\n            requestID = data.requestID,\n            liveDocument = this._liveDocuments[path],\n            virtualDocument = this._virtualServingDocuments[path];\n        let contents;\n        if(!ProjectManager.isWithinProject(data.path)) {\n            console.error(\"Security issue prevented: Live preview tried to access non project resource!!!\", path);\n            messageToLivePreviewTabs({\n                type: 'REQUEST_RESPONSE',\n                requestID, //pass along the requestID\n                path,\n                contents: Strings.DESCRIPTION_LIVEDEV_SECURITY\n            });\n            return;\n        }\n\n        let url = new URL(data.url), isLivePreviewPopoutPage = false;\n        if(url.searchParams.get(PHCODE_LIVE_PREVIEW_QUERY_PARAM)) {\n            // #LIVE_PREVIEW_TAB_NAVIGATION_RACE_FIX\n            // check if this is a live preview html. If so, then if you are here, it means that users switched\n            // live preview to a different page while we are just about to serve an old live preview page that is\n            // no longer in live preview. If we just serve the raw html here, it will not have any tab navigation\n            // instrumentation on popped out tabs and live preview navigation will stop on this page. So we will\n            // use a page loader url to continue navigation.\n            isLivePreviewPopoutPage = true;\n        }\n        if (virtualDocument) {\n            // virtual document overrides takes precedence over live preview docs\n            contents = virtualDocument;\n        } else if (liveDocument && liveDocument.getResponseData) {\n            contents = liveDocument.getResponseData().body;\n            if(isLivePreviewPopoutPage && contents.indexOf(LiveDevProtocol.getRemoteScript()) === -1){\n                console.log(\"serving stale live preview with navigable url\", url);\n                contents = _getRedirectionPage(url);\n            }\n        } else {\n            const file = FileSystem.getFileForPath(data.path);\n            let doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\n            if (doc) {\n                // this file is open in some editor, so we sent the edited contents.\n                contents = doc.getText();\n                if(isLivePreviewPopoutPage){\n                    console.log(\"serving stale live preview with navigable url\", url);\n                    contents = _getRedirectionPage(url);\n                }\n            } else {\n                fs.readFile(data.path, fs.BYTE_ARRAY_ENCODING, function (error, binContent) {\n                    if(error){\n                        contents = null;\n                    }\n                    contents = binContent;\n                    messageToLivePreviewTabs({\n                        type: 'REQUEST_RESPONSE',\n                        requestID, //pass along the requestID\n                        path,\n                        contents\n                    });\n                });\n                return;\n            }\n        }\n\n        messageToLivePreviewTabs({\n            type: 'REQUEST_RESPONSE',\n            requestID, //pass along the requestID so that the appropriate callback will be hit at the service worker\n            path,\n            contents: contents\n        });\n    };\n\n    function getContent(eventData) {\n        window.logger.livePreview.log(\"Static server: \", eventData, Phoenix.PHOENIX_INSTANCE_ID);\n        if (eventData.eventName === \"GET_CONTENT\"\n            && eventData.message.phoenixInstanceID === Phoenix.PHOENIX_INSTANCE_ID) {\n            // localStorage is domain specific so when it changes in one window it changes in the other\n            if(_isMarkdownFile(eventData.message.path)){\n                _sendMarkdown(eventData.message.path, eventData.message.requestID);\n                return;\n            }\n            if(_staticServerInstance){\n                _staticServerInstance._sendInstrumentedContent(eventData.message);\n            }\n        }\n    };\n\n    let serverStarted = false;\n    /**\n     * See BaseServer#start. Starts listenting to StaticServerDomain events.\n     */\n    StaticServer.prototype.start = function () {\n        _staticServerInstance = this;\n\n        // load the hidden iframe that loads the service worker server page once. we will reuse the same server\n        // as this is a cross-origin server phcode.live, the browser will identify it as a security issue\n        // if we continuously reload the service worker loader page frequently and it will stop working.\n        if(serverStarted){\n            return;\n        }\n        if(!Phoenix.browser.isTauri) {\n            $livepreviewServerIframe = $(\"#live-preview-server-iframe\");\n            let url = LiveDevServerManager.getStaticServerBaseURLs().baseURL +\n                `?parentOrigin=${location.origin}`;\n            $livepreviewServerIframe.attr(\"src\", url);\n            serverStarted = true;\n        }\n    };\n\n    /**\n     * See BaseServer#stop. Remove event handlers from StaticServerDomain.\n     */\n    StaticServer.prototype.stop = function () {\n        _staticServerInstance = undefined;\n    };\n\n    EventManager.registerEventHandler(\"ph-liveServer\", exports);\n    exports.on(\"REPORT_ERROR\", function(_ev, event){\n        logger.reportError(new Error(event.data.message));\n    });\n    exports.on(\"GET_CONTENT\", function(_ev, event){\n        window.logger.livePreview.log(event.data);\n        getContent(event.data);\n    });\n    exports.on(EVENT_GET_PHOENIX_INSTANCE_ID, function(_ev){\n        messageToLivePreviewTabs({\n            type: 'PHOENIX_INSTANCE_ID',\n            PHOENIX_INSTANCE_ID: Phoenix.PHOENIX_INSTANCE_ID\n        });\n    });\n\n    const livePreviewTabs = new Map();\n    exports.on('TAB_ONLINE', function(_ev, event){\n        livePreviewTabs.set(event.data.message.clientID, {\n            lastSeen: new Date(),\n            URL: event.data.message.URL\n        });\n    });\n\n    // If we didn't receive heartbeat message from a tab for 5 seconds, we assume tab closed\n    const TAB_HEARTBEAT_TIMEOUT = 5000; // in millis secs\n    setInterval(()=>{\n        let endTime = new Date();\n        for(let tab of livePreviewTabs.keys()){\n            let timeDiff = endTime - livePreviewTabs.get(tab).lastSeen; // in ms\n            if(timeDiff > TAB_HEARTBEAT_TIMEOUT){\n                livePreviewTabs.delete(tab);\n                exports.trigger('BROWSER_CLOSE', { data: { message: {clientID: tab}}});\n            }\n        }\n    }, 1000);\n\n    /**\n     * The message should be and object of the form: {type, ...}. a type attribute is mandatory\n     * @param message\n     */\n    function messageToLivePreviewTabs(message) {\n        if(!message.type){\n            throw new Error('Missing type attribute to send live preview message to tabs');\n        }\n        // The embedded iframe is a trusted origin and hence we use '*'. We can alternatively use\n        // LiveDevServerManager.getStaticServerBaseURLs().origin, but there seems to be a single error on startup\n        // Most likely as we switch frequently between about:blank and the live preview server host page.\n        // Error message in console:\n        // `Failed to execute 'postMessage' on 'DOMWindow': The target origin provided ('http://localhost:8001')\n        // does not match the recipient window's origin ('http://localhost:8000').`\n        $livepreviewServerIframe && $livepreviewServerIframe[0].contentWindow.postMessage(message, '*');\n    }\n\n    LiveDevelopment.setLivePreviewTransportBridge(exports);\n    exports.StaticServer = StaticServer;\n    exports.messageToLivePreviewTabs = messageToLivePreviewTabs;\n    exports.livePreviewTabs = livePreviewTabs;\n    exports.PHCODE_LIVE_PREVIEW_QUERY_PARAM = PHCODE_LIVE_PREVIEW_QUERY_PARAM;\n});\n"],"file":"StaticServer.js"}
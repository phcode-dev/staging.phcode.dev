{"version":3,"sources":["extensions/default/Phoenix-live-preview/StaticServer.js"],"names":["define","require","exports","module","BaseServer","brackets","getModule","LiveDevelopmentUtils","LiveDevelopment","LiveDevServerManager","LiveDevProtocol","marked","DocumentManager","Mustache","FileSystem","EventDispatcher","EventManager","ProjectManager","Strings","utils","BootstrapCSSText","GithubCSSText","HilightJSText","GFMCSSText","markdownHTMLTemplate","redirectionHTMLTemplate","EVENT_GET_PHOENIX_INSTANCE_ID","EVENT_GET_CONTENT","EVENT_TAB_ONLINE","EVENT_REPORT_ERROR","EVENT_UPDATE_TITLE_ICON","makeEventDispatcher","PHCODE_LIVE_PREVIEW_QUERY_PARAM","LOADER_BROADCAST_ID","Phoenix","PHOENIX_INSTANCE_ID","navigatorChannel","BroadcastChannel","livePreviewTabs","Map","onmessage","event","window","logger","livePreview","log","type","data","set","pageLoaderID","lastSeen","Date","URL","navigationTab","LIVE_PREVIEW_MESSENGER_CHANNEL","livePreviewChannel","_sendToLivePreviewServerTabs","postMessage","_staticServerInstance","$livepreviewServerIframe","StaticServer","config","baseUrl","getStaticServerBaseURLs","projectBaseURL","this","_getInstrumentedContent","bind","call","_getMarkdown","fullPath","Promise","resolve","reject","getDocumentForPath","done","doc","text","getText","markdownHtml","templateVars","markdownContent","parse","BOOTSTRAP_LIB_CSS","HIGHLIGHT_JS_CSS","HIGHLIGHT_JS","GFM_CSS","html","render","contents","headers","Content-Type","path","fail","err","Error","_getExtension","filePath","pathSplit","split","length","_isMarkdownFile","extension","includes","toLowerCase","_getRedirectionPage","redirectURL","url","searchParams","delete","href","getContent","startsWith","_baseUrl","eventName","message","then","response","requestID","catch","console","error","clientID","reportError","trigger","setOptions","renderer","Renderer","pedantic","gfm","breaks","sanitize","smartLists","smartypants","xhtml","prototype","Object","create","constructor","pathToUrl","getBaseUrl","relativePath","_pathResolver","encodeURI","urlToPath","indexOf","replace","decodeURI","canServe","localPath","match","isStaticHtmlFileExt","readyToServe","$","Deferred","promise","addVirtualContentAtPath","docText","add","liveDocument","setInstrumentationEnabled","remove","removeVirtualContentAtPath","clear","requestedPath","_documentKey","_liveDocuments","virtualDocument","_virtualServingDocuments","isWithinProject","DESCRIPTION_LIVEDEV_SECURITY","isLivePreviewPopoutPage","get","getResponseData","body","getRemoteScript","file","getFileForPath","getOpenDocumentForPath","fs","readFile","BYTE_ARRAY_ENCODING","binContent","serverStarted","start","async","browser","isTauri","baseURL","location","origin","attr","stop","undefined","registerEventHandler","on","_ev","phoenixInstanceID","requestPath","messageToLivePreviewTabs","TAB_HEARTBEAT_TIMEOUT","contentWindow","redirectAllTabs","newURL","_projectOpened","_evt","projectRoot","getTabPopoutURL","openURL","getPageLoaderURL","hasActiveLivePreviews","size","setInterval","endTime","tab","keys","tabInfo","timeDiff","title","faviconBase64","EVENT_PROJECT_OPEN","setLivePreviewTransportBridge"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2012 - present Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*global Phoenix, logger, fs */\n\ndefine(function (require, exports, module) {\n\n    const BaseServer = brackets.getModule(\"LiveDevelopment/Servers/BaseServer\").BaseServer,\n        LiveDevelopmentUtils = brackets.getModule(\"LiveDevelopment/LiveDevelopmentUtils\"),\n        LiveDevelopment    = brackets.getModule(\"LiveDevelopment/main\"),\n        LiveDevServerManager = brackets.getModule(\"LiveDevelopment/LiveDevServerManager\"),\n        LiveDevProtocol = brackets.getModule(\"LiveDevelopment/MultiBrowserImpl/protocol/LiveDevProtocol\"),\n        marked = brackets.getModule('thirdparty/marked.min'),\n        DocumentManager = brackets.getModule(\"document/DocumentManager\"),\n        Mustache = brackets.getModule(\"thirdparty/mustache/mustache\"),\n        FileSystem = brackets.getModule(\"filesystem/FileSystem\"),\n        EventDispatcher = brackets.getModule(\"utils/EventDispatcher\"),\n        EventManager = brackets.getModule(\"utils/EventManager\"),\n        ProjectManager = brackets.getModule(\"project/ProjectManager\"),\n        Strings = brackets.getModule(\"strings\"),\n        utils = require('utils'),\n        BootstrapCSSText = require(\"text!../../../thirdparty/bootstrap/bootstrap.min.css\"),\n        GithubCSSText = require(\"text!../../../thirdparty/highlight.js/styles/github.min.css\"),\n        HilightJSText = require(\"text!../../../thirdparty/highlight.js/highlight.min.js\"),\n        GFMCSSText = require(\"text!../../../thirdparty/gfm.min.css\"),\n        markdownHTMLTemplate = require(\"text!markdown.html\"),\n        redirectionHTMLTemplate = require(\"text!redirectPage.html\");\n\n    const EVENT_GET_PHOENIX_INSTANCE_ID = 'GET_PHOENIX_INSTANCE_ID';\n    const EVENT_GET_CONTENT = 'GET_CONTENT';\n    const EVENT_TAB_ONLINE = 'TAB_ONLINE';\n    const EVENT_REPORT_ERROR = 'REPORT_ERROR';\n    const EVENT_UPDATE_TITLE_ICON = 'UPDATE_TITLE_AND_ICON';\n\n    EventDispatcher.makeEventDispatcher(exports);\n    const PHCODE_LIVE_PREVIEW_QUERY_PARAM = \"phcodeLivePreview\";\n\n    const LOADER_BROADCAST_ID = `live-preview-loader-${Phoenix.PHOENIX_INSTANCE_ID}`;\n    const navigatorChannel = new BroadcastChannel(LOADER_BROADCAST_ID);\n\n    const livePreviewTabs = new Map();\n    navigatorChannel.onmessage = (event) => {\n        window.logger.livePreview.log(\"Live Preview navigator channel: Phoenix received event from tab: \", event);\n        const type = event.data.type;\n        switch (type) {\n        case 'TAB_LOADER_ONLINE':\n            livePreviewTabs.set(event.data.pageLoaderID, {\n                lastSeen: new Date(),\n                URL: event.data.URL,\n                navigationTab: true\n            });\n            return;\n        default: return; // ignore messages not intended for us.\n        }\n    };\n\n    const LIVE_PREVIEW_MESSENGER_CHANNEL = `live-preview-messenger-${Phoenix.PHOENIX_INSTANCE_ID}`;\n    const livePreviewChannel = new BroadcastChannel(LIVE_PREVIEW_MESSENGER_CHANNEL);\n\n    // this is the server tabs located at \"src/live-preview.html\" which embeds the `phcode.live` server and\n    // preview iframes.\n    function _sendToLivePreviewServerTabs(data, pageLoaderID=null) {\n        livePreviewChannel.postMessage({\n            pageLoaderID,\n            data\n        });\n    }\n\n    livePreviewChannel.onmessage = (event) => {\n        window.logger.livePreview.log(\"StaticServer: Live Preview message channel Phoenix recvd:\", event);\n        const pageLoaderID = event.data.pageLoaderID;\n        const data = event.data.data;\n        const eventName =  data.eventName;\n        const message =  data.message;\n        switch (eventName) {\n        case EVENT_GET_PHOENIX_INSTANCE_ID:\n            _sendToLivePreviewServerTabs({\n                type: 'PHOENIX_INSTANCE_ID',\n                PHOENIX_INSTANCE_ID: Phoenix.PHOENIX_INSTANCE_ID\n            }, pageLoaderID);\n            return;\n        case EVENT_GET_CONTENT:\n            getContent(message.path,  message.url)\n                .then(response =>{\n                    // response has the following attributes set\n                    // response.contents: <text or arrayBuffer content>,\n                    // response.path\n                    // headers: {'Content-Type': 'text/html'} // optional headers\n                    response.type = 'REQUEST_RESPONSE';\n                    response.requestID = message.requestID;\n                    _sendToLivePreviewServerTabs(response, pageLoaderID);\n                })\n                .catch(console.error);\n            return;\n        case EVENT_TAB_ONLINE:\n            livePreviewTabs.set(message.clientID, {\n                lastSeen: new Date(),\n                URL: message.URL\n            });\n            return;\n        case EVENT_REPORT_ERROR:\n            logger.reportError(new Error(message));\n            return;\n        default:\n            exports.trigger(eventName, {\n                data\n            });\n        }\n    };\n\n    let _staticServerInstance, $livepreviewServerIframe;\n\n    // see markdown advanced rendering options at https://marked.js.org/using_advanced\n    marked.setOptions({\n        renderer: new marked.Renderer(),\n        pedantic: false,\n        gfm: true,\n        breaks: false,\n        sanitize: false,\n        smartLists: true,\n        smartypants: false,\n        xhtml: false\n    });\n\n    /**\n     * @constructor\n     * @extends {BaseServer}\n     * Live preview server that uses a built-in HTTP server to serve static\n     * and instrumented files.\n     *\n     * @param {!{baseUrl: string, root: string, pathResolver: function(string), nodeDomain: NodeDomain}} config\n     *    Configuration parameters for this server:\n     *        baseUrl        - Optional base URL (populated by the current project)\n     *        pathResolver   - Function to covert absolute native paths to project relative paths\n     *        root           - Native path to the project root (and base URL)\n     */\n    function StaticServer(config) {\n        config.baseUrl= LiveDevServerManager.getStaticServerBaseURLs().projectBaseURL;\n        this._getInstrumentedContent = this._getInstrumentedContent.bind(this);\n        BaseServer.call(this, config);\n    }\n\n    StaticServer.prototype = Object.create(BaseServer.prototype);\n    StaticServer.prototype.constructor = StaticServer;\n\n    /**\n     * Returns a URL for a given path\n     * @param {string} path Absolute path to covert to a URL\n     * @return {?string} Converts a path within the project root to a URL.\n     *  Returns null if the path is not a descendant of the project root.\n     */\n    StaticServer.prototype.pathToUrl = function (path) {\n        const baseUrl         = this.getBaseUrl(),\n            relativePath    = this._pathResolver(path);\n\n        // See if base url has been specified and path is within project\n        if (relativePath !== path) {\n            // Map to server url. Base url is already encoded, so don't encode again.\n\n            return `${baseUrl}${encodeURI(path)}`;\n        }\n\n        return null;\n    };\n\n    /**\n     * Convert a URL to a local full file path\n     * @param {string} url\n     * @return {?string} The absolute path for given URL or null if the path is\n     *  not a descendant of the project.\n     */\n    StaticServer.prototype.urlToPath = function (url) {\n        let path,\n            baseUrl = \"\";\n\n        baseUrl = this.getBaseUrl();\n\n        if (baseUrl !== \"\" && url.indexOf(baseUrl) === 0) {\n            // Use base url to translate to local file path.\n            // Need to use encoded project path because it's decoded below.\n            path = url.replace(baseUrl, \"\");\n\n            return decodeURI(path);\n        }\n\n        return null;\n    };\n\n    /**\n     * Determines whether we can serve local file.\n     * @param {string} localPath A local path to file being served.\n     * @return {boolean} true for yes, otherwise false.\n     */\n    StaticServer.prototype.canServe = function (localPath) {\n        // If we can't transform the local path to a project relative path,\n        // the path cannot be served\n        if (localPath === this._pathResolver(localPath)) {\n            return false;\n        }\n\n        // Url ending in \"/\" implies default file, which is usually index.html.\n        // Return true to indicate that we can serve it.\n        if (localPath.match(/\\/$/)) {\n            return true;\n        }\n\n        // FUTURE: do a MIME Type lookup on file extension\n        return LiveDevelopmentUtils.isStaticHtmlFileExt(localPath);\n    };\n\n    /**\n     * Gets the server details from the StaticServerDomain in node.\n     * The domain itself handles starting a server if necessary (when\n     * the staticServer.getServer command is called).\n     *\n     * @return {jQuery.Promise} A promise that resolves/rejects when\n     *     the server is ready/failed.\n     */\n    StaticServer.prototype.readyToServe = function () {\n        return $.Deferred().resolve().promise(); // virtual server is always assumed present in phoenix\n    };\n\n    /**\n     * This will add the given text to be served when the path is hit in server. use this to either serve a file\n     * that doesn't exist in project, or to override a given path to the contents you give.\n     */\n    StaticServer.prototype.addVirtualContentAtPath = function (path, docText) {\n        BaseServer.prototype.addVirtualContentAtPath.call(this, path, docText);\n    };\n\n    /**\n     * See BaseServer#add. StaticServer ignores documents that do not have\n     * a setInstrumentationEnabled method. Updates request filters.\n     */\n    StaticServer.prototype.add = function (liveDocument) {\n        if (liveDocument.setInstrumentationEnabled) {\n            // enable instrumentation\n            liveDocument.setInstrumentationEnabled(true);\n        }\n\n        BaseServer.prototype.add.call(this, liveDocument);\n    };\n\n    /**\n     * See BaseServer#remove. Updates request filters.\n     */\n    StaticServer.prototype.remove = function (liveDocument) {\n        BaseServer.prototype.remove.call(this, liveDocument);\n    };\n\n    /**\n     * removes path added by addVirtualContentAtPath()\n     */\n    StaticServer.prototype.removeVirtualContentAtPath = function (path) {\n        BaseServer.prototype.removeVirtualContentAtPath.call(this, path);\n    };\n\n    /**\n     * See BaseServer#clear. Updates request filters.\n     */\n    StaticServer.prototype.clear = function () {\n        BaseServer.prototype.clear.call(this);\n    };\n\n    function _getMarkdown(fullPath) {\n        return new Promise((resolve, reject)=>{\n            DocumentManager.getDocumentForPath(fullPath)\n                .done(function (doc) {\n                    let text = doc.getText();\n                    let markdownHtml = marked.parse(text);\n                    let templateVars = {\n                        markdownContent: markdownHtml,\n                        BOOTSTRAP_LIB_CSS: BootstrapCSSText,\n                        HIGHLIGHT_JS_CSS: GithubCSSText,\n                        HIGHLIGHT_JS: HilightJSText,\n                        GFM_CSS: GFMCSSText\n                    };\n                    let html = Mustache.render(markdownHTMLTemplate, templateVars);\n                    resolve({\n                        contents: html,\n                        headers: {'Content-Type': 'text/html'},\n                        path: fullPath\n                    });\n                })\n                .fail(function (err) {\n                    reject(new Error(`Markdown rendering failed for ${fullPath}: ` + err));\n                });\n        });\n    }\n\n    function _getExtension(filePath) {\n        filePath = filePath || '';\n        let pathSplit = filePath.split('.');\n        return pathSplit && pathSplit.length>1 ? pathSplit[pathSplit.length-1] : '';\n    }\n\n    function _isMarkdownFile(filePath) {\n        let extension = _getExtension(filePath);\n        return ['md', 'markdown'].includes(extension.toLowerCase());\n    }\n\n    /**\n     * return a page loader html with redirect script tag that just redirects the page to the given redirectURL.\n     * Strips the PHCODE_LIVE_PREVIEW_QUERY_PARAM in redirectURL also, indicating this is not a live previewed url.\n     *\n     * @param redirectURL\n     * @return {string}\n     * @private\n     */\n    function _getRedirectionPage(redirectURL) {\n        let url = new URL(redirectURL);\n        // strip this query param as the redirection will be done by the page loader and not the content iframe.\n        url.searchParams.delete(PHCODE_LIVE_PREVIEW_QUERY_PARAM);\n        let templateVars = {\n            redirectURL: url.href\n        };\n        return Mustache.render(redirectionHTMLTemplate, templateVars);\n    }\n\n    /**\n     * @private\n     * Events raised by broadcast channel from the service worker will be captured here. The service worker will ask\n     * all phoenix instances if the url to be served should be replaced with instrumented content here or served\n     * as static file from disk.\n     */\n    StaticServer.prototype._getInstrumentedContent = function (requestedPath, url) {\n        return new Promise((resolve, reject)=>{\n            let path = this._documentKey(requestedPath),\n                liveDocument = this._liveDocuments[path],\n                virtualDocument = this._virtualServingDocuments[path];\n            let contents;\n            if(!ProjectManager.isWithinProject(requestedPath)) {\n                console.error(\"Security issue prevented: Live preview tried to access non project resource!!!\", path);\n                resolve({\n                    path,\n                    contents: Strings.DESCRIPTION_LIVEDEV_SECURITY\n                });\n                return;\n            }\n\n            url = new URL(url);\n            let isLivePreviewPopoutPage = false;\n            if(url.searchParams.get(PHCODE_LIVE_PREVIEW_QUERY_PARAM)) {\n                isLivePreviewPopoutPage = true;\n            }\n            if (virtualDocument) {\n                // virtual document overrides takes precedence over live preview docs\n                contents = virtualDocument;\n            } else if (liveDocument && liveDocument.getResponseData) {\n                contents = liveDocument.getResponseData().body;\n                if(isLivePreviewPopoutPage && contents.indexOf(LiveDevProtocol.getRemoteScript()) === -1){\n                    // #LIVE_PREVIEW_TAB_NAVIGATION_RACE_FIX\n                    // check if this is a live preview html. If so, then if you are here, it means that users switched\n                    // live preview to a different page while we are just about to serve an old live preview page that is\n                    // no longer in live preview. If we just serve the raw html here, it will not have any tab navigation\n                    // instrumentation on popped out tabs and live preview navigation will stop on this page. So we will\n                    // use a page loader url to continue navigation.\n                    console.log(\"serving stale live preview with navigable url\", url);\n                    contents = _getRedirectionPage(url);\n                }\n            } else {\n                const file = FileSystem.getFileForPath(requestedPath);\n                let doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\n                if (doc) {\n                    // this file is open in some editor, so we sent the edited contents.\n                    contents = doc.getText();\n                } else {\n                    fs.readFile(requestedPath, fs.BYTE_ARRAY_ENCODING, function (error, binContent) {\n                        if(error){\n                            binContent = null;\n                        }\n                        resolve({\n                            path,\n                            contents: binContent\n                        });\n                    });\n                    return;\n                }\n            }\n\n            resolve({\n                path,\n                contents: contents\n            });\n        });\n    };\n\n    function getContent(path, url) {\n        if(!_staticServerInstance){\n            return Promise.reject(\"Static serve not started!\");\n        }\n        if(!url.startsWith(_staticServerInstance._baseUrl)) {\n            return Promise.reject(\"Not serving content as url belongs to another phcode instance: \" + url);\n        }\n        if(_isMarkdownFile(path)){\n            return _getMarkdown(path);\n        }\n        if(_staticServerInstance){\n            return _staticServerInstance._getInstrumentedContent(path, url);\n        }\n        return Promise.reject(\"Cannot get content\");\n    };\n\n    let serverStarted = false;\n    /**\n     * See BaseServer#start. Starts listenting to StaticServerDomain events.\n     */\n    StaticServer.prototype.start = async function () {\n        _staticServerInstance = this;\n\n        // load the hidden iframe that loads the service worker server page once. we will reuse the same server\n        // as this is a cross-origin server phcode.live, the browser will identify it as a security issue\n        // if we continuously reload the service worker loader page frequently and it will stop working.\n        if(serverStarted){\n            return;\n        }\n        if(!Phoenix.browser.isTauri) {\n            $livepreviewServerIframe = $(\"#live-preview-server-iframe\");\n            let url = LiveDevServerManager.getStaticServerBaseURLs().baseURL +\n                `?parentOrigin=${location.origin}`;\n            $livepreviewServerIframe.attr(\"src\", url);\n            serverStarted = true;\n        }\n    };\n\n    /**\n     * See BaseServer#stop. Remove event handlers from StaticServerDomain.\n     */\n    StaticServer.prototype.stop = function () {\n        _staticServerInstance = undefined;\n    };\n\n    EventManager.registerEventHandler(\"ph-liveServer\", exports);\n    exports.on(EVENT_REPORT_ERROR, function(_ev, event){\n        logger.reportError(new Error(event.data.message));\n    });\n    exports.on(EVENT_GET_CONTENT, function(_ev, event){\n        window.logger.livePreview.log(\"Static Server GET_CONTENT\", event);\n        if(event.data.message && event.data.message.phoenixInstanceID === Phoenix.PHOENIX_INSTANCE_ID) {\n            const requestPath = event.data.message.path,\n                requestID = event.data.message.requestID,\n                url = event.data.message.url;\n            getContent(requestPath, url)\n                .then(response =>{\n                    // response has the following attributes set\n                    // response.contents: <text or arrayBuffer content>,\n                    // response.path\n                    // headers: {'Content-Type': 'text/html'} // optional headers\n                    response.type = 'REQUEST_RESPONSE';\n                    response.requestID = requestID;\n                    messageToLivePreviewTabs(response);\n                })\n                .catch(console.error);\n        }\n    });\n    exports.on(EVENT_GET_PHOENIX_INSTANCE_ID, function(_ev){\n        messageToLivePreviewTabs({\n            type: 'PHOENIX_INSTANCE_ID',\n            PHOENIX_INSTANCE_ID: Phoenix.PHOENIX_INSTANCE_ID\n        });\n    });\n\n    exports.on(EVENT_TAB_ONLINE, function(_ev, event){\n        livePreviewTabs.set(event.data.message.clientID, {\n            lastSeen: new Date(),\n            URL: event.data.message.URL\n        });\n    });\n\n    // If we didn't receive heartbeat message from a tab for 10 seconds, we assume tab closed\n    const TAB_HEARTBEAT_TIMEOUT = 10000; // in millis secs\n    setInterval(()=>{\n        let endTime = new Date();\n        for(let tab of livePreviewTabs.keys()){\n            const tabInfo = livePreviewTabs.get(tab);\n            let timeDiff = endTime - tabInfo.lastSeen; // in ms\n            if(timeDiff > TAB_HEARTBEAT_TIMEOUT){\n                livePreviewTabs.delete(tab);\n                // the parent navigationTab `phcode.dev/live-preview-loader.html` which loads the live preview tab also\n                // is in this list. We should not raise browser close event if its just a live-preview-loader tab.\n                if(!tabInfo.navigationTab) {\n                    exports.trigger('BROWSER_CLOSE', { data: { message: {clientID: tab}}});\n                }\n            }\n        }\n    }, 1000);\n\n    /**\n     * The message should be and object of the form: {type, ...}. a type attribute is mandatory\n     * @param message\n     */\n    function messageToLivePreviewTabs(message) {\n        if(!message.type){\n            throw new Error('Missing type attribute to send live preview message to tabs');\n        }\n        // The embedded iframe is a trusted origin and hence we use '*'. We can alternatively use\n        // LiveDevServerManager.getStaticServerBaseURLs().origin, but there seems to be a single error on startup\n        // Most likely as we switch frequently between about:blank and the live preview server host page.\n        // Error message in console:\n        // `Failed to execute 'postMessage' on 'DOMWindow': The target origin provided ('http://localhost:8001')\n        // does not match the recipient window's origin ('http://localhost:8000').`\n        $livepreviewServerIframe && $livepreviewServerIframe[0].contentWindow.postMessage(message, '*');\n        _sendToLivePreviewServerTabs(message);\n    }\n\n    function redirectAllTabs(newURL) {\n        navigatorChannel.postMessage({\n            type: 'REDIRECT_PAGE',\n            url: newURL\n        });\n    }\n\n    function _projectOpened(_evt, projectRoot) {\n        navigatorChannel.postMessage({\n            type: 'PROJECT_SWITCH',\n            projectRoot: projectRoot.fullPath\n        });\n    }\n\n    exports.on(EVENT_UPDATE_TITLE_ICON, function(_ev, event){\n        const title = event.data.message.title;\n        const faviconBase64 = event.data.message.faviconBase64;\n        navigatorChannel.postMessage({\n            type: 'UPDATE_TITLE_ICON',\n            title,\n            faviconBase64\n        });\n    });\n\n    ProjectManager.on(ProjectManager.EVENT_PROJECT_OPEN, _projectOpened);\n\n    function getTabPopoutURL(url) {\n        let openURL = new URL(url);\n        // we tag all externally opened urls with query string parameter phcodeLivePreview=\"true\" to address\n        // #LIVE_PREVIEW_TAB_NAVIGATION_RACE_FIX\n        openURL.searchParams.set(StaticServer.PHCODE_LIVE_PREVIEW_QUERY_PARAM, \"true\");\n        return  utils.getPageLoaderURL(openURL.href);\n    }\n\n    function hasActiveLivePreviews() {\n        return livePreviewTabs.size > 0;\n    }\n\n    LiveDevelopment.setLivePreviewTransportBridge(exports);\n    exports.StaticServer = StaticServer;\n    exports.messageToLivePreviewTabs = messageToLivePreviewTabs;\n    exports.livePreviewTabs = livePreviewTabs;\n    exports.redirectAllTabs = redirectAllTabs;\n    exports.getTabPopoutURL = getTabPopoutURL;\n    exports.hasActiveLivePreviews = hasActiveLivePreviews;\n    exports.PHCODE_LIVE_PREVIEW_QUERY_PARAM = PHCODE_LIVE_PREVIEW_QUERY_PARAM;\n});\n"],"file":"StaticServer.js"}
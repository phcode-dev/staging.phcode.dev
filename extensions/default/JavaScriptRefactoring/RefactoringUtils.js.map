{"version":3,"sources":["extensions/default/JavaScriptRefactoring/RefactoringUtils.js"],"names":["define","require","exports","module","Acorn","brackets","getModule","ASTWalker","MessageIds","JSON","parse","_","AcornLoose","ScopeManager","templates","FUNCTION_BODY_PREFIX_LENGTH","isEqual","a","b","start","end","getExpression","ast","fileText","expn","findSurroundExpression","type","includes","parentExpn","parentExpStr","substr","str","node","isStandAloneExpression","getAST","text","ecmaVersion","e","checkStatement","notStatement","simple","FunctionDeclaration","ClassDeclaration","startStatement","findSurroundASTNode","endStatement","getUniqueIdentifierName","scopes","prefix","num","props","reduce","scope","union","keys","name","indexOf","numLines","split","length","found","findNodeAt","nodeType","getScopeData","session","offset","path","fileInfo","TERN_FILE_INFO_TYPE_FULL","offsetLines","filterText","getJavascriptText","postMessage","TERN_SCOPEDATA_MSG","ternPromise","addPendingRequest","result","$","Deferred","done","response","resolveWith","fail","reject","normalizeText","removeTrailingSemiColons","trimmedText","trimLeft","trimRight","isFnScope","isBlock","isCatch","surroundExpn","methodDefinitionNode","value","types","foundNode","findNodeAround","clone","getAllScopes","fullText","curScope","cnt","id","push","fnType","originNode","key","classNode","temp","prev","newScope","isClass","assignmentExpNode","left","varDeclaratorNode","body","Math","min","RefactoringSession","editor","this","document","selection","getSelection","getText","selectedText","getSelectedText","cm","_codeMirror","startIndex","indexFromPos","endIndex","startPos","endPos","createAstOfCurrentDoc","prototype","lineEndPosition","line","lineText","ch","getLine","replaceTextFromTemplate","template","args","rangeToReplace","subTemplate","templateText","compiled","formattedText","replaceRange","startLine","endLine","i","indentLine","getParamsOfFunction","param","Function","params","forEach","item","getParentNode","isLastNodeInScope","parentNode","currentNodeStart","Property"],"mappings":"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","sourcesContent":["/*\n*  Copyright (c) 2021 - present core.ai . All rights reserved.\n *  Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n*\n* Permission is hereby granted, free of charge, to any person obtaining a\n* copy of this software and associated documentation files (the \"Software\"),\n* to deal in the Software without restriction, including without limitation\n* the rights to use, copy, modify, merge, publish, distribute, sublicense,\n* and/or sell copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n* DEALINGS IN THE SOFTWARE.\n*\n*/\n\n/*\n * Utilities functions related to refactoring\n */\ndefine(function (require, exports, module) {\n\n\n    var Acorn         = brackets.getModule(\"thirdparty/acorn/dist/acorn\"),\n        ASTWalker     = brackets.getModule(\"thirdparty/acorn/dist/walk\"),\n        MessageIds    = JSON.parse(brackets.getModule(\"text!JSUtils/MessageIds.json\")),\n        _             = brackets.getModule(\"thirdparty/lodash\"),\n        AcornLoose    = brackets.getModule(\"thirdparty/acorn/dist/acorn_loose\"),\n        ScopeManager  = brackets.getModule(\"JSUtils/ScopeManager\");\n\n\n    var templates = JSON.parse(require(\"text!Templates.json\"));\n\n\n\n    // Length of the function body used as function name for nameless functions\n    var FUNCTION_BODY_PREFIX_LENGTH = 30;\n\n    /**\n     * Checks whether two ast nodes are equal\n     * @param {!ASTNode} a\n     * @param {!ASTNode} b\n     * @return {boolean}\n     */\n    function isEqual(a, b) {\n        return a.start === b.start && a.end === b.end;\n    }\n\n    /**\n     * Gets a expression surrounding start and end (if any)\n     * @param {!ASTNode} ast - the ast of the complete file\n     * @param {!number} start - the start offset\n     * @param {!number} end - the end offset\n     * @param {!string} fileText - the entire file text\n     * @return {ASTNode|boolean}\n     */\n    function getExpression(ast, start, end, fileText) {\n        var expn = findSurroundExpression(ast, {start: start, end: end});\n        if (!expn) {\n            return false;\n        }\n\n        // Class Expression also includes the trailing semicolon\n        // Add special case for it\n        if (expn.type === \"ClassExpression\" && expn.start === start && expn.end - end <= 1) {\n            expn.end = end;\n            return expn;\n        }        else if (expn.start === start && expn.end === end) {\n            return expn;\n        }\n\n        // Subexpressions are possible only for BinaryExpression, LogicalExpression and SequenceExpression\n        if (!([\"BinaryExpression\", \"LogicalExpression\", \"SequenceExpression\"].includes(expn.type))) {\n            return false;\n        }\n\n        // Check subexpression\n        var parentExpn = expn;\n        var parentExpStr = fileText.substr(parentExpn.start, parentExpn.end - parentExpn.start);\n\n        // Check whether the parentExpn forms a valid expression after replacing the sub expression\n        var str = parentExpStr.substr(0, start - parentExpn.start) + \"placeHolder\" + parentExpStr.substr(end - parentExpn.start);\n        var node = isStandAloneExpression(str);\n        if (node && node.type === parentExpn.type) {\n            return parentExpn;\n        }\n\n        return false;\n    }\n\n    function getAST(text) {\n        var ast;\n        try {\n            ast = Acorn.parse(text, {ecmaVersion: 9});\n        } catch(e) {\n            ast = AcornLoose.parse(text, {ecmaVersion: 9});\n        }\n        return ast;\n    }\n\n    /*\n     * Checks whether the text between start and end offsets form a valid set of statements\n     * @param {!ASTNode} ast - the ast of the complete file\n     * @param {!number} start - the start offset\n     * @param {!number} end - the end offset\n     * @param {!string} fileText - the entire file text\n     * @return {boolean}\n     */\n    function checkStatement(ast, start, end, fileText) {\n        // Do not allow function or class nodes\n        var notStatement = false;\n        ASTWalker.simple(getAST(fileText.substr(start, end - start)), {\n            FunctionDeclaration: function (node) {\n                notStatement = true;\n            },\n            ClassDeclaration: function (node) {\n                notStatement = true;\n            }\n        });\n\n        if (notStatement) {\n            return false;\n        }\n\n        var startStatement = findSurroundASTNode(ast, {start: start}, [\"Statement\"]);\n        var endStatement   = findSurroundASTNode(ast, {start: end}, [\"Statement\"]);\n\n        return startStatement && endStatement && startStatement.start === start &&\n            startStatement.end <= end && endStatement.start >= start &&\n            endStatement.end === end;\n    }\n\n    /**\n     * Gets a unique identifier name in the scope that starts with prefix\n     * @param {!Scope} scopes - an array of all scopes returned from tern (each element contains 'props' with identifiers\n     *  in that scope)\n     * @param {!string} prefix - prefix of the identifier\n     * @param {number} num - number to start checking for\n     * @return {!string} identifier name\n     */\n    function getUniqueIdentifierName(scopes, prefix, num) {\n        if (!scopes) {\n            return prefix;\n        }\n\n        var props = scopes.reduce(function(props, scope) {\n            return _.union(props, _.keys(scope.props));\n        }, []);\n\n        if (!props) {\n            return prefix;\n        }\n\n        num = num || \"1\";\n        var name;\n        while (num < 100) { // limit search length\n            name = prefix + num;\n            if (props.indexOf(name) === -1) {\n                break;\n            }\n            ++num;\n        }\n        return name;\n    }\n\n    /**\n     * Returns the no of lines in the text\n     * @param {!string} text\n     * @return {number}\n     */\n    function numLines(text) {\n        return text.split(\"\\n\").length;\n    }\n\n    /**\n     * Checks whether the text forms a stand alone expression without considering the context of text\n     * @param {!string} text\n     * @return {boolean}\n     */\n    function isStandAloneExpression(text) {\n        var found = ASTWalker.findNodeAt(getAST(text), 0, text.length, function (nodeType, node) {\n            if (nodeType === \"Expression\") {\n                return true;\n            }\n            return false;\n        });\n        return found && found.node;\n    }\n\n    /**\n     * Requests scope data from tern\n     * @param {!Session} session\n     * @param {!{line: number, ch: number}} offset\n     * @return {!$.Promise} a jQuery promise that will be resolved with the scope data\n     */\n    function getScopeData(session, offset) {\n        var path = session.path,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: ScopeManager.filterText(session.getJavascriptText())\n            };\n\n        ScopeManager.postMessage({\n            type: MessageIds.TERN_SCOPEDATA_MSG,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        var ternPromise = ScopeManager.addPendingRequest(fileInfo.name, offset, MessageIds.TERN_SCOPEDATA_MSG);\n\n        var result = new $.Deferred();\n\n        ternPromise.done(function (response) {\n            result.resolveWith(null, [response.scope]);\n        }).fail(function () {\n            result.reject();\n        });\n\n        return result;\n    }\n\n    /**\n    * Normalize text by removing leading and trailing whitespace characters\n    * and moves the start and end offset to reflect the new offset\n    * @param {!string} text - selected text\n    * @param {!number} start - the start offset of the text\n    * @param {!number} end - the end offset of the text\n    * @param {!boolean} removeTrailingSemiColons - removes trailing semicolons also if true\n    * @return {!{text: string, start: number, end: number}}\n    */\n    function normalizeText(text, start, end, removeTrailingSemiColons) {\n        var trimmedText;\n\n        // Remove leading spaces\n        trimmedText = _.trimLeft(text);\n\n        if (trimmedText.length < text.length) {\n            start += (text.length - trimmedText.length);\n        }\n\n        text = trimmedText;\n\n        // Remove trailing spaces\n        trimmedText = _.trimRight(text);\n\n        if (trimmedText.length < text.length) {\n            end -= (text.length - trimmedText.length);\n        }\n\n        text = trimmedText;\n\n        // Remove trailing semicolons\n        if (removeTrailingSemiColons) {\n            trimmedText = _.trimRight(text, ';');\n\n            if (trimmedText.length < text.length) {\n                end -= (text.length - trimmedText.length);\n            }\n        }\n\n        return {\n            text: trimmedText,\n            start: start,\n            end: end\n        };\n    }\n\n    /**\n     * Checks whether the scope is a function scope\n     */\n    function isFnScope(scope) {\n        return !scope.isBlock && !scope.isCatch;\n    }\n\n    function findSurroundExpression(ast, expn) {\n        var start = expn.start;\n        var end = expn.end;\n        var surroundExpn;\n\n        while (true) {\n            surroundExpn = findSurroundASTNode(ast, {start: start, end: end}, [\"Expression\"]);\n\n            if (!surroundExpn) {\n                return null;\n            }\n\n            // Do not allow sequence expressions\n            if (surroundExpn.type === \"SequenceExpression\") {\n                start = surroundExpn.start - 1;\n            }            else if (surroundExpn.type === \"FunctionExpression\") { // Do not allow method definition expressions\n                var methodDefinitionNode = findSurroundASTNode(ast, surroundExpn, [\"MethodDefinition\"]);\n                if (methodDefinitionNode && isEqual(methodDefinitionNode.value, surroundExpn)) {\n                    start = surroundExpn.start - 1;\n                } else {\n                    return surroundExpn;\n                }\n            } else {\n                return surroundExpn;\n            }\n        }\n\n        return surroundExpn;\n    }\n\n    /**\n     * Finds the surrounding ast node of the given expression of any of the given types\n     * @param {!ASTNode} ast\n     * @param {!{start: number, end: number}} expn - contains start and end offsets of expn\n     * @param {!Array.<string>} types\n     * @return {?ASTNode}\n     */\n    function findSurroundASTNode(ast, expn, types) {\n        var foundNode = ASTWalker.findNodeAround(ast, expn.start, function (nodeType, node) {\n            if (expn.end) {\n                return types.includes(nodeType) && node.end >= expn.end;\n            }\n            return types.includes(nodeType);\n\n        });\n        return foundNode && _.clone(foundNode.node);\n    }\n\n    /**\n     * Converts the scopes returned from tern to an array of scopes and adds id and name to the scope\n     * Also checks for class scopes\n     * @param {!ASTNode} ast - ast of the complete file\n     * @param {!Scope} scope - scope returned from tern\n     * @param {!string} fullText - the complete text of a file\n     * @return {!Array.<Scope>}\n     */\n    function getAllScopes(ast, scope, fullText) {\n        var curScope = scope;\n        var cnt = 0;\n        var scopes = [];\n\n        while (curScope) {\n            curScope.id = cnt++;\n            scopes.push(curScope);\n\n            if (curScope.fnType) {\n                // Check for class scopes surrounding the function\n                if (curScope.fnType === \"FunctionExpression\") {\n                    var methodDefinitionNode = findSurroundASTNode(ast, curScope.originNode, [\"MethodDefinition\"]);\n                    // class scope found\n                    if (methodDefinitionNode && isEqual(methodDefinitionNode.value, curScope.originNode)) {\n                        // Change curScope name and originNode to that of methodDefinitionNode\n                        curScope.name = methodDefinitionNode.key.name;\n                        curScope.originNode = methodDefinitionNode;\n\n                        var classNode = findSurroundASTNode(ast, methodDefinitionNode, [\"ClassDeclaration\", \"ClassExpression\"]);\n\n                        if (classNode) {\n                            // Class Declaration found add it to scopes\n                            var temp = curScope.prev;\n                            var newScope = {};\n                            newScope.isClass = true;\n\n                            // if the class is class expression, check if it has a name\n                            if (classNode.type === \"ClassExpression\") {\n                                var assignmentExpNode = findSurroundASTNode(ast, classNode, [\"AssignmentExpression\"]);\n                                if (assignmentExpNode && assignmentExpNode.left && assignmentExpNode.left.name) {\n                                    newScope.name = \"class \" + assignmentExpNode.left.name;\n                                } else {\n                                    var varDeclaratorNode = findSurroundASTNode(ast, classNode, [\"VariableDeclarator\"]);\n                                    if (varDeclaratorNode && varDeclaratorNode.id && varDeclaratorNode.id.name) {\n                                        newScope.name = \"class \" + varDeclaratorNode.id.name;\n                                    } else {\n                                        newScope.name = \"class null\";\n                                    }\n                                }\n                            } else {\n                                newScope.name = \"class \" + (classNode.id && classNode.id.name);\n                            }\n                            newScope.originNode = classNode;\n                            curScope.prev = newScope;\n                            newScope.prev = temp;\n                        }\n                    } else {\n                        // For function expressions, assign name to prefix of the function body\n                        curScope.name = \"function starting with \" +\n                            fullText.substr(\n                                curScope.originNode.body.start,\n                                Math.min(\n                                    FUNCTION_BODY_PREFIX_LENGTH,\n                                    curScope.originNode.body.end - curScope.originNode.body.start\n                                )\n                            );\n                    }\n                } else {\n                    // Acorn parse marks name with '✖' under erroneous declarations, check it\n                    if (curScope.fnType === \"✖\") {\n                        curScope.name = \"function starting with \" +\n                            fullText.substr(\n                                curScope.originNode.body.start,\n                                Math.min(\n                                    FUNCTION_BODY_PREFIX_LENGTH,\n                                    curScope.originNode.body.end - curScope.originNode.body.start\n                                )\n                            );\n                    } else {\n                        curScope.name = curScope.fnType;\n                    }\n                }\n            } else if (!curScope.originNode) {\n                curScope.name = \"global\";\n            }\n\n            curScope = curScope.prev;\n        }\n        return scopes;\n    }\n\n    /**\n     * Note - To use these state defined in Refactoring Session,\n     * Please reinitialize this RefactoringSession after performing any of the below operations\n     * (i.e. replaceRange, setSelection or indentLine)\n     *\n     * RefactoringSession objects encapsulate state associated with a refactoring session\n     * and This will help finding information around documents, selection,\n     * position, ast, and queries around AST nodes\n     *\n     * @constructor\n     * @param {Editor} editor - the editor context for the session\n     */\n    function RefactoringSession(editor) {\n        this.editor = editor;\n        this.document = editor.document;\n        this.selection = editor.getSelection();\n        this.text = this.document.getText();\n        this.selectedText = editor.getSelectedText();\n        this.cm = editor._codeMirror;\n        this.startIndex = editor.indexFromPos(this.selection.start);\n        this.endIndex = editor.indexFromPos(this.selection.end);\n        this.startPos = this.selection.start;\n        this.endPos = this.selection.end;\n        this.ast = this.createAstOfCurrentDoc();\n    }\n\n    /**\n     * Get the end position of given line\n     *\n     * @param {number} line - line number\n     * @return {{line: number, ch: number}} - line end position\n     */\n    RefactoringSession.prototype.lineEndPosition = function (line) {\n        var lineText = this.document.getLine(line);\n\n        return {\n            line: line,\n            ch: lineText.length\n        };\n    };\n\n    /**\n     * Get the ast of current opened document in focused editor\n     *\n     * @return {Object} - Ast of current opened doc\n     */\n    RefactoringSession.prototype.createAstOfCurrentDoc = function () {\n        var ast,\n            text = this.document.getText();\n        try {\n            ast = Acorn.parse(text);\n        } catch(e) {\n            ast = AcornLoose.parse(text);\n        }\n        return ast;\n    };\n\n    /**\n     * This will add template at given position/selection\n     *\n     * @param {string} template - name of the template defined in templates.json\n     * @param {Array} args- Check all arguments that exist in defined templated pass all that args as array\n     * @param {{line: number, ch: number}} rangeToReplace - Range which we want to replace\n     * @param {string} subTemplate - If template written under some category\n     */\n    RefactoringSession.prototype.replaceTextFromTemplate = function (template, args, rangeToReplace, subTemplate) {\n        var templateText = templates[template];\n\n        if (subTemplate) {\n            templateText = templateText[subTemplate];\n        }\n\n        var compiled = _.template(templateText),\n            formattedText = compiled(args);\n\n        if (!rangeToReplace) {\n            rangeToReplace = this.editor.getSelection();\n        }\n\n        this.document.replaceRange(formattedText, rangeToReplace.start, rangeToReplace.end);\n\n        var startLine = rangeToReplace.start.line,\n            endLine = startLine + formattedText.split(\"\\n\").length;\n\n        for (var i = startLine + 1; i < endLine; i++) {\n            this.cm.indentLine(i);\n        }\n    };\n\n    /**\n     * Get Params of selected function\n     *\n     * @param {number} start- start offset\n     * @param {number} end - end offset\n     * @param {string} selectedText - Create ast for only selected node\n     * @return {Array} param - Array of all parameters in function\n     */\n    RefactoringSession.prototype.getParamsOfFunction = function getParamsOfFunction(start, end, selectedText) {\n        var param = [];\n        ASTWalker.simple(AcornLoose.parse(selectedText), {\n            Function: function (node) {\n                if (node.type === \"FunctionDeclaration\") {\n                    node.params.forEach(function (item) {\n                        param.push(item.name);\n                    });\n                }\n            }\n        });\n\n        return param;\n    };\n\n    /**\n     * Get the Parent node\n     *\n     * @param {Object} ast - ast of full document\n     * @param {number} start - start Offset\n     * @return {Object} node - Returns the parent node of node which is at offset start\n     */\n    RefactoringSession.prototype.getParentNode = function (ast, start) {\n        var foundNode = ASTWalker.findNodeAround(ast, start, function(nodeType, node) {\n            return (nodeType === \"ObjectExpression\");\n        });\n        return foundNode && foundNode.node;\n    };\n\n    /**\n     * Checks weather the node at start is last in that scope or not\n     *\n     * @param {Object} ast - ast of full document\n     * @param {number} start - start Offset\n     * @return {boolean} - is last node in that scope\n     */\n    RefactoringSession.prototype.isLastNodeInScope = function (ast, start) {\n        var parentNode = this.getParentNode(ast, start),\n            currentNodeStart;\n\n        ASTWalker.simple(parentNode, {\n            Property: function (node) {\n                currentNodeStart = node.start;\n            }\n        });\n\n        return start >= currentNodeStart;\n    };\n\n\n    // Define public api\n    exports.isEqual = isEqual;\n    exports.getUniqueIdentifierName = getUniqueIdentifierName;\n    exports.isStandAloneExpression = isStandAloneExpression;\n    exports.numLines = numLines;\n    exports.getScopeData = getScopeData;\n    exports.normalizeText = normalizeText;\n    exports.getExpression = getExpression;\n    exports.isFnScope = isFnScope;\n    exports.getAllScopes = getAllScopes;\n    exports.checkStatement = checkStatement;\n    exports.findSurroundASTNode = findSurroundASTNode;\n    exports.getAST = getAST;\n    exports.findSurroundExpression = findSurroundExpression;\n    exports.RefactoringSession = RefactoringSession;\n});\n"],"file":"RefactoringUtils.js"}
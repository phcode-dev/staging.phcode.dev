{"version":3,"sources":["extensions/default/JavaScriptRefactoring/RenameIdentifier.js"],"names":["define","require","exports","module","EditorManager","brackets","getModule","ScopeManager","Session","MessageIds","JSON","parse","TokenUtils","Strings","ProjectManager","session","keywords","initializeSession","editor","getRefs","fileInfo","offset","postMessage","type","TERN_REFS","addPendingRequest","name","requestFindRefs","document","path","file","fullPath","ternPromise","promise","TERN_FILE_INFO_TYPE_FULL","offsetLines","text","filterText","getJavascriptText","handleRename","getActiveEditor","token","getSelections","length","displayErrorMessageAtCursor","ERROR_RENAME_MULTICURSOR","getModeForSelection","getTokenAt","_codeMirror","posFromIndex","getOffset","indexOf","string","ERROR_RENAME_GENERAL","result","$","Deferred","isInSameFile","obj","refsResp","projectRoot","getProjectRoot","projectDir","fileName","slice","_multiFileRename","refs","handleFindRefs","references","inlineWidget","getFocusedInlineWidget","isInTextRange","find","item","start","line","_startLine","end","_endLine","ERROR_RENAME_QUICKEDIT","currentPosition","refsArray","primaryRef","filter","element","ch","primary","setSelections","requestFindReferences","response","hasOwnProperty","done","fail","errorMsg","reject"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    let EditorManager        = brackets.getModule(\"editor/EditorManager\"),\n        ScopeManager         = brackets.getModule(\"JSUtils/ScopeManager\"),\n        Session              = brackets.getModule(\"JSUtils/Session\"),\n        MessageIds           = JSON.parse(brackets.getModule(\"text!JSUtils/MessageIds.json\")),\n        TokenUtils           = brackets.getModule(\"utils/TokenUtils\"),\n        Strings              = brackets.getModule(\"strings\"),\n        ProjectManager      = brackets.getModule(\"project/ProjectManager\");\n\n    let session             = null,  // object that encapsulates the current session state\n        keywords = [\"define\", \"alert\", \"exports\", \"require\", \"module\", \"arguments\"];\n\n    //Create new session\n    function initializeSession(editor) {\n        session = new Session(editor);\n    }\n\n    //Post message to tern node domain that will request tern server to find refs\n    function getRefs(fileInfo, offset) {\n        ScopeManager.postMessage({\n            type: MessageIds.TERN_REFS,\n            fileInfo: fileInfo,\n            offset: offset\n        });\n\n        return ScopeManager.addPendingRequest(fileInfo.name, offset, MessageIds.TERN_REFS);\n    }\n\n    //Create info required to find reference\n    function requestFindRefs(session, document, offset) {\n        if (!document || !session) {\n            return;\n        }\n        let path    = document.file.fullPath,\n            fileInfo = {\n                type: MessageIds.TERN_FILE_INFO_TYPE_FULL,\n                name: path,\n                offsetLines: 0,\n                text: ScopeManager.filterText(session.getJavascriptText())\n            };\n        let ternPromise = getRefs(fileInfo, offset);\n\n        return {promise: ternPromise};\n    }\n\n    //Do rename of identifier which is at cursor\n    function handleRename() {\n        let editor = EditorManager.getActiveEditor(),\n            offset, token;\n\n        if (!editor) {\n            return;\n        }\n\n        if (editor.getSelections().length > 1) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_MULTICURSOR);\n            return;\n        }\n        initializeSession(editor);\n\n\n        if (!editor || editor.getModeForSelection() !== \"javascript\") {\n            return;\n        }\n\n        token = TokenUtils.getTokenAt(editor._codeMirror, editor._codeMirror.posFromIndex(session.getOffset()));\n\n        if (keywords.indexOf(token.string) >= 0) {\n            editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_GENERAL);\n            return;\n        }\n\n        let result = new $.Deferred();\n\n        function isInSameFile(obj, refsResp) {\n            let projectRoot = ProjectManager.getProjectRoot(),\n                projectDir,\n                fileName = \"\";\n            if (projectRoot) {\n                projectDir = projectRoot.fullPath;\n            }\n\n            // get the relative path of File as Tern can also return\n            // references with file name as a relative path wrt projectRoot\n            // so refernce file name will be compared with both relative and absolute path to check if it is same file\n            if (projectDir && refsResp && refsResp.file && refsResp.file.indexOf(projectDir) === 0) {\n                fileName = refsResp.file.slice(projectDir.length);\n            }\n            // In case of unsaved files, After renameing once Tern is returning filename without forward slash\n            return (obj && (obj.file === refsResp.file || obj.file === fileName\n                            || obj.file === refsResp.file.slice(1, refsResp.file.length)));\n        }\n\n        function _multiFileRename(refs) {\n            // TODO: Multi file rename here\n            // note that before we enable this, we should load tern with the full code base to identify all\n            // references properly. This sadly needs refactoring the current tern integration heavily\n        }\n\n        /**\n         * Check if references are in this file only\n         * If yes then select all references\n         */\n        function handleFindRefs (refsResp) {\n            if (!refsResp || !refsResp.references || !refsResp.references.refs) {\n                return;\n            }\n\n            let inlineWidget = EditorManager.getFocusedInlineWidget(),\n                editor = EditorManager.getActiveEditor(),\n                refs = refsResp.references.refs;\n\n            //In case of inline widget if some references are outside widget's text range then don't allow for rename\n            if (inlineWidget) {\n                let isInTextRange  = !refs.find(function(item) {\n                    return (item.start.line < inlineWidget._startLine || item.end.line > inlineWidget._endLine);\n                });\n\n                if (!isInTextRange) {\n                    editor.displayErrorMessageAtCursor(Strings.ERROR_RENAME_QUICKEDIT);\n                    return;\n                }\n            }\n\n            let currentPosition = editor.posFromIndex(refsResp.offset),\n                refsArray;\n            refsArray = refs.filter(function (element) {\n                return isInSameFile(element, refsResp);\n            });\n            if (refsArray.length !== refs.length) {\n                // There are references across multiple files, we are not ready to handle this yet\n                _multiFileRename(refs);\n                return;\n            }\n\n            // Finding the Primary Reference in Array\n            let primaryRef = refsArray.find(function (element) {\n                return ((element.start.line === currentPosition.line || element.end.line === currentPosition.line)\n                        && currentPosition.ch <= element.end.ch && currentPosition.ch >= element.start.ch);\n            });\n            // Setting the primary flag of Primary Refence to true\n            primaryRef.primary = true;\n\n            editor.setSelections(refsArray);\n        }\n\n        /**\n         * Make a find ref request.\n         * @param {Session} session - the session\n         * @param {number} offset - the offset of where to jump from\n         */\n        function requestFindReferences(session, offset) {\n            let response = requestFindRefs(session, session.editor.document, offset);\n\n            if (response && response.hasOwnProperty(\"promise\")) {\n                response.promise.done(handleFindRefs).fail(function (errorMsg) {\n                    EditorManager.getActiveEditor().displayErrorMessageAtCursor(errorMsg);\n                    result.reject();\n                });\n            }\n        }\n\n        offset = session.getOffset();\n        requestFindReferences(session, offset);\n\n        return result.promise();\n    }\n\n    exports.handleRename = handleRename;\n});\n"],"file":"RenameIdentifier.js"}
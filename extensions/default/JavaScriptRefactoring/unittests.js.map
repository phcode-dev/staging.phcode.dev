{"version":3,"sources":["extensions/default/JavaScriptRefactoring/unittests.js"],"names":["define","require","exports","module","MainViewManager","brackets","getModule","DocumentManager","FileUtils","SpecRunnerUtils","ExtractToVariable","ExtractToFunction","TokenUtils","WrapSelection","RenameIdentifier","extensionPath","testPath","getNativeModuleDirectoryPath","testDoc","testEditor","describe","it","expect","toBeFalsy"],"mappings":"AAwBAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,gBAAuBC,SAASC,UAAU,wBAC1CC,gBAAuBF,SAASC,UAAU,4BAC1CE,UAAuBH,SAASC,UAAU,kBAC1CG,gBAAuBJ,SAASC,UAAU,wBAC1CI,kBAAuBT,QAAQ,qBAC/BU,kBAAuBV,QAAQ,qBAC/BW,WAAuBP,SAASC,UAAU,oBAC1CO,cAAuBZ,QAAQ,iBAC/Ba,iBAAuBb,QAAQ,oBAE/Bc,cACAC,SADkBR,UAAUS,6BAA6Bd,QACvB,0BAClCe,QAAkB,KAClBC,WAEJC,SAAS,oCAAqC,WAC1CC,GAAG,sDAAuD,WACvDC,OAAO,sBAAsBC","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n/*global describe, it, expect, beforeEach, afterEach, awaitsFor, awaitsForDone */\n\ndefine(function (require, exports, module) {\n\n\n    var MainViewManager      = brackets.getModule(\"view/MainViewManager\"),\n        DocumentManager      = brackets.getModule(\"document/DocumentManager\"),\n        FileUtils            = brackets.getModule(\"file/FileUtils\"),\n        SpecRunnerUtils      = brackets.getModule(\"spec/SpecRunnerUtils\"),\n        ExtractToVariable    = require(\"ExtractToVariable\"),\n        ExtractToFunction    = require(\"ExtractToFunction\"),\n        TokenUtils           = brackets.getModule(\"utils/TokenUtils\"),\n        WrapSelection        = require(\"WrapSelection\"),\n        RenameIdentifier     = require(\"RenameIdentifier\");\n\n    var extensionPath   = FileUtils.getNativeModuleDirectoryPath(module),\n        testPath        = extensionPath + \"/unittest-files/test.js\",\n        testDoc         = null,\n        testEditor;\n\n    describe(\"extension:Javascript Refactoring \", function () {\n        it(\"tests are disabled till we have refactoring working\", function () {\n           expect(\"tests are disabled\").toBeFalsy();\n        });\n    });\n\n/*\n    describe(\"extension:Javascript Refactoring \", function () {\n\n        async function setupTest(path, primePump) { // FIXME: primePump argument ignored even though used below\n            DocumentManager.getDocumentForPath(path).done(function (doc) {\n                testDoc = doc;\n            });\n\n            await awaitsFor(function () {\n                return testDoc !== null;\n            }, \"Unable to open test document\", 10000);\n\n            // create Editor instance (containing a CodeMirror instance)\n            testEditor = SpecRunnerUtils.createMockEditorForDocument(testDoc);\n        }\n\n        function tearDownTest() {\n            // The following call ensures that the document is reloaded\n            // from disk before each test\n            MainViewManager._closeAll(MainViewManager.ALL_PANES);\n            SpecRunnerUtils.destroyMockEditor(testDoc);\n            testEditor = null;\n            testDoc = null;\n        }\n\n        async function _waitForRefactoring(prevDocLength, numberOfLines, callback) {\n            if (!callback || numberOfLines instanceof Function) {\n                callback = numberOfLines;\n                numberOfLines = null;\n            }\n            await awaitsFor(function() {\n                return (testDoc.getText().length !== prevDocLength || (numberOfLines && testDoc.getText().split(\"\\n\").length !== numberOfLines));\n            }, 3000);\n            callback();\n        }\n\n        async function _waitForRename(prevSelections, callback) {\n            await awaitsFor(function() {\n                return testEditor.getSelections().length !== prevSelections;\n            }, 3000);\n            callback();\n        }\n\n        describe(\"Extract to variable\", function () {\n            beforeEach(async function () {\n                await setupTest(testPath, false);\n            });\n\n            afterEach(function () {\n                tearDownTest();\n            });\n\n            it(\"should extract literal expression\", async function () {\n                testEditor.setSelection({line: 11, ch: 4}, {line: 11, ch: 7});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(11)).toBe(\"var extracted1 = 923;\");\n                    expect(testDoc.getLine(12)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract array expression\", async function () {\n                testEditor.setSelection({line: 14, ch: 4}, {line: 14, ch: 13});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(14)).toBe(\"var extracted1 = [1, 2, 3];\");\n                    expect(testDoc.getLine(15)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract object expression\", async function () {\n                testEditor.setSelection({line: 17, ch: 4}, {line: 20, ch: 1});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getRange({line: 17, ch: 0}, {line: 20, ch: 2}))\n                        .toBe(\n                            \"var extracted1 = {\\n\" +\n                            \"    test1: 12,\\n\"     +\n                            \"    test2: 45\\n\"      +\n                            \"};\"\n                        );\n                    expect(testDoc.getLine(21)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract property expression\", async function () {\n                testEditor.setSelection({line: 23, ch: 4}, {line: 23, ch: 11});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(23)).toBe(\"var extracted1 = x.test1;\");\n                    expect(testDoc.getLine(24)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract function expression\", async function () {\n                testEditor.setSelection({line: 26, ch: 4}, {line: 28, ch: 1});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getRange({line: 26, ch: 0}, {line: 28, ch: 2}))\n                        .toBe(\n                            \"var extracted1 = function() {\\n\"      +\n                            \"    console.log(\\\"hello world\\\");\\n\"  +\n                            \"};\"\n                        );\n                    expect(testDoc.getLine(29)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract unary expression\", async function () {\n                testEditor.setSelection({line: 31, ch: 4}, {line: 31, ch: 7});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(31)).toBe(\"var extracted1 = ++y;\");\n                    expect(testDoc.getLine(32)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract binary expression\", async function () {\n                testEditor.setSelection({line: 34, ch: 4}, {line: 34, ch: 13});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(34)).toBe(\"var extracted1 = 1 + 2 + 3;\");\n                    expect(testDoc.getLine(35)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract assignment expression\", async function () {\n                testEditor.setSelection({line: 38, ch: 0}, {line: 38, ch: 6});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(38)).toBe(\"var extracted1 = x = 23;\");\n                });\n            });\n\n            it(\"should extract assignment expression\", async function () {\n                testEditor.setSelection({line: 41, ch: 3}, {line: 41, ch: 17});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(41)).toBe(\"var extracted1 = true || false;\");\n                    expect(testDoc.getLine(42)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract conditional expression\", async function () {\n                testEditor.setSelection({line: 44, ch: 4}, {line: 44, ch: 19});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(44)).toBe(\"var extracted1 = (2 < 3)? 34: 45;\");\n                    expect(testDoc.getLine(45)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract new expression\", async function () {\n                testEditor.setSelection({line: 50, ch: 4}, {line: 50, ch: 16});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(50)).toBe(\"var extracted1 = new Square();\");\n                    expect(testDoc.getLine(51)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract arrow function\", async function () {\n                testEditor.setSelection({line: 56, ch: 4}, {line: 56, ch: 16});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(56)).toBe(\"var extracted1 = y => y ** 2;\");\n                    expect(testDoc.getLine(57)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract template literal\", async function () {\n                testEditor.setSelection({line: 62, ch: 4}, {line: 62, ch: 22});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(62)).toBe(\"var extracted1 = `Template Literal`;\");\n                    expect(testDoc.getLine(63)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract tagged template literal\", async function () {\n                testEditor.setSelection({line: 65, ch: 4}, {line: 65, ch: 29});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(65)).toBe(\"var extracted1 = String.raw`Hi${2 + 3}!`;\");\n                    expect(testDoc.getLine(66)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract await expression\", async function () {\n                testEditor.setSelection({line: 77, ch: 12}, {line: 77, ch: 42});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(77)).toBe(\"    var extracted1 = await resolveAfter2Seconds(10);\");\n                    expect(testDoc.getLine(78)).toBe(\"    var x = extracted1;\");\n                });\n            });\n\n            it(\"should extract yield expression\", async function () {\n                testEditor.setSelection({line: 84, ch: 8}, {line: 84, ch: 26});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(84)).toBe(\"        var extracted1 = yield saleList[i];\");\n                });\n            });\n\n            it(\"should extract super expression\", async function () {\n                testEditor.setSelection({line: 103, ch: 8}, {line: 103, ch: 29});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(103)).toBe(\"        var extracted1 = super(length, length);\");\n                });\n            });\n\n            it(\"should extract class expression\", async function () {\n                testEditor.setSelection({line: 109, ch: 4}, {line: 114, ch: 1});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getRange({line: 109, ch: 0}, {line: 114, ch: 2}))\n                    .toBe(\n                        \"var extracted1 = class {\\n\"          +\n                        \"    constructor (height, width) {\\n\" +\n                        \"        this.a = height;\\n\"          +\n                        \"        this.b = width;\\n\"           +\n                        \"    }\\n\"                            +\n                        \"};\"\n                    );\n                    expect(testDoc.getLine(115)).toBe(\"x = extracted1;\");\n                });\n            });\n\n            it(\"should extract all the references of expression in a scope\", async function() {\n                testEditor.setSelection({line: 118, ch: 12}, {line: 118, ch: 14});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(118)).toBe(\"    var extracted1 = 34;\");\n                    expect(testDoc.getLine(119)).toBe(\"    var x = extracted1;\");\n                    expect(testDoc.getLine(120)).toBe(\"    var y = extracted1;\");\n                    expect(testDoc.getLine(121)).toBe(\"    var z = extracted1;\");\n                });\n            });\n\n            it(\"should create variable with unique name\", async function() {\n                testEditor.setSelection({line: 126, ch: 12}, {line: 126, ch: 14});\n\n                var prevDocLength = testDoc.getText().length;\n\n                ExtractToVariable.handleExtractToVariable();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(126)).toBe(\"    var extracted2 = 45;\");\n                    expect(testDoc.getLine(127)).toBe(\"    var x = extracted2;\");\n                });\n            });\n        });\n\n        describe(\"Extract to function\", function () {\n            beforeEach(async function () {\n                await setupTest(testPath, false);\n            });\n\n            afterEach(function () {\n                tearDownTest();\n            });\n\n            it(\"should display correct scopes for line inside a function declaration\", async function () {\n                testEditor.setSelection({line: 7, ch: 4}, {line: 7, ch: 28});\n\n                var result = ExtractToFunction.handleExtractToFunction();\n                var scopeMenu;\n\n                await awaitsForDone(result.then(function(inlineMenu) {\n                    scopeMenu = inlineMenu;\n                }), \"Scope not displayed in extract to function\", 3000);\n\n                expect(scopeMenu.items.length).toBe(2);\n                expect(scopeMenu.items[0].name).toBe(\"test\");\n                expect(scopeMenu.items[1].name).toBe(\"global\");\n            });\n\n            it(\"should display correct scopes for line inside a function expression\", async function () {\n                testEditor.setSelection({line: 27, ch: 4}, {line: 27, ch: 31});\n\n                var result = ExtractToFunction.handleExtractToFunction();\n                var scopeMenu;\n\n                await awaitsForDone(result.then(function(inlineMenu) {\n                    scopeMenu = inlineMenu;\n                }), \"Scope not displayed in extract to function\", 3000);\n\n                expect(scopeMenu.items.length).toBe(2);\n                expect(scopeMenu.items[0].name).toBe(\"x\");\n                expect(scopeMenu.items[1].name).toBe(\"global\");\n            });\n\n            it(\"should display correct scopes for line inside a arrow function\", async function () {\n                testEditor.setSelection({line: 58, ch: 4}, {line: 58, ch: 17});\n\n                var result = ExtractToFunction.handleExtractToFunction();\n                var scopeMenu;\n\n                await awaitsForDone(result.then(function(inlineMenu) {\n                    scopeMenu = inlineMenu;\n                }), \"Scope not displayed in extract to function\", 3000);\n\n                expect(scopeMenu.items.length).toBe(2);\n                expect(scopeMenu.items[0].name).toBe(\"x\");\n                expect(scopeMenu.items[1].name).toBe(\"global\");\n            });\n\n            it(\"should display correct scopes for line inside a nested function\", async function () {\n                testEditor.setSelection({line: 71, ch: 12}, {line: 71, ch: 23});\n\n                var result = ExtractToFunction.handleExtractToFunction();\n                var scopeMenu;\n\n                await awaitsForDone(result.then(function(inlineMenu) {\n                    scopeMenu = inlineMenu;\n                }), \"Scope not displayed in extract to function\", 3000);\n\n                expect(scopeMenu.items.length).toBe(4);\n                expect(scopeMenu.items[0].name).toBe(\"function starting with {\\n            resolve(x);\\n    \");\n                expect(scopeMenu.items[1].name).toBe(\"function starting with {\\n        setTimeout(() => {\\n \");\n                expect(scopeMenu.items[2].name).toBe(\"resolveAfter2Seconds\");\n                expect(scopeMenu.items[3].name).toBe(\"global\");\n            });\n\n            it(\"should display correct scopes for line inside a class declaration\", async function () {\n                testEditor.setSelection({line: 93, ch: 8}, {line: 93, ch: 27});\n\n                var result = ExtractToFunction.handleExtractToFunction();\n                var scopeMenu;\n\n                await awaitsForDone(result.then(function(inlineMenu) {\n                    scopeMenu = inlineMenu;\n                }), \"Scope not displayed in extract to function\", 3000);\n\n                expect(scopeMenu.items.length).toBe(3);\n                expect(scopeMenu.items[0].name).toBe(\"constructor\");\n                expect(scopeMenu.items[1].name).toBe(\"class Polygon\");\n                expect(scopeMenu.items[2].name).toBe(\"global\");\n            });\n\n            it(\"should display correct scopes for line inside a class expression\", async function () {\n                testEditor.setSelection({line: 112, ch: 8}, {line: 112, ch: 23});\n\n                var result = ExtractToFunction.handleExtractToFunction();\n                var scopeMenu;\n\n                await awaitsForDone(result.then(function(inlineMenu) {\n                    scopeMenu = inlineMenu;\n                }), \"Scope not displayed in extract to function\", 3000);\n\n                expect(scopeMenu.items.length).toBe(3);\n                expect(scopeMenu.items[0].name).toBe(\"constructor\");\n                expect(scopeMenu.items[1].name).toBe(\"class x\");\n                expect(scopeMenu.items[2].name).toBe(\"global\");\n            });\n\n            it(\"should extract line in global scope without displaying scopes\", async function () {\n                testEditor.setSelection({line: 4, ch: 0}, {line: 4, ch: 11});\n\n                var result = ExtractToFunction.handleExtractToFunction();\n                var scopeMenu;\n\n                await awaitsForDone(result.then(function(inlineMenu) {\n                    scopeMenu = inlineMenu;\n                }), \"Scope not displayed in extract to function\", 3000);\n\n                expect(scopeMenu).toBeUndefined();\n                expect(testDoc.getRange({line: 4, ch: 0}, {line: 7, ch: 1}))\n                    .toBe(\n                        \"function extracted1() {\\n\" +\n                        \"    var y = 34;\\n\"     +\n                        \"    return y;\\n\"      +\n                        \"}\"\n                    );\n                expect(testDoc.getLine(9)).toBe(\"var y = extracted1();\");\n            });\n\n            it(\"should extract a line inside a function declaration\", async function () {\n                testEditor.setSelection({line: 7, ch: 4}, {line: 7, ch: 27});\n\n                var prevDocLength = testDoc.getText().length;\n                var result = ExtractToFunction.handleExtractToFunction();\n                var scopeMenu;\n\n                await awaitsForDone(result.then(function(inlineMenu) {\n                    scopeMenu = inlineMenu;\n                }), \"Scope not displayed in extract to function\", 3000);\n\n                expect(scopeMenu).toBeDefined();\n                var scopeElement = scopeMenu.$menu.find(\".inlinemenu-item\")[0];\n                expect(scopeElement).toBeDefined();\n                $(scopeElement).trigger(\"click\");\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getRange({line: 7, ch: 0}, {line: 9, ch: 6}))\n                        .toBe(\n                            \"    function extracted1() {\\n\"       +\n                            \"        console.log(\\\"Testing\\\");\\n\" +\n                            \"    }\"\n                        );\n                });\n            });\n\n            it(\"should extract a line inside a class to a class method\", async function () {\n                testEditor.setSelection({line: 104, ch: 8}, {line: 104, ch: 29});\n\n                var prevDocLength = testDoc.getText().length;\n                var result = ExtractToFunction.handleExtractToFunction();\n                var scopeMenu;\n\n                await awaitsForDone(result.then(function(inlineMenu) {\n                    scopeMenu = inlineMenu;\n                }), \"Scope not displayed in extract to function\", 3000);\n\n                expect(scopeMenu).toBeDefined();\n                var scopeElement = scopeMenu.$menu.find(\".inlinemenu-item\")[1];\n                expect(scopeElement).toBeDefined();\n                $(scopeElement).trigger(\"click\");\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getRange({line: 101, ch: 0}, {line: 103, ch: 6}))\n                        .toBe(\n                            \"    extracted1() {\\n\"            +\n                            \"        this.name = 'Square';\\n\" +\n                            \"    }\"\n                        );\n                    expect(testDoc.getLine(108)).toBe(\"        this.extracted1();\");\n                });\n            });\n\n            it(\"should extract a line inside a class to global scope\", async function () {\n                testEditor.setSelection({line: 104, ch: 8}, {line: 104, ch: 29});\n\n                var prevDocLength = testDoc.getText().length;\n                var result = ExtractToFunction.handleExtractToFunction();\n                var scopeMenu;\n\n                await awaitsForDone(result.then(function(inlineMenu) {\n                    scopeMenu = inlineMenu;\n                }), \"Scope not displayed in extract to function\", 3000);\n\n                expect(scopeMenu).toBeDefined();\n                var scopeElement = scopeMenu.$menu.find(\".inlinemenu-item\")[2];\n                expect(scopeElement).toBeDefined();\n                $(scopeElement).trigger(\"click\");\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getRange({line: 100, ch: 0}, {line: 102, ch: 2}))\n                        .toBe(\n                            \"function extracted1() {\\n\"            +\n                            \"    this.name = 'Square';\\n\" +\n                            \"}\"\n                        );\n                    expect(testDoc.getLine(108)).toBe(\"        extracted1.call(this);\");\n                });\n            });\n        });\n\n\n        describe(\"Rename\", function () {\n            beforeEach(async function () {\n                await setupTest(testPath, false);\n            });\n\n            afterEach(function () {\n                tearDownTest();\n            });\n\n            it(\"should rename function name\", async function() {\n                testEditor.setSelection({line: 140, ch: 17}, {line: 140, ch: 17});\n\n                var selections = testEditor.getSelections();\n\n                RenameIdentifier.handleRename();\n\n\n                await _waitForRename(selections.length, function() {\n                    var selections = testEditor.getSelections(),\n                        token1 = TokenUtils.getTokenAt(testEditor._codeMirror, {line: 132, ch: 14}, {line: 132, ch: 14}),\n                        token2 = TokenUtils.getTokenAt(testEditor._codeMirror, {line: 140, ch: 17}, {line: 140, ch: 17});\n\n                    expect(selections[0].start.line).toEqual(132);\n                    expect(selections[1].start.line).toEqual(140);\n                });\n            });\n\n            it(\"should rename variable name\", async function() {\n                testEditor.setSelection({line: 165, ch: 6}, {line: 165, ch: 6});\n\n                var selections = testEditor.getSelections();\n\n                RenameIdentifier.handleRename();\n\n\n                await _waitForRename(selections.length, function() {\n                    var selections = testEditor.getSelections(),\n                        token1 = TokenUtils.getTokenAt(testEditor._codeMirror, {line: 149, ch: 6}, {line: 149, ch: 6}),\n                        token2 = TokenUtils.getTokenAt(testEditor._codeMirror, {line: 150, ch: 13}, {line: 150, ch: 13});\n\n                    expect(selections[0].start.line).toEqual(165);\n                    expect(selections[1].start.line).toEqual(168);\n                });\n            });\n        });\n\n        describe(\"Wrap Selection\", function () {\n            beforeEach(async function () {\n                await setupTest(testPath, false);\n            });\n\n            afterEach(function () {\n                tearDownTest();\n            });\n\n            it(\"should wrap selection in Try-Catch block\", async function() {\n                testEditor.setSelection({line: 140, ch: 17}, {line: 140, ch: 17});\n\n                var prevDocLength = testDoc.getText().length;\n\n                WrapSelection.wrapInTryCatch();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(140)).toBe(\"    try {\");\n                    expect(testDoc.getLine(141)).toBe(\"        return addNumbers(a, c) * b;\");\n                    expect(testDoc.getLine(142)).toBe(\"    } catch (e) {\");\n                    expect(testDoc.getLine(143)).toBe(\"        //Catch Statement\");\n                    expect(testDoc.getLine(144)).toBe(\"    }\");\n                });\n            });\n\n            it(\"should wrap selection in Condition block\", async function() {\n                testEditor.setSelection({line: 140, ch: 17}, {line: 140, ch: 17});\n\n                var prevDocLength = testDoc.getText().length;\n\n                WrapSelection.wrapInCondition();\n\n                await _waitForRefactoring(prevDocLength, function() {\n                    expect(testDoc.getLine(140)).toBe(\"    if (Condition) {\");\n                    expect(testDoc.getLine(141)).toBe(\"        return addNumbers(a, c) * b;\");\n                    expect(testDoc.getLine(142)).toBe(\"    }\");\n                });\n            });\n        });\n\n        describe(\"Arrow Function\", function () {\n            beforeEach(async function () {\n                await setupTest(testPath, false);\n            });\n\n            afterEach(function () {\n                tearDownTest();\n            });\n\n            it(\"should convert selected function to arrow function with two param and one return statement\", async function() {\n                testEditor.setSelection({line: 146, ch: 6}, {line: 146, ch: 6});\n\n                var prevDoc = testDoc.getText();\n\n                WrapSelection.convertToArrowFunction();\n\n                await _waitForRefactoring(prevDoc.length, prevDoc.split(\"\\n\").length, function() {\n                    expect(testDoc.getLine(145)).toBe(\"var sum = (a, b) => a+b;\");\n                });\n            });\n\n            it(\"should convert selected function to arrow function with one param and one return statement\", async function() {\n                testEditor.setSelection({line: 150, ch: 6}, {line: 150, ch: 6});\n\n                var prevDoc = testDoc.getText();\n\n                WrapSelection.convertToArrowFunction();\n\n                await _waitForRefactoring(prevDoc.length, prevDoc.split(\"\\n\").length, function() {\n                    expect(testDoc.getLine(149)).toBe(\"var num = a => a;\");\n                });\n            });\n\n            it(\"should convert selected function to arrow function with two param and two statements\", async function() {\n                testEditor.setSelection({line: 154, ch: 6}, {line: 154, ch: 6});\n\n                var prevDoc = testDoc.getText();\n\n                WrapSelection.convertToArrowFunction();\n\n                await _waitForRefactoring(prevDoc.length, prevDoc.split(\"\\n\").length, function() {\n                    expect(testDoc.getLine(153)).toBe(\"var sumAll = (a, b) => {\");\n                });\n            });\n        });\n\n        describe(\"Getters-Setters\", function () {\n            beforeEach(async function () {\n                await setupTest(testPath, false);\n            });\n\n            afterEach(function () {\n                tearDownTest();\n            });\n\n            it(\"should create Getters Setters for selected property\", async function() {\n                testEditor.setSelection({line: 161, ch: 12}, {line: 161, ch: 12});\n\n                var prevDoc = testDoc.getText();\n\n                WrapSelection.createGettersAndSetters();\n\n                await _waitForRefactoring(prevDoc.length, prevDoc.split(\"\\n\").length, function() {\n                    expect(testDoc.getLine(162)).toBe(\"    get docCurrent() {\");\n                    expect(testDoc.getLine(163)).toBe(\"        return this.docCurrent;\");\n                    expect(testDoc.getLine(164)).toBe(\"    },\");\n                    expect(testDoc.getLine(166)).toBe(\"    set docCurrent(val) {\");\n                    expect(testDoc.getLine(167)).toBe(\"        this.docCurrent = val;\");\n                    expect(testDoc.getLine(168)).toBe(\"    },\");\n                });\n            });\n\n            it(\"should create Getters Setters for last property in context\", async function() {\n                testEditor.setSelection({line: 162, ch: 12}, {line: 162, ch: 12});\n\n                var prevDoc = testDoc.getText();\n\n                WrapSelection.createGettersAndSetters();\n\n                await _waitForRefactoring(prevDoc.length, prevDoc.split(\"\\n\").length, function() {\n                    expect(testDoc.getLine(162)).toBe(\"    isReadOnly  : false,\");\n                    expect(testDoc.getLine(163)).toBe(\"    get isReadOnly() {\");\n                    expect(testDoc.getLine(164)).toBe(\"        return this.isReadOnly;\");\n                    expect(testDoc.getLine(165)).toBe(\"    },\");\n                    expect(testDoc.getLine(167)).toBe(\"    set isReadOnly(val) {\");\n                    expect(testDoc.getLine(168)).toBe(\"        this.isReadOnly = val;\");\n                    expect(testDoc.getLine(169)).toBe(\"    }\");\n                });\n            });\n        });\n    });\n\n */\n});\n"],"file":"unittests.js"}
{"version":3,"sources":["extensions/default/InlineTimingFunctionEditor/BezierCurveEditor.js"],"names":["define","require","exports","module","KeyEvent","brackets","getModule","Strings","Mustache","TimingFunctionUtils","BezierCurveEditorTemplate","HEIGHT_ABOVE","HEIGHT_BELOW","HEIGHT_MAIN","WIDTH_MAIN","animationRequest","CubicBezier","coordinates","this","split","i","map","n","xy","isNaN","BezierCanvas","canvas","bezier","padding","getPadding","ctx","getContext","p","scale","width","height","translate","_curveClick","e","self","bezierEditor","target","curveBoundingBox","_getCurveBoundingBox","left","top","x","pageX","y","pageY","$P1","$","P1","$P2","P2","distance","x1","y1","x2","y2","Math","sqrt","pow","distP1","distP2","$P","parseInt","css","get","focus","_cubicBezierCoords","bezierCanvas","offsetsToCoordinates","concat","_commitTimingFunction","_updateCanvas","handlePointMove","mouseMoveRedraw","dragElement","window","requestAnimationFrame","which","min","max","updateTimeProgression","curve","percentX","round","percentY","parentNode","setAttribute","_curveMouseMove","_pointMouseMove","_pointMouseDown","_pointMouseUp","_pointKeyDown","code","keyCode","DOM_VK_LEFT","DOM_VK_DOWN","preventDefault","$this","offset","shiftKey","newVal","DOM_VK_UP","DOM_VK_RIGHT","DOM_VK_ESCAPE","DOM_VK_TAB","ctrlKey","metaKey","altKey","hasClass","BezierCurveEditor","$parent","bezierCurve","callback","$element","render","append","_callback","_getCubicBezierCoords","hint","elem","originalString","showHideHint","join","find","on","prototype","getOffsets","w","h","prettify","v","toString","replace","element","a","plot","settings","setting","defaultSettings","handleTimingFunction","handleThickness","vBorderThickness","hBorderThickness","bezierTimingFunction","bezierThickness","hasOwnProperty","clearRect","beginPath","fillStyle","lineWidth","strokeStyle","moveTo","lineTo","stroke","closePath","arc","PI","fill","bezierColor","bezierCurveTo","length","destroy","off","getRootElement","bezierCurveVal","match","slice","console","log","$canvas","canvasOffset","offsets","handleExternalUpdate"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2013 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\ndefine(function (require, exports, module) {\n\n\n    var KeyEvent        = brackets.getModule(\"utils/KeyEvent\"),\n        Strings         = brackets.getModule(\"strings\"),\n        Mustache        = brackets.getModule(\"thirdparty/mustache/mustache\");\n\n    var TimingFunctionUtils = require(\"TimingFunctionUtils\");\n\n    /** Mustache template that forms the bare DOM structure of the UI */\n    var BezierCurveEditorTemplate = require(\"text!BezierCurveEditorTemplate.html\");\n\n    /** @const @type {number} */\n    var HEIGHT_ABOVE    =  75,    // extra height above main grid\n        HEIGHT_BELOW    =  75,    // extra height below main grid\n        HEIGHT_MAIN     = 150,    // height of main grid\n        WIDTH_MAIN      = 150;    // width of main grid\n\n    var animationRequest = null;\n\n    /**\n     * CubicBezier object constructor\n     *\n     * @param {string|Array.number[4]} coordinates Four parameters passes to cubic-bezier()\n     *      either in string or array format.\n     */\n    function CubicBezier(coordinates) {\n        if (typeof coordinates === \"string\") {\n            this.coordinates = coordinates.split(\",\");\n        } else {\n            this.coordinates = coordinates;\n        }\n\n        if (!this.coordinates) {\n            throw \"No offsets were defined\";\n        }\n\n        this.coordinates = this.coordinates.map(function (n) { return +n; });\n\n        var i;\n        for (i = 3; i >= 0; i--) {\n            var xy = this.coordinates[i];\n            if (isNaN(xy) || (((i % 2) === 0) && (xy < 0 || xy > 1))) {\n                throw \"Wrong coordinate at \" + i + \"(\" + xy + \")\";\n            }\n        }\n    }\n\n    /**\n     * BezierCanvas object constructor\n     *\n     * @param {Element} canvas Inline editor <canvas> element\n     * @param {CubicBezier} bezier Associated CubicBezier object\n     * @param {number|Array.number} padding Element padding\n     */\n    function BezierCanvas(canvas, bezier, padding) {\n        this.canvas  = canvas;\n        this.bezier  = bezier;\n        this.padding = this.getPadding(padding);\n\n        // Convert to a cartesian coordinate system with axes from 0 to 1\n        var ctx = this.canvas.getContext(\"2d\"),\n            p = this.padding;\n\n        ctx.scale(canvas.width * (1 - p[1] - p[3]), -canvas.height * 0.5 * (1 - p[0] - p[2]));\n        ctx.translate(p[3] / (1 - p[1] - p[3]), (-1 - p[0] / (1 - p[0] - p[2])) - 0.5);\n    }\n\n    BezierCanvas.prototype = {\n\n        /**\n         * Calculates CSS offsets for <canvas> element\n         *\n         * @return {left:string, top:string}\n         */\n        getOffsets: function () {\n            var p = this.padding,\n                w = this.canvas.width,\n                h = this.canvas.height * 0.5;\n\n            return [{\n                left: w * (this.bezier.coordinates[0]     * (1 - p[3] - p[1]) - p[3]) + \"px\",\n                top: h * (1 - this.bezier.coordinates[1] * (1 - p[0] - p[2]) - p[0]) + \"px\"\n            }, {\n                left: w * (this.bezier.coordinates[2]     * (1 - p[3] - p[1]) - p[3]) + \"px\",\n                top: h * (1 - this.bezier.coordinates[3] * (1 - p[0] - p[2]) - p[0]) + \"px\"\n            }];\n        },\n\n        /**\n         * Round off number to hundreths place, convert to string, and strip leading zero\n         *\n         * @param {number} v Value\n         * @return {string}\n         */\n        prettify: function (v) {\n            return (Math.round(v * 100) / 100).toString().replace(/^0\\./, \".\");\n        },\n\n        /**\n         * Get CSS left, top offsets for endpoint handle\n         *\n         * @param {Element} element Endpoint handle <button> element\n         * @return {Array.string[2]}\n         */\n        offsetsToCoordinates: function (element) {\n            var p = this.padding,\n                w = this.canvas.width,\n                h = this.canvas.height * 0.5;\n\n            // Convert padding percentage to actual padding\n            p = p.map(function (a, i) {\n                return a * ((i % 2) ? w : h);\n            });\n\n            return [\n                this.prettify((parseInt($(element).css(\"left\"), 10)    - p[3]) / (w + p[1] + p[3])),\n                this.prettify((h - parseInt($(element).css(\"top\"), 10) - p[2]) / (h - p[0] - p[2]))\n            ];\n        },\n\n        /**\n         * Paint canvas\n         *\n         * @param {Object} settings Paint settings\n         */\n        plot: function (settings) {\n            var xy = this.bezier.coordinates,\n                ctx = this.canvas.getContext(\"2d\"),\n                setting;\n\n            var defaultSettings = {\n                handleTimingFunction: \"#2893ef\",\n                handleThickness: 0.008,\n                vBorderThickness: 0.02,\n                hBorderThickness: 0.01,\n                bezierTimingFunction: \"#2893ef\",\n                bezierThickness: 0.03\n            };\n\n            settings = settings || {};\n\n            for (setting in defaultSettings) {\n                if (defaultSettings.hasOwnProperty(setting)) {\n                    if (!settings.hasOwnProperty(setting)) {\n                        settings[setting] = defaultSettings[setting];\n                    }\n                }\n            }\n\n            ctx.clearRect(-0.5, -0.5, 2, 2);\n\n            // Draw control handles\n            ctx.beginPath();\n            ctx.fillStyle = settings.handleTimingFunction;\n            ctx.lineWidth = settings.handleThickness;\n            ctx.strokeStyle = settings.handleTimingFunction;\n\n            ctx.moveTo(0, 0);\n            ctx.lineTo(xy[0], xy[1]);\n            ctx.moveTo(1, 1);\n            ctx.lineTo(xy[2], xy[3]);\n\n            ctx.stroke();\n            ctx.closePath();\n\n            ctx.beginPath();\n            ctx.arc(xy[0], xy[1], 1.5 * settings.handleThickness, 0, 2 * Math.PI, false);\n            ctx.closePath();\n\n            ctx.fill();\n\n            ctx.beginPath();\n            ctx.arc(xy[2], xy[3], 1.5 * settings.handleThickness, 0, 2 * Math.PI, false);\n            ctx.closePath();\n\n            ctx.fill();\n\n            // Draw bezier curve\n            ctx.beginPath();\n            ctx.lineWidth = settings.bezierThickness;\n            ctx.strokeStyle = settings.bezierColor;\n            ctx.moveTo(0, 0);\n            ctx.bezierCurveTo(xy[0], xy[1], xy[2], xy[3], 1, 1);\n            ctx.stroke();\n            ctx.closePath();\n        },\n\n        /**\n         * Convert CSS padding shorthand to longhand\n         *\n         * @param {number|Array.number} padding Element padding\n         * @return {Array.number}\n         */\n        getPadding: function (padding) {\n            var p = (typeof padding === \"number\") ? [padding] : padding;\n\n            if (p.length === 1) {\n                p[1] = p[0];\n            }\n            if (p.length === 2) {\n                p[2] = p[0];\n            }\n            if (p.length === 3) {\n                p[3] = p[1];\n            }\n\n            return p;\n        }\n    };\n\n    // Event handlers\n\n    /**\n     * Handle click in <canvas> element\n     *\n     * @param {Event} e Mouse click event\n     */\n    function _curveClick(e) {\n        var self = e.target,\n            bezierEditor = self.bezierEditor;\n\n        var curveBoundingBox = bezierEditor._getCurveBoundingBox(),\n            left = curveBoundingBox.left,\n            top  = curveBoundingBox.top,\n            x    = e.pageX - left,\n            y    = e.pageY - top - HEIGHT_ABOVE,\n            $P1  = $(bezierEditor.P1),\n            $P2  = $(bezierEditor.P2);\n\n        // Helper function to calculate distance between 2-D points\n        function distance(x1, y1, x2, y2) {\n            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n        }\n\n        // Find which point is closer\n        var distP1 = distance(x, y, parseInt($P1.css(\"left\"), 10), parseInt($P1.css(\"top\"), 10)),\n            distP2 = distance(x, y, parseInt($P2.css(\"left\"), 10), parseInt($P2.css(\"top\"), 10)),\n            $P     = (distP1 < distP2) ? $P1 : $P2;\n\n        $P.css({\n            left: x + \"px\",\n            top: y + \"px\"\n        });\n        $P.get(0).focus();\n\n        // update coords\n        bezierEditor._cubicBezierCoords = bezierEditor.bezierCanvas\n            .offsetsToCoordinates(bezierEditor.P1)\n            .concat(bezierEditor.bezierCanvas.offsetsToCoordinates(bezierEditor.P2));\n\n        bezierEditor._commitTimingFunction();\n        bezierEditor._updateCanvas();\n    }\n\n    /**\n     * Helper function for handling point move\n     *\n     * @param {Event} e Mouse move event\n     * @param {number} x New horizontal position\n     * @param {number} y New vertical position\n     */\n    function handlePointMove(e, x, y) {\n        var self = e.target,\n            bezierEditor = self.bezierEditor;\n\n        // Helper function to redraw curve\n        function mouseMoveRedraw() {\n            if (!bezierEditor.dragElement) {\n                animationRequest = null;\n                return;\n            }\n\n            // Update code\n            bezierEditor._commitTimingFunction();\n\n            bezierEditor._updateCanvas();\n            animationRequest = window.requestAnimationFrame(mouseMoveRedraw);\n        }\n\n        // This is a dragging state, but left button is no longer down, so mouse\n        // exited element, was released, and re-entered element. Treat like a drop.\n        if (bezierEditor.dragElement && (e.which !== 1)) {\n            bezierEditor.dragElement = null;\n            bezierEditor._commitTimingFunction();\n            bezierEditor._updateCanvas();\n            bezierEditor = null;\n            return;\n        }\n\n        // Constrain time (x-axis) to 0 to 1 range. Progression (y-axis) is\n        // theoretically not constrained, although canvas to drawing curve is\n        // arbitrarily constrained to -0.5 to 1.5 range.\n        x = Math.min(Math.max(0, x), WIDTH_MAIN);\n\n        if (bezierEditor.dragElement) {\n            $(bezierEditor.dragElement).css({\n                left: x + \"px\",\n                top: y + \"px\"\n            });\n        }\n\n        // update coords\n        bezierEditor._cubicBezierCoords = bezierEditor.bezierCanvas\n            .offsetsToCoordinates(bezierEditor.P1)\n            .concat(bezierEditor.bezierCanvas.offsetsToCoordinates(bezierEditor.P2));\n\n        if (!animationRequest) {\n            animationRequest = window.requestAnimationFrame(mouseMoveRedraw);\n        }\n    }\n\n    /**\n     * Update Time (x-axis) and Progression (y-axis) data for mouse position\n     *\n     * @param {Element} canvas <canvas> element\n     * @param {number} x Horizontal position\n     * @param {number} y Vertical position\n     */\n    function updateTimeProgression(curve, x, y) {\n        var percentX = Math.round(100 * x / WIDTH_MAIN),\n            percentY = Math.round(100 * ((HEIGHT_MAIN - y) / HEIGHT_MAIN));\n\n        // Constrain horizontal percentage to [0, 100] range\n        percentX = Math.min(Math.max(0, percentX), 100);\n\n        curve.parentNode.setAttribute(\"data-time\", percentX);\n        curve.parentNode.setAttribute(\"data-progression\", percentY);\n    }\n\n    /**\n     * Handle mouse move in <canvas> element\n     *\n     * @param {Event} e Mouse move event\n     */\n    function _curveMouseMove(e) {\n        var self = e.target,\n            bezierEditor = self.bezierEditor,\n            curveBoundingBox = bezierEditor._getCurveBoundingBox(),\n            left   = curveBoundingBox.left,\n            top    = curveBoundingBox.top,\n            x = e.pageX - left,\n            y = e.pageY - top - HEIGHT_ABOVE;\n\n        updateTimeProgression(self, x, y);\n\n        if (bezierEditor.dragElement) {\n            if (e.pageX === 0 && e.pageY === 0) {\n                return;\n            }\n\n            handlePointMove(e, x, y);\n        }\n    }\n\n    /**\n     * Handle mouse move in <button> element\n     *\n     * @param {Event} e Mouse move event\n     */\n    function _pointMouseMove(e) {\n        var self = e.target,\n            bezierEditor = self.bezierEditor,\n            curveBoundingBox = bezierEditor._getCurveBoundingBox(),\n            left = curveBoundingBox.left,\n            top  = curveBoundingBox.top,\n            x = e.pageX - left,\n            y = e.pageY - top - HEIGHT_ABOVE;\n\n        updateTimeProgression(bezierEditor.curve, x, y);\n\n        if (e.pageX === 0 && e.pageY === 0) {\n            return;\n        }\n\n        handlePointMove(e, x, y);\n    }\n\n    /**\n     * Handle mouse down in <button> element\n     *\n     * @param {Event} e Mouse down event\n     */\n    function _pointMouseDown(e) {\n        var self = e.target;\n\n        self.bezierEditor.dragElement = self;\n    }\n\n    /**\n     * Handle mouse up in <button> element\n     *\n     * @param {Event} e Mouse up event\n     */\n    function _pointMouseUp(e) {\n        var self = e.target;\n\n        self.focus();\n\n        if (self.bezierEditor.dragElement) {\n            self.bezierEditor.dragElement = null;\n            self.bezierEditor._commitTimingFunction();\n            self.bezierEditor._updateCanvas();\n        }\n    }\n\n    /**\n     * Handle key down in <button> element\n     *\n     * @param {Event} e Key down event\n     */\n    function _pointKeyDown(e) {\n        var code = e.keyCode,\n            self = e.target,\n            bezierEditor = self.bezierEditor;\n\n        if (code >= KeyEvent.DOM_VK_LEFT && code <= KeyEvent.DOM_VK_DOWN) {\n            e.preventDefault();\n\n            // Arrow keys pressed\n            var $this = $(e.target),\n                left = parseInt($this.css(\"left\"), 10),\n                top  = parseInt($this.css(\"top\"), 10),\n                offset = (e.shiftKey ? 15 : 3),\n                newVal;\n\n            switch (code) {\n            case KeyEvent.DOM_VK_LEFT:\n                newVal = Math.max(0, left - offset);\n                if (left === newVal) {\n                    return false;\n                }\n                $this.css({ left: newVal + \"px\" });\n                break;\n            case KeyEvent.DOM_VK_UP:\n                newVal = Math.max(-HEIGHT_ABOVE, top - offset);\n                if (top === newVal) {\n                    return false;\n                }\n                $this.css({ top: newVal + \"px\" });\n                break;\n            case KeyEvent.DOM_VK_RIGHT:\n                newVal = Math.min(WIDTH_MAIN, left + offset);\n                if (left === newVal) {\n                    return false;\n                }\n                $this.css({ left: newVal + \"px\" });\n                break;\n            case KeyEvent.DOM_VK_DOWN:\n                newVal = Math.min(HEIGHT_MAIN + HEIGHT_BELOW, top + offset);\n                if (top === newVal) {\n                    return false;\n                }\n                $this.css({ top: newVal + \"px\" });\n                break;\n            }\n\n            // update coords\n            bezierEditor._cubicBezierCoords = bezierEditor.bezierCanvas\n                .offsetsToCoordinates(bezierEditor.P1)\n                .concat(bezierEditor.bezierCanvas.offsetsToCoordinates(bezierEditor.P2));\n\n            bezierEditor._commitTimingFunction();\n            bezierEditor._updateCanvas();\n            return true;\n\n        } else if (code === KeyEvent.DOM_VK_ESCAPE) {\n            return true;\n        } else if (code === KeyEvent.DOM_VK_TAB && !e.ctrlKey && !e.metaKey && !e.altKey) {\n            // Switch between the two points by tabbing\n            if ($(e.target).hasClass(\"P1\")) {\n                $(\".P2\").focus();\n            } else {\n                $(\".P1\").focus();\n            }\n            e.preventDefault();\n            return true;\n        }\n\n        return false;\n    }\n\n\n    /**\n     * Constructor for BezierCurveEditor Object. This control may be used standalone\n     * or within an InlineTimingFunctionEditor inline widget.\n     *\n     * @param {!jQuery} $parent  DOM node into which to append the root of the bezier curve editor UI\n     * @param {!RegExpMatch} bezierCurve  RegExp match object of initially selected bezierCurve\n     * @param {!function(string)} callback  Called whenever selected bezierCurve changes\n     */\n    function BezierCurveEditor($parent, bezierCurve, callback) {\n        // Create the DOM structure, filling in localized strings via Mustache\n        this.$element = $(Mustache.render(BezierCurveEditorTemplate, Strings));\n        $parent.append(this.$element);\n\n        this._callback = callback;\n        this.dragElement = null;\n\n        // current cubic-bezier() function params\n        this._cubicBezierCoords = this._getCubicBezierCoords(bezierCurve);\n\n        this.hint = {};\n        this.hint.elem = $(\".hint\", this.$element);\n        // If function was auto-corrected, then originalString holds the original function,\n        // and an informational message needs to be shown\n        if (bezierCurve.originalString) {\n            TimingFunctionUtils.showHideHint(this.hint, true, bezierCurve.originalString, \"cubic-bezier(\" + this._cubicBezierCoords.join(\", \") + \")\");\n        } else {\n            TimingFunctionUtils.showHideHint(this.hint, false);\n        }\n\n        this.P1 = this.$element.find(\".P1\")[0];\n        this.P2 = this.$element.find(\".P2\")[0];\n        this.curve = this.$element.find(\".curve\")[0];\n\n        this.P1.bezierEditor = this.P2.bezierEditor = this.curve.bezierEditor = this;\n\n        this.bezierCanvas = new BezierCanvas(this.curve, null, [0, 0]);\n\n        // redraw canvas\n        this._updateCanvas();\n\n        $(this.curve)\n            .on(\"click\", _curveClick)\n            .on(\"mousemove\", _curveMouseMove);\n        $(this.P1)\n            .on(\"mousemove\", _pointMouseMove)\n            .on(\"mousedown\", _pointMouseDown)\n            .on(\"mouseup\", _pointMouseUp)\n            .on(\"keydown\", _pointKeyDown);\n        $(this.P2)\n            .on(\"mousemove\", _pointMouseMove)\n            .on(\"mousedown\", _pointMouseDown)\n            .on(\"mouseup\", _pointMouseUp)\n            .on(\"keydown\", _pointKeyDown);\n    }\n\n    /**\n     * Destructor called by InlineTimingFunctionEditor.onClosed()\n     */\n    BezierCurveEditor.prototype.destroy = function () {\n\n        this.P1.bezierEditor = this.P2.bezierEditor = this.curve.bezierEditor = null;\n\n        $(this.curve)\n            .off(\"click\", _curveClick)\n            .off(\"mousemove\", _curveMouseMove);\n        $(this.P1)\n            .off(\"mousemove\", _pointMouseMove)\n            .off(\"mousedown\", _pointMouseDown)\n            .off(\"mouseup\", _pointMouseUp)\n            .off(\"keydown\", _pointKeyDown);\n        $(this.P2)\n            .off(\"mousemove\", _pointMouseMove)\n            .off(\"mousedown\", _pointMouseDown)\n            .off(\"mouseup\", _pointMouseUp)\n            .off(\"keydown\", _pointKeyDown);\n    };\n\n\n    /** Returns the root DOM node of the BezierCurveEditor UI */\n    BezierCurveEditor.prototype.getRootElement = function () {\n        return this.$element;\n    };\n\n    /**\n     * Default focus needs to go somewhere, so give it to P1\n     */\n    BezierCurveEditor.prototype.focus = function () {\n        this.P1.focus();\n        return true;\n    };\n\n    /**\n     * Generates cubic-bezier function based on coords, and updates the doc\n     */\n    BezierCurveEditor.prototype._commitTimingFunction = function () {\n        var bezierCurveVal = \"cubic-bezier(\" +\n            this._cubicBezierCoords[0] + \", \" +\n            this._cubicBezierCoords[1] + \", \" +\n            this._cubicBezierCoords[2] + \", \" +\n            this._cubicBezierCoords[3] + \")\";\n        this._callback(bezierCurveVal);\n        TimingFunctionUtils.showHideHint(this.hint, false);\n    };\n\n    /**\n     * Handle all matches returned from TimingFunctionUtils.cubicBezierMatch() and\n     * return array of coords\n     *\n     * @param {RegExp.match} match Matches returned from cubicBezierMatch()\n     * @return {Array.number[4]}\n     */\n    BezierCurveEditor.prototype._getCubicBezierCoords = function (match) {\n\n        if (match[0].match(/^cubic-bezier/)) {\n            // cubic-bezier()\n            return match.slice(1, 5);\n        }\n            // handle special cases of cubic-bezier calls\n        switch (match[0]) {\n        case \"linear\":\n            return [ \"0\", \"0\", \"1\", \"1\" ];\n        case \"ease\":\n            return [ \".25\", \".1\", \".25\", \"1\" ];\n        case \"ease-in\":\n            return [ \".42\", \"0\", \"1\", \"1\" ];\n        case \"ease-out\":\n            return [ \"0\", \"0\", \".58\", \"1\" ];\n        case \"ease-in-out\":\n            return [ \".42\", \"0\", \".58\", \"1\" ];\n        }\n\n\n        window.console.log(\"brackets-cubic-bezier: getCubicBezierCoords() passed invalid RegExp match array\");\n        return [ \"0\", \"0\", \"0\", \"0\" ];\n    };\n\n    /**\n     * Get <canvas> element's bounding box\n     *\n     * @return {left: number, top: number, width: number, height: number}\n     */\n    BezierCurveEditor.prototype._getCurveBoundingBox = function () {\n        var $canvas = this.$element.find(\".curve\"),\n            canvasOffset = $canvas.offset();\n\n        return {\n            left: canvasOffset.left,\n            top: canvasOffset.top,\n            width: $canvas.width(),\n            height: $canvas.height()\n        };\n    };\n\n    /**\n     * Update <canvas> after a change\n     */\n    BezierCurveEditor.prototype._updateCanvas = function () {\n        // collect data, build model\n        if (this._cubicBezierCoords) {\n            this.bezierCanvas.bezier = window.bezier = new CubicBezier(this._cubicBezierCoords);\n\n            var offsets = this.bezierCanvas.getOffsets();\n\n            $(this.P1).css({\n                left: offsets[0].left,\n                top: offsets[0].top\n            });\n            $(this.P2).css({\n                left: offsets[1].left,\n                top: offsets[1].top\n            });\n\n            this.bezierCanvas.plot();\n        }\n    };\n\n    /**\n     * Handle external update\n     *\n     * @param {!RegExpMatch} bezierCurve  RegExp match object of updated bezierCurve\n     */\n    BezierCurveEditor.prototype.handleExternalUpdate = function (bezierCurve) {\n        this._cubicBezierCoords = this._getCubicBezierCoords(bezierCurve);\n        this._updateCanvas();\n        // If function was auto-corrected, then originalString holds the original function,\n        // and an informational message needs to be shown\n        if (bezierCurve.originalString) {\n            TimingFunctionUtils.showHideHint(this.hint, true, bezierCurve.originalString, \"cubic-bezier(\" + this._cubicBezierCoords.join(\", \") + \")\");\n        } else {\n            TimingFunctionUtils.showHideHint(this.hint, false);\n        }\n    };\n\n\n    exports.BezierCurveEditor = BezierCurveEditor;\n});\n"],"file":"BezierCurveEditor.js"}
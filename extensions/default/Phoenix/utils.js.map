{"version":3,"sources":["extensions/default/Phoenix/utils.js"],"names":["define","require","exports","module","async","_ensureExistsAsync","path","Promise","resolve","reject","Phoenix","VFS","ensureExistsDir","err","_copyZippedItemToFS","item","destProjectDir","flattenFirstLevel","destPath","newPath","substr","indexOf","console","log","dir","window","dirname","then","data","fs","writeFile","Filer","Buffer","from","writeErr","catch","error","e","unzipFileToLocation","zipData","projectDir","progressControlCallback","endsWith","JSZip","loadAsync","zip","keys","Object","files","extractBatchSize","totalCount","length","doneCount","extractPromises","continueExtraction","extractPromise","push","all","unzipURLToLocation","url","JSZipUtils","getBinaryContent"],"mappings":"AAsBAA,OAAO,SAAUC,QAASC,QAASC,QAE/BC,eAAeC,mBAAmBC,MAC9B,OAAO,IAAIC,QAAQ,CAACC,QAASC,UACzBC,QAAQC,IAAIC,gBAAgBN,KAAOO,MAC5BA,IACCJ,OAAOI,KAEPL,cAMhB,SAASM,oBAAoBR,KAAMS,KAAMC,eAAgBC,mBACrD,OAAO,IAAIV,QAAQH,MAAOI,QAASC,UAC/B,IACI,IAAIS,YAAcF,iBAAiBV,OACnC,GAAGW,kBAAkB,CAEjB,IAAIE,QAAUb,KAAKc,OAAOd,KAAKe,QAAQ,KAAO,GAC9CH,YAAcF,iBAAiBG,UAC/BG,QAAQC,IAAIL,UAEbH,KAAKS,WACEnB,mBAAmBa,UACzBV,QAAQU,kBAEFb,mBAAmBoB,OAAOnB,KAAKoB,QAAQR,WAC7CH,KAAKX,MAAM,cAAcuB,KAAK,SAAUC,MACpCH,OAAOI,GAAGC,UAAUZ,SAAUa,MAAMC,OAAOC,KAAKL,MAAOM,WAChDA,SACCzB,OAAOyB,UAEP1B,QAAQU,cAGjBiB,MAAMC,QACL3B,OAAO2B,UAGjB,MAAOC,GACL5B,OAAO4B,MAoBnB,SAASC,oBAAoBC,QAASC,WAAYvB,mBAAoB,EAAOwB,yBAIzE,OAHID,WAAWE,SAAS,OACpBF,YAA0B,KAEvB,IAAIjC,QAAQ,CAACC,QAASC,UACzBkC,MAAMC,UAAUL,SAASZ,KAAKvB,eAAgByC,KAC1C,IAAIC,KAAOC,OAAOD,KAAKD,IAAIG,OAC3B,IACI,MAAMC,iBAAmB,IACzB,IAAIC,WAAaJ,KAAKK,OAClBC,UAAY,EACZC,gBAAkB,GAClBC,oBAAqB,EACzB,IAAI,IAAIhD,QAAQwC,KAAK,CAEjB,IAAIS,eAAiBzC,oBAAoBR,KAAMuC,IAAIG,MAAM1C,MAAOkC,WAAYvB,mBAa5E,GAXAsC,eAAe5B,KAAK,KAChByB,YACGX,0BACCa,mBAAqBb,wBAAwBW,UAAWF,eAGhEG,gBAAgBG,KAAKD,gBAClBF,gBAAgBF,SAAWF,yBACpB1C,QAAQkD,IAAIJ,iBAClBA,gBAAkB,KAEI,IAAvBC,mBAEC,YADA7C,OAAO,+CAIZ4C,gBAAgBF,cACT5C,QAAQkD,IAAIJ,iBAEtB/B,QAAQC,IAAI,mBAAoBiB,YAChChC,UACF,MAAOK,KACLS,QAAQc,MAAM,eAAgBvB,KAC9BJ,OAAOI,UAiBvB,SAAS6C,mBAAmBC,IAAKnB,WAAYvB,mBAAoB,GAC7D,OAAO,IAAIV,QAAQ,CAACC,QAASC,UACzBgB,OAAOmC,WAAWC,iBAAiBF,IAAKvD,eAAeS,IAAKe,MACrDf,KACCS,QAAQc,sCAAsCuB,SAAU9C,KACxDJ,UAEA6B,oBAAoBV,KAAMY,WAAYvB,mBACjCU,KAAKnB,SACL2B,MAAM1B,YAK3BP,QAAQoC,oBAAsBA,oBAC9BpC,QAAQwD,mBAAqBA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*globals Phoenix, JSZip, Filer*/\n\ndefine(function (require, exports, module) {\n\n    async function _ensureExistsAsync(path) {\n        return new Promise((resolve, reject)=>{\n            Phoenix.VFS.ensureExistsDir(path, (err)=>{\n                if(err){\n                    reject(err);\n                } else {\n                    resolve();\n                }\n            });\n        });\n    }\n\n    function _copyZippedItemToFS(path, item, destProjectDir, flattenFirstLevel) {\n        return new Promise(async (resolve, reject) =>{ // eslint-disable-line\n            try {\n                let destPath = `${destProjectDir}${path}`;\n                if(flattenFirstLevel){\n                    // contents/index.html to index.html\n                    let newPath = path.substr(path.indexOf(\"/\") + 1);\n                    destPath = `${destProjectDir}${newPath}`;\n                    console.log(destPath);\n                }\n                if(item.dir){\n                    await _ensureExistsAsync(destPath);\n                    resolve(destPath);\n                } else {\n                    await _ensureExistsAsync(window.path.dirname(destPath));\n                    item.async(\"uint8array\").then(function (data) {\n                        window.fs.writeFile(destPath, Filer.Buffer.from(data), writeErr=>{\n                            if(writeErr){\n                                reject(writeErr);\n                            } else {\n                                resolve(destPath);\n                            }\n                        });\n                    }).catch(error=>{\n                        reject(error);\n                    });\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    /**\n     *\n     * @param zipData binary UInt8Array zip data\n     * @param projectDir To extract to\n     * @param flattenFirstLevel if set to true, then if zip contents are nested inside a directory, the nexted dir will\n     * be removed in the path structure in destination. For Eg. some Zip may contain a `contents` folder inside the zip\n     * which has all the contents. If we blindly extract the zio, all the contents will be placed inside a `contents`\n     * folder in root and not the root dir itself.\n     * See a sample zip file here: https://api.github.com/repos/StartBootstrap/startbootstrap-grayscales/zipball\n     * @param {function(doneCount: number, totalCount: number)} [progressControlCallback] A function that can be used\n     * to view the progress and stop further extraction. The function will be invoked with (doneCount, totalCount).\n     * The function should return `false` if further extraction needs to be stopped. If nothing or `true` is returned,\n     * it will continue extraction.\n     * @returns {Promise}\n     */\n    function unzipFileToLocation(zipData, projectDir, flattenFirstLevel = false, progressControlCallback) {\n        if(!projectDir.endsWith('/')){\n            projectDir = projectDir + \"/\";\n        }\n        return new Promise((resolve, reject)=>{\n            JSZip.loadAsync(zipData).then(async function (zip) {\n                let keys = Object.keys(zip.files);\n                try{\n                    const extractBatchSize = 500;\n                    let totalCount = keys.length,\n                        doneCount = 0,\n                        extractPromises = [],\n                        continueExtraction = true;\n                    for(let path of keys){\n                        // This is intentionally batched as fs access api hangs on large number of file access\n                        let extractPromise = _copyZippedItemToFS(path, zip.files[path], projectDir, flattenFirstLevel);\n                        // eslint-disable-next-line no-loop-func\n                        extractPromise.then(()=>{\n                            doneCount ++;\n                            if(progressControlCallback){\n                                continueExtraction = progressControlCallback(doneCount, totalCount);\n                            }\n                        });\n                        extractPromises.push(extractPromise);\n                        if(extractPromises.length === extractBatchSize){\n                            await Promise.all(extractPromises);\n                            extractPromises = [];\n                        }\n                        if(continueExtraction === false){\n                            reject(`Extraction cancelled by progress controller`);\n                            return;\n                        }\n                    }\n                    if(extractPromises.length) {\n                        await Promise.all(extractPromises);\n                    }\n                    console.log(\"Unzip complete: \", projectDir);\n                    resolve();\n                } catch (err) {\n                    console.error('unzip failed', err);\n                    reject(err);\n                }\n            });\n        });\n    }\n\n    /**\n     *\n     * @param url the zip fle URL\n     * @param projectDir To extract to\n     * @param flattenFirstLevel if set to true, then if zip contents are nested inside a directory, the nexted dir will\n     * be removed in the path structure in destination. For Eg. some Zip may contain a `contents` folder inside the zip\n     * which has all the contents. If we blindly extract the zio, all the contents will be placed inside a `contents`\n     * folder in root and not the root dir itself.\n     * See a sample zip file here: https://api.github.com/repos/StartBootstrap/startbootstrap-grayscales/zipball\n     * @returns {Promise}\n     */\n    function unzipURLToLocation(url, projectDir, flattenFirstLevel = false) {\n        return new Promise((resolve, reject)=>{\n            window.JSZipUtils.getBinaryContent(url, async function(err, data) {\n                if(err) {\n                    console.error(`could not load zip from URL: ${url}\\n `, err);\n                    reject();\n                } else {\n                    unzipFileToLocation(data, projectDir, flattenFirstLevel)\n                        .then(resolve)\n                        .catch(reject);\n                }\n            });\n        });\n    }\n    exports.unzipFileToLocation = unzipFileToLocation;\n    exports.unzipURLToLocation = unzipURLToLocation;\n});\n"],"file":"utils.js"}
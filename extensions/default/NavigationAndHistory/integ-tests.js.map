{"version":3,"sources":["extensions/default/NavigationAndHistory/integ-tests.js"],"names":["define","require","exports","module","SpecRunnerUtils","brackets","getModule","describe","testPathOriginal","getTestPath","testPath","getTestRoot","tempRestorePath","FileViewController","ProjectManager","CommandManager","Commands","testWindow","EditorManager","MainViewManager","FileSystem","$","async","deletePath","pathToDel","startsWith","promise","awaitsForDone","loadTestWindow","force","createTestWindowAndRun","forceReload","test","copyPath","loadProjectInTestWindow","closeSession","execute","FILE_CLOSE_ALL","_forceClose","openFile","relativePath","openAndSelectDocument","PROJECT_MANAGER","isFileOpen","fullPath","allOpenFiles","getAllOpenFiles","file","initFileRestorer","fileToOpen","scanInterval","waitTillPathNotExists","expect","toBeTrue","_FileRecoveryExtensionForTests","exists","pathExists","toBeFalse","initWith","getDirectoryForPath","waitTillPathExists","beforeEach","afterAll","closeTestWindow","it","projectRestorePath","getProjectRestoreRoot","editor","getActiveEditor","document","setText","FILE_SAVE_ALL","unsavedText","Math","random","location","href","awaits","awaitsFor","length","click","getText"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global describe, it, expect, beforeAll, afterAll, awaitsForDone, beforeEach, awaits, awaitsFor */\n\ndefine(function (require, exports, module) {\n    // Recommended to avoid reloading the integration test window Phoenix instance for each test.\n\n    const SpecRunnerUtils     = brackets.getModule(\"spec/SpecRunnerUtils\");\n\n    describe(\"LegacyInteg:FileRecovery integration tests\", function () {\n\n        const testPathOriginal = SpecRunnerUtils.getTestPath(\"/spec/ProjectManager-test-files\");\n        const testPath = SpecRunnerUtils.getTestRoot() + \"/navigationTests/\";\n        const tempRestorePath = SpecRunnerUtils.getTestRoot() + \"/navigationTestsRestore/\";\n\n        let FileViewController,     // loaded from brackets.test\n            ProjectManager,         // loaded from brackets.test;\n            CommandManager,\n            Commands,\n            testWindow,\n            EditorManager,\n            MainViewManager,\n            brackets,\n            FileSystem,\n            $;\n\n\n        async function deletePath(pathToDel) {\n            if(!pathToDel.startsWith(\"/\")) {\n                pathToDel = testPath + pathToDel;\n            }\n            let promise = SpecRunnerUtils.deletePath(pathToDel, true);\n            await awaitsForDone(promise, \"Remove \" + pathToDel, 5000);\n        }\n\n        async function loadTestWindow(force) {\n            testWindow = await SpecRunnerUtils.createTestWindowAndRun({forceReload: force});\n            brackets            = testWindow.brackets;\n            $                   = testWindow.$;\n            FileViewController  = brackets.test.FileViewController;\n            ProjectManager      = brackets.test.ProjectManager;\n            CommandManager      = brackets.test.CommandManager;\n            Commands            = brackets.test.Commands;\n            EditorManager       = brackets.test.EditorManager;\n            MainViewManager     = brackets.test.MainViewManager;\n            FileSystem          = brackets.test.FileSystem;\n            await awaitsForDone(SpecRunnerUtils.copyPath(testPathOriginal, testPath), \"copy temp files\");\n            await SpecRunnerUtils.loadProjectInTestWindow(testPath);\n        }\n\n        beforeEach(async function () {\n            await closeSession();\n            await deletePath(testPath);\n            await deletePath(tempRestorePath);\n            await loadTestWindow(true);\n        }, 30000);\n\n        afterAll(async function () {\n            FileViewController  = null;\n            ProjectManager      = null;\n            testWindow = null;\n            brackets = null;\n            await deletePath(testPath);\n            await deletePath(tempRestorePath);\n            await SpecRunnerUtils.closeTestWindow(true);\n        }, 30000);\n\n        async function closeSession() {\n            if(!CommandManager){\n                return;\n            }\n            await awaitsForDone(CommandManager.execute(Commands.FILE_CLOSE_ALL, { _forceClose: true }),\n                \"closing all file\");\n        }\n\n        async function openFile(relativePath) {\n            await awaitsForDone(\n                FileViewController.openAndSelectDocument(\n                    testPath + relativePath,\n                    FileViewController.PROJECT_MANAGER\n                ));\n        }\n\n        function isFileOpen(relativePath) {\n            const fullPath = testPath + relativePath;\n            let allOpenFiles = MainViewManager.getAllOpenFiles();\n            for(let file of allOpenFiles){\n                if(file.fullPath === fullPath){\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        async function initFileRestorer(fileToOpen, scanInterval = 100) {\n            await deletePath(tempRestorePath);\n            await SpecRunnerUtils.waitTillPathNotExists(tempRestorePath);\n            await openFile(fileToOpen);\n            expect(isFileOpen(fileToOpen)).toBeTrue();\n            expect(testWindow._FileRecoveryExtensionForTests).exists;\n            expect(await SpecRunnerUtils.pathExists(tempRestorePath, true)).toBeFalse();\n            testWindow._FileRecoveryExtensionForTests.initWith(scanInterval,\n                FileSystem.getDirectoryForPath(tempRestorePath));\n            await SpecRunnerUtils.waitTillPathExists(tempRestorePath);\n\n        }\n\n        it(\"Should create restore folders and backup files\", async function () {\n            await initFileRestorer(\"file.js\");\n            let projectRestorePath = testWindow._FileRecoveryExtensionForTests.getProjectRestoreRoot(testPath);\n\n            // now edit a file so that its backup is created\n            let editor = EditorManager.getActiveEditor();\n            editor.document.setText(\"hello\");\n            await SpecRunnerUtils.waitTillPathExists(projectRestorePath.fullPath, true);\n            await SpecRunnerUtils.waitTillPathExists(projectRestorePath.fullPath + \"file.js\", false);\n            await closeSession();\n        });\n\n        it(\"Should saving files remove file restore folder\", async function () {\n            await initFileRestorer(\"toDelete1/file.js\");\n            let projectRestorePath = testWindow._FileRecoveryExtensionForTests.getProjectRestoreRoot(testPath);\n\n            // now edit a file so that its backup is created\n            let editor = EditorManager.getActiveEditor();\n            editor.document.setText(\"hello\");\n            await SpecRunnerUtils.waitTillPathExists(projectRestorePath.fullPath + \"toDelete1/file.js\", false);\n            await awaitsForDone(CommandManager.execute(Commands.FILE_SAVE_ALL), \"saving all file\");\n            await SpecRunnerUtils.waitTillPathNotExists(projectRestorePath.fullPath + \"toDelete1/file.js\", false);\n            await closeSession();\n        });\n\n        it(\"Should show restore notification and restore if there is anything to restore\", async function () {\n            await initFileRestorer(\"toDelete1/file.js\");\n            let projectRestorePath = testWindow._FileRecoveryExtensionForTests.getProjectRestoreRoot(testPath);\n\n            // now edit a file so that its backup is created\n            const unsavedText = \"hello\" + Math.random();\n            let editor = EditorManager.getActiveEditor();\n            editor.document.setText(unsavedText);\n            await SpecRunnerUtils.waitTillPathExists(projectRestorePath.fullPath + \"toDelete1/file.js\", false);\n\n            // backup is now present, reload the project\n            testWindow.location.href = \"about:blank\";\n            await awaits(1000);\n            await SpecRunnerUtils.closeTestWindow(true, true);\n            await loadTestWindow(true);\n            testWindow._FileRecoveryExtensionForTests.initWith(100,\n                FileSystem.getDirectoryForPath(tempRestorePath));\n            await awaitsFor(()=>{\n                return $(\".file-recovery-button\").length === 1;\n            }, \"waiting for restore notification\", 5000);\n\n            // now press the recover button to start the recovery\n            $(\".file-recovery-button\").click();\n            // check if the file is recovered\n            await awaitsFor(()=>{\n                editor = EditorManager.getActiveEditor();\n                return editor && editor.document.getText() === unsavedText;\n            }, \"waiting for restore notification\", 5000);\n            await closeSession();\n        }, 30000);\n\n        // below project switch test case is flakey. need to fix. disable for now.\n        // it(\"Should show restore on project switch\", async function () {\n        //     const readOnlyProject = SpecRunnerUtils.getTestPath(\"/spec/ProjectManager-test-files\");\n        //     await initFileRestorer(\"toDelete1/file.js\", 1000);\n        //     let projectRestorePath = testWindow._FileRecoveryExtensionForTests.getProjectRestoreRoot(testPath);\n        //\n        //     // now edit a file so that its backup is created\n        //     const unsavedText = \"hello\" + Math.random();\n        //     let editor = EditorManager.getActiveEditor();\n        //     editor.document.setText(unsavedText);\n        //     await SpecRunnerUtils.waitTillPathExists(projectRestorePath.fullPath + \"toDelete1/file.js\", false);\n        //\n        //     // backup is now present, switch to another project\n        //     let loadPromise = SpecRunnerUtils.loadProjectInTestWindow(readOnlyProject);\n        //     await awaitsFor(()=>{\n        //         return $('button[data-button-id=dontsave]').length >= 1;\n        //     }, \"waiting for save changes dialogue\", 5000);\n        //     $('button[data-button-id=dontsave]')[0].click();\n        //     await loadPromise;\n        //     await SpecRunnerUtils.loadProjectInTestWindow(testPath);\n        //     await awaits(3000);\n        //     await awaitsFor(()=>{\n        //         return $(\".file-recovery-button\").length === 1;\n        //     }, \"waiting for restore notification\", 5000);\n        //\n        //     // now press the recover button to start the recovery\n        //     $(\".file-recovery-button\").click();\n        //     // check if the file is recovered\n        //     await awaitsFor(()=>{\n        //         editor = EditorManager.getActiveEditor();\n        //         return editor && editor.document.getText() === unsavedText;\n        //     }, \"waiting for restore notification\", 5000);\n        //     await closeSession();\n        // }, 1000000);\n    });\n});\n"],"file":"integ-tests.js"}
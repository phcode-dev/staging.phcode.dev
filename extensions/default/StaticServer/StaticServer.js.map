{"version":3,"sources":["extensions/default/StaticServer/StaticServer.js"],"names":["define","require","exports","module","BaseServer","brackets","getModule","LiveDevelopmentUtils","marked","DocumentManager","Mustache","markdownHTMLTemplate","_serverBroadcastChannel","BroadcastChannel","_staticServerInstance","StaticServer","config","baseUrl","window","fsServerUrl","Phoenix","PHOENIX_INSTANCE_ID","this","_sendInstrumentedContent","bind","call","_sendMarkdown","fullPath","requestID","getDocumentForPath","done","doc","text","getText","markdownHtml","templateVars","markdownContent","parse","BOOTSTRAP_LIB_CSS","parent","baseURL","HIGHLIGHT_JS_CSS","HIGHLIGHT_JS","GFM_CSS","html","render","postMessage","type","contents","headers","Content-Type","fail","err","console","error","_getExtension","filePath","pathSplit","split","length","_isMarkdownFile","extension","includes","toLowerCase","setOptions","renderer","Renderer","pedantic","gfm","breaks","sanitize","smartLists","smartypants","xhtml","prototype","Object","create","constructor","pathToUrl","path","getBaseUrl","relativePath","_pathResolver","encodeURI","urlToPath","url","indexOf","replace","decodeURI","canServe","localPath","match","isStaticHtmlFileExt","_updateInstrumentedURLSInWorker","paths","keys","_liveDocuments","concat","_virtualServingDocuments","log","_root","messageSW","root","then","status","catch","readyToServe","$","Deferred","resolve","promise","addVirtualContentAtPath","docText","add","liveDocument","setInstrumentationEnabled","remove","removeVirtualContentAtPath","clear","_send","location","response","_nodeDomain","exec","pathname","data","phoenixInstanceID","_documentKey","virtualDocument","body","getResponseData","onmessage","event","start","stop","undefined"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2012 - present Adobe Systems Incorporated. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n */\n\n/*global Phoenix */\n\ndefine(function (require, exports, module) {\n\n    const BaseServer = brackets.getModule(\"LiveDevelopment/Servers/BaseServer\").BaseServer,\n        LiveDevelopmentUtils = brackets.getModule(\"LiveDevelopment/LiveDevelopmentUtils\"),\n        marked = brackets.getModule('thirdparty/marked.min'),\n        DocumentManager = brackets.getModule(\"document/DocumentManager\"),\n        Mustache = brackets.getModule(\"thirdparty/mustache/mustache\"),\n        markdownHTMLTemplate = require(\"text!markdown.html\");\n\n    const _serverBroadcastChannel = new BroadcastChannel(\"virtual_server_broadcast\");\n\n    let _staticServerInstance;\n\n    // see markdown advanced rendering options at https://marked.js.org/using_advanced\n    marked.setOptions({\n        renderer: new marked.Renderer(),\n        pedantic: false,\n        gfm: true,\n        breaks: false,\n        sanitize: false,\n        smartLists: true,\n        smartypants: false,\n        xhtml: false\n    });\n\n    /**\n     * @constructor\n     * @extends {BaseServer}\n     * Live preview server that uses a built-in HTTP server to serve static\n     * and instrumented files.\n     *\n     * @param {!{baseUrl: string, root: string, pathResolver: function(string), nodeDomain: NodeDomain}} config\n     *    Configuration parameters for this server:\n     *        baseUrl        - Optional base URL (populated by the current project)\n     *        pathResolver   - Function to covert absolute native paths to project relative paths\n     *        root           - Native path to the project root (and base URL)\n     */\n    function StaticServer(config) {\n        config.baseUrl = `${window.fsServerUrl}PHOENIX_LIVE_PREVIEW_${Phoenix.PHOENIX_INSTANCE_ID}`;\n        this._sendInstrumentedContent = this._sendInstrumentedContent.bind(this);\n        BaseServer.call(this, config);\n    }\n\n    StaticServer.prototype = Object.create(BaseServer.prototype);\n    StaticServer.prototype.constructor = StaticServer;\n\n    /**\n     * Returns a URL for a given path\n     * @param {string} path Absolute path to covert to a URL\n     * @return {?string} Converts a path within the project root to a URL.\n     *  Returns null if the path is not a descendant of the project root.\n     */\n    StaticServer.prototype.pathToUrl = function (path) {\n        const baseUrl         = this.getBaseUrl(),\n            relativePath    = this._pathResolver(path);\n\n        // See if base url has been specified and path is within project\n        if (relativePath !== path) {\n            // Map to server url. Base url is already encoded, so don't encode again.\n\n            return `${baseUrl}${encodeURI(path)}`;\n        }\n\n        return null;\n    };\n\n    /**\n     * Convert a URL to a local full file path\n     * @param {string} url\n     * @return {?string} The absolute path for given URL or null if the path is\n     *  not a descendant of the project.\n     */\n    StaticServer.prototype.urlToPath = function (url) {\n        let path,\n            baseUrl = \"\";\n\n        baseUrl = this.getBaseUrl();\n\n        if (baseUrl !== \"\" && url.indexOf(baseUrl) === 0) {\n            // Use base url to translate to local file path.\n            // Need to use encoded project path because it's decoded below.\n            path = url.replace(baseUrl, \"\");\n\n            return decodeURI(path);\n        }\n\n        return null;\n    };\n\n    /**\n     * Determines whether we can serve local file.\n     * @param {string} localPath A local path to file being served.\n     * @return {boolean} true for yes, otherwise false.\n     */\n    StaticServer.prototype.canServe = function (localPath) {\n        // If we can't transform the local path to a project relative path,\n        // the path cannot be served\n        if (localPath === this._pathResolver(localPath)) {\n            return false;\n        }\n\n        // Url ending in \"/\" implies default file, which is usually index.html.\n        // Return true to indicate that we can serve it.\n        if (localPath.match(/\\/$/)) {\n            return true;\n        }\n\n        // FUTURE: do a MIME Type lookup on file extension\n        return LiveDevelopmentUtils.isStaticHtmlFileExt(localPath);\n    };\n\n    /**\n     * @private\n     * Update the list of paths that fire \"request\" events\n     * @return {jQuery.Promise} Resolved by the StaticServer domain when the message is acknowledged.\n     */\n    StaticServer.prototype._updateInstrumentedURLSInWorker = function () {\n        let paths = Object.keys(this._liveDocuments)\n            .concat(Object.keys(this._virtualServingDocuments));\n        console.log(`Static server _updateInstrumentedURLSInWorker: `, this._root, paths);\n\n        window.messageSW({\n            type: 'setInstrumentedURLs',\n            root: this._root,\n            paths\n        }).then((status)=>{\n            console.log(`Static server received msg from Service worker: setInstrumentedURLs done: `, status);\n        }).catch(err=>{\n            console.error(\"Static server received msg from Service worker: Error while setInstrumentedURLs\", err);\n        });\n    };\n\n    /**\n     * Gets the server details from the StaticServerDomain in node.\n     * The domain itself handles starting a server if necessary (when\n     * the staticServer.getServer command is called).\n     *\n     * @return {jQuery.Promise} A promise that resolves/rejects when\n     *     the server is ready/failed.\n     */\n    StaticServer.prototype.readyToServe = function () {\n        return $.Deferred().resolve().promise(); // virtual server is always assumed present in phoenix\n    };\n\n    /**\n     * This will add the given text to be served when the path is hit in server. use this to either serve a file\n     * that doesn't exist in project, or to override a given path to the contents you give.\n     */\n    StaticServer.prototype.addVirtualContentAtPath = function (path, docText) {\n        BaseServer.prototype.addVirtualContentAtPath.call(this, path, docText);\n\n        // update the paths to watch\n        this._updateInstrumentedURLSInWorker();\n    };\n\n    /**\n     * See BaseServer#add. StaticServer ignores documents that do not have\n     * a setInstrumentationEnabled method. Updates request filters.\n     */\n    StaticServer.prototype.add = function (liveDocument) {\n        if (liveDocument.setInstrumentationEnabled) {\n            // enable instrumentation\n            liveDocument.setInstrumentationEnabled(true);\n        }\n\n        BaseServer.prototype.add.call(this, liveDocument);\n\n        // update the paths to watch\n        this._updateInstrumentedURLSInWorker();\n    };\n\n    /**\n     * See BaseServer#remove. Updates request filters.\n     */\n    StaticServer.prototype.remove = function (liveDocument) {\n        BaseServer.prototype.remove.call(this, liveDocument);\n\n        this._updateInstrumentedURLSInWorker();\n    };\n\n    /**\n     * removes path added by addVirtualContentAtPath()\n     */\n    StaticServer.prototype.removeVirtualContentAtPath = function (path) {\n        BaseServer.prototype.removeVirtualContentAtPath.call(this, path);\n\n        // update the paths to watch\n        this._updateInstrumentedURLSInWorker();\n    };\n\n    /**\n     * See BaseServer#clear. Updates request filters.\n     */\n    StaticServer.prototype.clear = function () {\n        BaseServer.prototype.clear.call(this);\n\n        this._updateInstrumentedURLSInWorker();\n    };\n\n    /**\n     * @private\n     * Send HTTP response data back to the StaticServerSomain\n     */\n    StaticServer.prototype._send = function (location, response) {\n        this._nodeDomain.exec(\"writeFilteredResponse\", location.root, location.pathname, response);\n    };\n\n    function _sendMarkdown(fullPath, requestID) {\n        DocumentManager.getDocumentForPath(fullPath)\n            .done(function (doc) {\n                let text = doc.getText();\n                let markdownHtml = marked.parse(text);\n                let templateVars = {\n                    markdownContent: markdownHtml,\n                    BOOTSTRAP_LIB_CSS: `${window.parent.Phoenix.baseURL}thirdparty/bootstrap/bootstrap.min.css`,\n                    HIGHLIGHT_JS_CSS: `${window.parent.Phoenix.baseURL}thirdparty/highlight.js/styles/github.min.css`,\n                    HIGHLIGHT_JS: `${window.parent.Phoenix.baseURL}thirdparty/highlight.js/highlight.min.js`,\n                    GFM_CSS: `${window.parent.Phoenix.baseURL}thirdparty/gfm.min.css`\n                };\n                let html = Mustache.render(markdownHTMLTemplate, templateVars);\n                _serverBroadcastChannel.postMessage({\n                    type: 'REQUEST_RESPONSE',\n                    requestID, //pass along the requestID to call the appropriate callback at service worker\n                    fullPath,\n                    contents: html,\n                    headers: {'Content-Type': 'text/html'}\n                });\n            })\n            .fail(function (err) {\n                console.error(`Markdown rendering failed for ${fullPath}: `, err);\n            });\n    }\n\n    function _getExtension(filePath) {\n        filePath = filePath || '';\n        let pathSplit = filePath.split('.');\n        return pathSplit && pathSplit.length>1 ? pathSplit[pathSplit.length-1] : '';\n    }\n\n    function _isMarkdownFile(filePath) {\n        let extension = _getExtension(filePath);\n        return ['md', 'markdown'].includes(extension.toLowerCase());\n    }\n\n    /**\n     * @private\n     * Events raised by broadcast channel from the service worker will be captured here. The service worker will ask\n     * all phoenix instances if the url to be served should be replaced with instrumented content here or served\n     * as static file from disk.\n     * @param {{hostname: string, pathname: string, port: number, root: string, id: number}} request\n     */\n    StaticServer.prototype._sendInstrumentedContent = function (data) {\n        if(data.phoenixInstanceID && data.phoenixInstanceID !== Phoenix.PHOENIX_INSTANCE_ID) {\n            return;\n        }\n        let path = this._documentKey(data.path),\n            requestID = data.requestID,\n            liveDocument = this._liveDocuments[path],\n            virtualDocument = this._virtualServingDocuments[path];\n        let response = {\n            body: \"instrumented document not found at static server\"\n        };\n\n        if (virtualDocument) {\n            // virtual document overrides takes precedence over live preview docs\n            response = {\n                body: virtualDocument\n            };\n        } else if (liveDocument && liveDocument.getResponseData) {\n            response = liveDocument.getResponseData();\n        }\n\n        _serverBroadcastChannel.postMessage({\n            type: 'REQUEST_RESPONSE',\n            requestID, //pass along the requestID so that the appropriate callback will be hit at the service worker\n            path,\n            contents: response.body\n        });\n    };\n\n    _serverBroadcastChannel.onmessage = (event) => {\n        console.log(\"sss\", event.data, Phoenix.PHOENIX_INSTANCE_ID);\n        if (event.data.type === \"getInstrumentedContent\"\n            && event.data.phoenixInstanceID === Phoenix.PHOENIX_INSTANCE_ID) {\n            // localStorage is domain specific so when it changes in one window it changes in the other\n            if(_isMarkdownFile(event.data.path)){\n                _sendMarkdown(event.data.path, event.data.requestID);\n                return;\n            }\n            if(_staticServerInstance){\n                _staticServerInstance._sendInstrumentedContent(event.data);\n            }\n        }\n    };\n\n    /**\n     * See BaseServer#start. Starts listenting to StaticServerDomain events.\n     */\n    StaticServer.prototype.start = function () {\n        _staticServerInstance = this;\n    };\n\n    /**\n     * See BaseServer#stop. Remove event handlers from StaticServerDomain.\n     */\n    StaticServer.prototype.stop = function () {\n        _staticServerInstance = undefined;\n    };\n\n    module.exports = StaticServer;\n});\n"],"file":"StaticServer.js"}
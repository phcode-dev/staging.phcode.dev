{"version":3,"sources":["extensions/default/InlineColorEditor/ColorEditor.js"],"names":["define","require","exports","module","KeyEvent","brackets","getModule","PreferencesManager","StringUtils","Strings","Mustache","tinycolor","ColorEditorTemplate","STEP_MULTIPLIER","ensureHexFormat","str","test","replace","as0xString","color","toHexString","as0x8String","toHex8String","_0xColorToHex","convertToStr","hexColor","_format","toString","checkSetFormat","ColorEditor","$parent","callback","swatches","this","$element","$","render","append","_callback","_handleKeydown","bind","_handleOpacityKeydown","_handleHslKeydown","_handleHueKeydown","_handleSelectionKeydown","_handleOpacityDrag","_handleHueDrag","_handleSelectionFieldDrag","_originalColor","_color","_redoColor","_isUpperCase","get","on","$colorValue","find","$buttonList","$rgbaButton","$hexButton","$hslButton","$0xButton","$currentColor","$originalColor","$selection","$selectionBase","$hueBase","$opacityGradient","$hueSlider","$hueSelector","$opacitySlider","$opacitySelector","$swatches","_addSwatches","_addListeners","css","_commitColor","_getNewOffset","pos","zeroPos","maxOffset","offset","Math","min","max","prototype","_hsv","toHsv","getRootElement","_bindColorFormatToRadioButton","_bindInputHandlers","_bindOriginalColorButton","_registerDragHandler","_bindKeyHandler","_synchronize","colorValue","getColor","getOriginalInput","colorObject","hueColor","h","_updateColorTypeRadioButtons","getFormat","val","a","isNaN","s","v","left","bottom","focus","is","destroy","off","format","removeClass","parent","addClass","buttonClass","propertyName","value","handler","self","event","newFormat","currentTarget","html","toLowerCase","newColor","toHslString","toRgbString","toPercentageRgbString","_a","toUpperCase","click","_convertToNormalRGB","matches","match","i","percentStr","round","Number","_normalizeColorString","normalizedColor","_handleTextFieldInput","losingFocus","trim","newColorObj","newColorOk","isValid","forEach","swatch","swatchValue","stringFormat","count","COLOR_EDITOR_USED_COLOR_TIP_PLURAL","COLOR_EDITOR_USED_COLOR_TIP_SINGULAR","usedColorTip","keydown","keyCode","DOM_VK_RETURN","DOM_VK_ENTER","DOM_VK_SPACE","DOM_VK_TAB","shiftKey","next","length","isValidColor","colorVal","setColorAsHsv","hsv","oldFormat","extend","resetHsv","undefined","colorObj","_originalInput","setColorFromString","height","width","xOffset","clientX","yOffset","clientY","top","mouseupHandler","window","unbind","mousedown","undo","originalColor","redo","hasCtrl","platform","DOM_VK_Z","DOM_VK_Y","DOM_VK_LEFT","DOM_VK_RIGHT","DOM_VK_UP","DOM_VK_DOWN","preventDefault","$target","target","selectionStart","selectionEnd","stopPropagation","children","step","adjustedOffset","style","hue","alpha","document","e"],"mappings":"AAuBAA,OAAO,SAAUC,QAASC,QAASC,QAG/B,IAAIC,SAAqBC,SAASC,UAAU,kBACxCC,mBAAqBF,SAASC,UAAU,kCACxCE,YAAqBH,SAASC,UAAU,qBACxCG,QAAqBJ,SAASC,UAAU,WACxCI,SAAqBL,SAASC,UAAU,gCACxCK,UAAqBV,QAAQ,wBAG7BW,oBAAsBX,QAAQ,iCAK9BY,gBAAkB,EAQtB,SAASC,gBAAgBC,KACrB,MAAO,MAAQC,KAAKD,KAAOA,IAAIE,QAAQ,KAAM,KAAOF,IAQxD,SAASG,WAAWC,OAChB,OAAOA,MAAMC,cAAcH,QAAQ,IAAK,MAQ5C,SAASI,YAAYF,OACjB,OAAOA,MAAMG,eAAeL,QAAQ,IAAK,MAW7C,SAASM,cAAcJ,MAAOK,cAC1B,IAAIC,SAAWd,UAAUQ,MAAMF,QAAQ,KAAM,MAG7C,OAFAQ,SAASC,QAAU,KAEfF,aACOC,SAASE,WAEbF,SAWX,SAASG,eAAeT,MAAOK,cAC3B,MAAI,MAAQR,KAAKG,OACNI,cAAcJ,MAAOK,cAE5BA,aACOb,UAAUQ,OAAOQ,WAErBhB,UAAUQ,OAUrB,SAASU,YAAYC,QAASX,MAAOY,SAAUC,UAE3CC,KAAKC,SAAWC,EAAEzB,SAAS0B,OAAOxB,oBAAqBH,UACvDqB,QAAQO,OAAOJ,KAAKC,UAEpBD,KAAKK,UAAYP,SAEjBE,KAAKM,eAAiBN,KAAKM,eAAeC,KAAKP,MAC/CA,KAAKQ,sBAAwBR,KAAKQ,sBAAsBD,KAAKP,MAC7DA,KAAKS,kBAAoBT,KAAKS,kBAAkBF,KAAKP,MACrDA,KAAKU,kBAAoBV,KAAKU,kBAAkBH,KAAKP,MACrDA,KAAKW,wBAA0BX,KAAKW,wBAAwBJ,KAAKP,MACjEA,KAAKY,mBAAqBZ,KAAKY,mBAAmBL,KAAKP,MACvDA,KAAKa,eAAiBb,KAAKa,eAAeN,KAAKP,MAC/CA,KAAKc,0BAA4Bd,KAAKc,0BAA0BP,KAAKP,MAErEA,KAAKe,eAAiB7B,MACtBc,KAAKgB,OAASrB,eAAeT,OAE7Bc,KAAKiB,WAAa,KAClBjB,KAAKkB,aAAe5C,mBAAmB6C,IAAI,mBAC3C7C,mBAAmB8C,GAAG,SAAU,kBAAmB,WAC/CpB,KAAKkB,aAAe5C,mBAAmB6C,IAAI,oBAC7CZ,KAAKP,OAEPA,KAAKqB,YAAcrB,KAAKC,SAASqB,KAAK,gBACtCtB,KAAKuB,YAAcvB,KAAKC,SAASqB,KAAK,iBACtCtB,KAAKwB,YAAcxB,KAAKC,SAASqB,KAAK,SACtCtB,KAAKyB,WAAazB,KAAKC,SAASqB,KAAK,QACrCtB,KAAK0B,WAAa1B,KAAKC,SAASqB,KAAK,SACrCtB,KAAK2B,UAAY3B,KAAKC,SAASqB,KAAK,OACpCtB,KAAK4B,cAAgB5B,KAAKC,SAASqB,KAAK,kBACxCtB,KAAK6B,eAAiB7B,KAAKC,SAASqB,KAAK,mBACzCtB,KAAK8B,WAAa9B,KAAKC,SAASqB,KAAK,0BACrCtB,KAAK+B,eAAiB/B,KAAKC,SAASqB,KAAK,yCACzCtB,KAAKgC,SAAWhC,KAAKC,SAASqB,KAAK,8BACnCtB,KAAKiC,iBAAmBjC,KAAKC,SAASqB,KAAK,qBAC3CtB,KAAKkC,WAAalC,KAAKC,SAASqB,KAAK,eACrCtB,KAAKmC,aAAenC,KAAKC,SAASqB,KAAK,8BACvCtB,KAAKoC,eAAiBpC,KAAKC,SAASqB,KAAK,mBACzCtB,KAAKqC,iBAAmBrC,KAAKC,SAASqB,KAAK,kCAC3CtB,KAAKsC,UAAYtC,KAAKC,SAASqB,KAAK,aAGpCtB,KAAKuC,aAAaxC,UAGlBC,KAAKwC,gBAGLxC,KAAK6B,eAAeY,IAAI,mBAAoB9C,eAAeK,KAAKe,iBAEhEf,KAAK0C,aAAaxD,OAmZtB,SAASyD,cAAcC,IAAKC,QAASC,WACjC,IAAIC,OAASH,IAAMC,QAEnB,OADAE,OAASC,KAAKC,IAAIH,UAAWE,KAAKE,IAAI,EAAGH,SA7Y7CnD,YAAYuD,UAAUnC,OAAS,KAO/BpB,YAAYuD,UAAUC,KAAO1E,UAAU,iBAAiB2E,QAMxDzD,YAAYuD,UAAUlC,WAAa,KAMnCrB,YAAYuD,UAAUpC,eAAiB,KAIvCnB,YAAYuD,UAAUG,eAAiB,WACnC,OAAOtD,KAAKC,UAIhBL,YAAYuD,UAAUX,cAAgB,WAClCxC,KAAKuD,8BAA8B,QACnCvD,KAAKuD,8BAA8B,OACnCvD,KAAKuD,8BAA8B,QACnCvD,KAAKuD,8BAA8B,MAEnCvD,KAAKwD,qBAELxD,KAAKyD,2BAELzD,KAAK0D,qBAAqB1D,KAAK8B,WAAY9B,KAAKc,2BAChDd,KAAK0D,qBAAqB1D,KAAKkC,WAAYlC,KAAKa,gBAChDb,KAAK0D,qBAAqB1D,KAAKoC,eAAgBpC,KAAKY,oBACpDZ,KAAK2D,gBAAgB3D,KAAK+B,eAAgB/B,KAAKW,yBAC/CX,KAAK2D,gBAAgB3D,KAAKgC,SAAUhC,KAAKU,mBACzCV,KAAK2D,gBAAgB3D,KAAKqC,iBAAkBrC,KAAKQ,uBACjDR,KAAK2D,gBAAgB3D,KAAK0B,WAAY1B,KAAKS,mBAG3CT,KAAK2D,gBAAgB3D,KAAKC,SAAUD,KAAKM,iBAQ7CV,YAAYuD,UAAUS,aAAe,WACjC,IAAIC,WAAc7D,KAAK8D,WAAWC,mBAC9BC,YAAcrE,eAAekE,YAC7BI,SAAc,OAASjE,KAAKoD,KAAKc,EAAI,eACzClE,KAAKmE,6BAA6BH,YAAYI,aAC9CpE,KAAKqB,YAAYgD,IAAIR,YACrB7D,KAAK4B,cAAca,IAAI,mBAAoB9C,eAAekE,YAAY,IACtE7D,KAAK8B,WAAWW,IAAI,mBAAoBwB,UACxCjE,KAAKgC,SAASS,IAAI,mBAAoBwB,UAGtCjE,KAAK+B,eAAeU,IAAI,mBAAoBuB,YAAY7E,eACxDa,KAAKiC,iBAAiBQ,IAAI,mBAAoB,mBAAqBwB,SAAW,kBAG9EjE,KAAKmC,aAAaM,IAAI,SAAWzC,KAAKoD,KAAKc,EAAI,IAAM,IAAO,KAC5DlE,KAAKqC,iBAAiBI,IAAI,SAAyB,IAAdzC,KAAKoD,KAAKkB,EAAW,KACrDC,MAAMvE,KAAKoD,KAAKoB,KACjBxE,KAAKoD,KAAKoB,EAAmB,IAAdxE,KAAKoD,KAAKoB,EAAW,KAEnCD,MAAMvE,KAAKoD,KAAKqB,KACjBzE,KAAKoD,KAAKqB,EAAmB,IAAdzE,KAAKoD,KAAKqB,EAAW,KAExCzE,KAAK+B,eAAeU,IAAI,CACpBiC,KAAM1E,KAAKoD,KAAKoB,EAChBG,OAAQ3E,KAAKoD,KAAKqB,KAQ1B7E,YAAYuD,UAAUyB,MAAQ,WAC1B,OAAK5E,KAAK+B,eAAe8C,GAAG,YACxB7E,KAAK+B,eAAe6C,SACb,IAQfhF,YAAYuD,UAAU2B,QAAU,WAC5BxG,mBAAmByG,IAAI,SAAU,oBAMrCnF,YAAYuD,UAAUW,SAAW,WAC7B,OAAO9D,KAAKgB,QAIhBpB,YAAYuD,UAAUgB,6BAA+B,SAAUa,QAE3D,OADAhF,KAAKuB,YAAYD,KAAK,MAAM2D,YAAY,YAChCD,QACR,IAAK,MACDhF,KAAKuB,YAAYD,KAAK,SAAS4D,SAASC,SAAS,YACjD,MACJ,IAAK,MACL,IAAK,OACDnF,KAAKuB,YAAYD,KAAK,QAAQ4D,SAASC,SAAS,YAChD,MACJ,IAAK,MACDnF,KAAKuB,YAAYD,KAAK,SAAS4D,SAASC,SAAS,YACjD,MACJ,IAAK,KACDnF,KAAKuB,YAAYD,KAAK,OAAO4D,SAASC,SAAS,cAMvDvF,YAAYuD,UAAUI,8BAAgC,SAAU6B,YAAaC,aAAcC,OACvF,IAAIC,QACAC,KAAOxF,KACXuF,QAAU,SAAUE,OAChB,IAAIC,UAAcxF,EAAEuF,MAAME,eAAeC,OAAOC,cAAc7G,QAAQ,IAAK,KACvE8G,SAAcN,KAAK1B,WAAWpE,WAE9BsE,YAAcwB,KAAK1B,WAEvB,OAAQ4B,WACR,IAAK,OACDI,SAAW9B,YAAY+B,cACvB,MACJ,IAAK,OACDD,SAAW9B,YAAYgC,cACvB,MACJ,IAAK,QACDF,SAAW9B,YAAYiC,wBACvB,MACJ,IAAK,MACEjC,YAAYkC,GAAI,EACfJ,SAAW9B,YAAY3E,gBAEvByG,SAAW9B,YAAY7E,cACvBqG,KAAKpC,KAAKkB,EAAI,GAElB,MACJ,IAAK,OACDwB,SAAW9B,YAAY3E,eACvB,MACJ,IAAK,KACE2E,YAAYkC,GAAI,GACfJ,SAAW1G,YAAY4E,aACvBwB,KAAKpC,KAAKkB,EAAI,EACdkB,KAAK/F,QAAU,OAEfqG,SAAW7G,WAAW+E,aACtBwB,KAAKpC,KAAKkB,EAAI,EACdkB,KAAK/F,QAAU,MAOvBqG,SAAWN,KAAKtE,aAAe4E,SAASK,cAAgBL,SACxDN,KAAK9C,aAAaoD,UAAU,IAEhC9F,KAAKC,SAASqB,KAAK,IAAM8D,aAAagB,MAAMb,UAIhD3F,YAAYuD,UAAUM,yBAA2B,WAC7C,IAAI+B,KAAOxF,KACXA,KAAK6B,eAAeuE,MAAM,SAAUX,OAChCD,KAAK9C,aAAa8C,KAAKzE,gBAAgB,MAU/CnB,YAAYuD,UAAUkD,oBAAsB,SAAUnH,OAClD,IAAIoH,QAAUpH,MAAMqH,MAAM,gDAElBC,EAAGC,WAAYnB,MADvB,GAAIgB,QAEA,IAAKE,EAAI,EAAGA,EAAI,EAAGA,IACfC,WAAaH,QAAQE,EAAI,GACzBlB,MAAQtC,KAAK0D,MAAM,IAAMC,OAAOF,YAAc,KACzClC,MAAMe,SACPpG,MAAQA,MAAMF,QAAQyH,WAAa,IAAKnB,QAIpD,OAAOpG,OASXU,YAAYuD,UAAUyD,sBAAwB,SAAU1H,OACpD,IAAI2H,gBAAkB3H,MAGtB,OAAIA,MAAMqH,MAAM,oBACL7H,UAAUQ,OAAOQ,YAExBR,MAAMqH,MAAM,iBAGZM,iBADAA,iBADAA,gBAAkBA,gBAAgB7H,QAAQ,QAAS,OACjBA,QAAQ,QAAS,MACjBA,QAAQ,QAAS,MAEhD6H,kBAIXjH,YAAYuD,UAAU2D,sBAAwB,SAAUC,aACpD,IAAIjB,SAAc5F,EAAE8G,KAAKhH,KAAKqB,YAAYgD,OACtC4C,YAActH,eAAemG,UAC7BoB,WAAcD,YAAYE,UAU1BD,aACAA,WAAcD,YAAYvH,aAAeM,KAAK4G,sBAAsB/H,gBAAgBiH,YAIpFiB,cAAgBG,aAChBpB,SAAW9F,KAAK8D,WAAWpE,aAI3BqH,aAAeG,aACflH,KAAK0C,aAAaoD,UAAU,IAIpClG,YAAYuD,UAAUK,mBAAqB,WACvC,IAAIgC,KAAOxF,KAEXA,KAAKqB,YAAYd,KAAK,QAAS,SAAUkF,OACrCD,KAAKsB,uBAAsB,KAG/B9G,KAAKqB,YAAYd,KAAK,SAAU,SAAUkF,OACtCD,KAAKsB,uBAAsB,MAQnClH,YAAYuD,UAAUZ,aAAe,SAAUxC,UAC3C,IAAIyF,KAAOxF,KAGXD,SAASqH,QAAQ,SAAUC,QACvB,IAAIC,YAAc3H,eAAe0H,OAAO/B,OAAO,GAC3CiC,aAAgBF,OAAOG,MAAQ,EAAKhJ,QAAQiJ,mCAAqCjJ,QAAQkJ,qCACzFC,aAAepJ,YAAYyG,OAAOuC,aAAcF,OAAO/B,MAAO+B,OAAOG,OAEzEhC,KAAKlD,UAAUlC,OAAO,wFACdkH,YAAc,aAAeK,aAAe,6CAC5CA,aAAe,KAAON,OAAO/B,MAAQ,kBAIjDtF,KAAKsC,UAAUhB,KAAK,MAAMsG,QAAQ,SAAUnC,OACxC,GAAIA,MAAMoC,UAAY1J,SAAS2J,eACvBrC,MAAMoC,UAAY1J,SAAS4J,cAC3BtC,MAAMoC,UAAY1J,SAAS6J,aAG/BxC,KAAK9C,aAAaxC,EAAEuF,MAAME,eAAerE,KAAK,UAAUsE,aACrD,GAAIH,MAAMoC,UAAY1J,SAAS8J,aAE7BxC,MAAMyC,UAA0C,IAA9BhI,EAAEF,MAAMmI,KAAK,MAAMC,OAEtC,OADA5C,KAAKzD,eAAe6C,SACb,IAKnB5E,KAAKsC,UAAUhB,KAAK,MAAM8E,MAAM,SAAUX,OACtCD,KAAK9C,aAAaxC,EAAEuF,MAAME,eAAerE,KAAK,UAAUsE,WAShEhG,YAAYuD,UAAUkF,aAAe,SAAUC,UAC3C,OAAO5J,UAAU4J,UAAUnB,WAQ/BvH,YAAYuD,UAAUoF,cAAgB,SAAUC,KAC5C,IAAIF,SAAUxC,SACV2C,UAAY/J,UAAUsB,KAAK8D,YAAYM,YAM3C,OAHAlE,EAAEwI,OAAO1I,KAAKoD,KAAMoF,KACpB1C,SAAWpH,UAAUsB,KAAKoD,MAElBqF,WACR,IAAK,MACDH,SAAWxC,SAASC,cACpB,MACJ,IAAK,MACDuC,SAAWxC,SAASE,cACpB,MACJ,IAAK,OACDsC,SAAWxC,SAASG,wBACpB,MACJ,IAAK,MACL,IAAK,OACDqC,SAAWtI,KAAKoD,KAAKkB,EAAI,EAAIwB,SAASE,cAAgBF,SAAS3G,cAC/D,MACJ,IAAK,KACDmJ,SAAWtI,KAAKoD,KAAKkB,EAAI,EAAIlF,YAAY0G,UAAW7G,WAAW6G,UAC/D,MACJ,IAAK,OACDwC,SAAWxC,SAASzG,eAGxBiJ,SAAWtI,KAAKkB,aAAeoH,SAASnC,cAAgBmC,SACxDtI,KAAK0C,aAAa4F,UAAU,IAShC1I,YAAYuD,UAAUT,aAAe,SAAU4F,SAAUK,eAEpCC,IAAbD,WACAA,UAAW,GAEf3I,KAAKK,UAAUiI,UAEf,IAAIO,SAAWlJ,eAAe2I,UAC9BO,SAASC,eAAiBR,SAC1BtI,KAAKgB,OAAS6H,SAEVF,WACA3I,KAAKoD,KAAOpD,KAAKgB,OAAOqC,SAG5BrD,KAAKiB,WAAa,KAClBjB,KAAK4D,gBAQThE,YAAYuD,UAAU4F,mBAAqB,SAAUT,UACjDtI,KAAK0C,aAAa4F,UAAU,IAWhC1I,YAAYuD,UAAUrC,0BAA4B,SAAU2E,OACxD,IAAIuD,OAAUhJ,KAAK8B,WAAWkH,SAC1BC,MAAUjJ,KAAK8B,WAAWmH,QAC1BC,QAAUvG,cAAc8C,MAAM0D,QAASnJ,KAAK8B,WAAWiB,SAAS2B,KAAMuE,OACtEG,QAAUzG,cAAc8C,MAAM4D,QAASrJ,KAAK8B,WAAWiB,SAASuG,IAAKN,QACrER,IAAU,GACdA,IAAIhE,EAAI0E,QAAUD,MAClBT,IAAI/D,EAAI,EAAI2E,QAAUJ,OACtBhJ,KAAKuI,cAAcC,KAAK,GACnBxI,KAAK8B,WAAWR,KAAK,kBAAkBuD,GAAG,WAC3C7E,KAAK8B,WAAWR,KAAK,kBAAkBsD,SAK/ChF,YAAYuD,UAAUtC,eAAiB,SAAU4E,OAC7C,IAAIuD,OAAShJ,KAAKkC,WAAW8G,SACzBjG,OAASJ,cAAc8C,MAAM4D,QAASrJ,KAAKkC,WAAWa,SAASuG,IAAKN,QACpER,IAAS,GACbA,IAAItE,EAA4B,KAAvB,EAAInB,OAASiG,QACtBhJ,KAAKuI,cAAcC,KAAK,GACnBxI,KAAKkC,WAAWZ,KAAK,kBAAkBuD,GAAG,WAC3C7E,KAAKkC,WAAWZ,KAAK,kBAAkBsD,SAK/ChF,YAAYuD,UAAUvC,mBAAqB,SAAU6E,OACjD,IAAIuD,OAAShJ,KAAKoC,eAAe4G,SAC7BjG,OAASJ,cAAc8C,MAAM4D,QAASrJ,KAAKoC,eAAeW,SAASuG,IAAKN,QACxER,IAAS,GACbA,IAAIlE,EAAI,EAAKvB,OAASiG,OACtBhJ,KAAKuI,cAAcC,KAAK,GACnBxI,KAAKoC,eAAed,KAAK,kBAAkBuD,GAAG,WAC/C7E,KAAKoC,eAAed,KAAK,kBAAkBsD,SASnDhF,YAAYuD,UAAUO,qBAAuB,SAAUzD,SAAUsF,SAC7D,IAAIgE,eAAiB,SAAU9D,OAC3BvF,EAAEsJ,QAAQC,OAAO,YAAalE,SAC9BrF,EAAEsJ,QAAQC,OAAO,UAAWF,iBAEhCtJ,SAASyJ,UAAU,SAAUjE,OACzBvF,EAAEsJ,QAAQjJ,KAAK,YAAagF,SAC5BrF,EAAEsJ,QAAQjJ,KAAK,UAAWgJ,kBAE9BtJ,SAASyJ,UAAUnE,UAOvB3F,YAAYuD,UAAUwG,KAAO,WACzB,GAAI3J,KAAKe,eAAerB,aAAeM,KAAKgB,OAAO+C,mBAAoB,CACnE,IAAI6F,cAAgB5J,KAAKgB,OAAO+C,mBAChC/D,KAAK0C,aAAa1C,KAAKe,gBAAgB,GAEvCf,KAAKiB,WAAa2I,gBAK1BhK,YAAYuD,UAAU0G,KAAO,WACrB7J,KAAKiB,aACLjB,KAAK0C,aAAa1C,KAAKiB,YAAY,GACnCjB,KAAKiB,WAAa,OAQ1BrB,YAAYuD,UAAU7C,eAAiB,SAAUmF,OAC7C,IAAIqE,QACJ,GADqC,QAAtB1L,SAAS2L,SAAuBtE,MAAa,QAAKA,MAAa,QAE1E,OAAQA,MAAMoC,SACd,KAAK1J,SAAS6L,SAMV,OALIvE,MAAMyC,SACNlI,KAAK6J,OAEL7J,KAAK2J,QAEF,EACX,KAAKxL,SAAS8L,SAEV,OADAjK,KAAK6J,QACE,OAGX,GAAIpE,MAAMoC,UAAY1J,SAAS+L,aACvBzE,MAAMoC,UAAY1J,SAASgM,cAC3B1E,MAAMoC,UAAY1J,SAASiM,WAC3B3E,MAAMoC,UAAY1J,SAASkM,YAAa,CAM5C,IAAIC,gBAAiB,EACjBC,QAAUrK,EAAEuF,MAAM+E,QAmBtB,GAfID,QAAQ1F,GAAG,sBAAwB0F,QAAQ1F,GAAG,oBAK1C0F,QAAQ,GAAGE,iBAAmBF,QAAQ,GAAGG,eACnCjF,MAAMoC,UAAY1J,SAAS+L,aAA6C,IAA9BK,QAAQ,GAAGE,gBACrDhF,MAAMoC,UAAY1J,SAASgM,cAAgBI,QAAQ,GAAGG,eAAiBH,QAAQlG,MAAM+D,UAC3FkC,gBAAiB,GAIrBA,gBAAiB,EAGjBA,eAEA,OADA7E,MAAMkF,mBACC,IAMvB/K,YAAYuD,UAAU1C,kBAAoB,SAAUgF,OAChD,GAAIA,MAAMoC,UAAY1J,SAAS8J,aAEtBxC,MAAMyC,UACkC,IAArClI,KAAKsC,UAAUsI,WAAWxC,OAE1B,OADApI,KAAK+B,eAAe6C,SACb,GAOvBhF,YAAYuD,UAAUxC,wBAA0B,SAAU8E,OACtD,IAAI+C,IAAM,GACNqC,KAAO,IACP3B,QACAE,QACA0B,eAEJ,OAAQrF,MAAMoC,SACd,KAAK1J,SAAS+L,YACd,KAAK/L,SAASgM,aAOV,OANAU,KAAOpF,MAAMyC,SAnrBC,EAmrBU2C,KAAyBA,KACjD3B,QAAUvC,OAAOzG,EAAE8G,KAAKhH,KAAK+B,eAAe,GAAGgJ,MAAMrG,KAAK1F,QAAQ,IAAK,MACvE8L,eAAkBrF,MAAMoC,UAAY1J,SAAS+L,YAAgBhB,QAAU2B,KAAS3B,QAAU2B,KAC1F3B,QAAUlG,KAAKC,IAAI,IAAKD,KAAKE,IAAI,EAAG4H,iBACpCtC,IAAIhE,EAAI0E,QAAU,IAClBlJ,KAAKuI,cAAcC,KAAK,IACjB,EACX,KAAKrK,SAASkM,YACd,KAAKlM,SAASiM,UAOV,OANAS,KAAOpF,MAAMyC,SA5rBC,EA4rBU2C,KAAyBA,KACjDzB,QAAUzC,OAAOzG,EAAE8G,KAAKhH,KAAK+B,eAAe,GAAGgJ,MAAMpG,OAAO3F,QAAQ,IAAK,MACzE8L,eAAkBrF,MAAMoC,UAAY1J,SAASkM,YAAgBjB,QAAUyB,KAASzB,QAAUyB,KAC1FzB,QAAUpG,KAAKC,IAAI,IAAKD,KAAKE,IAAI,EAAG4H,iBACpCtC,IAAI/D,EAAI2E,QAAU,IAClBpJ,KAAKuI,cAAcC,KAAK,IACjB,EACX,KAAKrK,SAAS8J,WAEV,GAAIxC,MAAMyC,SAMN,OALyC,IAArClI,KAAKsC,UAAUsI,WAAWxC,OAC1BpI,KAAK0B,WAAWkD,QAEhB5E,KAAKsC,UAAUhB,KAAK,WAAWsD,SAE5B,IAOnBhF,YAAYuD,UAAUzC,kBAAoB,SAAU+E,OAChD,IAAI+C,IAAM,GACNwC,IAAMrE,OAAO3G,KAAKoD,KAAKc,GACvB2G,KAAO,IAEX,OAAQpF,MAAMoC,SACd,KAAK1J,SAASkM,YAIV,OAHAQ,KAAOpF,MAAMyC,SAztBC,EAytBU2C,KAAyBA,KACjDrC,IAAItE,EAAK8G,IAAMH,MAAS,EAAI,IAAMA,KAAOG,IAAMH,KAC/C7K,KAAKuI,cAAcC,KAAK,IACjB,EACX,KAAKrK,SAASiM,UAIV,OAHAS,KAAOpF,MAAMyC,SA9tBC,EA8tBU2C,KAAyBA,KACjDrC,IAAItE,EAAK8G,IAAMH,MAAS,IAAMA,KAAOG,IAAMH,KAC3C7K,KAAKuI,cAAcC,KAAK,IACjB,IAKf5I,YAAYuD,UAAU3C,sBAAwB,SAAUiF,OACpD,IAAIwF,MAAQjL,KAAKoD,KAAKkB,EAClBkE,IAAM,GACNqC,KAAO,IAEX,OAAQpF,MAAMoC,SACd,KAAK1J,SAASkM,YAMV,OALAQ,KAAOpF,MAAMyC,SA7uBC,EA6uBU2C,KAAyBA,KAC7CI,MAAQ,IACRzC,IAAIlE,EAAK2G,MAAQJ,MAAS,EAAI,EAAII,MAAQJ,KAC1C7K,KAAKuI,cAAcC,OAEhB,EACX,KAAKrK,SAASiM,UAMV,OALAS,KAAOpF,MAAMyC,SApvBC,EAovBU2C,KAAyBA,KAC7CI,MAAQ,MACRzC,IAAIlE,EAAK2G,MAAQJ,MAAS,EAAI,EAAII,MAAQJ,KAC1C7K,KAAKuI,cAAcC,OAEhB,IAIf5I,YAAYuD,UAAUQ,gBAAkB,SAAU1D,SAAUsF,SACxDtF,SAASM,KAAK,UAAWgF,UAI7BrF,EAAEsJ,OAAO0B,UAAU9J,GAAG,YAAa,iDAAkD,SAAU+J,GAC3FA,EAAEb,mBAGNrM,QAAQ2B,YAAcA","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*jslint regexp: true */\n\ndefine(function (require, exports, module) {\n\n\n    var KeyEvent           = brackets.getModule(\"utils/KeyEvent\"),\n        PreferencesManager = brackets.getModule(\"preferences/PreferencesManager\"),\n        StringUtils        = brackets.getModule(\"utils/StringUtils\"),\n        Strings            = brackets.getModule(\"strings\"),\n        Mustache           = brackets.getModule(\"thirdparty/mustache/mustache\"),\n        tinycolor          = require(\"thirdparty/tinycolor\");\n\n    /** Mustache template that forms the bare DOM structure of the UI */\n    var ColorEditorTemplate = require(\"text!ColorEditorTemplate.html\");\n\n    /**\n     * @const @type {number}\n     */\n    var STEP_MULTIPLIER = 5;\n\n    /**\n     * Convert 0x notation into hex6 format for tinycolor\n     * compatibility: (\"0xFFAACC\" => \"#FFFFFF\")\n     * @param {string} str - String to ensure hex format for\n     * @returns {string} - str in hex format\n     */\n    function ensureHexFormat(str) {\n        return (/^0x/).test(str) ? str.replace(\"0x\", \"#\") : str;\n    }\n\n    /**\n     * Converts a color to a 0x-prefixed string\n     * @param {tinycolor} color - color to convert\n     * @returns {string} - color as 0x-prefixed string\n     */\n    function as0xString(color) {\n        return color.toHexString().replace(\"#\", \"0x\");\n    }\n\n    /**\n     * Converts a color to a 0x-prefixed string\n     * @param {tinycolor} color - color to convert\n     * @returns {string} - color as 0x-prefixed string\n     */\n    function as0x8String(color) {\n        return color.toHex8String().replace(\"#\", \"0x\");\n    }\n\n    /**\n     * Converts 0x-prefixed color to hex\n     * @param {string} color - Color to convert\n     * @param {boolean} convertToString - true if color should\n     *                                    be returned as string\n     * @returns {tinycolor|string} - Hex color as a Tinycolor object\n     *                               or a hex string\n     */\n    function _0xColorToHex(color, convertToStr) {\n        var hexColor = tinycolor(color.replace(\"0x\", \"#\"));\n        hexColor._format = \"0x\";\n\n        if (convertToStr) {\n            return hexColor.toString();\n        }\n        return hexColor;\n    }\n\n    /**\n     * Ensures that a string is in Tinycolor supported format\n     * @param {string} color - Color to check the format for\n     * @param {boolean} convertToString - true if color should\n     *                                    be returned as string\n     * @returns {tinycolor|string} - Color as a Tinycolor object\n     *                               or a hex string\n     */\n    function checkSetFormat(color, convertToStr) {\n        if ((/^0x/).test(color)) {\n            return _0xColorToHex(color, convertToStr);\n        }\n        if (convertToStr) {\n            return tinycolor(color).toString();\n        }\n        return tinycolor(color);\n    }\n\n    /**\n     * Color picker control; may be used standalone or within an InlineColorEditor inline widget.\n     * @param {!jQuery} $parent  DOM node into which to append the root of the color picker UI\n     * @param {!string} color  Initially selected color\n     * @param {!function(string)} callback  Called whenever selected color changes\n     * @param {!Array.<{value:string, count:number}>} swatches  Quick-access color swatches to include in UI\n     */\n    function ColorEditor($parent, color, callback, swatches) {\n        // Create the DOM structure, filling in localized strings via Mustache\n        this.$element = $(Mustache.render(ColorEditorTemplate, Strings));\n        $parent.append(this.$element);\n\n        this._callback = callback;\n\n        this._handleKeydown = this._handleKeydown.bind(this);\n        this._handleOpacityKeydown = this._handleOpacityKeydown.bind(this);\n        this._handleHslKeydown = this._handleHslKeydown.bind(this);\n        this._handleHueKeydown = this._handleHueKeydown.bind(this);\n        this._handleSelectionKeydown = this._handleSelectionKeydown.bind(this);\n        this._handleOpacityDrag = this._handleOpacityDrag.bind(this);\n        this._handleHueDrag = this._handleHueDrag.bind(this);\n        this._handleSelectionFieldDrag = this._handleSelectionFieldDrag.bind(this);\n\n        this._originalColor = color;\n        this._color = checkSetFormat(color);\n\n        this._redoColor = null;\n        this._isUpperCase = PreferencesManager.get(\"uppercaseColors\");\n        PreferencesManager.on(\"change\", \"uppercaseColors\", function () {\n            this._isUpperCase = PreferencesManager.get(\"uppercaseColors\");\n        }.bind(this));\n\n        this.$colorValue = this.$element.find(\".color-value\");\n        this.$buttonList = this.$element.find(\"ul.button-bar\");\n        this.$rgbaButton = this.$element.find(\".rgba\");\n        this.$hexButton = this.$element.find(\".hex\");\n        this.$hslButton = this.$element.find(\".hsla\");\n        this.$0xButton = this.$element.find(\".0x\");\n        this.$currentColor = this.$element.find(\".current-color\");\n        this.$originalColor = this.$element.find(\".original-color\");\n        this.$selection = this.$element.find(\".color-selection-field\");\n        this.$selectionBase = this.$element.find(\".color-selection-field .selector-base\");\n        this.$hueBase = this.$element.find(\".hue-slider .selector-base\");\n        this.$opacityGradient = this.$element.find(\".opacity-gradient\");\n        this.$hueSlider = this.$element.find(\".hue-slider\");\n        this.$hueSelector = this.$element.find(\".hue-slider .selector-base\");\n        this.$opacitySlider = this.$element.find(\".opacity-slider\");\n        this.$opacitySelector = this.$element.find(\".opacity-slider .selector-base\");\n        this.$swatches = this.$element.find(\".swatches\");\n\n        // Create quick-access color swatches\n        this._addSwatches(swatches);\n\n        // Attach event listeners to main UI elements\n        this._addListeners();\n\n        // Initially selected color\n        this.$originalColor.css(\"background-color\", checkSetFormat(this._originalColor));\n\n        this._commitColor(color);\n    }\n\n    /**\n     * A string or tinycolor object representing the currently selected color\n     * TODO (#2201): type is unpredictable\n     * @type {tinycolor|string}\n     */\n    ColorEditor.prototype._color = null;\n\n    /**\n     * An HSV representation of the currently selected color.\n     * TODO (#2201): type of _hsv.s/.v is unpredictable\n     * @type {!{h:number, s:number|string, v:number|string, a:number}}\n     */\n    ColorEditor.prototype._hsv = tinycolor(\"rgba(0,0,0,1)\").toHsv();\n\n    /**\n     * Color that was selected before undo(), if undo was the last change made. Else null.\n     * @type {?string}\n     */\n    ColorEditor.prototype._redoColor = null;\n\n    /**\n     * Initial value the color picker was opened with\n     * @type {!string}\n     */\n    ColorEditor.prototype._originalColor = null;\n\n\n    /** Returns the root DOM node of the ColorPicker UI */\n    ColorEditor.prototype.getRootElement = function () {\n        return this.$element;\n    };\n\n    /** Attach event listeners for main UI elements */\n    ColorEditor.prototype._addListeners = function () {\n        this._bindColorFormatToRadioButton(\"rgba\");\n        this._bindColorFormatToRadioButton(\"hex\");\n        this._bindColorFormatToRadioButton(\"hsla\");\n        this._bindColorFormatToRadioButton(\"0x\");\n\n        this._bindInputHandlers();\n\n        this._bindOriginalColorButton();\n\n        this._registerDragHandler(this.$selection, this._handleSelectionFieldDrag);\n        this._registerDragHandler(this.$hueSlider, this._handleHueDrag);\n        this._registerDragHandler(this.$opacitySlider, this._handleOpacityDrag);\n        this._bindKeyHandler(this.$selectionBase, this._handleSelectionKeydown);\n        this._bindKeyHandler(this.$hueBase, this._handleHueKeydown);\n        this._bindKeyHandler(this.$opacitySelector, this._handleOpacityKeydown);\n        this._bindKeyHandler(this.$hslButton, this._handleHslKeydown);\n\n        // General key handler gets bubbling events from any focusable part of widget\n        this._bindKeyHandler(this.$element, this._handleKeydown);\n    };\n\n    /**\n     * Update all UI elements to reflect the selected color (_color and _hsv). It is usually\n     * incorrect to call this directly; use _commitColor() or setColorAsHsv() instead.\n     */\n\n    ColorEditor.prototype._synchronize = function () {\n        var colorValue  = this.getColor().getOriginalInput();\n        var colorObject = checkSetFormat(colorValue);\n        var hueColor    = \"hsl(\" + this._hsv.h + \", 100%, 50%)\";\n        this._updateColorTypeRadioButtons(colorObject.getFormat());\n        this.$colorValue.val(colorValue);\n        this.$currentColor.css(\"background-color\", checkSetFormat(colorValue, true));\n        this.$selection.css(\"background-color\", hueColor);\n        this.$hueBase.css(\"background-color\", hueColor);\n\n        // Update gradients in color square & opacity slider\n        this.$selectionBase.css(\"background-color\", colorObject.toHexString());\n        this.$opacityGradient.css(\"background-image\", \"linear-gradient(\" + hueColor + \", transparent)\");\n\n        // Update slider thumb positions\n        this.$hueSelector.css(\"bottom\", (this._hsv.h / 360 * 100) + \"%\");\n        this.$opacitySelector.css(\"bottom\", (this._hsv.a * 100) + \"%\");\n        if (!isNaN(this._hsv.s)) {      // TODO (#2201): type of _hsv.s/.v is unpredictable\n            this._hsv.s = (this._hsv.s * 100) + \"%\";\n        }\n        if (!isNaN(this._hsv.v)) {\n            this._hsv.v = (this._hsv.v * 100) + \"%\";\n        }\n        this.$selectionBase.css({\n            left: this._hsv.s,\n            bottom: this._hsv.v\n        });\n    };\n\n    /**\n     * Focus the main color square's thumb.\n     * @return {boolean} True if we focused the square, false otherwise.\n     */\n    ColorEditor.prototype.focus = function () {\n        if (!this.$selectionBase.is(\":focus\")) {\n            this.$selectionBase.focus();\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Remove any preference listeners before destroying the editor.\n     */\n    ColorEditor.prototype.destroy = function () {\n        PreferencesManager.off(\"change\", \"uppercaseColors\");\n    };\n\n    /**\n     * @return {tinycolor|string} The currently selected color (TODO (#2201): type is unpredictable).\n     */\n    ColorEditor.prototype.getColor = function () {\n        return this._color;\n    };\n\n    /** Update the format button bar's selection */\n    ColorEditor.prototype._updateColorTypeRadioButtons = function (format) {\n        this.$buttonList.find(\"li\").removeClass(\"selected\");\n        switch (format) {\n        case \"rgb\":\n            this.$buttonList.find(\".rgba\").parent().addClass(\"selected\");\n            break;\n        case \"hex\":\n        case \"name\":\n            this.$buttonList.find(\".hex\").parent().addClass(\"selected\");\n            break;\n        case \"hsl\":\n            this.$buttonList.find(\".hsla\").parent().addClass(\"selected\");\n            break;\n        case \"0x\":\n            this.$buttonList.find(\".0x\").parent().addClass(\"selected\");\n            break;\n        }\n    };\n\n    /** Add event listeners to the format button bar */\n    ColorEditor.prototype._bindColorFormatToRadioButton = function (buttonClass, propertyName, value) {\n        var handler,\n            self = this;\n        handler = function (event) {\n            var newFormat   = $(event.currentTarget).html().toLowerCase().replace(\"%\", \"p\"),\n                newColor    = self.getColor().toString();\n\n            var colorObject = self.getColor();\n\n            switch (newFormat) {\n            case \"hsla\":\n                newColor = colorObject.toHslString();\n                break;\n            case \"rgba\":\n                newColor = colorObject.toRgbString();\n                break;\n            case \"prgba\":\n                newColor = colorObject.toPercentageRgbString();\n                break;\n            case \"hex\":\n                if(colorObject._a <1){\n                    newColor = colorObject.toHex8String();\n                } else {\n                    newColor = colorObject.toHexString();\n                    self._hsv.a = 1;\n                }\n                break;\n            case \"hex8\":\n                newColor = colorObject.toHex8String();\n                break;\n            case \"0x\":\n                if(colorObject._a <1){\n                    newColor = as0x8String(colorObject);\n                    self._hsv.a = 1;\n                    self._format = \"0x\";\n                } else {\n                    newColor = as0xString(colorObject);\n                    self._hsv.a = 1;\n                    self._format = \"0x\";\n                }\n                break;\n            }\n\n            // We need to run this again whenever RGB/HSL/Hex conversions\n            // are performed to preserve the case\n            newColor = self._isUpperCase ? newColor.toUpperCase() : newColor;\n            self._commitColor(newColor, false);\n        };\n        this.$element.find(\".\" + buttonClass).click(handler);\n    };\n\n    /** Add event listener to the \"original color value\" swatch */\n    ColorEditor.prototype._bindOriginalColorButton = function () {\n        var self = this;\n        this.$originalColor.click(function (event) {\n            self._commitColor(self._originalColor, true);\n        });\n    };\n\n    /**\n     * Convert percentage values in an RGB color into normal RGB values in the range of 0 - 255.\n     * If the original color is already in non-percentage format, does nothing.\n     * @param {string} color The color to be converted to non-percentage RGB color string.\n     * @return {string} an RGB color string in the normal format using non-percentage values\n     */\n    ColorEditor.prototype._convertToNormalRGB = function (color) {\n        var matches = color.match(/^rgb.*?([0-9]+)\\%.*?([0-9]+)\\%.*?([0-9]+)\\%/i);\n        if (matches) {\n            var i, percentStr, value;\n            for (i = 0; i < 3; i++) {\n                percentStr = matches[i + 1];\n                value = Math.round(255 * Number(percentStr) / 100);\n                if (!isNaN(value)) {\n                    color = color.replace(percentStr + \"%\", value);\n                }\n            }\n        }\n        return color;\n    };\n\n    /**\n     * Normalize the given color string into the format used by tinycolor, by adding a space\n     * after commas.\n     * @param {string} color The color to be corrected if it looks like an RGB or HSL color.\n     * @return {string} a normalized color string.\n     */\n    ColorEditor.prototype._normalizeColorString = function (color) {\n        var normalizedColor = color;\n\n        // Convert 6-digit hex to 3-digit hex as TinyColor (#ffaacc -> #fac)\n        if (color.match(/^#[0-9a-fA-F]{6}/)) {\n            return tinycolor(color).toString();\n        }\n        if (color.match(/^(rgb|hsl)/i)) {\n            normalizedColor = normalizedColor.replace(/,\\s*/g, \", \");\n            normalizedColor = normalizedColor.replace(/\\(\\s+/, \"(\");\n            normalizedColor = normalizedColor.replace(/\\s+\\)/, \")\");\n        }\n        return normalizedColor;\n    };\n\n    /** Handle changes in text field */\n    ColorEditor.prototype._handleTextFieldInput = function (losingFocus) {\n        var newColor    = $.trim(this.$colorValue.val()),\n            newColorObj = checkSetFormat(newColor),\n            newColorOk  = newColorObj.isValid();\n\n\n        // TinyColor will auto correct an incomplete rgb or hsl value into a valid color value.\n        // eg. rgb(0,0,0 -> rgb(0, 0, 0)\n        // We want to avoid having TinyColor do this, because we don't want to sync the color\n        // to the UI if it's incomplete. To accomplish this, we first normalize the original\n        // color string into the format TinyColor would generate, and then compare it to what\n        // TinyColor actually generates to see if it's different. If so, then we assume the color\n        // was incomplete to begin with.\n        if (newColorOk) {\n            newColorOk = (newColorObj.toString() === this._normalizeColorString(ensureHexFormat(newColor)));\n        }\n\n        // Restore to the previous valid color if the new color is invalid or incomplete.\n        if (losingFocus && !newColorOk) {\n            newColor = this.getColor().toString();\n        }\n\n        // Sync only if we have a valid color or we're restoring the previous valid color.\n        if (losingFocus || newColorOk) {\n            this._commitColor(newColor, true);\n        }\n    };\n\n    ColorEditor.prototype._bindInputHandlers = function () {\n        var self = this;\n\n        this.$colorValue.bind(\"input\", function (event) {\n            self._handleTextFieldInput(false);\n        });\n\n        this.$colorValue.bind(\"change\", function (event) {\n            self._handleTextFieldInput(true);\n        });\n    };\n\n    /**\n     * Populate the UI with the given color swatches and add listeners so they're selectable.\n     * @param {!Array.<{value:string, count:number}>} swatches\n     */\n    ColorEditor.prototype._addSwatches = function (swatches) {\n        var self = this;\n\n        // Create swatches\n        swatches.forEach(function (swatch) {\n            var swatchValue = checkSetFormat(swatch.value, true);\n            var stringFormat = (swatch.count > 1) ? Strings.COLOR_EDITOR_USED_COLOR_TIP_PLURAL : Strings.COLOR_EDITOR_USED_COLOR_TIP_SINGULAR,\n                usedColorTip = StringUtils.format(stringFormat, swatch.value, swatch.count);\n\n            self.$swatches.append(\"<li tabindex='0'><div class='swatch-bg'><div class='swatch' style='background-color: \" +\n                    swatchValue + \";' title='\" + usedColorTip + \"'></div></div> <span class='value'\" + \" title='\" +\n                    usedColorTip + \"'>\" + swatch.value + \"</span></li>\");\n        });\n\n        // Add key & click listeners to each\n        this.$swatches.find(\"li\").keydown(function (event) {\n            if (event.keyCode === KeyEvent.DOM_VK_RETURN ||\n                    event.keyCode === KeyEvent.DOM_VK_ENTER ||\n                    event.keyCode === KeyEvent.DOM_VK_SPACE) {\n                // Enter/Space is same as clicking on swatch\n\n                self._commitColor($(event.currentTarget).find(\".value\").html());\n            } else if (event.keyCode === KeyEvent.DOM_VK_TAB) {\n                // Tab on last swatch loops back to color square\n                if (!event.shiftKey && $(this).next(\"li\").length === 0) {\n                    self.$selectionBase.focus();\n                    return false;\n                }\n            }\n        });\n\n        this.$swatches.find(\"li\").click(function (event) {\n            self._commitColor($(event.currentTarget).find(\".value\").html());\n        });\n    };\n\n    /**\n     * Checks whether colorVal is a valid color\n     * @param {!string} colorVal\n     * @return {boolean} Whether colorVal is valid\n     */\n    ColorEditor.prototype.isValidColor = function (colorVal) {\n        return tinycolor(colorVal).isValid();\n    };\n\n    /**\n     * Sets _hsv and _color based on an HSV input, and updates the UI. Attempts to preserve\n     * the previous color format.\n     * @param {!{h:number=, s:number=, v:number=}} hsv  Any missing values use the previous color's values.\n     */\n    ColorEditor.prototype.setColorAsHsv = function (hsv) {\n        var colorVal, newColor,\n            oldFormat = tinycolor(this.getColor()).getFormat();\n\n        // Set our state to the new color\n        $.extend(this._hsv, hsv);\n        newColor = tinycolor(this._hsv);\n\n        switch (oldFormat) {\n        case \"hsl\":\n            colorVal = newColor.toHslString();\n            break;\n        case \"rgb\":\n            colorVal = newColor.toRgbString();\n            break;\n        case \"prgb\":\n            colorVal = newColor.toPercentageRgbString();\n            break;\n        case \"hex\":\n        case \"name\":\n            colorVal = this._hsv.a < 1 ? newColor.toRgbString() : newColor.toHexString();\n            break;\n        case \"0x\":\n            colorVal = this._hsv.a < 1 ? as0x8String(newColor): as0xString(newColor);\n            break;\n        case \"hex8\":\n            colorVal = newColor.toHex8String();\n            break;\n        }\n        colorVal = this._isUpperCase ? colorVal.toUpperCase() : colorVal;\n        this._commitColor(colorVal, false);\n    };\n\n    /**\n     * Sets _color (and optionally _hsv) based on a string input, and updates the UI. The string's\n     * format determines the new selected color's format.\n     * @param {!string} colorVal\n     * @param {boolean=} resetHsv  Pass false ONLY if hsv set already been modified to match colorVal. Default: true.\n     */\n    ColorEditor.prototype._commitColor = function (colorVal, resetHsv) {\n\n        if (resetHsv === undefined) {\n            resetHsv = true;\n        }\n        this._callback(colorVal);\n\n        var colorObj = checkSetFormat(colorVal);\n        colorObj._originalInput = colorVal;\n        this._color = colorObj;\n\n        if (resetHsv) {\n            this._hsv = this._color.toHsv();\n        }\n\n        this._redoColor = null;  // if we had undone, this new value blows away the redo history\n        this._synchronize();\n    };\n\n    /**\n     * Sets _color and _hsv based on a string input, and updates the UI. The string's\n     * format determines the new selected color's format.\n     * @param {!string} colorVal\n     */\n    ColorEditor.prototype.setColorFromString = function (colorVal) {\n        this._commitColor(colorVal, true);  // TODO (#2204): make this less entangled with setColorAsHsv()\n    };\n\n    /** Converts a mouse coordinate to be relative to zeroPos, and clips to [0, maxOffset] */\n    function _getNewOffset(pos, zeroPos, maxOffset) {\n        var offset = pos - zeroPos;\n        offset = Math.min(maxOffset, Math.max(0, offset));\n        return offset;\n    }\n\n    /** Dragging color square's thumb */\n    ColorEditor.prototype._handleSelectionFieldDrag = function (event) {\n        var height  = this.$selection.height(),\n            width   = this.$selection.width(),\n            xOffset = _getNewOffset(event.clientX, this.$selection.offset().left, width),\n            yOffset = _getNewOffset(event.clientY, this.$selection.offset().top, height),\n            hsv     = {};\n        hsv.s = xOffset / width;\n        hsv.v = 1 - yOffset / height;\n        this.setColorAsHsv(hsv, false);\n        if (!this.$selection.find(\".selector-base\").is(\":focus\")) {\n            this.$selection.find(\".selector-base\").focus();\n        }\n    };\n\n    /** Dragging hue slider thumb */\n    ColorEditor.prototype._handleHueDrag = function (event) {\n        var height = this.$hueSlider.height(),\n            offset = _getNewOffset(event.clientY, this.$hueSlider.offset().top, height),\n            hsv    = {};\n        hsv.h = (1 - offset / height) * 360;\n        this.setColorAsHsv(hsv, false);\n        if (!this.$hueSlider.find(\".selector-base\").is(\":focus\")) {\n            this.$hueSlider.find(\".selector-base\").focus();\n        }\n    };\n\n    /** Dragging opacity slider thumb */\n    ColorEditor.prototype._handleOpacityDrag = function (event) {\n        var height = this.$opacitySlider.height(),\n            offset = _getNewOffset(event.clientY, this.$opacitySlider.offset().top, height),\n            hsv    = {};\n        hsv.a = 1 - (offset / height);\n        this.setColorAsHsv(hsv, false);\n        if (!this.$opacitySlider.find(\".selector-base\").is(\":focus\")) {\n            this.$opacitySlider.find(\".selector-base\").focus();\n        }\n    };\n\n    /**\n     * Helper for attaching drag-related mouse listeners to an element. It's up to\n     * 'handler' to actually move the element as mouse is dragged.\n     * @param {!function(jQuery.event)} handler  Called whenever drag position changes\n     */\n    ColorEditor.prototype._registerDragHandler = function ($element, handler) {\n        var mouseupHandler = function (event) {\n            $(window).unbind(\"mousemove\", handler);\n            $(window).unbind(\"mouseup\", mouseupHandler);\n        };\n        $element.mousedown(function (event) {\n            $(window).bind(\"mousemove\", handler);\n            $(window).bind(\"mouseup\", mouseupHandler);\n        });\n        $element.mousedown(handler);  // run drag-update handler on initial mousedown too\n    };\n\n    /**\n     * Handles undo gestures while color picker has focus. We don't want to let CodeMirror's\n     * usual undo logic run since it will destroy our marker.\n     */\n    ColorEditor.prototype.undo = function () {\n        if (this._originalColor.toString() !== this._color.getOriginalInput()) {\n            let originalColor = this._color.getOriginalInput();\n            this._commitColor(this._originalColor, true);\n            // commit resets this._redoColor, so we have to do this save load cycle.\n            this._redoColor = originalColor;\n        }\n    };\n\n    /** Similarly, handle redo gestures while color picker has focus. */\n    ColorEditor.prototype.redo = function () {\n        if (this._redoColor) {\n            this._commitColor(this._redoColor, true);\n            this._redoColor = null;\n        }\n    };\n\n    /**\n     * Global handler for keys in the color editor. Catches undo/redo keys and traps\n     * arrow keys that would be handled by the scroller.\n     */\n    ColorEditor.prototype._handleKeydown = function (event) {\n        var hasCtrl = (brackets.platform !== \"mac\") ? (event.ctrlKey) : (event.metaKey);\n        if (hasCtrl) {\n            switch (event.keyCode) {\n            case KeyEvent.DOM_VK_Z:\n                if (event.shiftKey) {\n                    this.redo();\n                } else {\n                    this.undo();\n                }\n                return false;\n            case KeyEvent.DOM_VK_Y:\n                this.redo();\n                return false;\n            }\n        } else {\n            if (event.keyCode === KeyEvent.DOM_VK_LEFT ||\n                    event.keyCode === KeyEvent.DOM_VK_RIGHT ||\n                    event.keyCode === KeyEvent.DOM_VK_UP ||\n                    event.keyCode === KeyEvent.DOM_VK_DOWN) {\n                // Prevent arrow keys that weren't handled by a child control\n                // from being handled by a parent, either through bubbling or\n                // through default native behavior. There isn't a good general\n                // way to tell if the target would handle this event by default,\n                // so we look to see if the target is a text input control.\n                var preventDefault = false,\n                    $target = $(event.target);\n\n                // If the input has no \"type\" attribute, it defaults to text. So we\n                // have to check for both possibilities.\n                if ($target.is(\"input:not([type])\") || $target.is(\"input[type=text]\")) {\n                    // Text input control. In WebKit, if the cursor gets to the start\n                    // or end of a text field and can't move any further, the default\n                    // action doesn't take place in the text field, so the event is handled\n                    // by the outer scroller. We have to prevent in that case too.\n                    if ($target[0].selectionStart === $target[0].selectionEnd &&\n                            ((event.keyCode === KeyEvent.DOM_VK_LEFT && $target[0].selectionStart === 0) ||\n                             (event.keyCode === KeyEvent.DOM_VK_RIGHT && $target[0].selectionEnd === $target.val().length))) {\n                        preventDefault = true;\n                    }\n                } else {\n                    // Not a text input control, so we want to prevent default.\n                    preventDefault = true;\n                }\n\n                if (preventDefault) {\n                    event.stopPropagation();\n                    return false; // equivalent to event.preventDefault()\n                }\n            }\n        }\n    };\n\n    ColorEditor.prototype._handleHslKeydown = function (event) {\n        if (event.keyCode === KeyEvent.DOM_VK_TAB) {\n            // If we're the last focusable element (no color swatches), Tab wraps around to color square\n            if (!event.shiftKey) {\n                if (this.$swatches.children().length === 0) {\n                    this.$selectionBase.focus();\n                    return false;\n                }\n            }\n        }\n    };\n\n    /** Key events on the color square's thumb */\n    ColorEditor.prototype._handleSelectionKeydown = function (event) {\n        var hsv = {},\n            step = 1.5,\n            xOffset,\n            yOffset,\n            adjustedOffset;\n\n        switch (event.keyCode) {\n        case KeyEvent.DOM_VK_LEFT:\n        case KeyEvent.DOM_VK_RIGHT:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            xOffset = Number($.trim(this.$selectionBase[0].style.left.replace(\"%\", \"\")));\n            adjustedOffset = (event.keyCode === KeyEvent.DOM_VK_LEFT) ? (xOffset - step) : (xOffset + step);\n            xOffset = Math.min(100, Math.max(0, adjustedOffset));\n            hsv.s = xOffset / 100;\n            this.setColorAsHsv(hsv, false);\n            return false;\n        case KeyEvent.DOM_VK_DOWN:\n        case KeyEvent.DOM_VK_UP:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            yOffset = Number($.trim(this.$selectionBase[0].style.bottom.replace(\"%\", \"\")));\n            adjustedOffset = (event.keyCode === KeyEvent.DOM_VK_DOWN) ? (yOffset - step) : (yOffset + step);\n            yOffset = Math.min(100, Math.max(0, adjustedOffset));\n            hsv.v = yOffset / 100;\n            this.setColorAsHsv(hsv, false);\n            return false;\n        case KeyEvent.DOM_VK_TAB:\n            // Shift+Tab loops back to last focusable element: last swatch if any; format button bar if not\n            if (event.shiftKey) {\n                if (this.$swatches.children().length === 0) {\n                    this.$hslButton.focus();\n                } else {\n                    this.$swatches.find(\"li:last\").focus();\n                }\n                return false;\n            }\n            break;\n        }\n    };\n\n    /** Key events on the hue slider thumb */\n    ColorEditor.prototype._handleHueKeydown = function (event) {\n        var hsv = {},\n            hue = Number(this._hsv.h),\n            step = 3.6;\n\n        switch (event.keyCode) {\n        case KeyEvent.DOM_VK_DOWN:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            hsv.h = (hue - step) <= 0 ? 360 - step : hue - step;\n            this.setColorAsHsv(hsv, false);\n            return false;\n        case KeyEvent.DOM_VK_UP:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            hsv.h = (hue + step) >= 360 ? step : hue + step;\n            this.setColorAsHsv(hsv, false);\n            return false;\n        }\n    };\n\n    /** Key events on the opacity slider thumb */\n    ColorEditor.prototype._handleOpacityKeydown = function (event) {\n        var alpha = this._hsv.a,\n            hsv = {},\n            step = 0.01;\n\n        switch (event.keyCode) {\n        case KeyEvent.DOM_VK_DOWN:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            if (alpha > 0) {\n                hsv.a = (alpha - step) <= 0 ? 0 : alpha - step;\n                this.setColorAsHsv(hsv);\n            }\n            return false;\n        case KeyEvent.DOM_VK_UP:\n            step = event.shiftKey ? step * STEP_MULTIPLIER : step;\n            if (alpha < 100) {\n                hsv.a = (alpha + step) >= 1 ? 1 : alpha + step;\n                this.setColorAsHsv(hsv);\n            }\n            return false;\n        }\n    };\n\n    ColorEditor.prototype._bindKeyHandler = function ($element, handler) {\n        $element.bind(\"keydown\", handler);\n    };\n\n    // Prevent clicks on some UI elements (color selection field, slider and large swatch) from taking focus\n    $(window.document).on(\"mousedown\", \".color-selection-field, .slider, .large-swatch\", function (e) {\n        e.preventDefault();\n    });\n\n    exports.ColorEditor = ColorEditor;\n});\n"],"file":"ColorEditor.js"}
{"version":3,"sources":["extensions/default/CodeFolding/unittests.js"],"names":["define","require","exports","module","SpecRunnerUtils","brackets","getModule","describe","testWindow","testEditor","EditorManager","DocumentManager","CommandManager","PreferencesManager","prefs","cm","gutterName","foldMarkerOpen","foldMarkerClosed","testDocumentDirectory","getTestPath","testFilesSpec","js","filePath","foldableLines","sameLevelFoldableLines","firstSelection","start","line","ch","end","secondSelection","html","hbs","open","folded","setPreference","key","value","set","locations","scope","async","openTestFile","path","promise","openProjectFiles","then","getCurrentFullEditor","_codeMirror","awaitsForDone","setupWindow","createTestWindowAndRun","test","getExtensionPrefs","setup","loadProjectInTestWindow","tearDown","closeTestWindow","runCommand","command","execute","foldCodeOnLine","setCursor","expandCodeOnLine","getEditorFoldMarks","marks","getAllMarks","filter","m","__isFold","gutterMarkState","lineInfo","gutterMarkers","classes","classList","contains","type","getGutterFoldMarks","eachLine","lineHandle","push","filterOpen","filterFolded","getLineNumber","toZeroIndex","lines","map","l","selectTextInEditor","setSelection","awaits","beforeAll","afterAll","closeAllFiles","Object","keys","forEach","file","testFilePath","testFileSpec","beforeEach","afterEach","it","expect","length","toBeGreaterThan","toContain","lineNumber","toEqual","lineNo","range","find","from","clear","gutterMark","lineNumbers","gutterNumbers","mark","d","not","foldableLine","expandTimeoutElapsed","replaceRange","setTimeout","awaitsFor"],"mappings":"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","sourcesContent":["/**\n * Codefolding unit test files\n * @author Patrick Oladimeji\n * @date 01/08/2015 18:34\n */\n\n/*global describe, beforeAll, beforeEach, afterEach, afterAll, it, expect, awaitsForDone, awaitsFor, awaits*/\n\ndefine(function (require, exports, module) {\n\n    var SpecRunnerUtils = brackets.getModule(\"spec/SpecRunnerUtils\");\n\n    describe(\"individualrun:Code Folding\", function () {\n        var testWindow,\n            testEditor,\n            EditorManager,\n            DocumentManager,\n            CommandManager,\n            PreferencesManager,\n            prefs,\n            cm,\n            gutterName = \"CodeMirror-foldgutter\",\n            foldMarkerOpen = gutterName + \"-open\",\n            foldMarkerClosed = gutterName + \"-folded\";\n        var testDocumentDirectory = SpecRunnerUtils.getTestPath(\"/spec/Extension-test-project-files\"),\n            // The line numbers referenced below are dependent on the files in /unittest-files directory.\n            // Remember to update the numbers if the files change.\n            testFilesSpec = {\n                js: {\n                    filePath: \"test.js\",\n                    foldableLines: [1, 11, 17, 21, 25, 27, 30],\n                    sameLevelFoldableLines: [17, 21],\n                    firstSelection: {start: {line: 2, ch: 0}, end: {line: 10, ch: 0}},\n                    secondSelection: {start: {line: 5, ch: 0}, end: {line: 8, ch: 4}}\n                },\n                html: {\n                    filePath: \"test.html\",\n                    foldableLines: [1, 2, 3, 4, 8, 9, 14, 15, 16, 20, 21, 22, 23, 28, 29, 34, 37],\n                    sameLevelFoldableLines: [3, 8],\n                    firstSelection: {start: {line: 38, ch: 0}, end: {line: 41, ch: 0}},\n                    secondSelection: {start: {line: 42, ch: 0}, end: {line: 45, ch: 4}}\n                },\n                hbs: {\n                    filePath: \"test.hbs\",\n                    foldableLines: [1, 7, 14, 16, 17, 21, 26, 28, 29, 32, 33, 38, 41],\n                    sameLevelFoldableLines: [1, 7, 14],\n                    firstSelection: {start: {line: 2, ch: 0}, end: {line: 10, ch: 0}},\n                    secondSelection: {start: {line: 5, ch: 0}, end: {line: 8, ch: 4}}\n                }\n            },\n            open = \"open\",\n            folded = \"folded\";\n\n        /**\n         * Utility to temporarily set preference values in the session scope\n         */\n        function setPreference(key, value) {\n            prefs.set(key, value, {\n                locations: {\n                    scope: \"session\"\n                }\n            });\n        }\n\n        /**\n         * Open a test file\n         * @param {String} path The path to the file to open\n         */\n        async function openTestFile(path) {\n            var promise = SpecRunnerUtils.openProjectFiles([path]);\n            promise.then(function () {\n                testEditor = EditorManager.getCurrentFullEditor();\n                cm = testEditor._codeMirror;\n            });\n            await awaitsForDone(promise, \"Test file opened\", 3000);\n        }\n\n        /**\n         * Sets up the test window and loads the test project\n         */\n        async function setupWindow() {\n            testWindow = await SpecRunnerUtils.createTestWindowAndRun();\n            EditorManager = testWindow.brackets.test.EditorManager;\n            DocumentManager = testWindow.brackets.test.DocumentManager;\n            PreferencesManager = testWindow.brackets.test.PreferencesManager;\n            CommandManager = testWindow.brackets.test.CommandManager;\n\n            prefs = PreferencesManager.getExtensionPrefs(\"code-folding\");\n        }\n\n        /**\n         * Sets up the test window and loads the test project\n         */\n        async function setup() {\n            //setPreference(\"saveFoldStates\", false);\n            await SpecRunnerUtils.loadProjectInTestWindow(testDocumentDirectory);\n        }\n\n        /**\n         * Closes the test window\n         */\n        async function tearDown() {\n            await SpecRunnerUtils.closeTestWindow();\n        }\n\n        /**\n         * Runs the specified command\n         * @param   {String}  command The command to run\n         * @returns {Promise} A promise that resolves after command execution is completed or failed\n         */\n        function runCommand(command) {\n            return CommandManager.execute(command);\n        }\n\n        /**\n         * Folds the code on the given line number\n         * @param {Number} line The line number to fold\n         */\n        async function foldCodeOnLine(line) {\n            cm.setCursor(line - 1);\n            var promise = runCommand(\"codefolding.collapse\");\n            await awaitsForDone(promise, \"Collapse code\", 2000);\n        }\n\n        /**\n         * Expands the code on the given line number\n         * @param {Number} line The line number to fold\n         */\n        async function expandCodeOnLine(line) {\n            cm.setCursor(line - 1);\n            var promise = runCommand(\"codefolding.expand\");\n            await awaitsForDone(promise, \"Expand code\", 2000);\n        }\n\n        /**\n         * Returns all the fold marks currently inside the editor\n         * @returns {Array<TextMark>} The fold marks currently inside the editor\n         */\n        function getEditorFoldMarks() {\n            testEditor = EditorManager.getCurrentFullEditor();\n            cm = testEditor._codeMirror;\n\n            var marks = cm.getAllMarks().filter(function (m) {\n                return m.__isFold;\n            });\n            return marks;\n        }\n\n        /**\n         * Gets information about the mark in the gutter specifically whether it is folded or open.\n         * @param   {Object} lineInfo The CodeMirror lineInfo object\n         * @returns {Object} an object with line and type property\n         */\n        function gutterMarkState(lineInfo) {\n            if (!lineInfo || !lineInfo.gutterMarkers) {\n                return;\n            }\n            var classes = lineInfo.gutterMarkers[gutterName].classList;\n            if (classes && classes.contains(foldMarkerClosed)) {\n                return {line: lineInfo.line, type: folded};\n            } else if (classes && classes.contains(foldMarkerOpen)) {\n                return {line: lineInfo.line, type: open};\n            }\n            return;\n        }\n\n        /**\n         * Helper function to return the fold markers on the current codeMirror instance\n         *\n         * @returns {Array<object>} An array of objects containing the line and the type of marker.\n         */\n        function getGutterFoldMarks() {\n            testEditor = EditorManager.getCurrentFullEditor();\n            cm = testEditor._codeMirror;\n            var marks = [];\n            cm.eachLine(function (lineHandle) {\n                var lineInfo = cm.lineInfo(lineHandle);\n                marks.push(gutterMarkState(lineInfo));\n            });\n\n            return marks.filter(function (m) { return m; });\n        }\n\n        /**\n         * Helper function to filter out all open gutter markers\n         * @param   {Object}  m the marker to filter\n         * @returns {boolean} true if the marker is open or false otherwise\n         */\n        function filterOpen(m) {\n            return m.type === open;\n        }\n\n        /**\n         * Helper function to filter out all closed gutter markers.\n         * @param   {Object}  m the marker to to filter\n         * @returns {boolean} true if the marker is closed or false otherwise\n         */\n        function filterFolded(m) {\n            return m.type === folded;\n        }\n\n        /*\n         * Helper function to return the line number on a marker\n         * @param   {Object} m the maker whose line number we want to retrieve\n         * @returns {Number} the line number of the marker\n         */\n        function getLineNumber(m) {\n            return m.line;\n        }\n\n        /**\n         * Helper function to change the lines to zero-based index\n         * @param   {Array<number>} lines the line numbers to change to zero base index\n         * @returns {Array<number>} the zero-based index of the lines passed in\n         */\n        function toZeroIndex(lines) {\n            return lines.map(function (l) {\n                return l - 1;\n            });\n        }\n\n        /**\n         * Helper function to select a range of text in the editor\n         * @param   {CodeMirror.Pos} start the start position of the selection\n         * @param   {CodeMirror.Pos} end   the end position of the selection\n         */\n        async function selectTextInEditor(start, end) {\n            cm.setSelection(start, end);\n            //wait for foldmarks to be rendered\n            await awaits(500);\n        }\n\n        beforeAll(async function () {\n            await setupWindow();\n            await setup();\n        }, 30000);\n\n        afterAll(async function () {\n            await testWindow.closeAllFiles();\n            await tearDown();\n        });\n\n        Object.keys(testFilesSpec).forEach(function (file) {\n            var testFilePath = testFilesSpec[file].filePath;\n            var foldableLines = testFilesSpec[file].foldableLines;\n            var testFileSpec = testFilesSpec[file];\n            describe(file + \" - Editor/Gutter\", function () {\n                beforeEach(async function () {\n                    await setupWindow();\n                    await setup();\n\n                    await openTestFile(testFilePath);\n\n                    testEditor = EditorManager.getCurrentFullEditor();\n                    cm = testEditor._codeMirror;\n                });\n\n                afterEach(async function () {\n                    await testWindow.closeAllFiles();\n                });\n\n                it(\"renders fold marks on startup\", async function () {\n                    var marks = getGutterFoldMarks();\n                    expect(marks.length).toBeGreaterThan(0);\n                    marks.map(getLineNumber).forEach(function (line) {\n                        expect(toZeroIndex(foldableLines)).toContain(line);\n                    });\n                });\n\n                it(\"creates a folded region in editor when fold marker is clicked\", async function () {\n                    var lineNumber = foldableLines[0];\n                    await foldCodeOnLine(lineNumber);\n\n                    var marks = getEditorFoldMarks();\n                    expect(marks.length).toEqual(1);\n                    expect(marks[0].lines[0].lineNo()).toEqual(lineNumber - 1);\n                });\n\n                it(\"clears the folded region in editor when collapsed fold marker is clicked\", async function () {\n                    var lineNumber = foldableLines[0];\n                    await foldCodeOnLine(lineNumber);\n                    await expandCodeOnLine(lineNumber);\n\n                    var marks = getEditorFoldMarks();\n                    expect(marks.length).toEqual(0);\n                });\n\n                it(\"expands and updates the fold gutter when text marker for a folded region in editor is cleared\", async function () {\n                    var lineNumber = foldableLines[0];\n                    await foldCodeOnLine(lineNumber);\n                    var marks = getEditorFoldMarks().filter(function (m) {\n                        var range = m.find();\n                        return range ? range.from.line === lineNumber - 1 : false;\n                    });\n                    marks[0].clear();\n\n                    var marks = getEditorFoldMarks();\n                    var gutterMark = getGutterFoldMarks().filter(function (m) {\n                        return m.line === lineNumber - 1 && m.type === open;\n                    });\n                    expect(marks.length).toEqual(0);\n                    expect(gutterMark.length).toEqual(1);\n                });\n\n                it(\"renders folded marker in the gutter for folded code regions\", async function () {\n                    var lineNumbers = testFilesSpec[file].sameLevelFoldableLines;\n                    for(let l of lineNumbers){\n                        await foldCodeOnLine(l);\n                    }\n\n                    var marks = getGutterFoldMarks().filter(filterFolded);\n                    expect(marks.length).toEqual(lineNumbers.length);\n\n                    var gutterNumbers = marks\n                        .map(getLineNumber);\n                    expect(gutterNumbers).toEqual(toZeroIndex(lineNumbers));\n                });\n\n                it(\"indicates foldable lines in the gutter\", async function () {\n                    var lineNumbers = foldableLines;\n                    var marks = getGutterFoldMarks();\n                    var gutterNumbers = marks.filter(filterOpen)\n                        .map(getLineNumber);\n                    expect(gutterNumbers).toEqual(toZeroIndex(lineNumbers));\n                });\n\n                describe(\"Preferences\", function () {\n                    it(\"persists fold states\", async function () {\n                        var lineNumbers = testFileSpec.sameLevelFoldableLines;\n                        for(let line of lineNumbers){\n                            await foldCodeOnLine(line);\n                        }\n                        await testWindow.closeAllFiles();\n\n                        await openTestFile(testFilePath);\n\n                        var marks = getEditorFoldMarks();\n                        var gutterNumbers = marks.map(function (mark) {\n                            return mark.lines[0].lineNo();\n                        });\n                        expect(gutterNumbers).toEqual(toZeroIndex(lineNumbers));\n                    });\n\n                    it(\"can disable persistence of fold states\", async function () {\n                        await setPreference(\"saveFoldStates\", false);\n                        await foldCodeOnLine(foldableLines[0]);\n                        await testWindow.closeAllFiles();\n\n                        await openTestFile(testFilePath);\n\n                        var marks = getEditorFoldMarks();\n                        expect(marks.length).toEqual(0);\n\n                        var lineNumbers = foldableLines;\n                        var marks = getGutterFoldMarks();\n                        var gutterNumbers = marks.filter(filterOpen)\n                            .map(getLineNumber);\n                        expect(gutterNumbers).toEqual(toZeroIndex(lineNumbers));\n                    });\n\n                    it(\"can set the minimum fold size\", async function () {\n                        await setPreference(\"minFoldSize\", 20000);\n                        await testWindow.closeAllFiles();\n\n                        await openTestFile(testFilePath);\n\n                        var marks = getGutterFoldMarks();\n                        expect(marks.length).toEqual(0);\n                    });\n\n                    it(\"can disable code folding\", async function () {\n                        setPreference(\"enabled\", false);\n                        var marks = getEditorFoldMarks();\n                        expect(marks.length).toEqual(0);\n                    });\n\n                    describe(\"Fold selected region\", function () {\n                        it(\"can be enabled by setting `makeSelectionsFoldable' to true\", async function () {\n                            var start = testFileSpec.firstSelection.start, end = testFileSpec.firstSelection.end;\n                            setPreference(\"makeSelectionsFoldable\", true);\n\n                            await selectTextInEditor(start, end);\n\n                            var marks = getGutterFoldMarks().filter(filterOpen).map(getLineNumber);\n                            expect(marks).toContain(start.line);\n                        });\n\n                        it(\"can be disabled by setting `makeSelectionsFoldable' to false\", async function () {\n                            await setPreference(\"makeSelectionsFoldable\", false);\n                            var start = testFileSpec.firstSelection.start, end = testFileSpec.firstSelection.end;\n                            await selectTextInEditor(start, end);\n\n                            var marks = getGutterFoldMarks().filter(filterOpen)\n                                .map(getLineNumber).filter(function (d) {\n                                    return d === start.line;\n                                });\n                            expect(marks.length).toEqual(0);\n                        });\n\n                        it(\"shows fold ranges for only the most recent selection\", async function () {\n                            var firstSelection = testFileSpec.firstSelection,\n                                secondSelection = testFileSpec.secondSelection;\n\n                            await selectTextInEditor(firstSelection.start, firstSelection.end);\n\n                            await selectTextInEditor(secondSelection.start, secondSelection.end);\n\n                            var marks = getGutterFoldMarks().filter(filterOpen)\n                                .map(getLineNumber);\n                            expect(marks).toContain(secondSelection.start.line);\n                            expect(marks).not.toContain(firstSelection.start.line);\n                        });\n                    });\n\n                });\n\n                describe(\"Editor text changes\", function () {\n                    var foldableLine = foldableLines[1],\n                        expandTimeoutElapsed = false;\n\n                    // add a line after folding a region preserves the region and the region can be unfolded\n                    it(\"can unfold a folded region after a line has been added above it\", async function () {\n                        await foldCodeOnLine(foldableLine);\n                        cm.replaceRange(\"\\r\\n\", {line: foldableLine - 1, ch: 0});\n\n                        await expandCodeOnLine(foldableLine + 1);\n                        setTimeout(function () {\n                            expandTimeoutElapsed = true;\n                        }, 400);\n\n                        await awaitsFor(function () {\n                            return expandTimeoutElapsed;\n                        }, \"waiting a moment for gutter markerts to be re-rendered\", 500);\n\n                        var marks = getGutterFoldMarks().filter(filterFolded);\n                        expect(marks.length).toEqual(0);\n\n                    });\n\n                    it(\"can unfold a folded region even after a line has been removed above it\", async function () {\n                        await foldCodeOnLine(foldableLine);\n                        cm.replaceRange(\"\", {line: foldableLine - 1, ch: 0}, {line: foldableLine, ch: 0});\n\n                        await expandCodeOnLine(foldableLine - 1);\n                        setTimeout(function () {\n                            expandTimeoutElapsed = true;\n                        }, 400);\n\n                        await awaitsFor(function () {\n                            return expandTimeoutElapsed;\n                        }, \"waiting a moment for gutter markerts to be re-rendered\", 500);\n\n                        var marks = getGutterFoldMarks().filter(filterFolded);\n                        expect(marks.length).toEqual(0);\n                    });\n                });\n            });\n        });\n    });\n});\n"],"file":"unittests.js"}
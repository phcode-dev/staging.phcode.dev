{"version":3,"sources":["extensions/default/JavaScriptQuickEdit/unittests.js"],"names":["define","require","exports","module","CommandManager","EditorManager","PerfUtils","JSUtils","Commands","SpecRunnerUtils","brackets","getModule","Strings","UnitTestReporter","extensionPath","getTestPath","testPath","tempPath","getTempDirectory","testWindow","initInlineTest","rewriteProject","spec","result","$","Deferred","infos","options","parseOffsets","removePrefix","copyPath","done","resolve","fail","reject","promise","fixPos","pos","sticky","_initInlineTest","async","openFile","openOffset","expectInline","filesToOpen","this","undefined","awaitsForDone","loadProjectInTestWindow","push","openProjectFiles","toggleQuickEditAtOffset","getCurrentFullEditor","offsets","describe","beforeEach","bind","createTestWindowAndRun","test","afterEach","closeTestWindow","it","editor","extensionRequire","jsQuickEditMain","tokensFile","getRequireContextForExtension","javaScriptFunctionProvider","expect","toBe","ERROR_JSQUICKEDIT_FUNCTIONNOTFOUND","inlineWidget","inlinePos","getInlineWidgets","getCursorPos","toEql","JSCodeHints","ParameterHintProvider","expectHints","provider","key","hasHints","getActiveEditor","getHints","_waitForHints","hintObj","callback","complete","hintList","hasOwnProperty","hints","obj","awaitsFor","hintsPresentExact","expectedHints","toBeTruthy","length","forEach","expectedHint","index","data","value","expectParameterHint","expectedParams","expectedParameter","requestHints","request","expectHint","hint","params","parameters","n","i","currentIndex","name","type","isOptional","toBeFalsy","_getParameterHint","awaitsForFail","_waitForJump","oldLocation","cursor","activeEditor","line","ch","editorJumped","jsCodeHints","testEditor","expectedLocation","handleJumpToDefinition","newCursor","file","document","initJSCodeHints","_phProvider","start","testPos","openQuickEditor","setCursorPos","awaits","testJumpPos","jumpPos","jsHintProvider","perfMeasurements","measure","JAVASCRIPT_INLINE_CREATE","children","JAVASCRIPT_FIND_FUNCTION","JSUTILS_GET_ALL_FUNCTIONS","DOCUMENT_MANAGER_GET_DOCUMENT_FOR_PATH","operation","JSUTILS_REGEXP","JSUTILS_END_OFFSET","runCreateInlineEditor","execute","TOGGLE_QUICK_EDIT","logPerf","reporter","getActiveReporter","logTestWindow","clearTestWindow"],"mappings":"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","sourcesContent":["/*\n * GNU AGPL-3.0 License\n *\n * Copyright (c) 2021 - present core.ai . All rights reserved.\n * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.\n *\n * This program is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see https://opensource.org/licenses/AGPL-3.0.\n *\n */\n\n/*global describe, it, expect, beforeEach, afterEach, awaitsFor, awaitsForDone, awaitsForFail, awaits */\n\ndefine(function (require, exports, module) {\n\n\n    var CommandManager,         // loaded from brackets.test\n        EditorManager,          // loaded from brackets.test\n        PerfUtils,              // loaded from brackets.test\n        JSUtils,                // loaded from brackets.test\n        Commands,\n        SpecRunnerUtils     = brackets.getModule(\"spec/SpecRunnerUtils\"),\n        Strings             = brackets.getModule(\"strings\"),\n        UnitTestReporter    = brackets.getModule(\"test/UnitTestReporter\");\n\n    var extensionPath = SpecRunnerUtils.getTestPath(\"/spec/Extension-test-project-files/\"),\n        testPath = extensionPath + \"/js-quickedit-unittest-files/syntax\",\n        tempPath = SpecRunnerUtils.getTempDirectory(),\n        testWindow,\n        initInlineTest;\n\n    function rewriteProject(spec) {\n        var result = new $.Deferred(),\n            infos = {},\n            options = {\n                parseOffsets: true,\n                infos: infos,\n                removePrefix: true\n            };\n\n        SpecRunnerUtils.copyPath(testPath, tempPath, options).done(function () {\n            spec.infos = infos;\n            result.resolve();\n        }).fail(function () {\n            result.reject();\n        });\n\n        return result.promise();\n    }\n\n    // Helper function for testing cursor position\n    function fixPos(pos) {\n        if (!(\"sticky\" in pos)) {\n            pos.sticky = null;\n        }\n        return pos;\n    }\n\n    /**\n     * Performs setup for an inline editor test. Parses offsets (saved to Spec.offsets) for all files in\n     * the test project (testPath) and saves files back to disk without offset markup.\n     * When finished, open an editor for the specified project relative file path\n     * then attempts opens an inline editor at the given offset. Installs an after()\n     * function restore all file content back to original state with offset markup.\n     *\n     * @param {!string} openFile Project relative file path to open in a main editor.\n     * @param {!number} openOffset The offset index location within openFile to open an inline editor.\n     * @param {?boolean} expectInline Use false to verify that an inline editor should not be opened. Omit otherwise.\n     */\n    var _initInlineTest = async function (openFile, openOffset, expectInline, filesToOpen) {\n        var spec = this;\n\n        filesToOpen = filesToOpen || [];\n        expectInline = (expectInline !== undefined) ? expectInline : true;\n\n        await awaitsForDone(rewriteProject(spec), \"rewriteProject\");\n\n        await SpecRunnerUtils.loadProjectInTestWindow(tempPath);\n\n        filesToOpen.push(openFile);\n        await awaitsForDone(SpecRunnerUtils.openProjectFiles(filesToOpen), \"openProjectFiles\");\n\n        if (openOffset !== undefined) {\n            // open inline editor at specified offset index\n            await awaitsForDone(SpecRunnerUtils.toggleQuickEditAtOffset(\n                EditorManager.getCurrentFullEditor(),\n                spec.infos[openFile].offsets[openOffset]\n            ), \"toggleQuickEditAtOffset\");\n        }\n    };\n\n    describe(\"extension:JSQuickEdit\", function () {\n\n        /*\n         *\n         */\n        describe(\"javaScriptFunctionProvider\", function () {\n\n            beforeEach(async function () {\n                initInlineTest = _initInlineTest.bind(this);\n                testWindow  = await SpecRunnerUtils.createTestWindowAndRun();\n                EditorManager       = testWindow.brackets.test.EditorManager;\n                CommandManager      = testWindow.brackets.test.CommandManager;\n                JSUtils             = testWindow.brackets.test.JSUtils;\n            }, 30000);\n\n            afterEach(async function () {\n                // revert files to original content with offset markup\n                initInlineTest      = null;\n                testWindow          = null;\n                EditorManager       = null;\n                CommandManager      = null;\n                JSUtils             = null;\n                await SpecRunnerUtils.closeTestWindow();\n            });\n\n            it(\"should ignore tokens that are not function calls or references\", async function () {\n                var editor,\n                    extensionRequire,\n                    jsQuickEditMain,\n                    tokensFile = \"tokens.js\",\n                    promise,\n                    offsets;\n\n                await initInlineTest(tokensFile);\n\n                extensionRequire = testWindow.brackets.getModule(\"utils/ExtensionLoader\").getRequireContextForExtension(\"JavaScriptQuickEdit\");\n                jsQuickEditMain = extensionRequire(\"main\");\n                editor = EditorManager.getCurrentFullEditor();\n                offsets = this.infos[tokensFile];\n\n                // regexp token\n                promise = jsQuickEditMain.javaScriptFunctionProvider(editor, offsets[0]);\n                expect(promise).toBe(Strings.ERROR_JSQUICKEDIT_FUNCTIONNOTFOUND);\n\n                // multi-line comment\n                promise = jsQuickEditMain.javaScriptFunctionProvider(editor, offsets[1]);\n                expect(promise).toBe(Strings.ERROR_JSQUICKEDIT_FUNCTIONNOTFOUND);\n\n                // single-line comment\n                promise = jsQuickEditMain.javaScriptFunctionProvider(editor, offsets[2]);\n                expect(promise).toBe(Strings.ERROR_JSQUICKEDIT_FUNCTIONNOTFOUND);\n\n                // string, double quotes\n                promise = jsQuickEditMain.javaScriptFunctionProvider(editor, offsets[3]);\n                expect(promise).toBe(Strings.ERROR_JSQUICKEDIT_FUNCTIONNOTFOUND);\n\n                // string, single quotes\n                promise = jsQuickEditMain.javaScriptFunctionProvider(editor, offsets[4]);\n                expect(promise).toBe(Strings.ERROR_JSQUICKEDIT_FUNCTIONNOTFOUND);\n            });\n\n            it(\"should open a function with  form: function functionName()\", async function () {\n                await initInlineTest(\"test1main.js\", 0);\n\n                var inlineWidget = EditorManager.getCurrentFullEditor().getInlineWidgets()[0];\n                var inlinePos = inlineWidget.editor.getCursorPos();\n\n                // verify cursor position in inline editor\n                expect(fixPos(inlinePos)).toEql(fixPos(this.infos[\"test1inline.js\"].offsets[0]));\n            });\n\n            it(\"should open a function with  form: functionName = function()\", async function () {\n                await initInlineTest(\"test1main.js\", 1);\n\n                var inlineWidget = EditorManager.getCurrentFullEditor().getInlineWidgets()[0];\n                var inlinePos = inlineWidget.editor.getCursorPos();\n\n                // verify cursor position in inline editor\n                expect(fixPos(inlinePos)).toEql(fixPos(this.infos[\"test1inline.js\"].offsets[1]));\n            });\n\n            it(\"should open a function with  form: functionName: function()\", async function () {\n                await initInlineTest(\"test1main.js\", 2);\n\n                var inlineWidget = EditorManager.getCurrentFullEditor().getInlineWidgets()[0];\n                var inlinePos = inlineWidget.editor.getCursorPos();\n\n                // verify cursor position in inline editor\n                expect(fixPos(inlinePos)).toEql(fixPos(this.infos[\"test1inline.js\"].offsets[2]));\n            });\n\n            describe(\"Code hints tests within quick edit window \", function () {\n                var JSCodeHints,\n                    ParameterHintProvider;\n\n                /*\n                 * Ask provider for hints at current cursor position; expect it to\n                 * return some\n                 *\n                 * @param {Object} provider - a CodeHintProvider object\n                 * @param {string} key - the charCode of a key press that triggers the\n                 *      CodeHint provider\n                 * @return {boolean} - whether the provider has hints in the context of\n                 *      the test editor\n                 */\n                function expectHints(provider, key) {\n                    if (key === undefined) {\n                        key = null;\n                    }\n\n                    expect(provider.hasHints(EditorManager.getActiveEditor(), key)).toBe(true);\n                    return provider.getHints(null);\n                }\n\n                /*\n                 * Wait for a hint response object to resolve, then apply a callback\n                 * to the result\n                 *\n                 * @param {Object + jQuery.Deferred} hintObj - a hint response object,\n                 *      possibly deferred\n                 * @param {Function} callback - the callback to apply to the resolved\n                 *      hint response object\n                 */\n                async function _waitForHints(hintObj, callback) {\n                    var complete = false,\n                        hintList = null;\n\n                    if (hintObj.hasOwnProperty(\"hints\")) {\n                        complete = true;\n                        hintList = hintObj.hints;\n                    } else {\n                        hintObj.done(function (obj) {\n                            complete = true;\n                            hintList = obj.hints;\n                        });\n                    }\n\n                    await awaitsFor(function () {\n                        return complete;\n                    }, \"Expected hints did not resolve\", 3000);\n\n                    callback(hintList);\n                }\n\n                /*\n                 * Expect a given list of hints to be present in a given hint\n                 * response object, and no more.\n                 *\n                 * @param {Object + jQuery.Deferred} hintObj - a hint response object,\n                 *      possibly deferred\n                 * @param {Array.<string>} expectedHints - a list of hints that should be\n                 *      present in the hint response, and no more.\n                 */\n                async function hintsPresentExact(hintObj, expectedHints) {\n                    await _waitForHints(hintObj, function (hintList) {\n                        expect(hintList).toBeTruthy();\n                        expect(hintList.length).toBe(expectedHints.length);\n                        expectedHints.forEach(function (expectedHint, index) {\n                            expect(hintList[index].data(\"token\").value).toBe(expectedHint);\n                        });\n                    });\n                }\n\n                /**\n                 * Show a function hint based on the code at the cursor. Verify the\n                 * hint matches the passed in value.\n                 *\n                 * @param {Array<{name: string, type: string, isOptional: boolean}>}\n                 * expectedParams - array of records, where each element of the array\n                 * describes a function parameter. If null, then no hint is expected.\n                 * @param {number} expectedParameter - the parameter at cursor.\n                 */\n                async function expectParameterHint(expectedParams, expectedParameter) {\n                    var requestHints = undefined,\n                        request = null;\n\n                    function expectHint(hint) {\n                        var params = hint.parameters,\n                            n = params.length,\n                            i;\n\n                        // compare params to expected params\n                        expect(params.length).toBe(expectedParams.length);\n                        expect(hint.currentIndex).toBe(expectedParameter);\n\n                        for (i = 0; i < n; i++) {\n\n                            expect(params[i].name).toBe(expectedParams[i].name);\n                            expect(params[i].type).toBe(expectedParams[i].type);\n                            if (params[i].isOptional) {\n                                expect(expectedParams[i].isOptional).toBeTruthy();\n                            } else {\n                                expect(expectedParams[i].isOptional).toBeFalsy();\n                            }\n                        }\n\n                    }\n\n                    request = ParameterHintProvider._getParameterHint();\n\n                    if (expectedParams === null) {\n                        request.fail(function (result) {\n                            requestHints = result;\n                        });\n\n                        await awaitsForFail(request, \"ParameterHints\");\n                    } else {\n                        request.done(function (result) {\n                            requestHints = result;\n                        });\n\n                        await awaitsForDone(request, \"ParameterHints\");\n                    }\n\n                    if (expectedParams === null) {\n                        expect(requestHints).toBe(null);\n                    } else {\n                        expectHint(requestHints);\n                    }\n                }\n\n                /**\n                 * Wait for the editor to change positions, such as after a jump to\n                 * definition has been triggered.  Will timeout after 3 seconds\n                 *\n                 * @param {{line:number, ch:number}} oldLocation - the original line/col\n                 * @param {Function} callback - the callback to apply once the editor has changed position\n                 */\n                async function _waitForJump(oldLocation, callback) {\n                    var cursor = null;\n                    await awaitsFor(function () {\n                        var activeEditor = EditorManager.getActiveEditor();\n                        cursor = activeEditor.getCursorPos();\n                        return (cursor.line !== oldLocation.line) ||\n                            (cursor.ch !== oldLocation.ch);\n                    }, \"Expected jump did not occur\", 3000);\n\n                    callback(cursor);\n                }\n\n                /**\n                 * Trigger a jump to definition, and verify that the editor jumped to\n                 * the expected location.\n                 *\n                 * @param {{line:number, ch:number, file:string}} expectedLocation - the\n                 *  line, column, and optionally the new file the editor should jump to.  If the\n                 *  editor is expected to stay in the same file, then file may be omitted.\n                 */\n                async function editorJumped(jsCodeHints, testEditor, expectedLocation) {\n                    var oldLocation = testEditor.getCursorPos();\n\n                    jsCodeHints.handleJumpToDefinition();\n\n\n                    await _waitForJump(oldLocation, function (newCursor) {\n                        expect(newCursor.line).toBe(expectedLocation.line);\n                        expect(newCursor.ch).toBe(expectedLocation.ch);\n                        if (expectedLocation.file) {\n                            var activeEditor = EditorManager.getActiveEditor();\n                            expect(activeEditor.document.file.name).toBe(expectedLocation.file);\n                        }\n                    });\n                }\n\n                function initJSCodeHints() {\n                    let extensionRequire = testWindow.brackets.getModule(\"utils/ExtensionLoader\")\n                        .getRequireContextForExtension(\"JavaScriptCodeHints\");\n                    JSCodeHints = extensionRequire(\"main\");\n                    ParameterHintProvider = JSCodeHints._phProvider;\n                }\n\n                beforeEach(async function () {\n                    await initInlineTest(\"test.html\");\n                    initJSCodeHints();\n                });\n\n                afterEach(function () {\n                    JSCodeHints = null;\n                    ParameterHintProvider = null;\n                });\n\n                it(\"should see code hint lists in quick editor\", async function () {\n                    var start        = {line: 13, ch: 11 },\n                        testPos      = {line: 5, ch: 29},\n                        testEditor;\n\n                    var openQuickEditor = SpecRunnerUtils.toggleQuickEditAtOffset(EditorManager.getCurrentFullEditor(), start);\n                    await awaitsForDone(openQuickEditor, \"Open quick editor\");\n\n                    testEditor = EditorManager.getActiveEditor();\n                    testEditor.setCursorPos(testPos);\n                    await awaits(1000); // wait for tern init\n                    await expectParameterHint([{name: \"mo\", type: \"Number\"}], 0);\n                });\n\n                it(\"should see jump to definition on variable working in quick editor\", async function () {\n                    var start        = {line: 13, ch: 10 },\n                        testPos      = {line: 6, ch: 7},\n                        testJumpPos  = {line: 6, ch: 5},\n                        jumpPos      = {line: 3, ch: 6},\n                        testEditor;\n\n                    var openQuickEditor = SpecRunnerUtils.toggleQuickEditAtOffset(EditorManager.getCurrentFullEditor(), start);\n                    await awaitsForDone(openQuickEditor, \"Open quick editor\");\n\n                    testEditor = EditorManager.getActiveEditor();\n                    testEditor.setCursorPos(testPos);\n                    var hintObj = expectHints(JSCodeHints.jsHintProvider);\n                    await hintsPresentExact(hintObj, [\"propA\"]);\n\n                    testEditor = EditorManager.getActiveEditor();\n                    testEditor.setCursorPos(testJumpPos);\n                    await editorJumped(JSCodeHints, testEditor, jumpPos);\n                });\n            });\n        });\n    });\n\n    describe(\"performance:JS Quick Edit Extension\", function () {\n\n        var testPath = extensionPath + \"/js-quickedit-unittest-files/jquery-ui\";\n\n        beforeEach(async function () {\n            testWindow = await SpecRunnerUtils.createTestWindowAndRun();\n            CommandManager      = testWindow.brackets.test.CommandManager;\n            Commands                = testWindow.brackets.test.Commands;\n            EditorManager       = testWindow.brackets.test.EditorManager;\n            PerfUtils           = testWindow.brackets.test.PerfUtils;\n        }, 30000);\n\n        afterEach(async function () {\n            testWindow      = null;\n            CommandManager  = null;\n            EditorManager   = null;\n            PerfUtils       = null;\n            await SpecRunnerUtils.closeTestWindow();\n        });\n\n        it(\"should open inline editors\", async function () {\n            await SpecRunnerUtils.loadProjectInTestWindow(testPath);\n\n            var i,\n                perfMeasurements;\n\n            perfMeasurements = [\n                {\n                    measure: PerfUtils.JAVASCRIPT_INLINE_CREATE,\n                    children: [\n                        {\n                            measure: PerfUtils.JAVASCRIPT_FIND_FUNCTION,\n                            children: [\n                                {\n                                    measure: PerfUtils.JSUTILS_GET_ALL_FUNCTIONS,\n                                    children: [\n                                        {\n                                            measure: PerfUtils.DOCUMENT_MANAGER_GET_DOCUMENT_FOR_PATH,\n                                            name: \"Document creation during this search\",\n                                            operation: \"sum\"\n                                        },\n                                        {\n                                            measure: PerfUtils.JSUTILS_REGEXP,\n                                            operation: \"sum\"\n                                        }\n                                    ]\n                                },\n                                {\n                                    measure: PerfUtils.JSUTILS_END_OFFSET,\n                                    operation: \"sum\"\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ];\n\n            await awaitsForDone(SpecRunnerUtils.openProjectFiles([\"ui/jquery.effects.core.js\"]), \"openProjectFiles\");\n\n            var runCreateInlineEditor = async function () {\n                var editor = EditorManager.getCurrentFullEditor();\n                // Set the cursor in the middle of a call to \"extend\" so the JS helper function works correctly.\n                editor.setCursorPos(271, 20);\n                await awaitsForDone(\n                    CommandManager.execute(Commands.TOGGLE_QUICK_EDIT),\n                    \"createInlineEditor\",\n                    5000\n                );\n            };\n\n            function logPerf() {\n                var reporter = UnitTestReporter.getActiveReporter();\n                reporter.logTestWindow(perfMeasurements);\n                reporter.clearTestWindow();\n            }\n\n            await awaits(5000);\n            // repeat 5 times\n            for (i = 0; i < 5; i++) {\n                await runCreateInlineEditor();\n                logPerf();\n            }\n        }, 30000);\n    });\n});\n"],"file":"unittests.js"}